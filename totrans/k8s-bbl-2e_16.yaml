- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Launching a Kubernetes Cluster on Amazon Web Services with Amazon Elastic Kubernetes
    Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s build on what we learned in the previous chapter. We launched a Kubernetes
    cluster in a public cloud, taking our first steps to run Kubernetes on one of
    the “big three” public cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what the **Google Cloud Platform** (**GCP**) Kubernetes offering
    looks like, we will move on to **Amazon Elastic Kubernetes Service** (**EKS**)
    by **Amazon Web Services** (**AWS**).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to set up an AWS account and install the
    supporting toolsets on macOS, Windows, and Linux, before finally launching and
    interacting with an Amazon EKS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are Amazon Web Services and Amazon Elastic Kubernetes Service?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing your local environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching your Amazon Elastic Kubernetes Service cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a workload and interacting with your cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting your Amazon Elastic Kubernetes Service cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you plan to follow along with this chapter, you will need an AWS account
    with a valid payment attached.
  prefs: []
  type: TYPE_NORMAL
- en: Following the instructions in this chapter will incur a cost, and you must terminate
    any resources you launch once you have finished using them. All prices quoted
    in this chapter are correct as of when this book was written, and we recommend
    that you review the current costs before launching any resources.
  prefs: []
  type: TYPE_NORMAL
- en: What are Amazon Web Services and Amazon Elastic Kubernetes Service?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have already heard of Amazon Web Services, or AWS, as we will refer
    to it. It was one of the first public cloud providers and has the largest market
    share at the time of writing (June 2024): 31%, with Microsoft Azure second at
    25% and GCP third at 11%.'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Web Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have already guessed, Amazon owns and operates AWS. What began as
    Amazon experimenting with cloud services in 2000, by developing and deploying
    **application programming interfaces** (**APIs**) for its retail partners, has
    since evolved into AWS, a global leader in cloud computing, powering businesses
    of all sizes across various industries.
  prefs: []
  type: TYPE_NORMAL
- en: Based on this work, Amazon realized that they needed to build a better and more
    standardized infrastructure platform not only to host the services they had been
    developing but also to ensure they could quickly scale as more of their retail
    outlets consumed the software services and grew at an expedient rate.
  prefs: []
  type: TYPE_NORMAL
- en: Chris Pinkham and Benjamin Black wrote a white paper in 2003 that was approved
    by Jeff Bezos in 2004, which described an infrastructure platform where compute
    and storage resources can all be deployed programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: The first public acknowledgment of AWS’s existence was made in late 2004; however,
    the term was used to describe a collection of tools and APIs that would allow
    third parties to interact with Amazon’s retail product catalog, rather than what
    we know today.
  prefs: []
  type: TYPE_NORMAL
- en: It wasn’t until 2006 that a rebranded AWS was launched, starting in March with
    **Simple Storage Service** (**S3**). This service allowed developers to write
    and serve individual files using a web API, rather than writing and reading from
    a traditional local or remote filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The next service to launch, **Amazon Simple Queue Service** (**SQS**), had formed
    part of the original AWS collection of tools. This was a distributed message system
    that, again, could be controlled and consumed by developers using an API.
  prefs: []
  type: TYPE_NORMAL
- en: The final service, launched in 2006, was a beta of **Amazon Elastic Compute
    Cloud** (**Amazon EC2**), limited to existing AWS customers. Again, you could
    use the APIs developed by Amazon to launch Amazon EC2 resources.
  prefs: []
  type: TYPE_NORMAL
- en: This was the final piece of the puzzle for Amazon. They now had the foundations
    of a public cloud platform on which they could not only use their own retail platform
    but also sell space to other companies and the public, such as you and me.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s fast-forward from 2006, when there were 3 services, to the time of writing,
    mid-2024, where there are over 200 services available, all of which run in over
    125 physical data centers across 39 Regions, which comprise over 38 million square
    feet in total.
  prefs: []
  type: TYPE_NORMAL
- en: All 200+ services adhere to the core principles laid out in the 2003 white paper.
    Each service is software-defined, meaning that developers must make a simple API
    request to launch, configure, and, in some cases, consume the service before finally
    making another API request to terminate it.
  prefs: []
  type: TYPE_NORMAL
- en: You may have already noticed this from the services that have already been mentioned
    up to this point, but services running in AWS are prefixed with either Amazon
    or AWS – why is this? Well, services that start with Amazon are standalone services,
    unlike those prefixed with AWS, which are services designed to be used alongside
    the services that are prefixed with Amazon.
  prefs: []
  type: TYPE_NORMAL
- en: Long gone are the days of having to order a service, have someone build and
    deploy it, and then hand it over to you; this reduces deployment times to seconds
    from what could sometimes take weeks or months.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than discussing all 200+ services, which would be an entire series of
    books, we should discuss the service we will examine in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Elastic Kubernetes Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While AWS was the first of the major public cloud providers, it was one of the
    last to launch a standalone Kubernetes service. Amazon EKS was first announced
    in late 2017\. It became generally available in the United States (US), starting
    with the East (N. Virginia) and West (Oregon) Regions in June 2018.
  prefs: []
  type: TYPE_NORMAL
- en: 'The service is built to work with and take advantage of other AWS services
    and features, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS Identity and Access Management** (**IAM**) allows you to control and
    manage end-user and programmatic access to other AWS services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Route 53** is Amazon’s **Domain Name System** (**DNS**) service. Amazon
    EKS can use it as a source of DNS for clusters, meaning service discovery and
    routing can easily be managed within your cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Elastic Block Store** (**EBS**): If you need persistent block storage
    for containers running within your Amazon EKS cluster, **Amazon Elastic Block
    Store** (**EBS**) provides this storage, just as it does for your EC2 compute
    resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EC2 Auto Scaling**: If your cluster needs to scale, the same technology is
    employed to scale your EC2 instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-Availability Zones** (**AZs**) can be a useful feature. The Amazon
    EKS management layer and cluster nodes can be configured to be spread across multiple
    AZs within a given Region to bring **High Availability** (**HA**) and resilience
    to your deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we launch our Amazon EKS cluster, we will need to download, install,
    and configure a few tools.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing your local environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to install two command-line tools, but before we do, we should quickly
    discuss the steps to sign up for a new AWS account. If you already have an AWS
    account, skip this task and move straight to the *Installing the AWS command-line
    interface* section.
  prefs: []
  type: TYPE_NORMAL
- en: Signing up for an AWS account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Signing up for an AWS account is a straightforward process, as detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://aws.amazon.com/](https://aws.amazon.com/) and click the **Create
    an AWS account** button at the top right of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Amazon offers a free tier for new users. It is limited to certain services and
    instance sizes and lasts 12 months. For information on the AWS Free Tier, see
    [https://aws.amazon.com/free/](https://aws.amazon.com/free/).
  prefs: []
  type: TYPE_NORMAL
- en: Fill out the initial form that asks for an email address. This will be used
    for account recovery and some basic administrative functions. Also, provide your
    chosen AWS account name. Don’t worry if you change your mind; you can change this
    in your account settings after you sign up. You will then need to verify your
    email address. Once the email address has been verified, you will be asked to
    set the password for your “root” account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you enter your password, click **Continue** and follow the onscreen instructions.
    There are five steps; these will involve you confirming your payment details and
    identity via an automated phone call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have created and enabled your account, you will be notified when you
    can start using AWS services – most of the time, this will be straight away, but
    it can take up to 48 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to install the command-line tools that we will be using to launch
    our Amazon EKS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the AWS command-line interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next on our list of tasks is to install the AWS **Command-Line Interface** (**CLI**).
    As we did in the previous chapter, *Chapter 15*, *Kubernetes Clusters on Google
    Kubernetes Engine*, we will target Windows, Linux, and macOS, which we will look
    at first.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Installing the AWS CLI on macOS using Homebrew is as simple as running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it’s installed, run the following command, which should give you the version
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the version of the AWS CLI, along with some of the support
    services it needs, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_01.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.1: Checking the version of the AWS CLI'
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, you can move on to the AWS CLI configuration section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While packages are available for each distribution, the easiest way to install
    the AWS CLI on Linux is to download and run the installer.
  prefs: []
  type: TYPE_NORMAL
- en: These instructions assume that you have the `curl` and `unzip` packages installed.
    If you don’t, please install them using your distribution’s package manager. For
    example, on Ubuntu, you would need to run `sudo apt-get install unzip curl` to
    install both packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download and install the AWS CLI, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, you should be able to execute the `aws --version` command, and
    you will get something like the output shown in the *Installing on macOS* section,
    and the Windows version, which we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with macOS, you can install the AWS CLI with a package manager. As in *Chapter
    15*, *Kubernetes Clusters on Google Kubernetes Engine*, we will use Chocolatey.
    The command you need to run is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed using Chocolatey, executing the command below will give you
    a similar output to what we saw on macOS, with changes to the OS and Python versions
    being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Again, once installed, you can move on to the *AWS CLI configuration* section
    below.
  prefs: []
  type: TYPE_NORMAL
- en: AWS CLI configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have installed the AWS CLI and checked that it is running properly
    by issuing the `aws --version` command, you must link your local CLI install to
    your AWS account. To do this, you must log in to the AWS console, which can be
    accessed at [http://console.aws.amazon.com/](http://console.aws.amazon.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Once logged in, type **IAM** into the search box, which is located at the top
    left of the page, next to the **Services** button. Then, click on the **IAM Identity
    Center** service link in the Services results to be taken to the **IAM Identity
    Center** page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a user with programmatic access; to do this, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your AWS account’s age or access level, you may need to enable
    **IAM Identity Center**. My AWS account is for my own projects, so after clicking
    the **Enable** button, I chose the **Enable in only this AWS account** option
    rather than the recommended **Enable with AWS Organizations**. I did this because
    I do not have or require managing multiple AWS accounts within a single organization.
    Follow the onscreen instructions to enable the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the **IAM Identity Center** service is enabled, we must create a user with
    programmatic-only access. To do this, return to the search box in the menu at
    the top of the screen and search for **IAM** again, but this time select **IAM**,
    which is listed as **Manage access to AWS resources**. Once the page loads, click
    on **Users**, which can be found in the **Access Management** section of the left-hand-side
    menu, and then click the **Create user** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the username of **ekscluster** and ensure you do not select the **Provide
    user access to the AWS Management Console – optional** option, then click **Next**.
    We will discuss this option later in the chapter, once we have launched our cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_02.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.2: Adding a user'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than create a group, we will grant our user an existing policy. To do
    this, select **Attach existing policies directly**, select the **AdministratorAccess**
    policy, and then click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_03.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.3: Assigning permissions'
  prefs: []
  type: TYPE_NORMAL
- en: As this is a test in a non-production AWS account and we are going to remove
    this user at the end of the chapter, I am using quite a permissive policy. If
    you are going to be deploying this into a more production-like environment, I
    recommend referring to the AWS documentation for a more detailed guide on setting
    the correct permissions and policies.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have reviewed the information, click on the **Create user** button.
    Once your user has been created, select the **ekscluster** user from the list,
    select the **Security credentials** tab, and click the **Create access key** button
    in the **Access keys** section. Select **Command Line Interface (CLI)** and proceed
    to create the access key by clicking the **Next** and then **Create access key**
    buttons; once the key has been created, click on **Download .csv file** and, finally,
    the **Done** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep the file you have downloaded safe, as it contains valid credentials for
    accessing your AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to your terminal and then run the following command to create a default
    profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ask for a few bits of information, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS access key identifier** (**ID**): This is the access key ID from the
    **comma-separated values** (**CSV**) file we downloaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS secret access key**: This is the key from the CSV file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default region name**: I entered `us-west-2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default output format**: I left this blank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To test that everything is working, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will list the AWS Regions that are available, and the output should look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A computer screen with white text'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_04.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.4: Testing the AWS CLI'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the AWS CLI installed and configured for our account, we need
    to install the second command-line tool, which we’ll use to launch the Amazon
    EKS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing eksctl, the official CLI for Amazon EKS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it is possible to launch an Amazon EKS cluster using the AWS CLI, it is
    complicated and has many steps. To get around this, Weaveworks created a simple
    command-line tool that generates an AWS CloudFormation template and then launches
    your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Weaveworks stopped commercial operations in early 2024, but before
    ceasing operations, they passed control of the project to the AWS team.
  prefs: []
  type: TYPE_NORMAL
- en: AWS CloudFormation is Amazon’s **Infrastructure-as-Code** (**IaC**) definition
    language. It lets you define your AWS resources so that they can be deployed across
    multiple accounts or repeatedly in the same one. This is useful if you have to
    keep spinning up an environment, for example, as part of a **continuous integration**
    (**CI**) build.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have already guessed, installing on macOS and Windows follows the
    same pattern we have been using; macOS users can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, on Windows, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Installing `eksctl` on Linux, like the other tools, is slightly different,
    with the commands being:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you should be able to run the command below to get the version
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, we are now ready to launch our Amazon EKS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Launching your Amazon Elastic Kubernetes Service cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all of the prerequisites installed, we can finally start deploying our
    Amazon EKS cluster. Once deployed, we will be able to start interacting with it
    to launch a workload like we did in *Chapter 15*, *Kubernetes Clusters on Google
    Kubernetes Engine*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will use the defaults built into the `eksctl` command, as this
    is just a sandbox Amazon EKS against which we can run some commands. This will
    launch an Amazon EKS cluster with the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **us-west-1** Region
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With two worker nodes, using the **m5.large** instance type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the official AWS EKS **Amazon Machine Image** (**AMI**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses **Amazon’s Virtual Private Cloud** (**VPC**) for its networking service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With an automatically generated random name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, without further ado, let’s launch our cluster by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You should go and make a drink or catch up on emails, as this process can take
    up to 30 minutes to complete. If you are not deploying an Amazon EKS cluster,
    here is my output when running the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, some basic information is displayed about the version of `eksctl`
    and which Region will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, it will give some information on the networking and AZs it will be
    deploying resources into, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It will now give details of which version of the AMI it is going to use, along
    with the Kubernetes version that the image supports, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it knows all the elements, it is going to create a cluster. Here, you can
    see it making a start on the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it has called my cluster `hilarious-wardrobe-1717847351`; this
    will be referenced throughout the build. By default, logging is not enabled, as
    we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now is the point where we wait as the control plane and cluster are deploying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once deployed, it will download the cluster credentials and configure `kubectl`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to wait for the nodes to become available, as is happening
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have both nodes online and ready, it is time to display a message
    confirming that everything is ready, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the cluster is ready, let’s do as the output suggests and run `kubectl
    get nodes`. As expected, this gives us details on the two nodes that make up our
    cluster, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer screen'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_05.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.5: Viewing the two Amazon EKS cluster nodes'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a cluster up and running, let’s deploy the same workload we
    launched when we worked with our **Google Kubernetes Engine** (**GKE**) cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a workload and interacting with your cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 15*, *Kubernetes Clusters on Google Kubernetes Engine*, we used
    the Guestbook example from the GCP GKE examples GitHub repository. In this section,
    first we will deploy the workload before exploring the web-based AWS console.
    So now let’s start on our Guestbook deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the workload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though our cluster runs in AWS using Amazon EKS, we will use the same
    set of YAML files we used to launch our workload in GKE using our local `kubectl`;
    to do this, follow the steps below:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, our first step is launching the Redis Leader deployment and service
    by running the two commands below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the Redis Leader is deployed, we need to launch the Redis Follower deployment
    and service, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the Redis Leader and Follower are up and running, it’s time to launch
    the frontend deployment and service using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After a few minutes, we will be able to run the following command to get information
    on the service we have just launched, which should include details on where to
    access our workload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will notice that, this time, the output is slightly different from the
    output we got when running the workload on GKE, as we can see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_06.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.6: Getting information on the frontend service'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, rather than an **Internet Protocol** (**IP**) address, we get
    a **Uniform Resource Locator** (**URL**). Copy that into your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have opened the URL, given that we have used the same commands and
    workload configuration, you won’t be surprised to see the **Guestbook** application,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_07.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.7: The Guestbook application with a few examples'
  prefs: []
  type: TYPE_NORMAL
- en: Now that our workload is up and running, let’s explore what we can see about
    our cluster within the AWS console.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the AWS console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section will examine our newly deployed workload using the AWS console.
    First, log in to the AWS console at [https://console.aws.amazon.com/](https://console.aws.amazon.com/).
    Once logged in, select the **US West (Oregon) us-west-2** Region in the Region
    selector at the top right of the screen, next to your username.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_08.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.8: Selecting the correct Region'
  prefs: []
  type: TYPE_NORMAL
- en: Once the correct Region is selected, search for **Elastic Kubernetes Service**
    in the search bar on the top right and select the service, which should be the
    first result, to be taken to the EKS page in the Oregon Region.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_09.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.9: Our first look at our EKS cluster in the AWS console'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good; well, we will talk about it in a moment – click on your cluster
    name, and you will be presented with something that looks like the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_10.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.10: Access denied!'
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s unpack what is happening here. You may think, *“This is my main user,
    and surely it has full access?”.*
  prefs: []
  type: TYPE_NORMAL
- en: There is a good reason for this; when `eksctl` launched our cluster, it granted
    the **ekscluster** user we created earlier in the chapter permission to interact
    with the cluster using AWS services as we configured the AWS CLI to connect using
    this user and not the main user we are currently logged in as.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that to view workloads and the like within the AWS console, we need
    to log in as the user we created earlier. To do this, return to IAM in the AWS
    console, go to the **Users** page, and select the **ekscluster** user; go to the
    **Security Credentials** tab and then click on the **Enable console access** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_11.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.11: Enabling console access for the ekscluster user'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Autogenerated password** option and enable access; finally, download
    the CSV file containing the credentials as before.
  prefs: []
  type: TYPE_NORMAL
- en: Once downloaded, sign out of the AWS console and open the CSV file you downloaded.
    Go to the console sign-in URL. This is a URL that allows IAM users, like the one
    we created, to sign in to your account; use the username and password in the CSV
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have signed in, return to the EKS page and select your cluster; this
    time, you will not see any complaints about permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you first open the cluster, you will see several tabs. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overview**: Displays various cluster details, such as the version of Kubernetes
    running, endpoint information, the cluster status, creation time and date, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resources**: Provides information on nodes, Pods, namespaces, and workloads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compute**: Shows node information, node groups, and details on any Fargate
    profiles associated with the cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking**: Details the VPC configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add-ons**: Lists installed and available add-ons for the cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: Displays IAM roles, AWS auth ConfigMap, and Kubernetes RBAC role
    bindings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observability**: Configures and shows logging, monitoring, and recent events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Upgrade insights**: Lists available Kubernetes version upgrades and compatibility
    checks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update history**: Provides a history of cluster and node group updates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tags**: Lists and manages tags associated with the EKS cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Below, you can see details on the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_12.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.12: Viewing the two nodes in the cluster in the Compute tab'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on **Resources**, selecting **Deployments**, and filtering down to
    the **default** workspace will show the workload we launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_13.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.13: Viewing our workload'
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on one of the deployments will give you more information on the deployment
    – this includes details of the Pods, configuration, and so on. However, as you
    click around, you will find that all you can really do is view information on
    the services; there are no graphs, logging output, or anything that gives more
    than a basic overview of our workloads. This is because the AWS console is mostly
    just exposing information from Kubernetes itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving away from the EKS service page and going to the EC2 service section
    of the AWS console will display the two nodes, as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_14.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.14: Looking at the raw EC2 compute resource'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can drill down and find out more information on the instance, including
    CPU, RAM, and network utilization; however, this is only for the instance itself
    and not our Kubernetes workload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting **Load Balancers** from the **Load Balancing** section of the left-hand-side
    menu will show you the elastic load balancer that was launched and configured
    when we applied the frontend service, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_15.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.15: Looking at the raw load balancer resource'
  prefs: []
  type: TYPE_NORMAL
- en: One final AWS service we are using is AWS CloudFormation, so entering **CloudFormation**
    in the Services menu and clicking on the link will take you to the CloudFormation
    service page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you will see two stacks: one for the EKS nodes, our two EC2 instances,
    and one for the EKS cluster, which is our Kubernetes management plane. These stacks
    are illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_16.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.16: The two stacks that make up our cluster'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting one of the stacks will give you details on what happened when the
    stack was launched. It will list all the many resources created during the launch
    of the Amazon EKS cluster using `eksctl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You select a template and then view it in the designer; you can even see the
    CloudFormation template generated by `eksctl`, which is quite a complicated JSON
    file – if you click on the **View in Application Composer** button, you will be
    able to get a more digestible visual representation of the stack. A screenshot
    of this view can be seen below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B22019_16_17.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.17: Reviewing the CloudFormation template in Application Composer'
  prefs: []
  type: TYPE_NORMAL
- en: That is about all we can see in the AWS console. As we have seen, while Amazon
    EKS is relatively simple to launch using `eksctl`, its level of integration with
    the AWS console could be better compared to the GKE cluster we launched in the
    previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: While we were able to explore and view our workload, we could not interact with
    too much; also, the feedback on the cluster is tied to the basic monitoring offered
    by the Amazon EC2 service.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have finished with your Amazon EKS cluster, you can delete it.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting your Amazon Elastic Kubernetes Service cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can delete your cluster by running the following command, making sure to
    replace the cluster name with that of your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Deleting the cluster takes less time to run than when we launched it; in fact,
    it takes around 5 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, `eksctl` gives you details on what it is doing as it deletes the
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that is updated is the local kubectl configuration, as we can
    see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, any resources that have been launched as part of deploying workloads
    into our cluster are terminated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the two AWS CloudFormation stacks are removed, which in turn removes
    all of the resources they created and configured, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our cluster has been completely deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Please double-check the EC2, EKS, and CloudFormation sections in the AWS console
    to ensure that all services have been correctly deleted, as you will be charged
    for any orphaned or idle resources left behind. While this is an unlikely scenario,
    it is best to double-check now rather than receive an unexpected bill at the end
    of the month.
  prefs: []
  type: TYPE_NORMAL
- en: So, how much would our Amazon EKS cluster have cost us to run for a month?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two sets of costs that we need to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is for the Amazon EKS cluster itself. It is US Dollars (USD) 0.10
    per hour for each Amazon EKS cluster you create; however, each Amazon EKS cluster
    can run multiple node groups, so you shouldn’t have to launch more than one per
    Region. This means that the Amazon EKS cluster costs around $73 per month.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next consideration is the AWS resources used by the cluster, for example,
    the EC2 cluster nodes, in our case, would have cost around $70 each, and the total
    cost to run our cluster for a month would be around $213\. I say around because
    there are charges for bandwidth and the AWS **Elastic Load Balancing** (**ELB**)
    service, which will increase the cost of our workload further.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A link to the pricing overview page can be found in the *Further reading* section
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the origins of AWS and Amazon EKS before walking
    through how to sign up for an account and how to install and configure the two
    command-line tools required to easily launch an Amazon EKS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Once our cluster was up and running, we deployed the same workload as when we
    launched our GKE cluster. We did not have to make any allowances for the workload
    running on a different cloud provider – it just worked, even deploying a load
    balancer using the AWS native load balancing service without us having to instruct
    it to do so.
  prefs: []
  type: TYPE_NORMAL
- en: However, we did find that Amazon EKS is less integrated with the AWS console
    than the Google service we looked at. We also learned that we had to install a
    second command-line tool to easily launch our cluster due to the complications
    of trying to do so using the AWS CLI. This would have been around eight steps,
    assuming the Amazon VPC configuration and IAM roles had been created and deployed.
  prefs: []
  type: TYPE_NORMAL
- en: This lack of integration and complexity in launching and maintaining clusters
    compared to other providers would put me off running my Kubernetes workloads on
    Amazon EKS – it all feels a little disjointed and not as slick as the Google offering.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine launching an **Azure Kubernetes Service**
    (**AKS**) cluster on Microsoft Azure, the last of the three public providers we
    will cover.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are links to more information on some of the topics and tools we have
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'AWS: [https://aws.amazon.com/](https://aws.amazon.com/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Amazon EKS: [https://aws.amazon.com/eks/](https://aws.amazon.com/eks/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'The AWS CLI: [https://aws.amazon.com/cli/](https://aws.amazon.com/cli/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'eksctl: [https://eksctl.io/](https://eksctl.io/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'eksctl support status update: [https://github.com/aws/containers-roadmap/issues/2280](https://github.com/aws/containers-roadmap/issues/2280'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Official documentation: [https://docs.aws.amazon.com/eks/latest/userguide/what-is-eks.html](https://docs.aws.amazon.com/eks/latest/userguide/what-is-eks.html'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Amazon EKS pricing: [https://aws.amazon.com/eks/pricing/](https://aws.amazon.com/eks/pricing/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code119001106479081656.png)'
  prefs: []
  type: TYPE_IMG
