<html><head></head><body>
<div id="_idContainer017">
<h1 class="chapter-number" id="_idParaDest-31"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-32"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.2.1">Walking through Kubernetes Secrets Management Concepts</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we had a good overview of Kubernetes, the components that Kubernetes consists of, and how configurations are applied and stored. </span><span class="koboSpan" id="kobo.3.2">Also, we built a Golang application and managed to run this application on Kubernetes. </span><span class="koboSpan" id="kobo.3.3">As expected, Secrets had to be added to our application’s configuration. </span><span class="koboSpan" id="kobo.3.4">Secrets management comes with various concerns. </span><span class="koboSpan" id="kobo.3.5">From creation to modification to deletion, we need to tackle security concerns as well as scalability </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">and resiliency.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">What are Kubernetes Secrets, and how do they differ from other </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">Kubernetes objects?</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Different types of Secrets and their </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">usage scenarios</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Creating, modifying, and deleting Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">in Kubernetes</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Kubernetes Secrets configuration in different </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">deployment scenarios</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Requirement for managing Secrets, including secure storage and </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">access control</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Securing access to Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">with RBAC</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Auditing and monitoring </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Secret usage</span></span></li>
</ul>
<h1 id="_idParaDest-33"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">To link concepts to hands-on examples, we will leverage a series of tools and platforms commonly used to interact with containers, Kubernetes, and Secrets management. </span><span class="koboSpan" id="kobo.22.2">For this chapter, we will ramp up with a friendly desktop </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">graphical solution:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.24.1">Podman Desktop</span></strong><span class="koboSpan" id="kobo.25.1"> (</span><a href="https://podman-desktop.io"><span class="koboSpan" id="kobo.26.1">https://podman-desktop.io</span></a><span class="koboSpan" id="kobo.27.1">) is an </span><strong class="bold"><span class="koboSpan" id="kobo.28.1">open source software</span></strong><span class="koboSpan" id="kobo.29.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.30.1">OSS</span></strong><span class="koboSpan" id="kobo.31.1">) that</span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.32.1"> interacts with containers, runs local Kubernetes instances, and even connects with remote platforms such as Red Hat OpenShift, </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">Azure Kubernetes Service</span></strong><span class="koboSpan" id="kobo.34.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.35.1">AKS</span></strong><span class="koboSpan" id="kobo.36.1">), and more. </span><span class="koboSpan" id="kobo.36.2">We will use the Go programming language in this chapter. </span><span class="koboSpan" id="kobo.36.3">To install Go on your system, you can follow the instructions</span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.37.1"> from the official </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">documentation (</span></span><a href="https://go.dev/doc/install"><span class="No-Break"><span class="koboSpan" id="kobo.39.1">https://go.dev/doc/install</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.40.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.41.1">In this chapter, </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">minikube</span></strong><span class="koboSpan" id="kobo.43.1"> will also be </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.44.1">used. </span><span class="koboSpan" id="kobo.44.2">To install minikube on your system, you </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.45.1">can follow the instructions from the official </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">documentation (</span></span><a href="https://minikube.sigs.k8s.io/docs/start/"><span class="No-Break"><span class="koboSpan" id="kobo.47.1">https://minikube.sigs.k8s.io/docs/start/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.48.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.49.1">All of the code examples in the book are available on our dedicated GitHub repository with a clear structure and instruction set, with corresponding folders for each </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">chapter (</span></span><a href="https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook"><span class="No-Break"><span class="koboSpan" id="kobo.51.1">https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.52.1">).</span></span></li>
</ul>
<h1 id="_idParaDest-34"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.53.1">What are Kubernetes Secrets, and how do they differ from other Kubernetes objects?</span></h1>
<p><span class="koboSpan" id="kobo.54.1">One of the fundamental building blocks of Kubernetes is Kubernetes objects. </span><span class="koboSpan" id="kobo.54.2">Through Kubernetes objects, we can </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.55.1">represent the state of the system. </span><span class="koboSpan" id="kobo.55.2">An application running on Kubernetes consists of the actual program, the resources the application uses, and the configurations of the application such as health checks. </span><span class="koboSpan" id="kobo.55.3">With regard to other cross-cutting concerns such as security, there are configurations for </span><strong class="bold"><span class="koboSpan" id="kobo.56.1">role-based access control</span></strong><span class="koboSpan" id="kobo.57.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.58.1">RBAC</span></strong><span class="koboSpan" id="kobo.59.1">); these include </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.60.1">cluster-wide roles, namespace roles, and the role bindings to a user or entity. </span><span class="koboSpan" id="kobo.60.2">Furthermore, Kubernetes objects include namespaces, which act as logical containers, and network policies, which are cluster-wide traffic rules. </span><span class="koboSpan" id="kobo.60.3">By creating Kubernetes objects, we declare the desired state of the cluster. </span><span class="koboSpan" id="kobo.60.4">Kubernetes is responsible for and will work toward ensuring that the actual state of the system matches the state defined by the objects </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">we create.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">A typical Kubernetes object has certain mandatory fields: </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">apiVersion</span></strong><span class="koboSpan" id="kobo.64.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">kind</span></strong><span class="koboSpan" id="kobo.66.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">metadata</span></strong><span class="koboSpan" id="kobo.68.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">spec</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">We can see its YAML representation </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.74.1">apiVersion</span></strong><span class="koboSpan" id="kobo.75.1">: apps/v1 #version of Kubernetes api
</span><strong class="bold"><span class="koboSpan" id="kobo.76.1">kind</span></strong><span class="koboSpan" id="kobo.77.1">: Deployment    #type of Object
</span><strong class="bold"><span class="koboSpan" id="kobo.78.1">metadata</span></strong><span class="koboSpan" id="kobo.79.1">:           #metadata information
  </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">name</span></strong><span class="koboSpan" id="kobo.81.1">: example-deployment
</span><strong class="bold"><span class="koboSpan" id="kobo.82.1">spec</span></strong><span class="koboSpan" id="kobo.83.1">:               #the state the object should be</span></pre> <p><span class="koboSpan" id="kobo.84.1">The most common</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.85.1"> Kubernetes objects that a Kubernetes user will stumble upon are </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">Pod</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">Deployment</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">StatefulSet</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">Cronjob</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">Service</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">Ingress</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">NetworkPolicy</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">ConfigMap</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">Secret</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.96.1">The preceding objects can be logically grouped into objects representing workloads. </span><span class="koboSpan" id="kobo.96.2">Objects such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">Pod</span></strong><span class="koboSpan" id="kobo.98.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">Deployment</span></strong><span class="koboSpan" id="kobo.100.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">StatefulSet</span></strong><span class="koboSpan" id="kobo.102.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">Cronjob</span></strong><span class="koboSpan" id="kobo.104.1"> are used to define computing resources that will execute certain tasks; those can be running a server, executing a cronjob, or even setting up a distributed memory grid. </span><span class="koboSpan" id="kobo.104.2">Objects such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">Service</span></strong><span class="koboSpan" id="kobo.106.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">Ingress</span></strong><span class="koboSpan" id="kobo.108.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">NetworkPolicy</span></strong><span class="koboSpan" id="kobo.110.1"> specify networking aspects of our application; this can be load balancing traffic internally, exposing Kubernetes services to the internet, as well as blocking traffic internally between applications. </span><span class="koboSpan" id="kobo.110.2">So far, the Kubernetes objects mentioned are targeted toward application deployments to compute resources and traffic routing </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">between applications.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.113.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">Secret</span></strong><span class="koboSpan" id="kobo.115.1"> are different in their usage since they are targeted toward configuration storage. </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.117.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">Secret</span></strong><span class="koboSpan" id="kobo.119.1"> are objects consumed by applications running on Kubernetes. </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.121.1"> can be used for storing configurations. </span><span class="koboSpan" id="kobo.121.2">Common examples of configurations can be an </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">nginx</span></strong><span class="koboSpan" id="kobo.123.1"> configuration stored in </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">nginx.conf</span></strong><span class="koboSpan" id="kobo.125.1">, a JSON-based configuration, or an application configuration based on YAML. </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">Secret</span></strong><span class="koboSpan" id="kobo.127.1"> objects are for sensitive data. </span><span class="koboSpan" id="kobo.127.2">Take, for example, a </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">mutual TLS</span></strong><span class="koboSpan" id="kobo.129.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.130.1">mTLS</span></strong><span class="koboSpan" id="kobo.131.1">)-enabled </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">nginx</span></strong><span class="koboSpan" id="kobo.133.1"> configuration; we</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.134.1"> need a TLS key stored in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">.key</span></strong><span class="koboSpan" id="kobo.136.1"> file and a certificate stored in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">.pem</span></strong><span class="koboSpan" id="kobo.138.1"> file. </span><span class="koboSpan" id="kobo.138.2">Both are sensitive files and need to be handled securely. </span><span class="koboSpan" id="kobo.138.3">This secure handling should also apply to credentials such as usernames and passwords or access tokens. </span><span class="koboSpan" id="kobo.138.4">Essentially, Kubernetes Secrets are Kubernetes objects used in order to store sensitive configuration data, thus access should be restricted and the information stored in Secrets should be </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">handled securely.</span></span></p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.140.1">Different types of Secrets and their usage scenarios</span></h1>
<p><span class="koboSpan" id="kobo.141.1">Kubernetes provides us with various types of Secrets. </span><span class="koboSpan" id="kobo.141.2">Behind the scenes, it uses the same storage mechanism that we saw in </span><a href="B20970_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.142.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.143.1">, </span><em class="italic"><span class="koboSpan" id="kobo.144.1">Understanding Kubernetes Secrets Management</span></em><span class="koboSpan" id="kobo.145.1">; Secrets, once created, will be serialized and stored on </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">etcd</span></strong><span class="koboSpan" id="kobo.147.1">. </span><span class="koboSpan" id="kobo.147.2">What differs is how those Secrets are handled when used. </span><span class="koboSpan" id="kobo.147.3">There are various types of Secrets; let us examine them one </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">by one.</span></span></p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.149.1">Opaque</span></h2>
<p><span class="koboSpan" id="kobo.150.1">An Opaque secret</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.151.1"> is the default secret type. </span><span class="koboSpan" id="kobo.151.2">Whenever we want to add a sensitive configuration, whether it is a file or a variable, it will be created as an </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">Opaque secret.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">Opaque Secrets can be used by providing </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">key values:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.155.1">
$ kubectl create secret generic opaque-example-from-literals --from-literal=literal1=text-for-literal-1
$ kubectl get secret opaque-example-from-literals -o yaml
apiVersion: v1
data:
  literal1: dGV4dC1mb3ItbGl0ZXJhbC0x
kind: Secret
...
</span><span class="koboSpan" id="kobo.155.2">type: Opaque</span></pre> <p><span class="koboSpan" id="kobo.156.1">Opaque Secrets can also be executed by applying a </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">YAML file:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.158.1">
$ kubectl create secret generic opaque-example-from-literals --from-literal=literal1=text-for-literal-1
$ kubectl create secret generic secretfile --from-file=secret-file.txt=./secret.file.txt
kubectl get secret secretfile -o yaml
apiVersion: v1
data:
  secret-file.txt: QSBmaWxlIHdpdGggc2Vuc2l0aXZlIGRhdGE=
kind: Secret
metadata:
...
</span><span class="koboSpan" id="kobo.158.2">type: Opaque</span></pre> <p><span class="koboSpan" id="kobo.159.1">The examples for </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.160.1">Opaque Secrets are available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">ch02/secret-types/opaque</span></strong><span class="koboSpan" id="kobo.162.1"> folder. </span><span class="koboSpan" id="kobo.162.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">opaque.sh</span></strong><span class="koboSpan" id="kobo.164.1"> script will run the Bash commands needed to achieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">end result.</span></span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.166.1">Kubernetes service account token</span></h2>
<p><span class="koboSpan" id="kobo.167.1">A Pod</span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.168.1"> is a unit of work on</span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.169.1"> Kubernetes; a Pod that needs to interact with the Kubernetes API is in need of an identity. </span><span class="koboSpan" id="kobo.169.2">A service account is an identity that can be mapped to Pods directly or transitively through a deployment. </span><span class="koboSpan" id="kobo.169.3">A Pod can interact with the Kubernetes API, provided it has a service account attached. </span><span class="koboSpan" id="kobo.169.4">The service account attached is authorized to access resources of interest. </span><span class="koboSpan" id="kobo.169.5">On startup, the Pod with a service account configured has a service account token attached to </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">its filesystem.</span></span></p>
<h3><span class="koboSpan" id="kobo.171.1">Long-lived access token</span></h3>
<p><span class="koboSpan" id="kobo.172.1">On Kubernetes, prior </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.173.1">to version v1.27, a </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.174.1">service account token would be accessible as a Kubernetes secret managed by Kubernetes. </span><span class="koboSpan" id="kobo.174.2">This is called a long-lived </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">access token.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">It’s still possible to create a long-lived access token in the latest versions. </span><span class="koboSpan" id="kobo.176.2">This can be achieved by creating an empty secret and putting an annotation with the name of the </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">service account:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.178.1">
apiVersion: v1
kind: Secret
metadata:
  name: service-account-secret
  annotations:
    kubernetes.io/service-account.name: example-service-account
type: kubernetes.io/service-account-token</span></pre> <p><span class="koboSpan" id="kobo.179.1">As we can see, we</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.180.1"> note the service </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.181.1">account in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">annotations</span></strong><span class="koboSpan" id="kobo.183.1"> section. </span><span class="koboSpan" id="kobo.183.2">By running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">apply</span></strong><span class="koboSpan" id="kobo.185.1"> command, we should see that a token has </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">been generated:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.187.1">
$ kubectl create sa example-service-account
kubectl apply -f service-account-secret.yaml
kubectl get secret service-account-secret -o yaml
apiVersion: v1
data:
  ca.crt: ...==
  namespace: default
  token: eyJhbGxffQ.eyJhdWQ3RlbTpdW50In0.0LyJWAc2M9SdA3g
kind: Secret
metadata:
  annotations:
...
</span><span class="koboSpan" id="kobo.187.2">type: kubernetes.io/service-account-token</span></pre> <p><span class="koboSpan" id="kobo.188.1">Instructions to </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.189.1">create long-lived access</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.190.1"> tokens are available in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">script: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">ch02/secret-types/service-account/long-live-access-token.sh</span></strong></span></p>
<h3><span class="koboSpan" id="kobo.193.1">Service account token mounted on Pod</span></h3>
<p><span class="koboSpan" id="kobo.194.1">We’ve seen a service</span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.195.1"> account as a secret; let us see how a service account token is mounted to </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">a Pod.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">A Pod with a service account should look </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.199.1">
apiVersion: v1
kind: ServiceAccount
metadata:
  name: example-service-account
---
apiVersion: v1
kind: Pod
...
</span><span class="koboSpan" id="kobo.199.2">spec:
  ...
</span><span class="koboSpan" id="kobo.199.3">  serviceAccountName: example-service-account</span></pre> <p><span class="koboSpan" id="kobo.200.1">Once we apply the preceding YAML manifest, we can run a command within the Pod we just scheduled. </span><span class="koboSpan" id="kobo.200.2">We will print the service account token mounted </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.202.1">
$ kubectl exec -it busybox -- cat /var/run/secrets/kubernetes.io/serviceaccount/token
eyJhbGdkxfTlUifQ.eyJhdWQidwid3RlbTpdW50In0.0LyJWAc2M9SdA3g</span></pre> <p><span class="koboSpan" id="kobo.203.1">As we </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.204.1">can see, it is </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.205.1">a </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">JSON Web Token</span></strong><span class="koboSpan" id="kobo.207.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.208.1">JWT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">) token.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">Instructions to create a Pod with a service account are available in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">script: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">ch02/secret-types/service-account/service-account-with-pod.sh</span></strong></span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.213.1">Docker config</span></h2>
<p><span class="koboSpan" id="kobo.214.1">By using an image</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.215.1"> on a Pod, we might want to pull images from an alternative container registry. </span><span class="koboSpan" id="kobo.215.2">For this purpose, we want to mount the Docker configuration so that it is possible to communicate with the registry of our choice. </span><span class="koboSpan" id="kobo.215.3">One of the ways we can test this is by just using our local </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">Docker configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">We will use the following template to generate a </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">YAML manifest:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.219.1">
apiVersion: v1
kind: Secret
metadata:
  name: registry-docker-config
type: kubernetes.io/dockercfg
data:
  .dockercfg: |
     REPLACE_WITH_BASE64</span></pre> <p><span class="koboSpan" id="kobo.220.1">You can see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">REPLACE_WITH_BASE64</span></strong><span class="koboSpan" id="kobo.222.1"> string; this would be replaced with the Docker config from </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">Docker Hub.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">docker-credentials</span></strong><span class="koboSpan" id="kobo.226.1"> folder, there is already a Docker config file for that purpose at </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">ch02/secret-types/docker-credentials/config.json</span></strong><span class="koboSpan" id="kobo.228.1"> without any </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">actual credentials:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.230.1">
{
  "auths": {
    "</span><a href="https://index.docker.io/v1/”:"><span class="koboSpan" id="kobo.231.1">https://index.docker.io/v1/":</span></a><span class="koboSpan" id="kobo.232.1"> {}
  }
}</span></pre> <p><span class="koboSpan" id="kobo.233.1">We will issue a login and use our Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">Hub credentials:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.235.1">
$ docker --config ./ login --username=dockerhub-username --password=dockerhub-password</span></pre> <p><span class="koboSpan" id="kobo.236.1">The file will contain the basic authentication needed to connect with </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">Docker Hub:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.238.1">
{
...
</span><span class="koboSpan" id="kobo.238.2">    "auth": "token"
...
</span><span class="koboSpan" id="kobo.238.3">}</span></pre> <p><span class="koboSpan" id="kobo.239.1">We will use this config to mount it as a </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">Kubernetes secret:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.241.1">
$ DOCKER_CONFIG=$(cat ./config.json|base64)
$ cat docker-credentials-template.yaml|sed "s/REPLACE_WITH_BASE64/$DOCKER_CONFIG/" &gt; docker-credentials.yaml</span></pre> <p><span class="koboSpan" id="kobo.242.1">In our next steps, we</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.243.1"> will upload the credentials to Kubernetes by applying the YAML manifest </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">we created:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.245.1">
$ kubectl apply -f docker-credentials.yaml</span></pre> <p><span class="koboSpan" id="kobo.246.1">Then, we will create a Pod that pulls from </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">the registry:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.14.2
    ports:
    - containerPort: 80
  imagePullSecrets:
  - name: docker-credentials</span></pre> <p><span class="koboSpan" id="kobo.249.1">The image </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.250.1">will be pulled using the </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">credentials specified.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">The preceding instructions have been orchestrated in the following script: </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">ch02/secret-types/ docker-credentials/docker-credentials.sh</span></strong></span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.254.1">Basic authentication</span></h2>
<p><span class="koboSpan" id="kobo.255.1">Basic authentication</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.256.1"> consists of a key secret combination for the username and password. </span><span class="koboSpan" id="kobo.256.2">It gives us the option to be more declarative when specifying a basic </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">authentication secret.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">The YAML manifest should contain a value for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">username</span></strong><span class="koboSpan" id="kobo.260.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">password</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.262.1"> keys:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.263.1">
apiVersion: v1
kind: Secret
metadata:
  name: basic-auth-secret
type: kubernetes.io/basic-auth
stringData:
  username: a-user
  password: a-password</span></pre> <p><span class="koboSpan" id="kobo.264.1">Once we apply the preceding YAML manifest, the result will be very similar to the </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">Opaque Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">The preceding instructions have been orchestrated in the following script: </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">ch02/secret-types/ basic-authentication/basic-auth-secret.sh</span></strong></span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.268.1">TLS client or server</span></h2>
<p><span class="koboSpan" id="kobo.269.1">TLS Secrets are used to store SSL/TLS certificates. </span><span class="koboSpan" id="kobo.269.2">TLS Secrets</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.270.1"> can be used in order to be more declarative when it comes to mounting TLS certificates. </span><span class="koboSpan" id="kobo.270.2">However, a TLS secret can have direct usage when it comes to specifying </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">an Ιngress.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">An Ingress acts as an external load balancer to your system, serving HTTP/HTTPS traffic. </span><span class="koboSpan" id="kobo.272.2">Traffic needs to be secured </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">using SSL.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">An SSL secret</span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.275.1"> has the </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">following format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.277.1">
apiVersion: v1
kind: Secret
metadata:
  name: ingress-tls
type: kubernetes.io/tls
data:
  tls.crt: CRT
  tls.key: KEY</span></pre> <p><span class="koboSpan" id="kobo.278.1">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">ch02/secret-types/ssh/tls.sh</span></strong><span class="koboSpan" id="kobo.280.1"> script, we will create a certificate and key that can be used on an HTTP server. </span><span class="koboSpan" id="kobo.280.2">The secret created will be named </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">ingress-tls</span></strong><span class="koboSpan" id="kobo.282.1">. </span><span class="koboSpan" id="kobo.282.2">The script used as a certificate will have a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">webpage.your.hostname</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.284.1"> host.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">Let’s create an Ingress using TLS certificates we </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">created previously:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
apiVersion: networking.k8s.io/v1
kind: Ingress
...
</span><span class="koboSpan" id="kobo.287.2">spec:
  tls:
  - secretName: ingress-tls
    hosts:
      - webpage.your.hostname
  rules:
  - host: webpage.your.hostname
...</span></pre> <p><span class="koboSpan" id="kobo.288.1">By using the Ingress, we can define hosts and the SSL for </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">the hosts.</span></span></p>
<h3><span class="koboSpan" id="kobo.290.1">Note on minikube users</span></h3>
<p><span class="koboSpan" id="kobo.291.1">If you used</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.292.1"> minikube throughout the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">minikube.sh</span></strong><span class="koboSpan" id="kobo.294.1"> script, you should enable Ingress on your workstation </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.296.1">
$ minikube addons enable ingress</span></pre> <p><span class="koboSpan" id="kobo.297.1">We can now test the Ingress. </span><span class="koboSpan" id="kobo.297.2">Be aware that the Ingress needs to get an </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">IP assigned:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.299.1">
$ kubectl get ing
NAME           CLASS   HOSTS             ADDRESS        PORTS     AGE
webpage-ingress   nginx   webpage.your.hostname   192.168.49.2   80, 443   79s</span></pre> <p><span class="koboSpan" id="kobo.300.1">Since this IP might belong to an internal VM, we need to issue a </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">minikube tunnel</span></strong><span class="koboSpan" id="kobo.302.1"> command, which will forward the traffic to </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">our Ingress:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.304.1">
$ minikube tunnel</span></pre> <p><span class="koboSpan" id="kobo.305.1">By navigating to </span><a href="https://localhost/"><span class="koboSpan" id="kobo.306.1">https://localhost/</span></a><span class="koboSpan" id="kobo.307.1">, we can see </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">the certificate:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.309.1"><img alt="Figure 2.1 – SSL certificate" src="image/B20970_02_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.310.1">Figure 2.1 – SSL certificate</span></p>
<p><span class="koboSpan" id="kobo.311.1">Also, if we want to validate the Ingress routing, we can change </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">/etc/hosts</span></strong><span class="koboSpan" id="kobo.313.1"> and map the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">webpage.your.hostname</span></strong><span class="koboSpan" id="kobo.315.1"> DNS </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">localhost</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">.</span></span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.319.1">Token data</span></h2>
<p><span class="koboSpan" id="kobo.320.1">This type of secret is a bootstrap </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.321.1">token. </span><span class="koboSpan" id="kobo.321.2">It looks like the usual bearer token that we use on REST APIs; in the case of Kubernetes, it is used specifically for the bootstrap process of a Kubernetes cluster. </span><span class="koboSpan" id="kobo.321.3">When initializing a Kubernetes cluster, a bootstrap token is created and can then be used to join new nodes to </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">the cluster.</span></span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.323.1">Conclusion</span></h2>
<p><span class="koboSpan" id="kobo.324.1">We had a deep dive into Kubernetes Secrets. </span><span class="koboSpan" id="kobo.324.2">We identified different types of Secrets and ran examples of each secret type, depicting their usage and peculiarities. </span><span class="koboSpan" id="kobo.324.3">For the latest developments in Secrets, you can always refer to the official documentation (</span><a href="https://kubernetes.io/docs/concepts/configuration/secret/#secret-types"><span class="koboSpan" id="kobo.325.1">https://kubernetes.io/docs/concepts/configuration/secret/#secret-types</span></a><span class="koboSpan" id="kobo.326.1">). </span><span class="koboSpan" id="kobo.326.2">Throughout this section, the provisioning of the Secrets was done through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">kubectl</span></strong><span class="koboSpan" id="kobo.328.1"> command line. </span><span class="koboSpan" id="kobo.328.2">In the next section, we will explore our options for managing Secrets, creating them, deleting them, and </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">modifying them.</span></span></p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.330.1">Creating, modifying, and deleting Secrets in Kubernetes</span></h1>
<p><span class="koboSpan" id="kobo.331.1">Previously, we focused on creating Secrets and displaying their usage. </span><span class="koboSpan" id="kobo.331.2">We will proceed further on administrating Secrets and identify the available commands and options for provisioning </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">Kubernetes Secrets.</span></span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.333.1">data and stringData</span></h2>
<p><span class="koboSpan" id="kobo.334.1">We applied plaintext Secrets either by using a YAML file or through the command line. </span><span class="koboSpan" id="kobo.334.2">Behind the scenes, the Secrets that we applied in plaintext were converted to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">base64</span></strong><span class="koboSpan" id="kobo.336.1"> format. </span><span class="koboSpan" id="kobo.336.2">We can either apply Secrets in plaintext or apply them using </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">base64</span></strong><span class="koboSpan" id="kobo.338.1">; eventually, they will end up residing on Kubernetes in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">base64</span></strong><span class="koboSpan" id="kobo.340.1"> format. </span><span class="koboSpan" id="kobo.340.2">When we apply a secret using plaintext values, we </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.341.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">stringData</span></strong><span class="koboSpan" id="kobo.343.1"> field. </span><span class="koboSpan" id="kobo.343.2">Kubernetes will handle the encoding and decoding of the values </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">we provided.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">Take, for example, the </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">following secret:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
apiVersion: v1
kind: Secret
metadata:
  name: plain-text
type: Opaque
stringData:
  value: non-base64</span></pre> <p><span class="koboSpan" id="kobo.348.1">Once we create the secret, we will retrieve it. </span><span class="koboSpan" id="kobo.348.2">It should be </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">base64</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.352.1">
$ kubectl apply -f plain-text.yaml
$ kubectl get secret plain-text -o yaml|grep value
  value: bm9uLWJhc2U2NA==</span></pre> <p><span class="koboSpan" id="kobo.353.1">The value was stored in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">base64</span></strong><span class="koboSpan" id="kobo.355.1"> format. </span><span class="koboSpan" id="kobo.355.2">This is a convention that Kubernetes follows for storing Secrets. </span><span class="koboSpan" id="kobo.355.3">This is especially useful if we consider the different variations a secret can have. </span><span class="koboSpan" id="kobo.355.4">A secret can have a complex value; for example, a large YAML file or even </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">a binary.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">For the complex situations described previously, we have the option of </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.358.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">data</span></strong><span class="koboSpan" id="kobo.360.1"> field. </span><span class="koboSpan" id="kobo.360.2">When we apply Kubernetes Secrets using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">base64</span></strong><span class="koboSpan" id="kobo.362.1"> format, we use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.364.1"> field:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.365.1">
apiVersion: v1
kind: Secret
metadata:
  name: base64-encoded
type: Opaque
data:
  value: bm9uLWJhc2U2NA==</span></pre> <p><span class="koboSpan" id="kobo.366.1">Now that we have acquired knowledge on creating Secrets, we will proceed with other operations such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">update</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.368.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">delete</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">.</span></span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.371.1">Updating Secrets</span></h2>
<p><span class="koboSpan" id="kobo.372.1">When it comes to Kubernetes </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.373.1">objects, there are some basic commands that we can use to manage them. </span><span class="koboSpan" id="kobo.373.2">Those commands apply also to Secrets since they are Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">objects too.</span></span></p>
<h3><span class="koboSpan" id="kobo.375.1">Editing Secrets</span></h3>
<p><span class="koboSpan" id="kobo.376.1">Editing a </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.377.1">secret is done by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">edit</span></strong><span class="koboSpan" id="kobo.379.1"> command of </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">kubectl</span></strong><span class="koboSpan" id="kobo.381.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">kubectl</span></strong><span class="koboSpan" id="kobo.383.1"> comes with a preconfigured editor. </span><span class="koboSpan" id="kobo.383.2">By default, the editor </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">is Vim:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.385.1">
$ kubectl edit secret plain-text</span></pre> <p><span class="koboSpan" id="kobo.386.1">As we can see, the secret when editing will be presented in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">base64</span></strong><span class="koboSpan" id="kobo.388.1"> format. </span><span class="koboSpan" id="kobo.388.2">If we try to change the secret using plaintext, we will fail. </span><span class="koboSpan" id="kobo.388.3">When we edit a secret, we must provide a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">base64</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.390.1"> value.</span></span></p>
<p><span class="koboSpan" id="kobo.391.1">An option when editing a secret using </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">kubectl</span></strong><span class="koboSpan" id="kobo.393.1"> is to record the command that causes the change using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">—</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">record=true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.396.1"> argument:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.397.1">
$ kubectl edit secret plain-text --record=true
$ kubectl get secret plain-text -o yaml
...
</span><span class="koboSpan" id="kobo.397.2">    kubernetes.io/change-cause: kubectl edit secret plain-text --record=true
...</span></pre> <p><span class="koboSpan" id="kobo.398.1">As we can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">edit</span></strong><span class="koboSpan" id="kobo.400.1"> command that we issued </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">is recorded.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">For backup purposes as well as for keeping track of the previous state, when editing we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">—</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">save-config=true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.405.1"> argument:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.406.1">
$ kubectl edit secret plain-text --save-config=true
$ kubectl get secret plain-text -o yaml
...
</span><span class="koboSpan" id="kobo.406.2">kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion...."type":"Opaque"}
...</span></pre> <p><span class="koboSpan" id="kobo.407.1">In </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.408.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">last-applied-configuration</span></strong><span class="koboSpan" id="kobo.410.1"> field, we will back up the </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">previous configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">So far, we have edited Secrets and managed to keep track of the commands that caused the Secrets to change but also keep track of the last applied configuration. </span><span class="koboSpan" id="kobo.412.2">This is not always the case; sometimes, we might want Secrets to be immutable, which is something we will achieve in the </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">next section.</span></span></p>
<h3><span class="koboSpan" id="kobo.414.1">Immutable Secrets</span></h3>
<p><span class="koboSpan" id="kobo.415.1">In certain cases, we might want</span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.416.1"> our Secrets to remain unchanged; for example, we want to prevent accidental editing. </span><span class="koboSpan" id="kobo.416.2">Here’s how we can </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">achieve that:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.418.1">
apiVersion: v1
kind: Secret
metadata:
  name: immutable-secret
type: Opaque
stringData:
  value: non-base64
immutable: true</span></pre> <p><span class="koboSpan" id="kobo.419.1">If we try to edit the following secret, once we try to save, we will face the following </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">error message:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.421.1">
data: Forbidden: field is immutable when `immutable`is set</span></pre> <p><span class="koboSpan" id="kobo.422.1">Also, if we make </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.423.1">an existing secret immutable, then it is not possible to edit it; the secret becomes permanently immutable. </span><span class="koboSpan" id="kobo.423.2">To change an immutable secret, the only way is to delete the secret and re-apply it. </span><span class="koboSpan" id="kobo.423.3">Next, we will learn how to delete </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">Kubernetes Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">An example of showcasing immutable Secrets is provided </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">ch02/secret-types/secret-management/immutable/immutable-secret.sh</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">.</span></span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.429.1">Deleting Secrets</span></h2>
<p><span class="koboSpan" id="kobo.430.1">The command for </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.431.1">deleting a Kubernetes object also applies </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">to Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">The following example will delete a Kubernetes secret if </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">it exists:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.435.1">
kubectl delete secret immutable-secret</span></pre> <p><span class="koboSpan" id="kobo.436.1">By deleting a secret, it is permanently removed from our system. </span><span class="koboSpan" id="kobo.436.2">The only way to be able to retrieve it is either by restoring an </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">etcd</span></strong><span class="koboSpan" id="kobo.438.1"> backup, provided it contains the secret, or applying a manual backup that was taken using the </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.440.1">
kubectl get secret immutable-secret –o yaml</span></pre> <h2 id="_idParaDest-47"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.441.1">Conclusion</span></h2>
<p><span class="koboSpan" id="kobo.442.1">In this section, we went one step further on managing Kubernetes Secrets. </span><span class="koboSpan" id="kobo.442.2">We updated Secrets, kept track of our changes, and also took a backup of the previously existing configuration. </span><span class="koboSpan" id="kobo.442.3">Furthermore, we created immutable Secrets in order to prevent accidental editing, and last but not least, we deleted Secrets we did not need anymore. </span><span class="koboSpan" id="kobo.442.4">In the following section, we will focus on concerns surrounding secret usage in </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">different environments.</span></span></p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.444.1">Kubernetes Secrets configuration in different deployment scenarios</span></h1>
<p><span class="koboSpan" id="kobo.445.1">Throughout the </span><strong class="bold"><span class="koboSpan" id="kobo.446.1">software development life cycle</span></strong><span class="koboSpan" id="kobo.447.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.448.1">SDLC</span></strong><span class="koboSpan" id="kobo.449.1">), a team might use different environments to test their</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.450.1"> increments before releasing them to production. </span><span class="koboSpan" id="kobo.450.2">Just as with a production deployment, any other deployment on another environment will have certain configuration requirements, </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">including Secrets.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.452.1">Secret usage among environments</span></h2>
<p><span class="koboSpan" id="kobo.453.1">When it comes </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.454.1">to Secrets, we need to ensure their durability and integrity regardless of the environment. </span><span class="koboSpan" id="kobo.454.2">Having different handling of Secrets in different environments can cause issues in the long term, and the team will not be able to fully validate the security implications of choices on </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">secret handling.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">Provided the environments have differences due to cost-saving requirements or because a full installation brings more overhead, Secrets need to be securely stored. </span><span class="koboSpan" id="kobo.456.2">There might be cases where Secrets might be shared. </span><span class="koboSpan" id="kobo.456.3">An example can be a proprietary key of an external SaaS service that needs to be shared between environments. </span><span class="koboSpan" id="kobo.456.4">Another example is when multitenant cloud accounts host </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">multiple environments.</span></span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.458.1">From development to deployment</span></h2>
<p><span class="koboSpan" id="kobo.459.1">To deploy a </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.460.1">secret, sensitive information needs to reside somewhere. </span><span class="koboSpan" id="kobo.460.2">This information at some point will be inserted by an individual to a system and applied to Kubernetes. </span><span class="koboSpan" id="kobo.460.3">Companies nowadays store their sensitive information on various systems designed specifically to host this type of information. </span><span class="koboSpan" id="kobo.460.4">Briefly, secure storage is required to </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">host Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">The life cycle of deploying something as sensitive as a Kubernetes secret starts from retrieving the certificate from the secure storage, creating the YAML file needed for the secret, and applying it </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">to Kubernetes.</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">In the case of CI/CD jobs, most CI/CD providers provide us with the option to use secret values on our jobs. </span><span class="koboSpan" id="kobo.464.2">This can assist us in providing credentials to our CI/CD jobs to interact with the </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">secret storage.</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">Another </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.467.1">paradigm is</span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.468.1"> GitOps. </span><span class="koboSpan" id="kobo.468.2">Argo CD</span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.469.1"> is an extremely popular tool that can have a secret deployment customized to be able to apply a secret after it has </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">been decrypted.</span></span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.471.1">Conclusion</span></h2>
<p><span class="koboSpan" id="kobo.472.1">When it comes to different environments, our handling of Secrets should be treated the same regardless of the environment. </span><span class="koboSpan" id="kobo.472.2">This helps with automation as well </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">as consistency.</span></span></p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.474.1">Requirement for managing Secrets, including secure storage and access control</span></h1>
<p><span class="koboSpan" id="kobo.475.1">In terms of responsibilities, a Kubernetes cluster has a responsibility to securely contain Secrets and prevent unauthorized access. </span><span class="koboSpan" id="kobo.475.2">Every secret that is hosted on Kubernetes has been stored by an individual or an automated process. </span><span class="koboSpan" id="kobo.475.3">At some point in time, this secret that now resides on Kubernetes was in another system. </span><span class="koboSpan" id="kobo.475.4">This makes it important to store Secrets securely before they </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">reach Kubernetes.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.477.1">Secure storage</span></h2>
<p><span class="koboSpan" id="kobo.478.1">There </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.479.1">are various </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.480.1">tools dedicated to the purpose of secure storage. </span><span class="koboSpan" id="kobo.480.2">Take, for example, HashiCorp Vault, </span><strong class="bold"><span class="koboSpan" id="kobo.481.1">Google Cloud Platform</span></strong><span class="koboSpan" id="kobo.482.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.483.1">GCP</span></strong><span class="koboSpan" id="kobo.484.1">) Secret Manager, and </span><strong class="bold"><span class="koboSpan" id="kobo.485.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.486.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.487.1">AWS</span></strong><span class="koboSpan" id="kobo.488.1">) Secrets Manager. </span><span class="koboSpan" id="kobo.488.2">These are </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.489.1">external Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">management solutions.</span></span></p>
<p><span class="koboSpan" id="kobo.491.1">The benefit of those solutions is that they can be used as a standalone Secrets management system but can also be used directly from Kubernetes. </span><span class="koboSpan" id="kobo.491.2">It is feasible to use secure storage during development or even on </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">CI/CD jobs.</span></span></p>
<p><span class="koboSpan" id="kobo.493.1">A thing </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.494.1">these types of solutions have in common is that they tackle cross-cutting concerns such as management, versioning, encryption, and </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">access-control capabilities.</span></span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.496.1">Access control</span></h2>
<p><span class="koboSpan" id="kobo.497.1">Access control</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.498.1"> is essential to have our secret storage secured. </span><span class="koboSpan" id="kobo.498.2">Durability, encryption at rest, and encryption in transit make our interactions with a secure storage system secure, but it is not enough. </span><span class="koboSpan" id="kobo.498.3">We need to have fine-grained control when it comes to </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">accessing Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.500.1">We need to distinguish between users and their role in an organization. </span><span class="koboSpan" id="kobo.500.2">Also, permissions might differ per environment. </span><span class="koboSpan" id="kobo.500.3">Another aspect is auditing and identifying whether there was an incident of </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">unauthorized access.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.502.1">Git and encryption</span></h2>
<p><span class="koboSpan" id="kobo.503.1">Apart from using a secure storage system, another popular option is to store Secrets in an encrypted form. </span><span class="koboSpan" id="kobo.503.2">By storing Secrets encrypted on a Git repository, various aspects are feasible through</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.504.1"> Git’s capabilities. </span><span class="koboSpan" id="kobo.504.2">For example, versioning is by default enabled through commit history, access control is satisfied through the access control rules of Git, and the resiliency and durability of storage are based on the provider’s guarantees. </span><span class="koboSpan" id="kobo.504.3">As for encryption, this can be as good as the solution chosen. </span><span class="koboSpan" id="kobo.504.4">Data can be encrypted in various forms, from </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.505.1">a </span><strong class="bold"><span class="koboSpan" id="kobo.506.1">Pretty Good Privacy</span></strong><span class="koboSpan" id="kobo.507.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.508.1">PGP</span></strong><span class="koboSpan" id="kobo.509.1">) key (</span><a href="https://www.openpgp.org/"><span class="koboSpan" id="kobo.510.1">https://www.openpgp.org/</span></a><span class="koboSpan" id="kobo.511.1">) to a hardware security module to a modern </span><strong class="bold"><span class="koboSpan" id="kobo.512.1">cloud key management service</span></strong><span class="koboSpan" id="kobo.513.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.514.1">cloud KMS</span></strong><span class="koboSpan" id="kobo.515.1">) solution. </span><span class="koboSpan" id="kobo.515.2">An </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.516.1">extremely popular tool based on</span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.517.1"> this is </span><strong class="bold"><span class="koboSpan" id="kobo.518.1">Mozilla Secrets OPerationS</span></strong><span class="koboSpan" id="kobo.519.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.520.1">SOPS</span></strong><span class="koboSpan" id="kobo.521.1">): </span><a href="https://github.com/mozilla/sops"><span class="koboSpan" id="kobo.522.1">https://github.com/mozilla/sops</span></a><span class="koboSpan" id="kobo.523.1">. </span><span class="koboSpan" id="kobo.523.2">Mozilla SOPS utilizes KMSs provided by cloud providers as well </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">as PGP.</span></span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.525.1">Conclusion</span></h2>
<p><span class="koboSpan" id="kobo.526.1">Just as with every secret, their access should be limited, and they should not be available to be accessed to unauthorized personnel in any circumstances. </span><span class="koboSpan" id="kobo.526.2">For these reasons, apart from where we keep Secrets, we need to provide proper </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">access control.</span></span></p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.528.1">Securing access to Secrets with RBAC</span></h1>
<p><span class="koboSpan" id="kobo.529.1">A cross-cutting concern when it comes to Kubernetes objects is authorized access. </span><span class="koboSpan" id="kobo.529.2">Overall, the state of a system is something sensitive. </span><span class="koboSpan" id="kobo.529.3">You should have authorized access for operations such as changing the number of replicas for a deployment or changing the autoscaling rules for a deployment. </span><span class="koboSpan" id="kobo.529.4">The security mechanism that Kubernetes provides us with </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">is RBAC.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.531.1">RBAC introduction</span></h2>
<p><span class="koboSpan" id="kobo.532.1">RBAC </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.533.1">consists of the following </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">Kubernetes objects:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.535.1">Roles</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.536.1">Role bindings</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.537.1">Cluster roles</span></span></li>
<li><span class="koboSpan" id="kobo.538.1">Cluster </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">role bindings</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.540.1">We will check each component separately and see how they are combined with </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">Kubernetes Secrets.</span></span></p>
<h3><span class="koboSpan" id="kobo.542.1">Roles</span></h3>
<p><span class="koboSpan" id="kobo.543.1">Roles</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.544.1"> are a set of permissions that take effect only on the namespace where the role resides. </span><span class="koboSpan" id="kobo.544.2">By specifying a role, we define operations that can be executed upon a Kubernetes resource. </span><span class="koboSpan" id="kobo.544.3">Roles have the </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">following format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.546.1">
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: secret-viewer
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get","list","watch"]</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">verbs</span></strong><span class="koboSpan" id="kobo.548.1"> are the actions that we should be able to execute, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">resources</span></strong><span class="koboSpan" id="kobo.550.1"> are the targets for those actions. </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">apiGroups</span></strong><span class="koboSpan" id="kobo.552.1"> points to the API group of the resources we will interact with; by setting an empty value, it indicates the core </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">API group.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">The </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.555.1">preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">Role</span></strong><span class="koboSpan" id="kobo.557.1"> object enables the actor with that role to get, list, and watch Secrets for the default namespaces. </span><span class="koboSpan" id="kobo.557.2">Let us proceed and bind that role to </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">an actor.</span></span></p>
<h3><span class="koboSpan" id="kobo.559.1">Role bindings</span></h3>
<p><span class="koboSpan" id="kobo.560.1">By checking </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.561.1">how a </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">Role</span></strong><span class="koboSpan" id="kobo.563.1"> object is represented using YAML, we identify the action and the target. </span><span class="koboSpan" id="kobo.563.2">Role bindings help us to define the actor. </span><span class="koboSpan" id="kobo.563.3">An actor can be a user (individual or a group) or a service account. </span><span class="koboSpan" id="kobo.563.4">Role bindings have the following </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">YAML manifest:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.565.1">
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: secret-viewer-binding
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: secret-viewer
subjects:
- kind: ServiceAccount
  name: secret-viewer
  namespace: default</span></pre> <p><span class="koboSpan" id="kobo.566.1">A namespace is present when defining a role binding. </span><span class="koboSpan" id="kobo.566.2">This is because role bindings take effect only on the namespace in which they reside. </span><span class="koboSpan" id="kobo.566.3">On </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">roleRef</span></strong><span class="koboSpan" id="kobo.568.1">, we define a role that should be on the same namespace. </span><span class="koboSpan" id="kobo.568.2">On </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">subjects</span></strong><span class="koboSpan" id="kobo.570.1">, we define a list of actors that will have access </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.571.1">to that role. </span><span class="koboSpan" id="kobo.571.2">Take note that the subjects can come from </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">different namespaces.</span></span></p>
<h3><span class="koboSpan" id="kobo.573.1">Cluster roles</span></h3>
<p><span class="koboSpan" id="kobo.574.1">Cluster roles</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.575.1"> are close to roles: they do define a set of permissions; however, they take effect cluster-wide and are not limited to one namespace. </span><span class="koboSpan" id="kobo.575.2">They have the following </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">YAML representation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.577.1">
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: secret-admin-cluster
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["*"]</span></pre> <p><span class="koboSpan" id="kobo.578.1">This is almost identical to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">Role</span></strong><span class="koboSpan" id="kobo.580.1"> object except for the namespace not being present since those rules apply cluster-wide. </span><span class="koboSpan" id="kobo.580.2">The preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">ClusterRole</span></strong><span class="koboSpan" id="kobo.582.1"> role enables the actor with that role to administer Secrets from all namespaces we have on the Kubernetes clusters. </span><span class="koboSpan" id="kobo.582.2">We can now proceed with binding that </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">ClusterRole</span></strong><span class="koboSpan" id="kobo.584.1"> object to </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">an actor.</span></span></p>
<h3><span class="koboSpan" id="kobo.586.1">Cluster role bindings</span></h3>
<p><span class="koboSpan" id="kobo.587.1">By using </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.588.1">cluster role bindings, we bind a cluster role to a list of users and service accounts. </span><span class="koboSpan" id="kobo.588.2">A cluster role binding has the following </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">YAML representation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.590.1">
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: secret-admin-cluster-binding
subjects:
- kind: ServiceAccount
  name: secret-admin
  namespace: default
roleRef:
  kind: ClusterRole
  name: secret-admin-cluster
  apiGroup: rbac.authorization.k8s.io</span></pre> <p><span class="koboSpan" id="kobo.591.1">Now that we have been introduced to RBAC and how we can utilize it to secure Secrets, we can proceed to an </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">end-to-end example.</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.593.1">RBAC and Secrets</span></h2>
<p><span class="koboSpan" id="kobo.594.1">In the previous </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.595.1">example, we created roles and cluster roles for our cluster’s secret resources. </span><span class="koboSpan" id="kobo.595.2">We focused on a viewer role and an administrator role for Secrets, but it is worth seeing if there are </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">more options.</span></span></p>
<p><span class="koboSpan" id="kobo.597.1">We can identify which verbs are related to Secrets by using an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">api-resources</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.599.1"> call:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.600.1">
$ kubectl api-resources -o wide|grep secrets
secrets v1 true Secret [create delete deletecollection get list patch update watch]</span></pre> <p><span class="koboSpan" id="kobo.601.1">Now that we know what our options are, we will create our own RBAC configuration for </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">our Secrets.</span></span></p>
<h3><span class="koboSpan" id="kobo.603.1">ClusterRole</span></h3>
<p><span class="koboSpan" id="kobo.604.1">We will </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.605.1">create a cluster role for administering Secrets using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">ClusterRole</span></strong><span class="koboSpan" id="kobo.607.1"> specification in the YAML file we </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">created earlier:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.609.1">
$ kubectl create sa secret-admin
$ kubectl apply -f ./secret-admin-cluster.yaml</span></pre> <p><span class="koboSpan" id="kobo.610.1">This should create a cluster role able to administer Secrets cluster-wide. </span><span class="koboSpan" id="kobo.610.2">We will use a Pod with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">ClusterRole</span></strong><span class="koboSpan" id="kobo.612.1"> object attached and check the </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">secret creation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.614.1">
apiVersion: v1
kind: Pod
metadata:
  name: kubectl-create-secret
spec:
  containers:
  - name: kubectl
    image: bitnami/kubectl:latest
    args:
    - create
    - secret
    - generic
    - test
    - --from-literal=literal1=text-for-literal-1
  serviceAccount: secret-admin
  serviceAccountName: secret-admin</span></pre> <p><span class="koboSpan" id="kobo.615.1">By checking the logs, we should see the </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">following message:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.617.1">
secret/test created</span></pre> <p><span class="koboSpan" id="kobo.618.1">The Pod was configured with the service account, and the service account has a cluster binding to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">ClusterRole</span></strong><span class="koboSpan" id="kobo.620.1"> object with admin permissions </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">upon Secrets.</span></span></p>
<h3><span class="koboSpan" id="kobo.622.1">Role</span></h3>
<p><span class="koboSpan" id="kobo.623.1">We will use the role </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.624.1">we created earlier that provides viewer permissions </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">over Secrets:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.626.1">
$ kubectl create sa secret-viewer
$ kubectl apply -f ./secret-viewer.yaml</span></pre> <p><span class="koboSpan" id="kobo.627.1">We should now have a viewer role for Secrets on the default namespace. </span><span class="koboSpan" id="kobo.627.2">We will run a Pod to retrieve </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">the Secrets:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.629.1">
apiVersion: v1
kind: Pod
metadata:
  name: kubectl-get-secrets
spec:
  containers:
  - name: kubectl
    image: bitnami/kubectl:latest
    args:
    - get
    - secret
    - secret-toview
  serviceAccount: secret-viewer
  serviceAccountName: secret-viewer</span></pre> <h2 id="_idParaDest-60"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.630.1">Conclusion</span></h2>
<p><span class="koboSpan" id="kobo.631.1">In this section, we introduced RBAC for Secrets. </span><span class="koboSpan" id="kobo.631.2">We identified available actions for Secrets within a cluster and the distinction between </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">ClusterRole</span></strong><span class="koboSpan" id="kobo.633.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">Role</span></strong><span class="koboSpan" id="kobo.635.1"> objects. </span><span class="koboSpan" id="kobo.635.2">We then proceeded to secure secret usage within our cluster and provided fine-grained authorized access to Secrets, whether access was limited to a namespace by using a role or access was granted throughout the cluster. </span><span class="koboSpan" id="kobo.635.3">Since we have fulfilled the requirement for authorized access, another requirement that we should pay attention to is monitoring our </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">secret usage.</span></span></p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.637.1">Auditing and monitoring secret usage</span></h1>
<p><span class="koboSpan" id="kobo.638.1">To record </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.639.1">and monitor ongoing activities on a Kubernetes cluster, we have the option of auditing. </span><span class="koboSpan" id="kobo.639.2">Events that happen in a Kubernetes cluster are sent to the output stream or saved as logs; this makes it feasible to identify what happened in </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">our system.</span></span></p>
<p><span class="koboSpan" id="kobo.641.1">In our case, we want to monitor our secret usage. </span><span class="koboSpan" id="kobo.641.2">To avoid the overhead of other activities, we will focus only on audits generated </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">for Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.643.1">The audit configuration to enable audits on Secrets should be </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.645.1">
apiVersion: audit.k8s.io/v1
kind: Policy
omitStages:
  - "RequestReceived"
rules:
  - level: Metadata
    resources:
    - group: ""
      resources: ["secrets"]</span></pre> <p><span class="koboSpan" id="kobo.646.1">On a Kubernetes installation, this can be achieved by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">--audit-policy-file</span></strong><span class="koboSpan" id="kobo.648.1"> flag and passing it when </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">running </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">kube-apiserver</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.652.1">
kube-apiserver --audit-policy-file=/path/to/audit-policy.yaml</span></pre> <h2 id="_idParaDest-62"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.653.1">minikube note</span></h2>
<p><span class="koboSpan" id="kobo.654.1">In the case of minikube, we need </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.655.1">to pass the audit configuration when </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">starting minikube.</span></span></p>
<p><span class="koboSpan" id="kobo.657.1">We have summed up those actions in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">minikube-script.sh</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.659.1"> script:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.660.1">
minikube start \
  --extra-config=apiserver.audit-policy-file=/etc/ssl/certs/audit-policy.yaml \
  --extra-config=apiserver.audit-log-path=-</span></pre> <p><span class="koboSpan" id="kobo.661.1">Since we enabled auditing, let’s check </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">the logs:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.663.1">
$ kubectl logs -f kube-apiserver-minikube -n kube-system | grep audit.k8s.io/v1</span></pre> <p><span class="koboSpan" id="kobo.664.1">To trigger an audit event, we can issue a </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">secret operation:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.666.1">
$ kubectl get secret</span></pre> <p><span class="koboSpan" id="kobo.667.1">Eventually, we will receive the </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">following log:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.669.1">
{"kind":"Event",...,"verb":"list","user":{"username":"minikube-user","groups":["system:masters","system:authenticated"]},"sourceIPs":["192.168.49.1"],"...,"responseStatus":{"metadata":{},"code":200},...}</span></pre> <p><span class="koboSpan" id="kobo.670.1">We managed </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.671.1">to track and monitor changes in our Secrets thanks to enabling the auditing feature </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">of Kubernetes.</span></span></p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.673.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.674.1">In this chapter, we had a deeper dive into Kubernetes Secrets. </span><span class="koboSpan" id="kobo.674.2">We learned about the different types of Kubernetes Secrets and for which occasions they are used, and we went through executing code snippets highlighting those use cases. </span><span class="koboSpan" id="kobo.674.3">Also, since Secrets contain sensitive information, we went further into securing access to those Secrets by applying RBAC rules. </span><span class="koboSpan" id="kobo.674.4">This helped us to limit access to Secrets but also provide authorized access to our Pods. </span><span class="koboSpan" id="kobo.674.5">Another aspect that we covered is auditing. </span><span class="koboSpan" id="kobo.674.6">Auditing is a very important aspect since we want to have full control over access to Secrets as well as other operations. </span><span class="koboSpan" id="kobo.674.7">In the next chapter, we will focus on encrypting Secrets in transit and </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">at rest.</span></span></p>
</div>
</body></html>