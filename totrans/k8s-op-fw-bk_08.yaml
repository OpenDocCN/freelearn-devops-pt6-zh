- en: '*Chapter 6*: Building and Deploying Your Operator'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we have written a significant amount of code to develop an `make`
    command provided by a boilerplate Operator SDK project to build a container image
    and manually deploy that image in a running Kubernetes cluster. In addition, this
    chapter will follow up those steps with guided steps for iterative development
    in which new changes in the Operator are compiled and pushed to the cluster. Finally,
    we will offer troubleshooting resources and tips for issues that may arise during
    this process. Those sections will be broken into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a container image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying in a test cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing and testing changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that during the course of this chapter, running the Operator in a cluster
    will be done manually using local build commands. This is useful for local development
    and testing in non-production environments because it is quick and does not rely
    on additional components, minimizing the time and resources required to deploy
    proof-of-concept test cases. In a real environment, it is better to install and
    manage Operators with the **Operator Lifecycle Manager**. That process will be
    covered in more detail in [*Chapter 7*](B18147_07_ePub.xhtml#_idTextAnchor108),
    *Installing and Running Operators with the Operator Lifecycle Manager*. For now,
    we will proceed with local deployments in a test cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will rely on the code from previous chapters to build a container
    image and deploy that image in a Kubernetes cluster. As such, the technical requirements
    for this chapter necessitate access to a cluster and container management tool
    such as Docker. However, it is not explicitly required to use the code from the
    previous chapters, as the commands and processes explained will work with any
    `operator-sdk` project. Therefore, the minimum recommended requirements for this
    chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An internet connection (to pull Docker base images and push built container
    images to a public registry).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to a running Kubernetes cluster. This can be any cluster, although it
    is recommended to use a tool such as **Kubernetes in Docker** (**kind**) ([https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/))
    or **minikube** ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
    so that it is not costly to destroy and recreate clusters if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An up-to-date version of `kubectl` ([https://kubernetes.io/docs/tasks/tools/#kubectl](https://kubernetes.io/docs/tasks/tools/#kubectl))
    on your machine (in order to interact with the Kubernetes cluster).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker installed locally, as well as an account on either `Makefile` that the
    Operator SDK generates in a project assumes that the `docker` binary will be available
    locally. Therefore, additional local setup (for example, aliasing `docker` commands
    to `buildah`), which is not covered in this chapter, will be necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter introduces several of the preceding projects, some of which involve
    additional setup. In addition, a few of them (such as kind) are described in this
    tutorial only for the purposes of creating a stock test environment to follow
    along with. In these cases, alternative tools can be used as noted if you are
    more comfortable with them. For each of the technologies introduced in this chapter,
    resources are provided in the *Troubleshooting* section at the end of this chapter
    for further assistance if needed. However, the use cases with a specific technology
    in this chapter have been chosen to be fairly basic to guide toward the minimal
    risk of technical problems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Using a public registry without any access credentials will make your Operator
    image accessible to anyone on the internet. This may be fine for following a tutorial
    such as this, but for production images, you may wish to look more into securing
    your image registry (which is out of the scope of this book).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for this chapter can be viewed at: [https://bit.ly/3NdVZ7s](https://bit.ly/3NdVZ7s)'
  prefs: []
  type: TYPE_NORMAL
- en: Building a container image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is a container orchestration platform, meaning that it is designed
    to run applications that have been built into containers. Even the core system
    components for Kubernetes, such as the API server and scheduler, run as containers.
    So, it should come as no surprise that the Operators developed for Kubernetes
    must also be built and deployed as containers.
  prefs: []
  type: TYPE_NORMAL
- en: For this process, a basic understanding of the fundamentals of working with
    containers is helpful. Fortunately, however, the Operator SDK abstracts away much
    of the configuration and command-line incantations to simple `Makefile` targets.
    These are build macros that help to automate the process of compiling binaries
    and container images (as well as pushing those images to a registry and deploying
    them in a cluster).
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the full list of available targets provided by the Operator SDK, run
    the `make help` command within the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Some of these commands, such as `make manifests` and `make generate`, were used
    in earlier chapters to initialize the project and generate the Operator's API
    and `Build` heading. Specifically, `make build` and `make docker-build`, with
    the former responsible for compiling a local binary of the Operator and the latter
    building a container image.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Operator locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s examine `make build`. From `Makefile`, the definition is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This target is primarily concerned with running `go build`, which is the standard
    command to compile any `make generate`, `make fmt`, and `make vet` targets, which
    ensure that the Operator's generated API code is up to date and that the Go code
    in the project's source code conforms to the stylistic standards of the language.
    This is an added convenience and is why `Makefile` targets such as this are useful
    in development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `make build` produces the standard output that one would expect when
    compiling a Go program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When the compilation is successful, there should be no more output than the
    preceding code. Upon completion, there will now be a new executable file under
    `bin/manager`, which is the compiled Operator code. This can be run manually (or
    with `make run`) against any accessible Kubernetes cluster, but it will not actually
    be deployed in the cluster until it is built into a container image. This is what
    `make docker-build` does.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Operator image with Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The definition for `make docker-build` is slightly more interesting than the
    local `build` target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is essentially just calling `docker build` (with an added dependency to
    make a test that runs any unit tests defined in the project along with ensuring
    all generated CRD manifests and API code are up to date).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker build` command will instruct the local Docker daemon to construct
    a container image from the Dockerfile in the root of the Operator''s project directory.
    This file was originally generated by the initial `operator-sdk init` command
    from when the project was first created. We have made a very slight modification
    (which will be explained here), so the file now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the exact details about how this Dockerfile works are a more advanced
    topic in regard to container builds. It''s not critical to understand each of
    these in depth (just one benefit of using the Operator SDK to generate the file!),
    but we will summarize them here. These steps roughly break down into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the base image for the Operator to build with Go 1.17.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the Go module dependency files to the new image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the module dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the main Operator code, including `main.go`, `api/`, `controllers/`, and
    `assets/` to the new image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this project, we have modified the default Dockerfile to copy the `assets/`
    directory. When it is generated by `operator-sdk`, this Dockerfile only copies
    `main.go` and the `api/` and `controllers/` directories by default. Since the
    tutorial for our nginx Operator included adding a new top-level package under
    `assets/`, we need to ensure that this directory is also included in the Operator
    image. This serves as an example to demonstrate that it is okay to modify the
    project's default Dockerfile (however, using version control or otherwise making
    backups is recommended).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Alternatively, the `assets` package could have been created under the `controllers/`
    folder, which would not have required any updates to the Dockerfile (because it
    would have been included under the existing `COPY controllers/ controllers/` line).
    See the *Troubleshooting* section of this chapter for more information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compile the Operator binary within the image. This is the same as building the
    Operator locally (as shown previously), except it will be packaged within a container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the Operator's binary as the main command for the built container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the preceding Dockerfile (including the change to include `COPY assets/
    assets/`), running `make docker-build` will successfully complete. But, before
    we do that, first note that this command includes a variable that we have not
    yet discussed: `${IMG}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Makefile` command uses this `IMG` variable to define the tag for the compiled
    image. That variable is defined earlier in `Makefile` with a default value of
    `controller:latest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This is helpful to know because, without updating this variable, the built
    image for our Operator will simply have the name `controller`. In order to build
    an image with a tag that references our actual container registry (for example,
    `docker.io/myregistry`) the `build` command can be invoked like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Some output has been omitted, but the important parts to note are the `builder`
    steps, which have been included. These follow the steps as defined in the project's
    Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a container image successfully built, the new image should now be present
    on your local machine. You can confirm this by running `docker images`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will push this image to a public registry and deploy
    the Operator in a running Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying in a test cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the Operator has been built into a container image, it can be deployed
    in a cluster as a container. To do this, you will first need to ensure that you
    have access to a running cluster as well as a public image registry. To host your
    image in a registry, you can obtain a free personal account on **Docker Hub**
    ([https://hub.docker.com](https://hub.docker.com)).
  prefs: []
  type: TYPE_NORMAL
- en: For this tutorial, we will be using a local Kubernetes cluster created with
    kind, which deploys a running Kubernetes cluster within Docker containers rather
    than directly on the local machine, and is available at [https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/).
    However, the steps described here will be agnostic to any Kubernetes cluster running
    the latest version of the platform. For example, if you are more comfortable using
    development environments such as minikube (or have another cluster already available),
    then you can skip the kind setup shown in this section. The rest of the steps
    in this section will apply to any Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a local cluster with kind, ensure that you have Docker and kind installed
    on your machine and run `kind create cluster`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `kind create cluster` may take a moment to complete. This bootstraps
    a functional Kubernetes cluster running within Docker. You can confirm that your
    cluster is accessible by running any `kubectl` command, for example, `kubectl
    cluster-info`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With a cluster running, it's time to make the Operator's image accessible by
    pushing it to a public registry. First, ensure that you have access to your registry.
    For Docker Hub, this means running `docker login` and entering your username and
    password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once logged in, you can push the image using the provided `Makefile` `make
    docker-push` target (which is simply the equivalent of manually running `docker
    push`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: (This command may take a moment to run, and your exact output may differ.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we have still passed the `IMG` variable to this command. To eliminate
    the need to do this, you can either modify `Makefile` to change the default definition
    of the variable (this definition was shown in the *Building a container image*
    section earlier) or export your image name as an environment variable, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, the image is available publicly on the internet. You may wish to manually
    confirm that your image is accessible by running `docker pull <image>`, but this
    is not required.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Docker Hub
  prefs: []
  type: TYPE_NORMAL
- en: You technically do not have to use a public registry such as Docker Hub to make
    your image accessible to the cluster. There are alternative ways of importing
    your image into the cluster, for example, kind provides the `kind load docker-image`
    command, which manually loads the image into your cluster's internal registry
    (see [https://kind.sigs.k8s.io/docs/user/quick-start/#loading-an-image-into-your-cluster](https://kind.sigs.k8s.io/docs/user/quick-start/#loading-an-image-into-your-cluster)
    for more information). However, in this tutorial, we have chosen the public registry
    route as it is a common approach (especially for open source Operators that are
    published for others to use) and remains agnostic to the specific cluster you
    may be running.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Operator image accessible (and the public image name defined in an
    environment variable or modified in `Makefile`, as shown earlier), all that is
    required to run the Operator in a cluster now is the `make deploy` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you will see a new namespace in your cluster that matches the Operator''s
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring this namespace deeper with `kubectl get all` will show that it contains
    a **Deployment**, **ReplicaSet**, **Service**, and **Pod** for the Operator (some
    output has been omitted for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'But where is the operand nginx Pod? Recall that we designed the Operator to
    do nothing if it cannot locate an instance of its CRD. To remedy this, you can
    create your first CRD object (matching the API defined in [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK*) like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'sample-cr.yaml:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Create this file and save it anywhere on your machine as any name (in this
    case, `sample-cr.yaml` is fine). Then, run `kubectl create -f sample-cr.yaml`
    to create the custom resource object in the nginx Operator''s namespace. Now,
    running `kubectl get pods` will show that the new nginx Pod (named `cluster-xxx`)
    has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can modify the custom resource object you just created with `kubectl edit
    nginxoperators/cluster -n nginx-operator-system`. This command (`kubectl edit`)
    will open your local text editor where you can make changes directly to the object''s
    `spec` fields. For example, to change the number of operand replicas, we can run
    the preceding command and set `spec.replicas: 2`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: $ kubectl edit nginxoperators/cluster -n nginx-operator-system
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that when using `kubectl edit`, other fields in the Operator (such as
    `status`) are also visible. While you cannot directly modify these fields, this
    is a good spot to point out that our Operator conditions are successfully reporting
    in the CRD''s `status` section. This is indicated by the `OperatorDegraded: False`
    condition type and status.'
  prefs: []
  type: TYPE_NORMAL
- en: However, take note that this condition may initially be confusing to users because
    it appears to be indicating that `OperatorSucceeded` is `False` at first glance.
    But, upon further inspection, it is indicated that `OperatorSucceeded` is actually
    the reason for `OperatorDegraded` to be `False`. In other words, the *Operator*
    is *not* degraded because the Operator *succeeded*. This example has intentionally
    been chosen to highlight the care that must be taken to implement informative
    and clearly understandable status conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Saving the changes to the CRD object and running `kubectl get` pods again now
    shows a new nginx Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, changing the `spec.replicas` field to `0` will delete all of the
    nginx Pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This concludes the basic deployment steps for an Operator. The following steps
    summarize what we have done so far:'
  prefs: []
  type: TYPE_NORMAL
- en: Built a container image for the Operator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pushed the image to a public registry
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Used `make deploy` to launch the Operator in a local cluster (in the process,
    pulling the image from the public registry into the cluster)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Manually created an instance of the Operator's CRD object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modified the CRD object within the cluster using `kubectl edit`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, there is still some work to be done in order to enable metrics (which
    was a big part of the work done in [*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078),
    *Developing an Operator – Advanced Functionality*, and key to achieving higher-level
    functionality within the **capability model**). In the next section, we will demonstrate
    how to make changes to our Operator's deployment and redeploy it in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing and testing changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the course of development (for any project, not just Kubernetes Operators)
    it will likely become necessary to make changes to the code or other project files
    (such as resource manifests) and test those changes. In the case of this example,
    we will not be changing any code. Instead, we will redeploy the Operator with
    the proper metrics resources created to make the metrics visible, which we implemented
    in [*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078), *Developing an Operator
    – Advanced Functionality*.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring kube-prometheus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Metrics are not very useful without a tool to scrape and present them. This
    is what Prometheus is for, and it understands the metrics language in which we
    have implemented our own metrics. There are a number of other tools that can parse
    Prometheus metrics. In this tutorial, we will use **kube-prometheus** ([https://github.com/prometheus-operator/kube-prometheus](https://github.com/prometheus-operator/kube-prometheus))
    to install a full end-to-end monitoring stack in our cluster. kube-prometheus
    provides a number of additional features that we won't explicitly explore in this
    book, but it is a very convenient and powerful library for installing monitoring
    in a cluster. In your own environment, you may choose another option, such as
    installing Prometheus directly or using the Prometheus Operator from [https://github.com/prometheus-operator/prometheus-operator](https://github.com/prometheus-operator/prometheus-operator)
    (which is provided by kube-prometheus).
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, follow the steps at [https://github.com/prometheus-operator/kube-prometheus](https://github.com/prometheus-operator/kube-prometheus)
    installing to install kube-prometheus in our Operator project. Take note of the
    prerequisites for the *Installing* and *Compiling* sections in that link. Specifically,
    the following tools are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gojsontoyaml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jsonnet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When kube-prometheus has been successfully installed in the project, we will
    have a new subdirectory (`my-kube-prometheus`, as described in the kube-prometheus
    documentation), which contains the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will modify `example.jsonnet` to include our Operator''s namespace.
    This means modifying the `values+::` block within the file to add a `prometheus+`
    object that includes a list of namespaces (in our case, only the `nginx-operator-system`
    namespace):'
  prefs: []
  type: TYPE_NORMAL
- en: 'my-kube-prometheus/example.jsonnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use `build.sh` to compile the new manifests by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create the `kube-prometheus` manifests in our cluster by applying
    them with the following commands (from within the `my-kube-prometheus` directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'When finished, the Prometheus dashboard should be accessible by running the
    following commands to open a local proxy to your cluster and the Prometheus service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: (Note, this command will remain running until you manually end it, for example,
    by pressing *Ctrl* + *C*.) The dashboard will be visible by navigating to `http://localhost:9090`
    in your web browser. However, if you try to search for our Operator's metric (recall
    that it was named `reconciles_total`), you will see that it is not available.
    This is because we need to redeploy our Operator with an additional manifest that
    is not created by default.
  prefs: []
  type: TYPE_NORMAL
- en: Redeploying the Operator with metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prometheus knows to scrape our Operator's namespace for metrics due to the configuration
    created previously. However, it still needs to know which specific endpoint within
    the namespace to query. This is the role of an object called `ServiceMonitor`
    ([https://pkg.go.dev/github.com/coreos/prometheus-operator/pkg/apis/monitoring/v1#ServiceMonitor](https://pkg.go.dev/github.com/coreos/prometheus-operator/pkg/apis/monitoring/v1#ServiceMonitor)).
    This object is not created by default by the Operator SDK when running `make deploy`,
    so we need to modify `config/default/kustomization.yaml`. (This file location
    is relative to the project root directory, not the new `my-kube-prometheus` directory
    that we created previously when installing kube-prometheus).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this file, simply find any lines that are marked with `[PROMETHEUS]` and
    uncomment them by removing the leading pound or the hash symbol (`#`). This is
    currently only one line, shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'config/default/kustomization.yaml:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This is the default configuration file for **Kustomize** ([https://kustomize.io/](https://kustomize.io/)),
    which is a Kubernetes templating project that the Operator SDK uses to generate
    and deploy project manifests.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you can run `make undeploy` to remove the current Operator installation,
    followed by running `make deploy` once again to recreate it. After a few moments,
    the `reconciles_total` metric should be visible in the Prometheus dashboard. The
    following screenshot shows this metric in the Prometheus dashboard search bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Screenshot of the Prometheus dashboard](img/B18147_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Screenshot of the Prometheus dashboard
  prefs: []
  type: TYPE_NORMAL
- en: Key takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While this section may seem focused on just setting up metrics, it actually
    covers some important steps related to the development-driven redeployment of
    an Operator project. Specifically, we covered the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing `kube-prometheus` as a library in our project and configuring it
    to scrape our Operator's namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying Kustomize configuration files to include new dependencies in our Operator
    deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `make undeploy` to remove the existing Operator deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technically, we could have simply run `make deploy` without first undeploying
    the project. The idempotent nature of Kubernetes resource manifests means that
    only the new resources would have been created. However, awareness of `make undeploy`
    is very useful in cases where the existing project may need to be completely removed.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced several new tools and concepts not yet covered by earlier
    chapters. These include Docker, kind, kubectl, Make, and kube-prometheus. It is
    possible that you may have run into some issues while working with these tools,
    so this section is intended to offer links to references that can help resolve
    common issues. Many of the underlying tools used in this chapter are not exclusive
    to the Operator Framework, which thankfully means that there is a wealth of resources
    available to address problems you may encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Makefile issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Make** ([https://www.gnu.org/software/make/](https://www.gnu.org/software/make/))
    is a very popular tool for automating the generation and compilation of countless
    software projects. It was already used in [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK,* and [*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078),
    *Developing an Operator – Advanced Functionality*, in order to generate the APIs
    and manifests used by our project. In this chapter, it was leveraged even more
    to automate many of the commands for building and deploying.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the `make ...` commands used throughout this book are shorthand for
    running underlying tools. Therefore, when encountering an error with any `make`
    commands, the first debugging step is to examine the `Makefile` to find what that
    command is actually running. If this happens, you will likely find that you are
    rather encountering an issue with Docker, Go, or Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: These commands have been preemptively provided when `operator-sdk` initialized
    the project, but you are free to modify the provided `Makefile` as you wish to
    customize your project.
  prefs: []
  type: TYPE_NORMAL
- en: kind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we used kind to deploy a test Kubernetes cluster. Using kind
    offers a very quick way to create (and destroy) local Kubernetes clusters. It
    also provides a configurable setup that allows for relatively easy changes to
    the default cluster (for example, starting a cluster with additional nodes).
  prefs: []
  type: TYPE_NORMAL
- en: The official website for kind is [https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/).
    The website provides extensive documentation and sample configurations for different
    cluster setups. In addition, the kind code base is available on GitHub at [https://github.com/kubernetes-sigs/kind](https://github.com/kubernetes-sigs/kind).
    The kind maintainers and users are also active on the official Kubernetes Slack
    server ([slack.k8s.io](http://slack.k8s.io)) in the **#kind** channel. Both of
    these links are excellent resources for asking questions or searching for answers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are working with Kubernetes, you are likely already familiar with Docker
    ([https://www.docker.com/](https://www.docker.com/)). It is just one of several
    options for building and managing container images, which are essential for deploying
    applications on Kubernetes. The key step for transitioning Operator code to a
    deployable image is the `docker build` command (which is called when running `make
    docker-build`). This command follows the `build` steps defined in the Dockerfile.
    More information on Dockerfile syntax is available in the Docker documentation
    at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  prefs: []
  type: TYPE_NORMAL
- en: When building a container image following the steps in this chapter, there are
    some unique issues specific to this tutorial that you may encounter, which are
    explained next.
  prefs: []
  type: TYPE_NORMAL
- en: docker build fails with no required module error for assets package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When running `make docker-build`, you may find that your build fails with the
    following error (or something similar):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: This error is actually arising from the `go build` command in the final step
    of the Dockerfile. In the context of this specific tutorial, Go is failing to
    build because it cannot locate the `assets` package (created in [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK*, to organize and access the operand
    Deployment manifest).
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, ensure that you have modified the Dockerfile to include the `COPY
    assets/ assets/` directive (see the example in the *Building a container image*
    section of this chapter). Alternatively, you could refactor the Operator code
    to embed the `assets/` directory within the existing `controllers/` directory
    without needing to modify the Dockerfile. This is because both `controllers/`
    and `api/` are already copied to the `builder` image (but it does not semantically
    make sense to store embedded manifests within the API directory, as they are not
    an API).
  prefs: []
  type: TYPE_NORMAL
- en: docker push fails with access denied
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `make docker-push` command may fail with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This exact error (including the `docker push controller:latest` line) implies
    a misconfigured `IMG` variable for the command. Recall that in the *Building a
    container image* section of this chapter, this variable was discussed as a way
    to tag the built image with an appropriate name. There are a few options for setting
    this value, either as an environment variable or by modifying the `Makefile`.
  prefs: []
  type: TYPE_NORMAL
- en: However you choose to update this variable, it is important to check that the
    value is propagated to the `docker-push` target in the `Makefile` as well. Otherwise,
    Docker will attempt to push this to a generic registry for library images. You
    do not have access to this registry, therefore, Docker returns the `access denied`
    error shown here.
  prefs: []
  type: TYPE_NORMAL
- en: If instead, the error does include the appropriate public registry with your
    `IMG` variable value (for example, the second line is `docker push docker.io/yourregistry/yourimagename`)
    then it is likely a simple authentication error. Run `docker login` to make sure
    you are logged into your Docker Hub account.
  prefs: []
  type: TYPE_NORMAL
- en: Operator deploys but fails to start with ImagePull error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you run `make deploy`, the command will likely always complete successfully
    (unless you have made significant modifications to the generated manifest files).
    However, when viewing the Operator in your cluster (for example, with `kubectl
    get all -n nginx-operator-system`) you may see that the Operator''s Pod is failing
    to start with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: This is probably a similar error to the one described previously. In Kubernetes,
    the `ImagePullBackOff` error indicates that, for some reason, the Pod is unable
    to pull the container image it is intended to run. This is usually either an authentication
    error (for example, the registry may be private) or the image is not found. Ensure
    that you have built and pushed the Operator image with the right `IMG` environment
    variable set, as mentioned in the other *Troubleshooting* sections. If you still
    see the error, check to make sure that your image registry is not set to private
    by logging into the Docker Hub web UI.
  prefs: []
  type: TYPE_NORMAL
- en: Operator deploys but fails to start with another error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Kubernetes, there are many reasons why any given Pod may fail to start. There
    could be a logical bug in the Operator's code or there may be a system configuration
    issue within the cluster. There is, unfortunately, no *one-size-fits-all* solution
    to this problem. However, there are tools to gather more information. Using `kubectl`
    to inspect the Pod is the most common way to diagnose errors. For example, `kubectl
    describe pod/<podname>` will print events and status updates that can explain
    the failure. Or, `kubectl logs pod/<podname>` will print the log output of the
    Pod (which is helpful for diagnosing runtime errors that usually need to be fixed
    in code). All of the `kubectl` commands will provide documentation by running
    `kubectl -h`.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As part of developing an Operator with rich features and debugging capabilities,
    this and previous chapters dedicated effort to demonstrating the implementation
    of Prometheus metrics. Prometheus ([https://prometheus.io/](https://prometheus.io/))
    is an open source monitoring platform that is widely used in the Kubernetes ecosystem.
    Therefore, there are many resources available online for various problems (many
    are not specific to the Operator Framework). These community resources are documented
    at [https://prometheus.io/community/](https://prometheus.io/community/).
  prefs: []
  type: TYPE_NORMAL
- en: Operator metrics do not show up in Prometheus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With Prometheus deployed in a cluster following the `kube-prometheus` steps
    in this tutorial, the custom metrics defined in our Operator code should show
    up in the Prometheus dashboard after a few moments. If, after some time, the custom
    metrics are still not visible, ensure that you have made the correct changes described
    in the *Installing and configuring kube-prometheus* section to instruct Prometheus
    to scrape the Operator's namespace for new metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, make sure that you have uncommented the `- ../prometheus` line
    in `config/default/kustomization.yaml` before deploying the Operator as described
    in the *Redeploying the Operator with metrics* section. This step ensures that
    the `ServiceMonitor` object (which informs Prometheus which endpoint to scrape
    for metrics) is created in the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Operator deployment fails with no matches for kind 'ServiceMonitor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When running `make deploy`, the following error may appear among several other
    lines showing which resources were created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the Operator did not actually fail to deploy. However, it did
    fail to create the `ServiceMonitor` object due to an inability to locate the object's
    definition in the Kubernetes API. This is likely due to failing to install Prometheus
    in the cluster before attempting to deploy the Operator with metrics. Specifically,
    `ServiceMonitor` is a CRD that is provided by Prometheus. So, deploying the Operator
    with metrics before installing `kube-prometheus` in this tutorial will lead to
    failures when reporting metrics. To resolve this, ensure that you have followed
    the steps for installing Prometheus before deploying the Operator with metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Additional errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding issues are just some of the technical problems that may arise
    when following this tutorial. It is, unfortunately, not possible for this chapter
    to cover every scenario. However, the Operator Framework community and its resources
    provide solutions to many different types of problems. These, along with the resources
    in the *Troubleshooting* section of [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK*, are very likely to resolve any
    difficulty that you may face.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter's main objective was to compile the Operator code that we have
    been building throughout this book and deploy it in a cluster. To do this, we
    followed steps designed for local development environments. These included building
    the Operator as a local binary and building a container image to deploy in an
    ephemeral test cluster (created using kind). This lightweight process is helpful
    for development and rapid testing, but it lacks the full workflow benefits needed
    for publishing an Operator with the intent of deploying in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will explore the final pillars of the Operator Framework:
    **OperatorHub** and the **Operator Lifecycle Manager**. Learning how to prepare
    and submit an Operator to OperatorHub will be a key part of offering any Operator
    available for public use. With that, the Operator Lifecycle Manager is a much
    more elegant solution for deploying Operators (both publicly available on OperatorHub
    or privately deployed). Compared to deploying manually with Make, these processes
    are much better suited for sharing your Operator with the world.'
  prefs: []
  type: TYPE_NORMAL
