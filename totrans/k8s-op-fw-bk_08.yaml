- en: '*Chapter 6*: Building and Deploying Your Operator'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we have written a significant amount of code to develop an `make`
    command provided by a boilerplate Operator SDK project to build a container image
    and manually deploy that image in a running Kubernetes cluster. In addition, this
    chapter will follow up those steps with guided steps for iterative development
    in which new changes in the Operator are compiled and pushed to the cluster. Finally,
    we will offer troubleshooting resources and tips for issues that may arise during
    this process. Those sections will be broken into the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Building a container image
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying in a test cluster
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing and testing changes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that during the course of this chapter, running the Operator in a cluster
    will be done manually using local build commands. This is useful for local development
    and testing in non-production environments because it is quick and does not rely
    on additional components, minimizing the time and resources required to deploy
    proof-of-concept test cases. In a real environment, it is better to install and
    manage Operators with the **Operator Lifecycle Manager**. That process will be
    covered in more detail in [*Chapter 7*](B18147_07_ePub.xhtml#_idTextAnchor108),
    *Installing and Running Operators with the Operator Lifecycle Manager*. For now,
    we will proceed with local deployments in a test cluster.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will rely on the code from previous chapters to build a container
    image and deploy that image in a Kubernetes cluster. As such, the technical requirements
    for this chapter necessitate access to a cluster and container management tool
    such as Docker. However, it is not explicitly required to use the code from the
    previous chapters, as the commands and processes explained will work with any
    `operator-sdk` project. Therefore, the minimum recommended requirements for this
    chapter are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: An internet connection (to pull Docker base images and push built container
    images to a public registry).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to a running Kubernetes cluster. This can be any cluster, although it
    is recommended to use a tool such as **Kubernetes in Docker** (**kind**) ([https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/))
    or **minikube** ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
    so that it is not costly to destroy and recreate clusters if needed.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An up-to-date version of `kubectl` ([https://kubernetes.io/docs/tasks/tools/#kubectl](https://kubernetes.io/docs/tasks/tools/#kubectl))
    on your machine (in order to interact with the Kubernetes cluster).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker installed locally, as well as an account on either `Makefile` that the
    Operator SDK generates in a project assumes that the `docker` binary will be available
    locally. Therefore, additional local setup (for example, aliasing `docker` commands
    to `buildah`), which is not covered in this chapter, will be necessary.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter introduces several of the preceding projects, some of which involve
    additional setup. In addition, a few of them (such as kind) are described in this
    tutorial only for the purposes of creating a stock test environment to follow
    along with. In these cases, alternative tools can be used as noted if you are
    more comfortable with them. For each of the technologies introduced in this chapter,
    resources are provided in the *Troubleshooting* section at the end of this chapter
    for further assistance if needed. However, the use cases with a specific technology
    in this chapter have been chosen to be fairly basic to guide toward the minimal
    risk of technical problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Using a public registry without any access credentials will make your Operator
    image accessible to anyone on the internet. This may be fine for following a tutorial
    such as this, but for production images, you may wish to look more into securing
    your image registry (which is out of the scope of this book).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for this chapter can be viewed at: [https://bit.ly/3NdVZ7s](https://bit.ly/3NdVZ7s)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Building a container image
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is a container orchestration platform, meaning that it is designed
    to run applications that have been built into containers. Even the core system
    components for Kubernetes, such as the API server and scheduler, run as containers.
    So, it should come as no surprise that the Operators developed for Kubernetes
    must also be built and deployed as containers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: For this process, a basic understanding of the fundamentals of working with
    containers is helpful. Fortunately, however, the Operator SDK abstracts away much
    of the configuration and command-line incantations to simple `Makefile` targets.
    These are build macros that help to automate the process of compiling binaries
    and container images (as well as pushing those images to a registry and deploying
    them in a cluster).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the full list of available targets provided by the Operator SDK, run
    the `make help` command within the project:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Some of these commands, such as `make manifests` and `make generate`, were used
    in earlier chapters to initialize the project and generate the Operator's API
    and `Build` heading. Specifically, `make build` and `make docker-build`, with
    the former responsible for compiling a local binary of the Operator and the latter
    building a container image.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Building the Operator locally
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s examine `make build`. From `Makefile`, the definition is simple:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This target is primarily concerned with running `go build`, which is the standard
    command to compile any `make generate`, `make fmt`, and `make vet` targets, which
    ensure that the Operator's generated API code is up to date and that the Go code
    in the project's source code conforms to the stylistic standards of the language.
    This is an added convenience and is why `Makefile` targets such as this are useful
    in development.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `make build` produces the standard output that one would expect when
    compiling a Go program:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When the compilation is successful, there should be no more output than the
    preceding code. Upon completion, there will now be a new executable file under
    `bin/manager`, which is the compiled Operator code. This can be run manually (or
    with `make run`) against any accessible Kubernetes cluster, but it will not actually
    be deployed in the cluster until it is built into a container image. This is what
    `make docker-build` does.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Building the Operator image with Docker
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The definition for `make docker-build` is slightly more interesting than the
    local `build` target:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is essentially just calling `docker build` (with an added dependency to
    make a test that runs any unit tests defined in the project along with ensuring
    all generated CRD manifests and API code are up to date).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker build` command will instruct the local Docker daemon to construct
    a container image from the Dockerfile in the root of the Operator''s project directory.
    This file was originally generated by the initial `operator-sdk init` command
    from when the project was first created. We have made a very slight modification
    (which will be explained here), so the file now looks like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Dockerfile:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that the exact details about how this Dockerfile works are a more advanced
    topic in regard to container builds. It''s not critical to understand each of
    these in depth (just one benefit of using the Operator SDK to generate the file!),
    but we will summarize them here. These steps roughly break down into the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Set the base image for the Operator to build with Go 1.17.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the Go module dependency files to the new image.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the module dependencies.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the main Operator code, including `main.go`, `api/`, `controllers/`, and
    `assets/` to the new image.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this project, we have modified the default Dockerfile to copy the `assets/`
    directory. When it is generated by `operator-sdk`, this Dockerfile only copies
    `main.go` and the `api/` and `controllers/` directories by default. Since the
    tutorial for our nginx Operator included adding a new top-level package under
    `assets/`, we need to ensure that this directory is also included in the Operator
    image. This serves as an example to demonstrate that it is okay to modify the
    project's default Dockerfile (however, using version control or otherwise making
    backups is recommended).
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Alternatively, the `assets` package could have been created under the `controllers/`
    folder, which would not have required any updates to the Dockerfile (because it
    would have been included under the existing `COPY controllers/ controllers/` line).
    See the *Troubleshooting* section of this chapter for more information.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compile the Operator binary within the image. This is the same as building the
    Operator locally (as shown previously), except it will be packaged within a container.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the Operator's binary as the main command for the built container.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the preceding Dockerfile (including the change to include `COPY assets/
    assets/`), running `make docker-build` will successfully complete. But, before
    we do that, first note that this command includes a variable that we have not
    yet discussed: `${IMG}`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Makefile` command uses this `IMG` variable to define the tag for the compiled
    image. That variable is defined earlier in `Makefile` with a default value of
    `controller:latest`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is helpful to know because, without updating this variable, the built
    image for our Operator will simply have the name `controller`. In order to build
    an image with a tag that references our actual container registry (for example,
    `docker.io/myregistry`) the `build` command can be invoked like so:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Some output has been omitted, but the important parts to note are the `builder`
    steps, which have been included. These follow the steps as defined in the project's
    Dockerfile.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'With a container image successfully built, the new image should now be present
    on your local machine. You can confirm this by running `docker images`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the next section, we will push this image to a public registry and deploy
    the Operator in a running Kubernetes cluster.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Deploying in a test cluster
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the Operator has been built into a container image, it can be deployed
    in a cluster as a container. To do this, you will first need to ensure that you
    have access to a running cluster as well as a public image registry. To host your
    image in a registry, you can obtain a free personal account on **Docker Hub**
    ([https://hub.docker.com](https://hub.docker.com)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: For this tutorial, we will be using a local Kubernetes cluster created with
    kind, which deploys a running Kubernetes cluster within Docker containers rather
    than directly on the local machine, and is available at [https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/).
    However, the steps described here will be agnostic to any Kubernetes cluster running
    the latest version of the platform. For example, if you are more comfortable using
    development environments such as minikube (or have another cluster already available),
    then you can skip the kind setup shown in this section. The rest of the steps
    in this section will apply to any Kubernetes cluster.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a local cluster with kind, ensure that you have Docker and kind installed
    on your machine and run `kind create cluster`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that `kind create cluster` may take a moment to complete. This bootstraps
    a functional Kubernetes cluster running within Docker. You can confirm that your
    cluster is accessible by running any `kubectl` command, for example, `kubectl
    cluster-info`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With a cluster running, it's time to make the Operator's image accessible by
    pushing it to a public registry. First, ensure that you have access to your registry.
    For Docker Hub, this means running `docker login` and entering your username and
    password.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Once logged in, you can push the image using the provided `Makefile` `make
    docker-push` target (which is simply the equivalent of manually running `docker
    push`):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: (This command may take a moment to run, and your exact output may differ.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we have still passed the `IMG` variable to this command. To eliminate
    the need to do this, you can either modify `Makefile` to change the default definition
    of the variable (this definition was shown in the *Building a container image*
    section earlier) or export your image name as an environment variable, like so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, the image is available publicly on the internet. You may wish to manually
    confirm that your image is accessible by running `docker pull <image>`, but this
    is not required.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Docker Hub
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: You technically do not have to use a public registry such as Docker Hub to make
    your image accessible to the cluster. There are alternative ways of importing
    your image into the cluster, for example, kind provides the `kind load docker-image`
    command, which manually loads the image into your cluster's internal registry
    (see [https://kind.sigs.k8s.io/docs/user/quick-start/#loading-an-image-into-your-cluster](https://kind.sigs.k8s.io/docs/user/quick-start/#loading-an-image-into-your-cluster)
    for more information). However, in this tutorial, we have chosen the public registry
    route as it is a common approach (especially for open source Operators that are
    published for others to use) and remains agnostic to the specific cluster you
    may be running.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Operator image accessible (and the public image name defined in an
    environment variable or modified in `Makefile`, as shown earlier), all that is
    required to run the Operator in a cluster now is the `make deploy` command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, you will see a new namespace in your cluster that matches the Operator''s
    name:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Exploring this namespace deeper with `kubectl get all` will show that it contains
    a **Deployment**, **ReplicaSet**, **Service**, and **Pod** for the Operator (some
    output has been omitted for brevity):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'But where is the operand nginx Pod? Recall that we designed the Operator to
    do nothing if it cannot locate an instance of its CRD. To remedy this, you can
    create your first CRD object (matching the API defined in [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK*) like the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'sample-cr.yaml:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create this file and save it anywhere on your machine as any name (in this
    case, `sample-cr.yaml` is fine). Then, run `kubectl create -f sample-cr.yaml`
    to create the custom resource object in the nginx Operator''s namespace. Now,
    running `kubectl get pods` will show that the new nginx Pod (named `cluster-xxx`)
    has been created:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can modify the custom resource object you just created with `kubectl edit
    nginxoperators/cluster -n nginx-operator-system`. This command (`kubectl edit`)
    will open your local text editor where you can make changes directly to the object''s
    `spec` fields. For example, to change the number of operand replicas, we can run
    the preceding command and set `spec.replicas: 2`, like so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以使用 `kubectl edit nginxoperators/cluster -n nginx-operator-system` 修改刚刚创建的自定义资源对象。此命令（`kubectl
    edit`）将打开本地文本编辑器，您可以直接修改对象的 `spec` 字段。例如，要更改操作数副本的数量，可以运行前面的命令并设置 `spec.replicas:
    2`，如下所示：'
- en: $ kubectl edit nginxoperators/cluster -n nginx-operator-system
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: $ kubectl edit nginxoperators/cluster -n nginx-operator-system
- en: '[PRE48]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Notice that when using `kubectl edit`, other fields in the Operator (such as
    `status`) are also visible. While you cannot directly modify these fields, this
    is a good spot to point out that our Operator conditions are successfully reporting
    in the CRD''s `status` section. This is indicated by the `OperatorDegraded: False`
    condition type and status.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，使用`kubectl edit`时，Operator中的其他字段（如`status`）也可见。虽然无法直接修改这些字段，但这是一个很好的地方，可以指出我们的
    Operator 条件已成功报告在 CRD 的 `status` 部分。通过 `OperatorDegraded: False` 条件类型和状态可以看出这一点。'
- en: However, take note that this condition may initially be confusing to users because
    it appears to be indicating that `OperatorSucceeded` is `False` at first glance.
    But, upon further inspection, it is indicated that `OperatorSucceeded` is actually
    the reason for `OperatorDegraded` to be `False`. In other words, the *Operator*
    is *not* degraded because the Operator *succeeded*. This example has intentionally
    been chosen to highlight the care that must be taken to implement informative
    and clearly understandable status conditions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，这个条件最初可能会让用户感到困惑，因为它似乎表明 `OperatorSucceeded` 是 `False`。但经过进一步检查后，可以看出
    `OperatorSucceeded` 实际上是 `OperatorDegraded` 为 `False` 的原因。换句话说，*Operator* 并未 *降级*，因为
    Operator *成功* 了。这个例子被特意选择出来，强调在实现具有信息量且易于理解的状态条件时必须小心。
- en: 'Saving the changes to the CRD object and running `kubectl get` pods again now
    shows a new nginx Pod:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 保存对 CRD 对象的更改后，再次运行 `kubectl get` pods 现在会显示一个新的 nginx Pod：
- en: '[PRE66]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Similarly, changing the `spec.replicas` field to `0` will delete all of the
    nginx Pods:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，将 `spec.replicas` 字段更改为 `0` 将删除所有 nginx Pods：
- en: '[PRE67]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This concludes the basic deployment steps for an Operator. The following steps
    summarize what we have done so far:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了 Operator 的基本部署步骤。以下步骤总结了我们迄今为止所做的工作：
- en: Built a container image for the Operator
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 Operator 构建了容器镜像
- en: Pushed the image to a public registry
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将镜像推送到公共注册表
- en: Used `make deploy` to launch the Operator in a local cluster (in the process,
    pulling the image from the public registry into the cluster)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`make deploy`在本地集群中启动 Operator（在此过程中，将镜像从公共注册表拉取到集群中）
- en: Manually created an instance of the Operator's CRD object
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动创建了 Operator 的 CRD 对象实例
- en: Modified the CRD object within the cluster using `kubectl edit`
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `kubectl edit` 修改了集群中的 CRD 对象
- en: However, there is still some work to be done in order to enable metrics (which
    was a big part of the work done in [*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078),
    *Developing an Operator – Advanced Functionality*, and key to achieving higher-level
    functionality within the **capability model**). In the next section, we will demonstrate
    how to make changes to our Operator's deployment and redeploy it in the cluster.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然需要一些工作来启用指标（这也是在[*第5章*](B18147_05_ePub.xhtml#_idTextAnchor078)《开发 Operator
    – 高级功能》中的一个重要部分，并且是实现 **能力模型** 中更高级功能的关键）。在下一部分中，我们将展示如何修改我们的 Operator 部署并重新部署到集群中。
- en: Pushing and testing changes
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推送并测试更改
- en: During the course of development (for any project, not just Kubernetes Operators)
    it will likely become necessary to make changes to the code or other project files
    (such as resource manifests) and test those changes. In the case of this example,
    we will not be changing any code. Instead, we will redeploy the Operator with
    the proper metrics resources created to make the metrics visible, which we implemented
    in [*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078), *Developing an Operator
    – Advanced Functionality*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中（无论是任何项目，不仅仅是 Kubernetes Operator），可能需要对代码或其他项目文件（如资源清单）进行更改并测试这些更改。在此示例中，我们不会更改任何代码。相反，我们将重新部署
    Operator，并创建正确的指标资源以使指标可见，这一点我们在 [*第5章*](B18147_05_ePub.xhtml#_idTextAnchor078)《开发
    Operator – 高级功能》中实现了。
- en: Installing and configuring kube-prometheus
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置 kube-prometheus
- en: Metrics are not very useful without a tool to scrape and present them. This
    is what Prometheus is for, and it understands the metrics language in which we
    have implemented our own metrics. There are a number of other tools that can parse
    Prometheus metrics. In this tutorial, we will use **kube-prometheus** ([https://github.com/prometheus-operator/kube-prometheus](https://github.com/prometheus-operator/kube-prometheus))
    to install a full end-to-end monitoring stack in our cluster. kube-prometheus
    provides a number of additional features that we won't explicitly explore in this
    book, but it is a very convenient and powerful library for installing monitoring
    in a cluster. In your own environment, you may choose another option, such as
    installing Prometheus directly or using the Prometheus Operator from [https://github.com/prometheus-operator/prometheus-operator](https://github.com/prometheus-operator/prometheus-operator)
    (which is provided by kube-prometheus).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, follow the steps at [https://github.com/prometheus-operator/kube-prometheus](https://github.com/prometheus-operator/kube-prometheus)
    installing to install kube-prometheus in our Operator project. Take note of the
    prerequisites for the *Installing* and *Compiling* sections in that link. Specifically,
    the following tools are required:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '`jb`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gojsontoyaml`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jsonnet`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When kube-prometheus has been successfully installed in the project, we will
    have a new subdirectory (`my-kube-prometheus`, as described in the kube-prometheus
    documentation), which contains the following files:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we will modify `example.jsonnet` to include our Operator''s namespace.
    This means modifying the `values+::` block within the file to add a `prometheus+`
    object that includes a list of namespaces (in our case, only the `nginx-operator-system`
    namespace):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'my-kube-prometheus/example.jsonnet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Next, use `build.sh` to compile the new manifests by running the following
    command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, we can create the `kube-prometheus` manifests in our cluster by applying
    them with the following commands (from within the `my-kube-prometheus` directory):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'When finished, the Prometheus dashboard should be accessible by running the
    following commands to open a local proxy to your cluster and the Prometheus service:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: (Note, this command will remain running until you manually end it, for example,
    by pressing *Ctrl* + *C*.) The dashboard will be visible by navigating to `http://localhost:9090`
    in your web browser. However, if you try to search for our Operator's metric (recall
    that it was named `reconciles_total`), you will see that it is not available.
    This is because we need to redeploy our Operator with an additional manifest that
    is not created by default.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Redeploying the Operator with metrics
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prometheus knows to scrape our Operator's namespace for metrics due to the configuration
    created previously. However, it still needs to know which specific endpoint within
    the namespace to query. This is the role of an object called `ServiceMonitor`
    ([https://pkg.go.dev/github.com/coreos/prometheus-operator/pkg/apis/monitoring/v1#ServiceMonitor](https://pkg.go.dev/github.com/coreos/prometheus-operator/pkg/apis/monitoring/v1#ServiceMonitor)).
    This object is not created by default by the Operator SDK when running `make deploy`,
    so we need to modify `config/default/kustomization.yaml`. (This file location
    is relative to the project root directory, not the new `my-kube-prometheus` directory
    that we created previously when installing kube-prometheus).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'In this file, simply find any lines that are marked with `[PROMETHEUS]` and
    uncomment them by removing the leading pound or the hash symbol (`#`). This is
    currently only one line, shown in the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'config/default/kustomization.yaml:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This is the default configuration file for **Kustomize** ([https://kustomize.io/](https://kustomize.io/)),
    which is a Kubernetes templating project that the Operator SDK uses to generate
    and deploy project manifests.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you can run `make undeploy` to remove the current Operator installation,
    followed by running `make deploy` once again to recreate it. After a few moments,
    the `reconciles_total` metric should be visible in the Prometheus dashboard. The
    following screenshot shows this metric in the Prometheus dashboard search bar:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Screenshot of the Prometheus dashboard](img/B18147_06_001.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Screenshot of the Prometheus dashboard
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Key takeaways
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While this section may seem focused on just setting up metrics, it actually
    covers some important steps related to the development-driven redeployment of
    an Operator project. Specifically, we covered the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Installing `kube-prometheus` as a library in our project and configuring it
    to scrape our Operator's namespace
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying Kustomize configuration files to include new dependencies in our Operator
    deployment
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `make undeploy` to remove the existing Operator deployment
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technically, we could have simply run `make deploy` without first undeploying
    the project. The idempotent nature of Kubernetes resource manifests means that
    only the new resources would have been created. However, awareness of `make undeploy`
    is very useful in cases where the existing project may need to be completely removed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced several new tools and concepts not yet covered by earlier
    chapters. These include Docker, kind, kubectl, Make, and kube-prometheus. It is
    possible that you may have run into some issues while working with these tools,
    so this section is intended to offer links to references that can help resolve
    common issues. Many of the underlying tools used in this chapter are not exclusive
    to the Operator Framework, which thankfully means that there is a wealth of resources
    available to address problems you may encounter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Makefile issues
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Make** ([https://www.gnu.org/software/make/](https://www.gnu.org/software/make/))
    is a very popular tool for automating the generation and compilation of countless
    software projects. It was already used in [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK,* and [*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078),
    *Developing an Operator – Advanced Functionality*, in order to generate the APIs
    and manifests used by our project. In this chapter, it was leveraged even more
    to automate many of the commands for building and deploying.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: However, the `make ...` commands used throughout this book are shorthand for
    running underlying tools. Therefore, when encountering an error with any `make`
    commands, the first debugging step is to examine the `Makefile` to find what that
    command is actually running. If this happens, you will likely find that you are
    rather encountering an issue with Docker, Go, or Kubernetes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: These commands have been preemptively provided when `operator-sdk` initialized
    the project, but you are free to modify the provided `Makefile` as you wish to
    customize your project.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: kind
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we used kind to deploy a test Kubernetes cluster. Using kind
    offers a very quick way to create (and destroy) local Kubernetes clusters. It
    also provides a configurable setup that allows for relatively easy changes to
    the default cluster (for example, starting a cluster with additional nodes).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The official website for kind is [https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/).
    The website provides extensive documentation and sample configurations for different
    cluster setups. In addition, the kind code base is available on GitHub at [https://github.com/kubernetes-sigs/kind](https://github.com/kubernetes-sigs/kind).
    The kind maintainers and users are also active on the official Kubernetes Slack
    server ([slack.k8s.io](http://slack.k8s.io)) in the **#kind** channel. Both of
    these links are excellent resources for asking questions or searching for answers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are working with Kubernetes, you are likely already familiar with Docker
    ([https://www.docker.com/](https://www.docker.com/)). It is just one of several
    options for building and managing container images, which are essential for deploying
    applications on Kubernetes. The key step for transitioning Operator code to a
    deployable image is the `docker build` command (which is called when running `make
    docker-build`). This command follows the `build` steps defined in the Dockerfile.
    More information on Dockerfile syntax is available in the Docker documentation
    at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: When building a container image following the steps in this chapter, there are
    some unique issues specific to this tutorial that you may encounter, which are
    explained next.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: docker build fails with no required module error for assets package
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When running `make docker-build`, you may find that your build fails with the
    following error (or something similar):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This error is actually arising from the `go build` command in the final step
    of the Dockerfile. In the context of this specific tutorial, Go is failing to
    build because it cannot locate the `assets` package (created in [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK*, to organize and access the operand
    Deployment manifest).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, ensure that you have modified the Dockerfile to include the `COPY
    assets/ assets/` directive (see the example in the *Building a container image*
    section of this chapter). Alternatively, you could refactor the Operator code
    to embed the `assets/` directory within the existing `controllers/` directory
    without needing to modify the Dockerfile. This is because both `controllers/`
    and `api/` are already copied to the `builder` image (but it does not semantically
    make sense to store embedded manifests within the API directory, as they are not
    an API).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: docker push fails with access denied
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `make docker-push` command may fail with the following error:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This exact error (including the `docker push controller:latest` line) implies
    a misconfigured `IMG` variable for the command. Recall that in the *Building a
    container image* section of this chapter, this variable was discussed as a way
    to tag the built image with an appropriate name. There are a few options for setting
    this value, either as an environment variable or by modifying the `Makefile`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: However you choose to update this variable, it is important to check that the
    value is propagated to the `docker-push` target in the `Makefile` as well. Otherwise,
    Docker will attempt to push this to a generic registry for library images. You
    do not have access to this registry, therefore, Docker returns the `access denied`
    error shown here.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: If instead, the error does include the appropriate public registry with your
    `IMG` variable value (for example, the second line is `docker push docker.io/yourregistry/yourimagename`)
    then it is likely a simple authentication error. Run `docker login` to make sure
    you are logged into your Docker Hub account.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Operator deploys but fails to start with ImagePull error
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you run `make deploy`, the command will likely always complete successfully
    (unless you have made significant modifications to the generated manifest files).
    However, when viewing the Operator in your cluster (for example, with `kubectl
    get all -n nginx-operator-system`) you may see that the Operator''s Pod is failing
    to start with the following message:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This is probably a similar error to the one described previously. In Kubernetes,
    the `ImagePullBackOff` error indicates that, for some reason, the Pod is unable
    to pull the container image it is intended to run. This is usually either an authentication
    error (for example, the registry may be private) or the image is not found. Ensure
    that you have built and pushed the Operator image with the right `IMG` environment
    variable set, as mentioned in the other *Troubleshooting* sections. If you still
    see the error, check to make sure that your image registry is not set to private
    by logging into the Docker Hub web UI.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Operator deploys but fails to start with another error
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Kubernetes, there are many reasons why any given Pod may fail to start. There
    could be a logical bug in the Operator's code or there may be a system configuration
    issue within the cluster. There is, unfortunately, no *one-size-fits-all* solution
    to this problem. However, there are tools to gather more information. Using `kubectl`
    to inspect the Pod is the most common way to diagnose errors. For example, `kubectl
    describe pod/<podname>` will print events and status updates that can explain
    the failure. Or, `kubectl logs pod/<podname>` will print the log output of the
    Pod (which is helpful for diagnosing runtime errors that usually need to be fixed
    in code). All of the `kubectl` commands will provide documentation by running
    `kubectl -h`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Metrics
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As part of developing an Operator with rich features and debugging capabilities,
    this and previous chapters dedicated effort to demonstrating the implementation
    of Prometheus metrics. Prometheus ([https://prometheus.io/](https://prometheus.io/))
    is an open source monitoring platform that is widely used in the Kubernetes ecosystem.
    Therefore, there are many resources available online for various problems (many
    are not specific to the Operator Framework). These community resources are documented
    at [https://prometheus.io/community/](https://prometheus.io/community/).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Operator metrics do not show up in Prometheus
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With Prometheus deployed in a cluster following the `kube-prometheus` steps
    in this tutorial, the custom metrics defined in our Operator code should show
    up in the Prometheus dashboard after a few moments. If, after some time, the custom
    metrics are still not visible, ensure that you have made the correct changes described
    in the *Installing and configuring kube-prometheus* section to instruct Prometheus
    to scrape the Operator's namespace for new metrics.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, make sure that you have uncommented the `- ../prometheus` line
    in `config/default/kustomization.yaml` before deploying the Operator as described
    in the *Redeploying the Operator with metrics* section. This step ensures that
    the `ServiceMonitor` object (which informs Prometheus which endpoint to scrape
    for metrics) is created in the namespace.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Operator deployment fails with no matches for kind 'ServiceMonitor'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When running `make deploy`, the following error may appear among several other
    lines showing which resources were created:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In this case, the Operator did not actually fail to deploy. However, it did
    fail to create the `ServiceMonitor` object due to an inability to locate the object's
    definition in the Kubernetes API. This is likely due to failing to install Prometheus
    in the cluster before attempting to deploy the Operator with metrics. Specifically,
    `ServiceMonitor` is a CRD that is provided by Prometheus. So, deploying the Operator
    with metrics before installing `kube-prometheus` in this tutorial will lead to
    failures when reporting metrics. To resolve this, ensure that you have followed
    the steps for installing Prometheus before deploying the Operator with metrics.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Additional errors
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding issues are just some of the technical problems that may arise
    when following this tutorial. It is, unfortunately, not possible for this chapter
    to cover every scenario. However, the Operator Framework community and its resources
    provide solutions to many different types of problems. These, along with the resources
    in the *Troubleshooting* section of [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK*, are very likely to resolve any
    difficulty that you may face.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter's main objective was to compile the Operator code that we have
    been building throughout this book and deploy it in a cluster. To do this, we
    followed steps designed for local development environments. These included building
    the Operator as a local binary and building a container image to deploy in an
    ephemeral test cluster (created using kind). This lightweight process is helpful
    for development and rapid testing, but it lacks the full workflow benefits needed
    for publishing an Operator with the intent of deploying in production.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will explore the final pillars of the Operator Framework:
    **OperatorHub** and the **Operator Lifecycle Manager**. Learning how to prepare
    and submit an Operator to OperatorHub will be a key part of offering any Operator
    available for public use. With that, the Operator Lifecycle Manager is a much
    more elegant solution for deploying Operators (both publicly available on OperatorHub
    or privately deployed). Compared to deploying manually with Make, these processes
    are much better suited for sharing your Operator with the world.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
