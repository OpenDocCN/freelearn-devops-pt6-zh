<html><head></head><body>
		<div id="_idContainer017">
			<h1 id="_idParaDest-39" class="chapter-number"><a id="_idTextAnchor038"/>2</h1>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Preparing a Kubernetes and Helm Environment</h1>
			<p><strong class="bold"><a id="_idTextAnchor040"/>Helm</strong> is a tool that<a id="_idIndexMarker069"/> provides a variety of benefits that help users deploy and manage <strong class="bold">Kubernetes</strong> applications easier. Before users can start experiencing these benefits, however, they must satisfy several prerequisites. First, a user must have access to a Kubernetes cluster. Next, a user should have the command-line tools for both Kubernetes and Helm. Finally, a user should be aware of Helm’s basic configuration options to be productive with as little friction as possible.<a id="_idTextAnchor041"/></p>
			<p>In this chapter, we will outline the tools and concepts that are required to begin working with Helm. The following topics will be covered in this chapter:<a id="_idTextAnchor042"/></p>
			<ul>
				<li>Preparing a local Kubernetes environment with minikube</li>
				<li>Setting up kubectl</li>
				<li>Setting up Helm</li>
				<li>Configuring Helm<a id="_idTextAnchor043"/></li>
			</ul>
			<h1 id="_idParaDest-41">Technical requirements<a id="_idTextAnchor044"/></h1>
			<p>In this chapter, you must install the following technologies on your local workstation:</p>
			<ul>
				<li>minikube</li>
				<li>VirtualBox</li>
				<li>Helm</li>
				<li>kubectl</li>
			</ul>
			<p>These tools can be installed with a package manager or by downloading them directly from the source. We will provide instructions for using the <strong class="source-inline">Chocolatey</strong> package manager on Windows, the <strong class="source-inline">Homebrew</strong> package manager on macOS, the <strong class="source-inline">apt-get</strong> package manager for Debian-based Linux distributions, and the <strong class="source-inline">dnf</strong> package manager for RPM-based Linux distributions.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor045"/>Preparing a local Kubernetes environment with minikube</h1>
			<p>Helm won’t be able to<a id="_idIndexMarker070"/> deploy applications without access to a Kubernetes cluster. For this reason, let’s discuss one option where users can run a local cluster on their machine – <strong class="bold">minikube</strong>.</p>
			<p>minikube is a <a id="_idIndexMarker071"/>community-driven tool that allows users to easily deploy a small, single-node Kubernetes cluster to their local machine. A cluster created with minikube is run inside either a container or a <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>) so that it can easily be created and later discarded. minikube presents us with an excellent way to experiment with Kubernetes, and it can also be used to learn Helm alongside the examples provided throughout this book. </p>
			<p>In the next few sections, we’ll cover how minikube can be installed and configured so that you have a Kubernetes cluster available while learning how to use Helm. For more comprehensive instructions, please refer to the <em class="italic">Getting Started!</em> page of the official minikube website at <a href="">https://minikube.sigs.k8s.io/docs/start<span id="_idTextAnchor046"/>/</a>.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor047"/>Installing minikube</h2>
			<p>minikube, like the<a id="_idIndexMarker072"/> other tools that will be installed within this chapter, has <a id="_idIndexMarker073"/>binaries compiled for the Windows, macOS, and Linux operating systems. The easiest way to install the latest version of minikube on Windows and macOS is via a package manager, such as <strong class="source-inline">Chocolatey</strong> for Windows and <strong class="source-inline">Homebrew</strong> for macOS. Linux users will find it easier to install the latest <strong class="source-inline">minikube</strong> binary by downloading it from minikube’s GitHub releases page, though this method can also be used on Windows and macOS as well.</p>
			<p>The following steps describe how to install minikube based on your machine and installation preference. Please note that minikube version v1.22.0 was used at the time of writing and for developing the examples that have been used throughout this book.</p>
			<p>To install <a id="_idIndexMarker074"/>it via a package manager (on Windows and macOS), run one of <a id="_idIndexMarker075"/>the following commands based on your operating system:</p>
			<ul>
				<li>For Windows, run the following command:<p class="source-code"><strong class="bold">choco install minikube</strong></p></li>
				<li>For macOS, run the following command:<p class="source-code"><strong class="bold">brew install minikube</strong></p></li>
			</ul>
			<p>The following steps show you how to install minikube using a direct download link (on Windows, macOS, and Linux):</p>
			<ol>
				<li>Navigate<a id="_idIndexMarker076"/> to minikube’s <em class="italic">releases</em> page on GitHub at <a href="B17979_02.xhtml#_idTextAnchor038">https://github.com/kubernetes/minikube/releases/</a>.</li>
				<li>Find the <strong class="bold">Assets</strong> section, which contains the minikube binaries for a given release:</li>
			</ol>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_2.1_B17979.jpg" alt="Figure 2.1 – A snippet of the minikube binaries from the GitHub releases page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – A snippet of the minikube binaries from the GitHub releases page</p>
			<ol>
				<li value="3">Under the <strong class="bold">Assets</strong> section, download the binary that corresponds to your target platform. Once downloaded, you should rename the binary <strong class="source-inline">minikube</strong>. If you are <a id="_idIndexMarker077"/>downloading the Linux binary, for example, you would run the following command:<p class="source-code"><strong class="bold">mv minikube-linux-amd64 minikube</strong></p></li>
				<li>To <a id="_idIndexMarker078"/>execute minikube, Linux and macOS users may need to add the executable bit by running the <strong class="source-inline">chmod</strong> command:<p class="source-code"><strong class="bold">chmod u+x minikube</strong></p></li>
				<li><strong class="source-inline">minikube</strong> should then be moved to a location that’s managed by the <strong class="source-inline">PATH</strong> variable so that it can be executed from any location in your command line. The locations that the <strong class="source-inline">PATH</strong> variable contains vary, depending on your operating system. For macOS and Linux users, these locations can be determined by running the following command in the Terminal:<p class="source-code"><strong class="bold">echo $PATH</strong></p></li>
			</ol>
			<p>Windows users can determine the <strong class="source-inline">PATH</strong> variable’s locations by running the following command in PowerShell:</p>
			<p class="source-code"><strong class="bold">$env:PATH</strong></p>
			<ol>
				<li value="6">Move the <strong class="source-inline">minikube</strong> binary to a <strong class="source-inline">PATH</strong> location using the <strong class="source-inline">mv</strong> command. The following example moves <strong class="source-inline">minikube</strong> to a common <strong class="source-inline">PATH</strong> location on Linux:<p class="source-code"><strong class="bold">mv minikube /usr/local/bin/</strong></p></li>
				<li>You can verify your minikube installation by running <strong class="source-inline">minikube version</strong> and ensuring that the displayed version corresponds with the version that was downloaded:<p class="source-code"><strong class="bold">$ minikube version</strong></p><p class="source-code"><strong class="bold">minikube version: v1.22.0</strong></p><p class="source-code"><strong class="bold">commit: a03fbcf166e6f74ef224d4a63be4277d017bb62e</strong></p></li>
			</ol>
			<p>The next step involves installing a container or virtual machine manager to run your local Kubernetes cluster. In this book, we will choose to run Kubernetes in a VM using VirtualBox since it is flexible and available on the Windows, macOS, and Linux operating systems. We will explain how to install VirtualBox next.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor048"/>Installing VirtualBox</h2>
			<p>Like minikube, VirtualBox can easily be installed via Chocolatey or Homebrew:</p>
			<ul>
				<li>Use the <a id="_idIndexMarker079"/>following command<a id="_idIndexMarker080"/> to install VirtualBox on Windows:<p class="source-code"><strong class="bold">choco install virtualbox</strong></p></li>
				<li>Use the following command to install VirtualBox on macOS:<p class="source-code"><strong class="bold">brew install --cask virtualbox</strong></p></li>
			</ul>
			<p>VirtualBox can also be installed by Linux package managers, but you need to download a package<a id="_idIndexMarker081"/> first from VirtualBox’s website (<a href="">https://www.virtualbox.org/wiki/Linux_Downloads</a>):</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/Figure_2.2_B17979.jpg" alt="Figure 2.2 – VirtualBox package download links&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – VirtualBox package download links</p>
			<p>Once you have downloaded your distribution’s package, you can install VirtualBox via <strong class="source-inline">apt-get</strong> or <strong class="source-inline">dnf</strong>:</p>
			<ul>
				<li>Use the following command to install VirtualBox on Debian-based Linux:<p class="source-code"><strong class="bold">apt-get install ./virtualbox-*.deb</strong></p></li>
				<li>Use the following command to install VirtualBox on RPM-based Linux:<p class="source-code"><strong class="bold">dnf install ./VirtualBox-*.rpm</strong></p></li>
			</ul>
			<p>Alternative methods <a id="_idIndexMarker082"/>of installing VirtualBox can be found at its official download page at <a href="">https://www.virtualbox.org/wiki/Downloads</a>.</p>
			<p>With VirtualBox <a id="_idIndexMarker083"/>installed, minikube must be configured to leverage VirtualBox as its default hypervisor. We will configure this in the next section.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor049"/>Configuring VirtualBox as the default driver</h2>
			<p>VirtualBox <a id="_idIndexMarker084"/>can be<a id="_idIndexMarker085"/> made the default driver in minikube by specifying the <strong class="source-inline">driver</strong> option as <strong class="source-inline">virtualbox</strong>:</p>
			<p class="source-code">minikube config set driver virtualbox</p>
			<p>Note that this command may produce the following warning:</p>
			<p class="source-code">❗  These changes will take effect upon a minikube delete and then a minikube start</p>
			<p>This message can be safely ignored if there are no active minikube clusters on your machine.</p>
			<p>The change to VirtualBox can be confirmed by checking the value of the <strong class="source-inline">driver</strong> configuration option:</p>
			<p class="source-code">minikube config get driver</p>
			<p>If the configuration change was successful, the following output will be displayed:</p>
			<p class="source-code">virtualbox</p>
			<p>In addition to configuring the default driver, you can also configure the resources that are allocated to a minikube instance, which we will discuss in the next section.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor050"/>Configuring minikube resource allocation</h2>
			<p>By <a id="_idIndexMarker086"/>default, minikube will allocate 2 CPUs and 2 GB of RAM to the VM, but we recommend increasing<a id="_idIndexMarker087"/> the memory allocation to 4 GB if your machine has the resources to spare. This is to prevent bumping into memory constraints as you run through the exercises.</p>
			<p>Run the following command to increase the VM memory allocation to 4 GB:</p>
			<p class="source-code">minikube config set memory 4000</p>
			<p>This change can be verified by running the following command: </p>
			<p class="source-code">minikube config get memory.</p>
			<p>Let’s continue exploring minikube by discussing <a id="_idTextAnchor051"/>its basic usage.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor052"/>Exploring the basic usage of minikube</h2>
			<p>Throughout<a id="_idIndexMarker088"/> this book, it will be <a id="_idIndexMarker089"/>handy to understand the key commands that are used in a typical minikube operation. They will also be essential to understand while executing the examples provided throughout this book. Fortunately, minikube is an easy tool to get started with.</p>
			<p>minikube has three key subcommands:</p>
			<ul>
				<li><strong class="source-inline">start</strong></li>
				<li><strong class="source-inline">stop</strong></li>
				<li><strong class="source-inline">delete</strong></li>
			</ul>
			<p>The <strong class="source-inline">start</strong> subcommand is used to create a single-node Kubernetes cluster. It creates a VM and bootstraps a cluster within it. The command will terminate once the cluster is ready:</p>
			<p class="source-code">$ minikube start</p>
			<p class="source-code">😄  minikube v1.22.0 on Redhat 8.4</p>
			<p class="source-code">✨  Using the virtualbox driver based on user configuration</p>
			<p class="source-code">👍  Starting control plane node minikube in cluster minikube</p>
			<p class="source-code">🔥  Creating virtualbox VM (CPUs=2, Memory=4000MB, Disk=20000MB) ...</p>
			<p class="source-code">🐳  Preparing Kubernetes v1.21.2 on Docker 20.10.6 ...</p>
			<p class="source-code">    ▪ Generating certificates and keys ...</p>
			<p class="source-code">    ▪ Booting up control plane ...</p>
			<p class="source-code">    ▪ Configuring RBAC rules ...</p>
			<p class="source-code">🔎  Verifying Kubernetes components...</p>
			<p class="source-code">    ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5</p>
			<p class="source-code">🌟  Enabled addons: storage-provisioner, default-storageclass</p>
			<p class="source-code">🏄  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default</p>
			<p>The <strong class="source-inline">stop</strong> subcommand is used to shut down the cluster and the VM. The state of the cluster and VM are saved to the disk, allowing users to run the <strong class="source-inline">start</strong> subcommand again to <a id="_idIndexMarker090"/>quickly begin resuming their work, rather than having to build a new VM from scratch. You should try to get into<a id="_idIndexMarker091"/> the habit of running <strong class="source-inline">minikube stop</strong> when you have finished working with a cluster that you would like to return to later:</p>
			<p class="source-code">$ minikube stop</p>
			<p class="source-code">✋  Stopping node "minikube"  ...</p>
			<p class="source-code">🛑  1 nodes stopped.</p>
			<p>The <strong class="source-inline">delete</strong> subcommand is used to delete a cluster and the VM. This command erases the state of the cluster and VM, freeing up the space on the disk that was previously allocated. The next time <strong class="source-inline">minikube start</strong> is executed, a fresh cluster and VM will be created:</p>
			<p class="source-code">$ minikube delete</p>
			<p class="source-code">🔥  Deleting "minikube" in virtualbox ...</p>
			<p class="source-code">💀  Removed all traces of the "minikube" cluster.</p>
			<p>There are more minikube subcommands available, but these are the subcommands that you should be aware of. </p>
			<p>With minikube<a id="_idIndexMarker092"/> installed and<a id="_idIndexMarker093"/> configured on a local machine, you can now install <strong class="bold">kubectl</strong>, the Kubernetes command-line tool, and satisfy the remaining prerequisite for workin<a id="_idTextAnchor053"/>g with Helm.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor054"/>Setting up kubectl</h1>
			<p>As we<a id="_idIndexMarker094"/> mentioned in <a href="B17979_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Understanding Kubernetes and Helm</em>, Kubernetes is a system that exposes different API endpoints. These API endpoints are used to perform various actions on a cluster, such as creating, viewing, or deleting resources. To provide a simpler user experience, developers need a way of interacting with Kubernetes without having to manage the underlying API layer.</p>
			<p>While you will predominantly use the Helm command-line tool throughout this book to install and manage applications, kubectl is an essential tool for common tasks.</p>
			<p>Read on to learn how to install kubectl on a local workstation. Note that the kubectl version that was used at the time of writing<a id="_idTextAnchor055"/> was v1.21.2.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor056"/>Installing kubectl</h2>
			<p>kubectl can<a id="_idIndexMarker095"/> be installed using minikube, or it can be obtained via a package manager or through direct download. First, let’s describe how to obtain kubectl u<a id="_idTextAnchor057"/>sing minikube.</p>
			<h3>Installing kubectl via minikube</h3>
			<p>Installing kubectl is<a id="_idIndexMarker096"/> straightforward with minikube. minikube provides a subcommand called <strong class="source-inline">kubectl</strong>, which downloads the kubectl binary for you. Begin by running a <strong class="source-inline">kubectl</strong> command using <strong class="source-inline">minikube kubectl</strong>:</p>
			<p class="source-code">minikube kubectl version</p>
			<p>This command installs kubectl to the <strong class="source-inline">$HOME/.minikube/cache/linux/v1.21.2</strong> directory. Note that the version of kubectl that’s included in the path will depend on the version of minikube that is being used. To <a id="_idIndexMarker097"/>access kubectl once it has been installed, use the following syntax:</p>
			<p class="source-code">minikube kubectl -- &lt;subcommand&gt; &lt;flags&gt;</p>
			<p>Here’s an example command:</p>
			<p class="source-code">$ minikube kubectl -- version --client</p>
			<p class="source-code">Client Version: version.Info{Major:"1", Minor:"21", GitVersion:"v1.21.2", GitCommit:"092fbfbf53427de67cac1e9fa54aaa09a28371d7", GitTreeState:"clean", BuildDate:"2021-06-16T12:59:11Z", GoVersion:"go1.16.5", Compiler:"gc", Platform:"linux/amd64"}</p>
			<p>While invoking kubectl with <strong class="source-inline">minikube kubectl</strong> works, the syntax is more unwieldy than that of invoking kubectl directly. This can be overcome by copying the <strong class="source-inline">kubectl</strong> executable from the local minikube cache into a location that’s managed by the <strong class="source-inline">PATH</strong> variable. Performing this action is similar on each operating system, but the following is an example of how it can be achieved on a Linux machine:</p>
			<p class="source-code">$ sudo cp ~/.minikube/cache/linux/v1.21.2/kubectl /usr/local/bin/</p>
			<p>Once complete, <strong class="source-inline">kubectl</strong> can be invoked as a standalone binary, as illustrated here:</p>
			<p class="source-code">$ kubectl version –client</p>
			<p class="source-code">Client Version: version.Info{Major:"1", Minor:"21", GitVersion:"v1.21.2", GitCommit:"092fbfbf53427de67cac1e9fa54aaa09a28371d7", GitTreeState:"clean", BuildDate:"2021-06-16T12:59:11Z", GoVersion:"go1.16.5", Compiler:"gc", Platform:"linux/amd64"}</p>
			<p><strong class="source-inline">kubectl</strong> can also be installed without <strong class="source-inline">minikube</strong>, as we’ll see in the fol<a id="_idTextAnchor058"/>lowing sections.</p>
			<h3>Installing kubectl without minikube</h3>
			<p>The <a id="_idIndexMarker098"/>Kubernetes upstream documentation provides several different mechanisms to do so for a variety of target operating systems, as described in <a href="">https://kubernetes.io/docs/tasks/tools/<span id="_idTextAnchor059"/>install-kubectl/</a>.</p>
			<h3>Using a package manager</h3>
			<p>Another way<a id="_idIndexMarker099"/> that kubectl can be installed without minikube is with a native package manager. The following list demonstrates how this can be accomplished on different operating systems:</p>
			<ul>
				<li>Use the following command to install kubectl on Windows:<p class="source-code"><strong class="bold">choco install kubernetes-cli</strong></p></li>
				<li>Use the following command to install kubectl on macOS:<p class="source-code"><strong class="bold">brew install kubernetes-cli</strong></p></li>
				<li>Use the following command to install kubectl on Debian-based Linux:<p class="source-code"><strong class="bold">sudo apt-get update</strong></p><p class="source-code"><strong class="bold">sudo apt-get install -y apt-transport-https ca-certificates curl</strong></p><p class="source-code"><strong class="bold">sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg </strong><a href="">https://packages.cloud.google.com/apt/doc/apt-key.gpg</a></p><p class="source-code"><strong class="bold">echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list</strong></p><p class="source-code"><strong class="bold">sudo apt-get update</strong></p><p class="source-code"><strong class="bold">sudo apt-get install -y kubectl</strong></p></li>
				<li>Use the following command to install kubectl on RPM-based Linux:<p class="source-code"><strong class="bold">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpgEOF</strong></p><p class="source-code"><strong class="bold">yum <a id="_idTextAnchor060"/>install -y kubectl</strong></p></li>
			</ul>
			<p>We will discuss the<a id="_idIndexMarker100"/> final kubectl installation method next.</p>
			<h3>Downloading directly from a link</h3>
			<p>kubectl can also be downloaded directly from a download link. The following list explains how<a id="_idIndexMarker101"/> version v1.21.2 can be downloaded, which is the version of kubectl that will be used throughout this book:</p>
			<ul>
				<li>Download <a id="_idIndexMarker102"/>kubectl for Windows from <a href="B17979_02.xhtml#_idTextAnchor082">https://storage.googleapis.com/kubernetes-release/release/v1.21.2/bin/windows/amd64/kubectl.exe</a>.</li>
				<li>Download <a id="_idIndexMarker103"/>kubectl for macOS from <a href="B17979_02.xhtml#_idTextAnchor081">https://storage.googleapis.com/kubernetes-release/release/v1.21.2/bin/darwin/amd64/kubectl</a>.</li>
				<li>Download <a id="_idIndexMarker104"/>kubectl for Linux from <a href="B17979_02.xhtml#_idTextAnchor080">https://storage.googleapis.com/kubernetes-release/release/v1.21.2/bin/linux/amd64/kubectl</a>.</li>
			</ul>
			<p>The kubectl binary can then be moved to a location that’s managed by the <strong class="source-inline">PATH</strong> variable. On the macOS and Linux operating systems, be sure to grant the file executable permission:</p>
			<p class="source-code">chmod u+x kubectl</p>
			<p>The installation can be verified by running the following command.</p>
			<p class="source-code">$ kubectl version --client</p>
			<p class="source-code">Client Version: version.Info{Major:"1", Minor:"21", GitVersion:"v1.21.2", GitCommit:"092fbfbf53427de67cac1e9fa54aaa09a28371d7", GitTreeState:"clean", BuildDate:"2021-06-16T12:59:11Z", GoVersion:"go1.16.5", Compiler:"gc", <a id="_idTextAnchor061"/>Platform:"linux/amd64"}</p>
			<p>Now that we’ve covered how to set up kubectl, we’re ready to get into the key technology of this book – Helm.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor062"/>Setting up Helm</h1>
			<p>Once<a id="_idIndexMarker105"/> minikube and kubectl have been installed, the next logical tool to configure is Helm. Note that the version of Helm that was used at the time of writi<a id="_idTextAnchor063"/>ng this book was v3.6.3.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor064"/>Installing Helm</h2>
			<p>Packages<a id="_idIndexMarker106"/> for Helm exist for both <strong class="source-inline">Chocolatey</strong> and <strong class="source-inline">Homebrew</strong> to allow you to easily install it on Windows or macOS. On these systems, the following commands can be run to install Helm with the applicable package manager:</p>
			<ul>
				<li>Install Helm on Windows using the following command:<p class="source-code"><strong class="bold">&gt; choco install kubernetes-helm     </strong></p></li>
				<li>Install Helm on macOS using the following command:<p class="source-code"><strong class="bold">$ brew install helm</strong></p></li>
			</ul>
			<p>Linux users, or users who would rather install Helm from a direct downloadable link, can download an archive from Helm’s GitHub releases page by following these steps:</p>
			<ol>
				<li value="1">Find <a id="_idIndexMarker107"/>the <strong class="bold">Installation and Upgrading</strong> section on Helm’s GitHub releases page at <a href="">https://github.com/helm/helm/releases</a>:</li>
			</ol>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_2.3_B17979.jpg" alt="Figure 2.3 – The Installation and Upgrading section on the Helm GitHub releases page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – The Installation and Upgrading section on the Helm GitHub releases page</p>
			<ol>
				<li value="2">Download the archive file associated with your operating system.</li>
				<li>Once <a id="_idIndexMarker108"/>downloaded, the file will need to be unarchived. One way that this can be achieved is by using the <strong class="source-inline">Expand-Archive</strong> cmdlet on PowerShell or by using the <strong class="source-inline">tar</strong> utility on Bash:</li>
			</ol>
			<p>For Windows/PowerShell, use the following example code:</p>
			<p class="source-code"><strong class="bold">Expand-Archive -Path helm-v3.6.3-windows-amd64.zip -DestinationPath $DEST</strong></p>
			<p>For Linux, use the following example code:</p>
			<p class="source-code"><strong class="bold">tar -zxvf helm-v3.6.3-linux-amd64.tar.gz</strong></p>
			<p>For Mac, use the following example code:</p>
			<p class="source-code"><strong class="bold">tar -zxvf helm-v3.6.3-linux-amd64.tar</strong></p>
			<p>The <strong class="source-inline">helm</strong> binary can be found in the unarchived folder. It should be moved to a location that’s managed by the <strong class="source-inline">PATH</strong> variable.</p>
			<p>The following example illustrates how to move the <strong class="source-inline">helm</strong> binary to the <strong class="source-inline">/usr/local/bin</strong> folder on a Linux system:</p>
			<p class="source-code">sudo mv ~/Downloads/linux-amd64/helm /usr/local/bin</p>
			<p>Regardless of the method that Helm was installed with, verification can be performed by running the <strong class="source-inline">helm version</strong> command. If the resulting output is similar to that of the following<a id="_idIndexMarker109"/> code, then Helm has been successfully installed:</p>
			<p class="source-code">$ helm version</p>
			<p class="source-code">version.BuildInfo{Version:"v3.6.3", GitCommit:"d506314abfb5d21419df8c7e7e68012379db2354", GitTreeState:"cl<a id="_idTextAnchor065"/>ean", GoVersion:"go1.16.5"}</p>
			<p>With Helm installed on your machine, let’s learn about the basic Helm configuration topics.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor066"/>Configuring Helm</h1>
			<p>Helm is a <a id="_idIndexMarker110"/>tool with sensible defaults that allow users to be productive without needing to perform a large number of tasks post-installation. With that being said, there are several different options users can change or enable to modify Helm’s behavior. We will cover these options in the following sections, beginning with config<a id="_idTextAnchor067"/>uring upstream repositories.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor068"/>Adding upstream repositories</h2>
			<p>One way<a id="_idIndexMarker111"/> that users can begin to configure their Helm installation is by adding upstream chart repositories. In <a href="B17979_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Understanding Kubernetes and Helm</em>, we described how chart repositories contain Helm charts that are more broadly available for consumption. Helm, being the Kubernetes package manager, can connect to various chart repositories to install Kubernetes applications.</p>
			<p>Helm provides the <strong class="source-inline">repo</strong> subcommand to allow users to manage configured chart repositories. This subcommand contains additional subcommands that can be used to perform actions against specified repositories. </p>
			<p>Here are the five <strong class="source-inline">repo</strong> subcommands:</p>
			<ul>
				<li><strong class="source-inline">add</strong>: To add a chart repository</li>
				<li><strong class="source-inline">list</strong>: To list chart repositories</li>
				<li><strong class="source-inline">remove</strong>: To remove a chart repository</li>
				<li><strong class="source-inline">update</strong>: To update information on available charts locally from chart repositories</li>
				<li><strong class="source-inline">index</strong>: To generate an index file, given a directory containing packaged charts</li>
			</ul>
			<p>Using the <a id="_idIndexMarker112"/>preceding list as a guide, adding a chart repository can be accomplished using the <strong class="source-inline">add repo</strong> subcommand, as follows:</p>
			<p class="source-code">$ helm repo add $REPO_NAME $REPO_URL</p>
			<p>Adding chart repositories is required before installing the charts contained within them. The specific steps to install charts from repositories will be discussed in detail throughout this book.</p>
			<p>You can confirm whether a repository has been successfully added by leveraging the <strong class="source-inline">list repo</strong> subcommand:</p>
			<p class="source-code">$ helm repo list</p>
			<p class="source-code">NAME      URL                  </p>
			<p class="source-code">bitnami   <a href="B17979_02.xhtml#_idTextAnchor078">https://charts.bitnami.com</a></p>
			<p>Repositories that have been added to the Helm client will appear in this output. The preceding example shows that a chart repository called <strong class="source-inline">bitnami</strong> was previously added, so it appears in the list of repositories known by the Helm client. If additional repositories are added, they will also appear in this output.</p>
			<p>Over time, updates to charts will be published and released to these repositories. Repository metadata is cached locally. As a result, Helm is not automatically aware of when a chart is updated. You can instruct Helm to check for updates from each configured repository by running the <strong class="source-inline">update repo</strong> subcommand. Once this command has been executed, you will be able to install the latest charts from each repository:</p>
			<p class="source-code">$ helm repo update</p>
			<p class="source-code">Hang tight while we grab the latest from your chart repositories...</p>
			<p class="source-code">...Successfully got an update from the "bitnami" chart repository</p>
			<p class="source-code">Update Complete. ⎈ Happy Helming!⎈</p>
			<p>You may also need to remove repositories that have been configured previously. This can be <a id="_idIndexMarker113"/>accomplished by using the <strong class="source-inline">repo remove</strong> subcommand:</p>
			<p class="source-code">$ helm repo remove bitnami</p>
			<p class="source-code">"bitnami" has been removed from your repositories</p>
			<p>The last remaining <strong class="source-inline">repo</strong> subcommand form is <strong class="source-inline">index</strong>. This subcommand is used by repository and chart maintainers to publish new or updated charts. This task will be cover<a id="_idTextAnchor069"/>ed more extensively in <a href="B17979_08.xhtml#_idTextAnchor210"><em class="italic">Chapter 8</em></a>,<em class="italic"> Publishing to a Helm Chart Repository</em>.</p>
			<p>Next, we will discuss Helm plugin configurations.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor070"/>Adding plugins</h2>
			<p>Plugins <a id="_idIndexMarker114"/>are <a id="_idIndexMarker115"/>add-on capabilities that can be used to provide additional features to Helm. Most users will not need to worry about plugins and plugin management with Helm. Helm is a powerful tool on its own and is complete with a full set of included features. With that being said, the Helm community maintains a variety of different plugins that can be used to enhance Helm’s capabilities outside of the core code base. Some <a id="_idIndexMarker116"/>of the more popular Helm plugins are listed within the Helm documentation at <a href="">https://helm.sh/docs/community/related/</a>.</p>
			<p>Helm provides a <strong class="source-inline">plugin</strong> subcommand for managing plugins, which contain further subcommands, as described in the following table:</p>
			<table id="table001-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Plugin Subcommand</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Usage</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">install</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Installs one or more Helm plugins</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">helm plugin install $URL</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">list</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Lists installed Helm plugins</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">helm plugin list</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">uninstall</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Uninstalls one or more Helm plugins</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">helm plugin uninstall $PLUGIN</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">update</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Updates one or more Helm plugins</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">helm plugin update $PLUGIN</strong></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.1 – Helm plugin subcommands</p>
			<p>Plugins <a id="_idIndexMarker117"/>can provide a variety of different productivity <a id="_idIndexMarker118"/>enhancements.</p>
			<p>The following are several<a id="_idIndexMarker119"/> examples of upstream plugins:</p>
			<ul>
				<li><strong class="bold">Helm Diff</strong>: Performs<a id="_idIndexMarker120"/> a diff between a deployed release and proposed Helm upgrade</li>
				<li><strong class="bold">Helm Secrets</strong>: Used<a id="_idIndexMarker121"/> to help conceal secrets from Helm charts</li>
				<li><strong class="bold">Helm Monitor</strong>: Used <a id="_idIndexMarker122"/>to monitor a release and perform a rollback if certain events occur</li>
				<li><strong class="bold">Helm Unittest</strong>: Used<a id="_idIndexMarker123"/> to perform unit testing on a Helm<a id="_idTextAnchor071"/> chart</li>
			</ul>
			<p>We will continue discussing Helm configuration options by reviewing the different environment variables that can be set to change various aspects of Helm’s behavior.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor072"/>Environment variables</h2>
			<p>Helm relies on the existence <a id="_idIndexMarker124"/>of environment variables <a id="_idIndexMarker125"/>to configure some of the low-level options. There are many variables you can configure, each of which can be seen in the <strong class="source-inline">helm help</strong> output. </p>
			<p>A few <a id="_idIndexMarker126"/>environment variables are used for storing Helm metadata:</p>
			<ul>
				<li><strong class="source-inline">HELM_CACHE_HOME</strong><strong class="bold"> or </strong><strong class="source-inline">XDG_CACHE_HOME</strong>: Sets an alternative location<a id="_idIndexMarker127"/> for storing cached files</li>
				<li><strong class="source-inline">HELM_CONFIG_HOME</strong><strong class="bold"> or </strong><strong class="source-inline">XDG_CONFIG_HOME</strong>: Sets an alternative location <a id="_idIndexMarker128"/>for storing Helm configuration</li>
				<li><strong class="source-inline">HELM_DATA_HOME</strong><strong class="bold"> or </strong><strong class="source-inline">XDG_DATA_HOME</strong>: Sets an alternative location for<a id="_idIndexMarker129"/> storing Helm data</li>
			</ul>
			<p>Helm adheres to <a id="_idIndexMarker130"/>the <strong class="bold">XDG Base Directory Specification</strong>, which is designed to provide a standardized way of defining where different files are located on an operating system’s filesystem. Based on the XDG specification, Helm automatically creates three different <a id="_idIndexMarker131"/>default directories on each operating system as required:</p>
			<table id="table002-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Operating System</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Cache Path</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Configuration Path</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Data Path</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Windows</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">%TEMP%\helm</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">%APPDATA%\helm</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">%APPDATA%\helm</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">macOS</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">$HOME/Library/Caches/helm</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">$HOME/Library/Preferences/helm</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">$HOME/Library/helm</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Linux</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">$HOME/.cache/helm</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">$HOME/.config/helm</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">$HOME/.local/share/helm</strong></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.2 – Default locations for Helm metadata</p>
			<p>Helm uses the <strong class="bold">cache path</strong> to<a id="_idIndexMarker132"/> store charts that are downloaded from upstream chart repositories. Installed charts are cached to the local machine to enable faster installation of the chart the next time it is referenced. The cache path also includes YAML files that are used to index the available Helm charts from each configured repository. These index files are updated when users run the <strong class="source-inline">helm repo update</strong> command.</p>
			<p>The <strong class="bold">configuration path</strong> is used<a id="_idIndexMarker133"/> to save repository information, such as the URL and credentials for authentication, if required. When a chart is installed but is not located in the local cache yet, Helm uses the configuration path to look up the URL of the chart repository. The chart is then downloaded from this URL.</p>
			<p>The <strong class="bold">data path</strong> is used <a id="_idIndexMarker134"/>to store plugins. When a plugin is installed using the <strong class="source-inline">helm plugin install</strong> command, the plugin itself is stored in this location.</p>
			<p>Besides the Helm metadata paths, other <a id="_idIndexMarker135"/>environment variables are used for configuring regular Helm usage:</p>
			<ul>
				<li><strong class="bold">HELM_DRIVER</strong>: Sets <a id="_idIndexMarker136"/>the backend storage driver. It is used to determine how the release state is stored in Kubernetes. The default value is <strong class="source-inline">secret</strong>, which Base64-encodes the state of a release in a Kubernetes <strong class="source-inline">secret</strong>. Other options include <strong class="source-inline">configmap</strong>, which stores state in a plaintext Kubernetes ConfigMap, <strong class="source-inline">memory</strong>, which stores the state in the local process’s memory, and <strong class="source-inline">sql</strong>, which stores state in a relational database.</li>
				<li><strong class="bold">HELM_NAMESPACE</strong>: Sets<a id="_idIndexMarker137"/> the namespace that’s used for Helm operations. The <strong class="source-inline">HELM_NAMESPACE</strong> environment variable is used to set the namespace in which Helm operations take place. This is a convenient environment variable to use as it prevents you from needing to pass the <strong class="source-inline">--namespace</strong> or <strong class="source-inline">-n</strong> flag on each Helm invocation.</li>
				<li><strong class="bold">KUBECONFIG</strong>: Sets<a id="_idIndexMarker138"/> an alternative Kubernetes configuration file. The <strong class="source-inline">KUBECONFIG</strong> environment variable is used to set the file that’s used for authentication to the Kubernetes cluster. If unset, the default value will be <strong class="source-inline">~/.kube/config</strong>. In most cases, users won’t need to modify this <a id="_idTextAnchor073"/>value.</li>
			</ul>
			<p>Another component of Helm that can be configured is tab completion, as discussed next.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor074"/>Tab completion</h2>
			<p>Bash, Zsh, and Fish users<a id="_idIndexMarker139"/> can enable tab completion to simplify Helm usage. Tab completion allows Helm commands to be auto-completed when the <em class="italic">Tab</em> key is pressed, enabling users to perform tasks faster and helping prevent input mistakes.</p>
			<p>This process is similar to how most modern terminal emulators behave by default. When the <em class="italic">Tab</em> key is pressed, terminals try to guess what arguments are needed next by observing the state of <a id="_idIndexMarker140"/>the command and the environment. For example, the <strong class="source-inline">cd /usr/local/b</strong> input can be tab-completed to <strong class="source-inline">cd /usr/local/bin</strong> in a Bash shell. Similarly, an input such as <strong class="source-inline">helm upgrade hello-</strong> can be tab-completed to read <strong class="source-inline">helm upgrade hello-world</strong>. </p>
			<p>Tab completion can be enabled by running one of the following commands, based on your shell of choice:</p>
			<ul>
				<li>For Bash users, run the following command:<p class="source-code"><strong class="bold">source &lt;(helm completion bash)</strong></p></li>
				<li>For Zsh users, run the following command:<p class="source-code"><strong class="bold">source &lt;(helm completion zsh)</strong></p></li>
				<li>For Fish users, run the following command:<p class="source-code"><strong class="bold">helm completion fish | source</strong></p></li>
			</ul>
			<p>Note that auto-completion will only exist in terminal windows that execute one of the preceding commands, so other open windows will need to run this command as well to experience the auto-completion <a id="_idTextAnchor075"/>feature.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor076"/>Authentication</h2>
			<p>Helm needs<a id="_idIndexMarker141"/> to be able to authenticate with a Kubernetes cluster to deploy and manage applications. It authenticates by referencing a <strong class="source-inline">kubeconfig</strong> file, which specifies different Kubernetes clusters and how to interact with them. </p>
			<p>If you are using minikube, you will not need to configure authentication as minikube automatically configures a <strong class="source-inline">kubeconfig</strong> file each time a new cluster is created. If you are not running minikube, you will likely need to create a <strong class="source-inline">kubeconfig</strong> file or have one provided, depending on the Kubernetes distribution you are using. A <strong class="source-inline">kubeconfig</strong> file is comprised of three primary components:</p>
			<ul>
				<li><strong class="bold">clusters</strong>: Hostnames<a id="_idIndexMarker142"/> or IP addresses, along with a certificate authority</li>
				<li><strong class="bold">users</strong>: Authentication<a id="_idIndexMarker143"/> details</li>
				<li><strong class="bold">contexts</strong>: Binding <a id="_idIndexMarker144"/>between a cluster, users, and an active namespace</li>
			</ul>
			<p>A <strong class="source-inline">kubeconfig</strong> file, along with these three primary components, can be created by leveraging three<a id="_idIndexMarker145"/> different <strong class="source-inline">kubectl</strong> commands:</p>
			<ul>
				<li>The first command is <strong class="source-inline">set-cluster</strong>:<p class="source-code"><strong class="bold">kubectl config set-cluster</strong></p></li>
			</ul>
			<p>The <strong class="source-inline">set-cluster</strong> command <a id="_idIndexMarker146"/>will define a <strong class="source-inline">cluster</strong> entry in the <strong class="source-inline">kubeconfig</strong> file. <strong class="source-inline">set-context</strong> is used to associate a credential with a cluster. Once an association between a credential and a cluster has been established, you will be able to authenticate to the specified cluster using the credential’s authentication method.</p>
			<ul>
				<li>The next command is <strong class="source-inline">set-credentials</strong>:<p class="source-code"><strong class="bold">kubectl config set-credentials</strong></p></li>
			</ul>
			<p>The <strong class="source-inline">set-credentials</strong> command <a id="_idIndexMarker147"/>will define the name of a user, along with its authentication method and details. This command can configure a username and password pair, client certificate, bearer token, or authentication provider to allow users and administrators to specify varying different methods of authentication.</p>
			<ul>
				<li>Then, we have the <strong class="source-inline">set-context</strong> command:<p class="source-code"><strong class="bold">kubectl config set-context</strong></p></li>
			</ul>
			<p>The <strong class="source-inline">set-context</strong> command, as <a id="_idIndexMarker148"/>mentioned previously, specifies a name mapping between a <strong class="source-inline">cluster</strong>, <strong class="source-inline">credential</strong>, (user), and an active namespace. All invocations referencing a <strong class="source-inline">kubeconfig</strong> file target a specific context.</p>
			<p>The <strong class="source-inline">kubectl config view</strong> command <a id="_idIndexMarker149"/>can be used to view the <strong class="source-inline">kubeconfig</strong> file. Notice how the <strong class="source-inline">clusters</strong>, <strong class="source-inline">contexts</strong>, and <strong class="source-inline">user</strong> stanzas of <strong class="source-inline">kubeconfig</strong> correspond to the previously described commands, as shown in the following example:</p>
			<p class="source-code">$ kubectl config view</p>
			<p class="source-code">apiVersion: v1</p>
			<p class="source-code">clusters:</p>
			<p class="source-code">- cluster:</p>
			<p class="source-code">    certificate-authority: /home/helm-user/.minikube/ca.crt</p>
			<p class="source-code">    extensions:</p>
			<p class="source-code">    - extension:</p>
			<p class="source-code">        last-update: Mon, 13 Dec 2021 17:26:45 EST</p>
			<p class="source-code">        provider: minikube.sigs.k8s.io</p>
			<p class="source-code">        version: v1.22.0</p>
			<p class="source-code">      name: cluster_info</p>
			<p class="source-code">    server: https://192.168.49.2:8443</p>
			<p class="source-code">  name: minikube</p>
			<p class="source-code">contexts:</p>
			<p class="source-code">- context:</p>
			<p class="source-code">    cluster: minikube</p>
			<p class="source-code">    extensions:</p>
			<p class="source-code">    - extension:</p>
			<p class="source-code">        last-update: Mon, 13 Dec 2021 17:26:45 EST</p>
			<p class="source-code">        provider: minikube.sigs.k8s.io</p>
			<p class="source-code">        version: v1.22.0</p>
			<p class="source-code">      name: context_info</p>
			<p class="source-code">    namespace: default</p>
			<p class="source-code">    user: minikube</p>
			<p class="source-code">  name: minikube</p>
			<p class="source-code">current-context: minikube</p>
			<p class="source-code">kind: Config</p>
			<p class="source-code">preferences: {}</p>
			<p class="source-code">users:</p>
			<p class="source-code">- name: minikube</p>
			<p class="source-code">  user:</p>
			<p class="source-code">    client-certificate: /home/helm-user/.minikube/profiles/minikube/client.crt</p>
			<p class="source-code">    client-key: /home/helm-user/.minikube/profiles/minikube/client.key</p>
			<p>Starting the minikube instance <a id="_idIndexMarker150"/>will automatically populate the contents of the <strong class="source-inline">kubeconfig</strong> file. Once this file is present, kubectl and Helm will be able to interact with a Kubernetes cluster.</p>
			<p>In the next section, we will discuss how authorization is handled against a K<a id="_idTextAnchor077"/>ubernetes cluster.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor078"/>Authorization/RBAC</h2>
			<p>While<a id="_idIndexMarker151"/> authentication is a means of confirming identity, authorization defines the actions that an authenticated user is allowed to perform. Kubernetes <a id="_idIndexMarker152"/>uses <strong class="bold">role-based access control</strong> (<strong class="bold">RBAC</strong>) to perform authorization on Kubernetes. RBAC is a system for designing roles and privileges that can be assigned to a given user or group of users. The actions a user is permitted to perform on Kubernetes depends on the roles that the user has been assigned.</p>
			<p>Kubernetes provides many different roles on the platform. Three common roles are listed here:</p>
			<ul>
				<li><strong class="source-inline">cluster-admin</strong>: This<a id="_idIndexMarker153"/> allows a user to perform any action against any resource throughout the cluster.</li>
				<li><strong class="source-inline">edit</strong>: This <a id="_idIndexMarker154"/>allows a user to read and write to most resources within a namespace or a logical grouping of Kubernetes resources.</li>
				<li><strong class="source-inline">view</strong>: This<a id="_idIndexMarker155"/> prevents a user from modifying existing resources. It only allows users to read resources within a namespace.</li>
			</ul>
			<p>Since Helm authenticates to Kubernetes using the credentials defined in the <strong class="source-inline">kubeconfig</strong> file, Helm is given the same level of access. If <strong class="source-inline">edit</strong> access is allowed, Helm can be assumed to have sufficient permission to install applications, in most cases. With view access, Helm will not be able to install applications, as this level of access is read-only. It may also be unable to list details related to installed releases since <strong class="source-inline">secrets</strong> are used as the default storage driver.</p>
			<p>Users that run minikube are given <strong class="source-inline">cluster-admin</strong> by default after instance creation. While this level of access would not be a best practice in a production environment, it is acceptable for learning and experimenting. If you are running Minikube, you will not have to worry about configuring authorization to follow along with both the concepts and examples provided in this book. If you are working with Kubernetes users that aren’t using minikube, you will need to make sure they are given at least the <strong class="source-inline">edit</strong> role to be able to <a id="_idIndexMarker156"/>deploy applications with Helm. This can be accomplished by asking an administrator to run the following command (where <strong class="source-inline">$USER</strong> is your Kubernetes user):</p>
			<p class="source-code">kubectl create clusterrolebinding $USER-edit --clusterrole=edit --user=$USER</p>
			<p>Best practices around RBAC will be discussed in <a href="B17979_12.xhtml#_idTextAnchor270"><em class="italic">Chapter 12</em></a>, <em class="italic">Helm Security Considerations</em>, when we discuss, in greater detail, the concepts related to security, including how to appropriately apply roles to prevent mistakes and actions of maliciou<a id="_idTextAnchor079"/>s intent in the cluster.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor080"/>Summary</h1>
			<p>There are a variety of different components you need to have available to start using Helm. In this chapter, you learned how to install minikube to provide a local Kubernetes cluster that can be used throughout this book. You also learned how to install kubectl, which is the official tool for interacting with the Kubernetes API. Finally, you learned how to install the Helm client and explored the various ways that Helm can be configured, including adding repositories and plugins, modifying environment variables, enabling tab completion, and configuring authentication and authorization against a Kubernetes cluster.</p>
			<p>Now that you have the prerequisite tooling installed, you can begin learning how to deploy your first application with Helm. In the next chapter, you will install a Helm chart from an upstream chart repository, as well as learn about life cycle management and application configuration. After finishing that chapter, you will have an understanding of how Helm acts as the package manager for Kubernetes.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor081"/>Further reading</h1>
			<p>Check out the following links to learn more about the installation options that are available for minikube, kubectl, and Helm:</p>
			<ul>
				<li>Minikube: <a href="">https://kubernetes.io/docs/tasks/tools/install-minikube/</a></li>
				<li>kubectl: <a href="">https://kubernetes.io/docs/tasks/tools/install-kubectl/</a></li>
				<li>Helm: <a href="B17979_02.xhtml#_idTextAnchor076">https://helm.sh/docs/intro/install/</a></li>
			</ul>
			<p>We covered various ways of configuring Helm post-installation. Check out the following links to learn more about these topics:</p>
			<ul>
				<li>Repository management: <a href="B17979_02.xhtml#_idTextAnchor074">https://helm.sh/docs/intro/quickstart/#initialize-a-helm-chart-repository</a></li>
				<li>Plugin management: <a href="">https://helm.sh/docs/topics/plugins/</a></li>
				<li>Environment variables and the <strong class="source-inline">helm help</strong> output: <a href="B17979_02.xhtml#_idTextAnchor072">https://helm.sh/docs/helm/helm/</a></li>
				<li>Tab completion: <a href="B17979_02.xhtml#_idTextAnchor070">https://helm.sh/docs/helm/helm_completion/</a></li>
				<li>Authentication and authorization via the <strong class="source-inline">kubeconfig</strong> file: <a href="">https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/</a></li>
			</ul>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor082"/>Questions</h1>
			<p>Answer the following questions to test your knowledge of this chapter:</p>
			<ol>
				<li value="1">How does Helm authenticate to a Kubernetes cluster?</li>
				<li>What mechanism is in place to provide authorization to the Helm client? How can an administrator manage these privileges?</li>
				<li>What is the purpose of the <strong class="source-inline">helm repo add</strong> command?</li>
				<li>What are the three file paths that are used for storing Helm metadata? What does each path contain?</li>
				<li>How does Helm manage the state? What options are available to change how the state is stored?</li>
			</ol>
		</div>
	</body></html>