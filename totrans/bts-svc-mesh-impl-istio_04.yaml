- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Managing Application Traffic
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理应用流量
- en: 'Microservices architecture creates a sprawl of loosely coupled applications
    deployed as containers on platforms such as Kubernetes. With the loose coupling
    of applications, inter-service traffic management becomes complex. If exposed
    insecurely to external systems, it can cause exposure of sensitive data, making
    your system vulnerable to external threats. Istio provides various mechanisms
    to secure and govern the following kinds of application traffic:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构创建了一个由松散耦合的应用程序组成的扩展系统，这些应用程序以容器的形式部署在如 Kubernetes 等平台上。由于应用程序之间的松散耦合，服务间的流量管理变得复杂。如果暴露给外部系统不安全，可能导致敏感数据的泄露，从而使系统容易受到外部威胁。Istio
    提供了多种机制来保护和管理以下类型的应用流量：
- en: Ingress traffic coming to your application from outside
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自外部的流量访问您的应用程序
- en: Inter-mesh traffic generated between various components of the application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序各个组件之间生成的跨网格流量
- en: Egress traffic going out from your application to other applications outside
    the mesh
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从您的应用程序到网格外其他应用程序的 Egress 流量
- en: In this chapter, we will read about and practice managing application traffic
    by going through the following topics in detail.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下详细的主题来学习和实践管理应用流量。
- en: Managing Ingress traffic using the Kubernetes Ingress resource and an Istio
    Gateway
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes Ingress 资源和 Istio Gateway 管理 Ingress 流量
- en: Traffic routing and canary release
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量路由和金丝雀发布
- en: Traffic mirroring
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量镜像
- en: Routing traffic to services outside the mesh
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将流量路由到网格外的服务
- en: Exposing Ingress over HTTPS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 HTTPS 暴露 Ingress
- en: Managing Egress
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理 Egress
- en: It will be a good idea to delete Istio and install it again to get a clean slate,
    as well as practice what you learned in *Chapter 2*. Istio releases a minor version
    at a 3-month cadence, as described at [https://istio.io/latest/docs/releases/supported-releases/](https://istio.io/latest/docs/releases/supported-releases/);
    therefore, it is recommended to keep your Istio version up to date using the documentation
    on the Istio website ([https://istio.io/latest/docs/setup/getting-started/#download](https://istio.io/latest/docs/setup/getting-started/#download))
    and the concepts you learned about in *Chapter 2*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 删除 Istio 并重新安装它是个好主意，这样可以获得一个干净的环境，并且复习在*第二章*中学到的内容。Istio 每三个月发布一个小版本，如[https://istio.io/latest/docs/releases/supported-releases/](https://istio.io/latest/docs/releases/supported-releases/)中所述；因此，建议使用
    Istio 网站上的文档([https://istio.io/latest/docs/setup/getting-started/#download](https://istio.io/latest/docs/setup/getting-started/#download))保持
    Istio 版本更新，并结合在*第二章*中学到的概念。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this section, we will create an AWS cloud setup, which will be used to perform
    hands-on exercises in this and subsequent chapters. You can use any cloud provider
    of your choice, but to introduce some variety in this book, I have selected AWS
    for *Part 2* and Google Cloud for *Part 3*. You can also use minikube for the
    exercises, but you will need at least a quad-core processor and 16 GB or more
    of RAM assigned to minikube for smooth, lag-free operations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个 AWS 云设置，用于在本章和后续章节中进行动手操作练习。您可以使用任何您选择的云提供商，但为了在本书中引入一些多样性，我选择了
    AWS 作为*第二部分*的练习环境，Google Cloud 作为*第三部分*的练习环境。您也可以使用 minikube 进行练习，但您需要至少一个四核处理器和分配给
    minikube 16 GB 或更多的内存，以保证操作流畅且无延迟。
- en: Setting up the environment
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置环境
- en: Let’s go!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Create an AWS account. If you don’t already have an AWS account, then it’s time
    to sign up with AWS using [https://portal.aws.amazon.com/billing/signup#/start/email](https://portal.aws.amazon.com/billing/signup#/start/email).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 AWS 账户。如果你还没有 AWS 账户，是时候使用[https://portal.aws.amazon.com/billing/signup#/start/email](https://portal.aws.amazon.com/billing/signup#/start/email)注册
    AWS 账户了。
- en: 'Set up the AWS CLI:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 AWS CLI：
- en: Install the AWS CLI using the steps provided at [https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html).
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照[https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)中提供的步骤安装
    AWS CLI。
- en: Configure the AWS CLI using the steps provided at [https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html).
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照[https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html)中提供的步骤配置
    AWS CLI。
- en: Install the AWS IAM authenticator using the steps provided at [https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html](https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照[https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html](https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html)提供的步骤安装AWS
    IAM验证器。
- en: Install Terraform, which is infrastructure-as-code software that automates the
    provisioning of infrastructure. This helps you to create an infrastructure that
    is consistent with the infrastructure used for the exercises in this book. I hope
    this provides a hassle-free experience where you can spend more time learning
    about Istio rather than troubleshooting infrastructure issues. Follow the steps
    provided at [https://learn.hashicorp.com/tutorials/terraform/install-cli?in=terraform/aws-get-started](https://learn.hashicorp.com/tutorials/terraform/install-cli?in=terraform/aws-get-started).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Terraform，它是一个基础设施即代码软件，可以自动化基础设施的配置。这有助于你创建与本书中的练习所用基础设施一致的基础设施。我希望这能为你提供一个无忧的体验，让你能更多时间学习Istio，而不是解决基础设施问题。按照[https://learn.hashicorp.com/tutorials/terraform/install-cli?in=terraform/aws-get-started](https://learn.hashicorp.com/tutorials/terraform/install-cli?in=terraform/aws-get-started)提供的步骤进行操作。
- en: Creating an EKS cluster
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建EKS集群
- en: Next, you will need to create an EKS cluster. `sockshop/devops/deploy/terraform`
    in the source code repo of this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建一个EKS集群。在本书的源代码仓库中的`sockshop/devops/deploy/terraform`目录下创建。
- en: 'Perform the following steps from the `sockshop/devops/deploy/terraform/src`
    folder:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从`sockshop/devops/deploy/terraform/src`文件夹中执行以下步骤：
- en: 'Initialize Terraform. Prepare the working directory so that Terraform can run
    the configurations:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化Terraform。准备工作目录，使Terraform能够运行配置：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can read about `init` at [https://developer.hashicorp.com/terraform/tutorials/cli/init](https://developer.hashicorp.com/terraform/tutorials/cli/init).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://developer.hashicorp.com/terraform/tutorials/cli/init](https://developer.hashicorp.com/terraform/tutorials/cli/init)上阅读有关`init`的更多信息。
- en: Configure Terraform variables by modifying `sockshop/devops/deploy/terraform/src/variables.tf`.
    Default values will work, but you can also modify them to suit your requirements.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过修改`sockshop/devops/deploy/terraform/src/variables.tf`配置Terraform变量。默认值可以使用，但你也可以根据需求修改它们。
- en: Plan the deployment. In this step, Terraform creates an execution plan that
    you can inspect to find any discrepancies and get a preview of the infrastructure,
    although it is not provisioned yet.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规划部署。在这一步中，Terraform会创建一个执行计划，你可以检查该计划，以查找任何不一致之处并预览基础设施，尽管它还未被配置。
- en: 'The output in the following code snippet is shortened to save space:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段中的输出已被简化，以节省空间：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can read more about `plan` at [https://developer.hashicorp.com/terraform/tutorials/cli/plan](https://developer.hashicorp.com/terraform/tutorials/cli/plan).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://developer.hashicorp.com/terraform/tutorials/cli/plan](https://developer.hashicorp.com/terraform/tutorials/cli/plan)上阅读更多关于`plan`的信息。
- en: 'Provision the infrastructure. In this step, Terraform will create the infrastructure
    as per the execution plan created in previous steps:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置基础设施。在这一步中，Terraform会根据前面创建的执行计划来创建基础设施：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once the infrastructure is provisioned, Terraform will also set a variable as
    defined in `sockshop/devops/deploy/terraform/src/outputs.tf`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦基础设施配置完成，Terraform还会设置` sockshop/devops/deploy/terraform/src/outputs.tf`中定义的变量。
- en: You can read more about `apply` at [https://developer.hashicorp.com/terraform/tutorials/cli/apply](https://developer.hashicorp.com/terraform/tutorials/cli/apply).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://developer.hashicorp.com/terraform/tutorials/cli/apply](https://developer.hashicorp.com/terraform/tutorials/cli/apply)上阅读更多关于`apply`的信息。
- en: Setting up kubeconfig and kubectl
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置kubeconfig和kubectl
- en: 'Next, we will configure kubectl to be able to connect the newly created EKS
    cluster using Terraform. Use the following aws cli command to update kubeconfig
    with cluster details:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将配置kubectl，以便通过Terraform连接到新创建的EKS集群。使用以下aws cli命令更新kubeconfig以包含集群详情：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, check that kubectl is using the correct context:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，检查kubectl是否使用正确的上下文：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the value is not as expected, you can perform the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值不符合预期，你可以执行以下操作：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Find the correct name of the cluster and then use the following command to
    set the kubectl context:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 查找集群的正确名称，然后使用以下命令设置kubectl上下文：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There will be instances where you will need to use minikube. In such a case,
    simply use the following command to switch context, and vice versa for switching
    back to EKS:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你需要使用minikube。在这种情况下，只需使用以下命令切换上下文，反之亦然，切换回EKS：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Deploying the Sockshop application
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署Sockshop应用程序
- en: 'Finally, to add some variety to hands-on exercises, we will make use of a demo
    application called Sockshop available at [https://github.com/microservices-demo/microservices-demo](https://github.com/microservices-demo/microservices-demo).
    You can find the deployment files in `sockshop/devops/deploy/kubernetes/manifests`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了增加实践练习的多样性，我们将使用一个名为Sockshop的演示应用程序，该应用程序可以在[https://github.com/microservices-demo/microservices-demo](https://github.com/microservices-demo/microservices-demo)找到。您可以在`sockshop/devops/deploy/kubernetes/manifests`中找到部署文件：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will deploy the Sockshop application, and you are all set with the environment.
    The next step for you is to install the latest version of Istio using the instructions
    at [https://istio.io/latest/docs/setup/install/istioctl/](https://istio.io/latest/docs/setup/install/istioctl/)
    and the concepts you learned about in *Chapter 2*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将部署Sockshop应用程序，您已准备好环境。接下来的步骤是按照[https://istio.io/latest/docs/setup/install/istioctl/](https://istio.io/latest/docs/setup/install/istioctl/)的说明安装Istio的最新版本，并应用您在*第二章*中学习的概念。
- en: In the rest of the chapter and the book, we will be making use of the Sockshop
    application to demonstrate various Service Mesh concepts. Feel free to use the
    sample `BookInfo` application that is provided with Istio, or any other application
    you may like for performing hands-on exercises. Let’s get started!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和本书的其余部分，我们将使用Sockshop应用程序来演示各种Service Mesh概念。您也可以随意使用Istio附带的示例`BookInfo`应用程序，或者任何您喜欢的应用程序来进行实践练习。让我们开始吧！
- en: Managing Ingress traffic using the Kubernetes Ingress resource
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes Ingress资源管理Ingress流量
- en: When building applications that need to be consumed by other applications from
    outside the network boundary in which the application is deployed, you will need
    to build an Ingress point using which the consumers can reach the application.
    In Kubernetes, a Service is an abstraction through which a set of Pods are exposed
    as a network service. When these services need to be consumed by other applications,
    they need to be made externally accessible. Kubernetes supports `ClusterIP` for
    consuming services internally from within the cluster, `NodePort` for consuming
    the service outside the cluster but within the network, `LoadBalancer` for consuming
    the services externally via the cloud load balancer, and there are also options
    for exposing an internal-facing load balancer for internal traffic outside of
    the Kubernetes cluster. In this section, we will read about how we can configure
    Istio to expose a service using the Kubernetes Ingress resource.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建需要由外部网络边界之外的其他应用程序访问的应用程序时，您需要创建一个Ingress点，消费者可以通过该点访问应用程序。在Kubernetes中，Service是一个抽象，通过它可以将一组Pod暴露为网络服务。当这些服务需要被其他应用程序使用时，它们需要对外部可访问。Kubernetes支持`ClusterIP`用于从集群内部访问服务，`NodePort`用于在集群外部但在网络内访问服务，`LoadBalancer`用于通过云负载均衡器外部访问服务，还可以选择暴露一个面向内部流量的负载均衡器，供Kubernetes集群外的内部流量使用。在本节中，我们将了解如何配置Istio，通过Kubernetes
    Ingress资源暴露服务。
- en: In the previous chapter, we exposed the frontend service as a `NodePort` type
    and accessed it via minikube tunnel as well as AWS `Loadbalancer`. This approach
    takes away any control we might need on how the traffic to the frontend service
    should be managed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们将前端服务暴露为`NodePort`类型，并通过minikube tunnel以及AWS `Loadbalancer`访问它。这个方法剥夺了我们对如何管理前端服务流量的控制。
- en: 'So, instead of making use of `Loadbalancer` service types to expose the frontend
    service, let’s make the frontend service internal facing and rather make use of
    the Kubernetes Ingress resource. Update the frontend service Kubernetes configuration
    by removing `NodePort` (if using minikube) or `LoadBalancer` (if deploying on
    AWS) by removing the following lines from the YAML file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了使用`Loadbalancer`服务类型来暴露前端服务外，让我们将前端服务设置为内部服务，并改为使用Kubernetes Ingress资源。通过从YAML文件中删除以下行，更新前端服务的Kubernetes配置，移除`NodePort`（如果使用minikube）或`LoadBalancer`（如果在AWS上部署）：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding changes make the service type take the default value of `ClusterIp`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的更改使得服务类型采用了`ClusterIp`的默认值。
- en: The updated file is also available in the `Chapter4` folder under the name `10-1-front-end-svc.yaml`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的文件也可以在`Chapter4`文件夹中找到，文件名为`10-1-front-end-svc.yaml`。
- en: 'Go ahead and change the frontend service type to `ClusterIP` using the following
    command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用以下命令将前端服务类型更改为`ClusterIP`：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After the changes, you will notice that the Sockshop website is not accessible
    from the browser due to obvious reasons.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 变更后，你会注意到，由于明显的原因，浏览器无法访问 Sockshop 网站。
- en: 'Now, we will make use of the Kubernetes Ingress resource to provide access
    to the Sockshop frontend service. Kubernetes Ingress is a way to provide access
    to `ClusterIP` services in the cluster. Ingress defines the addressed host accepted
    by Ingress, along with a list of URIs and the services to which the request needs
    to be routed. The following is an illustration highlighting this concept:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将利用 Kubernetes Ingress 资源来为 Sockshop 前端服务提供访问。Kubernetes Ingress 是为集群中的
    `ClusterIP` 服务提供访问的一种方式。Ingress 定义了 Ingress 接受的目标主机，并列出了 URI 和请求需要路由到的服务。以下是突出此概念的图示：
- en: '![Figure 4.1 – Kubernetes Ingress resource](img/B17989_04_01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – Kubernetes Ingress 资源](img/B17989_04_01.jpg)'
- en: Figure 4.1 – Kubernetes Ingress resource
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – Kubernetes Ingress 资源
- en: Along with defining Ingress, we also need to define Ingress controllers, which
    are another Kubernetes resource that is responsible for handling the traffic as
    per the specification defined in the Ingress resource.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义 Ingress 时，我们还需要定义 Ingress 控制器，Ingress 控制器是另一种 Kubernetes 资源，负责根据 Ingress
    资源中定义的规范处理流量。
- en: The following illustrates the relationship between Ingress, Ingress controllers,
    and Services. Please note that Ingress is a logical construct – that is, a set
    of rules enforced by the Ingress controller.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了 Ingress、Ingress 控制器和服务之间的关系。请注意，Ingress 是一个逻辑构造——也就是说，它是由 Ingress 控制器强制执行的一组规则。
- en: '![Figure 4.2 – Ingress controllers](img/B17989_04_02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – Ingress 控制器](img/B17989_04_02.jpg)'
- en: Figure 4.2 – Ingress controllers
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – Ingress 控制器
- en: Next, we will be making use of the Istio Gateway controller to handle the Ingress;
    we read about the Istio Gateway in *Chapter 3*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 Istio Gateway 控制器来处理 Ingress；我们在*第 3 章*中介绍了 Istio Gateway。
- en: 'We will need to provide the following configuration, also defined in `Chapter4/1-istio-ingress.yaml`,
    to make the changes:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供以下配置，也定义在 `Chapter4/1-istio-ingress.yaml` 中，以进行更改：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding configuration, we are doing the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，我们正在执行以下操作：
- en: 'Creating an Ingress resource with an annotation of `kubernetes.io/ingress.class:
    istio`, which, via admission controllers, as we discussed in *Chapter 3*, tells
    Istio that this Ingress is to be handled by the Istio Gateway.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '创建一个带有 `kubernetes.io/ingress.class: istio` 注解的 Ingress 资源，通过 admission controllers（我们在*第
    3 章*中讨论过）告诉 Istio，该 Ingress 由 Istio Gateway 处理。'
- en: The Ingress resource is defined in the `sock-shop` namespace, as that’s where
    our Sockshop frontend service exists.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ingress 资源在 `sock-shop` 命名空间中定义，因为我们的 Sockshop 前端服务就存在于这个命名空间中。
- en: A rule that says that any request specified by `path` of the `/` value and destined
    for the `"sockshop.com"` host (specified by `host` and the `sockshop.com` value)
    should be handled by this Ingress.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规定任何指定为 `/` 路径并且目标主机为 `"sockshop.com"`（由 `host` 和 `sockshop.com` 值指定）的请求应由该
    Ingress 处理的规则。
- en: 'Within the `path` configuration, we are configuring `pathType` of `Prefix`,
    which basically means that any request of the `hostname/` format will be matched.
    Other values for `pathType` are as follows:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `path` 配置中，我们正在配置 `pathType` 为 `Prefix`，这基本意味着任何以 `hostname/` 格式的请求都会被匹配。`pathType`
    的其他值如下：
- en: '`Exact`: the path is matching exactly as specified in `path`'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exact`：路径与 `path` 中指定的内容完全匹配'
- en: '`ImplementationSpecific`: the matching of `path` is decided by the underlying
    implementation of the Ingress controller'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImplementationSpecific`：`path` 的匹配由 Ingress 控制器的底层实现决定'
- en: 'Apply the rule using the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令应用规则：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you are using minikube for this exercise, then run `minikube tunnel` in
    a separate terminal and get the external IP from the output. Find the port at
    which the service is exposed by the Istio Ingress gateway using the following
    command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在做这个练习时使用的是 minikube，请在单独的终端中运行 `minikube tunnel`，并从输出中获取外部 IP。使用以下命令找到 Istio
    Ingress 网关暴露服务的端口：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this instance, the Ingress gateway is exposing traffic from port `80` to
    Ingress port `31120`, and `443` to `30149`, but it may be different for your setup.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实例中，Ingress 网关将端口 `80` 的流量暴露到 Ingress 端口 `31120`，并将 `443` 暴露到 `30149`，但你的设置可能有所不同。
- en: 'If you followed the instruction in *Chapter 4* to use AWS EKS, then the IP
    and ports will be different; the following is an equivalent of minikube for AWS
    EKS:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照*第 4 章*中的说明使用了 AWS EKS，那么 IP 和端口会有所不同；以下是 AWS EKS 中与 minikube 等效的配置：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this example, the Ingress gateway is exposed via an AWS classic load balancer
    at the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，Ingress 网关通过 AWS 经典负载均衡器暴露，地址如下：
- en: '`http://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com:80`
    for HTTP traffic'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com:80`
    用于 HTTP 流量'
- en: '`https://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com:443`
    for HTTPS traffic'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com:443`
    用于 HTTPS 流量'
- en: Going forward, please use appropriate IPs and ports depending on your choice
    of environment. The examples in the rest of the chapters are deployed on the AWS
    EKS cluster, but they will also work for any other Kubernetes provider.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，请根据您选择的环境使用适当的 IP 地址和端口。接下来章节中的示例部署在 AWS EKS 集群上，但它们也适用于任何其他 Kubernetes 提供商。
- en: 'Go ahead and test the Ingress to frontend service via `curl`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 继续，通过 `curl` 测试 Ingress 到前端服务：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Or if using the Chrome browser, then use extensions such as ModHeader, available
    at [http://modheader.com/](http://modheader.com/). In either case, you will need
    to provide the `host` header with the value of `sockshop.com`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果使用 Chrome 浏览器，则可以使用如 ModHeader 等扩展，访问 [http://modheader.com/](http://modheader.com/)。无论哪种情况，您都需要提供
    `host` 头，并将其值设置为 `sockshop.com`。
- en: So, we saw how the Istio Ingress gateway can be configured to handle Kubernetes
    Ingress.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们看到 Istio Ingress 网关可以配置为处理 Kubernetes Ingress。
- en: 'Let’s add another Ingress rule to see how the Istio Ingress controller can
    handle multiple Ingress rules. We will be making use of the `envoy` configuration
    we did in *Chapter 3*, where we used a router filter to return a dummy string:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一个 Ingress 规则，看看 Istio Ingress 控制器如何处理多个 Ingress 规则。我们将使用我们在 *第 3 章* 中做的
    `envoy` 配置，其中我们使用了一个路由过滤器返回一个虚拟字符串：
- en: 'In the following command, we are creating a `chapter4` namespace so that we
    can be organized, and it will be easier to clean up:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下命令中，我们创建了一个 `chapter4` 命名空间，以便于管理，并且清理时也更方便：
- en: '[PRE16]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At this stage, we don’t need automatic sidecar injection, but from a visibility
    point of view and for getting meaningful information from Kiali, it will be a
    good idea to enable Istio sidecar injection using the following command we discussed
    in *Chapter 2*:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此阶段，我们不需要自动侧车注入，但从可视化的角度出发，为了从 Kiali 获取有意义的信息，启用 Istio 侧车注入将是一个好主意，可以使用我们在
    *第 2 章* 中讨论的以下命令：
- en: '[PRE17]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will then go ahead with the creation of `configmap` to load `envoy` config
    (also discussed in *Chapter 3*), which will be required by the Pods we will be
    creating in the next step:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将继续创建 `configmap` 来加载 `envoy` 配置（也在 *第 3 章* 中讨论），这是我们将在下一步创建的 Pods 所需要的：
- en: '[PRE18]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we are creating the service and deployment to run `envoy` to return a
    dummy response for all HTTP requests:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建服务和部署以运行 `envoy`，为所有 HTTP 请求返回一个虚拟响应：
- en: '[PRE19]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And finally, we create an Ingress rule to route all traffic destined for `mockshop.com`
    to the `envoy` service we created in the previous step:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个 Ingress 规则，将所有目标为 `mockshop.com` 的流量路由到我们在前一步中创建的 `envoy` 服务：
- en: '[PRE20]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Go ahead and test using the `sockshop.com` and `mockshop.com` hosts headers;
    the Istio Ingress controller will manage the routing to the appropriate destination
    as per defined Ingress rules.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续使用 `sockshop.com` 和 `mockshop.com` 主机头进行测试；Istio Ingress 控制器将根据定义的 Ingress
    规则管理路由到适当的目标。
- en: 'The following illustration describes what we have configured so far. Note how
    the Ingress rules define the routing of traffic to Service A and B based on hostnames:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了我们迄今为止配置的内容。请注意，Ingress 规则如何根据主机名定义流量路由到服务 A 和 B：
- en: '![Figure 4.3 – Snapshot of Ingress configuration](img/B17989_04_03.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – Ingress 配置快照](img/B17989_04_03.jpg)'
- en: Figure 4.3 – Snapshot of Ingress configuration
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – Ingress 配置快照
- en: In this section, we discussed how to expose services outside of the Kubernetes
    cluster using the Kubernetes Ingress resource and Istio Ingress controller. In
    this kind of Ingress configuration, although we are using Istio to manage the
    Ingress, we are limited by the spec of Kubernetes Ingress, which allows Ingress
    controllers to perform limited functions such as load balancing, SSL termination,
    and name-based virtual hosting. When using the Kubernetes Ingress resource type,
    we are not leveraging a wide range of functionality provided by Istio to manage
    Ingress. When using Istio, it is recommended to use the Istio Gateway CRD to manage
    Ingress; we will be discussing that in the next section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何使用Kubernetes Ingress资源和Istio Ingress控制器将服务暴露到Kubernetes集群外部。在这种Ingress配置中，尽管我们使用Istio来管理Ingress，但我们受限于Kubernetes
    Ingress的规格，这使得Ingress控制器只能执行有限的功能，如负载均衡、SSL终止和基于名称的虚拟主机。使用Kubernetes Ingress资源类型时，我们没有充分利用Istio提供的广泛功能来管理Ingress。使用Istio时，建议使用Istio网关CRD来管理Ingress；我们将在下一节讨论这一点。
- en: 'Before moving on, let’s do some technical cleanup of your environment so that
    it doesn’t conflict with upcoming exercises:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们先进行一些环境的技术清理，以避免与接下来的练习产生冲突：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Important note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Throughout this book, we will be leaving you reminders to reverse or clean up
    the configurations. You can use the preceding commands to execute the cleanup.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将给出一些提醒，让你反向或清理配置。你可以使用前述命令来执行清理操作。
- en: Managing Ingress using the Istio Gateway
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Istio网关管理Ingress
- en: When managing Ingress, it is recommended to make use of Istio Gateway over the
    Kubernetes Ingress resource. Istio Gateway is like a load balancer running at
    the edge of the mesh receiving incoming HTTP and TCP connections.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理Ingress时，建议优先使用Istio网关，而非Kubernetes Ingress资源。Istio网关像一个负载均衡器，运行在服务网格的边缘，接收传入的HTTP和TCP连接。
- en: When configuring Ingress via Istio Gateway, you need to perform the following
    tasks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过Istio网关配置Ingress时，你需要执行以下任务。
- en: Creating the gateway
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建网关
- en: 'The following code block creates an Istio Gateway resource:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块创建了一个Istio网关资源：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we are declaring a Kubernetes resource named `chapter4-gateway` of the
    `gateway.networking.istio.io` type custom resource definition in the `chapter4`
    namespace. This is also equivalent to defining a load balancer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为`chapter4-gateway`的Kubernetes资源，该资源属于`gateway.networking.istio.io`类型的自定义资源定义，位于`chapter4`命名空间中。这也等同于定义了一个负载均衡器。
- en: 'In the `servers` property, we are defining the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`servers`属性中，我们定义了以下内容：
- en: '`hosts`: These are one or more DNS names exposed by the gateway. In the preceding
    example, we are defining two hosts: `sockshop.com` and `mockshop.com`. Any other
    hosts apart from these two will be rejected by the Ingress gateway.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hosts`：这些是网关暴露的一个或多个DNS名称。在前面的例子中，我们定义了两个主机：`sockshop.com`和`mockshop.com`。除了这两个主机之外，任何其他主机将被Ingress网关拒绝。'
- en: '`port`: In the port configuration, we define port numbers and the protocols,
    which can be either `HTTP`, `HTTPS`, `gRPC`, `TCP`, `TLS`, or `Mongo`. The name
    of the port can be anything you like to use. In this example, we are exposing
    port `80` over the `HTTP` protocol.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`：在端口配置中，我们定义了端口号和协议，可以是`HTTP`、`HTTPS`、`gRPC`、`TCP`、`TLS`或`Mongo`。端口名称可以是任何你喜欢使用的名称。在这个例子中，我们通过`HTTP`协议暴露端口`80`。'
- en: To summarize, the gateway will accept any HTTP request over port `80` with the
    host header of `sockshop.com` or `mockshop.com`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，网关将接受所有通过端口`80`的HTTP请求，且主机头为`sockshop.com`或`mockshop.com`。
- en: Creating virtual services
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建虚拟服务
- en: 'A virtual service is another set of abstractions between the Ingress gateway
    and destination services. Using virtual services, you declare how the traffic
    for a single host (such as `sockshop.com`) or multiple hosts (such as `mockshop.com`
    and `sockshop.com`) should be routed to its destination. For example, you can
    define the following in a virtual service for all traffic addressed to `sockshop.com`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟服务是Ingress网关与目标服务之间的另一层抽象。通过虚拟服务，你可以声明如何将一个主机（如`sockshop.com`）或多个主机（如`sockshop.com`和`mockshop.com`）的流量路由到目标。例如，你可以在虚拟服务中定义以下内容，针对所有指向`sockshop.com`的流量：
- en: Request with the `/path1` URI should go to service 1, and `/path2` should go
    to service 2
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求带有`/path1` URI的应发送到服务1，带有`/path2`的应发送到服务2。
- en: Route request based on the value of header or query parameters
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据头信息或查询参数的值来路由请求。
- en: Weight-based routing or traffic splitting – for example, 60% of the traffic
    goes to version 1 of the service and 40% goes to another version of the traffic
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于权重的路由或流量拆分——例如，60%的流量进入服务的版本1，40%的流量进入另一个版本的服务
- en: Define timeouts – that is, if a response is not received from the upstream service
    in *X* seconds, then the request should time out
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义超时——即，如果在*X*秒内未收到来自上游服务的响应，则请求应超时
- en: Retry – that is, how many times a request should be attempted if the upstream
    system is not responding or is too slow to respond
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试——即，如果上游系统没有响应或响应过慢，请尝试多少次请求
- en: All these routing features are implemented via virtual services, and we will
    read more about them in this chapter as well as the next chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些路由功能都是通过虚拟服务实现的，我们将在本章以及下一章中详细了解它们。
- en: 'In the following configuration, we are defining two virtual services that contain
    rules regarding traffic matching and to what destination it should be routed:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下配置中，我们定义了两个虚拟服务，这些服务包含关于流量匹配的规则以及流量应路由到的目标：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding configuration, we have defined a virtual service named `sockshop`.
    In the `spec` property, we are defining the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配置中，我们定义了一个名为`sockshop`的虚拟服务。在`spec`属性中，我们定义了以下内容：
- en: '`hosts`: The rules in this virtual service will be applied to traffic destined
    for `sockshop.com` as defined under `host`.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hosts`：此虚拟服务中的规则将应用于目标为`sockshop.com`的流量，正如在`host`中定义的那样。'
- en: '`gateway`: This virtual service is associated with `chapter4-gateway` we created
    in step 1 (*Creating the gateway*); this enforces that any other traffic not associated
    with the mentioned gateway will not be processed by this virtual service configuration.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gateway`：此虚拟服务与我们在第1步（*创建网关*）中创建的`chapter4-gateway`关联；这强制要求任何未与该网关关联的流量不会被此虚拟服务配置处理。'
- en: '`http`: Here, we will define rules and routing information for HTTP traffic.
    There is also an option for defining `tls` and `tcp` routes; `tls` is used for
    passthrough TLS or HTTPS traffic, whereas `tcp` is used for opaque TCP traffic.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http`：在这里，我们将定义HTTP流量的规则和路由信息。还有定义`tls`和`tcp`路由的选项；`tls`用于透传TLS或HTTPS流量，而`tcp`用于不透明的TCP流量。'
- en: '`match`: These contain the matching criteria and can be based on path, headers,
    and so on. In this example, we are instructing that all traffic will be routed
    as per the instruction in this section.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match`：这些包含匹配标准，可以基于路径、头部等。在此示例中，我们指示所有流量都将根据本节中的指示进行路由。'
- en: '`route`: If the traffic is matched, the traffic is routed as per the information
    provided here. In this example, we are routing traffic to `front-end.sock-shop.svc.cluster.local`
    on port `80`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route`：如果流量匹配，则根据这里提供的信息路由流量。在此示例中，我们将流量路由到`front-end.sock-shop.svc.cluster.local`的端口`80`。'
- en: You can find the declaration of the corresponding virtual service for `envoy-dummy-svc`
    in `Chapter4/3-istio-gateway.yaml`. The file combines the declaration of the gateway
    and virtual services.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Chapter4/3-istio-gateway.yaml`中找到与`envoy-dummy-svc`对应的虚拟服务声明。该文件结合了网关和虚拟服务的声明。
- en: As a next step, if not already deleted as per the cleanup notes of the previous
    section, then please delete the Ingress resources you created in the previous
    section so that they do not conflict with the configuration we will be applying
    in this section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，如果尚未按照上一节的清理说明删除，则请删除上一节中创建的Ingress资源，以避免与我们将在本节应用的配置发生冲突。
- en: 'Apply the new configuration:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 应用新配置：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Please test that you are able to access `sockshop.com` and `mockshop.com` using
    your preferred HTTP client, and do not forget to inject the correct `host` header.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请测试你是否能够使用你喜欢的HTTP客户端访问`sockshop.com`和`mockshop.com`，并且不要忘记注入正确的`host`头。
- en: 'If you are finding it difficult to visualize the end-to-end configuration,
    then take the help of the following illustrations:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现很难将端到端的配置可视化，那么可以参考以下插图：
- en: 'The following diagram summarizes the configuration in this section:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下图表总结了本节中的配置：
- en: '![Figure 4.4 – Virtual services](img/B17989_04_04.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 虚拟服务](img/B17989_04_04.jpg)'
- en: Figure 4.4 – Virtual services
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 虚拟服务
- en: 'The following diagram summarizes the association between various Istio CRDs
    and Kubernetes resources:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下图表总结了各种Istio CRD和Kubernetes资源之间的关联：
- en: '![Figure 4.5 – Association between virtual services and other Istio resources](img/B17989_04_05.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 虚拟服务与其他Istio资源之间的关联](img/B17989_04_05.jpg)'
- en: Figure 4.5 – Association between virtual services and other Istio resources
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 - 虚拟服务与其他Istio资源的关联
- en: In this section, we learned how to use Istio Gateway and virtual services for
    managing Ingress.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用Istio Gateway和虚拟服务来管理Ingress。
- en: Reminder
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: Please clean up `chapter4/3-istio-gateway.yaml` to avoid conflict with the upcoming
    exercises.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请清理`chapter4/3-istio-gateway.yaml`文件，以避免与即将进行的练习发生冲突。
- en: Traffic routing and canary release
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流量路由与金丝雀发布
- en: In the previous section, we went through some of the functionality of virtual
    services; in this section, let’s go through how you can distribute traffic to
    multiple destinations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分中，我们了解了虚拟服务的一些功能；在这一部分中，我们将介绍如何将流量分配到多个目标。
- en: I’m assuming you have the `envoy-dummy` config map configured and the `envoy`
    Pod and service running as per the `01-envoy-proxy.yaml` file. If not, follow
    the instructions in the previous section to get these configured.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经配置了`envoy-dummy`配置映射，并且根据`01-envoy-proxy.yaml`文件启动了`envoy` Pod和服务。如果没有，请按照前面的说明配置这些内容。
- en: 'In the following exercise, we will be creating another version of the `envoydummy`
    Pod called `v2`, which returns a different response than `v1`. We will deploy
    `v2` alongside `v1` and then configure traffic splitting between the two versions
    of the `envoydummy` Pods:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将创建另一个名为`v2`的`envoydummy` Pod版本，它返回与`v1`不同的响应。我们将并行部署`v2`和`v1`，然后配置两者之间的流量分配：
- en: 'Create another version of the `envoy` mock service but with a different message:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个版本的`envoy`模拟服务，但使用不同的消息：
- en: '[PRE25]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The changes can be found in `Chapter4/envoy-config-2.yaml`; go ahead and create
    another config map:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改内容可以在`Chapter4/envoy-config-2.yaml`中找到；请继续创建另一个配置映射：
- en: '[PRE26]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, create another Deployment, but this time label the Pods as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建另一个部署，但这次请按以下方式标记Pods：
- en: '[PRE27]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Apply the changes:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用更改：
- en: '[PRE28]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we will be creating another virtual service, but with the following changes:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建另一个虚拟服务，但会做以下更改：
- en: '[PRE29]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You must have noticed that we have two destinations under the same route. `destination`
    indicates the location of the service to which the requests are eventually routed.
    Under `destination`, we have the following three fields:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定注意到我们在同一路由下有两个目标。`destination`表示请求最终路由到的服务位置。在`destination`下，我们有以下三个字段：
- en: '`host`: This states the service name to which the request should be routed.
    The service names are resolved against the Kubernetes service registry or hosts
    registered by Istio service entry. We will read about service entry in the next
    section.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`：这表示请求应该路由到的服务名称。服务名称会根据Kubernetes服务注册表或Istio服务入口注册的主机解析。我们将在下一部分讨论服务入口。'
- en: '`subset`: This is a subset of the service defined by the destination rule,
    as described next.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subset`：这是目标规则定义的服务子集，接下来会进行说明。'
- en: '`port`: This is the port on which the service is reachable.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`：这是服务可以访问的端口。'
- en: 'We are also associating weights to the routing rules, specifying that 10% of
    traffic should be sent to `subset: v1`, whereas 90% should be sent to `subset:
    v2`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还为路由规则关联了权重，指定10%的流量应发送到`subset: v1`，而90%的流量应发送到`subset: v2`。'
- en: Following the virtual service definition, we also need to define destination
    rules. Destination rules are a set of rules applied to the traffic after they
    have gone through the virtual service routing rules.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟服务定义之后，我们还需要定义目标规则。目标规则是一组应用于流量的规则，这些流量在通过虚拟服务路由规则后执行。
- en: 'In the following configuration, we are defining a destination rule called `envoy-destination`,
    which will be applied to traffic destined for `envoy-dummy-svc`. It further defines
    two subsets – `subset: v1` corresponds to the `envoy-dummy-svc` endpoints with
    the `version = v1` label, while `subset: v2` corresponds to endpoints with the
    `version =` `v2` label:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '在以下配置中，我们定义了一个名为`envoy-destination`的目标规则，这个规则将应用于指向`envoy-dummy-svc`的流量。它进一步定义了两个子集——`subset:
    v1`对应于带有`version = v1`标签的`envoy-dummy-svc`端点，而`subset: v2`对应于带有`version = v2`标签的端点：'
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Apply the changes:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 应用更改：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You will notice that 10% of the request will be returning `Bootstrap Service
    Mesh Implementation with Istio`, and 90% of the request will be returning the
    `V2----------Bootstrap Service Mesh Implementation with` `Istio----------V2` response.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，10%的请求将返回`Bootstrap Service Mesh Implementation with Istio`，而90%的请求将返回`V2----------Bootstrap
    Service Mesh Implementation with` `Istio----------V2`响应。
- en: 'If you are finding it difficult to visualize the end-to-end configuration,
    then take the help of the following illustration, which summarizes the configuration
    in this section:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Destination rules](img/B17989_04_06.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Destination rules
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the association between various Istio CRDs
    and Kubernetes resources:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Association between destination rules and other Istio resources](img/B17989_04_07.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Association between destination rules and other Istio resources
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check in the Kiali dashboard that traffic is getting routed in
    a 1:9 ratio between the two services:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Kiali dashboard showing traffic split](img/B17989_04_08.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Kiali dashboard showing traffic split
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Please clean up `Chapter4/4a-istio-gateway.yaml` to avoid conflicts in the upcoming
    exercises.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to route or split traffic between two versions
    of a service. This is fundamental to various operations related to traffic management,
    with the canary release being one of them. In the next section, we will read about
    traffic mirroring, which is also called **traffic shadowing**; it is another example
    of traffic routing.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Traffic mirroring
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Traffic mirroring** is another important feature that allows you to asynchronously
    copy traffic being sent to an upstream to another upstream service as well, also
    known as **mirrored service**. Traffic mirroring is on a fire-and-forget basis,
    where the sidecar/gateway will not wait for responses from the mirrored upstream.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an illustration of traffic mirroring:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Traffic mirroring](img/B17989_04_09.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Traffic mirroring
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'There are very interesting use cases for traffic mirroring, including the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Traffic mirroring to pre-production systems for testing purposes
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traffic mirroring to sink systems where traffic is recorded for out-of-band
    analysis
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, in the virtual service definition under route configuration,
    we are mentioning that 100% of traffic should be mirrored to `subset: v2`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Before applying the preceding changes, first, create an nginx service using
    the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After that, deploy the virtual service:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following illustrates the configuration of virtual services and destination
    rules:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Traffic mirroring via virtual services](img/B17989_04_10.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Traffic mirroring via virtual services
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: When accessing the service using `curl` or the browser with the `mockshop.com`
    host header, you will notice that you are always receiving a `Bootstrap Service
    Mesh Implementation with` `Istio` response.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: But if you check the nginx logs using the `kubectl logs nginxdummy -c nginx
    -n chapter4` command, you will notice that nginx is also receiving the request,
    indicating that the traffic has been shadowed to nginx.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: This completes a short section on traffic mirroring, a simple but powerful feature
    especially for event-driven architecture, testing, and training models when using
    machine learning and artificial intelligence.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分简短地介绍了流量镜像功能，它是一个简单但强大的特性，尤其适用于事件驱动架构、测试以及使用机器学习和人工智能进行模型训练时。
- en: Reminder
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: Please clean up `Chapter4/4b-istio-gateway.yaml` to avoid conflict in upcoming
    exercises.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请清理`Chapter4/4b-istio-gateway.yaml`文件，以避免在接下来的练习中出现冲突。
- en: Routing traffic to services outside of the cluster
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将流量路由到集群外的服务
- en: In your IT environments, not all services will be deployed within the Kubernetes
    cluster; there will be services running on traditional VMs or bare metal environments,
    there will be services that will be provided by SaaS providers as well as your
    business partners, and there will be services running outside or on a different
    Kubernetes cluster. In those scenarios, there is a requirement to let services
    from the mesh reach out to such services. So, as the next steps, let’s try building
    routes to a service outside of the cluster. We will make use of the `httpbin`
    service, available at [https://httpbin.org/](https://httpbin.org/).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的IT环境中，并非所有服务都将在Kubernetes集群内部署；一些服务将在传统的虚拟机或裸金属环境中运行，也有一些服务将由SaaS提供商或业务合作伙伴提供，另外还有一些服务将运行在外部或不同的Kubernetes集群中。在这些场景中，需要让网格中的服务能够访问这些外部服务。因此，接下来的步骤是尝试构建到集群外服务的路由。我们将使用位于[https://httpbin.org/](https://httpbin.org/)的`httpbin`服务。
- en: Any request destined for `mockshop.com/get` should be routed to `httpbin`; the
    rest should be processed by `envoy-dummy-svc, which` we created in the previous
    section.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 任何目标为`mockshop.com/get`的请求应路由到`httpbin`；其他请求应由我们在上一节中创建的`envoy-dummy-svc`处理。
- en: 'In the following virtual service definition, we have defined that any request
    with `/get` should be routed to `httpbin.org`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下虚拟服务定义中，我们已定义任何带有`/get`的请求应路由到`httpbin.org`：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Next, we will create `ServiceEntry`, which is a way of adding entries to Istio’s
    internal service registry. The Istio control plane manages a registry of all services
    within the mesh. The registry is populated from two kinds of data sources– one
    being the Kubernetes API server, which in turn uses etcd for maintaining a registry
    of all services in the cluster, and the second being a config store that is populated
    by `ServiceEntry` and `WorkloadEntry`. Now, `ServiceEntry` and `WorkloadEntry`
    are used to populate details about services that are unknown to the Kubernetes
    service registry. We will read about `WorkloadEntry` in *Chapter 10*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`ServiceEntry`，它是向Istio内部服务注册表添加条目的方法。Istio控制平面管理着网格内所有服务的注册表。该注册表由两种数据源填充——一种是Kubernetes
    API服务器，后者使用etcd来维护集群中所有服务的注册表，第二种是由`ServiceEntry`和`WorkloadEntry`填充的配置存储。现在，`ServiceEntry`和`WorkloadEntry`用于填充有关Kubernetes服务注册表中未知服务的详细信息。我们将在*第10章*中阅读关于`WorkloadEntry`的内容。
- en: 'The following is the `ServiceEntry` declaration for adding `httpbin.org` to
    the Istio service registry:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将`httpbin.org`添加到Istio服务注册表的`ServiceEntry`声明：
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `ServiceEntry` declaration, the following configurations are defined:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ServiceEntry`声明中，定义了以下配置：
- en: '`resolution`: Here, we define how the hostname should be resolved; the following
    are the possible values:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resolution`：在这里，我们定义如何解析主机名；以下是可能的值：'
- en: '`DNS`: Makes use of available DNS to resolve the hostname'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DNS`：利用可用的DNS来解析主机名'
- en: '`DNS_ROUND_ROBBIN`: In this case, the first resolved address is used'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DNS_ROUND_ROBBIN`：在这种情况下，使用第一个解析的地址'
- en: '`NONE`: No DNS resolution is required; the destination is specified in form
    of an IP address'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NONE`：不需要DNS解析；目标通过IP地址指定'
- en: '`STATIC`: Uses a static endpoint against the hostnames'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATIC`：使用静态端点对应主机名'
- en: '`location`: The service entry location is used to specify whether the requested
    service is part of the mesh or outside the mesh. Possible values are `MESH_EXTERNAL`
    and `MESH_INTERNAL`.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location`：服务条目的位置用于指定请求的服务是属于网格内部还是外部。可能的值有`MESH_EXTERNAL`和`MESH_INTERNAL`。'
- en: '`hosts`: This is the hostname associated with the service being requested;
    in this example, the host is `httpbin.org`. The host field in `ServiceEntry` is
    matched with host fields specified in virtual service and destination rules.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hosts`：这是与请求的服务相关联的主机名；在本例中，主机是`httpbin.org`。`ServiceEntry`中的主机字段与虚拟服务和目标规则中指定的主机字段匹配。'
- en: 'Go ahead and apply the changes:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续应用更改：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When executing `curl` to `/get`, you will receive a response from `httpbin.org`,
    whereas `/ping` should route to the `envoydummy` service.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Kiali dashboard showing connection to an external system via
    ServiceEntry](img/B17989_04_11.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Kiali dashboard showing connection to an external system via ServiceEntry
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Please clean up `Chapter4/5a-istio-gateway.yaml` to avoid conflict in upcoming
    exercises.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '`ServiceEntry` provides various options to register external services to the
    Istio registry so that traffic within the mesh can be correctly routed to workloads
    outside the mesh.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Exposing Ingress over HTTPS
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to configure the Istio Gateway to expose
    the Sockshop frontend application over HTTPs.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '*Steps 1* and *3* are optional if you already have a **Certificate Authority**
    (**CA**); usually, for production systems, these steps will be performed by your
    organization’s CA:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a CA. Here, we are creating a CA with `CN` (`sockshop.inc`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Generate a `sockshop.com`, which also generates a private key:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Sign the CSR using the CA with the following command:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Load the certificate and private key as a Kubernetes Secret:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a gateway and virtual service using the following command:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This way, we have created a certificate and loaded that along with its private
    key as a Kubernetes Secret.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are configuring Istio Gateway to use the Secret as a credential
    for TLS communications. In the `Chapter4/6-istio-gateway.yaml` file gateway, we
    are configuring `IstioGateway` as the Ingress, and listening on port `443` on
    the `HTTPS` server protocol:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the gateway configuration, we have changed the protocol version to `HTTPS`
    from `HTTP`, and we added the following configurations under `servers`>`tls`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '`Mode`: Indicates whether this port should be secured using TLS. Possible values
    for this field are as follows:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIMPLE`: This is the standard TLS setting that we have selected to expose
    Sockshop.'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MUTUAL`: This is for mutual TLS between the gateway and any system calling
    the gateway.'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PASSTHROUGH`: This is used when a connection needs to be routed to a virtual
    service with the host value as the **Server Name Indication** (**SNI**) presented
    during the call.'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: SNI
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: SNI is an extension of the TLS protocol, where the hostname or domain name of
    the destination service is shared at the TLS handshake process rather than Layer
    7\. SNI is useful where a server is hosting multiple domain names, with each represented
    by its own HTTPS certificate. By knowing the requested hostname at the Layer 5
    handshake, the server is able to present the correct certificate as per the presented
    SNI during the handshake.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '`AUTO_PASSTHROUGH`: This is the same as `PASSTHROUGH`, except that there is
    no need for virtual services. The connection is forwarded to upstream services
    as per the details in the SNI.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISTIO_MUTUAL`: This is the same as `MUTUAL`, except that the certificate used
    for mutual TLS is generated automatically by Istio.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Credential name`: This is the Secret that holds the private key and certificate
    to be used for the server-side connection during TLS. We created the Secret in
    *step 4*.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go ahead and access `sockshop.com`; you will have to use `--connect-to` in
    `curl` to get around the name resolution issue caused by the difference in the
    replacement name and the actual name of the host:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Please note, `a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com`
    is the `--resolve` in `curl`, similar to the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding command, `56407` is the local port on which the Ingress gateway
    is listening.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'During the connection, you will notice in the output that the gateway correctly
    presented the server-side certificates:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: One special point to make here is that we exposed `sockshop.com` as an `HTTPS`
    service without making any changes to the frontend services that host the website.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Please clean up `Chapter4/6-istio-gateway.yaml` to avoid conflict with upcoming
    exercises.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Enabling HTTP redirection to HTTPS
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For downstream systems that are still sending requests to non-HTTPS ports,
    we can implement HTTP redirection by making the following changes in gateway configuration
    for non-HTTPS ports:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We have simply added `httpsRedirect: true`, which makes the gateway send a
    `301` redirect for all non-HTTPS connections. Apply the changes and test the connection:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the output, you will notice the redirection to `sockshop.com`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Reminder
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: As usual, please clean up `Chapter4/7-istio-gateway.yaml` to avoid conflict
    with the next section exercises.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Enabling HTTPS for multiple hosts
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we defined the settings for `sockshop.com` on the
    gateway. We can also apply similar settings for multiple hosts on the gateway.
    In this section, we will enable TLS on the gateway for `mockshop.com` along with
    `sockshop.com`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make use of the CA we created in the previous section. So, as the next
    steps, let’s generate a CSR for `mockshop.com`:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Sign the CSR using the CA:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Load the certificate and private key as a Kubernetes Secret:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add the following configuration for `mockshop.com` under server configuration
    in the gateway:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Apply the changes:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: After the changes, the gateway will resolve the correct certificates based on
    the hostname.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now access `sockshop.com`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the response, you can see that the correct certificates have been presented:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Similarly, test `mockshop.com`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, check whether the certificate presented by the gateway belongs to `mockshop.com`:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this way, we have configured the Istio Ingress gateway to serve multiple
    TLS certificates depending on hostnames; this is also called SNI. The Istio Ingress
    gateway can resolve SNI at the TLS Layer 4 level, allowing it to serve multiple
    domain names over TLS.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Enabling HTTPS for CNAME and wildcard records
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last topic on HTTPS is how to manage certificates for CNAME and wildcard
    records. Especially for traffic exposed internally, it is important to support
    wildcard. In this section, we will configure the gateway to support wildcard using
    SNI support. We will be using the CA we created in previous sections:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a CSR for `*.sockshop.com` and sign it using the CA certificates, then
    create the Kubernetes Secret:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, add the `*.sockshop.com` hostname to the server configuration in the
    gateway:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Also, modify the virtual service with `*.sockshop.com`:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Apply the configuration:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can test `mockshop.com`, `sockshop.com`, or any other CNAME records for
    `sockshop.com`. The following example is using `my.sockshop.com`:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following is the snippet from the output of *step 5* showing that the correct
    certificate was presented during the handshake:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As you can see, Istio presented the correct wildcard certificate for CNAME.
    This example demonstrates how Istio gateways can be configured to handle multiple
    domains and subdomains.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: In this and prior sections, we read about the various ways Ingress and the routing
    of traffic within and outside of the mesh are managed by Istio. It is important
    that you go through the concepts of gateways, virtual services, destination rules,
    and service entries and play with the example provided in this chapter, as well
    as think of other examples and try to implement them. In *Chapter 6*, we will
    discuss security in more depth and will cover topics such as mTLS, and so on.
    But for now, we will read about how Istio manages Egress traffic.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to clean up `Chapter4/8-istio-gateway.yaml` and `Chapter4/9-istio-gateway.yaml`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Managing Egress traffic using Istio
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Routing traffic to services outside of the cluster* section, we discovered
    how service entries can be used to update the Istio service registry about services
    external to the mesh and the cluster. Service entries are a way to add additional
    entries into Istio’s internal service registry for virtual services to be able
    to route to those entries. An Egress gateway, however, is used for controlling
    how the traffic for external service leaves the mesh.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'To get familiar with Egress gateways, we will first deploy a Pod within the
    mesh from which we can call an external service:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The command creates a Pod from which you can perform `curl`; this mimics a
    workload running inside the mesh:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'From the shell, access `httpbin.org` using `curl`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, we will stop all Egress traffic from the mesh using the following command:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the previous command, we are modifying the Istio installation to change the
    outbound traffic policy from `ALLOW_ANY` to `REGISTRY_ONLY`, which enforces that
    only hosts defined with `ServiceEntry` resources are part of the mesh service
    registry.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back and try `curl` again; you will see the following output:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let’s now list `httpbin.org` in the Istio service registry by creating a service
    entry as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, you may go ahead and apply the configuration:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Access `https://httpbin.org/get` from the `curl` Pod; this time, you will succeed.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '`ServiceEntry` added `httpbin.org` to the mesh service registry, and hence
    we were able to access `httpbin.org` from the `curl` Pod.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Though `ServiceEntry` is great for providing external access, it does not provide
    any control over how the external endpoints should be accessed. For example, you
    may want only certain workloads or namespaces to be able to send traffic to an
    external resource. What if there is a need to verify the authenticity of an external
    resource by verifying its certificates?
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to clean up `Chapter4/10-a-istio-egress-gateway.yaml`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'The Egress gateway, along with a combination of virtual services, destination
    rules, and service entries, provides flexible options to manage and control traffic
    egressing out of the mesh. So, let’s make configuration changes to route all traffic
    for `httpbin.org` to the Egress gateway:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the Egress gateway, which is very similar to the Ingress gateway
    configuration. Please note the Egress gateway is attached to `httpbin.org`; you
    can provide other hosts or `*` to match all hostnames:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, configure the virtual service. Here, we are configuring the virtual service
    to attach to the Egress gateway as well as to the mesh:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In the following part of the virtual service definition, we are configuring
    that all traffic originating from within the mesh for the `httpbin.org` host will
    be directed to the Egress gateway:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We have configured `subset: httpbin` to apply destination rules; in this example,
    the destination rules are empty.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will add another rule to route traffic from the Egress gateway
    to `httpbin.org`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create a placeholder for any destination rules you might want to implement:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: You also need to add `ServiceEntry` for `httpbin.org`, which we discussed in
    the previous section.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go ahead and apply the changes:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Try accessing `httpbin.org` from the `curl` Pod; you will be able to access
    it now.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine the headers in the response, as well as the logs of `istio-egressgateway
    pods`. You will find information about the Egress gateway under `X-Envoy-Peer-Metadata-Id`.
    You can also see the request in the Egress gateway logs.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that you are not able to access `https://httpbin.org/get`, although
    we have defined `https` in the service entry. Try enabling `https` access to `httpbin.org`;
    you will find the solution in `Chapter4/10-c-istio-egress-gateway.yaml`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Egress is important to control traffic leaving the mesh. In *Chapter 6*, we
    will focus on some of the other security aspects of Egress.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Delete `chapter4/10-b-istio-egress-gateway.yaml` along with `chapter4` namespace.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'Revert the authorization policy to allow all outgoing traffic from the mesh
    without needing an Egress gateway using the following command:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '`$ istioctl install -y --set profile=demo --``set meshConfig.outboundTrafficPolicy.mode=ALLOW_ANY`'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we read about how to manage external traffic coming inside
    the Service Mesh using the Istio Ingress gateway, as well as how to manage internal
    traffic leaving the mesh via Istio Egress gateways.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned about virtual services and destination rules: how virtual services
    are used to describe the rules to route traffic to various destinations in the
    mesh, how destination rules are used to define the end destination, and how the
    destination processes the traffic routed via rules defined by virtual services.
    Using virtual services, we can perform weight-based traffic routing, which is
    also used for canary releases and blue-green deployment.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we learned about `ServiceEntry` and how it is used to make Istio
    aware of external services so that workloads in the mesh can send traffic to services
    outside the mesh. And finally, we learned how Egress gateways are used to control
    the Egress to endpoints defined by `ServiceEntry` so that we can access external
    services securely and reliably from the mesh. This chapter sets you up for the
    next chapter, where we will discuss how to implement application resiliency using
    the concepts from this chapter.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
