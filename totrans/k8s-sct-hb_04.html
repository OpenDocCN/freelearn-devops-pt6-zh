<html><head></head><body>
<div id="_idContainer024">
<h1 class="chapter-number" id="_idParaDest-75"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-76"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.2.1">Debugging and Troubleshooting Kubernetes Secrets</span></h1>
<p><span class="koboSpan" id="kobo.3.1">So far, we have identified the attack vectors for Kubernetes Secrets. </span><span class="koboSpan" id="kobo.3.2">Two of them are encryption at rest and encryption in transit. </span><span class="koboSpan" id="kobo.3.3">Previously, in </span><a href="B20970_03.xhtml#_idTextAnchor064"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Encrypting Secrets the Kubernetes-Native Way</span></em><span class="koboSpan" id="kobo.7.1">, encryption at rest helped us increase our security at rest and in transit. </span><span class="koboSpan" id="kobo.7.2">In this chapter, we will focus on debugging issues that we might have with Secrets. </span><span class="koboSpan" id="kobo.7.3">Secrets play a critical role in storing and providing sensitive information used by applications and services running in a Kubernetes environment. </span><span class="koboSpan" id="kobo.7.4">They are crucial to our applications, and understanding how to effectively troubleshoot Secret-related issues can save lots of time </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">and effort.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will expand on the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Discussion of common issues with </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Kubernetes Secrets</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Debugging and </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">troubleshooting Secrets</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Best practices for debugging and </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">troubleshooting Secrets</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">By the end of the chapter, we will have acquired the knowledge needed to tackle secret-related challenges effectively. </span><span class="koboSpan" id="kobo.17.2">Also, we should be able to follow certain workarounds and avoid common pitfalls when troubleshooting </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Secret-related issues.</span></span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">To link concepts with practice, we will use a series of tools and platforms commonly used to interact with containers, Kubernetes, and Secrets management. </span><span class="koboSpan" id="kobo.20.2">For this chapter, we need the </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">following tools:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.22.1">Docker</span></strong><span class="koboSpan" id="kobo.23.1"> (</span><a href="https://docker.com"><span class="koboSpan" id="kobo.24.1">https://docker.com</span></a><span class="koboSpan" id="kobo.25.1">) or</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.26.1"> Podman (</span><a href="https://podman.io"><span class="koboSpan" id="kobo.27.1">https://podman.io</span></a><span class="koboSpan" id="kobo.28.1">) as a </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">container </span></span><span class="No-Break"><a id="_idIndexMarker205"/></span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">engine.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.31.1">Golang</span></strong><span class="koboSpan" id="kobo.32.1"> (</span><a href="https://go.dev"><span class="koboSpan" id="kobo.33.1">https://go.dev</span></a><span class="koboSpan" id="kobo.34.1">), or Go, which </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.35.1">is a programming language used within our examples. </span><span class="koboSpan" id="kobo.35.2">Note that Kubernetes and most of its third-party components are written </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">in Go.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.37.1">minikube</span></strong><span class="koboSpan" id="kobo.38.1"> (</span><a href="https://minikube.sigs.k8s.io/docs/"><span class="koboSpan" id="kobo.39.1">https://minikube.sigs.k8s.io/docs/</span></a><span class="koboSpan" id="kobo.40.1">) allows us to run a single-node Kubernetes</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.41.1"> cluster on our personal computers, making it perfect for learning and </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">development purposes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.43.1">Git</span></strong><span class="koboSpan" id="kobo.44.1"> (</span><a href="https://git-scm.com"><span class="koboSpan" id="kobo.45.1">https://git-scm.com</span></a><span class="koboSpan" id="kobo.46.1">) is a version control system that we will be using to recover the</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.47.1"> book examples but also leverage our discovery of Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">management solutions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.49.1">Helm</span></strong><span class="koboSpan" id="kobo.50.1"> (</span><a href="https://helm.sh"><span class="koboSpan" id="kobo.51.1">https://helm.sh</span></a><span class="koboSpan" id="kobo.52.1">) is a package manager for Kubernetes that we will be using to</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.53.1"> simplify the deployment and management of </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">Kubernetes resources.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.55.1">GnuPG</span></strong><span class="koboSpan" id="kobo.56.1"> (</span><a href="https://gnupg.org/download/"><span class="koboSpan" id="kobo.57.1">https://gnupg.org/download/</span></a><span class="koboSpan" id="kobo.58.1">) is a free open source implementation of </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.59.1">OpenPGP. </span><span class="koboSpan" id="kobo.59.2">OpenPGP</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.60.1"> provides cryptographic privacy and authentication for </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">data communication.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.62.1">The following link gives you access to the digital materials used in </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">this book:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.64.1">The GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">repository: </span></span><a href="https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook"><span class="No-Break"><span class="koboSpan" id="kobo.66.1">https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook</span></span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.67.1">Note that reference to Kubernetes distributions such as Azure Kubernetes Engine, Rancher Kubernetes Engine, and Red Hat OpenShift will be made but you don’t need working instances of these to perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">hands-on exercises.</span></span></p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.69.1">Discussion of common issues with Kubernetes Secrets</span></h1>
<p><span class="koboSpan" id="kobo.70.1">Throughout </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.71.1">the previous chapters, we interacted with Kubernetes either through direct commands or by using YAML files. </span><span class="koboSpan" id="kobo.71.2">While applying those YAML specifications and applying the commands, some mistakes are very likely to occur along the way. </span><span class="koboSpan" id="kobo.71.3">An incorrect Secret name or YAML definition can introduce hours of troubleshooting to identify what caused the issue in the first place. </span></p>
<p><span class="koboSpan" id="kobo.72.1">For these reasons, certain principles need to </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">be followed:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.74.1">YAML files are structured and can create a source </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">of truth</span></span></li>
<li><span class="koboSpan" id="kobo.76.1">Reusability of Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">minimizes errors</span></span></li>
<li><span class="koboSpan" id="kobo.78.1">Automation removes human intervention, which is prone </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">to error</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.80.1">Applying a Secret eagerly every time we want to use it through the command line makes it easy to introduce an error in the specification. </span><span class="koboSpan" id="kobo.80.2">By having the Secret defined through a YAML file, it is easy to check the structure through an editor and to ensure that we have the desired outcome. </span><span class="koboSpan" id="kobo.80.3">Also, a YAML file gives the flexibility to apply the same Secret multiple times. </span><span class="koboSpan" id="kobo.80.4">In case of an error, the same file can be fixed </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">and applied.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">The other principal is a Secret's reusability. </span><span class="koboSpan" id="kobo.82.2">The reusability can happen in multiple ways. </span><span class="koboSpan" id="kobo.82.3">The more you apply the creation of the same Secret each time, the more likely you will encounter an error. </span><span class="koboSpan" id="kobo.82.4">A Secret that can reside in a </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.83.1">namespace can be used by </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">various components.</span></span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.85.1">Helm and Helm Secrets</span></h2>
<p><span class="koboSpan" id="kobo.86.1">When it comes to providing encryption and </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.87.1">decryption capabilities for Secrets on Helm charts, we have the option of the Helm Secrets plugin. </span><span class="koboSpan" id="kobo.87.2">With Helm Secrets, we can </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.88.1">encrypt sensitive data and the confidential information that resides on Kubernetes Secrets such as passwords, certificates, keys, and so on. </span><span class="koboSpan" id="kobo.88.2">There are various encryption options available when it comes to Helm Secrets. </span><span class="koboSpan" id="kobo.88.3">There are cloud KMS options such as AWS KMS and GCP KMS. </span><span class="koboSpan" id="kobo.88.4">There is also a non-vendor-based option, which is encryption through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">gpg</span></strong><span class="koboSpan" id="kobo.90.1"> command-line tool, an implementation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">OpenPGP standard.</span></span></p>
<h3><span class="koboSpan" id="kobo.92.1">Creating a PGP key</span></h3>
<p><span class="koboSpan" id="kobo.93.1">One of the options to encrypt a</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.94.1"> file with Helm Secrets is to use a PGP key. </span><span class="koboSpan" id="kobo.94.2">PGP uses public key encryption; a public and private key pair are used. </span><span class="koboSpan" id="kobo.94.3">The public key is used to encrypt the data and the private key to decrypt the data. </span><span class="koboSpan" id="kobo.94.4">The public key can be distributed, whereas the private key should be kept secret. </span><span class="koboSpan" id="kobo.94.5">Information can be encrypted by anyone who has access to the public key; however, the decryption can happen only through the actor holding the </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">encryption key.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">If a PGP key is not available, we can generate one </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.98.1">
$ gpg --generate-key</span></pre> <p><span class="koboSpan" id="kobo.99.1">This command will generate the key with some default options, for example, expiration after one year and a default key size. </span><span class="koboSpan" id="kobo.99.2">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">--full-generate-key</span></strong><span class="koboSpan" id="kobo.101.1"> function, there are more options during </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">key creation.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">A prompt </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.104.1">will ask for a passphrase; ignore this prompt and leave it empty. </span><span class="koboSpan" id="kobo.104.2">If the passphrase is not left empty, it will be required at every step of decryption making operations difficult </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">to automate.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">We can list the keys and retrieve the key we </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">already created:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.108.1">
$ gpg --list-keys
      00FFFE11421E1F1EED1EEE811E11E111D1111111
uid          [ultimate] test-key-2 &lt;kubernetes@secrets.com&gt;
sub   rsa3072 2023-08-27 [E] [expires: 2025-08-26]</span></pre> <p><span class="koboSpan" id="kobo.109.1">Now that we have a key generated, we can proceed with </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">encrypting Secrets.</span></span></p>
<h3><span class="koboSpan" id="kobo.111.1">Encrypting Secrets</span></h3>
<p><span class="koboSpan" id="kobo.112.1">Supposing we have this file with </span><a id="_idIndexMarker218"/><span class="No-Break"><span class="koboSpan" id="kobo.113.1">Helm values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.114.1">
jwt-key:
  value: secret-key</span></pre> <p><span class="koboSpan" id="kobo.115.1">Provided we already have a GPG key, Helm Secrets will use it in order to encrypt the sensitive values. </span><span class="koboSpan" id="kobo.115.2">We need to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">.sops.yaml</span></strong><span class="koboSpan" id="kobo.117.1"> file specifying the GPG key to </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">be used:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.119.1">
creation_rules:
    - pgp: &gt;-
        gpg-key</span></pre> <p><span class="koboSpan" id="kobo.120.1">Then we can just encrypt </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">the values:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.122.1">
helm secrets enc values.yaml</span></pre> <p><span class="koboSpan" id="kobo.123.1">Eventually, our file should look </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.125.1">
jwt-key:
    value:  ENC[AES256_GCM,data:9/0gmkCNm2DbEw==,iv:dbthtzx1t8KUHazh7v48T7ASep0rTbYJBrl/jEw6zWE=,tag:MLVXlruHpkMxYihPvNieVQ==,type:str]
sops:
...
</span><span class="koboSpan" id="kobo.125.2">    pgp:
          enc: |
            -----BEGIN PGP MESSAGE-----
             -----END PGP MESSAGE-----
    version: 3.7.3</span></pre> <p><span class="koboSpan" id="kobo.126.1">Helm and</span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.127.1"> Helm Secrets are two </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.128.1">of the many tools that can help us organize our Secrets in a structured format and keep them secured and encrypted on disk. </span><span class="koboSpan" id="kobo.128.2">Helm and Helm Secrets are examples of </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.129.1">keeping  Secrets in a YAML format and reusing them </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">through templating.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">To summarize, automation and proper Secret organization can not only give us productivity gains but also help a lot in removing the need for human intervention. </span><span class="koboSpan" id="kobo.131.2">Most of the time, when an error is introduced, it is highly likely to be caused by </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">human intervention.</span></span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.133.1">Secret application pitfalls</span></h2>
<p><span class="koboSpan" id="kobo.134.1">During the creation of Kubernetes </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.135.1">Secrets, we might encounter errors, which can occur due to several reasons. </span><span class="koboSpan" id="kobo.135.2">An error may come from an invalid YAML syntax, invalid Secret type, missing data, or bad encoding. </span><span class="koboSpan" id="kobo.135.3">On the bright side, failing to apply a Secret properly gives us immediate feedback. </span><span class="koboSpan" id="kobo.135.4">A dry run can help us to validate our operations before </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">executing them.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.137.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.138.1">Take note that all the Kubernetes commands executed take effect on the default namespace unless specified otherwise or configured through the Kubernetes context. </span><span class="koboSpan" id="kobo.138.2">The following commands will take effect on the default namespace or the namespace that has </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">been configured.</span></span></p>
<h3><span class="koboSpan" id="kobo.140.1">Dry run</span></h3>
<p><span class="koboSpan" id="kobo.141.1">Before applying a</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.142.1"> Kubernetes Secret, we can simulate the creation or update of the Secret by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">--dry-run</span></strong><span class="koboSpan" id="kobo.144.1"> option. </span><span class="koboSpan" id="kobo.144.2">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">--dry-run</span></strong><span class="koboSpan" id="kobo.146.1"> along with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">kubectl</span></strong><span class="koboSpan" id="kobo.148.1"> commands, we do not actually perform any operation. </span><span class="koboSpan" id="kobo.148.2">It is a helpful feature for testing and validating our Secret configurations before applying them, thus saving time </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">from troubleshooting.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">For example, we want to create a Secret </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">from literals:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.152.1">
$ kubectl create secret generic opaque-example-from-literals --from-literal=literal1=text-for-literal-1 --dry-run=client
secret/opaque-example-from-literals created (dry run)</span></pre> <p><span class="koboSpan" id="kobo.153.1">This output can confirm that our action will be successful. </span><span class="koboSpan" id="kobo.153.2">We can go one step further and produce a response </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">in YAML:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.155.1">
$ kubectl create secret generic opaque-example-from-literals --from-literal=literal1=text-for-literal-1 --dry-run=client -o yaml
secret/opaque-example-from-literals created (dry run)
apiVersion: v1
data:
  literal1: dGV4dC1mb3ItbGl0ZXJhbC0x
kind: Secret
metadata:
  creationTimestamp: null
  name: opaque-example-from-literals</span></pre> <p><span class="koboSpan" id="kobo.156.1">The dry run can help us validate the operation without applying it, and we can validate the outcome of the operations without the operation taking any effect. </span><span class="koboSpan" id="kobo.156.2">Though the </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">--dry-run</span></strong><span class="koboSpan" id="kobo.158.1"> option is extremely useful, it cannot be of help with Secrets that are successfully applied containing invalid data content. </span><span class="koboSpan" id="kobo.158.2">A common issue is the Base64 formatting of </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">a Secret.</span></span></p>
<h3><span class="koboSpan" id="kobo.160.1">Base64</span></h3>
<p><span class="koboSpan" id="kobo.161.1">The Base64 format</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.162.1"> is used for representing Secret values. </span><span class="koboSpan" id="kobo.162.2">By default, when applying a Secret, if the value is in plain text, it will be encoded and stored in the Base64 format. </span><span class="koboSpan" id="kobo.162.3">Also, instead of supplying the value in plain text, we can submit a value already encoded in the Base64 format. </span><span class="koboSpan" id="kobo.162.4">This might cause an issue if the value that we want to submit is by its </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">nature Base64-encoded.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">Take, for example, an </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">AES-256 key:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.166.1">
$ secretKey=$(openssl rand -hex 32)
$ echo "$secretKey"
80a3284da641ac728b5585fd913b0e60e9c4f61ffe2cfb6f456c16a312552e11
$ echo "$secretKey" |md5sum
6a59e95805ea05ff21a708038be9b130
echo "$secretKey"</span></pre> <p><span class="koboSpan" id="kobo.167.1">The AES key printed is already encoded using Base64. </span><span class="koboSpan" id="kobo.167.2">Through Base64 encoding, binary data is represented in a format of printable ASCII characters. </span><span class="koboSpan" id="kobo.167.3">This makes it easier to pass in our codebase, for example, through environment variables. </span><span class="koboSpan" id="kobo.167.4">Also, we printed the MD5 hash of the Secret, and we will use the hash for troubleshooting </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">purposes later.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">Let us try now to create a Secret using the AES-256 key we created previously using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">openssl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.171.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.172.1">
$ kubectl create secret generic aes-key --from-literal=key=$secretKey -o yaml
apiVersion: v1
data:
  key: ODBhMzI4NGRhNjQxYWM3MjhiNTU4NWZkOTEzYjBlNjBlOWM0ZjYxZmZlMmNmY jZmNDU2YzE2YTMxMjU1MmUxMQ==
kind: Secret
metadata:
..
</span><span class="koboSpan" id="kobo.172.2">type: Opaque</span></pre> <p><span class="koboSpan" id="kobo.173.1">As we can see, the Secret has been encoded. </span><span class="koboSpan" id="kobo.173.2">If we try to mount the Secret in a Pod, it will contain the </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">right value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.175.1">
apiVersion: v1
kind: Pod
...
</span><span class="koboSpan" id="kobo.175.2">      command: ["/bin/sh","-c"]
      args: ["echo $(key) | md5sum"]
      envFrom:
        - secretRef:
            name:  aes-key</span></pre> <p><span class="koboSpan" id="kobo.176.1">We applied it, so let’s check </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">the logs:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.178.1">
$ kubectl logs print-env-pod
6a59e95805ea05ff21a708038be9b130  -</span></pre> <p><span class="koboSpan" id="kobo.179.1">The checksums match. </span><span class="koboSpan" id="kobo.179.2">As you see, we preferred to use an MD5 hash over just printing the variable. </span><span class="koboSpan" id="kobo.179.3">Printing </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.180.1">variables in a live environment might lead to a </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">data leak.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">We will try the same through a YAML file, but we shall not encode </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">the key:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.184.1">
apiVersion: v1
kind: Secret
metadata:
  name: aes-key
type: Opaque
data:
  key: 80a3284da641ac728b5585fd913b0e60e9c4f61ffe2cfb6f456c16a312552e11</span></pre> <p><span class="koboSpan" id="kobo.185.1">Once we try to use the key through an environment variable on a Pod, we face </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">an issue:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.187.1">
$ kubectl apply -f base_64_example.yaml
$ kubectl logs -f print-env-pod
fc7d115eb58e428c53b346659e7604d6</span></pre> <p><span class="koboSpan" id="kobo.188.1">The MD5 hash is different. </span><span class="koboSpan" id="kobo.188.2">This is because the key was passed to the Pod in binary format. </span><span class="koboSpan" id="kobo.188.3">Kubernetes identified that the</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.189.1"> Secret is in the Base64 format; therefore, by creating the Pod, it decoded the AES key and placed the binary as an environment variable. </span><span class="koboSpan" id="kobo.189.2">This can create confusion and hours </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">of debugging.</span></span></p>
<h3><span class="koboSpan" id="kobo.191.1">Specific Secret types</span></h3>
<p><span class="koboSpan" id="kobo.192.1">Kubernetes provides us with </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.193.1">specific Secret types. </span><span class="koboSpan" id="kobo.193.2">This might give us the impression that before applying a Secret, certain checks take place concerning the format of the Secrets. </span><span class="koboSpan" id="kobo.193.3">This behavior might vary based on the type </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">of Secret.</span></span></p>
<h4><span class="koboSpan" id="kobo.195.1">TLS Secret</span></h4>
<p><span class="koboSpan" id="kobo.196.1">When we</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.197.1"> apply </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.198.1">TLS Secrets, Kubernetes will not perform any checks with regard to the content of the Secrets. </span><span class="koboSpan" id="kobo.198.2">For example, we will try to create a TLS Secret using </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">invalid certificates:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.200.1">
apiVersion: v1
kind: Secret
metadata:
  name: ingress-tls
type: kubernetes.io/tls
data:
  tls.crt: aW52YWxpZC1zZWNyZXQ=
  tls.key: aW52YWxpZC1zZWNyZXQ=</span></pre> <p><span class="koboSpan" id="kobo.201.1">We might think that there would be a check when applying the Secret; however, this will not happen. </span><span class="koboSpan" id="kobo.201.2">The Secret will be created and eventually, it will cause issues once a resource tries to mount and </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">use it.</span></span></p>
<h4><span class="koboSpan" id="kobo.203.1">Basic auth Secrets</span></h4>
<p><span class="koboSpan" id="kobo.204.1">Basic auth </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.205.1">Secrets </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.206.1">fall in the same category as TLS Secrets. </span><span class="koboSpan" id="kobo.206.2">There are no validation checks when basic auth Secrets are </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">being applied:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.208.1">
apiVersion: v1
kind: Secret
metadata:
  name: basic-auth-secret
type: kubernetes.io/basic-auth
stringData:
  no-username: a-user
  password: a-password
  another-key: some-value</span></pre> <p><span class="koboSpan" id="kobo.209.1">The Secret is applied, although it is obviously wrong. </span><span class="koboSpan" id="kobo.209.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">basic-auth</span></strong><span class="koboSpan" id="kobo.211.1"> Secret should have a username and a password; however, we added variables of </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">different names.</span></span></p>
<h4><span class="koboSpan" id="kobo.213.1">docker config Secret</span></h4>
<p><span class="koboSpan" id="kobo.214.1">In the case of </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.215.1">docker config Secrets, Kubernetes will </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.216.1">perform validation and issue an error in the case of an invalid Kubernetes configuration. </span><span class="koboSpan" id="kobo.216.2">We will try to apply a Secret containing an invalid </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">Docker configuration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.218.1">
apiVersion: v1
kind: Secret
metadata:
  name: docker-credentials
type: kubernetes.io/dockercfg
data:
  .dockercfg: |
     UkVQTEFDRV9XSVRIX0JBU0U2NA==</span></pre> <p><span class="koboSpan" id="kobo.219.1">When we run the following command, the file will not be applied. </span><span class="koboSpan" id="kobo.219.2">The docker config we provided is the </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">wrong one:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.221.1">
kubectl apply -f docker-credentials.yaml
The Secret "docker-credentials" is invalid: data[.dockercfg]: Invalid value: "&lt;secret contents redacted&gt;": invalid character 'R' looking for beginning of value</span></pre> <p><span class="koboSpan" id="kobo.222.1">The </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.223.1">errors we get when applying a Secret can vary. </span><span class="koboSpan" id="kobo.223.2">Sometimes, we </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.224.1">might even create an erroneous Secret without receiving </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">any feedback.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">So far, we have identified issues we could face during the application of the Secrets and how we could use dry runs to our advantage. </span><span class="koboSpan" id="kobo.226.2">We have also identified cases where the Secret application is correct but the content of the actual Secret is incorrect. </span><span class="koboSpan" id="kobo.226.3">Last, but not least, we have had an overview of the types of Secrets that Kubernetes may or may not apply any validations to. </span><span class="koboSpan" id="kobo.226.4">This brings us to the next section on </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">troubleshooting Secrets.</span></span></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.228.1">Debugging and troubleshooting Secrets</span></h1>
<p><span class="koboSpan" id="kobo.229.1">Debugging</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.230.1"> Kubernetes Secrets is hard. </span><span class="koboSpan" id="kobo.230.2">This is largely because issues with Secrets materialize mainly when another component dependent on them is failing. </span><span class="koboSpan" id="kobo.230.3">For example, imagine an ingress</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.231.1"> deployment with bad certificates. </span><span class="koboSpan" id="kobo.231.2">Identifying the actual issue will be a process of inspecting multiple components until you find the root cause. </span><span class="koboSpan" id="kobo.231.3">In this section, we will learn tools and approaches for troubleshooting common Secret issues such as non-existent Secrets, badly configured Secrets, </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">and more.</span></span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.233.1">The describe command</span></h2>
<p><span class="koboSpan" id="kobo.234.1">So far, </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">kubectl get</span></strong><span class="koboSpan" id="kobo.236.1"> has been our main</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.237.1"> command to retrieve information about Kubernetes resources. </span><span class="koboSpan" id="kobo.237.2">As a command, it can provide a quick way to retrieve information on the resources of interest and their status. </span><span class="koboSpan" id="kobo.237.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">kubectl get</span></strong><span class="koboSpan" id="kobo.239.1"> function can serve us only to a certain level, however. </span><span class="koboSpan" id="kobo.239.2">Once more information is needed, we should utilize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">kubectl describe</span></strong><span class="koboSpan" id="kobo.241.1"> command. </span><span class="koboSpan" id="kobo.241.2">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">kubectl describe</span></strong><span class="koboSpan" id="kobo.243.1"> command, we can retrieve detailed information for </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">Kubernetes resources.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">Supposing we have an </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.246.1">Nginx deployment Pod in our Kubernetes cluster, we will describe the deployment </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.248.1">
$ kubectl describe deployment.apps/nginx-deployment
Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Wed, 28 Jun 2023 23:53:22 +0100
...
</span><span class="koboSpan" id="kobo.248.2">Pod Template:
  Labels:  app=nginx
  Annotations:      test-annotation: nginx
  Containers:
   nginx:
...
</span><span class="koboSpan" id="kobo.248.3">    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  &lt;none&gt;
NewReplicaSet:   nginx-deployment-544dc8b7c4 (1/1 replicas created)
Events:          &lt;none&gt;</span></pre> <p><span class="koboSpan" id="kobo.249.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">kubectl describe</span></strong><span class="koboSpan" id="kobo.251.1"> command </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.252.1">provides us with all the information needed for the resource of interest. </span><span class="koboSpan" id="kobo.252.2">As we can see, it can list events, labels, annotations, and even properties that apply only to the </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">resource examined.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.254.1">Non-existing Secrets</span></h2>
<p><span class="koboSpan" id="kobo.255.1">We will utilize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">describe</span></strong><span class="koboSpan" id="kobo.257.1"> command for </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.258.1">a deployment that tries to use a Secret that does not exist. </span><span class="koboSpan" id="kobo.258.2">Our example will try to mount a Secret volume that </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">is non-existent:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.260.1">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
...
</span><span class="koboSpan" id="kobo.260.2">    spec:
      containers:
        - name: nginx
          image: nginx
          volumeMounts:
            - name: users-volume
              mountPath: /users.json
      volumes:
        - name: users-volume
          secret:
            secretName: user-file</span></pre> <p><span class="koboSpan" id="kobo.261.1">Since we specified a deployment, we will not be confronted with an error immediately. </span><span class="koboSpan" id="kobo.261.2">Our deployment will get into a continuous </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">ContainerCreating</span></strong><span class="koboSpan" id="kobo.263.1"> state until the Secret </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">is available.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">In this case, by using</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.266.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">describe</span></strong><span class="koboSpan" id="kobo.268.1"> command, we shall get the information that would assist us in identifying </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">the problem:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.270.1">
kubectl describe pod nginx-5d66b7fbc-7cb7g
...
</span><span class="koboSpan" id="kobo.270.2">  Warning  FailedMount  36s (x9 over 2m44s)  kubelet            MountVolume.SetUp failed for volume "users-volume" : secret "user-file" not found</span></pre> <p><span class="koboSpan" id="kobo.271.1">Thanks to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">describe</span></strong><span class="koboSpan" id="kobo.273.1"> command, we can see that the Secret is </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">not available.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">The feedback from badly mounted volumes is not immediately visible. </span><span class="koboSpan" id="kobo.275.2">This is not the case when Secrets are mapped to </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">environment variables.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">Take, for example, an Nginx Pod acquiring its environment variables through a Secret that does </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">not exist:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.279.1">
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
spec:
  containers:
    - name: nginx
      image: nginx
      envFrom:
        - secretRef:
            name: does-not-exist
  restartPolicy: Always</span></pre> <p><span class="koboSpan" id="kobo.280.1">Let us apply the configuration. </span><span class="koboSpan" id="kobo.280.2">After some seconds, we will see that the Pod is not able </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">to start:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.282.1">
$ kubectl get po
NAME      READY STATUS                       RESTARTS   AGE
nginx-pod 0/1   CreateContainerConfigError   0          3s</span></pre> <p><span class="koboSpan" id="kobo.283.1">We shall use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">describe</span></strong><span class="koboSpan" id="kobo.285.1"> command to </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">dig deeper:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.287.1">
$ kubectl describe pod nginx-pod
Warning  Failed 3s (x8 over 87s) kubelet Error: secret "does-not-exist" not found
Normal   Pulled 3s               kubelet Successfully pulled image "nginx" in 968.341209ms</span></pre> <p><span class="koboSpan" id="kobo.288.1">As expected, the Pod is </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.289.1">not able to start since the Secret is missing. </span><span class="koboSpan" id="kobo.289.2">This is something that we detected because of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">describe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.291.1"> command.</span></span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.292.1">Badly configured Secrets</span></h2>
<p><span class="koboSpan" id="kobo.293.1">Badly configured Secrets are the</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.294.1"> reason you could spend hours on debugging. </span><span class="koboSpan" id="kobo.294.2">They can expand to multiple components in an application being affected and lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">extensive troubleshooting.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">A complex scenario can be an ingress with invalid SSL certificates. </span><span class="koboSpan" id="kobo.296.2">We previously created an SSL certificate Secret containing invalid certificates. </span><span class="koboSpan" id="kobo.296.3">We will create an ingress that will use those SSL certificates and try to identify </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">the issue.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">The Secrets we shall apply are </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.300.1">
apiVersion: v1
kind: Secret
metadata:
  name: ingress-tls
type: kubernetes.io/tls
data:
  tls.crt: aW52YWxpZC1zZWNyZXQ=
  tls.key: aW52YWxpZC1zZWNyZXQ=</span></pre> <p><span class="koboSpan" id="kobo.301.1">The ingress </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.302.1">is </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-ingress
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  tls:
    - hosts:
        - bad-ssl
      secretName: ingress-tls
  rules:
    - host: bad-ssl
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: nginx-service
                port:
                  number: 80</span></pre> <p><span class="koboSpan" id="kobo.305.1">At some point, the ingress will be operational. </span><span class="koboSpan" id="kobo.305.2">We can check this using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">kubectl get </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">ing</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.308.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.309.1">
$ kubectl get ing
NAME            CLASS   HOSTS     ADDRESS        PORTS     AGE
nginx-ingress   nginx   bad-ssl   192.168.49.2   80, 443   2m36s</span></pre> <p><span class="koboSpan" id="kobo.310.1">Eventually, by reaching the ingress through the browser, we will see a certificate that has been generated by Kubernetes. </span><span class="koboSpan" id="kobo.310.2">If we don’t provide a certificate by ourselves or we provide a bad certificate configuration, Kubernetes will generate a certificate on </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">its own.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">The first step would </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.313.1">be to check the </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">Kubernetes events:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.315.1">
$ kubectl get events
...
</span><span class="koboSpan" id="kobo.315.2">11m         Normal    Pulled              pod/webpage                              Container image "nginx:stable" already present on machine</span></pre> <p><span class="koboSpan" id="kobo.316.1">Also, based on our previous work, we can see the events just for </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">the ingress:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.318.1">
$ kubectl describe ing
...
</span><span class="koboSpan" id="kobo.318.2">Events:
  Type    Reason  Age                From                      Message
  ----    ------  ----               ----                      -------
  Normal  Sync    35s (x2 over 37s)  nginx-ingress-controller  Scheduled for sync</span></pre> <p><span class="koboSpan" id="kobo.319.1">Eventually, we will have to identify the problem by checking the </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">controller logs:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.321.1">
kubectl logs -f ingress-nginx-controller-755dfbfc65-vf7v6 -n ingress-nginx
...
</span><span class="koboSpan" id="kobo.321.2">W0701 10:18:30.928989       7 backend_ssl.go:45] Error obtaining X.509 certificate: unexpected error creating SSL Cert: no valid PEM formatted block found
...
</span><span class="koboSpan" id="kobo.321.3">W0701 10:18:35.203316       7 controller.go:1348] Unexpected error validating SSL certificate "default/ingress-tls" for server "bad-ssl": x509: certificate is not valid for any names, but wanted to match bad-ssl</span></pre> <p><span class="koboSpan" id="kobo.322.1">The logs will lead us </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.323.1">to the badly configured certificate. </span><span class="koboSpan" id="kobo.323.2">This is where our focus </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">will be.</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.325.1">Troubleshooting and observability solutions</span></h2>
<p><span class="koboSpan" id="kobo.326.1">Our </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.327.1">troubleshooting has so far involved the usage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">kubectl</span></strong><span class="koboSpan" id="kobo.329.1">, which is not always feasible. </span><span class="koboSpan" id="kobo.329.2">Depending on the organization, there can be various observability solutions integrated with a Kubernetes installation. </span><span class="koboSpan" id="kobo.329.3">For example, Datadog</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.330.1"> is a popular observability solution. </span><span class="koboSpan" id="kobo.330.2">In the case of a cloud-based Kubernetes offering, the observability tools offered by a cloud provider are integrated with the Kubernetes offering. </span><span class="koboSpan" id="kobo.330.3">That means tools such as CloudWatch and Google Cloud Monitoring can help us to identify the incidents without the usage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">kubectl</span></strong><span class="koboSpan" id="kobo.332.1">. </span><span class="koboSpan" id="kobo.332.2">We will see more on this topic in </span><a href="B20970_08.xhtml#_idTextAnchor157"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.333.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.334.1">, </span><em class="italic"><span class="koboSpan" id="kobo.335.1">Exploring Cloud Secret Store on AWS</span></em><span class="koboSpan" id="kobo.336.1">, </span><a href="B20970_09.xhtml#_idTextAnchor176"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.337.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.338.1">, </span><em class="italic"><span class="koboSpan" id="kobo.339.1">Exploring Cloud Secret Store on Azure</span></em><span class="koboSpan" id="kobo.340.1">, and </span><a href="B20970_10.xhtml#_idTextAnchor193"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.341.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.342.1">, </span><em class="italic"><span class="koboSpan" id="kobo.343.1">Exploring Cloud Secret Store </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.344.1">on GCP</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">We saw certain scenarios of badly configured Secrets. </span><span class="koboSpan" id="kobo.346.2">In order to identify the cause, we followed a process and used tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">describe</span></strong><span class="koboSpan" id="kobo.348.1">, and we checked the logs </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">of Kubernetes.</span></span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.350.1">Best practices for debugging and troubleshooting Secrets</span></h1>
<p><span class="koboSpan" id="kobo.351.1">When a Secret is wrong, it can </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.352.1">affect us in ways that are not immediately visible. </span><span class="koboSpan" id="kobo.352.2">A top-down approach can be used where we start by checking the actual application that is affected. </span><span class="koboSpan" id="kobo.352.3">Eventually, we will reach a point where the logs will point to the misconfigured Secret. </span><span class="koboSpan" id="kobo.352.4">Once we reach the Secret, we should identify whether the Secret has been applied correctly or whether it is a </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">wrong Secret.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">We could make a checklist when evaluating </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">the Secret:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.356.1">Ensure the existence of </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">the Secret.</span></span></li>
<li><span class="koboSpan" id="kobo.358.1">Check the value of </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">the Secret.</span></span></li>
<li><span class="koboSpan" id="kobo.360.1">Decode the Secret and see whether it is the </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">desired one.</span></span></li>
<li><span class="koboSpan" id="kobo.362.1">Use </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">MD5 hashing.</span></span></li>
<li><span class="koboSpan" id="kobo.364.1">Avoid downloading </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">Secrets locally.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.366.1">The next thing to check is whether the application of the Secret is wrong. </span><span class="koboSpan" id="kobo.366.2">Imagine a scenario where a Secret is mounted on a Pod of a deployment incorrectly. </span><span class="koboSpan" id="kobo.366.3">There is the option to continuously try to change the deployment and eventually figure out along the way what is wrong. </span><span class="koboSpan" id="kobo.366.4">However, this might not give the best results. </span><span class="koboSpan" id="kobo.366.5">It is very easy to continuously apply trial and error until you figure out what is not working, but this will consume time and also make it difficult to distinguish what </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">is happening.</span></span></p>
<p><span class="koboSpan" id="kobo.368.1">There are many things that can go wrong in an application. </span><span class="koboSpan" id="kobo.368.2">This translates to noise that makes it difficult to identify the problem. </span><span class="koboSpan" id="kobo.368.3">Ruling out that the Secrets are not the problem brings us closer to a resolution. </span><span class="koboSpan" id="kobo.368.4">Secrets are already a </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">complex concept.</span></span></p>
<p><span class="koboSpan" id="kobo.370.1">A way to </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.371.1">rule out that the Secret usage is wrong can be by using a simple Docker container and mounting the Secrets there. </span><span class="koboSpan" id="kobo.371.2">A simpler container is less complex and minimizes what can </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">go wrong:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.373.1">Mount the Secrets as environment variables to </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">a Pod.</span></span></li>
<li><span class="koboSpan" id="kobo.375.1">Mount the Secrets as a file to </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">a Pod.</span></span></li>
<li><span class="koboSpan" id="kobo.377.1">Use the hash algorithm of your choice to make sure they are the </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">expected Secret.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.379.1">By following this approach, the possibility of any Kubernetes issues being caused by the Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">are minimized.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.381.1">Avoiding leaking Secrets</span></h2>
<p><span class="koboSpan" id="kobo.382.1">It is </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.383.1">essential to avoid leaking any Secrets when troubleshooting. </span><span class="koboSpan" id="kobo.383.2">When you have an issue with a Secret, it is very tempting to open a terminal session to a Kubernetes Pod and run troubleshooting commands. </span><span class="koboSpan" id="kobo.383.3">The logs generated in a container are written to the standard output (</span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">stdout</span></strong><span class="koboSpan" id="kobo.385.1">) and standard error (</span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">stderr</span></strong><span class="koboSpan" id="kobo.387.1">) streams. </span><span class="koboSpan" id="kobo.387.2">Kubernetes is integrated with many popular logging solutions such as AWS CloudWatch, Datadog, and Google Cloud Monitoring. </span><span class="koboSpan" id="kobo.387.3">By printing Secrets on a Pod, those Secrets are written to those streams and will end up in one of the integrated logging solutions. </span><span class="koboSpan" id="kobo.387.4">A logging solution can be widely accessible in an organization – more accessible than direct Secret access on a Kubernetes cluster. </span><span class="koboSpan" id="kobo.387.5">The outcome of this action is a data leak, and as soon as this happens, the Secrets have to be revoked causing </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">extra overhead.</span></span></p>
<p><span class="koboSpan" id="kobo.389.1">Another best practice is to avoid downloading the Secrets locally when troubleshooting. </span><span class="koboSpan" id="kobo.389.2">Downloading the Secrets locally could lead to a violation of the information security policies that an organization </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">has established.</span></span></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.391.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.392.1">In this chapter, we went further into the details of debugging Kubernetes Secrets and focused on troubleshooting and debugging common issues faced with Secrets within our Kubernetes clusters. </span><span class="koboSpan" id="kobo.392.2">We learned how essential it is to keep Secrets organized and follow best practices, and how human error can introduce hours of troubleshooting. </span><span class="koboSpan" id="kobo.392.3">We also went through the process of identifying issues with Secrets and tools that we could use to get to the root of the problem. </span><span class="koboSpan" id="kobo.392.4">In the next chapter, we will focus on security and compliance when it comes to </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">Kubernetes Secrets.</span></span></p>
</div>


<div class="Content" id="_idContainer025">
<h1 id="_idParaDest-89" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.1.1">Part 2: Advanced Topics – Kubernetes Secrets in a Production Environment</span></h1>
</div>
<div id="_idContainer026">
<p><span class="koboSpan" id="kobo.2.1">In this part, you will explore more advanced topics related to Kubernetes Secrets, including security and compliance considerations, risk mitigation strategies, and disaster recovery and backup plans. </span><span class="koboSpan" id="kobo.2.2">Toward the end, you will learn more about mitigating security risks and how to establish a disaster recovery plan and backup strategies for </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">Kubernetes Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B20970_05.xhtml#_idTextAnchor092"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Security, Auditing, and Compliance</span></em></li>
<li><a href="B20970_06.xhtml#_idTextAnchor117"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Disaster Recovery and Backups</span></em></li>
<li><a href="B20970_07.xhtml#_idTextAnchor142"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Challenges and Risks in Managing Secrets</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer027">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer028">
</div>
</div>
</body></html>