<html><head></head><body>
<div id="_idContainer024">
<h1 class="chapter-number" id="_idParaDest-75"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-76"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.2.1">Debugging and Troubleshooting Kubernetes Secrets</span></h1>
<p><span class="koboSpan" id="kobo.3.1">So far, we have identified the attack vectors for Kubernetes Secrets. </span><span class="koboSpan" id="kobo.3.2">Two of them are encryption at rest and encryption in transit. </span><span class="koboSpan" id="kobo.3.3">Previously, in </span><a href="B20970_03.xhtml#_idTextAnchor064"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Encrypting Secrets the Kubernetes-Native Way</span></em><span class="koboSpan" id="kobo.7.1">, encryption at rest helped us increase our security at rest and in transit. </span><span class="koboSpan" id="kobo.7.2">In this chapter, we will focus on debugging issues that we might have with Secrets. </span><span class="koboSpan" id="kobo.7.3">Secrets play a critical role in storing and providing sensitive information used by applications and services running in a Kubernetes environment. </span><span class="koboSpan" id="kobo.7.4">They are crucial to our applications, and understanding how to effectively troubleshoot Secret-related issues can save lots of time </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">and effort.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will expand on the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Discussion of common issues with </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Kubernetes Secrets</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Debugging and </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">troubleshooting Secrets</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Best practices for debugging and </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">troubleshooting Secrets</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">By the end of the chapter, we will have acquired the knowledge needed to tackle secret-related challenges effectively. </span><span class="koboSpan" id="kobo.17.2">Also, we should be able to follow certain workarounds and avoid common pitfalls when troubleshooting </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Secret-related issues.</span></span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">To link concepts with practice, we will use a series of tools and platforms commonly used to interact with containers, Kubernetes, and Secrets management. </span><span class="koboSpan" id="kobo.20.2">For this chapter, we need the </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">following tools:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.22.1">Docker</span></strong><span class="koboSpan" id="kobo.23.1"> (</span><a href="https://docker.com"><span class="koboSpan" id="kobo.24.1">https://docker.com</span></a><span class="koboSpan" id="kobo.25.1">) or</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.26.1"> Podman (</span><a href="https://podman.io"><span class="koboSpan" id="kobo.27.1">https://podman.io</span></a><span class="koboSpan" id="kobo.28.1">) as a </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">container </span></span><span class="No-Break"><a id="_idIndexMarker205"/></span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">engine.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.31.1">Golang</span></strong><span class="koboSpan" id="kobo.32.1"> (</span><a href="https://go.dev"><span class="koboSpan" id="kobo.33.1">https://go.dev</span></a><span class="koboSpan" id="kobo.34.1">), or Go, which </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.35.1">is a programming language used within our examples. </span><span class="koboSpan" id="kobo.35.2">Note that Kubernetes and most of its third-party components are written </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">in Go.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.37.1">minikube</span></strong><span class="koboSpan" id="kobo.38.1"> (</span><a href="https://minikube.sigs.k8s.io/docs/"><span class="koboSpan" id="kobo.39.1">https://minikube.sigs.k8s.io/docs/</span></a><span class="koboSpan" id="kobo.40.1">) allows us to run a single-node Kubernetes</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.41.1"> cluster on our personal computers, making it perfect for learning and </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">development purposes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.43.1">Git</span></strong><span class="koboSpan" id="kobo.44.1"> (</span><a href="https://git-scm.com"><span class="koboSpan" id="kobo.45.1">https://git-scm.com</span></a><span class="koboSpan" id="kobo.46.1">) is a version control system that we will be using to recover the</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.47.1"> book examples but also leverage our discovery of Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">management solutions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.49.1">Helm</span></strong><span class="koboSpan" id="kobo.50.1"> (</span><a href="https://helm.sh"><span class="koboSpan" id="kobo.51.1">https://helm.sh</span></a><span class="koboSpan" id="kobo.52.1">) is a package manager for Kubernetes that we will be using to</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.53.1"> simplify the deployment and management of </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">Kubernetes resources.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.55.1">GnuPG</span></strong><span class="koboSpan" id="kobo.56.1"> (</span><a href="https://gnupg.org/download/"><span class="koboSpan" id="kobo.57.1">https://gnupg.org/download/</span></a><span class="koboSpan" id="kobo.58.1">) is a free open source implementation of </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.59.1">OpenPGP. </span><span class="koboSpan" id="kobo.59.2">OpenPGP</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.60.1"> provides cryptographic privacy and authentication for </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">data communication.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.62.1">The following link gives you access to the digital materials used in </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">this book:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.64.1">The GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">repository: </span></span><a href="https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook"><span class="No-Break"><span class="koboSpan" id="kobo.66.1">https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook</span></span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.67.1">Note that reference to Kubernetes distributions such as Azure Kubernetes Engine, Rancher Kubernetes Engine, and Red Hat OpenShift will be made but you donâ€™t need working instances of these to perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">hands-on exercises.</span></span></p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.69.1">Discussion of common issues with Kubernetes Secrets</span></h1>
<p><span class="koboSpan" id="kobo.70.1">Throughout </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.71.1">the previous chapters, we interacted with Kubernetes either through direct commands or by using YAML files. </span><span class="koboSpan" id="kobo.71.2">While applying those YAML specifications and applying the commands, some mistakes are very likely to occur along the way. </span><span class="koboSpan" id="kobo.71.3">An incorrect Secret name or YAML definition can introduce hours of troubleshooting to identify what caused the issue in the first place. </span></p>
<p><span class="koboSpan" id="kobo.72.1">For these reasons, certain principles need to </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">be followed:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.74.1">YAML files are structured and can create a source </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">of truth</span></span></li>
<li><span class="koboSpan" id="kobo.76.1">Reusability of Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">minimizes errors</span></span></li>
<li><span class="koboSpan" id="kobo.78.1">Automation removes human intervention, which is prone </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">to error</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.80.1">Applying a Secret eagerly every time we want to use it through the command line makes it easy to introduce an error in the specification. </span><span class="koboSpan" id="kobo.80.2">By having the Secret defined through a YAML file, it is easy to check the structure through an editor and to ensure that we have the desired outcome. </span><span class="koboSpan" id="kobo.80.3">Also, a YAML file gives the flexibility to apply the same Secret multiple times. </span><span class="koboSpan" id="kobo.80.4">In case of an error, the same file can be fixed </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">and applied.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">The other principal is a Secret's reusability. </span><span class="koboSpan" id="kobo.82.2">The reusability can happen in multiple ways. </span><span class="koboSpan" id="kobo.82.3">The more you apply the creation of the same Secret each time, the more likely you will encounter an error. </span><span class="koboSpan" id="kobo.82.4">A Secret that can reside in a </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.83.1">namespace can be used by </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">various components.</span></span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.85.1">Helm and Helm Secrets</span></h2>
<p><span class="koboSpan" id="kobo.86.1">When it comes to providing encryption and </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.87.1">decryption capabilities for Secrets on Helm charts, we have the option of the Helm Secrets plugin. </span><span class="koboSpan" id="kobo.87.2">With Helm Secrets, we can </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.88.1">encrypt sensitive data and the confidential information that resides on Kubernetes Secrets such as passwords, certificates, keys, and so on. </span><span class="koboSpan" id="kobo.88.2">There are various encryption options available when it comes to Helm Secrets. </span><span class="koboSpan" id="kobo.88.3">There are cloud KMS options such as AWS KMS and GCP KMS. </span><span class="koboSpan" id="kobo.88.4">There is also a non-vendor-based option, which is encryption through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">gpg</span></strong><span class="koboSpan" id="kobo.90.1"> command-line tool, an implementation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">OpenPGP standard.</span></span></p>
<h3><span class="koboSpan" id="kobo.92.1">Creating a PGP key</span></h3>
<p><span class="koboSpan" id="kobo.93.1">One of the options to encrypt a</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.94.1"> file with Helm Secrets is to use a PGP key. </span><span class="koboSpan" id="kobo.94.2">PGP uses public key encryption; a public and private key pair are used. </span><span class="koboSpan" id="kobo.94.3">The public key is used to encrypt the data and the private key to decrypt the data. </span><span class="koboSpan" id="kobo.94.4">The public key can be distributed, whereas the private key should be kept secret. </span><span class="koboSpan" id="kobo.94.5">Information can be encrypted by anyone who has access to the public key; however, the decryption can happen only through the actor holding the </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">encryption key.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">If a PGP key is not available, we can generate one </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.98.1">
$ gpg --generate-key</span></pre> <p><span class="koboSpan" id="kobo.99.1">This command will generate the key with some default options, for example, expiration after one year and a default key size. </span><span class="koboSpan" id="kobo.99.2">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">--full-generate-key</span></strong><span class="koboSpan" id="kobo.101.1"> function, there are more options during </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">key creation.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">A prompt </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.104.1">will ask for a passphrase; ignore this prompt and leave it empty. </span><span class="koboSpan" id="kobo.104.2">If the passphrase is not left empty, it will be required at every step of decryption making operations difficult </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">to automate.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">We can list the keys and retrieve the key we </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">already created:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.108.1">
$ gpg --list-keys
Â Â Â Â Â Â 00FFFE11421E1F1EED1EEE811E11E111D1111111
uidÂ Â Â Â Â Â Â Â Â Â [ultimate] test-key-2 &lt;kubernetes@secrets.com&gt;
subÂ Â Â rsa3072 2023-08-27 [E] [expires: 2025-08-26]</span></pre> <p><span class="koboSpan" id="kobo.109.1">Now that we have a key generated, we can proceed with </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">encrypting Secrets.</span></span></p>
<h3><span class="koboSpan" id="kobo.111.1">Encrypting Secrets</span></h3>
<p><span class="koboSpan" id="kobo.112.1">Supposing we have this file with </span><a id="_idIndexMarker218"/><span class="No-Break"><span class="koboSpan" id="kobo.113.1">Helm values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.114.1">
jwt-key:
Â Â value: secret-key</span></pre> <p><span class="koboSpan" id="kobo.115.1">Provided we already have a GPG key, Helm Secrets will use it in order to encrypt the sensitive values. </span><span class="koboSpan" id="kobo.115.2">We need to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">.sops.yaml</span></strong><span class="koboSpan" id="kobo.117.1"> file specifying the GPG key to </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">be used:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.119.1">
creation_rules:
Â Â Â Â - pgp: &gt;-
Â Â Â Â Â Â Â Â gpg-key</span></pre> <p><span class="koboSpan" id="kobo.120.1">Then we can just encrypt </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">the values:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.122.1">
helm secrets enc values.yaml</span></pre> <p><span class="koboSpan" id="kobo.123.1">Eventually, our file should look </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.125.1">
jwt-key:
Â Â Â Â value:Â Â ENC[AES256_GCM,data:9/0gmkCNm2DbEw==,iv:dbthtzx1t8KUHazh7v48T7ASep0rTbYJBrl/jEw6zWE=,tag:MLVXlruHpkMxYihPvNieVQ==,type:str]
sops:
...
</span><span class="koboSpan" id="kobo.125.2">Â Â Â Â pgp:
Â Â Â Â Â Â Â Â Â Â enc: |
Â Â Â Â Â Â Â Â Â Â Â Â -----BEGIN PGP MESSAGE-----
Â Â Â Â Â Â Â Â Â Â Â Â Â -----END PGP MESSAGE-----
Â Â Â Â version: 3.7.3</span></pre> <p><span class="koboSpan" id="kobo.126.1">Helm and</span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.127.1"> Helm Secrets are two </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.128.1">of the many tools that can help us organize our Secrets in a structured format and keep them secured and encrypted on disk. </span><span class="koboSpan" id="kobo.128.2">Helm and Helm Secrets are examples of </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.129.1">keeping  Secrets in a YAML format and reusing them </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">through templating.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">To summarize, automation and proper Secret organization can not only give us productivity gains but also help a lot in removing the need for human intervention. </span><span class="koboSpan" id="kobo.131.2">Most of the time, when an error is introduced, it is highly likely to be caused by </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">human intervention.</span></span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.133.1">Secret application pitfalls</span></h2>
<p><span class="koboSpan" id="kobo.134.1">During the creation of Kubernetes </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.135.1">Secrets, we might encounter errors, which can occur due to several reasons. </span><span class="koboSpan" id="kobo.135.2">An error may come from an invalid YAML syntax, invalid Secret type, missing data, or bad encoding. </span><span class="koboSpan" id="kobo.135.3">On the bright side, failing to apply a Secret properly gives us immediate feedback. </span><span class="koboSpan" id="kobo.135.4">A dry run can help us to validate our operations before </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">executing them.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.137.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.138.1">Take note that all the Kubernetes commands executed take effect on the default namespace unless specified otherwise or configured through the Kubernetes context. </span><span class="koboSpan" id="kobo.138.2">The following commands will take effect on the default namespace or the namespace that has </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">been configured.</span></span></p>
<h3><span class="koboSpan" id="kobo.140.1">Dry run</span></h3>
<p><span class="koboSpan" id="kobo.141.1">Before applying a</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.142.1"> Kubernetes Secret, we can simulate the creation or update of the Secret by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">--dry-run</span></strong><span class="koboSpan" id="kobo.144.1"> option. </span><span class="koboSpan" id="kobo.144.2">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">--dry-run</span></strong><span class="koboSpan" id="kobo.146.1"> along with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">kubectl</span></strong><span class="koboSpan" id="kobo.148.1"> commands, we do not actually perform any operation. </span><span class="koboSpan" id="kobo.148.2">It is a helpful feature for testing and validating our Secret configurations before applying them, thus saving time </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">from troubleshooting.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">For example, we want to create a Secret </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">from literals:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.152.1">
$ kubectl create secret generic opaque-example-from-literals --from-literal=literal1=text-for-literal-1 --dry-run=client
secret/opaque-example-from-literals created (dry run)</span></pre> <p><span class="koboSpan" id="kobo.153.1">This output can confirm that our action will be successful. </span><span class="koboSpan" id="kobo.153.2">We can go one step further and produce a response </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">in YAML:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.155.1">
$ kubectl create secret generic opaque-example-from-literals --from-literal=literal1=text-for-literal-1 --dry-run=client -o yaml
secret/opaque-example-from-literals created (dry run)
apiVersion: v1
data:
Â Â literal1: dGV4dC1mb3ItbGl0ZXJhbC0x
kind: Secret
metadata:
Â Â creationTimestamp: null
Â Â name: opaque-example-from-literals</span></pre> <p><span class="koboSpan" id="kobo.156.1">The dry run can help us validate the operation without applying it, and we can validate the outcome of the operations without the operation taking any effect. </span><span class="koboSpan" id="kobo.156.2">Though the </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">--dry-run</span></strong><span class="koboSpan" id="kobo.158.1"> option is extremely useful, it cannot be of help with Secrets that are successfully applied containing invalid data content. </span><span class="koboSpan" id="kobo.158.2">A common issue is the Base64 formatting of </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">a Secret.</span></span></p>
<h3><span class="koboSpan" id="kobo.160.1">Base64</span></h3>
<p><span class="koboSpan" id="kobo.161.1">The Base64 format</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.162.1"> is used for representing Secret values. </span><span class="koboSpan" id="kobo.162.2">By default, when applying a Secret, if the value is in plain text, it will be encoded and stored in the Base64 format. </span><span class="koboSpan" id="kobo.162.3">Also, instead of supplying the value in plain text, we can submit a value already encoded in the Base64 format. </span><span class="koboSpan" id="kobo.162.4">This might cause an issue if the value that we want to submit is by its </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">nature Base64-encoded.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">Take, for example, an </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">AES-256 key:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.166.1">
$ secretKey=$(openssl rand -hex 32)
$ echo "$secretKey"
80a3284da641ac728b5585fd913b0e60e9c4f61ffe2cfb6f456c16a312552e11
$ echo "$secretKey" |md5sum
6a59e95805ea05ff21a708038be9b130
echo "$secretKey"</span></pre> <p><span class="koboSpan" id="kobo.167.1">The AES key printed is already encoded using Base64. </span><span class="koboSpan" id="kobo.167.2">Through Base64 encoding, binary data is represented in a format of printable ASCII characters. </span><span class="koboSpan" id="kobo.167.3">This makes it easier to pass in our codebase, for example, through environment variables. </span><span class="koboSpan" id="kobo.167.4">Also, we printed the MD5 hash of the Secret, and we will use the hash for troubleshooting </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">purposes later.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">Let us try now to create a Secret using the AES-256 key we created previously using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">openssl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.171.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.172.1">
$ kubectl create secret generic aes-key --from-literal=key=$secretKey -o yaml
apiVersion: v1
data:
Â Â key: ODBhMzI4NGRhNjQxYWM3MjhiNTU4NWZkOTEzYjBlNjBlOWM0ZjYxZmZlMmNmY jZmNDU2YzE2YTMxMjU1MmUxMQ==
kind: Secret
metadata:
..
</span><span class="koboSpan" id="kobo.172.2">type: Opaque</span></pre> <p><span class="koboSpan" id="kobo.173.1">As we can see, the Secret has been encoded. </span><span class="koboSpan" id="kobo.173.2">If we try to mount the Secret in a Pod, it will contain the </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">right value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.175.1">
apiVersion: v1
kind: Pod
...
</span><span class="koboSpan" id="kobo.175.2">Â Â Â Â Â Â command: ["/bin/sh","-c"]
Â Â Â Â Â Â args: ["echo $(key) | md5sum"]
Â Â Â Â Â Â envFrom:
Â Â Â Â Â Â Â Â - secretRef:
Â Â Â Â Â Â Â Â Â Â Â Â name:Â Â aes-key</span></pre> <p><span class="koboSpan" id="kobo.176.1">We applied it, so letâ€™s check </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">the logs:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.178.1">
$ kubectl logs print-env-pod
6a59e95805ea05ff21a708038be9b130Â Â -</span></pre> <p><span class="koboSpan" id="kobo.179.1">The checksums match. </span><span class="koboSpan" id="kobo.179.2">As you see, we preferred to use an MD5 hash over just printing the variable. </span><span class="koboSpan" id="kobo.179.3">Printing </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.180.1">variables in a live environment might lead to a </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">data leak.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">We will try the same through a YAML file, but we shall not encode </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">the key:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.184.1">
apiVersion: v1
kind: Secret
metadata:
Â Â name: aes-key
type: Opaque
data:
Â Â key: 80a3284da641ac728b5585fd913b0e60e9c4f61ffe2cfb6f456c16a312552e11</span></pre> <p><span class="koboSpan" id="kobo.185.1">Once we try to use the key through an environment variable on a Pod, we face </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">an issue:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.187.1">
$ kubectl apply -f base_64_example.yaml
$ kubectl logs -f print-env-pod
fc7d115eb58e428c53b346659e7604d6</span></pre> <p><span class="koboSpan" id="kobo.188.1">The MD5 hash is different. </span><span class="koboSpan" id="kobo.188.2">This is because the key was passed to the Pod in binary format. </span><span class="koboSpan" id="kobo.188.3">Kubernetes identified that the</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.189.1"> Secret is in the Base64 format; therefore, by creating the Pod, it decoded the AES key and placed the binary as an environment variable. </span><span class="koboSpan" id="kobo.189.2">This can create confusion and hours </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">of debugging.</span></span></p>
<h3><span class="koboSpan" id="kobo.191.1">Specific Secret types</span></h3>
<p><span class="koboSpan" id="kobo.192.1">Kubernetes provides us with </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.193.1">specific Secret types. </span><span class="koboSpan" id="kobo.193.2">This might give us the impression that before applying a Secret, certain checks take place concerning the format of the Secrets. </span><span class="koboSpan" id="kobo.193.3">This behavior might vary based on the type </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">of Secret.</span></span></p>
<h4><span class="koboSpan" id="kobo.195.1">TLS Secret</span></h4>
<p><span class="koboSpan" id="kobo.196.1">When we</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.197.1"> apply </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.198.1">TLS Secrets, Kubernetes will not perform any checks with regard to the content of the Secrets. </span><span class="koboSpan" id="kobo.198.2">For example, we will try to create a TLS Secret using </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">invalid certificates:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.200.1">
apiVersion: v1
kind: Secret
metadata:
Â Â name: ingress-tls
type: kubernetes.io/tls
data:
Â Â tls.crt: aW52YWxpZC1zZWNyZXQ=
Â Â tls.key: aW52YWxpZC1zZWNyZXQ=</span></pre> <p><span class="koboSpan" id="kobo.201.1">We might think that there would be a check when applying the Secret; however, this will not happen. </span><span class="koboSpan" id="kobo.201.2">The Secret will be created and eventually, it will cause issues once a resource tries to mount and </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">use it.</span></span></p>
<h4><span class="koboSpan" id="kobo.203.1">Basic auth Secrets</span></h4>
<p><span class="koboSpan" id="kobo.204.1">Basic auth </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.205.1">Secrets </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.206.1">fall in the same category as TLS Secrets. </span><span class="koboSpan" id="kobo.206.2">There are no validation checks when basic auth Secrets are </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">being applied:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.208.1">
apiVersion: v1
kind: Secret
metadata:
Â Â name: basic-auth-secret
type: kubernetes.io/basic-auth
stringData:
Â Â no-username: a-user
Â Â password: a-password
Â Â another-key: some-value</span></pre> <p><span class="koboSpan" id="kobo.209.1">The Secret is applied, although it is obviously wrong. </span><span class="koboSpan" id="kobo.209.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">basic-auth</span></strong><span class="koboSpan" id="kobo.211.1"> Secret should have a username and a password; however, we added variables of </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">different names.</span></span></p>
<h4><span class="koboSpan" id="kobo.213.1">docker config Secret</span></h4>
<p><span class="koboSpan" id="kobo.214.1">In the case of </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.215.1">docker config Secrets, Kubernetes will </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.216.1">perform validation and issue an error in the case of an invalid Kubernetes configuration. </span><span class="koboSpan" id="kobo.216.2">We will try to apply a Secret containing an invalid </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">Docker configuration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.218.1">
apiVersion: v1
kind: Secret
metadata:
Â Â name: docker-credentials
type: kubernetes.io/dockercfg
data:
Â Â .dockercfg: |
Â Â Â Â Â UkVQTEFDRV9XSVRIX0JBU0U2NA==</span></pre> <p><span class="koboSpan" id="kobo.219.1">When we run the following command, the file will not be applied. </span><span class="koboSpan" id="kobo.219.2">The docker config we provided is the </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">wrong one:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.221.1">
kubectl apply -f docker-credentials.yaml
The Secret "docker-credentials" is invalid: data[.dockercfg]: Invalid value: "&lt;secret contents redacted&gt;": invalid character 'R' looking for beginning of value</span></pre> <p><span class="koboSpan" id="kobo.222.1">The </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.223.1">errors we get when applying a Secret can vary. </span><span class="koboSpan" id="kobo.223.2">Sometimes, we </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.224.1">might even create an erroneous Secret without receiving </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">any feedback.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">So far, we have identified issues we could face during the application of the Secrets and how we could use dry runs to our advantage. </span><span class="koboSpan" id="kobo.226.2">We have also identified cases where the Secret application is correct but the content of the actual Secret is incorrect. </span><span class="koboSpan" id="kobo.226.3">Last, but not least, we have had an overview of the types of Secrets that Kubernetes may or may not apply any validations to. </span><span class="koboSpan" id="kobo.226.4">This brings us to the next section on </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">troubleshooting Secrets.</span></span></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.228.1">Debugging and troubleshooting Secrets</span></h1>
<p><span class="koboSpan" id="kobo.229.1">Debugging</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.230.1"> Kubernetes Secrets is hard. </span><span class="koboSpan" id="kobo.230.2">This is largely because issues with Secrets materialize mainly when another component dependent on them is failing. </span><span class="koboSpan" id="kobo.230.3">For example, imagine an ingress</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.231.1"> deployment with bad certificates. </span><span class="koboSpan" id="kobo.231.2">Identifying the actual issue will be a process of inspecting multiple components until you find the root cause. </span><span class="koboSpan" id="kobo.231.3">In this section, we will learn tools and approaches for troubleshooting common Secret issues such as non-existent Secrets, badly configured Secrets, </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">and more.</span></span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.233.1">The describe command</span></h2>
<p><span class="koboSpan" id="kobo.234.1">So far, </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">kubectl get</span></strong><span class="koboSpan" id="kobo.236.1"> has been our main</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.237.1"> command to retrieve information about Kubernetes resources. </span><span class="koboSpan" id="kobo.237.2">As a command, it can provide a quick way to retrieve information on the resources of interest and their status. </span><span class="koboSpan" id="kobo.237.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">kubectl get</span></strong><span class="koboSpan" id="kobo.239.1"> function can serve us only to a certain level, however. </span><span class="koboSpan" id="kobo.239.2">Once more information is needed, we should utilize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">kubectl describe</span></strong><span class="koboSpan" id="kobo.241.1"> command. </span><span class="koboSpan" id="kobo.241.2">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">kubectl describe</span></strong><span class="koboSpan" id="kobo.243.1"> command, we can retrieve detailed information for </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">Kubernetes resources.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">Supposing we have an </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.246.1">Nginx deployment Pod in our Kubernetes cluster, we will describe the deployment </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.248.1">
$ kubectl describe deployment.apps/nginx-deployment
Name:Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â nginx-deployment
Namespace:Â Â Â Â Â Â Â Â Â Â Â Â Â Â default
CreationTimestamp:Â Â Â Â Â Â Wed, 28 Jun 2023 23:53:22 +0100
...
</span><span class="koboSpan" id="kobo.248.2">Pod Template:
Â Â Labels:Â Â app=nginx
Â Â Annotations:Â Â Â Â Â Â test-annotation: nginx
Â Â Containers:
Â Â Â nginx:
...
</span><span class="koboSpan" id="kobo.248.3">Â Â Â Â Mounts:Â Â Â Â Â Â Â &lt;none&gt;
Â Â Volumes:Â Â Â Â Â Â Â Â &lt;none&gt;
Conditions:
Â Â TypeÂ Â Â Â Â Â Â Â Â Â Â StatusÂ Â Reason
Â Â ----Â Â Â Â Â Â Â Â Â Â Â ------Â Â ------
Â Â AvailableÂ Â Â Â Â Â TrueÂ Â Â Â MinimumReplicasAvailable
Â Â ProgressingÂ Â Â Â TrueÂ Â Â Â NewReplicaSetAvailable
OldReplicaSets:Â Â &lt;none&gt;
NewReplicaSet:Â Â Â nginx-deployment-544dc8b7c4 (1/1 replicas created)
Events:Â Â Â Â Â Â Â Â Â Â &lt;none&gt;</span></pre> <p><span class="koboSpan" id="kobo.249.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">kubectl describe</span></strong><span class="koboSpan" id="kobo.251.1"> command </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.252.1">provides us with all the information needed for the resource of interest. </span><span class="koboSpan" id="kobo.252.2">As we can see, it can list events, labels, annotations, and even properties that apply only to the </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">resource examined.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.254.1">Non-existing Secrets</span></h2>
<p><span class="koboSpan" id="kobo.255.1">We will utilize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">describe</span></strong><span class="koboSpan" id="kobo.257.1"> command for </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.258.1">a deployment that tries to use a Secret that does not exist. </span><span class="koboSpan" id="kobo.258.2">Our example will try to mount a Secret volume that </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">is non-existent:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.260.1">
apiVersion: apps/v1
kind: Deployment
metadata:
Â Â name: nginx
spec:
...
</span><span class="koboSpan" id="kobo.260.2">Â Â Â Â spec:
Â Â Â Â Â Â containers:
Â Â Â Â Â Â Â Â - name: nginx
Â Â Â Â Â Â Â Â Â Â image: nginx
Â Â Â Â Â Â Â Â Â Â volumeMounts:
Â Â Â Â Â Â Â Â Â Â Â Â - name: users-volume
Â Â Â Â Â Â Â Â Â Â Â Â Â Â mountPath: /users.json
Â Â Â Â Â Â volumes:
Â Â Â Â Â Â Â Â - name: users-volume
Â Â Â Â Â Â Â Â Â Â secret:
Â Â Â Â Â Â Â Â Â Â Â Â secretName: user-file</span></pre> <p><span class="koboSpan" id="kobo.261.1">Since we specified a deployment, we will not be confronted with an error immediately. </span><span class="koboSpan" id="kobo.261.2">Our deployment will get into a continuous </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">ContainerCreating</span></strong><span class="koboSpan" id="kobo.263.1"> state until the Secret </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">is available.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">In this case, by using</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.266.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">describe</span></strong><span class="koboSpan" id="kobo.268.1"> command, we shall get the information that would assist us in identifying </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">the problem:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.270.1">
kubectl describe pod nginx-5d66b7fbc-7cb7g
...
</span><span class="koboSpan" id="kobo.270.2">Â Â WarningÂ Â FailedMountÂ Â 36s (x9 over 2m44s)Â Â kubeletÂ Â Â Â Â Â Â Â Â Â Â Â MountVolume.SetUp failed for volume "users-volume" : secret "user-file" not found</span></pre> <p><span class="koboSpan" id="kobo.271.1">Thanks to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">describe</span></strong><span class="koboSpan" id="kobo.273.1"> command, we can see that the Secret is </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">not available.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">The feedback from badly mounted volumes is not immediately visible. </span><span class="koboSpan" id="kobo.275.2">This is not the case when Secrets are mapped to </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">environment variables.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">Take, for example, an Nginx Pod acquiring its environment variables through a Secret that does </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">not exist:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.279.1">
apiVersion: v1
kind: Pod
metadata:
Â Â name: nginx-pod
spec:
Â Â containers:
Â Â Â Â - name: nginx
Â Â Â Â Â Â image: nginx
Â Â Â Â Â Â envFrom:
Â Â Â Â Â Â Â Â - secretRef:
Â Â Â Â Â Â Â Â Â Â Â Â name: does-not-exist
Â Â restartPolicy: Always</span></pre> <p><span class="koboSpan" id="kobo.280.1">Let us apply the configuration. </span><span class="koboSpan" id="kobo.280.2">After some seconds, we will see that the Pod is not able </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">to start:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.282.1">
$ kubectl get po
NAMEÂ Â Â Â Â Â READY STATUSÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â RESTARTSÂ Â Â AGE
nginx-pod 0/1Â Â Â CreateContainerConfigErrorÂ Â Â 0Â Â Â Â Â Â Â Â Â Â 3s</span></pre> <p><span class="koboSpan" id="kobo.283.1">We shall use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">describe</span></strong><span class="koboSpan" id="kobo.285.1"> command to </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">dig deeper:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.287.1">
$ kubectl describe pod nginx-pod
WarningÂ Â Failed 3s (x8 over 87s) kubelet Error: secret "does-not-exist" not found
NormalÂ Â Â Pulled 3sÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â kubelet Successfully pulled image "nginx" in 968.341209ms</span></pre> <p><span class="koboSpan" id="kobo.288.1">As expected, the Pod is </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.289.1">not able to start since the Secret is missing. </span><span class="koboSpan" id="kobo.289.2">This is something that we detected because of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">describe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.291.1"> command.</span></span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.292.1">Badly configured Secrets</span></h2>
<p><span class="koboSpan" id="kobo.293.1">Badly configured Secrets are the</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.294.1"> reason you could spend hours on debugging. </span><span class="koboSpan" id="kobo.294.2">They can expand to multiple components in an application being affected and lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">extensive troubleshooting.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">A complex scenario can be an ingress with invalid SSL certificates. </span><span class="koboSpan" id="kobo.296.2">We previously created an SSL certificate Secret containing invalid certificates. </span><span class="koboSpan" id="kobo.296.3">We will create an ingress that will use those SSL certificates and try to identify </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">the issue.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">The Secrets we shall apply are </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.300.1">
apiVersion: v1
kind: Secret
metadata:
Â Â name: ingress-tls
type: kubernetes.io/tls
data:
Â Â tls.crt: aW52YWxpZC1zZWNyZXQ=
Â Â tls.key: aW52YWxpZC1zZWNyZXQ=</span></pre> <p><span class="koboSpan" id="kobo.301.1">The ingress </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.302.1">is </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
Â Â name: nginx-ingress
Â Â annotations:
Â Â Â Â nginx.ingress.kubernetes.io/ssl-redirect: "true"
Â Â Â Â nginx.ingress.kubernetes.io/rewrite-target: /
spec:
Â Â tls:
Â Â Â Â - hosts:
Â Â Â Â Â Â Â Â - bad-ssl
Â Â Â Â Â Â secretName: ingress-tls
Â Â rules:
Â Â Â Â - host: bad-ssl
Â Â Â Â Â Â http:
Â Â Â Â Â Â Â Â paths:
Â Â Â Â Â Â Â Â Â Â - path: /
Â Â Â Â Â Â Â Â Â Â Â Â pathType: Prefix
Â Â Â Â Â Â Â Â Â Â Â Â backend:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â service:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â name: nginx-service
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â port:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â number: 80</span></pre> <p><span class="koboSpan" id="kobo.305.1">At some point, the ingress will be operational. </span><span class="koboSpan" id="kobo.305.2">We can check this using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">kubectl get </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">ing</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.308.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.309.1">
$ kubectl get ing
NAMEÂ Â Â Â Â Â Â Â Â Â Â Â CLASSÂ Â Â HOSTSÂ Â Â Â Â ADDRESSÂ Â Â Â Â Â Â Â PORTSÂ Â Â Â Â AGE
nginx-ingressÂ Â Â nginxÂ Â Â bad-sslÂ Â Â 192.168.49.2Â Â Â 80, 443Â Â Â 2m36s</span></pre> <p><span class="koboSpan" id="kobo.310.1">Eventually, by reaching the ingress through the browser, we will see a certificate that has been generated by Kubernetes. </span><span class="koboSpan" id="kobo.310.2">If we donâ€™t provide a certificate by ourselves or we provide a bad certificate configuration, Kubernetes will generate a certificate on </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">its own.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">The first step would </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.313.1">be to check the </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">Kubernetes events:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.315.1">
$ kubectl get events
...
</span><span class="koboSpan" id="kobo.315.2">11mÂ Â Â Â Â Â Â Â Â NormalÂ Â Â Â PulledÂ Â Â Â Â Â Â Â Â Â Â Â Â Â pod/webpageÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Container image "nginx:stable" already present on machine</span></pre> <p><span class="koboSpan" id="kobo.316.1">Also, based on our previous work, we can see the events just for </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">the ingress:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.318.1">
$ kubectl describe ing
...
</span><span class="koboSpan" id="kobo.318.2">Events:
Â Â TypeÂ Â Â Â ReasonÂ Â AgeÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â FromÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Message
Â Â ----Â Â Â Â ------Â Â ----Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ----Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â -------
Â Â NormalÂ Â SyncÂ Â Â Â 35s (x2 over 37s)Â Â nginx-ingress-controllerÂ Â Scheduled for sync</span></pre> <p><span class="koboSpan" id="kobo.319.1">Eventually, we will have to identify the problem by checking the </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">controller logs:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.321.1">
kubectl logs -f ingress-nginx-controller-755dfbfc65-vf7v6 -n ingress-nginx
...
</span><span class="koboSpan" id="kobo.321.2">W0701 10:18:30.928989Â Â Â Â Â Â Â 7 backend_ssl.go:45] Error obtaining X.509 certificate: unexpected error creating SSL Cert: no valid PEM formatted block found
...
</span><span class="koboSpan" id="kobo.321.3">W0701 10:18:35.203316Â Â Â Â Â Â Â 7 controller.go:1348] Unexpected error validating SSL certificate "default/ingress-tls" for server "bad-ssl": x509: certificate is not valid for any names, but wanted to match bad-ssl</span></pre> <p><span class="koboSpan" id="kobo.322.1">The logs will lead us </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.323.1">to the badly configured certificate. </span><span class="koboSpan" id="kobo.323.2">This is where our focus </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">will be.</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.325.1">Troubleshooting and observability solutions</span></h2>
<p><span class="koboSpan" id="kobo.326.1">Our </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.327.1">troubleshooting has so far involved the usage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">kubectl</span></strong><span class="koboSpan" id="kobo.329.1">, which is not always feasible. </span><span class="koboSpan" id="kobo.329.2">Depending on the organization, there can be various observability solutions integrated with a Kubernetes installation. </span><span class="koboSpan" id="kobo.329.3">For example, Datadog</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.330.1"> is a popular observability solution. </span><span class="koboSpan" id="kobo.330.2">In the case of a cloud-based Kubernetes offering, the observability tools offered by a cloud provider are integrated with the Kubernetes offering. </span><span class="koboSpan" id="kobo.330.3">That means tools such as CloudWatch and Google Cloud Monitoring can help us to identify the incidents without the usage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">kubectl</span></strong><span class="koboSpan" id="kobo.332.1">. </span><span class="koboSpan" id="kobo.332.2">We will see more on this topic in </span><a href="B20970_08.xhtml#_idTextAnchor157"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.333.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.334.1">, </span><em class="italic"><span class="koboSpan" id="kobo.335.1">Exploring Cloud Secret Store on AWS</span></em><span class="koboSpan" id="kobo.336.1">, </span><a href="B20970_09.xhtml#_idTextAnchor176"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.337.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.338.1">, </span><em class="italic"><span class="koboSpan" id="kobo.339.1">Exploring Cloud Secret Store on Azure</span></em><span class="koboSpan" id="kobo.340.1">, and </span><a href="B20970_10.xhtml#_idTextAnchor193"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.341.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.342.1">, </span><em class="italic"><span class="koboSpan" id="kobo.343.1">Exploring Cloud Secret Store </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.344.1">on GCP</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">We saw certain scenarios of badly configured Secrets. </span><span class="koboSpan" id="kobo.346.2">In order to identify the cause, we followed a process and used tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">describe</span></strong><span class="koboSpan" id="kobo.348.1">, and we checked the logs </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">of Kubernetes.</span></span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.350.1">Best practices for debugging and troubleshooting Secrets</span></h1>
<p><span class="koboSpan" id="kobo.351.1">When a Secret is wrong, it can </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.352.1">affect us in ways that are not immediately visible. </span><span class="koboSpan" id="kobo.352.2">A top-down approach can be used where we start by checking the actual application that is affected. </span><span class="koboSpan" id="kobo.352.3">Eventually, we will reach a point where the logs will point to the misconfigured Secret. </span><span class="koboSpan" id="kobo.352.4">Once we reach the Secret, we should identify whether the Secret has been applied correctly or whether it is a </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">wrong Secret.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">We could make a checklist when evaluating </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">the Secret:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.356.1">Ensure the existence of </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">the Secret.</span></span></li>
<li><span class="koboSpan" id="kobo.358.1">Check the value of </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">the Secret.</span></span></li>
<li><span class="koboSpan" id="kobo.360.1">Decode the Secret and see whether it is the </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">desired one.</span></span></li>
<li><span class="koboSpan" id="kobo.362.1">Use </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">MD5 hashing.</span></span></li>
<li><span class="koboSpan" id="kobo.364.1">Avoid downloading </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">Secrets locally.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.366.1">The next thing to check is whether the application of the Secret is wrong. </span><span class="koboSpan" id="kobo.366.2">Imagine a scenario where a Secret is mounted on a Pod of a deployment incorrectly. </span><span class="koboSpan" id="kobo.366.3">There is the option to continuously try to change the deployment and eventually figure out along the way what is wrong. </span><span class="koboSpan" id="kobo.366.4">However, this might not give the best results. </span><span class="koboSpan" id="kobo.366.5">It is very easy to continuously apply trial and error until you figure out what is not working, but this will consume time and also make it difficult to distinguish what </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">is happening.</span></span></p>
<p><span class="koboSpan" id="kobo.368.1">There are many things that can go wrong in an application. </span><span class="koboSpan" id="kobo.368.2">This translates to noise that makes it difficult to identify the problem. </span><span class="koboSpan" id="kobo.368.3">Ruling out that the Secrets are not the problem brings us closer to a resolution. </span><span class="koboSpan" id="kobo.368.4">Secrets are already a </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">complex concept.</span></span></p>
<p><span class="koboSpan" id="kobo.370.1">A way to </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.371.1">rule out that the Secret usage is wrong can be by using a simple Docker container and mounting the Secrets there. </span><span class="koboSpan" id="kobo.371.2">A simpler container is less complex and minimizes what can </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">go wrong:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.373.1">Mount the Secrets as environment variables to </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">a Pod.</span></span></li>
<li><span class="koboSpan" id="kobo.375.1">Mount the Secrets as a file to </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">a Pod.</span></span></li>
<li><span class="koboSpan" id="kobo.377.1">Use the hash algorithm of your choice to make sure they are the </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">expected Secret.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.379.1">By following this approach, the possibility of any Kubernetes issues being caused by the Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">are minimized.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.381.1">Avoiding leaking Secrets</span></h2>
<p><span class="koboSpan" id="kobo.382.1">It is </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.383.1">essential to avoid leaking any Secrets when troubleshooting. </span><span class="koboSpan" id="kobo.383.2">When you have an issue with a Secret, it is very tempting to open a terminal session to a Kubernetes Pod and run troubleshooting commands. </span><span class="koboSpan" id="kobo.383.3">The logs generated in a container are written to the standard output (</span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">stdout</span></strong><span class="koboSpan" id="kobo.385.1">) and standard error (</span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">stderr</span></strong><span class="koboSpan" id="kobo.387.1">) streams. </span><span class="koboSpan" id="kobo.387.2">Kubernetes is integrated with many popular logging solutions such as AWS CloudWatch, Datadog, and Google Cloud Monitoring. </span><span class="koboSpan" id="kobo.387.3">By printing Secrets on a Pod, those Secrets are written to those streams and will end up in one of the integrated logging solutions. </span><span class="koboSpan" id="kobo.387.4">A logging solution can be widely accessible in an organization â€“ more accessible than direct Secret access on a Kubernetes cluster. </span><span class="koboSpan" id="kobo.387.5">The outcome of this action is a data leak, and as soon as this happens, the Secrets have to be revoked causing </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">extra overhead.</span></span></p>
<p><span class="koboSpan" id="kobo.389.1">Another best practice is to avoid downloading the Secrets locally when troubleshooting. </span><span class="koboSpan" id="kobo.389.2">Downloading the Secrets locally could lead to a violation of the information security policies that an organization </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">has established.</span></span></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.391.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.392.1">In this chapter, we went further into the details of debugging Kubernetes Secrets and focused on troubleshooting and debugging common issues faced with Secrets within our Kubernetes clusters. </span><span class="koboSpan" id="kobo.392.2">We learned how essential it is to keep Secrets organized and follow best practices, and how human error can introduce hours of troubleshooting. </span><span class="koboSpan" id="kobo.392.3">We also went through the process of identifying issues with Secrets and tools that we could use to get to the root of the problem. </span><span class="koboSpan" id="kobo.392.4">In the next chapter, we will focus on security and compliance when it comes to </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">Kubernetes Secrets.</span></span></p>
</div>


<div class="Content" id="_idContainer025">
<h1 id="_idParaDest-89" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.1.1">Part 2: Advanced Topics â€“ Kubernetes Secrets in a Production Environment</span></h1>
</div>
<div id="_idContainer026">
<p><span class="koboSpan" id="kobo.2.1">In this part, you will explore more advanced topics related to Kubernetes Secrets, including security and compliance considerations, risk mitigation strategies, and disaster recovery and backup plans. </span><span class="koboSpan" id="kobo.2.2">Toward the end, you will learn more about mitigating security risks and how to establish a disaster recovery plan and backup strategies for </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">Kubernetes Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B20970_05.xhtml#_idTextAnchor092"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Security, Auditing, and Compliance</span></em></li>
<li><a href="B20970_06.xhtml#_idTextAnchor117"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Disaster Recovery and Backups</span></em></li>
<li><a href="B20970_07.xhtml#_idTextAnchor142"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Challenges and Risks in Managing Secrets</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer027">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer028">
</div>
</div>
</body></html>