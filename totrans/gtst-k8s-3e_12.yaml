- en: Cluster Federation and Multi-Tenancy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will discuss the new federation capabilities and how to use them
    to manage multiple clusters across cloud providers. We will also cover the federated
    version of the core constructs. We will walk you through federated Deployments,
    ReplicaSets, ConfigMaps, and Events.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Federating clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Federating multiple clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting and controlling resources across multiple clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching resources across multiple clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll need to have your Google Cloud Platform account enabled and logged
    in, or you can use a local Minikube instance of Kubernetes. You can also use Play
    with Kubernetes over the web: [https://labs.play-with-k8s.com/](https://labs.play-with-k8s.com/).
    There''s also the Katacoda playground at [https://www.katacoda.com/courses/kubernetes/playground](https://www.katacoda.com/courses/kubernetes/playground).'
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need GitHub credentials, the setting up of which we'll go over later
    in this chapter. Here's the GitHub repository for this chapter: [https://github.com/PacktPublishing/Getting-Started-with-Kubernetes-third-edition/tree/master/Code-files/Chapter12](https://github.com/PacktPublishing/Getting-Started-with-Kubernetes-third-edition/tree/master/Code-files/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to federation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While federation is still very new in Kubernetes, it lays the groundwork for
    a highly sought after cross-cloud provider solution. Using federation, we can
    run multiple Kubernetes clusters on-premises and in one or more public cloud providers
    and manage applications utilizing the entire set of all our organizational resources.
  prefs: []
  type: TYPE_NORMAL
- en: This begins to create a path for avoiding cloud provider lock-in and highly
    available deployment that can place application servers in multiple clusters and
    allow for communication to other services located in single points among our federated
    clusters. We can improve isolation on outages at a particular provider or geographic
    location while providing greater flexibility for scaling and utilizing total infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the federation plane supports these resources: ConfigMap, DaemonSets,
    Deployment, Events, Ingress, Namespaces, ReplicaSets, Secrets, and Services. Note
    that federation and its components are in alpha and beta phases of release, so
    functionality may still be a bit temperamental.'
  prefs: []
  type: TYPE_NORMAL
- en: Why federation?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several major advantages to taking on Kubernetes cluster federation.
    As mentioned previously, federation allows you increase the availability and tenancy
    capabilities of your Kubernetes clusters. By scaling across availability zones
    or regions of a single **cloud service provider** (**CSP**), or by scaling across
    multiple CSPs, federation takes the concept of high availability to the next level.
    Some term this global scheduling, which will could enable you to direct traffic
    in order to maximize an inexpensive CSP resource that becomes available in the
    spot market. You could also use global scheduling to relocate workloads cluster
    to end use populations, improving the performance of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the opportunity to treat entire clusters as if they were Kubernetes
    objects, and deal with failure on a per-cluster basis instead of per machine.
    Cluster federation could allow operators to automatically recover from entire
    clusters failing by routing traffic to redundant, available clusters.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that, while federation increases the potential for high availability
    on your cluster, it's clear that the significant increase in complexity also lowers
    your potential reliability if your clusters aren't managed well. You can manage
    some of this complexity by using a hosted PaaS version of Kubernetes such as GKE,
    where leaving the cluster management to GCP will drastically lower the operational
    load on your teams.
  prefs: []
  type: TYPE_NORMAL
- en: Federation can also enable your team to support a hybrid environment, with on-premises
    clusters pairing with your resources in the cloud. Depending on your traffic routing
    requirements, this may require additional engineering in the form of a service
    mesh.
  prefs: []
  type: TYPE_NORMAL
- en: There's a number of technical features that federation supplies, which enable
    higher potential availability.
  prefs: []
  type: TYPE_NORMAL
- en: The building blocks of federation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Federation makes it easy to manage resources across clusters by providing two
    distinct types of building blocks. The first is resources and the second is service
    discovery:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource synchronization across clusters**: Federation is the glue that allows
    you to keep track of the many resources needed to run sets of applications. When
    you''re running a lot of applications, with many resources and object types, across
    many clusters, federation is key to keeping your clusters organized and managed
    well. You may find yourself needing to keep an application deployment running
    in multiple clusters with a single pane of glass view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-cluster service discovery**: There are a number of resources that share
    well between clusters such as DNS, load balancers, object storage, and ingress.
    Federation gives you the ability to automatically configure those services with
    multi-cluster awareness, so you can route application traffic and manage the control
    plane across several clusters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we''ll learn next, Kubernetes federation is managed by a tool named `kubefed`,
    which has a number of command-line flags that allow you to manage many clusters
    and the building blocks we discussed previously. The major building blocks of
    `kubefed` that we''ll use are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubefed init`: Initialize a federation control plane'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubefed join`: Join a cluster to a federation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubefed options`: Print the list of flags inherited by all commands'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubefed unjoin`: Unjoin a cluster from a federation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubefed version`: Print the client and server version information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a handy list of the options that can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a high-level diagram that shows what all of these pieces look like
    when strung together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43b385da-a4e9-4371-8d7c-b73bb50833a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Key components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two key components to the federation capability within Kubernetes.
    These components make up the federation control plane.
  prefs: []
  type: TYPE_NORMAL
- en: The first is `federation-controller-manager`, which embeds the core control
    loops required to operate federation. `federation-controller-manager` watches
    the state of your clusters via `apiserver` and makes changes in order to reach
    a desired state.
  prefs: []
  type: TYPE_NORMAL
- en: The second is `federation-apiserver`, which validates and configures Kubernetes
    objects such as pods, services, and controllers. `federation-apiserver` is the
    frontend for the cluster through which all other components interact.
  prefs: []
  type: TYPE_NORMAL
- en: Federated services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the building blocks of federation conceptualized in our mind,
    let's review one more facet of this before setting up federation. How exactly
    does a common service, deployed across multiple clusters, work?
  prefs: []
  type: TYPE_NORMAL
- en: 'Federated services are created in a very similar fashion to regular services:
    first, by sending the desired state and properties of the service to an API endpoint,
    which is then brought to bear by the Kubernetes architecture. There are two main
    differences:'
  prefs: []
  type: TYPE_NORMAL
- en: A non-federated service will make an API call directly to a cluster API endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A federated service will make the call to the Federated API endpoint at `federation/v1beta1`,
    which will then redirect the API call to all of the individual clusters within
    the federation control plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This second type of service allows us to extend such things as DNS service discovery
    across cluster boundaries. The DNS `resolv` chain is able to leverage service
    federation and public DNS records to resolve names across multiple clusters.
  prefs: []
  type: TYPE_NORMAL
- en: The API for a federated service is 100% compatible with regular services.
  prefs: []
  type: TYPE_NORMAL
- en: When a service is created, federation takes care of several things. First, it
    creates matching services in all clusters where `kubefed` specifies they reside.
    The health of those services is monitored so that traffic can be routed or re-routed
    to them. Lastly, federation ensure that there's a definitive set of public DNS
    records available through providers such as Route 53 or Google Cloud DNS.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices residing on different pods within your Kubernetes clusters will
    use all of this machinery in order to locate the federated service either within
    their own cluster or navigate to the nearest healthy example within your federation
    map.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up federation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we can use the cluster we had running for the rest of the examples, I
    would highly recommend that you start fresh. The default naming of the clusters
    and contexts can be problematic for the federation system. Note that the `--cluster-context`
    and `--secret-name` flags are there to help you work around the default naming,
    but for first-time federation, it can still be confusing and less than straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, starting fresh is how we will walk through the examples in this chapter.
    Either use new and separate cloud provider (AWS and/or GCE) accounts or tear down
    the current cluster and reset your Kubernetes control environment by running the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Double-check that nothing is listed using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will want to get the `kubefed` command on our path and make it executable.
    Navigate back to the folder where you have the Kubernetes download extracted. The
    `kubefed` command is located in the `/kubernetes/client/bin` folder. Run the following
    commands to get in the `bin` folder and change the execution permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contexts are used by the Kubernetes control plane to keep authentication and
    cluster configuration stored for multiple clusters. This allows us to access and
    manage multiple clusters accessible from the same `kubectl`. You can always see
    the contexts available with the `get-contexts` command that we used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: New clusters for federation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, make sure you navigate to wherever Kubernetes was downloaded and move
    into the `cluster` sub-folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Before we proceed, make sure you have the GCE command line and the AWS command
    line installed, authenticated, and configured. Refer to [Chapter 1](446f901d-70fa-4ebe-be8a-0de14248f99c.xhtml),
    *Introduction to Kubernetes*, if you need assistance doing so on a new box.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create the AWS cluster. Note that we are adding an environment
    variable named `OVERRIDE_CONTEXT`, which will allow us to set the context name
    to something that complies with the DNS naming standards. DNS is a critical component
    for federation as it allows us to do cross-cluster discovery and service communication.
    This is important in a federated world where clusters may be in different data
    centers and even providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run these commands to create your AWS cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a GCE cluster, once again using the `OVERRIDE_CONTEXT` environment
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a look at our contexts now, we will notice both `awsk8s` and `gcek8s`,
    which we just created. The star in front of `gcek8s` denotes that it''s where
    `kubectl` is currently pointing and executing against:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command should produce something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b5b6aae-59f7-4e76-8f74-5520fcb1570a.png)'
  prefs: []
  type: TYPE_IMG
- en: Initializing the federation control plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have two clusters, let''s set up the federation control plane in
    the GCE cluster. First, we''ll need to make sure that we are in the GCE context,
    and then we will initialize the federation control plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command creates a new context just for federation called `master-control`.
    It uses the `gcek8s` cluster/context to host the federation components (such as
    API server and controller). It assumes GCE DNS as the federation's DNS service.
    You'll need to update `dns-zone-name` with a domain suffix you manage.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the DNS provider is GCE. You can use `--dns-provider="aws-route53"`
    to set it to AWS `route53`; however, out of the box implementation still has issues
    for many users.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we check our contexts once again, we will now see three contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command should produce something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32642ab3-67a0-4488-b698-d7283f1a474d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s make sure we have all of the federation components running before we
    proceed. The federation control plane uses the `federation-system` namespace.
    Use the `kubectl get pods` command with the namespace specified to monitor the
    progress. Once you see two API server pods and one controller pod, you should
    be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/07a6f78a-e107-4ca2-95e8-a3a0fc7327a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have the federation components set up and running, let''s switch
    to that context for the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Adding clusters to the federation system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our federation control plane, we can add the clusters to the
    federation system. First, we will join the GCE cluster and then the AWS cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Federated resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Federated resources allow us to deploy across multiple clusters and/or regions.
    Currently, version 1.5 of Kubernetes support a number of core resource types in
    the federation API, including ConfigMap, DaemonSets, Deployment, Events, Ingress,
    Namespaces, ReplicaSets, Secrets, and Services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a federated deployment that will allow us to schedule
    pods across both AWS and GCE. Save the following file as `node-js-deploy-fed.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create this deployment with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try listing the pods from this deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/ac71ec43-457f-4b34-9e3e-6ed440646a9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We should see a message like the preceding one depicted. This is because we
    are still using `master-control` or federation context, which does not itself
    run pods. We will, however, see the deployment in the federation plane and, if
    we inspect the events, we will see that the deployment was in fact created on
    both of our federated clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see something like the following. Notice that the `Events:` section
    shows deployments in both our GCE and AWS contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fab6b6c-e740-47d0-929e-a70d4f55332e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also see the federated events using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/483ab423-3cac-42ae-8b8b-67473995cca6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It may take a moment for all three pods to run. Once that happens, we can switch
    to each cluster context and see some of the pods on each. Note that we can now
    use `get pods` since we are on the individual clusters and not on the control
    plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/cf4f6def-7210-4221-adc9-85f5163b6ddd.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/52d8853d-7773-4e58-af50-a1dd633d8666.png)'
  prefs: []
  type: TYPE_IMG
- en: We should see the three pods spread across the clusters with two on one and
    a third on the other. Kubernetes has spread them across the cluster without any
    manual intervention. Any pods that fail will be restarted, but now we have the
    added redundancy of two cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: Federated configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern software development, it is common to separate configuration variables
    from the application code itself. In this way, it is easier to make updates to
    service URLs, credentials, common paths, and so on. Having these values in external
    configuration files means we can easily update configuration without rebuilding
    the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: This separation solves the initial problem, but true portability comes when
    you can remove the dependency from the application completely. Kubernetes offers
    a configuration store for exactly this purpose. ConfigMaps are simple constructs
    that store key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes also supports Secrets for more sensitive configuration data. This
    will be covered in more detail in [Chapter 10](a26334cc-d455-4eaf-9e0e-6d216848a690.xhtml),
    *Cluster Authentication, Authorization, and Container Security*. You can use the
    example there in both single clusters or on the federation control plane as we
    are demonstrating with ConfigMaps here.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at an example that will allow us to store some configuration
    and then consume it in various pods. The following listings will work for both
    federated and single clusters, but we will continue using a federated setup for
    this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ConfigMap` kind can be created using literal values, flat files and directories,
    and finally YAML definition files. The following listing is a YAML definition
    of the `configmap-fed.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s first switch back to our federation plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create this listing with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s display the `configmap` object that we just created. The `-o yaml` flag
    helps us to display the full information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/83de3392-cff3-4276-8c11-9e8b7de0f327.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a `ConfigMap` object, let''s start up a federated `ReplicaSet` that
    can use the `ConfigMap` object. This will create replicas of pods across our cluster
    that can access the `ConfigMap` object. `ConfigMaps`can be accessed via environment
    variables or mount volumes. This example will use a mount volume that provides
    a folder hierarchy and the files for each key with the contents representing the
    values. Save the following file as `configmap-rs-fed.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create this pod with `kubectl create -f configmap-rs-fed.yaml`. After creation,
    we will need to switch contexts to one of the clusters where the pods are running.
    You can choose either, but we will use the GCE context here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we are on the GCE cluster specifically, let''s check `configmaps` here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `ConfigMap` is propagated locally to each cluster. Next,
    let''s find a pod from our federated `ReplicaSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3dd6ab65-c77d-4d67-b50b-28dc5a464726.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take one of the `node-js-rs` pod names from the listing and run a bash
    shell with `kubectl exec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s change directories to the `/etc/config` folder that we set up
    in the pod definition. Listing this directory reveals a single file with the name
    of the `ConfigMap` we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then display the contents of the files with the following command, we
    should see the value we entered earlier, `my-backend-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If we were to look in any of the pods across our federated cluster, we would
    see the same values. This is a great way to decouple configuration from an application
    and distribute it across our fleet of clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Federated horizontal pod autoscalers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at another example of a newer resource that you can use with the
    federated model: **horizontal pod autoscalers** (**HPAs**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the architecture of these looks like in a single cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79f2b93f-cefb-44aa-abb8-b1f93733bd4a.png)'
  prefs: []
  type: TYPE_IMG
- en: Credit: **[https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#how-does-the-horizontal-pod-autoscaler-work](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#how-does-the-horizontal-pod-autoscaler-work)**.
  prefs: []
  type: TYPE_NORMAL
- en: These HPAs will act in a similar fashion to normal HPAs, with the same functionality
    and same API-based compatibility—only, with federation, the management will traverse
    your clusters. This is an alpha feature, so it is not enabled by default on your
    cluster. In order to enable it, you'll need to run `federation-apiserver` with
    the `--runtime-config=api/all=true` option. Currently, the only metrics that work
    to manage HPAs are CPU utilization metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a file that contains the HPA configuration, called `node-hpa-fed.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add this to our cluster with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `--context=federation-cluster` is telling `kubectl` to send the
    request to `federation-apiserver` instead of `kube-apiserver`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, for example, you wanted to restrict this HPA to a subset of your Kubernetes
    clusters, you can use cluster selectors to restrict the federated object by using
    the `federation.alpha.kubernetes.io/cluster-selector` annotation. It''s similar
    in function to nodeSelector, but acts upon full Kubernetes clusters. Cool! You''ll
    need to create an annotation in JSON format. Here''s a specific example of a ClusterSelector
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This example is going to keep workloads with the `hipaa` label out of environments
    with the `nonprod` label.
  prefs: []
  type: TYPE_NORMAL
- en: For a full list of Top Level Federation API objects, see the following: [https://kubernetes.io/docs/reference/federation/](https://kubernetes.io/docs/reference/federation/)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check your clusters to see whether the HPA was created in an individual
    location by specifying the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''re finished with the HPA, it can be deleted with the following `kubectl`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How to use federated HPAs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HPAs used in the previous manner are an essential tool for ensuring that your
    clusters scale up as their workloads increase. The default behavior for HPA spreading
    in clusters ensure that maximum replicas are spread evenly first in all clusters.
    Let''s say that you have 10 registered Kubernetes clusters in your federation
    control plane. If you have `spec.maxReplicas = 30`, each of the clusters will
    receive the following HPA `spec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to then set `spec.minReplicas = 5`, then some of the clusters will
    receive the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is due to being unable to have a replica sum of 0\. It's important to note
    that federation manipulates the minx/mix replicas it creates on the federated
    clusters, not by directly monitoring the target object metrics (in our case, CPU).
    The federated HPA controller is relying on HPAs within the federated cluster to
    monitor CPU utilization, which then makes changes to specs such as current and
    desired replicas.
  prefs: []
  type: TYPE_NORMAL
- en: Other federated resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen federated Deployments, ReplicaSets, Events, and ConfigMaps
    in action. DaemonSets, Ingress, Namespaces, Secrets, and Services are also supported. Your
    specific setup will vary and you may have a set of clusters that differ from our
    example here. As mentioned earlier, these resources are still in beta, so it's
    worth spending some time to experiment with the various resource types and understand
    how well the federation constructs are supported for your particular mix of infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some examples that we can use to leverage other common Kubernetes
    API objects from a federated perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to see what events are only stored in the federation control plane,
    you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Jobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you go to create a job, you''ll use similar concepts as before. Here''s
    what that looks like when you create a job within the federation context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get the list of these jobs within the federated context with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As with HPAs, you can spread your jobs across multiple underlying clusters with
    the appropriate specs. The relevant definitions are `spec.parallelism` and `spec.completions`,
    and they can be modified by specifying the correct `ReplicaAllocationPreferences`
    with the `federation.kubernetes.io/job-preferences` key.
  prefs: []
  type: TYPE_NORMAL
- en: True multi-cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is an exciting space to watch. As it grows, it gives us a really good start
    to doing multi-cloud implementations and providing redundancy across regions,
    data centers, and even cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: While Kubernetes does provide an easy and exciting path to multi-cloud infrastructure,
    it's important to note that production multi-cloud requires much more than distributed
    deployments. A full set of capabilities from logging and monitoring to compliance
    and host-hardening, there is much to manage in a multi-provider setup.
  prefs: []
  type: TYPE_NORMAL
- en: True multi-cloud adoption will require a well-planned architecture, and Kubernetes
    takes a big step forward in pursuing this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to multi-cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this exercise, we're going to unite two clusters using Istio's multi-cloud
    feature. Normally, we'd create two clusters from scratch, across two CSPs, but
    for the purposes of exploring one single isolated concept at a time, we're going
    to use the GKE to spin up our clusters, so we can focus on the inner workings
    of Istio's multi-cloud functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started by logging in to your Google Cloud Project! First, you'll
    want to create a project in the GUI called `gsw-k8s-3`, if you haven't already,
    and get your Google Cloud Shell to point to it. If you're already pointed at your
    GCP account, you can disregard that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click this button for an easy way to get access to the CLI tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5d89e61-5ecf-4189-9d5c-9dbf599023e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you''ve launched the shell, you can point it to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll set up an environment variable for the project ID, which can echo
    back to see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create some clusters. Set some variables for the zone and cluster
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'First, create cluster one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You may need to change the cluster version to a newer GKE version as updates
    are made. Older versions become unsupported over time. For example, you might
    see a message such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ERROR: (gcloud.container.clusters.create) ResponseError: code=400, message=EXTERNAL:
    Master version "1.9.6-gke.1" is unsupported.` You can check this web page to find
    out the currently supported version of GKE: [https://cloud.google.com/kubernetes-engine/release-notes](https://cloud.google.com/kubernetes-engine/release-notes).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, specify `cluster-2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create it, where you''ll see messages above. We''ll omit them this time
    around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see the same messaging above. You can create another Google Cloud Shell
    window by clicking on the **+** icon in order to create some `watch` commands
    to see the clusters created. Take a minute to do this while the instances are
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f244410-3414-4381-8ba5-8ae26af26fd9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In that window, launch this command: `gcloud container clusters list`. You
    should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'On the dashboard, it''ll look like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b410eee-aa4e-44ce-93f4-6250185c2c0d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next up, we''ll grab the cluster credentials. This command will allow us to
    set a `kubeconfig` context for each specific cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s ensure that we can use `kubectl` to get the context for each cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you then run `kubectl get pods --all-namespaces` after executing each of
    the cluster context switches, you should see something similar to this for each
    cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''re going to need to create a Google Cloud firewall rule so each
    cluster can talk to the other. We''re going to need to gather all cluster networking
    data (tags and CIDR), and then create firewall rules with `gcloud`. The CIDR ranges
    will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The tags will be per-node, resulting in eight total tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the full command now to create the firewall rules. Note the `join_by`
    function is a neat hack that allows us to join multiple elements of an array in
    Bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'That will set up our security firewall rules, which should look similar to
    this in the GUI when complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/275978f9-b5df-4c14-8847-4a8b943bceac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create an admin role that we can use in future steps. First, set `KUBE_USER`
    to the email address associated with your GCP account with `KUBE_USER="<YOUR_EMAIL>"`.
    Next, we''ll create a `clusterrolebinding`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we'll install the Istio control plane with Helm, create a namespace,
    and deploy Istio using a chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check to make sure you''re using `cluster-1` as your context with `kubectl
    config current-context`. Next, we''ll install Helm with these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, switch to another, Istio-specific context where we''ll install Istio in
    its own namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy over the installation chart for Istio into our home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a namespace for it to be used in, install it, and enable injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now set some more environment variables to collect the IPs of our pilot,
    statsD, policy, and telemetry pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now generate a manifest for our remote cluster, `cluster-2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll instill the minimal Istio components and sidecar inject in our
    target, `cluster-2`. Run the following commands in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll create more scaffolding to take advantage of the features of Istio.
    We''ll need to create a file in which we can configure `kubeconfig` to work with
    Istio. First, change back into your home directory with `cd`. The `--minify` flag
    will ensure that you only see output associated with your current context. Now,
    enter the following groups of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file with the following `cat` command. This will inject the contents
    here into a file that''s going to be located in `~/${WORK_DIR}/{CLUSTER_NAME}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''ll create a secret so that the control plane for Istio that exists
    on `cluster-1` can access `istio-pilot` on `cluster-2`. Switch back to the first
    cluster, create a Secret, and label it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve completed these tasks, let''s use all of this machinery to deploy
    one of Google''s code examples, `bookinfo`, across both clusters. Run this on
    the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a file called `reviews-v3.yaml` for deploying `bookinfo` to the
    remote cluster. The file contents can be found in the repository directory of
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s install this deployment on the remote cluster, `cluster-2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Once this is complete, you'll need to get access to the external IP of Istio's
    `isto-ingressgateway` service, in order to view the data in the `bookinfo` homepage.
    You can run this command to open that up. You'll need to reload that page dozens
    of times in order to see Istio's load balancing take place. You can hold down
    *F5* in order to reload the page many times.
  prefs: []
  type: TYPE_NORMAL
- en: You can access `http://<GATEWAY_IP>/productpage` in order to see the reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting the cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to clean up the control panel once you're finished, you can run the
    following commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, delete the firewall rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''ll delete our cluster-admin-rolebinding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let''s delete our GKE clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In the GUI, you can see the cluster being deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c3b43ff-8a9a-4df5-8b73-258bfb7efc2f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also see it on the command line from your `watch` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9386cfa0-813a-48cb-9388-3ca421e49b4c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the same command with your other cluster. You can double-check the Compute
    Engine dashboard to ensure that your instances are being deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69c71f3d-0ec2-4566-b846-3b237ae1f902.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the new federation capabilities in Kubernetes.
    We saw how we can deploy clusters to multiple cloud providers and manage them
    from a single control plane. We also deployed an application across clusters in
    both AWS and GCE. While these features are new and still mainly in alpha and beta,
    we should now have the skills to utilize them as they evolve and become part of
    the standard Kubernetes operating model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will take a look at another advanced topic: security.
    We will cover the basics for secure containers and also how to secure your Kubernetes
    cluster. We will also look at the Secrets construct, which gives us the capability
    to store sensitive configuration data similar to our preceding `ConfigMap` example.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the main goal of federation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main advantage of using federation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the building blocks of federation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Kubernetes CLI command that controls federation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two software components of Kubernetes federation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main difference between HPAs and federated HPAs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What types of federated resources are available?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you'd like more information on mastering Kubernetes, check out another excellent
    Packt resource called *Mastering Kubernetes* ([https://www.packtpub.com/application-development/mastering-kubernetes-second-edition](https://www.packtpub.com/application-development/mastering-kubernetes-second-edition)).
  prefs: []
  type: TYPE_NORMAL
