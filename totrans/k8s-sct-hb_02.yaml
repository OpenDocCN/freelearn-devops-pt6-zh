- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Walking through Kubernetes Secrets Management Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we had a good overview of Kubernetes, the components
    that Kubernetes consists of, and how configurations are applied and stored. Also,
    we built a Golang application and managed to run this application on Kubernetes.
    As expected, Secrets had to be added to our application’s configuration. Secrets
    management comes with various concerns. From creation to modification to deletion,
    we need to tackle security concerns as well as scalability and resiliency.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are Kubernetes Secrets, and how do they differ from other Kubernetes objects?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different types of Secrets and their usage scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, modifying, and deleting Secrets in Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes Secrets configuration in different deployment scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirement for managing Secrets, including secure storage and access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing access to Secrets with RBAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auditing and monitoring Secret usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To link concepts to hands-on examples, we will leverage a series of tools and
    platforms commonly used to interact with containers, Kubernetes, and Secrets management.
    For this chapter, we will ramp up with a friendly desktop graphical solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Podman Desktop** ([https://podman-desktop.io](https://podman-desktop.io))
    is an **open source software** (**OSS**) that interacts with containers, runs
    local Kubernetes instances, and even connects with remote platforms such as Red
    Hat OpenShift, **Azure Kubernetes Service** (**AKS**), and more. We will use the
    Go programming language in this chapter. To install Go on your system, you can
    follow the instructions from the official documentation ([https://go.dev/doc/install](https://go.dev/doc/install)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, **minikube** will also be used. To install minikube on your
    system, you can follow the instructions from the official documentation ([https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the code examples in the book are available on our dedicated GitHub repository
    with a clear structure and instruction set, with corresponding folders for each
    chapter ([https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are Kubernetes Secrets, and how do they differ from other Kubernetes objects?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the fundamental building blocks of Kubernetes is Kubernetes objects.
    Through Kubernetes objects, we can represent the state of the system. An application
    running on Kubernetes consists of the actual program, the resources the application
    uses, and the configurations of the application such as health checks. With regard
    to other cross-cutting concerns such as security, there are configurations for
    **role-based access control** (**RBAC**); these include cluster-wide roles, namespace
    roles, and the role bindings to a user or entity. Furthermore, Kubernetes objects
    include namespaces, which act as logical containers, and network policies, which
    are cluster-wide traffic rules. By creating Kubernetes objects, we declare the
    desired state of the cluster. Kubernetes is responsible for and will work toward
    ensuring that the actual state of the system matches the state defined by the
    objects we create.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical Kubernetes object has certain mandatory fields: `apiVersion`, `kind`,
    `metadata`, and `spec`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see its YAML representation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The most common Kubernetes objects that a Kubernetes user will stumble upon
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Pod`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Deployment`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StatefulSet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cronjob`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ingress`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NetworkPolicy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConfigMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Secret`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding objects can be logically grouped into objects representing workloads.
    Objects such as `Pod`, `Deployment`, `StatefulSet`, and `Cronjob` are used to
    define computing resources that will execute certain tasks; those can be running
    a server, executing a cronjob, or even setting up a distributed memory grid. Objects
    such as `Service`, `Ingress`, and `NetworkPolicy` specify networking aspects of
    our application; this can be load balancing traffic internally, exposing Kubernetes
    services to the internet, as well as blocking traffic internally between applications.
    So far, the Kubernetes objects mentioned are targeted toward application deployments
    to compute resources and traffic routing between applications.
  prefs: []
  type: TYPE_NORMAL
- en: '`ConfigMap` and `Secret` are different in their usage since they are targeted
    toward configuration storage. `ConfigMap` and `Secret` are objects consumed by
    applications running on Kubernetes. `ConfigMap` can be used for storing configurations.
    Common examples of configurations can be an `nginx` configuration stored in `nginx.conf`,
    a JSON-based configuration, or an application configuration based on YAML. `Secret`
    objects are for sensitive data. Take, for example, a `nginx` configuration; we
    need a TLS key stored in a `.key` file and a certificate stored in a `.pem` file.
    Both are sensitive files and need to be handled securely. This secure handling
    should also apply to credentials such as usernames and passwords or access tokens.
    Essentially, Kubernetes Secrets are Kubernetes objects used in order to store
    sensitive configuration data, thus access should be restricted and the information
    stored in Secrets should be handled securely.'
  prefs: []
  type: TYPE_NORMAL
- en: Different types of Secrets and their usage scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes provides us with various types of Secrets. Behind the scenes, it
    uses the same storage mechanism that we saw in [*Chapter 1*](B20970_01.xhtml#_idTextAnchor015),
    *Understanding Kubernetes Secrets Management*; Secrets, once created, will be
    serialized and stored on `etcd`. What differs is how those Secrets are handled
    when used. There are various types of Secrets; let us examine them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Opaque
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Opaque secret is the default secret type. Whenever we want to add a sensitive
    configuration, whether it is a file or a variable, it will be created as an Opaque
    secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'Opaque Secrets can be used by providing key values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Opaque Secrets can also be executed by applying a YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The examples for Opaque Secrets are available in the `ch02/secret-types/opaque`
    folder. The `opaque.sh` script will run the Bash commands needed to achieve the
    end result.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes service account token
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Pod is a unit of work on Kubernetes; a Pod that needs to interact with the
    Kubernetes API is in need of an identity. A service account is an identity that
    can be mapped to Pods directly or transitively through a deployment. A Pod can
    interact with the Kubernetes API, provided it has a service account attached.
    The service account attached is authorized to access resources of interest. On
    startup, the Pod with a service account configured has a service account token
    attached to its filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Long-lived access token
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Kubernetes, prior to version v1.27, a service account token would be accessible
    as a Kubernetes secret managed by Kubernetes. This is called a long-lived access
    token.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s still possible to create a long-lived access token in the latest versions.
    This can be achieved by creating an empty secret and putting an annotation with
    the name of the service account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we note the service account in the `annotations` section. By
    running the `apply` command, we should see that a token has been generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Instructions to create long-lived access tokens are available in the following
    script: `ch02/secret-types/service-account/long-live-access-token.sh`'
  prefs: []
  type: TYPE_NORMAL
- en: Service account token mounted on Pod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve seen a service account as a secret; let us see how a service account token
    is mounted to a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Pod with a service account should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we apply the preceding YAML manifest, we can run a command within the
    Pod we just scheduled. We will print the service account token mounted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, it is a **JSON Web Token** (**JWT**) token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instructions to create a Pod with a service account are available in the following
    script: `ch02/secret-types/service-account/service-account-with-pod.sh`'
  prefs: []
  type: TYPE_NORMAL
- en: Docker config
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using an image on a Pod, we might want to pull images from an alternative
    container registry. For this purpose, we want to mount the Docker configuration
    so that it is possible to communicate with the registry of our choice. One of
    the ways we can test this is by just using our local Docker configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following template to generate a YAML manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can see the `REPLACE_WITH_BASE64` string; this would be replaced with the
    Docker config from Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `docker-credentials` folder, there is already a Docker config file for
    that purpose at `ch02/secret-types/docker-credentials/config.json` without any
    actual credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will issue a login and use our Docker Hub credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The file will contain the basic authentication needed to connect with Docker
    Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use this config to mount it as a Kubernetes secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In our next steps, we will upload the credentials to Kubernetes by applying
    the YAML manifest we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create a Pod that pulls from the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The image will be pulled using the credentials specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding instructions have been orchestrated in the following script:
    `ch02/secret-types/ docker-credentials/docker-credentials.sh`'
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic authentication consists of a key secret combination for the username and
    password. It gives us the option to be more declarative when specifying a basic
    authentication secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'The YAML manifest should contain a value for the `username` and `password`
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once we apply the preceding YAML manifest, the result will be very similar to
    the Opaque Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding instructions have been orchestrated in the following script:
    `ch02/secret-types/ basic-authentication/basic-auth-secret.sh`'
  prefs: []
  type: TYPE_NORMAL
- en: TLS client or server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TLS Secrets are used to store SSL/TLS certificates. TLS Secrets can be used
    in order to be more declarative when it comes to mounting TLS certificates. However,
    a TLS secret can have direct usage when it comes to specifying an Ιngress.
  prefs: []
  type: TYPE_NORMAL
- en: An Ingress acts as an external load balancer to your system, serving HTTP/HTTPS
    traffic. Traffic needs to be secured using SSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'An SSL secret has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: By using the `ch02/secret-types/ssh/tls.sh` script, we will create a certificate
    and key that can be used on an HTTP server. The secret created will be named `ingress-tls`.
    The script used as a certificate will have a `webpage.your.hostname` host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an Ingress using TLS certificates we created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: By using the Ingress, we can define hosts and the SSL for the hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Note on minikube users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you used minikube throughout the `minikube.sh` script, you should enable
    Ingress on your workstation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now test the Ingress. Be aware that the Ingress needs to get an IP assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this IP might belong to an internal VM, we need to issue a `minikube
    tunnel` command, which will forward the traffic to our Ingress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'By navigating to [https://localhost/](https://localhost/), we can see the certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – SSL certificate](img/B20970_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – SSL certificate
  prefs: []
  type: TYPE_NORMAL
- en: Also, if we want to validate the Ingress routing, we can change `/etc/hosts`
    and map the `webpage.your.hostname` DNS to `localhost`.
  prefs: []
  type: TYPE_NORMAL
- en: Token data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This type of secret is a bootstrap token. It looks like the usual bearer token
    that we use on REST APIs; in the case of Kubernetes, it is used specifically for
    the bootstrap process of a Kubernetes cluster. When initializing a Kubernetes
    cluster, a bootstrap token is created and can then be used to join new nodes to
    the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We had a deep dive into Kubernetes Secrets. We identified different types of
    Secrets and ran examples of each secret type, depicting their usage and peculiarities.
    For the latest developments in Secrets, you can always refer to the official documentation
    ([https://kubernetes.io/docs/concepts/configuration/secret/#secret-types](https://kubernetes.io/docs/concepts/configuration/secret/#secret-types)).
    Throughout this section, the provisioning of the Secrets was done through the
    `kubectl` command line. In the next section, we will explore our options for managing
    Secrets, creating them, deleting them, and modifying them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating, modifying, and deleting Secrets in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we focused on creating Secrets and displaying their usage. We will
    proceed further on administrating Secrets and identify the available commands
    and options for provisioning Kubernetes Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: data and stringData
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We applied plaintext Secrets either by using a YAML file or through the command
    line. Behind the scenes, the Secrets that we applied in plaintext were converted
    to a `base64` format. We can either apply Secrets in plaintext or apply them using
    `base64`; eventually, they will end up residing on Kubernetes in a `base64` format.
    When we apply a secret using plaintext values, we use the `stringData` field.
    Kubernetes will handle the encoding and decoding of the values we provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, the following secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we create the secret, we will retrieve it. It should be in `base64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The value was stored in a `base64` format. This is a convention that Kubernetes
    follows for storing Secrets. This is especially useful if we consider the different
    variations a secret can have. A secret can have a complex value; for example,
    a large YAML file or even a binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the complex situations described previously, we have the option of the
    `data` field. When we apply Kubernetes Secrets using a `base64` format, we use
    the `data` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have acquired knowledge on creating Secrets, we will proceed with
    other operations such as `update` and `delete`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to Kubernetes objects, there are some basic commands that we can
    use to manage them. Those commands apply also to Secrets since they are Kubernetes
    objects too.
  prefs: []
  type: TYPE_NORMAL
- en: Editing Secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Editing a secret is done by using the `edit` command of `kubectl`. `kubectl`
    comes with a preconfigured editor. By default, the editor is Vim:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the secret when editing will be presented in a `base64` format.
    If we try to change the secret using plaintext, we will fail. When we edit a secret,
    we must provide a `base64` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'An option when editing a secret using `kubectl` is to record the command that
    causes the change using the `—``record=true` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `edit` command that we issued is recorded.
  prefs: []
  type: TYPE_NORMAL
- en: 'For backup purposes as well as for keeping track of the previous state, when
    editing we can use the `—``save-config=true` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the `last-applied-configuration` field, we will back up the previous configuration.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have edited Secrets and managed to keep track of the commands that
    caused the Secrets to change but also keep track of the last applied configuration.
    This is not always the case; sometimes, we might want Secrets to be immutable,
    which is something we will achieve in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable Secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In certain cases, we might want our Secrets to remain unchanged; for example,
    we want to prevent accidental editing. Here’s how we can achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to edit the following secret, once we try to save, we will face the
    following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Also, if we make an existing secret immutable, then it is not possible to edit
    it; the secret becomes permanently immutable. To change an immutable secret, the
    only way is to delete the secret and re-apply it. Next, we will learn how to delete
    Kubernetes Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: An example of showcasing immutable Secrets is provided at `ch02/secret-types/secret-management/immutable/immutable-secret.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command for deleting a Kubernetes object also applies to Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will delete a Kubernetes secret if it exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'By deleting a secret, it is permanently removed from our system. The only way
    to be able to retrieve it is either by restoring an `etcd` backup, provided it
    contains the secret, or applying a manual backup that was taken using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we went one step further on managing Kubernetes Secrets. We
    updated Secrets, kept track of our changes, and also took a backup of the previously
    existing configuration. Furthermore, we created immutable Secrets in order to
    prevent accidental editing, and last but not least, we deleted Secrets we did
    not need anymore. In the following section, we will focus on concerns surrounding
    secret usage in different environments.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Secrets configuration in different deployment scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the **software development life cycle** (**SDLC**), a team might
    use different environments to test their increments before releasing them to production.
    Just as with a production deployment, any other deployment on another environment
    will have certain configuration requirements, including Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Secret usage among environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to Secrets, we need to ensure their durability and integrity regardless
    of the environment. Having different handling of Secrets in different environments
    can cause issues in the long term, and the team will not be able to fully validate
    the security implications of choices on secret handling.
  prefs: []
  type: TYPE_NORMAL
- en: Provided the environments have differences due to cost-saving requirements or
    because a full installation brings more overhead, Secrets need to be securely
    stored. There might be cases where Secrets might be shared. An example can be
    a proprietary key of an external SaaS service that needs to be shared between
    environments. Another example is when multitenant cloud accounts host multiple
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: From development to deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To deploy a secret, sensitive information needs to reside somewhere. This information
    at some point will be inserted by an individual to a system and applied to Kubernetes.
    Companies nowadays store their sensitive information on various systems designed
    specifically to host this type of information. Briefly, secure storage is required
    to host Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: The life cycle of deploying something as sensitive as a Kubernetes secret starts
    from retrieving the certificate from the secure storage, creating the YAML file
    needed for the secret, and applying it to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of CI/CD jobs, most CI/CD providers provide us with the option to
    use secret values on our jobs. This can assist us in providing credentials to
    our CI/CD jobs to interact with the secret storage.
  prefs: []
  type: TYPE_NORMAL
- en: Another paradigm is GitOps. Argo CD is an extremely popular tool that can have
    a secret deployment customized to be able to apply a secret after it has been
    decrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to different environments, our handling of Secrets should be treated
    the same regardless of the environment. This helps with automation as well as
    consistency.
  prefs: []
  type: TYPE_NORMAL
- en: Requirement for managing Secrets, including secure storage and access control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In terms of responsibilities, a Kubernetes cluster has a responsibility to securely
    contain Secrets and prevent unauthorized access. Every secret that is hosted on
    Kubernetes has been stored by an individual or an automated process. At some point
    in time, this secret that now resides on Kubernetes was in another system. This
    makes it important to store Secrets securely before they reach Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Secure storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various tools dedicated to the purpose of secure storage. Take, for
    example, HashiCorp Vault, **Google Cloud Platform** (**GCP**) Secret Manager,
    and **Amazon Web Services** (**AWS**) Secrets Manager. These are external Secrets
    management solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of those solutions is that they can be used as a standalone Secrets
    management system but can also be used directly from Kubernetes. It is feasible
    to use secure storage during development or even on CI/CD jobs.
  prefs: []
  type: TYPE_NORMAL
- en: A thing these types of solutions have in common is that they tackle cross-cutting
    concerns such as management, versioning, encryption, and access-control capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Access control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Access control is essential to have our secret storage secured. Durability,
    encryption at rest, and encryption in transit make our interactions with a secure
    storage system secure, but it is not enough. We need to have fine-grained control
    when it comes to accessing Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: We need to distinguish between users and their role in an organization. Also,
    permissions might differ per environment. Another aspect is auditing and identifying
    whether there was an incident of unauthorized access.
  prefs: []
  type: TYPE_NORMAL
- en: Git and encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from using a secure storage system, another popular option is to store
    Secrets in an encrypted form. By storing Secrets encrypted on a Git repository,
    various aspects are feasible through Git’s capabilities. For example, versioning
    is by default enabled through commit history, access control is satisfied through
    the access control rules of Git, and the resiliency and durability of storage
    are based on the provider’s guarantees. As for encryption, this can be as good
    as the solution chosen. Data can be encrypted in various forms, from a **Pretty
    Good Privacy** (**PGP**) key ([https://www.openpgp.org/](https://www.openpgp.org/))
    to a hardware security module to a modern **cloud key management service** (**cloud
    KMS**) solution. An extremely popular tool based on this is **Mozilla Secrets
    OPerationS** (**SOPS**): [https://github.com/mozilla/sops](https://github.com/mozilla/sops).
    Mozilla SOPS utilizes KMSs provided by cloud providers as well as PGP.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as with every secret, their access should be limited, and they should not
    be available to be accessed to unauthorized personnel in any circumstances. For
    these reasons, apart from where we keep Secrets, we need to provide proper access
    control.
  prefs: []
  type: TYPE_NORMAL
- en: Securing access to Secrets with RBAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A cross-cutting concern when it comes to Kubernetes objects is authorized access.
    Overall, the state of a system is something sensitive. You should have authorized
    access for operations such as changing the number of replicas for a deployment
    or changing the autoscaling rules for a deployment. The security mechanism that
    Kubernetes provides us with is RBAC.
  prefs: []
  type: TYPE_NORMAL
- en: RBAC introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RBAC consists of the following Kubernetes objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cluster roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cluster role bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will check each component separately and see how they are combined with Kubernetes
    Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Roles are a set of permissions that take effect only on the namespace where
    the role resides. By specifying a role, we define operations that can be executed
    upon a Kubernetes resource. Roles have the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`verbs` are the actions that we should be able to execute, and `resources`
    are the targets for those actions. `apiGroups` points to the API group of the
    resources we will interact with; by setting an empty value, it indicates the core
    API group.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `Role` object enables the actor with that role to get, list, and
    watch Secrets for the default namespaces. Let us proceed and bind that role to
    an actor.
  prefs: []
  type: TYPE_NORMAL
- en: Role bindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By checking how a `Role` object is represented using YAML, we identify the
    action and the target. Role bindings help us to define the actor. An actor can
    be a user (individual or a group) or a service account. Role bindings have the
    following YAML manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A namespace is present when defining a role binding. This is because role bindings
    take effect only on the namespace in which they reside. On `roleRef`, we define
    a role that should be on the same namespace. On `subjects`, we define a list of
    actors that will have access to that role. Take note that the subjects can come
    from different namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster roles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Cluster roles are close to roles: they do define a set of permissions; however,
    they take effect cluster-wide and are not limited to one namespace. They have
    the following YAML representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is almost identical to the `Role` object except for the namespace not being
    present since those rules apply cluster-wide. The preceding `ClusterRole` role
    enables the actor with that role to administer Secrets from all namespaces we
    have on the Kubernetes clusters. We can now proceed with binding that `ClusterRole`
    object to an actor.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster role bindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By using cluster role bindings, we bind a cluster role to a list of users and
    service accounts. A cluster role binding has the following YAML representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have been introduced to RBAC and how we can utilize it to secure
    Secrets, we can proceed to an end-to-end example.
  prefs: []
  type: TYPE_NORMAL
- en: RBAC and Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we created roles and cluster roles for our cluster’s
    secret resources. We focused on a viewer role and an administrator role for Secrets,
    but it is worth seeing if there are more options.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can identify which verbs are related to Secrets by using an `api-resources`
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know what our options are, we will create our own RBAC configuration
    for our Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: ClusterRole
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will create a cluster role for administering Secrets using the `ClusterRole`
    specification in the YAML file we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This should create a cluster role able to administer Secrets cluster-wide.
    We will use a Pod with the `ClusterRole` object attached and check the secret
    creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'By checking the logs, we should see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The Pod was configured with the service account, and the service account has
    a cluster binding to a `ClusterRole` object with admin permissions upon Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use the role we created earlier that provides viewer permissions over
    Secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now have a viewer role for Secrets on the default namespace. We will
    run a Pod to retrieve the Secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we introduced RBAC for Secrets. We identified available actions
    for Secrets within a cluster and the distinction between `ClusterRole` and `Role`
    objects. We then proceeded to secure secret usage within our cluster and provided
    fine-grained authorized access to Secrets, whether access was limited to a namespace
    by using a role or access was granted throughout the cluster. Since we have fulfilled
    the requirement for authorized access, another requirement that we should pay
    attention to is monitoring our secret usage.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing and monitoring secret usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To record and monitor ongoing activities on a Kubernetes cluster, we have the
    option of auditing. Events that happen in a Kubernetes cluster are sent to the
    output stream or saved as logs; this makes it feasible to identify what happened
    in our system.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we want to monitor our secret usage. To avoid the overhead of other
    activities, we will focus only on audits generated for Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The audit configuration to enable audits on Secrets should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'On a Kubernetes installation, this can be achieved by using the `--audit-policy-file`
    flag and passing it when running `kube-apiserver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: minikube note
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the case of minikube, we need to pass the audit configuration when starting
    minikube.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have summed up those actions in the `minikube-script.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we enabled auditing, let’s check the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To trigger an audit event, we can issue a secret operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Eventually, we will receive the following log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We managed to track and monitor changes in our Secrets thanks to enabling the
    auditing feature of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a deeper dive into Kubernetes Secrets. We learned about
    the different types of Kubernetes Secrets and for which occasions they are used,
    and we went through executing code snippets highlighting those use cases. Also,
    since Secrets contain sensitive information, we went further into securing access
    to those Secrets by applying RBAC rules. This helped us to limit access to Secrets
    but also provide authorized access to our Pods. Another aspect that we covered
    is auditing. Auditing is a very important aspect since we want to have full control
    over access to Secrets as well as other operations. In the next chapter, we will
    focus on encrypting Secrets in transit and at rest.
  prefs: []
  type: TYPE_NORMAL
