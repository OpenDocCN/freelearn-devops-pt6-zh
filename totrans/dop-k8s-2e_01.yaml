- en: Introduction to DevOps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the past few years, the software delivery cycle has been moving increasingly
    fast, while at the same time application deployment has become more and more complicated.
    This increases the workload of all roles involved in the release cycle, including
    **software developers**, **Quality Assurance** (**QA**) teams, and **IT operators**.
    In order to deal with rapidly-changing software systems, a new concept called
    **DevOps **was introduced in 2009, which is dedicated to helping the whole software
    delivery pipeline evolve in order to make it faster and more robust.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: How has the software delivery methodology changed?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a microservices architecture? Why do people choose to adopt this architecture?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is DevOps? How can it make software systems more resilient?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software delivery challenges
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Software Development Life Cycle** (**SDLC**), or the way in which we build
    applications and deliver them to the market, has evolved significantly over time.
    In this section, we'll focus on the changes made and why.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Waterfall and static delivery
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in the 1990s, software was delivered in a static way—using a **physical **floppy
    disk or CD-ROM. The SDLC always took years per cycle, because it wasn't easy to
    (re)deliver applications to the market.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'At that time, one of the major software development methodologies was the **waterfall
    model**. This is made up of various phases, as shown in the following diagram:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55700efd-3c68-46c1-8018-ade8b7b2dbea.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: Once one phase was started, it was hard go back to the previous phase. For example,
    after starting the **Implementation** phase, we wouldn't be able to go back to
    the **Design** phase to fix a technical expandability issue, for example, because
    any changes would impact the overall schedule and cost. Everything was hard to
    change, so new designs would be relegated to the next release cycle.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The waterfall method had to coordinate precisely with every department, including
    development, logistics, marketing, and distributors. The waterfall model and static
    delivery sometimes took several years and required tremendous effort.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Agile and digital delivery
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A few years later, when the internet became more widely used, the software delivery
    method changed from physical to **digital**, using methods such as online downloads.
    For this reason, many software companies (also known as dot-com companies) tried
    to figure out how to shorten the SDLC process in order to deliver software that
    was capable of beating their competitors.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Many developers started to adopt new methodologies, such as incremental, iterative,
    or **agile** models, in the hope that these could help shorten the time to market.
    This meant that if new bugs were found, these new methods could deliver patches
    to customers via electronic delivery. From Windows 98, Microsoft Windows updates
    were also introduced in this manner.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'In agile or digital models, software developers write relatively small modules,
    instead of the entire application. Each module is delivered to a QA team, while
    the developers continue to work on new modules. When the desired modules or functions
    are ready, they will be released as shown in the following diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷或数字化模型中，软件开发人员编写的是相对较小的模块，而不是整个应用程序。每个模块会交付给QA团队，而开发者则继续开发新的模块。当所需的模块或功能完成时，它们将按以下图示发布：
- en: '![](img/bf87dad6-cce1-4611-9113-7fa445f095c4.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf87dad6-cce1-4611-9113-7fa445f095c4.png)'
- en: This model makes the SDLC cycle and software delivery faster and easily adjustable.
    The cycle ranges from a few weeks to a few months, which is short enough to make
    quick changes if necessary.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型使得软件开发生命周期（SDLC）和软件交付变得更快速、易于调整。该周期从几周到几个月不等，足够短以便在必要时进行快速修改。
- en: Although this model was favored by the majority at the time, application software
    delivery meant software binaries, often in the form of an EXE program, had to
    be installed and run on the customer's PC. However, the infrastructure (such as
    the server or the network) is very static and has to set up beforehand. Therefore,
    this model doesn't tend to include the infrastructure in the SDLC.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管当时大多数人偏爱这种模型，但应用软件交付意味着软件二进制文件（通常是EXE程序）必须安装并运行在客户的个人电脑上。然而，基础设施（如服务器或网络）是非常静态的，必须提前设置。因此，这种模型通常不包括在软件开发生命周期（SDLC）中。
- en: Software delivery on the cloud
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云上的软件交付
- en: A few years later, smartphones (such as the iPhone) and wireless technology
    (such as Wi-Fi and 4G networks) became popular and widely used. Application software
    was transformed from binaries to online services. The web browser became the interface
    of application software, which meant that it no longer requires installation.
    The infrastructure became very dynamic—in order to accommodate rapidly-changing
    application requirements, it now had to be able to grow in both capacity and performance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 几年后，智能手机（如iPhone）和无线技术（如Wi-Fi和4G网络）变得流行并广泛应用。应用软件从二进制形式转变为在线服务。网页浏览器成为应用软件的界面，这意味着不再需要安装。基础设施变得非常动态——为了适应快速变化的应用需求，它现在必须能够在容量和性能上进行扩展。
- en: This is made possible through virtualization technology and a **Software Defined
    Network** (**SDN**). Now, cloud services, such as **Amazon Web Services** (**AWS**), **Google
    Cloud Platform** (**GCP**), and **Microsoft Azure**, are often used. These can create
    and manage on-demand infrastructures easily.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切得益于虚拟化技术和**软件定义网络**（**SDN**）。如今，云服务，如**亚马逊网络服务**（**AWS**）、**谷歌云平台**（**GCP**）和**微软
    Azure**，通常被广泛使用。这些服务可以轻松创建和管理按需的基础设施。
- en: The infrastructure is one of the most important components within the scope
    of the **Software Development Delivery Cycle**. Because applications are installed
    and operated on the server side, rather than on a client-side PC, the software
    and service delivery cycle takes between just a few days and a few weeks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施是**软件开发交付周期**（SDDC）中最重要的组成部分之一。由于应用程序在服务器端安装和运行，而不是在客户端PC上，因此软件和服务交付周期通常只需几天到几周。
- en: Continuous integration
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: As mentioned previously, the software delivery environment is constantly changing,
    while the delivery cycle is getting increasingly shorter. In order to achieve
    this rapid delivery with a higher quality, developers and QA teams have recently
    started to adopt automation technologies. One of these is **Continuous Integration**
    (**CI**). This includes various tools, such as **Version Control Systems** (**VCSs**),
    **build servers**, and **testing automation tools**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，软件交付环境在不断变化，而交付周期越来越短。为了实现这种快速交付并提高质量，开发者和QA团队最近开始采用自动化技术。其中之一就是**持续集成**（**CI**）。它包括各种工具，如**版本控制系统**（**VCS**）、**构建服务器**和**测试自动化工具**。
- en: VCSs help developers keep track of the software source code changes in central
    servers. They preserve code revisions and prevent the source code from being overwritten
    by different developers. This makes it easier to keep the source code consistent
    and manageable for every release. Centralized build servers connect to VCSs to
    retrieve the source code periodically or automatically whenever the developer
    updates the code to VCS. They then trigger a new build. If the build fails, the
    build server notifies the developer rapidly. This helps the developer when someone
    adds broken code into the VCS. Testing automation tools are also integrated with
    the build server. These invoke the unit test program after the build succeeds,
    then notify the developer and QA team of the result. This helps to identify if
    somebody writes buggy code and stores it in the VCS.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: VCS（版本控制系统）帮助开发者跟踪软件源代码在中央服务器上的更改。它们保存代码的修订记录，并防止不同开发者覆盖源代码。这使得每个版本的源代码都能保持一致和可管理。集中式构建服务器连接到
    VCS，定期或在开发者更新代码到 VCS 时自动获取源代码。然后，它们触发新的构建。如果构建失败，构建服务器会迅速通知开发者。这有助于开发者发现有人将有缺陷的代码提交到
    VCS。测试自动化工具也与构建服务器集成。在构建成功后，这些工具会调用单元测试程序，然后将结果通知开发者和 QA 团队。这有助于识别是否有人编写了有 bug
    的代码并存储到 VCS 中。
- en: 'The entire CI flow is shown in the following diagram:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 CI 流程如以下图所示：
- en: '![](img/786b01ae-4abc-49d8-9b9d-c52c632b7ba1.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/786b01ae-4abc-49d8-9b9d-c52c632b7ba1.png)'
- en: CI helps both developers and QA teams to not only increase the quality, but
    also shorten the process of archiving an application or a module package cycle.
    In the age of electronic delivery to the customer, CI is more than enough. Delivery
    to the customer means deploying the application to the server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: CI 不仅帮助开发者和 QA 团队提高质量，还缩短了应用程序或模块包周期的过程。在电子交付客户的时代，CI 足以应对。交付给客户意味着将应用程序部署到服务器上。
- en: Continuous delivery
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续交付
- en: CI plus deployment automation is an ideal process for server-side applications
    to provide a service to customers. However, there are some technical challenges
    that need to be resolved, such as how to deploy the software to the server; how
    to gracefully shut down the existing application; how to replace and roll back
    the application; how to upgrade or replace system libraries that also need to
    be updated; and how to modify the user and group settings in the OS if necessary.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: CI 加上部署自动化是服务器端应用程序提供服务给客户的理想过程。然而，仍然存在一些技术挑战需要解决，比如如何将软件部署到服务器上；如何优雅地关闭现有应用程序；如何替换并回滚应用程序；如何升级或替换需要更新的系统库；如果需要，如何修改操作系统中的用户和组设置。
- en: An infrastructure includes servers and networks. We normally have different
    environments for different software release stages, such as development, QA, staging,
    and production. Each environment has its own server configuration and IP ranges.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施包括服务器和网络。我们通常有不同的环境来支持不同的软件发布阶段，如开发、QA、预发布和生产。每个环境都有自己的服务器配置和 IP 范围。
- en: '**Continuous Delivery** (**CD**) is a common way of resolving the previously
    mentioned challenges. This is a combination of CI, configuration management, and
    orchestration tools:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续交付** (**CD**) 是解决前面提到的挑战的一种常见方法。这是一个结合了 CI、配置管理和编排工具的过程：'
- en: '![](img/ac970356-20b3-460e-a25f-c4301289a8c6.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac970356-20b3-460e-a25f-c4301289a8c6.png)'
- en: Configuration management
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置管理
- en: Configuration management tools help to configure OS settings, such as creating
    a user or group, or installing system libraries. It also acts as an orchestrator,
    which keeps multiple managed servers consistent with our desired state.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理工具帮助配置操作系统设置，比如创建用户或组，或者安装系统库。它还充当一个编排工具，确保多个管理的服务器与我们期望的状态保持一致。
- en: It's not a programming script, because a script is not necessarily idempotent.
    This means that if we execute a script twice, we might get an error, such as if
    we are trying to create the same user twice. Configuration management tools, however,
    watch the **state**, so if a user is created already, a configuration management
    tool wouldn't do anything. If we delete a user accidentally or even intentionally,
    the configuration management tool would create the user again.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是一个编程脚本，因为脚本不一定是幂等的。这意味着如果我们执行一个脚本两次，可能会出错，比如如果我们尝试创建同一个用户两次。而配置管理工具则关注**状态**，所以如果用户已经创建，配置管理工具不会再做任何操作。如果我们不小心或故意删除了用户，配置管理工具会重新创建该用户。
- en: Configuration management tools also support the deployment or installation of
    software to the server. We simply describe what kind of software package we need
    to install, then the configuration management tool will trigger the appropriate
    command to install the software package accordingly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理工具还支持将软件部署或安装到服务器上。我们只需描述需要安装的软件包类型，然后配置管理工具会触发相应的命令，按照要求安装软件包。
- en: As well as this, if you tell a configuration management tool to stop your application,
    to download and replace it with a new package (if applicable), and restart the
    application, it'll always be up-to-date with the latest software version. Via
    the configuration management tool, you can also perform blue-green deployments
    easily.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你告诉配置管理工具停止你的应用程序，下载并替换为新的软件包（如果适用），然后重启应用程序，它将始终保持最新的版本。通过配置管理工具，你还可以轻松执行蓝绿部署。
- en: Blue-green deployment is a technique that prepares two sets of an application
    stack. Only one environment (for example, the blue one) services the production.
    Then, when you need to deploy a new version of the application, you can deploy
    it to the other side (for example, the green one), then perform the final test.
    If it works fine, you can change the load balancer or router setting to switch
    the network flow from blue to green. Then, the green side becomes the production
    environment, while the blue side becomes dormant and waits for the next version
    to be deployed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿部署是一种技术，准备两套应用栈。只有一个环境（例如，蓝色环境）提供生产服务。当你需要部署新版本的应用时，可以将其部署到另一侧（例如，绿色环境），然后进行最终测试。如果一切正常，你可以更改负载均衡器或路由器设置，将网络流量从蓝色切换到绿色。然后，绿色环境成为生产环境，而蓝色环境变为休眠，等待下一个版本的部署。
- en: Infrastructure as code
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施即代码
- en: 'The configuration management tool supports not only a bare metal environment
    or a VM, but also cloud infrastructure. If you need to create and configure the
    network, storage, and VM on the cloud, the configuration management tool helps
    to set up the cloud infrastructure on the configuration file, as shown in the
    following diagram:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理工具不仅支持裸机环境或虚拟机（VM），还支持云基础设施。如果你需要在云上创建和配置网络、存储和虚拟机，配置管理工具可以帮助在配置文件中设置云基础设施，如下图所示：
- en: '![](img/d6f96fdc-dc0a-48f5-b61b-ce7797502147.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6f96fdc-dc0a-48f5-b61b-ce7797502147.png)'
- en: Configuration management has some advantages compared to a **Standard Operation
    Procedure** (**SOP**). It helps to maintain a configuration file via **VCS**,
    which can trace the history of all of the revisions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理相较于**标准操作程序**（**SOP**）有一些优势。它通过**VCS**帮助维护配置文件，可以追踪所有版本的历史记录。
- en: It also helps to replicate the environment. For example, let's say we want to
    create a disaster recovery site in the cloud. If you follow the traditional approach,
    which involves using the SOP to build the environment manually, it's hard to predict
    and detect human or operational errors. On the other hand, if we use the configuration
    management tool, we can build an environment in the cloud quickly and automatically.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 它还帮助复制环境。例如，假设我们想在云中创建一个灾难恢复站点。如果你按照传统方法，使用SOP手动构建环境，这很难预测和发现人为或操作性错误。另一方面，如果我们使用配置管理工具，我们可以快速且自动地在云中构建环境。
- en: Infrastructure as code may or may not be included in the CD process, because
    the cost of replacing or updating the infrastructure is higher than simply replacing
    an application binary on the server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施即代码（Infrastructure as Code）可能包含也可能不包含在持续交付（CD）过程中，因为替换或更新基础设施的成本高于仅仅替换服务器上的应用程序二进制文件。
- en: Orchestration
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编排
- en: The orchestration tool is part of the configuration management tool set. However,
    this tool is more intelligent and dynamic with regard to configuring and allocating
    cloud resources. The orchestration tool manages several server resources and networks.
    Whenever the administrator wants to increase the application and network capacity,
    the orchestration tool can determine whether a server is available and can then deploy
    and configure the application and the network automatically. Although the orchestration
    tool is not included in SDLC, it helps the capacity management in the CD pipeline.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 编排工具是配置管理工具集的一部分。然而，这种工具在配置和分配云资源方面更加智能和动态。编排工具管理多个服务器资源和网络。每当管理员想增加应用程序和网络容量时，编排工具可以确定服务器是否可用，然后自动部署和配置应用程序和网络。尽管编排工具不包括在SDLC中，但它有助于CD流水线中的容量管理。
- en: To conclude, the SDLC has evolved significantly such that we can now achieve
    rapid delivery using various processes, tools, and methodologies. Now, software
    delivery takes place anywhere and anytime, and software architecture and design
    is capable of producing large and rich applications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，SDLC已经显著发展，使我们能够使用各种过程、工具和方法实现快速交付。现在，软件交付可以随时随地进行，软件架构和设计能够生成大而丰富的应用程序。
- en: The microservices trend
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务趋势
- en: As mentioned previously, software architecture and design has continued to evolve
    based on the target environment and the volume of the application. This section
    will discuss the history and evolution of software design.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前文所述，软件架构和设计基于目标环境和应用程序的体量继续演进。本节将讨论软件设计的历史和演变。
- en: Modular programming
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化编程
- en: As the size of applications increases, the job of developers is to try to divide
    it into several modules. Each module aims to be independent and reusable, and
    each is maintained by different developer teams. The main application simply initializes,
    imports, and uses these modules. This makes the process of building a larger application
    more efficient.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序规模的增加，开发者的任务是尝试将其分解为多个模块。每个模块旨在独立和可重用，并由不同的开发团队维护。主应用程序只需初始化、导入和使用这些模块。这使得构建更大的应用程序的过程更加高效。
- en: 'The following example shows the dependencies for `nginx` ([https://www.nginx.com](https://www.nginx.com))
    on CentOS 7\. It indicates that `nginx` uses `OpenSSL(libcrypt.so.1, libssl.so.10)`,
    the `POSIX thread(libpthread.so.0)` library, the regular expression `PCRE(libpcre.so.1)` library, the `zlib(libz.so.1)` compression
    library, the `GNU C(libc.so.6)` library, and so on:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了在CentOS 7上`nginx` ([https://www.nginx.com](https://www.nginx.com)) 的依赖项。它表明`nginx`使用`OpenSSL(libcrypt.so.1,
    libssl.so.10)`，`POSIX thread(libpthread.so.0)`库，正则表达式`PCRE(libpcre.so.1)`库，`zlib(libz.so.1)`压缩库，`GNU
    C(libc.so.6)`库等等：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `ldd(list dynamic dependencies)` command is included in the `glibc-common`
    package on CentOS.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldd(list dynamic dependencies)`命令包含在CentOS的`glibc-common`软件包中。'
- en: Package management
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件包管理
- en: The Java programming language, and several other scripting programming languages
    such as Python, Ruby, and JavaScript, have their own module or package management
    tool. Java, for example, has Maven ([http://maven.apache.org](http://maven.apache.org)),
    Python uses `pip` ([https://pip.pypa.io](https://pip.pypa.io)), RubyGems ([https://rubygems.org](https://rubygems.org))
    is used for for Ruby, and `npm` is used ([https://www.npmjs.com](https://www.npmjs.com))
    for JavaScript.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Java编程语言以及Python、Ruby和JavaScript等多种脚本编程语言，都有自己的模块或软件包管理工具。例如，Java使用Maven ([http://maven.apache.org](http://maven.apache.org))，Python使用`pip`
    ([https://pip.pypa.io](https://pip.pypa.io))，Ruby使用RubyGems ([https://rubygems.org](https://rubygems.org))，JavaScript使用`npm`
    ([https://www.npmjs.com](https://www.npmjs.com))。
- en: 'Package management tools not only allow you to download the necessary packages,
    but can also register the module or package that you implement. The following
    screenshot shows the Maven repository for the AWS SDK:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包管理工具不仅允许你下载必要的软件包，还能注册你实施的模块或软件包。以下屏幕截图显示了AWS SDK的Maven仓库：
- en: '![](img/59825fef-e5e6-41a0-829c-6aabe6771811.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59825fef-e5e6-41a0-829c-6aabe6771811.png)'
- en: 'When you add dependencies to your application, Maven downloads the necessary
    packages. The following screenshot is the result you get when you add the `aws-java-sdk`
    dependency to your application:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向应用程序添加依赖项时，Maven会下载必要的软件包。以下屏幕截图显示了当你将`aws-java-sdk`依赖项添加到应用程序时的结果：
- en: '![](img/a1b77c54-4409-4b95-a82d-03bd62911f77.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1b77c54-4409-4b95-a82d-03bd62911f77.png)'
- en: Modular programming helps you to accelerate software development speed. However,
    applications nowadays have become more sophisticated. They require an ever-increasing
    number of modules, packages, and frameworks, and new features and logic are continuously
    added. Typical server-side applications usually use authentication methods such
    as LDAP, connect to a centralized database such as RDBMS, and then return the
    result to the user. Developers have recently found themselves required to utilize
    software design patterns in order to accommodate a bunch of modules in an application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The MVC design pattern
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most popular application design patterns is **Model-View-Controller**
    (**MVC**). This defines three layers: the Model layer is in charge of data queries and persistence,
    such as loading and storing data to a database; the **View** layer is in charge
    of the **User Interface** (**UI**) and the **Input/Output** (**I/O**); and the
    **Controller** layer is in charge of business logic, which lies in between the **View**
    and the **Model**:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e071a9a-ff6e-4959-9d95-126fe1d5988b.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: There are some frameworks that help developers to make MVC easier, such as Struts
    ([https://struts.apache.org/](https://struts.apache.org/)), SpringMVC ([https://projects.spring.io/spring-framework/](https://projects.spring.io/spring-framework/)),
    Ruby on Rails ([http://rubyonrails.org/](http://rubyonrails.org/)), and Django
    ([https://www.djangoproject.com/](https://www.djangoproject.com/)). MVC is one
    of the most successful software design pattern, and is used for the foundation
    of modern web applications and services.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: MVC defines a borderline between every layer, which allows several developers
    to jointly develop the same application. However, it also causes some negative
    side effects. The size of the source code within the application keeps getting
    bigger. This is because the database code (the **Model**), the presentation code
    (the **View**), and the business logic (the **Controller**) are all within the
    same VCS repository. This eventually has an impact on the software development
    cycle. This type of application is called a **monolithic **application. It contains
    a lot of code that builds a giant EXE or war program.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic applications
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's no concrete measurement that we can use to define an application as
    monolithic, but a typical monolithic app tends to have more than 50 modules or
    packages, more than 50 database tables, and requires more than 30 minutes to build.
    If we need to add or modify one of those modules, the changes made might affect
    a lot of code. Therefore, developers try to minimize code changes within the application.
    This reluctance can lead to the developer hesitation to maintain the application
    code, however, if problems aren't dealt with in a timely manner. For this reason, developers
    now tend to divide monolithic applications into smaller pieces and connect them
    over the network.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Remote procedure call
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In fact, dividing an application into small pieces and connecting them via a
    network was first attempted back in the 1990s, when Sun Microsystems introduced
    the **Sun** **Remote Procedure Call** (**SunRPC**). This allows you to use a module
    remotely. One of most popular implementation is **Network File System** (**NFS**).
    The NFS client and the NFS server can communicate over the network, even if the
    server and the client use different CPUs and OSes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，将一个应用程序划分为小部分并通过网络连接最早是在1990年代进行尝试的，当时Sun Microsystems推出了**Sun远程过程调用**（**SunRPC**）。这允许远程使用某个模块。最流行的实现之一是**网络文件系统**（**NFS**）。NFS客户端和NFS服务器可以通过网络进行通信，即使服务器和客户端使用不同的CPU和操作系统。
- en: Some programming languages also support RPC-style functionality. UNIX and the
    C language have the `rpcgen` tool, which generates a stub code that contains some
    complicated network communication code. The developer can use this over the network
    to avoid difficult network-layer programming.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言也支持RPC风格的功能。UNIX和C语言有`rpcgen`工具，它生成包含一些复杂网络通信代码的存根代码。开发者可以通过网络使用这些代码，以避免困难的网络层编程。
- en: 'Java has the **Java** **Remote Method Invocation** (**RMI**), which is similar
    to the Sun RPC, but specific to the Java language. The **RMI Compiler** (**RMIC**)
    generates the stub code that connects remote Java processes to invoke the method
    and return a result. The following diagram shows the procedure flow of the Java
    RMI:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Java有**Java远程方法调用**（**RMI**），它类似于Sun RPC，但特定于Java语言。**RMI编译器**（**RMIC**）生成连接远程Java进程以调用方法并返回结果的存根代码。下图展示了Java
    RMI的过程流程：
- en: '![](img/b9cdbfae-03ba-43bb-9026-b052d226e5bb.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9cdbfae-03ba-43bb-9026-b052d226e5bb.png)'
- en: Objective C has a **distributed object** and .NET has **remoting**, both of
    which work in a similar fashion. Most modern programming languages have RPC capabilities
    out of the box. These RPC designs are capable of dividing a single application
    into multiple processes (programs). Individual programs can have separate source
    code repositories. While the RPC designs worked well, machine resources (CPU and
    memory) were limited during the 1990s and early 2000s. Another disadvantage was
    that the same programming language was intended to be used throughout and these
    designs were intended to be used for a client/server model architecture, rather
    than a distributed architecture. In addition, there was less security consideration
    when these designs were developed, so they are not recommended to be used over
    a public network.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Objective C有**分布式对象**，而.NET有**远程调用**，两者的工作方式相似。大多数现代编程语言都自带RPC功能。这些RPC设计能够将单一应用分割成多个进程（程序）。各个程序可以有独立的源代码仓库。尽管RPC设计在一定程度上有效，但在1990年代和2000年代初期，机器资源（CPU和内存）有限。另一个缺点是这些设计通常要求使用相同的编程语言，并且这些设计是为客户端/服务器架构而设计的，而非分布式架构。此外，这些设计在开发时对安全性的考虑较少，因此不推荐在公共网络上使用。
- en: In the early 2000s, initiative **web services** that used **SOAP** (HTTP/SSL)
    as data transport were developed. These used XML for data presentation and the **Web
    Services Description Language** (**WSDL**) to define services. Then, **Universal
    Description, Discovery, and Integration** (**UDDI**) was used as the service registry
    to look up a web services application. However, as machine resources were not
    plentiful at the time and due to the complexity of programming and maintaining
    web services, this was not widely accepted by developers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代初，使用**SOAP**（HTTP/SSL）作为数据传输的**Web服务**应运而生。这些服务使用XML作为数据呈现，并使用**Web服务描述语言**（**WSDL**）定义服务。随后，**通用描述、发现与集成**（**UDDI**）作为服务注册表，用于查找Web服务应用。然而，由于当时机器资源不充裕，并且Web服务的编程与维护复杂，这一技术未被开发者广泛接受。
- en: Nowadays, gRPC ([https://grpc.io/](https://grpc.io/)) has led to a complete
    reevaluation of programming techniques because gRPC is a simple, secure, multi-language
    support.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，gRPC ([https://grpc.io/](https://grpc.io/)) 促使编程技术发生了彻底的重新评估，因为gRPC是一个简单、安全、支持多语言的工具。
- en: RESTful design
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful设计
- en: In the 2010s, machines and even smartphones were able to access plenty of CPU
    resources, and network bandwidths of a few hundred Mbps were everywhere. Developers started
    to utilize these resources to make application code and system structures as easy
    as possible, making the software development cycle quicker.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在2010年代，机器甚至智能手机能够访问大量的CPU资源，并且几百Mbps的网络带宽到处可见。开发者开始利用这些资源，使应用程序代码和系统结构尽可能简单，从而加快了软件开发周期。
- en: 'Nowadays, there are sufficient hardware resources available, so it makes sense
    to use HTTP/SSL as the RPC transport. In addition, from experience, developers
    choose to make this process easier as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，硬件资源已经足够充裕，因此使用HTTP/SSL作为RPC传输是有意义的。此外，根据经验，开发人员选择以下方式简化这一过程：
- en: By making HTTP and SSL/TLS as standard transport
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将HTTP和SSL/TLS作为标准传输协议
- en: By using HTTP method for **Create**/**Load**/**Upload**/**Delete** (**CLUD**)
    operation, such as `GET`, `POST`, `PUT`, or `DELETE`
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用HTTP方法进行**创建**/**加载**/**上传**/**删除**（**CLUD**）操作，例如`GET`、`POST`、`PUT`或`DELETE`
- en: By using the URI as the resource identifier, the user with the ID `123`, for
    example, would have the URI of `/user/123/`
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用URI作为资源标识符，例如，具有ID为`123`的用户，其URI将是`/user/123/`
- en: By using JSON for standard data presentation
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用JSON作为标准数据表示格式
- en: These concepts are known as **Representational State Transfer** (**RESTful**)
    design. They have been widely accepted by developers and have become the de facto
    standard of distributed applications. RESTful applications allow the use of any
    programming language, as they are HTTP-based. It is possible to have, for example,
    Java as the RESTful server and Python as the client.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念被称为**表征状态转移**（**RESTful**）设计。它们已经被开发人员广泛接受，并成为分布式应用程序的事实标准。RESTful应用程序允许使用任何编程语言，因为它们基于HTTP。例如，可以使用Java作为RESTful服务器，Python作为客户端。
- en: RESTful design brings freedom and opportunities to the developer. It makes it
    easy to perform code refactoring, to upgrade a library, and even to switch to
    another programming language. It also encourages the developer to build a distributed
    modular design made up of multiple RESTful applications, which are called microservices.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful设计为开发人员带来了自由和机会。它使得代码重构、升级库甚至切换到其他编程语言变得更加容易。它还鼓励开发人员构建由多个RESTful应用组成的分布式模块化设计，这些应用被称为微服务。
- en: If you have multiple RESTful applications, you might be wondering how to manage
    multiple source codes on VCS and how to deploy multiple RESTful servers. However,
    CI and CD automation makes it easier to build and deploy multiple RESTful server
    applications. For this reason, the microservices design is becoming increasingly
    popular for web application developers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多个RESTful应用，你可能会想知道如何在VCS上管理多个源代码以及如何部署多个RESTful服务器。然而，CI和CD自动化使得构建和部署多个RESTful服务器应用变得更加容易。因此，微服务设计正在成为Web应用开发人员越来越受欢迎的选择。
- en: Microservices
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: Although microservices have the word micro in their name, they are actually
    pretty heavy compared to applications from the 1990s or early 2000s. They use
    full stack HTTP/SSL servers and contain entire MVC layers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管微服务的名称中有“微”字，但与1990年代或2000年代初期的应用程序相比，它们实际上相当“重”。它们使用完整堆栈的HTTP/SSL服务器，并包含整个MVC层。
- en: 'The microservices design has the following advantages:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务设计具有以下优势：
- en: '**Stateless**: They don''t store user sessions to the system, which helps to
    scale the application.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：微服务不会存储用户会话，这有助于扩展应用程序。'
- en: '**No shared data store**: Microservices should have their own data stores, such
    as databases. They shouldn''t share these with other applications. They help to
    encapsulate the backend database so that it is easier to refactor and update the
    database scheme within a single microservice.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有共享数据存储**：微服务应该拥有自己的数据存储，例如数据库。它们不应该与其他应用共享这些数据存储。这有助于封装后端数据库，从而更容易在单个微服务内重构和更新数据库架构。'
- en: '**Versioning and compatibility**: Microservices may change and update the API,
    but they should define versions, such as `/api/v1` and `/api/v2`, that have backward
    compatibility. This helps to decouple other microservices and applications.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制与兼容性**：微服务可能会更改和更新API，但它们应定义版本，例如`/api/v1`和`/api/v2`，并保持向后兼容性。这有助于解耦其他微服务和应用程序。'
- en: '**Integrate CI/CD**: The microservice should adopt the CI and CD process to
    eliminate management effort.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成CI/CD**：微服务应采用CI和CD流程，以消除管理工作量。'
- en: There are some frameworks that can help to build microservice-based applications,
    such as Spring Boot ([https://projects.spring.io/spring-boot/](http://spring.io/projects/spring-boot))
    and Flask ([http://flask.pocoo.org](http://flask.pocoo.org/)). However, there're
    a lot of HTTP-based frameworks, so developers can feel free to choose any preferred
    framework or programming language. This is the beauty of the microservice design.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a comparison between the monolithic application design
    and the microservices design. It indicates that a microservice design is the same
    as the monolithic design; they both contain an interface layer, a business logic
    layer, a model layer, and a data store. The difference is, however, that the application
    is constructed of multiple microservices. Different applications can share the
    same microservices:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f127da8-e5e3-471b-aabb-c2b680f70ecf.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: The developer can add the necessary microservices and modify existing microservices
    with a rapid software delivery method that won't affect an existing application
    or service. This is an important breakthrough. It represents an entire software
    development environment and methodology that's widely accepted by developers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Although CI and CD automation processes help to develop and deploy microservices,
    the number of resources, such as VMs, OS, libraries, disk volumes, and networks, can't
    compare with monolithic applications. There are some tools that can support these
    large automation environments on the cloud.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Automation and tools
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed previously, automation is the best way to achieve rapid software
    delivery. It solves the issue of managing microservices. However, automation tools
    aren't ordinary IT or infrastructure applications such as **Active Directory**,
    **BIND** (DNS), or **Sendmail** (MTA). In order to achieve automation, we need
    an engineer who should have both a developer skill set to write code, particularly
    in scripting languages, and an infrastructure operator skill set with knowledge
    related to VMs, networks, and storage operations.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: DevOps is short for development and operations. It refers to the ability to
    make automation processes such as CI, infrastructure as code, and CD. It uses
    some DevOps tools for these automation processes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration tools
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the popular VCS tools is Git ([https://git-scm.com](https://git-scm.com)).
    A developer uses Git to check-in and check-out code all the time. There are various
    hosting Git services, including GitHub ([https://github.com](https://github.com/))
    and Bitbucket ([https://bitbucket.org](https://bitbucket.org)). These allow you
    to create and save your Git repositories and collaborate with other users over
    the internet. The following screenshot shows a sample pull request on GitHub:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2732bf6-6fc5-41f2-91ce-922e259b252d.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: The build server has a lot of variation. Jenkins ([https://jenkins.io](https://jenkins.io))
    is one of the most well established applications, along with TeamCity ([https://www.jetbrains.com/teamcity/](https://www.jetbrains.com/teamcity/)).
    As well as build servers, you also have hosted services, otherwise known as **Software
    as a Service** (**SaaS**), such as Codeship ([https://codeship.com](https://codeship.com/))
    and Travis CI ([https://travis-ci.org](https://travis-ci.org/)). SaaS can integrate
    with other SaaS tools. The build server is capable of invoking external commands,
    such as unit test programs. This makes the build server a key tool within the
    CI pipeline.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a sample build using Codeship. We check out
    the code from GitHub and invoke Maven for building (`mvn compile`) and unit testing
    (`mvn test`) our sample application:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e3bebc6-5efe-407c-8859-d2bc04543820.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: Configuration management tools
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a variety of configuration management tools available. The most popular
    ones include Puppet ([https://puppet.com](https://puppet.com)), Chef ([https://www.chef.io](https://www.chef.io)),
    and Ansible ([https://www.ansible.com](https://www.ansible.com)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'AWS OpsWorks ([https://aws.amazon.com/opsworks/](https://aws.amazon.com/opsworks/))
    provides a managed Chef platform on AWS Cloud. The following screenshot shows
    a Chef recipe (configuration) of an installation of the Amazon CloudWatch Log
    agent using AWS OpsWorks. AWS OpsWorks automates the installation of the CloudWatch
    Log agent when launching an EC2 instance:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cd17de8-69e6-4fc9-a46f-08052bd7ec95.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'AWS CloudFormation ([https://aws.amazon.com/cloudformation/](https://aws.amazon.com/cloudformation/))
    helps to achieve infrastructure as code. It supports the automation of AWS operations,
    so that we can perform the following functions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Creating a VPC
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a subnet on VPC
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an internet gateway on VPC
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a routing table to associate a subnet to the internet gateway
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a security group
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a VM instance
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associating a security group to a VM instance
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The configuration of CloudFormation is written by JSON, as shown in the following
    screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbef6f55-2055-4f89-97d3-db72ef43dd7e.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: CloudFormation supports parameterizing, so it's easy to create an additional
    environment with different parameters (such as VPC and CIDR) using a JSON file
    with the same configuration. It also supports the update operation. If we need
    to change a part of the infrastructure, there's no need to recreate the whole
    thing. CloudFormation can identify a delta of configuration and perform only the
    necessary infrastructure operations on your behalf.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'AWS CodeDeploy ([https://aws.amazon.com/codedeploy/](https://aws.amazon.com/codedeploy/))
    is another useful automation tool that focuses on software deployment. It allows
    the user to define the deployment steps. You can carry out the following actions
    on the YAML file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Specify where to download and install the application
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify how to stop the application
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify how to install the application
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify how to start and configure an application
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot is an example of the AWS CodeDeploy configuration
    file, `appspec.yml`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c52811ce-877b-4b4d-8ec8-503ee36e977b.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Monitoring and logging tools
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you start to manage microservices using a cloud infrastructure, there are
    various monitoring tools that can help you to manage your servers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon** **CloudWatch** is the built-in monitoring tool for AWS. No agent
    installation is needed; it automatically gathers metrics from AWS instances and
    allows the user to visualize these in order to carry out DevOps tasks. It also
    supports the ability to set an alert based on the criteria that you set. The following
    screenshot shows the Amazon CloudWatch metrics for an EC2 instance:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0062afda-837d-465f-b1ee-c57139856d42.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: Amazon CloudWatch also supports the gathering of an application log. This requires
    us to install an agent on an EC2 instance. Centralized log management is useful
    when you need to start managing multiple microservice instances.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'ELK is a popular combination of stacks that stands for Elasticsearch ([https://www.elastic.co/products/elasticsearch](https://www.elastic.co/products/elasticsearch)),
    Logstash ([https://www.elastic.co/products/logstash](https://www.elastic.co/products/logstash)),
    and Kibana ([https://www.elastic.co/products/kibana](https://www.elastic.co/products/kibana)).
    Logstash aggregates the application log, transforms it to JSON format, and then
    sends it to Elasticsearch. Elasticsearch is a distributed JSON database. Kibana
    can visualize the data that''s stored on Elasticsearch. The following Kibana example
    shows an `nginx` access log:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19e4ce39-382e-45a9-b88a-80205520e4e5.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: Grafana ([https://grafana.com](https://grafana.com)) is another popular visualization
    tool. It used to be connected with time series databases such as Graphite ([https://graphiteapp.org](https://graphiteapp.org/))
    or InfluxDB ([https://www.influxdata.com](https://www.influxdata.com/)). A time
    series database is designed to store data that's flat, de-normalized, and numeric,
    such as CPU usage or network traffic. Unlike RDBMS, a time series database has
    some optimization in order to save data space and can carry out faster queries
    on historical numeric data. Most DevOps monitoring tools use time series databases
    in the backend.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Grafana screenshot shows some **Message Queue Server** statistics:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ace2512-fe08-4717-93bb-ee664e2f1810.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: Communication tools
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you start to use several DevOps tools, you need to go back and forth to
    visit several consoles to check whether the CI and CD pipelines work properly
    or not. In particular, the following events need to be monitored:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Merging the source code to GitHub
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering the new build on Jenkins
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering AWS CodeDeploy to deploy the new version of the application
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These events need to be tracked. If there's any trouble, DevOps teams needs
    to discuss this with the developers and the QA team. However, communication can
    be a problem here, because DevOps teams are required to capture each event one
    by one and then pass it on as appropriate. This is inefficient.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: There are some communication tools that help to integrate these different teams.
    They allow anyone to join to look at the events and communicate. Slack ([https://slack.com](https://slack.com))
    and HipChat ([https://www.hipchat.com](https://www.hipchat.com)) are the most
    popular communication tools.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'These tools also support integration with SaaS services so that DevOps teams
    can see events on a single chat room. The following screenshot is a Slack chat
    room that integrates with Jenkins:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a10b4cdf-8349-4060-9434-38736610cec2.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: The public cloud
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI, CD, and automation work can be achieved easily when used with cloud technology.
    In particular, public cloud APIs help DevOps to come up with many CI and CD tools.
    Public clouds such as Amazon Web Services ([https://aws.amazon.com](https://aws.amazon.com)), Google
    Cloud Platform ([https://cloud.google.com](https://cloud.google.com/)), and Microsoft
    Azure ([https://azure.microsoft.com](https://azure.microsoft.com)) provide some
    APIs for DevOps teams to control cloud infrastructure. The DevOps can also reduce
    wastage of resources, because you can pay as you go whenever the resources are
    needed. The public cloud will continue to grow in the same way as the software
    development cycle and the architecture design. These are all essential in order
    to carry your application or service to success.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the web console for Amazon Web Services:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/964e31d9-9d61-4c6c-9ae7-5b4227b9c08c.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: 'Google Cloud Platform also has a web console, as shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45bba9f8-cec6-421d-b19f-757b14a1f066.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a screenshot of the Microsoft Azure console as well:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3af792a2-0475-418c-9a27-60b5bc7f8095.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: All three cloud services have a free trial period that a DevOps engineer can
    use to try and understand the benefits of cloud infrastructure.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've discussed the history of software development methodology,
    programming evolution, and DevOps tools. These methodologies and tools support
    a faster software delivery cycle. The microservices design also helps to produce
    continuous software updates. However, microservices increase the complexity of
    the management of an environment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](05e2d0b4-0e70-4480-b5a0-f3860ddb24f2.xhtml), *DevOps with Containers*,
    we will describe the Docker container technology, which helps to compose microservice
    applications and manage them in a more efficient and automated way.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
