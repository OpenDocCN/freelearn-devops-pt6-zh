- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitOps with Flux for Edge Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previous chapters have already covered the basics of building your home lab
    using K3s. It’s time to implement simple use cases that you can use in edge computing.
    This chapter covers how to implement GitOps for your applications using Flux in
    edge computing environments, starting with the basic theory of GitOps and the
    necessary tools to manage a Git repository for deployments. Then, we will look
    at how to install Flux to implement a basic GitOps workflow for a demo application.
    This chapter includes how to automate an application deployment using a **mono
    repository** (**monorepo**) configuration, the Helm operator, and the image updater
    feature of Flux. Finally, we will end the chapter with the installation of basic
    monitoring dashboards in Flux, essential troubleshooting commands for Flux, and
    how to uninstall Flux.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GitOps for edge computing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flux and its architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing GitOps with Flux for edge applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your container image with GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring Flux for GitOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting Flux installations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Flux monitoring dashboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uninstalling Flux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, to implement GitOps using Flux, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Three single node K3s clusters using a device with an **ARM** processor such
    as a Raspberry Pi.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Previous experience with Git.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub repository and its token; you also need some basic experience using Git.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Hub account to push new image releases of your application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, you are ready for this first use case to implement GitOps at the
    edge using Flux. So, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more detail and code snippets, check out this resource on GitHub: [https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch7](https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch7)'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GitOps for edge computing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start this topic, let’s get started with the concept of GitOps. The [https://www.gitops.tech/](https://www.gitops.tech/)
    website states: “*GitOps is a way of implementing Continuous Deployment for cloud
    native applications. It focuses on a developer-centric experience when operating
    infrastructure, by using tools developers are already familiar with, including
    Git and Continuous Deployment tools*.” This means that GitOps helps you with your
    **continuous deployment** (**CD**) in general. In software engineering, it is
    common to refer to continuous deployment and continuous delivery with the CD acronym.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the GitLab page [https://about.gitlab.com/topics/gitops](https://about.gitlab.com/topics/gitops)
    mentions that GitOps contains the following basic components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infrastructure as code** (**IaC**): This refers to a declarative way to provide
    infrastructure or deployments for your applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Merge requests or pull requests** (**PRs**): A way to manage infrastructure
    or application code updates across multiple changes and collaborators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source code management** (**SCM**): Systems such as Git enable merge request-
    or pull request-based workflows and a mechanism to manage this, usually using
    a Git repository. In this way, a team can have an approval-and-review mechanism
    to apply changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous integration and continuous delivery** (**CI/CD**): CI and CD include,
    by nature, all the processes of building, checking, and deploying applications
    and changes to those software applications. GitOps is used to automate CD for
    a cloud native application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, you will find tools that provide mechanisms for CI/CD automation
    pipelines. Let’s pay attention to the following diagram that shows a summary of
    how GitOps works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – GitOps'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – GitOps
  prefs: []
  type: TYPE_NORMAL
- en: 'The basics of starting with GitOps are outlined here, as depicted in *Figure
    7.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Commit code to the source**: Here, a developer makes changes and pushes their
    changes to a source or repository—for example, a Git repository hosted at GitHub.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Synchronize changes**: A GitOps tool such as, for example, Flux periodically
    detects changes in the source.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Provision or reconcile changes**: Once the GitOps tool detects changes, it
    aims to automate the process of updating a deployment based on the declarative
    configuration changes found. This could include processes to modify, such as changing
    configurations, updating the container image for an application using containers,
    and so on. Sometimes, if a resource or deployment doesn’t exist, you have to provision
    resources or reconcile these, comparing changes. This means that a GitOps tool
    regularly works with declarative definitions to reflect the state of your infrastructure
    or application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the user will see changes when accessing their application, and you
    can also add some additional processes such as notifications if a process was
    finalized, or an alert if something fails.
  prefs: []
  type: TYPE_NORMAL
- en: In general, this is how a GitOps process works and how a GitOps tool operates.
    In this chapter, we are going to focus on Flux as our GitOps tool, to implement
    GitOps processes to automate our applications’ deployments and updates.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some principles that you have to follow if you are using GitOps to
    automate your CD pipelines. Based on *Weaveworks*, these principles are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative definitions**: You can often find these definitions using **YAML**
    files, but they could also be found in other formats such as **JSON**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State of your applications versioned with Git**: GitOps tools use Git repositories
    to store changes and states for applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Approve changes that can be applied automatically to your resources**: Git
    repositories or services provide ways to automate a trigger tool when some changes
    or merges are detected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software agents listening to changes notifying or alerting**: GitOps tools
    also have daemons listening to changes in a ready-to-launch action, such as changing
    a repository with a new image tag in the case of applications using containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitOps benefits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you know how a GitOps tool works and how GitOps processes help you to automate
    your CD pipeline, it’s time to find out about the benefits of GitOps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on *Weaveworks*, these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased productivity**: An automated process reduces the execution time;
    in this case, more changes and updates made for your applications in less time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced developer experience**: GitOps tools usually launch automated processes
    on your Git repository, and these will be launched automatically without knowing
    the internals of how it works—for example, for applications using Kubernetes,
    a developer doesn’t have to know Kubernetes in some cases. However, this depends
    on how your application is structured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved stability**: Logs of GitOps tools are included by default, which
    helps to meet some security and monitoring features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Higher reliability**: GitOps tools give you the ability to implement rollback
    mechanisms, reducing downtime for your applications if a change has an impact
    on the operation of your system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency and standardization**: GitOps tools have structures to define
    your applications, and give you best practices for your applications’ definitions,
    pipelines, or updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stronger security guarantees**: GitOps tools have security features such
    as cryptography for secrets, and tracking and managing changes. This brings a
    way to secure your applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s move on to understand how GitOps works in a cloud native context.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps, cloud native, and edge computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we know, **cloud native** refers to the use of applications using technologies
    such as containers, microservices, and CI/CD in the context of a **development-operations**
    (**DevOps**) culture. So, you can find an intersection for this concept when a
    GitOps tool is designed to run on cloud native environments—for example, Kubernetes
    clusters.
  prefs: []
  type: TYPE_NORMAL
- en: A GitOps tool can help you to automate the CD process for your Kubernetes applications.
    Tools such as Argo CD or Flux can help you to implement GitOps for your applications.
  prefs: []
  type: TYPE_NORMAL
- en: But in this chapter, we are going to focus more on applications that run in
    low-resource environments using ARM processors. In this case, Flux has support
    for ARM while Argo CD doesn’t. This chapter focuses on implementing GitOps with
    Flux using ARM devices. So, let’s get started with a brief introduction to Flux
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Flux and its architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Flux website, [https://fluxcd.io](https://fluxcd.io), says: “*Flux is a
    set of continuous and progressive delivery solutions for Kubernetes that are open
    and extensible*.” Flux gives you the ability to have your Kubernetes clusters
    in sync with the source that contains declarative definitions of your applications,
    commonly stored in Git repositories.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flux also uses the Kubernetes API to manage its objects. It also uses its own
    GitOps Toolkit, which gives you the tools to build a CD system on top of Kubernetes.
    You can see how Flux works in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Flux architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_07_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Flux architecture
  prefs: []
  type: TYPE_NORMAL
- en: This diagram reflects a typical workflow for GitOps, starting with a commit
    and a GitOps tool that is constantly checking for changes in the application’s
    definitions—in this case, YAML files. When Flux detects this change, it automatically
    provisions for the reconciliation of your applications, based on declarative definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To bring essential functionalities to GitOps, Flux provides the following main
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: Support for Git repositories of multiple providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported integrations for tools such as Kustomize and Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-triggered and periodic reconciliation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with Kubernetes **role-based access control** (**RBAC**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alerting external systems (webhook senders)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External events handling (webhook receivers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated container image updates to Git (image scanning and patching)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a GitOps tool for Kubernetes, Flux could be installed on ARM devices. In
    this way, Flux could be a good match for edge computing. But first, let’s look
    at how Flux matches edge computing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flux matches edge computing requirements for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Has less complexity for GitOps compared with tools such as Argo CD, Tekton,
    and others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be installed on ARM devices for low-resource environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires low resource consumption to operate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is how Flux works and how it matches edge computing requirements. Now,
    let’s see how we are going to organize our applications to implement GitOps for
    the edge using Flux in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Designing GitOps with Flux for edge applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to implement GitOps for edge computing with Flux, but first, we
    have to explain the whole workflow and the main parts of this implementation.
    For this, let’s explore the following diagram, which explains the components and
    workflow of GitOps, implementing an image automation updater for your applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Flux GitOps implementation using image updater feature](img/B16945_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Flux GitOps implementation using image updater feature
  prefs: []
  type: TYPE_NORMAL
- en: 'Our GitOps workflow implementation has the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A developer changes the application and submits changes with a PR to be merged
    into the main branch. You could make changes and push them directly to the main
    branch, but this is not a good practice since you may have submitted broken or
    unreviewed changes. In later examples of this chapter, we use GitHub to host our
    Git repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The repository has activated GitHub Actions and triggered a small pipeline just
    to build an image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An image is built in the pipeline and tagged with a new version, then it is
    pushed to the public Docker registry. In most business scenarios, you have to
    use private repositories in the cloud or on-premises.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image updater feature checks for new changes and tags for previous newly
    generated images that your application is going to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once Flux detects the new image, it looks for files configured to be updated
    with the new image tag. Once Flux updates the files’ definitions with the new
    tag, the changes are pushed to the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flux detects changes in the definition of files that were updated with the new
    image tag. Then, Flux triggers a reconciliation process to update your applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Objects in the Kubernetes cluster associated with the definition files are updated.
    Then, your application will run with the new image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To implement the GitOps workflow just described, we are assuming the next networking
    and GitHub configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: Single node K3s clusters using the `192.168.0.0/24` network so that they can
    access the same network. You can use a different private network such as the `172.16.0.0/16`
    or `10.0.0.0/8` networks, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each cluster is using MetalLB as the bare metal load balancer service, using
    different IP ranges for load balancing. Cluster 1 is using IP addresses in the
    range of `192.168.0.51-60`, cluster 2 is using `192.168.0.61-70`, and cluster
    3 is using `192.168.0.71-80` to do some basic IP address distribution for this
    network. The first addresses are typically used by the default load balancer of
    Traefik, so this IP address could be different in your network. Take a look at
    [*Chapter 5*](B16945_05_Final_PG.xhtml#_idTextAnchor097), *K3s Homelab for Edge
    Computing Experiments*, to configure MetalLB using the same or similar IP ranges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You have a GitHub account and a token to access or create repositories in your
    account. Here’s what we’re doing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using the https://github.com/sergioarmgpl/fluxappdemo GitHub repository,
    which contains a basic Helm chart to deploy in our clusters. You can find more
    details about the application in the repository link.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, we are ready to start implementing this scenario in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple monorepo for GitOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our GitOps implementation, we are going to use a monorepo. We have chosen
    to do this to reduce the management of many repositories and centralize all work
    in a single repository. For this use case, we are going to organize our cluster
    configurations and applications’ definitions in a single repository. Let’s explore
    the following screenshot to understand how our new repository will be organized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Monorepo structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_07_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Monorepo structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s describe what each directory and file does, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clusters`: This is the main directory that contains all the configuration
    of Flux and deployments in separated directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cluster1`-`cluster3`: Inside these folders, the definitions of Flux and your
    applications are organized. `cluster1` will be the cluster in charge of updating
    YAML definitions for the application for all clusters. So, `cluster2` and `cluster3`
    don’t need the image updater components in their installations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flux-system`: Contains Flux definitions to deploy it. Includes the `gotk-components.yaml`,
    `gotk-sync.yaml`, and `kustomization.yaml` files, which configure different components
    to implement our image updater GitOps workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manifests`: Contains the necessary definitions to deploy your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`namespace.yaml`: Creates a production namespace for your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`helm-charts.yaml`: A definition to access your Helm chart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`helm-release.yaml`: Includes a definition and values to deploy your application
    using the Helm chart defined in `helm-charts.yaml`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app-demo-registry.yaml`: Contains an image to scan on Docker Hub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app-demo-policy.yaml`: Contains an expression to check inside files where
    you want to update the container image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flux-system-automation.yaml`: Looks for a folder to update changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This repository is designed for your applications. It is a monorepo for a production
    environment with different clusters. You can do more complex configurations using
    Kustomize, but that is out of the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also find some approaches to how to organize your repositories on the
    Flux website. For more information, check out the following link: [https://fluxcd.io/docs/guides/repository-structure](https://fluxcd.io/docs/guides/repository-structure).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to see the workflow that we are going to implement in our GitOps
    use case for edge computing.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the application and GitHub Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start implementing GitOps with Flux, we have to set a small pipeline that
    creates a container image every time we modify the source code of our application.
    To simplify our work, this configuration will be based on the [https://github.com/sergioarmgpl/fluxappdemo](https://github.com/sergioarmgpl/fluxappdemo)
    repository, which contains a simple Python application using Flask. This application
    has two directories: `src` and `.github/workflows`. The `src` directory contains
    the source of the application, while the `workflows` folder has the GitHub Actions
    configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s first explore the `src` directory. You can see an overview of the
    repository in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – fluxappdemo repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_07_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – fluxappdemo repository
  prefs: []
  type: TYPE_NORMAL
- en: 'The `src` directory contains the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dockerfile`: This has the configuration to build a Docker image; it also calls
    a small unit test included in `tests.py`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Operations.py`: This has a class called `Operations` that contains a `runningInfo`
    method. This function receives two parameters: `msg1` and `msg2`. With these parameters,
    it returns the following message: `Running app <msg1> in namespace <msg2>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build_push.sh`: This is a sample script to build an image manually. It receives
    two parameters; the first one is your Docker username and the second is a tag
    for the image. You can run it as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`index.py`: This is the main Python file to run our application. It has a function
    called `hello_world` that gets the `MESSAGE` and `NAMESPACE` environment variables
    and then calls the `runningInfo` function to return the following message: `Running
    app <MESSAGE> in namespace <NAMESPACE>`. So, every time you call the application
    in `route /` and port `5000`, it will show the message, then `route /_health return
    Running message, /_version a custom message`. You could use this route to explore
    the application. To take a look at the code, check out the following link: [https://github.com/sergioarmgpl/fluxappdemo/blob/main/src/index.py](https://github.com/sergioarmgpl/fluxappdemo/blob/main/src/index.py).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requirements.txt`: Includes all the necessary libraries to run the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tests.py`: This file includes a small test for the `runningInfo` function
    inside the `Operations` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see an overview of the `src` directory in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – src directory with source code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_07_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – src directory with source code
  prefs: []
  type: TYPE_NORMAL
- en: '`.github/workflows` contains a `github-actions-fluxappdemo.yml` file. This
    file contains a CI pipeline definition that builds and pushes your container ARM
    image using the following name and tag format: `<DOCKER_USER>/fluxappdemo:RELEASE.YEAR-MONTH-DAYT-HOUR-MINUTE-SECONDZ`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`DOCKER_USER` is your Docker username.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this file in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – GitHub Actions workflows file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_07_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – GitHub Actions workflows file
  prefs: []
  type: TYPE_NORMAL
- en: With this brief explanation, let’s move on to configure your own pipeline to
    build and push your container image.
  prefs: []
  type: TYPE_NORMAL
- en: Building your container image with GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build and push your image with GitHub Actions, you should follow the given
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Fork the [https://github.com/sergioarmgpl/fluxappdemo](https://github.com/sergioarmgpl/fluxappdemo)
    repository. This is going to create a repository named `https://github.com/<GITHUB_USER>/fluxappdemo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GITHUB_USER` is the username of your GitHub account. Replace it with your
    own username.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `DOCKERHUB_USERNAME` and `DOCKERHUB_TOKEN` secrets for your repository.
    These will be created as encrypted secrets for a repository. To create the secrets,
    open the following page in the browser: `https://github.com/<GITHUB_USER>/fluxappdemo/settings/secrets/actions`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After adding the variables, your repository will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – GitHub repository secrets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_07_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – GitHub repository secrets
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `.github/workflows/github-actions-fluxappdemo.yml` file in the last
    line in the `tags` section with your user. It will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `DOCKER_USER` is your Docker Hub username.
  prefs: []
  type: TYPE_NORMAL
- en: Commit and push the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '(*Optional*) To check whether your GitHub action is running, you can check
    out the following link: `https://github.com/<GITHUB_USER>/fluxappdemo/actions`.
    The following screenshot provides an example of how this should look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.9 – GitHub Actions showing current workflows'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_07_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – GitHub Actions showing current workflows
  prefs: []
  type: TYPE_NORMAL
- en: '(*Optional*) To check new container tags created for your account, check out
    the following link: `https://hub.docker.com/repository/docker/<DOCKERHUB_USERNAME>/fluxappdemo/tags`.
    The following screenshot provides an example of how this should look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Docker Hub tags for a repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_07_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – Docker Hub tags for a repository
  prefs: []
  type: TYPE_NORMAL
- en: (*Optional*) To test whether your GitHub Actions pipeline works, modify the
    source code of the application inside the `src` directory and commit and push
    the changes. Then, a new workflow will be running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about creating encrypted secrets for a repository, check
    out the following link: [https://docs.github.com/en/actions/security-guides/encrypted-secrets](https://docs.github.com/en/actions/security-guides/encrypted-secrets).
    To create a token to access your Docker Hub account to push new images, check
    out this link: [https://docs.docker.com/docker-hub/access-tokens](https://docs.docker.com/docker-hub/access-tokens).
    Finally, to fork a repository, check out the following link: [https://docs.github.com/en/get-started/quickstart/fork-a-repo](https://docs.github.com/en/get-started/quickstart/fork-a-repo).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have configured a GitHub Actions pipeline to automate the creation
    of a container image with its tags, it’s time to start configuring Flux to complete
    our GitOps workflow in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Flux for GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before configuring Flux, let’s understand what we are going to install in this
    section. In this section, we are going to install Flux and its components that
    detect new image tags for your container. Once new images are detected, Flux modifies
    the `HelmRelease` definition file inside your deployment repository. Then, Flux
    will automatically reconcile changes, updating the application deployment defined
    in this `HelmRelease` file that is using the Helm chart published at [https://sergiops.xyz/helm-charts](https://sergiops.xyz/helm-charts).
    Together with the GitHub Actions workflow defined in the *Building your container
    image with GitHub Actions* section, the complete workflow is going to work like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: The user pushes changes from its local repository copy to the original source
    code repository located at `https://github.com/<GITHUB_USER>/fluxappdemo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GitHub Actions builds and pushes the image to Docker Hub at `https://hub.docker.com/repository/docker/<DOCKER_USER>/fluxappdemo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flux detects the new tag generated when the image was updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flux replaces the `HelmRelease` definition with the new tag. For this, Flux
    modifies, commits, and pushes the changes to the repository with your deployment
    definitions at `https://github.com/<GITHUB_USER>/fluxdemo-production.git`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flux reconciles the changes, and the application is updated with the new image
    tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `<GITHUB_USER>` and `<DOCKER_USER>` values have to be replaced with your
    GitHub and Docker users.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start building this use case scenario with Flux, you have to install the
    Flux **CLI**. Here’s how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the Flux CLI on Linux, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or, if you have macOS, you can install Flux with Homebrew using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: You can check for alternative installation at the official website, [https://fluxcd.io](https://fluxcd.io).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you have to install the Flux image updater feature, necessary to automate
    the CD process every time that a new image tag is detected. To install Flux and
    all necessary components, follow the given steps on each cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set your environment variables; in this case, we need to set our GitHub user
    and the token of our GitHub account, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to create a token for your GitHub account: [https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s set the email address and username associated with your GitHub account.
    For this, run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, install Flux and all the necessary components for image updater implementation.
    For this, run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `repository` parameter is the name of the GitHub repository to create— for
    example, `fluxdemo-production`.
  prefs: []
  type: TYPE_NORMAL
- en: '`CLUSTER_N` is an environment variable with the number of the cluster where
    you are installing Flux—for example, `CLUSTER_1`. The YAML files used to install
    Flux will be stored inside the `clusters/production/<CLUSTER_N>` directory.'
  prefs: []
  type: TYPE_NORMAL
- en: The process will show the message **waiting for Kustomization “flux-system/flux-system”
    to be reconciled**. Once Flux is installed, you will see the message **all components
    are healthy**.
  prefs: []
  type: TYPE_NORMAL
- en: This command is going to create a repository with your user account. The link
    to access this repository will be `https://github.com/<GITHUB_USER>/fluxdemo-production.git`.
  prefs: []
  type: TYPE_NORMAL
- en: '`GITHUB_USER` is the name of your GitHub username. Replace this value in the
    link with your own.'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Omit the `--components-extra=image-reflector-controller,image-automation-controller`
    line for `cluster2` and `cluster3`. `cluster1` is in charge of updating the application
    definitions for all clusters. Also refer to the help for this command by running
    `flux bootstrap github --help` for more options, especially if you are using an
    organization or enterprise or another versioning tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the new repository and change it into this directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is going to ask you to enter your username and password to clone your
    repository. This will be used in the next steps to customize and create deployment
    definitions. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a namespace for your application inside a directory called `clusters/<clusterN>/manifests`.
    For this, run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a Helm chart source Flux object to point to your own Helm chart, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using a Helm chart with a sample application in [https://sergiops.xyz/helm-charts](https://sergiops.xyz/helm-charts).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Flux `HelmRelease` object to create a YAML definition for your application
    deployment, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add a section called `values` to the file by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to the commented line `# {"$imagepolicy": "flux-system:app-demo"}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This part tells Flux to find where to replace the image with the new tag. Finally,
    the file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This `HelmRelease` object provided with the Flux installation provides a declarative
    way to parametrize a deployment. In this case, the values inside the `values`
    section correspond to the different parameters that you can send to our Helm chart.
    The creation of Helm charts is out of the scope of this book, but you can find
    good resources at the end of the chapter in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can check the repository at [https://github.com/sergioarmgpl/fluxdemo-production](https://github.com/sergioarmgpl/fluxdemo-production)
    to see the final results of creating and modifying configuration files for your
    demo application with the previous commands.
  prefs: []
  type: TYPE_NORMAL
- en: This `HelmRelease` object is stored in a file and is the object that you need
    to modify, commit, and push your changes to your repository. After this, Flux
    detects the changes and updates your application. This file is inside of your
    repository in the `clusters/cluster$CLUSTER_N/manifests/helm-release.yaml` path.
    In this way, you can test how Flux updates your application, where the `CLUSTER_N`
    variable is the cluster number that you are modifying.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create your own Helm chart repository, you can check out [https://helm.sh/docs/topics/chart_repository](https://helm.sh/docs/topics/chart_repository)
    and go to the *GitHub Pages e*[*xample* section. In this example,](https://sergiops.xyz/helm-charts)
    we are using the charts located at [https://sergiops.xyz/helm-charts](https://sergiops.xyz/helm-charts)
    and [https://github.com/sergioarmgpl/helm-charts/tree/gh-pages](https://github.com/sergioarmgpl/helm-charts/tree/gh-pages).
    You can check or clone this repository to create your own.
  prefs: []
  type: TYPE_NORMAL
- en: '*You can omit Steps 11-13 if you are configuring cluster2 and cluster3 because
    cluster1 will be in charge of updating all the deployments’ definitions.*'
  prefs: []
  type: TYPE_NORMAL
- en: '(*Optional*) Create an image repository to detect new releases or tags for
    your image, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '(*Optional*) Create an image policy to define an expression to match to detect
    new image tags or releases from your image registry. This use case is going to
    use the following format to tag the new Docker images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RELEASE.YEAR-MONTH-DAYT-HOUR-MINUTE-SECONDZ`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This convention is based on RFC3339 and ISO 7601, which refers to the standards
    for date and time on the internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '(*Optional*) Now, it’s time to put all the pieces together. For this, you have
    to create an `ImageUpdateAutomation` object, which is going to detect new releases
    and update the images in your deployments’ YAML definitions. In the following
    case, it’s going to check the folder clusters to update all the YAML definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have to change the `<AUTHOR_NAME>` and `<AUTHOR_EMAIL>` tags with your own
    values. This will appear as the commit author when Flux pushes changes for image
    tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Commit and push the changes to the repository with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `push` command is going to ask you for the user and the token that you previously
    created, to access your GitHub account.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can build a new image, and you can wait for Flux to automatically update
    your `HelmRelease` file with the new image detected. After 1 minute or more, you
    can expect the change to have been made. You will expect to see a commit in your
    repository made by Flux with the new tag detected, to troubleshoot whether the
    image updater is working.
  prefs: []
  type: TYPE_NORMAL
- en: '(*Optional*) You can force Flux to apply this configuration by running the
    Flux reconciliation process with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Helm chart is going to provision a `LoadBalancer` service type. To find
    the provisioned IP address, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, the `IP_LOADBALANCER` variable contains the IP of the load balancer created
    by the `HelmRelease` definition, which is the endpoint for your application in
    this cluster. You can check the value by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Using *Figure 7.4* as a reference, you will expect to see an IP address such
    as `192.168.0.52`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that, for example, the returned IP is `192.168.0.52`. You can access
    your application with the following URL: `http://192.168.0.52:5000`. You can test
    to access other routes—for example, `/_version` or `/_health`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you have installed Flux, you can start testing the auto-reconciliation
    to update your files by committing and pushing the changes of your `HelmRelease`
    files. The auto-reconciliation updates everything Flux detects in new image tags
    of your applications. This process is described in the previous section, *Designing
    GitOps with Flux for edge applications*. After this, you can continue with the
    next section to learn how to troubleshoot your installation.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting Flux installations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few useful commands that can help you to troubleshoot your installation;
    in this section, we’re going to find out what these are. So, let’s proceed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To reconcile Flux changes in Flux, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command is going to show new tags detected for your container, and how
    these new tags are set up in your `HelmRelease` YAML definition file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the image repositories in Flux, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check the current policy in your cluster, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get all images configured in your Flux installation, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To reconcile YAML definition changes in your cluster, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To watch in real time how image detection and updates to your repositories
    are running, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check your application deployments, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check your Pods, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have now learned these essential commands to troubleshoot your Flux system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to explore Flux monitoring dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Flux monitoring dashboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flux itself doesn’t include a graphical user interface for management but integrates
    some useful dashboards using Prometheus and Grafana to visualize the state of
    your deployments. These dashboards have to be installed on each cluster. To install
    this feature, follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the Git repository that contains monitoring stack definitions for
    its installation. The configuration will listen for changes every 30 minutes.
    The code is illustrated here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install `kube-prometheus-stack`, which is going to be used to configure Prometheus
    for your dashboards. This stack will be installed in the `monitoring` namespace.
    The code is illustrated in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install Grafana and configure your Flux dashboards, storing data in Prometheus
    and visualizing this across preconfigured dashboards in Grafana. The code is illustrated
    in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the dashboards using the next command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is going to open port `3000` of your dashboard. Remember that the IP address
    that you have to access is the IP of the node where you are accessing this dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Access the dashboard using the following URL: `http://<NODE_IP_ADDRESS>:3000/d/flux-control-plane`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`NODE_IP_ADDRESS` is the IP address cluster node where you are running the
    command shown in this step.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the dashboard, use the next credentials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Username: `admin`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Password: `prom-operator`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The login screen will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Grafana login form'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_07_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – Grafana login form
  prefs: []
  type: TYPE_NORMAL
- en: Once you are logged in, you will be redirected to the dashboard URL previously
    mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the dashboard is opened, it will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Grafana Flux control plane dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_07_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – Grafana Flux control plane dashboard
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that you can customize this dashboard and create your own dashboards.
    For more information about this dashboard, you can visit the following link: [https://fluxcd.io/docs/guides/monitoring](https://fluxcd.io/docs/guides/monitoring).'
  prefs: []
  type: TYPE_NORMAL
- en: Your Grafana dashboards are now installed successfully, and you can see the
    state of your deployments. Now, it’s time to learn how to uninstall Flux in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Uninstalling Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you don’t need the Flux installation anymore, you can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is going to uninstall Flux from your Kubernetes cluster. Now, it’s time
    to finish the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how GitOps works and how you can implement GitOps
    using GitHub Actions and Flux. Flux could be useful to automate your deployments
    on an edge environment, using a single Git repository. For this, we learned how
    Flux can implement GitOps to update your applications at the edge using the HelmRelease
    object and the image updater feature. Flux can manage your application cluster
    without using an external way to expose the Kubernetes API of your cluster, which
    is the case with tools such as Argo CD. This can be translated into cost savings
    and a more effective tool for edge environments using ARM devices. Argo CD, on
    the other hand, doesn’t support ARM and needs a way to expose your Kubernetes
    API from your cluster to connect the cluster to Argo CD using a public load balancer
    or a virtual machine on the internet. In the next chapter, we are going to learn
    how to add basic observability and traffic splitting to your applications using
    Linkerd.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few questions to validate your new knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: How can GitHub Actions help me to implement GitOps at the edge?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I implement GitOps using Flux?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which other features does Flux have that can help me to implement GitOps?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I troubleshoot my Helm releases with Flux?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I apply this simple use case in my edge computing scenarios?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I structure my repositories for GitOps?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following references for more information on the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*What is GitOps?*: [https://www.gitops.tech](https://www.gitops.tech)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dev Leaders Compare Continuous Delivery vs Continuous Deployment vs Continuous
    Integration*: [https://stackify.com/continuous-delivery-vs-continuous-deployment-vs-continuous-integration](https://stackify.com/continuous-delivery-vs-continuous-deployment-vs-continuous-integration)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quickstart on using GitHub: [https://docs.github.com/en/get-started/quickstart](https://docs.github.com/en/get-started/quickstart)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub Actions to build container images: [https://github.com/docker/build-push-action](https://github.com/docker/build-push-action)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Hub: [https://hub.docker.com](https://hub.docker.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating secrets on GitHub Actions: [https://docs.github.com/en/actions/security-guides/encrypted-secrets](https://docs.github.com/en/actions/security-guides/encrypted-secrets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Date and time internet standard: [https://datatracker.ietf.org/doc/html/rfc3339](https://datatracker.ietf.org/doc/html/rfc3339)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating a public Helm chart with GitHub Pages: [https://medium.com/@mattiaperi/create-a-public-helm-chart-repository-with-github-pages-49b180dbb417](mailto:https://medium.com/@mattiaperi/create-a-public-helm-chart-repository-with-github-pages-49b180dbb417)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating a Helm chart repository: [https://harness.io/blog/helm-chart-repo](https://harness.io/blog/helm-chart-repo
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to structure your Flux repositories: [https://fluxcd.io/docs/guides/repository-structure](https://fluxcd.io/docs/guides/repository-structure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Flux Documentation*: [https://fluxcd.io/docs](https://fluxcd.io/docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flux Helm releases: [https://fluxcd.io/docs/guides/helmreleases](https://fluxcd.io/docs/guides/helmreleases)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flux, Kustomize, and Helm example: [https://github.com/fluxcd/flux2-kustomize-helm-example](https://github.com/fluxcd/flux2-kustomize-helm-example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
