- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Docker and Container Essentials
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 和容器基础
- en: '**Containers** have become an incredibly popular and influential technology
    that brings significant changes from legacy applications. Everyone, from tech
    companies to big corporations and end users, not has widely embraced containers
    to handle their day-to-day tasks. It’s worth noting that the conventional method
    of installing ready-made commercial applications is gradually transforming into
    fully containerized setups. Considering the sheer magnitude of this technological
    shift, it becomes essential for people working in the field of information technology
    to gain knowledge and understand the concept of containers.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器**已经成为一项极受欢迎且具有重大影响的技术，给传统应用带来了显著变化。从科技公司到大型企业再到终端用户，每个人都广泛采用容器来处理日常任务。值得注意的是，传统的安装现成商业应用的方法正逐渐转变为完全容器化的配置。考虑到这一技术变革的巨大规模，信息技术领域的从业者必须掌握并理解容器的概念。'
- en: This chapter will provide an overview of the issues that containers aim to solve.
    We will begin by highlighting the significance of containers. Then, we will introduce
    **Docker**, the runtime that played a pivotal role in the rise of containerization,
    and discuss its relationship with **Kubernetes**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将概述容器旨在解决的问题。我们将从强调容器的重要性开始。然后，我们将介绍 **Docker**，这一在容器化兴起过程中发挥了关键作用的运行时，并讨论它与
    **Kubernetes** 的关系。
- en: 'This chapter intends to provide you with an understanding of running containers
    in Docker. One common question you may have heard is: “What is the relationship
    of Docker to Kubernetes?” Well, in today’s world, Docker is not tied to Kubernetes
    at all – you do not need Docker to run Kubernetes and you don’t need it to create
    containers. We are discussing Docker in this chapter to provide you with the skills
    to run containers locally and test your images before you deploy them to a Kubernetes
    cluster.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在帮助你理解如何在 Docker 中运行容器。你可能听过一个常见问题：“Docker 和 Kubernetes 之间有什么关系？”好吧，在今天的世界里，Docker
    完全与 Kubernetes 无关——你不需要 Docker 来运行 Kubernetes，也不需要它来创建容器。本章讨论 Docker，旨在提供让你在本地运行容器并在部署到
    Kubernetes 集群之前测试镜像的技能。
- en: By the end of this chapter, you will have a clear understanding of how to install
    Docker and how to effectively utilize the commonly used **Docker command-line
    interface** (**CLI**) commands.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将清楚地理解如何安装 Docker，以及如何有效使用常用的 **Docker 命令行界面**（**CLI**）命令。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Understanding the need for containerization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解容器化的需求
- en: Understanding why Kubernetes removed Docker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么 Kubernetes 移除了 Docker
- en: Understanding Docker
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Docker
- en: Installing Docker
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: Using the Docker CLI
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker CLI
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有以下技术要求：
- en: An Ubuntu 22.04+ server running Docker with a minimum of 4 GB of RAM, though
    8 GB is suggested.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行 Docker 的 Ubuntu 22.04+ 服务器，至少 4 GB 的内存，建议 8 GB。
- en: 'Scripts from the `chapter1` folder from the repository, which you can access
    by using this link: [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自仓库 `chapter1` 文件夹的脚本，你可以通过以下链接访问：[https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition)
- en: Understanding the need for containerization
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解容器化的需求
- en: 'You may have experienced a conversation like this at your office or school:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在办公室或学校经历过这样的对话：
- en: '**Developer**: “*Here’s the new application. It went through weeks of testing
    and you are the first to get the new release.*”'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发者**：“*这是新应用程序。它经过了几周的测试，你是第一个获得新版本的人。*”'
- en: ….. A little while later …..
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ….. 一会儿后 …..
- en: '**User**: “*It’s not working. When I click the submit button, it shows an error
    about a missing dependency*.”'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户**：“*它不工作。当我点击提交按钮时，显示一个关于缺少依赖项的错误。*”'
- en: '**Developer**: “*That’s weird; it’s working fine on my machine.*”'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发者**：“*这很奇怪，它在我的机器上运行得很好。*”'
- en: Encountering such issues can be incredibly frustrating for developers when they’re
    deploying an application. Oftentimes, these problems occur due to a missing library
    in the final package that the developer had on their own machine. One might think
    that a simple solution would be to include all the libraries in the release, but
    what if this release includes a newer version of a library that replaces an older
    version, which another application may still rely on?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署应用程序时，遇到此类问题可能会让开发人员感到非常沮丧。这些问题通常是由于最终包中缺少开发人员自己机器上有的某个库所致。有人可能认为一个简单的解决方法是将所有库都包含在发布包中，但如果这个发布包中包含了一个更新版本的库，而这个版本替换了一个较旧版本的库，而另一个应用程序仍依赖于该旧版本的库呢？
- en: Developers have to carefully consider their new releases and the potential conflicts
    they may cause with existing software on users’ workstations. It becomes a delicate
    balancing act that often requires larger deployment teams to thoroughly test the
    application on various system configurations. This situation can result in additional
    work for the developer or, in extreme cases, render the application completely
    incompatible with an existing one.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员必须仔细考虑他们的新版本及其可能与用户工作站上现有软件产生的冲突。这变成了一个微妙的平衡行为，通常需要更大的部署团队在各种系统配置上彻底测试应用程序。这种情况可能导致开发人员增加额外的工作，或者在极端情况下，使应用程序与现有应用程序完全不兼容。
- en: Over the years, there have been several attempts to simplify application delivery.
    One solution is VMware’s **ThinApp**, which aims to virtualize an application
    (not to be confused with virtualizing the entire operating system (OS)). It allows
    you to bundle the application and its dependencies into a single executable package.
    By doing so, all the application’s dependencies are contained within the package,
    eliminating conflicts with other application dependencies. This not only ensures
    application isolation but also enhances security and reduces the complexities
    of OS migrations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，已经有几个尝试简化应用程序交付的方案。一种解决方案是VMware的**ThinApp**，其目的是虚拟化一个应用程序（不要与虚拟化整个操作系统（OS）混淆）。它允许你将应用程序及其依赖项打包成一个可执行文件。这样，所有应用程序的依赖项都包含在包内，消除了与其他应用程序依赖项的冲突。这不仅确保了应用程序的隔离性，还增强了安全性并减少了操作系统迁移的复杂性。
- en: You might not have come across terms like application packaging or application-on-a-stick
    until now, but it seems like a great solution to the infamous “it worked on my
    machine” problem. However, there are reasons why it hasn’t gained widespread adoption
    as anticipated. Firstly, most solutions in this space are paid offerings that
    require a significant investment. Additionally, they require a “clean PC,” meaning
    that for each application you want to virtualize, you need to start with a fresh
    system. The package you create captures the differences between the base installation
    and any changes made afterward. These differences are then packaged into a distribution
    file, which can be executed on any workstation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能直到现在才接触到诸如应用程序打包或“随身应用”之类的术语，但它似乎是解决臭名昭著的“在我的机器上能运行”问题的一个不错的解决方案。然而，这种方法未能如预期那样广泛采用，也有其原因。首先，这个领域的大多数解决方案都是收费的，需要进行大量的投资。此外，它们需要一个“干净的PC”，也就是说，每次想要虚拟化一个应用程序时，必须从一个全新的系统开始。你创建的包会捕捉基础安装和后续更改之间的差异。这些差异随后会被打包成一个分发文件，可以在任何工作站上执行。
- en: We’ve mentioned application virtualization to highlight that application issues
    such as “it works on my machine” have had different solutions over the years.
    Products such as **ThinApp** are just one attempt at solving the problem. Other
    attempts include running the application on a server using **Citrix**, **Remote
    Desktop**, **Linux containers**, **chroot jails**, and even **virtual machines**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到应用程序虚拟化，是为了突出“在我的机器上能运行”之类的应用程序问题近年来有过不同的解决方案。像**ThinApp**这样的产品只是其中一种尝试。其他尝试还包括使用**Citrix**、**远程桌面**、**Linux容器**、**chroot监狱**，甚至是**虚拟机**来运行应用程序。
- en: Understanding why Kubernetes removed Docker
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解为什么Kubernetes移除了Docker
- en: Kubernetes removed all support for Docker in version 1.24 as a supported container
    runtime. While it has been removed as a runtime engine option, you can create
    new containers using Docker and they will run on any runtime that supports the
    **Open Container Initiative** (**OCI**) specification. OCI is a set of standards
    for containers and their runtimes. These standards ensure that containers remain
    portable, regardless of the container platform or the runtime used to execute
    them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 在版本 1.24 中移除了对 Docker 作为支持的容器运行时的所有支持。虽然它已被移除作为运行时引擎选项，但你仍然可以使用 Docker
    创建新的容器，它们将能够在任何支持 **开放容器倡议**（**OCI**）规范的运行时上运行。OCI 是一套关于容器及其运行时的标准，这些标准确保了容器的可移植性，无论容器平台或执行它们的运行时是什么。
- en: When you create a container using Docker, you are creating a container that
    is fully OCI compliant, so it will still run on Kubernetes clusters that are running
    any Kubernetes-compatible container runtime.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Docker 创建容器时，你实际上是在创建一个完全符合 **开放容器规范**（**OCI**）的容器，因此它仍然可以在运行任何与 Kubernetes
    兼容的容器运行时的 Kubernetes 集群上运行。
- en: To fully explain the impact and the supported alternatives, we need to understand
    what a container runtime is. A high-level definition would be that a container
    runtime is the software layer that runs and manages containers. Like many components
    that make up a Kubernetes cluster, the runtime is not included as part of Kubernetes
    – it is a pluggable module that needs to be supplied by a vendor, or by you, to
    create a functioning cluster.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了全面解释影响及其支持的替代方案，我们需要了解什么是容器运行时。一个高级定义是，容器运行时是运行和管理容器的软件层。像 Kubernetes 集群中的许多组件一样，运行时并不包含在
    Kubernetes 中——它是一个可插拔模块，需要由供应商或你自己提供，以创建一个功能正常的集群。
- en: 'There are many technical reasons that led to the decision to deprecate and
    remove Docker, but at a high level, the main concerns were as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多技术原因导致了弃用和移除 Docker 的决定，但从高层次来看，主要的担忧如下：
- en: Docker contains multiple pieces inside of the Docker runtime to support its
    own remote API and **user experience** (**UX**). Kubernetes only requires one
    component in the executable, dockerd, which is the runtime process that manages
    containers. All other pieces of the executable contribute nothing to using Docker
    in a Kubernetes cluster. These extra components make the binary bloated and can
    lead to additional bugs, security, or performance issues.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 在 Docker 运行时内部包含多个组件，用于支持其自己的远程 API 和 **用户体验**（**UX**）。而 Kubernetes 只需要可执行文件中的一个组件，dockerd，它是管理容器的运行时进程。可执行文件中的所有其他组件对在
    Kubernetes 集群中使用 Docker 没有任何贡献。这些额外的组件使得二进制文件臃肿，并可能导致额外的漏洞、安全性或性能问题。
- en: Docker does not conform to the **Container Runtime Interface** (**CRI**) standard,
    which was introduced to create a set of standards to easily integrate container
    runtimes in Kubernetes. Since it doesn’t comply, the Kubernetes team has had extra
    work that only caters to supporting Docker.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 不符合 **容器运行时接口**（**CRI**）标准，后者的引入旨在创建一套标准，以便在 Kubernetes 中轻松集成容器运行时。由于
    Docker 不符合该标准，Kubernetes 团队不得不额外做很多工作，仅仅是为了支持 Docker。
- en: When it comes to local container testing and development, you can still use
    Docker on your workstation or server. Considering the previous statement, if you
    build a container on Docker and the container successfully runs on your Docker
    runtime system, it will run on a Kubernetes cluster that does not use Docker as
    the runtime.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地容器测试和开发时，你仍然可以在工作站或服务器上使用 Docker。考虑到之前的陈述，如果你在 Docker 上构建一个容器，并且该容器能够在 Docker
    运行时系统上成功运行，那么它也能在不使用 Docker 作为运行时的 Kubernetes 集群上运行。
- en: Removing Docker will have very little impact on most users of Kubernetes in
    new clusters. Containers will still run using any standard method, as they would
    with Docker as the container runtime. If you happen to manage a cluster, you may
    need to learn new commands when you troubleshoot a Kubernetes node – you will
    not have a Docker command on the node to look at running containers, clean up
    volumes, and so on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 移除 Docker 对大多数新集群中的 Kubernetes 用户影响很小。容器将仍然以任何标准方式运行，就像 Docker 作为容器运行时时一样。如果你恰好管理一个集群，在排查
    Kubernetes 节点问题时，你可能需要学习新的命令——因为节点上将没有 Docker 命令来查看正在运行的容器、清理卷等。
- en: 'Kubernetes supports a number of runtimes in place of Docker. Two of the most
    commonly used runtimes are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 支持多种替代 Docker 的运行时。以下是两个最常用的运行时：
- en: containerd
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: containerd
- en: CRI-O
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CRI-O
- en: While these are the two commonly used runtimes, there are a number of other
    compatible runtimes available. You can always view the latest supported runtimes
    on the Kubernetes GitHub page at [https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两种是常用的运行时，但也有许多其他兼容的运行时可用。你可以随时在 Kubernetes 的 GitHub 页面查看最新支持的运行时，网址是 [https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md)。
- en: 'For more details on the impact of deprecating and removing Docker, refer to
    the article called *Don’t Panic: Kubernetes and Docker* on the Kubernetes.io site
    at [https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/](https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '关于弃用和移除 Docker 的影响的更多细节，请参考 Kubernetes.io 网站上的文章 *Don’t Panic: Kubernetes and
    Docker*，网址是 [https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/](https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/)。'
- en: Introducing Docker
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入 Docker
- en: Both the industry and end users were seeking a solution that was both convenient
    and affordable, and this is where **Docker** containers came in. While containers
    have been utilized in different ways over time, Docker has brought about a transformation
    by providing a runtime and tools for everyday users and developers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是行业还是最终用户，都在寻求一个既方便又实惠的解决方案，这就是**Docker**容器的出现。虽然容器在不同的时间以不同方式被使用，但 Docker
    通过为普通用户和开发者提供运行时和工具，带来了变革。
- en: Docker brought an abstraction layer to the masses. It was easy to use and didn’t
    require a clean PC for every application before creating a package, thus offering
    a solution for dependency issues, but most attractive of all, it was free. Docker
    became a standard for many projects on GitHub, where teams would often create
    a Docker container and distribute the Docker image or Dockerfile to team members,
    providing a standard testing or development environment. This adoption by end
    users is what eventually brought Docker to the enterprise and, ultimately, what
    made it the standard it has become today.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 为大众带来了一个抽象层，它易于使用，不需要为每个应用程序创建包时都清理 PC，从而解决了依赖性问题，但最吸引人的一点是，它是免费的。Docker
    成为 GitHub 上许多项目的标准，团队通常会创建一个 Docker 容器，并将 Docker 镜像或 Dockerfile 分发给团队成员，提供标准的测试或开发环境。这种最终被最终用户接受的方式，促使
    Docker 进入企业，并最终使其成为今天的标准。
- en: Within the scope of this book, we will be focusing on what you will need to
    know when trying to use a local Kubernetes environment. Docker has a long and
    interesting history of how it evolved into the standard container image format
    that we use today. We encourage you to read about the company and how they ushered
    in the container world we know today.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的范围内，我们将重点关注在尝试使用本地 Kubernetes 环境时需要了解的内容。Docker 具有悠久而有趣的发展历史，如何演变成今天我们使用的标准容器镜像格式。我们鼓励你了解这家公司，以及他们如何引领我们今天所知道的容器世界。
- en: While our focus is not to teach Docker inside out, we feel that those of you
    who are new to Docker would benefit from a quick primer on general container concepts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的重点不是从头到尾教授 Docker，但我们认为对于那些 Docker 新手来说，快速了解一般容器概念会带来帮助。
- en: If you have some Docker experience and understand terminology such as ephemeral
    and stateless, you can jump to the *Installing Docker* section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些 Docker 经验，并且理解像是短暂（ephemeral）和无状态（stateless）这样的术语，你可以跳到*安装 Docker*部分。
- en: Docker versus Moby
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 与 Moby
- en: When the Docker runtime was developed, it was a single code base. The single
    code base contained every function that Docker offered, whether you have used
    them or not. This led to inefficiencies, and it started to hinder the progression
    of Docker and containers in general.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Docker 运行时被开发时，它是一个单一的代码库。这个单一的代码库包含了 Docker 提供的所有功能，无论你是否使用过它们。这导致了效率低下，并开始阻碍
    Docker 和容器的整体发展。
- en: The following table shows the differences between the Docker and Moby projects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了 Docker 和 Moby 项目的区别。
- en: '| **Feature** | **Docker** | **Moby** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **Docker** | **Moby** |'
- en: '| Development | The primary contributor is Docker, with some community support
    | It is open-source software with heavy community development and support |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 开发 | 主要贡献者是 Docker，并有一些社区支持 | 它是开源软件，拥有强大的社区开发和支持 |'
- en: '| Project scope | The complete platform that includes all components to build
    and run containers | It is a modular platform for building container-based components
    and solutions |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 项目范围 | 包括构建和运行容器所需的所有组件的完整平台 | 它是一个模块化平台，用于构建基于容器的组件和解决方案 |'
- en: '| Ownership | It is a branded product, offered by Docker, Inc. | It is an open-source
    project that is used to build various container solutions |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 所有权 | 这是一个由 Docker, Inc. 提供的品牌产品 | 它是一个开源项目，用于构建各种容器解决方案 |'
- en: '| Configuration | A full default configuration is included to make it easy
    for users to use it quickly | It has more available customizations, providing
    users with the ability to address their specific requirements |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 配置 | 包含完整的默认配置，使用户能够快速使用 | 提供更多可用的自定义选项，帮助用户满足特定需求 |'
- en: '| Commercial support | It offers full support, including enterprise support
    | It is offered as open-source software; there is no support direct from the Moby
    project |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 商业支持 | 提供完整支持，包括企业级支持 | 作为开源软件提供；Moby 项目不直接提供支持 |'
- en: 'Table 1.1: Docker versus Moby features'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 1.1：Docker 与 Moby 的功能对比
- en: To recap – **Moby** is a project that was started by Docker, but it is not the
    complete Docker runtime. The Docker runtime uses the components from Moby to create
    the Docker runtime, which includes the Moby open-source components and Docker’s
    own open-sourced components.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下——**Moby** 是一个由 Docker 启动的项目，但它不是完整的 Docker 运行时。Docker 运行时使用来自 Moby 的组件来创建
    Docker 运行时，其中包含 Moby 的开源组件和 Docker 自身的开源组件。
- en: Now, let’s move on to understanding Docker a little more and how you can use
    it to create and manage containers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更进一步了解 Docker，看看你如何使用它来创建和管理容器。
- en: Understanding Docker
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Docker
- en: This book assumes that you have a foundational understanding of Docker and container
    concepts. However, we know that not everyone will have prior experience with Docker
    or containers. Therefore, we have included this crash course to introduce you
    to container concepts and guide you through the usage of Docker.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设你已经具备了 Docker 和容器概念的基础理解。然而，我们知道并非每个人都拥有 Docker 或容器的使用经验。因此，我们在书中加入了这部分速成课程，旨在向你介绍容器概念，并指导你如何使用
    Docker。
- en: 'If you are new to containers, we suggest reading the documentation that can
    be found on Docker’s website for additional information: [https://docs.docker.com/](https://docs.docker.com/).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是容器新手，我们建议你阅读 Docker 网站上的文档，获取更多信息：[https://docs.docker.com/](https://docs.docker.com/)。
- en: Containers are ephemeral
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器是短暂的
- en: The first thing to understand is that containers are ephemeral.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要理解的是，容器是短暂的（暂时存在的）。
- en: The term “ephemeral” means something that exists for a short period. **Containers**
    can be intentionally terminated, or automatically restarted without any user involvement
    or consequences. To better understand this concept, let’s look at an example –
    imagine someone interactively adds files to a web server running within a container.
    The uploaded files are temporary because they were not originally part of the
    base image.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: “短暂”（ephemeral）一词指的是存在时间较短的事物。**容器**可以被故意终止，或者在没有用户干预或后果的情况下自动重新启动。为了更好地理解这个概念，我们来看一个例子——假设某人在容器中运行的网页服务器上交互式地添加了文件。这些上传的文件是临时的，因为它们最初并不属于基础镜像的一部分。
- en: 'This means that once a container is built and running, any changes that are
    made to the container will not be saved once it is removed, or destroyed, from
    the Docker host. Let’s look at a full example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一旦容器被构建并运行，任何对容器所做的更改都不会在容器被移除或销毁后保存。让我们来看一个完整的示例：
- en: You start a container running a web server using **NGINX** on your host without
    any base **HTML** pages.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在主机上启动一个运行 **NGINX** 的容器，但没有任何基础的 **HTML** 页面。
- en: Using a Docker command, you execute a `copy` command to copy some web files
    into the container’s filesystem.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Docker 命令，你执行 `copy` 命令将一些网页文件复制到容器的文件系统中。
- en: To test that the copy was successful, you go to the website and confirm that
    it is serving the correct web pages.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证复制是否成功，你访问网站并确认它是否提供正确的网页。
- en: Happy with the results, you stop the container and remove it from the host.
    Later that day, you want to show a coworker the website and you start your **NGINX**
    container. You go to the website again, but when the site opens, you receive a
    `404` error (page not found error).
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 满意结果后，你停止容器并将其从主机中移除。当天稍晚，你想向同事展示网站，便启动了 **NGINX** 容器。你再次访问网站，但当页面打开时，收到 `404`
    错误（页面未找到错误）。
- en: What happened to the files you uploaded before you stopped and removed the container
    from the host?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你在停止并从主机上移除容器之前上传的文件去哪了？
- en: The reason your web pages cannot be found after the container was restarted
    is that all containers are ephemeral. Whatever is in the base container image
    is all that will be included each time the container is initially started. Any
    changes that you make inside a container are short-lived.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你在容器重启后找不到网页的原因是所有容器都是临时性的。每次容器首次启动时，基础容器镜像中的内容就是唯一会被包含的内容。你在容器内部所做的任何更改都是短暂的。
- en: If you need to add permanent files to an existing image, you need to rebuild
    the image with the files included or, as we will explain in the *Persistent data*
    section later in this chapter, you could mount a Docker volume in your container.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要向现有镜像添加永久文件，你需要重新构建镜像并将文件包含其中，或者正如我们将在本章稍后的*持久化数据*部分中解释的，你可以在容器中挂载一个Docker卷。
- en: At this point, the main concept to understand is that containers are **ephemeral**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，主要的概念是容器是**临时的**。
- en: But wait! You may be wondering, “If containers are ephemeral, how did I add
    web pages to the server?” **Ephemeral** just means that changes will not be saved;
    it doesn’t stop you from making changes to a running container.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！你可能会想，“如果容器是临时的，那我怎么把网页添加到服务器中？”**临时**只是意味着更改不会被保存；它并不阻止你对运行中的容器进行更改。
- en: Any changes made to a running container will be written to a temporary layer,
    called the **container layer**, which is a directory on the localhost filesystem.
    Docker uses a **storage driver**, which is in charge of handling requests that
    use the container layer. The storage driver is responsible for managing and storing
    images and containers on your Docker host. It controls the mechanisms and processes
    involved in their storage and management.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对运行中的容器所做的任何更改都会写入一个临时层，这个层被称为**容器层**，它是本地文件系统上的一个目录。Docker使用**存储驱动程序**，负责处理使用容器层的请求。存储驱动程序负责在Docker主机上管理和存储镜像及容器。它控制与存储和管理它们相关的机制和过程。
- en: This location will store all changes in the container’s filesystem so that when
    you add the HTML pages to the container, they will be stored on the local host.
    The container layer is tied to the **container ID** of the running image and it
    will remain on the host system until the container is removed from Docker, either
    by using the CLI or by running a Docker **prune job** (see *Figure 1.1* on the
    next page).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个位置将存储容器文件系统中的所有更改，因此，当你将HTML页面添加到容器时，它们会存储在本地主机上。容器层与运行镜像的**容器ID**绑定，并且它会一直保留在主机系统上，直到容器从Docker中移除，无论是通过CLI命令还是运行Docker
    **清理任务**（参见下一页的*图 1.1*）。
- en: Considering that containers are temporary and are read only, you might wonder
    how it’s possible to modify data within a container. Docker addresses this by
    utilizing **image layering**, which involves creating interconnected layers that
    collectively function as a single filesystem. Through this, changes can be made
    to the container’s data, even though the underlying image remains **immutable**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到容器是临时的并且是只读的，你可能会好奇，如何在容器内部修改数据。Docker通过利用**镜像层叠**来解决这个问题，镜像层叠涉及创建相互连接的层，这些层共同作为一个单一的文件系统。通过这种方式，可以对容器的数据进行更改，即使底层镜像保持**不可变**。
- en: Docker images
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 镜像
- en: A Docker image is composed of multiple image layers, each accompanied by a **JavaScript
    Object Notation** (**JSON**) file that stores metadata specific to the layer.
    When a container image is launched, these layers are combined to form the application
    that users interact with.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Docker镜像由多个镜像层组成，每个镜像层都附带一个**JavaScript对象表示法**（**JSON**）文件，用于存储该层特定的元数据。当启动容器镜像时，这些层会被组合成用户交互的应用程序。
- en: You can read more about the contents of an image on Docker’s GitHub at [https://github.com/moby/moby/blob/master/image/spec/v1.1.md](https://github.com/moby/moby/blob/master/image/spec/v1.1.md).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Docker的GitHub上查看更多关于镜像内容的信息，链接：[https://github.com/moby/moby/blob/master/image/spec/v1.1.md](https://github.com/moby/moby/blob/master/image/spec/v1.1.md)。
- en: Image layers
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜像层
- en: 'As we mentioned in the previous section, a running container uses a **container
    layer** that is “on top” of the base **image layer**, as shown in the following
    diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一部分中提到的，运行中的容器使用一个位于基础**镜像层**“之上”的**容器层**，如下图所示：
- en: '![Figure 1.1 – Docker image layers ](img/B21165_01_01.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – Docker 镜像层](img/B21165_01_01.png)'
- en: 'Figure 1.1: Docker image layers'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：Docker 镜像层
- en: The image layers cannot be written to since they are in a read-only state, but
    the temporary container layer is in a writeable state. Any data that you add to
    the container is stored in this layer and will be retained as long as the container
    is running.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像层是只读状态，不能写入，但临时容器层是可写的。你添加到容器中的任何数据都会存储在这个层中，并且只要容器在运行，这些数据就会被保留。
- en: To deal with multiple layers efficiently, Docker implements **copy-on-write**,
    which means that if a file already exists, it will not be created. However, if
    a file is required that does not exist in the current image, it will be written.
    In the container world, if a file exists in a lower layer, the layers above it
    do not need to include it. For example, if layer 1 had a file called `/opt/nginx/index.xhtml`
    in it, layer 2 does not need the same file in its layer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了高效地处理多个层次，Docker 实现了**写时复制**（copy-on-write），这意味着如果文件已经存在，它不会被重新创建。然而，如果当前镜像中不存在某个需要的文件，它将会被写入。在容器世界中，如果某个文件存在于较低的层次，位于它之上的层次就不需要再次包含这个文件。例如，如果第一层包含一个名为`/opt/nginx/index.xhtml`的文件，那么第二层就不需要在它的层次中包含相同的文件。
- en: This explains how the system handles files that either exist or do not exist,
    but what about a file that has been modified? There will be times when you’ll
    need to replace a file that is in a lower layer. You may need to do this when
    you are building an image or as a temporary fix to a running container issue.
    The copy-on-write system knows how to deal with these issues. Since images read
    from the top down, the container uses only the highest layer file. If your system
    had a `/opt/nginx/index.xhtml` file in layer 1 and you modified and saved the
    file, the running container would store the new file in the container layer. Since
    the container layer is the topmost layer, the new copy of `index.xhtml` would
    always be read before the older version in the image layer.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了系统如何处理已存在或不存在的文件，但如果文件被修改了怎么办？有时你需要替换较低层次中的文件。你可能在构建镜像时需要这么做，或者作为临时修复正在运行的容器问题。写时复制系统知道如何处理这些问题。由于镜像是从上到下读取的，容器只会使用最上层的文件。如果你的系统在第一层有一个`/opt/nginx/index.xhtml`文件，并且你修改并保存了该文件，那么运行中的容器会将新文件保存在容器层中。由于容器层是最上层，新版本的`index.xhtml`会始终在镜像层中的旧版本之前被读取。
- en: Persistent data
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久数据
- en: Being limited to ephemeral-only containers would severely limit the use cases
    for Docker. You will probably encounter use cases where persistent storage is
    needed or data must be retained even if a container is stopped.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 仅限于临时容器会极大限制 Docker 的使用场景。你可能会遇到需要持久存储的情况，或者即使容器停止运行也必须保留数据。
- en: Remember, when you store data in the container image layer, the base image does
    not change. When the container is removed from the host, the container layer is
    also removed. If the same image is used to start a new container, a new container
    image layer is created. While containers themselves are ephemeral, you can achieve
    data persistence by incorporating a Docker volume. By utilizing a **Docker volume**,
    data can be stored externally in the container, enabling it to persist beyond
    the container’s lifespan.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当你将数据存储在容器镜像层时，基础镜像本身并不会改变。当容器从主机中删除时，容器层也会被删除。如果使用相同的镜像启动新容器，则会创建一个新的容器镜像层。虽然容器本身是临时的，但你可以通过结合
    Docker 卷来实现数据持久化。通过使用**Docker 卷**，数据可以存储在容器外部，使其能够在容器生命周期之外持久存在。
- en: Accessing services running in containers
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问运行在容器中的服务
- en: Unlike a physical machine or a virtual machine, containers do not connect to
    a network directly. When a container needs to send or receive traffic, it goes
    through the Docker host system using a bridged **network address translation**
    (**NAT**) connection. This means that when you run a container and you want to
    receive incoming traffic requests, you need to expose the ports for each of the
    containers that you wish to receive traffic on. On a Linux-based system, `iptables`
    has rules to forward traffic to the Docker daemon, which will service the assigned
    ports for each container. There is no need to worry about how the `iptables` rules
    are created, as Docker will handle that for you by using the port information
    provided when you start the container. If you are new to Linux, `iptables` may
    be new to you.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与物理机器或虚拟机不同，容器不会直接连接到网络。当容器需要发送或接收流量时，它会通过 Docker 主机系统使用桥接的**网络地址转换**（**NAT**）连接。这意味着当你运行容器并希望接收传入的流量请求时，你需要为每个希望接收流量的容器暴露端口。在基于
    Linux 的系统中，`iptables` 有规则将流量转发到 Docker 守护进程，后者将为每个容器分配的端口提供服务。你无需担心 `iptables`
    规则是如何创建的，因为 Docker 会在启动容器时通过使用提供的端口信息来为你处理。如果你是 Linux 新手，`iptables` 可能对你来说是一个新概念。
- en: At a high level, `iptables` is used to manage network traffic and keep it secure
    within a cluster. It controls the flow of network connections between components
    in the cluster, deciding which connections are allowed and which ones are blocked.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，`iptables` 用于管理网络流量并确保集群内的安全。它控制集群中各个组件之间的网络连接流向，决定哪些连接被允许，哪些被阻止。
- en: That concludes the introduction to container fundamentals and Docker concepts.
    In the next section, we will guide you through the process of installing Docker
    on your host.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容介绍了容器基础知识和 Docker 概念。在下一部分，我们将引导你完成在主机上安装 Docker 的过程。
- en: Installing Docker
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: The hands-on exercises in this book will require that you have a working Docker
    host. To install Docker, we have included a script located in this book’s GitHub
    repository, in the `chapter1` directory, called `install-docker.sh`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的动手练习要求你拥有一个正常工作的 Docker 主机。为了安装 Docker，我们在本书的 GitHub 仓库中包含了一个脚本，该脚本位于 `chapter1`
    目录下，名为 `install-docker.sh`。
- en: Today, you can install Docker on just about every hardware platform out there.
    Each version of Docker acts and looks the same on each platform, making development
    and using Docker easy for people who need to develop cross-platform applications.
    By making the functions and commands the same between different platforms, developers
    do not need to learn a different container runtime to run images.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，你可以在几乎所有硬件平台上安装 Docker。每个版本的 Docker 在不同平台上的表现和外观都是一致的，这使得开发跨平台应用程序变得更加容易。通过确保不同平台之间的功能和命令相同，开发者无需学习不同的容器运行时来运行镜像。
- en: 'The following is a table of Docker’s available platforms. As you can see, there
    are installations for multiple OSs, as well as multiple architectures:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Docker 可用平台的表格。如你所见，有多个操作系统的安装版本，以及多种架构：
- en: '| **Desktop Platform** | **x86_64/amd64** | **arm64 (Apple Silicon)** |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **桌面平台** | **x86_64/amd64** | **arm64 (Apple Silicon)** |'
- en: '| Docker Desktop (Linux) | ![Checkmark](img/Icon.png) |  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| Docker Desktop (Linux) | ![Checkmark](img/Icon.png) |  |'
- en: '| Docker Desktop (macOS) | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png)
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| Docker Desktop (macOS) | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png)
    |'
- en: '| Docker Desktop (Windows) | ![Checkmark](img/Icon.png) |  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| Docker Desktop (Windows) | ![Checkmark](img/Icon.png) |  |'
- en: '| **Server Platform** | **x86_64/amd64** | **arm64/aarch64** | **arm (32-bit)**
    | **ppcc64le** | **s390x** |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **服务器平台** | **x86_64/amd64** | **arm64/aarch64** | **arm (32-bit)** | **ppcc64le**
    | **s390x** |'
- en: '| CentOS | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png) |  | ![Checkmark](img/Icon.png)
    |  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| CentOS | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png) |  | ![Checkmark](img/Icon.png)
    |  |'
- en: '| Debian | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png)
    | ![Checkmark](img/Icon.png) |  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| Debian | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png)
    | ![Checkmark](img/Icon.png) |  |'
- en: '| Fedora | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png) |  | ![Checkmark](img/Icon.png)
    |  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| Fedora | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png) |  | ![Checkmark](img/Icon.png)
    |  |'
- en: '| Raspberry Pi OS |  |  | ![Checkmark](img/Icon.png) |  |  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| Raspberry Pi OS |  |  | ![Checkmark](img/Icon.png) |  |  |'
- en: '| RHEL (s390) | ![Checkmark](img/Icon.png) |  |  |  | ![Checkmark](img/Icon.png)
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| RHEL (s390) | ![Checkmark](img/Icon.png) |  |  |  | ![Checkmark](img/Icon.png)
    |'
- en: '| SLES | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png)
    | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png) |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| SLES | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png)
    | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png) |'
- en: '| Ubuntu | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png)
    |  |  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| Ubuntu | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png) | ![Checkmark](img/Icon.png)
    |  |  |'
- en: 'Table 1.2: Available Docker platforms'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.2：可用的Docker平台
- en: Images that are created using one architecture cannot run on a different architecture.
    This means that you cannot create an image based on x86 hardware and expect that
    same image to run on your Raspberry Pi running an ARM processor. It’s also important
    to note that while you can run a Linux container on a Windows machine, you cannot
    run a Windows container on a Linux machine.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单一架构创建的镜像不能在不同架构上运行。这意味着你不能基于x86硬件创建一个镜像，并期望它能够在运行ARM处理器的Raspberry Pi上运行。同样需要注意的是，虽然你可以在Windows机器上运行Linux容器，但无法在Linux机器上运行Windows容器。
- en: While images, by default, are not cross-architecture compatible, there are new
    tools to create what’s known as a multi-platform image. Multi-platform images
    are images that can be used across different architectures or processors in a
    single container, rather than having multiple images, such as one for **NGINX**
    on x86, another one for **ARM**, and another one for **PowerPC**. This will help
    you simplify your management and deployment of containerized applications. Since
    multi-platform images contain various versions, one for each architecture you
    include, you need to specify the architecture when deploying the image. Luckily,
    the container runtime will help out and automatically select the correct architecture
    from the image manifest.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然镜像默认情况下不具备跨架构兼容性，但现在有新的工具可以创建所谓的多平台镜像。多平台镜像是可以在不同架构或处理器上使用的镜像，这样你就不需要为**NGINX**在x86架构、为**ARM**架构、以及为**PowerPC**架构分别创建多个镜像，而是可以在一个容器中使用多个架构的镜像。这将帮助你简化容器化应用程序的管理和部署。由于多平台镜像包含不同架构的多个版本，因此在部署镜像时需要指定架构。幸运的是，容器运行时会自动从镜像清单中选择正确的架构。
- en: The use of multi-platform images provides portability, flexibility, and scalability
    for your containers across cloud platforms, edge deployments, and hybrid infrastructure.
    With the use of ARM-based servers growing in the industry and the heavy use of
    Raspberry Pi by people learning Kubernetes, cross-platform images will help make
    consuming containers quicker and easier.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多平台镜像可以为你的容器提供跨云平台、边缘部署和混合基础设施的可移植性、灵活性和可扩展性。随着行业中基于ARM的服务器的使用不断增长，以及学习Kubernetes的人们广泛使用Raspberry
    Pi，跨平台镜像将有助于加快容器的使用，并使其更加容易。
- en: For example, in 2020, Apple released the M1 chip, ending the era of Apple running
    Intel processors in favor of the ARM processor. We’re not going to get into the
    details of the difference, only that they are different and this leads to important
    challenges for container developers and users. Docker does have **Docker Desktop**,
    a macOS tool for running containers that lets you use the same workflows that
    you used if you had a Docker installation on Linux, Windows, or x86 macOS. Docker
    will try to match the architecture of the underlying host when pulling or building
    images. On ARM-based systems, if you are attempting to pull an image that does
    not have an ARM version, Docker will throw an error due to the architecture incompatibilities.
    If you are attempting to build an image, it will build an ARM version on macOS,
    which cannot run on x86 machines.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在2020年，苹果发布了M1芯片，结束了苹果使用英特尔处理器的时代，转而使用ARM处理器。我们不打算深入讨论它们之间的差异，只要知道它们是不同的，而这为容器开发人员和用户带来了重要的挑战。Docker确实有**Docker
    Desktop**，这是一款macOS工具，允许你使用与Linux、Windows或x86 macOS上Docker安装相同的工作流来运行容器。Docker会尝试在拉取或构建镜像时匹配底层主机的架构。在基于ARM的系统上，如果你尝试拉取没有ARM版本的镜像，Docker会因架构不兼容而抛出错误。如果你尝试构建一个镜像，它将在macOS上构建一个ARM版本，但这个版本不能在x86机器上运行。
- en: 'Multi-platform images can be complex to create. If you want additional details
    on creating multi-platform images, visit the *Multi-platform* *images* page on
    Docker’s website: [https://docs.docker.com/build/building/multi-platform/](https://docs.docker.com/build/building/multi-platform/).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 创建多平台镜像可能比较复杂。如果你想了解更多关于创建多平台镜像的细节，可以访问Docker官网的*多平台* *镜像*页面：[https://docs.docker.com/build/building/multi-platform/](https://docs.docker.com/build/building/multi-platform/)。
- en: 'The installation procedures that are used to install Docker vary between platforms.
    Luckily, Docker has documented many of them on their website: [https://docs.docker.com/install/](https://docs.docker.com/install/).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Docker 的过程在不同平台之间有所不同。幸运的是，Docker 在其官网上记录了许多安装方法：[https://docs.docker.com/install/](https://docs.docker.com/install/)。
- en: In this chapter, we will install Docker on an **Ubuntu 22.04** system. If you
    do not have an Ubuntu machine to install on, you can still read about the installation
    steps, as each step will be explained and does not require that you have a running
    system to understand the process. If you have a different Linux installation,
    you can use the installation procedures outlined on Docker’s site at [https://docs.docker.com/](https://docs.docker.com/).
    Steps are provided for CentOS, Debian, Fedora, and Ubuntu, and there are generic
    steps for other Linux distributions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将指导你在 **Ubuntu 22.04** 系统上安装 Docker。如果你没有 Ubuntu 机器进行安装，仍然可以阅读安装步骤，因为每个步骤都会详细解释，并且不需要实际系统就能理解整个过程。如果你使用的是其他
    Linux 发行版，可以参考 Docker 官网提供的安装步骤：[https://docs.docker.com/](https://docs.docker.com/)。官网为
    CentOS、Debian、Fedora 和 Ubuntu 提供了具体步骤，并为其他 Linux 发行版提供了通用步骤。
- en: Preparing to install Docker
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备安装 Docker
- en: 'Now that we have introduced Docker, the next step is to select an installation
    method. Docker’s installation changes between not only different Linux distributions
    but also versions of the same Linux distribution. Our script is based on using
    an Ubuntu 22.04 server, so it may not work on other versions of Ubuntu. You can
    install Docker using one of two methods:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 Docker，下一步是选择安装方法。Docker 的安装方式不仅在不同的 Linux 发行版之间有所不同，甚至同一 Linux 发行版的不同版本也会有所变化。我们的脚本基于使用
    Ubuntu 22.04 服务器，因此在其他版本的 Ubuntu 上可能无法使用。你可以通过以下两种方法之一来安装 Docker：
- en: Add the Docker repositories to your host system
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Docker 仓库添加到主机系统
- en: Install using Docker scripts
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 脚本进行安装
- en: The first option is considered the best option since it allows for easy installation
    and updates to the Docker engine. The second option is designed for installing
    Docker on testing/development environments and is not recommended for deployment
    in production environments.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项被认为是最佳选择，因为它便于安装和更新 Docker 引擎。第二个选项旨在用于测试/开发环境的 Docker 安装，不建议在生产环境中部署。
- en: Since the preferred method is to add Docker’s repository to our host, we will
    use that option.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于首选方法是将 Docker 仓库添加到主机中，我们将选择此选项。
- en: Installing Docker on Ubuntu
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Ubuntu 上安装 Docker
- en: Now that we have added the required repositories, the next step is to install
    Docker.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了所需的仓库，下一步是安装 Docker。
- en: We have provided a script in the `chapter1` folder of the Git repository called
    `install`-`docker.sh`. When you execute the script, it will automatically install
    all of the necessary binaries required for Docker to run.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Git 仓库的 `chapter1` 文件夹中提供了一个名为 `install`-`docker.sh` 的脚本。当你执行此脚本时，它将自动安装运行
    Docker 所需的所有必要二进制文件。
- en: To provide a brief summary of the script, it begins by modifying a specific
    value in the `/etc/needrestart/needrestart.conf` file. In Ubuntu 22.04, there
    was a change in how daemons are restarted, where users might be required to manually
    select which system daemons to restart. To simplify the exercises described in
    the book, we alter the `restart` value in the `needsrestart.conf` file to “automatic”
    instead of prompting for each changed service.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 简要概述一下脚本，它首先会修改 `/etc/needrestart/needrestart.conf` 文件中的特定值。在 Ubuntu 22.04 中，守护进程的重启方式发生了变化，用户可能需要手动选择哪些系统守护进程需要重启。为了简化本书中描述的操作，我们将
    `needsrestart.conf` 文件中的 `restart` 值更改为“自动”，而不是每次提示重新启动被更改的服务。
- en: Next, we install a few utilities like `vim`, `ca-certificates`, `curl`, and
    `GnuPG`. The first three utilities are fairly common, but the last one, `GnuPG`,
    may be newer to some readers and might need some explaining. `GnuPG`, an acronym
    for **GNU Privacy Guard**, enhances Ubuntu with a range of cryptographic capabilities
    such as **encryption**, **decryption**, **digital signatures**, and **key management**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们安装一些实用工具，如 `vim`、`ca-certificates`、`curl` 和 `GnuPG`。前三个工具比较常见，而最后一个 `GnuPG`
    可能对一些读者来说是新的，可能需要一些解释。`GnuPG` 是 **GNU 隐私保护工具**（GNU Privacy Guard）的缩写，它为 Ubuntu
    提供了一系列加密功能，如 **加密**、**解密**、**数字签名** 和 **密钥管理**。
- en: In our Docker deployment, we need to add Docker’s **GPG public key**. which
    is a cryptographic key pair that secures communication and maintains data integrity.
    GPG keys use asymmetrical encryption, which involves the use of two different,
    but related, keys, known as a **public** key and a **private** key. These keys
    are generated together as a pair, but they provide different functions. The private
    key, which remains confidential, is used to generate the digital signatures on
    the downloaded files. The public key is publicly available and is used to verify
    digital signatures created by the private key.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Docker 部署中，我们需要添加 Docker 的 **GPG 公钥**，这是一个加密密钥对，用于保护通信并保持数据完整性。GPG 密钥使用非对称加密，即使用两把不同但相关的密钥，称为
    **公钥** 和 **私钥**。这两把密钥一起生成，但它们执行不同的功能。私钥保持机密，用于对下载的文件生成数字签名。公钥是公开的，用于验证由私钥创建的数字签名。
- en: 'Next, we need to add Docker’s repository to our local repository list. When
    we add the repository to the list, we need to include the Docker certificate.
    The `docker.gpg` certificate was downloaded by the script from Docker’s site and
    stored on the local server under `/etc/apt/keyings/docker.gpg`. When we add the
    repository to the repository list, we add the key by using the signed-by option
    in the `/etc/apt/sources.list.d/docker.list` file. The full command is shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 Docker 仓库添加到我们的本地仓库列表中。当我们将仓库添加到列表时，还需要包含 Docker 证书。`docker.gpg` 证书由脚本从
    Docker 网站下载，并保存在本地服务器的 `/etc/apt/keyings/docker.gpg` 路径下。当我们将仓库添加到仓库列表时，我们通过在
    `/etc/apt/sources.list.d/docker.list` 文件中使用 signed-by 选项来添加该密钥。完整的命令如下所示：
- en: '[PRE0]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By including the Docker repository in our local `apt` repository list, we gain
    the ability to install the Docker binaries effortlessly. This process entails
    using a straightforward `apt-get install` command, which will install the five
    essential binaries for Docker: `docker-ce`, `docker-ce-cli`, `containerd.io`,
    `docker-buildx-plugin`, and `docker-compose-plugin`. As previously stated, all
    these files are signed with Docker’s GPG key. Thanks to the inclusion of Docker’s
    key on our server, we can be confident that the files are safe and originate from
    a reliable source.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 Docker 仓库添加到我们本地的 `apt` 仓库列表中，我们可以轻松地安装 Docker 二进制文件。此过程涉及使用简单的 `apt-get
    install` 命令，它将安装 Docker 所需的五个基本二进制文件：`docker-ce`、`docker-ce-cli`、`containerd.io`、`docker-buildx-plugin`
    和 `docker-compose-plugin`。如前所述，所有这些文件都经过 Docker 的 GPG 密钥签名。由于服务器上已包含 Docker 的密钥，我们可以确信这些文件是安全的，并且来自可靠的来源。
- en: Once Docker is successfully installed, the next step involves enabling and configuring
    the Docker daemon to start automatically during system boot using the `systemctl`
    command. This process follows the standard procedure applied to most system daemons
    installed on Linux servers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Docker 成功安装，下一步是使用 `systemctl` 命令启用并配置 Docker 守护进程，以便在系统启动时自动启动。此过程遵循应用于大多数在
    Linux 服务器上安装的系统守护进程的标准程序。
- en: Rather than go over each line of code in each script, we have included comments
    in the scripts to help you understand how what each command and step is executing.
    Where it may help with some topics, we will include some section of code in the
    chapters for reference.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有逐行解释每个脚本中的代码，而是在脚本中加入了注释，帮助你理解每个命令和步骤的执行方式。如果某些主题需要帮助，我们将在章节中提供部分代码供参考。
- en: After installing Docker, let’s get some configuration out of the way. First,
    you will rarely execute commands as root in the real world, so we need to grant
    permissions to use Docker to your user.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Docker 后，我们来处理一些配置。首先，你在实际操作中很少以 root 身份执行命令，因此我们需要授权你的用户使用 Docker。
- en: Granting Docker permissions
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授予 Docker 权限
- en: In a default installation, Docker requires root access, so you will need to
    run all Docker commands as **root**. Rather than using `sudo` with every Docker
    command, you can add your user account to a new group on the server that provides
    Docker access without requiring `sudo` for every command.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认安装中，Docker 需要 root 权限，因此你需要以 **root** 身份运行所有 Docker 命令。为了避免每次都使用 `sudo` 执行
    Docker 命令，你可以将你的用户账户添加到服务器上一个新的组中，该组提供 Docker 访问权限，而无需为每个命令使用 `sudo`。
- en: 'If you are logged on as a standard user and try to run a Docker command, you
    will receive an error:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以普通用户身份登录并尝试运行 Docker 命令，你将收到一个错误提示：
- en: '[PRE1]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To allow your user, or any other user you may want to add, to execute Docker
    commands, you need to add the users to a new group called `docker` that was created
    during the installation of Docker. The following is an example command you can
    use to add the currently logged-on user to the group:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的用户，或你可能希望添加的其他用户，执行Docker命令，你需要将这些用户添加到一个名为`docker`的新组，该组是在安装Docker时创建的。以下是你可以使用的命令示例，将当前登录用户添加到该组：
- en: '[PRE2]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To add the new members to your account, you can either log off and log back
    into the Docker host, or activate the group changes using the `newgrp` command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新成员添加到你的账户中，你可以选择注销并重新登录Docker主机，或者使用`newgrp`命令激活组变更：
- en: '[PRE3]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let’s test that Docker is working by running the standard `hello-world`
    image (note that we do not require `sudo` to run the Docker command):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过运行标准的`hello-world`镜像来测试Docker是否正常工作（请注意，我们不需要`sudo`来运行Docker命令）：
- en: '[PRE4]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see the following output, which verifies that your user has access
    to Docker:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出，验证你的用户有权限访问Docker：
- en: '[PRE5]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This message shows that your installation is working correctly – congratulations!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该消息显示你的安装工作正常——恭喜！
- en: 'To generate this message, Docker took the following steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成此消息，Docker执行了以下步骤：
- en: The Docker client contacted the Docker daemon.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker客户端已联系Docker守护进程。
- en: The Docker daemon pulled the `hello-world` image from Docker Hub (amd64).
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker守护进程从Docker Hub拉取了`hello-world`镜像（amd64）。
- en: The Docker daemon created a new container from the image that runs the executable
    that produces the output you are currently reading.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker守护进程从镜像创建了一个新容器，并运行该可执行文件，生成你当前所看到的输出。
- en: The Docker daemon streamed that output to the Docker client, which sent it to
    your terminal.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker守护进程将该输出流式传输到Docker客户端，客户端将其发送到你的终端。
- en: 'To try something more ambitious – you can run an Ubuntu container with the
    following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试更有挑战性的操作，可以使用以下命令运行一个Ubuntu容器：
- en: '[PRE6]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For more examples and ideas, visit [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多示例和想法，请访问[https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)。
- en: Now that we’ve granted Docker permission, we can start unlocking the most common
    Docker commands by learning how to use the Docker CLI.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经授予了Docker权限，可以开始解锁最常用的Docker命令，学习如何使用Docker CLI。
- en: Using the Docker CLI
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker CLI
- en: 'You used the Docker CLI when you ran the `hello-world` container to test your
    installation. The Docker command is what you will use to interact with the Docker
    daemon. Using this single executable, you can do the following, and more:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`hello-world`容器测试安装时，你使用了Docker CLI。Docker命令是你与Docker守护进程交互时将使用的命令。通过这个单一的可执行文件，你可以执行以下操作，甚至更多：
- en: Start and stop containers
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动和停止容器
- en: Pull and push images
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取和推送镜像
- en: Run a shell in an active container
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在活动容器中运行一个Shell
- en: Look at container logs
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看容器日志
- en: Create Docker volumes
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Docker卷
- en: Create Docker networks
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Docker网络
- en: Prune old images and volumes
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理旧的镜像和卷
- en: This chapter is not meant to include an exhaustive explanation of every Docker
    command; instead, we will explain some of the common commands that you will need
    to use to interact with the Docker daemon and containers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本章并不打算详尽地解释每个Docker命令；相反，我们将解释一些你在与Docker守护进程和容器交互时需要使用的常见命令。
- en: 'You can break down Docker commands into two categories: general Docker commands
    and Docker management commands. The standard Docker commands allow you to manage
    containers, while management commands allow you to manage Docker options such
    as managing volumes and networking.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将Docker命令分为两类：一般的Docker命令和Docker管理命令。标准的Docker命令允许你管理容器，而管理命令允许你管理Docker选项，如管理卷和网络。
- en: docker help
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker help
- en: It is quite common to forget the syntax or options of a command, and Docker
    acknowledges this. If you ever find yourself in a situation where you can’t recall
    a command, you can always depend on the `docker help` command. It will help you
    by providing what the command can do and how to use it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记命令的语法或选项是很常见的，Docker对此已有考虑。如果你发现自己无法记起某个命令，随时可以依赖`docker help`命令。它会提供该命令的功能说明以及如何使用它的帮助。
- en: docker run
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker run
- en: To run a container, use the `docker run` command with the provided image name.
    But, before executing a `docker run` command, you should understand the options
    you can supply when starting a container.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行容器，使用`docker run`命令并提供相应的镜像名称。但在执行`docker run`命令之前，你应该了解在启动容器时可以提供的选项。
- en: 'In its simplest form, an example command you can use to run an NGINX web server
    would be `docker run bitnami/nginx:latest`. This will start a container running
    NGINX, and it will run in the foreground, showing logs of the application running
    in the container. Pressing *Ctrl* + *C* will stop the running container and terminate
    the NGINX server:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式下，你可以使用的命令来运行一个 NGINX Web 服务器是 `docker run bitnami/nginx:latest`。这将启动一个运行
    NGINX 的容器，并且它将在前台运行，显示容器中运行应用程序的日志。按下 *Ctrl* + *C* 将停止正在运行的容器并终止 NGINX 服务器：
- en: '[PRE7]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you saw, when you used *Ctrl* + *C* to stop the container, NGINX also stopped.
    In most cases, you want a container to start and continue to run without being
    in the foreground, allowing the system to run other tasks while the container
    also continues to run. To run a container as a background process, you need to
    add the `-d`, or `--detach` option to your Docker command, which will run your
    container in detached mode. Now, when you run a detached container, you will only
    see the container ID, instead of the interactive or attached screen:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当你使用 *Ctrl* + *C* 停止容器时，NGINX 也停止了。在大多数情况下，你希望容器启动并继续运行，而不处于前台，这样系统可以运行其他任务，同时容器也能继续运行。要将容器作为后台进程运行，你需要在
    Docker 命令中添加 `-d` 或 `--detach` 选项，这将使容器以分离模式运行。现在，当你运行一个分离的容器时，你只会看到容器 ID，而不是交互式或附加的屏幕：
- en: '[PRE8]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By default, containers will be given a random name once they are started. In
    our previous detached example, if we list the running containers, we will see
    that the container has been given the name `silly_keldysh`, as shown in the following
    output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，容器启动后会被赋予一个随机名称。在我们之前的分离示例中，如果我们列出正在运行的容器，我们将看到容器被赋予了名称 `silly_keldysh`，如下所示的输出：
- en: '[PRE9]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you do not assign a name to your container, it can quickly get confusing
    as you start to run multiple containers on a single host. To make management easier,
    you should always start your container with a name that will make it easier to
    manage. Docker provides another option with the `run` command: the `--name` option.
    Building on our previous example, we will name our container `nginx-test`. Our
    new `docker run` command will be as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有为容器指定名称，当你在单个主机上运行多个容器时，很容易造成混乱。为了简化管理，你应该始终为容器指定一个名称，这样有助于更好地管理。Docker
    提供了另一个选项来配合 `run` 命令使用：`--name` 选项。基于我们之前的示例，我们将容器命名为 `nginx-test`。我们的新 `docker
    run` 命令如下所示：
- en: '[PRE10]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Just like running any detached image, this will return the container ID, but
    not the name you provided. In order to verify that the container ran with the
    name `nginx-test`, we can list the containers using the `docker ps` command, which
    we will explain next.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 就像运行任何分离镜像一样，这将返回容器 ID，但不会显示你指定的名称。为了验证容器是否以 `nginx-test` 的名称运行，我们可以使用 `docker
    ps` 命令列出容器，接下来我们将对此进行解释。
- en: docker ps
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker ps
- en: 'Often, you will need to retrieve a list of running containers or a list of
    containers that have been stopped. The Docker CLI has a flag called `ps` that
    will list all running and stopped containers, by adding the extra flag to the
    `ps` command. The output will list the containers, including their container ID,
    image tag, `entry` command, creation date, status, ports, and container name.
    The following is an example of containers that are currently running:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要检索正在运行的容器列表或已停止的容器列表。Docker CLI 有一个名为 `ps` 的标志，它会列出所有正在运行和已停止的容器，方法是将额外的标志添加到
    `ps` 命令中。输出将列出容器，包括它们的容器 ID、镜像标签、`entry` 命令、创建日期、状态、端口和容器名称。以下是当前正在运行的容器的示例：
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is helpful if the container you are looking for is currently running, but
    what if the container has stopped, or even worse, what if the container failed
    to start and then stopped? You can view the status of all containers, including
    previously run containers, by adding the `-a` flag to the `docker ps` command.
    When you execute `docker ps -a`, you will see the same output from a standard
    `ps` command, but you will notice that the list may include additional containers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于你要查找的容器当前正在运行时很有帮助，但如果容器已经停止，或者更糟的是，容器未能启动然后停止了呢？你可以通过在 `docker ps` 命令中添加
    `-a` 标志，查看所有容器的状态，包括以前运行过的容器。当你执行 `docker ps -a` 时，你将看到与标准 `ps` 命令相同的输出，但你会注意到列表中可能包含额外的容器。
- en: How can you tell which containers are running versus which ones have stopped?
    If you look at the `STATUS` field of the list, the running containers will show
    a running time; for example, `Up xx hours`, or `Up xx days`. However, if the container
    has been stopped for any reason, the status will show when it stopped; for example,
    `Exited (0) 10 minutes ago`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如何判断哪些容器正在运行，哪些容器已经停止？如果你查看列表中的`STATUS`字段，正在运行的容器会显示运行时间；例如，`Up xx hours` 或
    `Up xx days`。然而，如果容器因为某种原因已经停止，状态会显示容器停止的时间；例如，`Exited (0) 10 minutes ago`。
- en: '[PRE12]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A stopped container does not mean there was an issue with running the image.
    There are containers that may execute a single task and, once completed, the container
    may stop gracefully. One way to determine whether an exit was graceful or whether
    it was due to a failed startup is to look at the exited status code. There are
    a number of exit codes that you can use to find out why a container has exited.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 停止的容器并不意味着运行镜像时发生了问题。有些容器可能只执行一个任务，完成后容器可能会优雅地停止。判断退出是否优雅或是否由于启动失败的一种方法是查看退出状态码。有多种退出码可以帮助你查找容器退出的原因。
- en: '| **Exit Code** | **Description** |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| **退出码** | **描述** |'
- en: '| `0` | The command was executed successfully without any issues. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 命令成功执行，没有任何问题。 |'
- en: '| `1` | The command failed due to an unexpected error. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `1` | 由于意外错误，命令执行失败。 |'
- en: '| `2` | The command was unable to find the specified resource or encountered
    a similar issue. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `2` | 命令无法找到指定的资源或遇到类似的问题。 |'
- en: '| `125` | The command failed due to a Docker-related error. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `125` | 由于 Docker 相关错误，命令执行失败。 |'
- en: '| `126` | The command failed because the Docker binary or script could not
    be executed. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `126` | 命令执行失败，因为 Docker 二进制文件或脚本无法执行。 |'
- en: '| `127` | The command failed because the Docker binary or script could not
    be found. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `127` | 命令执行失败，因为无法找到 Docker 二进制文件或脚本。 |'
- en: '| `128+` | The command failed due to a specific Docker-related error or exception.
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `128+` | 由于特定的与 Docker 相关的错误或异常，命令执行失败。 |'
- en: 'Table 1.3: Docker exit codes'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.3：Docker 退出码
- en: docker start and stop
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker 启动和停止
- en: You may need to stop a container due to limited system resources, limiting you
    to running a few containers simultaneously. To stop a running container and free
    up resources, use the `docker stop` command with the name of the container, or
    the container ID, you want to stop.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要停止一个容器，因为系统资源有限，限制了你同时运行的容器数量。要停止一个正在运行的容器并释放资源，可以使用`docker stop`命令，后面跟上你要停止的容器名称或容器
    ID。
- en: If you need to start that container at a future time for additional testing
    or development, execute `docker start <name>`, which will start the container
    with all of the options that it was originally started with, including any networks
    or volumes that were assigned.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在未来某个时刻重新启动该容器进行额外的测试或开发，可以执行`docker start <name>`，这将以原始启动时的所有选项启动容器，包括任何分配的网络或卷。
- en: docker attach
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker attach
- en: In order to troubleshoot an issue or inspect a log file, it may be necessary
    to interact with a container. One way to connect to a container that is currently
    running is by using the `docker attach <container ID/name>` command. When you
    perform this action, you establish a connection with the active process of the
    running container. If you attach to a container that is executing a process, it
    is unlikely that you will see any prompt. In fact, it’s likely that you will see
    a blank screen for a period of time until the container starts producing output
    that is displayed on the screen.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了排查问题或查看日志文件，可能需要与容器进行交互。连接到当前正在运行的容器的一种方法是使用`docker attach <容器 ID/名称>`命令。当你执行此操作时，你将与运行容器的活动进程建立连接。如果你连接到一个正在执行进程的容器，通常不会看到任何提示信息。事实上，很可能你会看到一个空白屏幕，直到容器开始产生并显示在屏幕上的输出。
- en: 'You should always be cautious when attaching to a container. It’s easy to accidentally
    stop the running process and, in turn, stop the container. Let’s use an example
    of attaching to a web server running NGINX. First, we need to verify that the
    container is running using `docker ps`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接到一个容器时，你应该始终保持谨慎。很容易不小心停止正在运行的进程，从而停止容器。让我们以连接一个运行 NGINX 的 Web 服务器为例。首先，我们需要通过`docker
    ps`验证容器是否正在运行：
- en: '[PRE13]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using the `attach` command, we execute `docker attach 4a77c14a236a`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`attach`命令，我们执行`docker attach 4a77c14a236a`。
- en: 'When you attach to a process, you will only be able to interact with the running
    process, and the only output you will see is data being sent to standard output.
    In the case of the NGINX container, the `attach` command has been attached to
    the NGINX process. To show this, we will leave the attachment and `curl` to the
    web server from another session. Once we `curl` to the container, we will see
    logs outputted to the attached console:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当您附加到一个进程时，您将只能与正在运行的进程交互，并且您看到的唯一输出是发送到标准输出的数据。以 NGINX 容器为例，`attach` 命令已附加到
    NGINX 进程。为了展示这一点，我们将退出附加并从另一个会话中对 Web 服务器执行 `curl`。一旦我们对容器执行 `curl`，我们将看到日志输出到附加的控制台：
- en: '[PRE14]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We mentioned that you need to be careful once you attach to the container.
    Those who are new to Docker may attach to the NGINX image and assume that nothing
    is happening on the server or a process appears to be hung so they may decide
    to break out of the container using the standard *Ctrl* + *C* keyboard command.
    This will stop the container and send them back to a Bash prompt, where they may
    run `docker ps` to look at the running containers:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过，一旦你附加到容器，就需要小心。对于新手来说，可能会附加到 NGINX 镜像，假设服务器上没有发生任何事情，或者进程似乎卡住了，因此他们可能决定使用标准的
    *Ctrl* + *C* 键盘命令跳出容器。这将停止容器并将他们带回 Bash 提示符，在这里他们可以运行 `docker ps` 来查看正在运行的容器：
- en: '[PRE15]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What happened to the NGINX container? We didn’t execute a `docker stop` command,
    and the container was running until we attached to the container. Why did the
    container stop after we attached to it?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX 容器发生了什么？我们没有执行 `docker stop` 命令，而容器一直在运行，直到我们附加到容器。为什么我们附加到容器后，容器会停止？
- en: As we mentioned, when an attachment is made to a container, you are attached
    to the running process. All keyboard commands will act in the same way as if you
    were at a physical server that was running NGINX in a regular shell. This means
    that when the user used *Ctrl* + *C* to return to a prompt, they stopped the running
    NGINX process.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，当附加到容器时，您实际上是附加到正在运行的进程上。所有键盘命令的行为就像您在一台运行 NGINX 的物理服务器上的常规 shell 中一样。这意味着，当用户使用
    *Ctrl* + *C* 返回到提示符时，他们实际上停止了正在运行的 NGINX 进程。
- en: 'If we press *Ctrl* + *C* to exit the container, we will receive an output that
    shows that the process has been terminated. The following output shows an example
    of what happens in our NGINX example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按下 *Ctrl* + *C* 来退出容器，我们将看到一个输出，显示进程已被终止。以下输出展示了在我们的 NGINX 示例中发生的情况：
- en: '[PRE16]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If a container’s running process stops, the container will also stop, and that’s
    why the `docker ps` command does not show a running NGINX container.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器的运行进程停止，容器也会停止，这就是为什么 `docker ps` 命令没有显示正在运行的 NGINX 容器。
- en: To exit an attachment, rather than use *Ctrl* + *C* to return to a prompt, you
    should have used *Ctrl* + *P*, followed by *Ctrl* + *Q*, which will exit the container
    without stopping the running process.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出附加会话，而不是使用 *Ctrl* + *C* 返回到提示符，您应该使用 *Ctrl* + *P*，然后按 *Ctrl* + *Q*，这将退出容器而不停止正在运行的进程。
- en: 'There is an alternative to the `attach` command: the `docker exec` command.
    The `exec` command differs from the `attach` command since you supply the process
    to execute on the container.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个替代 `attach` 命令的方法：`docker exec` 命令。`exec` 命令与 `attach` 命令不同，因为您需要提供要在容器中执行的进程。
- en: docker exec
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker exec
- en: A better option when it comes to interacting with a running container is the
    `exec` command. Rather than attach to the container, you can use the `docker exec`
    command to execute a process in the container. You need to supply the container
    name and the process you want to execute in the image. Of course, the process
    must be included in the running image – if you do not have the Bash executable
    in the image, you will receive an error when trying to execute Bash in the container.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在与正在运行的容器交互时，一个更好的选择是 `exec` 命令。与其附加到容器，您可以使用 `docker exec` 命令在容器中执行进程。您需要提供容器名称以及您想在镜像中执行的进程。当然，进程必须包含在运行的镜像中——如果镜像中没有
    Bash 可执行文件，在尝试执行 Bash 时将会出现错误。
- en: 'We will use an NGINX container as an example again. We will verify that NGINX
    is running using `docker ps` and then, using the container ID or the name, we
    execute into the container. The command syntax is `docker exec <options> <container
    name> <command>`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用 NGINX 容器作为示例。我们将使用 `docker ps` 来验证 NGINX 是否在运行，然后使用容器 ID 或名称执行进入容器的操作。命令语法是
    `docker exec <options> <container name> <command>`：
- en: '[PRE17]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The option we included is `-it`, which tells the `exec` to run in an interactive
    TTY session. Here, the process we want to execute is Bash.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含的选项是`-it`，它告诉`exec`在交互式TTY会话中运行。在这里，我们希望执行的进程是Bash。
- en: Notice how the prompt name changed from the original user and hostname. The
    hostname is `localhost`, while the container name is `a7c916e7411`. You may also
    have noticed that the current working directory changed from `~` to `/app` and
    that the prompt is not running as a root user, as shown by the `$` prompt.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到提示符的名称已经从原来的用户名和主机名发生了变化。主机名是`localhost`，而容器名称是`a7c916e7411`。你可能还注意到当前的工作目录从`~`变成了`/app`，并且提示符显示不是以root用户身份运行（如显示的`$`提示符）。
- en: You can use this session the same way you would a standard **SSH** connection;
    you are running Bash in the container and since we are not attached to the running
    process in the container, *Ctrl* + *C* will not stop any process from running.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像使用标准的**SSH**连接一样使用这个会话；你在容器中运行Bash，并且因为我们没有附加到容器中的运行进程，*Ctrl* + *C*不会停止任何正在运行的进程。
- en: To exit an interactive session, you only need to type in `exit`, followed by
    *Enter*, which will exit the container. If you then run `docker ps`, you will
    notice that the container is still in a running state.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出交互式会话，你只需要输入`exit`，然后按*Enter*，这将退出容器。如果你接着运行`docker ps`，你会注意到容器仍然处于运行状态。
- en: Next, let’s see what we can learn about Docker log files.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们能从Docker日志文件中学到什么。
- en: docker logs
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker logs
- en: The `docker logs` command allows you to retrieve logs from a container using
    the container name or container ID. You can view the logs from any container that
    is listed in your `ps` command; it doesn’t matter if it’s currently running or
    stopped.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker logs`命令允许你使用容器名称或容器ID从容器中获取日志。你可以查看`ps`命令中列出的任何容器的日志，无论该容器是否正在运行或已停止。'
- en: Log files are often the only way to troubleshoot why a container may not be
    starting up, or why a container is in an exited state. For example, if you attempt
    to run an image and the image starts and suddenly stops, you may find the answer
    by looking at the logs for that container.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件通常是排查容器无法启动或处于退出状态的唯一方法。例如，如果你尝试运行一个镜像，镜像启动后突然停止，你可以通过查看该容器的日志来找到问题所在。
- en: To look at the logs for a container, you can use the `docker logs <container
    ID or name>` command.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看容器的日志，你可以使用`docker logs <容器ID或名称>`命令。
- en: 'To view the logs for a container with a container ID of `7967c50b260f`, you
    would use the following command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看容器ID为`7967c50b260f`的容器的日志，你可以使用以下命令：
- en: '[PRE18]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will output the logs from the container to your screen, which may be very
    long and verbose. Since many logs may contain a lot of information, you can limit
    the output by supplying the `logs` command with additional options. The following
    table lists the options available for viewing logs:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把容器的日志输出到你的屏幕上，日志内容可能非常长且冗杂。由于许多日志可能包含大量信息，你可以通过为`logs`命令添加额外选项来限制输出。下表列出了查看日志时可用的选项：
- en: '| **Log Options** | **Description** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **日志选项** | **描述** |'
- en: '| `-f` | Follow the log output (can also use `--follow`). |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `-f` | 跟踪日志输出（也可以使用`--follow`）。 |'
- en: '| `--tail xx` | Show the log output starting from the end of the file and retrieve
    `xx` lines. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `--tail xx` | 从文件末尾开始显示日志输出并检索`xx`行。 |'
- en: '| `--until xxx` | Show the log output before the `xxx` timestamp.`xxx` can
    be a timestamp; for example, `2020-02-23T18:35:13`.`xxx` can be a relative time;
    for example, `60m`. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `--until xxx` | 显示在`xxx`时间戳之前的日志输出。`xxx`可以是时间戳，例如`2020-02-23T18:35:13`；`xxx`也可以是相对时间，例如`60m`。
    |'
- en: '| `--since xxx` | Show the log output after the `xxx` timestamp.`xxx` can be
    a timestamp; for example, `2020-02-23T18:35:13`.`xxx` can be a relative time;
    for example, `60m`. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `--since xxx` | 显示从`xxx`时间戳之后的日志输出。`xxx`可以是时间戳，例如`2020-02-23T18:35:13`；`xxx`也可以是相对时间，例如`60m`。
    |'
- en: 'Table 1.4: Log options'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.4：日志选项
- en: Checking log files is a process you will find yourself doing often, and since
    they can be very lengthy, knowing options like `tail`, `until`, and `since` will
    help you to find the information in a log quicker.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 查看日志文件是你经常需要做的一个操作，由于日志文件可能非常长，了解像`tail`、`until`和`since`这样的选项可以帮助你更快地找到日志中的信息。
- en: docker rm
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker rm
- en: 'Once you assign a name to a container, the assigned name cannot be used on
    a different container unless you remove it using the `docker rm` command. If you
    had a container running called `nginx-test` that was stopped and you attempted
    to start another container with the name `nginx-test`, the Docker daemon would
    return an error, stating that the name is in use:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你为容器指定了一个名称，除非使用`docker rm`命令删除它，否则该名称不能用于其他容器。如果你有一个名为`nginx-test`的容器，并且它已停止运行，尝试启动另一个名为`nginx-test`的容器时，Docker守护进程会返回一个错误，提示该名称正在使用：
- en: '[PRE19]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The original `nginx-test` container is not running, but the daemon knows that
    the container name was used previously and that it’s still in the list of previously
    run containers.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`nginx-test`容器没有运行，但守护进程知道该容器名称之前已被使用，并且它仍然存在于之前运行的容器列表中。
- en: When you want to reuse a specific name, you must first remove the existing container
    before launching a new one with the same name. This scenario commonly occurs during
    container image testing. You may initially start a container but encounter issues
    with the application or image. In such instances, you would stop the container,
    resolve the problems with the image or application, and wish to redeploy it using
    the same name. However, since the previous container with that name still exists
    in the Docker history, it becomes necessary to remove it before reutilizing the
    name.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要重用一个特定名称时，必须先删除已有的容器，然后才能用相同的名称启动一个新的容器。这种情况通常发生在容器镜像测试期间。你可能最初启动了一个容器，但遇到了应用或镜像问题。在这种情况下，你会停止容器，解决镜像或应用的问题，并希望使用相同的名称重新部署它。然而，由于之前的容器仍存在于Docker历史记录中，因此在重新利用该名称之前必须先将其删除。
- en: You can also add the `--rm` option to your Docker command to automatically remove
    the image after it is stopped.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以向Docker命令中添加`--rm`选项，以在容器停止后自动删除镜像。
- en: 'To remove the `nginx-test` container, simply execute `docker rm nginx-test`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除`nginx-test`容器，只需执行`docker rm nginx-test`：
- en: '[PRE20]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Assuming the container name is correct and it’s not running, the only output
    you will see is the name of the image that you have removed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 假设容器名称正确并且该容器未运行，你看到的唯一输出将是你已删除的镜像名称。
- en: We haven’t discussed Docker volumes, but when removing a container that has
    a volume, or volumes, attached, it’s a good practice to add the `-v` option to
    your remove command. Adding the `-v` option to the `docker rm` command will remove
    any volumes that were attached to the container.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论Docker卷，但当删除一个附带卷的容器时，最好在删除命令中添加`-v`选项。将`-v`选项添加到`docker rm`命令中将删除任何附加到容器的卷。
- en: docker pull/run
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker pull/run
- en: When running a `pull`, make sure to specify the architecture. `docker` `pull`
    and `run` are used to either pull an image or run an image. If you try to run
    a container that doesn’t exist on the Docker host already, it will initiate a
    `pull` request to get the container and then run it.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`pull`时，确保指定架构。`docker`的`pull`和`run`用于拉取镜像或运行镜像。如果你尝试运行一个在Docker主机上尚不存在的容器，它将启动一个`pull`请求来获取该容器并运行它。
- en: 'When you attempt to `pull` or `run` a container, Docker will download a container
    that is compatible with the host’s architecture. If you want to download a different
    image that is based on a different architecture, you can add the `--platform`
    tag to the `build` command. For example, if you are on a system that is running
    on arm64 architecture and you want to pull an x86 image, you would add `linux/arm64`
    as your platform. When running a pull, make sure to specify the architecture:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试`pull`或`run`一个容器时，Docker会下载与主机架构兼容的容器。如果你想下载基于不同架构的镜像，可以在`build`命令中添加`--platform`标签。例如，如果你使用的是arm64架构的系统，并且想要拉取一个x86镜像，你需要将`linux/arm64`作为平台。运行`pull`时，确保指定架构：
- en: '[PRE21]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Adding `--platform=linux/amd64` is what told Docker to get the right platform.
    You can use the same parameter for `docker run` to make sure that the right container
    image platform is used.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`--platform=linux/amd64`就是告诉Docker获取正确的平台。你可以对`docker run`使用相同的参数，以确保使用正确的容器镜像平台。
- en: docker build
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker build
- en: 'Similar to `pull` and `run`, Docker will attempt to build the image based on
    the host’s architecture: `arm64`. Assuming you are building on an arm64-based
    image system, you can tell Docker to create an x86 image by using the `buildx`
    sub-command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 与`pull`和`run`类似，Docker会尝试基于主机架构`arm64`来构建镜像。假设你是在一个基于arm64的镜像系统上构建，你可以通过使用`buildx`子命令来让Docker创建一个x86镜像：
- en: '[PRE22]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This addition tells Docker to generate the `x86` version, which will run on
    any x86-based hardware.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个附加选项告诉 Docker 生成 `x86` 版本，它将在任何基于 x86 的硬件上运行。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how Docker can be used to solve common development
    issues, including the dreaded “it works on my machine” problem. We also presented
    an introduction to the most commonly used Docker CLI commands that you will use
    on a daily basis.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 Docker 如何解决常见的开发问题，包括让人头痛的“它在我的机器上能运行”问题。我们还介绍了你在日常使用中会用到的最常用的 Docker
    CLI 命令。
- en: In the next chapter, we will start our Kubernetes journey with an introduction
    to **KinD**, a utility that provides an easy way to run multi-node Kubernetes
    test servers on a single workstation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始 Kubernetes 之旅，介绍 **KinD**，这是一个实用工具，提供了一种在单台工作站上运行多节点 Kubernetes
    测试服务器的简便方法。
- en: Questions
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: A **single** Docker image can be used on any Docker host, regardless of the
    architecture used.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单一** Docker 镜像可以在任何 Docker 主机上使用，无论使用什么架构。'
- en: 'True'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: 'Answer: b'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：b
- en: We added the topic of cross-platform images
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们增加了跨平台镜像的主题
- en: What does Docker use to merge multiple image layers into a single filesystem?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 用什么来将多个镜像层合并为一个单一的文件系统？
- en: Merged filesystem
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并文件系统
- en: NTFS filesystem
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: NTFS 文件系统
- en: EXT4 filesystem
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: EXT4 文件系统
- en: Union filesystem
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联合文件系统
- en: 'Answer: d'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：d
- en: Kubernetes is only compatible with the Docker runtime engine.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 仅与 Docker 运行时引擎兼容。
- en: 'True'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: 'Answer: b'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：b
- en: When you edit a container’s filesystem interactively, what layer are the changes
    written to?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你交互式编辑容器的文件系统时，变更会写入哪个层？
- en: OS layer
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作系统层
- en: Bottom-most layer
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最底层
- en: Container layer
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器层
- en: Ephemeral layer
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 临时层
- en: 'Answer: c'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：c
- en: Assuming the image contains the required binaries, what Docker command allows
    you to gain access to a running container’s bash prompt?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设镜像包含所需的二进制文件，哪个 Docker 命令允许你访问正在运行的容器的 bash 提示符？
- en: '`docker shell -it <container> /bin/bash`'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker shell -it <container> /bin/bash`'
- en: '`docker run -it <container> /bin/bash`'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker run -it <container> /bin/bash`'
- en: '`docker exec -it <container> /bin/bash`'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker exec -it <container> /bin/bash`'
- en: '`docker spawn -it <container> /bin/bash`'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker spawn -it <container> /bin/bash`'
- en: 'Answer: c'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：c
- en: If you start a container with a simple `run` command, without any flags, and
    the container is stopped, the Docker daemon will delete all traces of the container.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用简单的 `run` 命令启动一个容器，并且没有任何标志，而且容器被停止，Docker 守护进程将删除容器的所有痕迹。
- en: 'True'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: 'Answer: b'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：b
- en: What command will show you a list of all containers, including any stopped containers?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令将显示所有容器的列表，包括任何已停止的容器？
- en: '`docker ps -all`'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker ps -all`'
- en: '`docker ps -a`'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker ps -a`'
- en: '`docker ps -list`'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker ps -list`'
- en: '`docker list all`'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker list all`'
- en: 'Answer: b'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：b
- en: Join our book’s Discord space
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们书籍的 Discord 空间
- en: 'Join the book’s Discord workspace for a monthly *Ask Me Anything* session with
    the authors:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 加入本书的 Discord 工作区，参加每月一次的*问我任何问题*环节，与作者们互动：
- en: '[https://packt.link/K8EntGuide](https://packt.link/K8EntGuide)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/K8EntGuide](https://packt.link/K8EntGuide)'
- en: '![](img/QR_Code965214276169525265.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code965214276169525265.png)'
