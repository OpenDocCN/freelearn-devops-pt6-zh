- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Edge Computing with Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Edge computing is an emerging paradigm of distributed systems where the units
    that compute information are close to the origin of that information. The benefit
    of this paradigm is that it helps your system to reduce network outages and reduces
    the delays when you process across the cloud. This means you get a better interactive
    experience with your machine learning or **Internet of Things** (**IoT**) applications.
    This chapter covers the basics and the importance of edge computing and how Kubernetes
    can be used for it. It also covers different scenarios and basic architectures
    using low-power devices, which can use private and public clouds to exchange data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Edge data centers using K3s and basic edge computing concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic edge computing architectures with K3s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapting your software to run at the edge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to run our edge computing on an edge device (such
    as a **Raspberry Pi**), so we need to set up a cross-compiling toolchain for **Advanced
    RISC Machines** (**ARM**).
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you need one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Mac with terminal access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PC with Ubuntu installed with terminal access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A virtual machine with Ubuntu installed with terminal access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more detail and code snippets, check out this resource on GitHub: [https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch1](https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch1).'
  prefs: []
  type: TYPE_NORMAL
- en: Edge data centers using K3s and basic edge computing concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the evolution of the cloud, companies and organizations are starting to
    migrate their processing tasks to edge computing devices, with the goal to reduce
    costs and get more benefits for the infrastructure that they are paying for. As
    a part of the introductory content in this book, we must learn about the basic
    concepts related to edge computing and understand why we use K3s for edge computing.
    So, let’s get started with the basic concepts.
  prefs: []
  type: TYPE_NORMAL
- en: The edge and edge computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the Qualcomm and Cisco companies, the edge can be defined as *“anywhere
    where data is processed before it crosses the Wide Area Network (WAN)”*; this
    is the edge, but what is edge computing? A post by Eric Hamilton from Cloudwards.net
    defines edge computing as *“the processing and analyzing of data along a network
    edge, closest to the point of its collection, so that data becomes actionable.”*
    In other words, edge computing refers to processing your data near to the source
    and distributing the computation in different places, using devices that are close
    to the source of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add more context, let’s explore the next figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Components of edge layers](img/B16945_Figure_1.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Components of edge layers
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure shows how the data is processed in different contexts; these contexts
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cloud layer**: In this layer, you can find the cloud providers, such as AWS,
    Azure, GCP, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Near edge**: In this layer, you can find telecommunications infrastructure
    and devices, such as 5G networks, radio virtual devices, and similar devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Far edge**: In this layer, you will find edge clusters, such as K3s clusters
    or devices that exchange data between the cloud and edge layer, but this layer
    can be subdivided into the tiny edge layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tiny edge**: In this layer, you will find sensors, end-user devices that
    exchange data with a processing device, and edge clusters on the far edge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that edge computing refers to data that is processed on edge devices
    before the result goes to its destination, which could be on a public or private
    cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other important concepts to consider for building edge clusters are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fog computing**: An architecture of cloud services that distribute the system
    across near edge and far edge devices; these devices can be geographically dispersed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-Access Edge Computing** (**MEC**): This distributes the computing at
    the edge of larger networks, with low latency and high bandwidth, and is the predecessor
    of mobile edge computing; in other words, the processing uses telecom networks
    and mobile devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloudlets**: This is a small-scale cloud data center, which could be used
    for resource-intensive use cases, such as data analytics, **Machine Learning**
    (**ML**) and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits of edge computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With this short explanation, let’s move on to understand the main benefits
    of edge computing; some of these include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reducing latency**: Edge computing can process heavy compute processes on
    edge devices, reducing the latency to bring this information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reducing bandwidth**: Edge computing can reduce the used bandwidth while
    taking part of the data on the edge devices, reducing the traffic on the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reducing costs**: Reducing latency and bandwidth translates to the reduction
    of operational costs, which is one of the most important benefits of edge computing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improving security**: Edge computing uses data aggregation and data encryption
    algorithms to improve the security of data access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s now discuss containers, Docker, and containerd.
  prefs: []
  type: TYPE_NORMAL
- en: Containers, Docker, and containerd for edge computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the last few years, container adoption has been increasing because of the
    success of Docker. Docker has been the most popular container engine for the last
    few years. Container technology gives businesses a way to design applications
    using microservices architecture. This way, companies speed up their development
    and strategies for scaling their applications. So, to begin with a basic concept:
    *A container is a small runtime environment that packages your application with
    all the dependencies needed for it to run.* This concept is not new, but Docker,
    a container engine, popularized this concept. In simple words, Docker uses small
    operating system images with the necessary dependencies to run your software.
    This can be called operating system virtualization. What this does is use the
    **cgroups** kernel feature of Linux to limit CPU, memory, network, I/O, and so
    on for your processes. Other operating systems, such as Windows or FreeBSD, use
    similar features to insulate and create this type of virtualization. Let’s see
    the next figure to represent these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Containerized applications inside the OS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_Figure_1.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – Containerized applications inside the OS
  prefs: []
  type: TYPE_NORMAL
- en: This figure shows that a container doesn’t depend on special features, such
    as a hypervisor that is commonly seen in hardware virtualization used by VMware,
    Hyper-V, and Xen; instead of that, the application runs as a binary inside the
    container and reuses the host kernel. Let’s say that running a container is almost
    like running a binary program inside a directory but adds some resource limits,
    using cgroups in the case of Linux containers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker implements all these abstractions. It is a popular container toolchain
    that adds some versioning features, such as Git. That was the main reason it became
    very popular, and it features easy portability and versioning at the operating
    system level. At the moment, containerd is the container runtime used by Docker
    and Kubernetes to create containers. In general, with containerd, you can create
    containers without extra features; it’s very optimized. With the explosion of
    edge computing, containerd has become an important piece of software to run containers
    in low-resource environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, with all these technologies you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Standardize how to package your software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bring portability to your software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain your software in an easier way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run applications in low-resource environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, Docker must be taken into consideration as an important software piece to
    build edge computing and low-resource environments.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed systems, edge computing, and Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last decade, distributed systems evolved from multi-node clusters with
    applications using monolithic architectures to multi-node clusters with microservices
    architectures. One of the first options to start building microservices is to
    use containers, but once the system needs to scale, it is necessary to use an
    orchestrator. This is where Kubernetes comes into the game.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s imagine an orchestra with lots of musicians. You can find
    musicians playing the piano, trumpets, and so on. But if the orchestra was disorganized,
    what would you need to have to organize all the musicians? The answer is an orchestra
    director or an orchestrator. Here is when Kubernetes appears; each musician is
    a container that needs to communicate or listen to other musicians and, of course,
    follow the instructions of the orchestra director or orchestrator. In this way,
    all the musicians can play their instruments at the right time and can sound beautiful.
  prefs: []
  type: TYPE_NORMAL
- en: This is what Kubernetes does; it is an orchestrator of containers, but at the
    same time it is a platform with all the necessary prebuilt pieces to build your
    own distributed system, ready to scale and designed with best practices that can
    help you to implement agile development and a DevOps culture. Depending on your
    use case, sometimes it’s better to use something small such as Docker or containerd,
    but for complex or demanding scenarios, it’s better to use Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Edge clusters using K3s – a lightweight Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, the big question is how to start building edge computing systems. Let’s
    get started with K3s. K3s is a Kubernetes-certified distribution created by Rancher
    Labs. K3s doesn’t include by default extra features that are not vital to be used
    on Kubernetes, but they can be added later. K3s uses containerd as its container
    engine, which gives K3s the ability to run on low-resource environments using
    ARM devices. For example, you can also run K3s on x86_64 devices in production
    environments. However, for the purpose of this book, we will use K3s as our main
    piece of software to build edge computing systems using ARM devices.
  prefs: []
  type: TYPE_NORMAL
- en: Talking about clusters at the edge, K3s offers the same power as Kubernetes
    but in a small package and in an optimized way, plus some features designed especially
    for edge computing systems. K3s is very easy to use, compared with other Kubernetes
    distributions. It’s a lightweight Kubernetes that can be used for edge computing,
    sandbox environments, or whatever you want, depending on the use case.
  prefs: []
  type: TYPE_NORMAL
- en: Edge devices using ARM processors and micro data centers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, it’s time to talk about edge devices and ARM processors, so let’s begin
    with edge devices. Edge devices are designed to process and analyze information
    near to the data source location; this is where the *edge* computing mindset comes
    from. Talking about low-energy consumption devices, x86 or Intel processors consume
    more energy and get warmer than ARM processors. This means more power and more
    cooling; in other words, you will pay more money for x86_64 processors. On the
    other hand, ARM processors have less computational power and consume less energy.
    That’s the reason for the success of ARM processors on smartphone devices; they
    give you better cost and benefit between processing and energy consumption compared
    to Intel processors.
  prefs: []
  type: TYPE_NORMAL
- en: Because of that, companies are interested in designing micro data centers using
    ARM processors in their servers. For the same reason, companies are starting to
    migrate their workloads to be processed by devices using ARM processors. One example
    is the AWS Graviton2, which is a service that offers cloud instances using ARM
    processors.
  prefs: []
  type: TYPE_NORMAL
- en: Edge computing diagrams to build your system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, with all the basic concepts of containers, orchestrators, and edge
    computing and its layers, we can focus on the five basic diagrams of edge computing
    configurations that you can use to design this kind of system. So, let’s use K3s
    as our main platform for edge computing for the next diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: Edge cluster and public cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This configuration shares and processes data between the public or private
    cloud with edge layers, but let’s explain its different layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cloud layer**: This layer is in the public cloud and its provider, such as
    AWS, Azure, or GCP. This provider can offer instances using Intel or ARM processors.
    For example, AWS offers the AWS Graviton2 instance if you need an ARM processor.
    As a complement, the public cloud can offer managed services to store data such
    as databases, storage, and so on. The private cloud could be in this layer too.
    You can find software such as VMware ESXi or OpenStack to provide this kind of
    service or instance locally. You can even choose a hybrid approach using the public
    and the private cloud. In general, this layer supports your far and tiny edge
    layers for storage or data processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Near edge**: In this layer, you can find network devices to move all the
    data between the cloud layer and the far layer. Typically, these include telco
    devices, 5G networks, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Far edge**: In this layer, you can find K3s clusters, similar lightweight
    clusters such as KubeEdge, and software such as Docker or containerd. In general,
    this is your local processing layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tiny edge**: This is a layer inside the far edge, where you can find edge
    devices such as smartwatches, IoT devices, and so on, which send data to the far
    edge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Edge cluster and public cloud'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_Figure_1.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 – Edge cluster and public cloud
  prefs: []
  type: TYPE_NORMAL
- en: 'Use cases include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Scenarios where you must share data between different systems across the internet
    or a private cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distribute data processing between your cloud and the edge, such as a machine
    learning model generation or predictions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scenarios where you must scale IoT applications, and the response time of the
    application is critical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scenarios where you want to secure your data using the aggregation strategy
    of distributing data and encryption across the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regional edge clusters and public cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This configuration is focused on distributing the processing strategy across
    different regions and sharing data across a public cloud. Let’s explain the different
    layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cloud layer**: This layer contains managed services such as databases to
    distribute the data across different regions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Near edge**: In this layer, you can find network devices to move all the
    data between the cloud layer and the far layer. Typically, this includes telco
    devices, 5G networks, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Far edge**: In this layer, you can find K3s clusters across different regions.
    These clusters or nodes can share or update the data stored in a public cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tiny edge**: Here, you can find different edge devices close to each region
    where the far edge clusters process the information because of this distributed
    configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Regional edge cluster and public cloud'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_Figure_1.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.4 – Regional edge cluster and public cloud
  prefs: []
  type: TYPE_NORMAL
- en: 'Use cases include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Different cluster configurations across different regions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing application response time, choosing the closest data, or processing
    node location, which is critical in IoT applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing data across different regions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributing processing across different regions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single node cluster and public/private cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a basic configuration where a single computer processes all the information
    captured on tiny edge devices. Let’s explain the different layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cloud layer**: In this layer, you can find the data storage for the system.
    It could be placed on the public or private cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Near edge**: In this layer, you can find network devices to move all the
    data between the cloud layer and the far layer. Typically, this includes telco
    devices, 5G networks, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Far edge**: In this layer, you can find a single node K3s cluster that recollects
    data from tiny edge devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tiny edge**: Devices that capture data, such as smartwatches, tablets, cameras,
    sensors, and so on. This kind of configuration is more for processing locally
    or on a small scale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Single node cluster and public/private cloud'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_Figure_1.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.5 – Single node cluster and public/private cloud
  prefs: []
  type: TYPE_NORMAL
- en: 'Use cases include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Low-cost and low-energy consumption environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Green edge applications that can be powered by solar panels or wind turbines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small processes or use cases, such as analyzing health records or autonomous
    house systems that need something local or not too complicated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s now adapt the software to run at the edge.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting your software to run at the edge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Something important while designing an edge computing system is to choose the
    processor architecture to build your software. One popular architecture because
    of the lower consumption for computing is ARM, but if ARM is the selected architecture,
    it is necessary to transform your current code in most of the cases from x86_64
    (Intel) to ARM (ARMv7 such as RI and ARM such as AWS Graviton2 instances). The
    following subsections include short guides to perform the process to convert from
    one platform to another; this process is called cross-compiling. With this, you
    will be able to run your software on ARM devices using Go, Python, Rust, and Java.
    So, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting Go to run on ARM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, it’s necessary to install Go on your system. Here are a couple of ways
    to install Go.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Go on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install Go on Linux, execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and untar the Go official binaries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the environment variables to run Go:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set your `GOPATH` in the configuration file of your terminal with the following
    lines. `~/.profile` is a common file to set these environment variables; let’s
    modify the `.profile` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load the new configuration using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '(*Optional*). If you want to, you can set these environment variables temporarily
    in your terminal using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check whether `GOPATH` is configured, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you are ready to use Go on Linux. Let’s move to this installation using
    a Mac.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Go on a Mac
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install Go on a Mac, execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Homebrew (called `brew`) with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once it is installed, install Go with `brew`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: To find out how to install `brew`, you can check the official page at [https://brew.sh](https://brew.sh).
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling from x86_64 to ARM with Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To cross-compile from x86_64 to ARM, execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder to store your code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an initial Go configuration to install external Go libraries outside
    the `GOPATH` command; for this, execute the next command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `example.go` file with `Hello World` as its contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assuming that your environment is under x86_64 and you want to cross-compile
    for ARMv7 support, execute the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the next line for ARMv8 64-bit support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see other options for cross-compiling, see [https://github.com/golang/go/wiki/GoArm](https://github.com/golang/go/wiki/GoArm).
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the execution permissions for the generated binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Copy the generated binary to your ARM device and test if it works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we will learn how to adapt Rust to run on ARM.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting Rust to run on ARM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, it’s necessary to install Rust on your system. Here are a couple of ways
    to install Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Rust on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install Rust on Linux, execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Rust by executing the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the path for Rust in the configuration file of your terminal. For example,
    if you are using Bash, add the following line to your `.bashrc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Installing Rust on a Mac
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install Rust on a Mac, execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Homebrew with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once it is installed, install `rustup` with `brew`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `rustup` command to install Rust and all the necessary tools for Rust
    with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set your terminal environment variables by adding the following line to your
    terminal configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Mac users often use the ZSH terminal, so they have to use `.zshrc`. If you are
    using another terminal, look for the proper configuration file or the generic
    `/etc/profile`.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling from x86_64 to ARMv7 with Rust on a Mac
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To cross-compile from x86_64 to ARM, execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the complements to match the compiler and environment variables for
    ARMv7 architecture on your Mac; for this, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Download the support for ARMv7 for cross-compiling by executing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now set the environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a folder to store your code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an initial `Hello World` project with Rust:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The generated Rust code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The source code will be located at `src/main.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the support for ARMv7:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build your software:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy the binary file into your device and test whether it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The generated binary will be inside the `target/armv7-unknown-linux-gnueabi/hello-rust`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now copy your binary into your device and test whether it works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: For more options for cross-compiling with Rust, check out [https://doc.rust-lang.org/nightly/rustc/platform-support.html](https://doc.rust-lang.org/nightly/rustc/platform-support.html)
    and [https://rust-lang.github.io/rustup/cross-compilation.html](https://rust-lang.github.io/rustup/cross-compilation.html).
    For the toolchain for Mac and AArch64 (64-bit ARMv8), check out `aarch64-unknown-linux-gnu`
    inside the repository at [https://github.com/messense/homebrew-macos-cross-toolchains](https://github.com/messense/homebrew-macos-cross-toolchains).
  prefs: []
  type: TYPE_NORMAL
- en: Adapting Python to run on ARM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, it is necessary to install Python on your system. There are a couple
    of ways of doing this.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install Python, execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your repositories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install Python 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Install Python on a Mac
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install Python on a Mac using Homebrew, execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check for your desired Python version on brew’s available version list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s say that you choose Python 3.8; you have to install it by executing the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test your installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Cross-compiling from x86_64 to ARM with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python is very important and one of the most popular languages now, and it is
    commonly used for AI and ML applications. Python is an interpreted language; it
    needs a runtime environment (such as Java) to run the code. In this case, you
    must install Python as the runtime environment. It has similar challenges running
    code as Java but has other challenges too. Sometimes, you need to compile libraries
    from scratch to use it. The standard Python libraries currently support ARM, but
    the issue is when you want something outside those standard libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a basic example, let’s run Python code across different platforms by executing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a basic file called `example.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Copy `example.py` to your ARM device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install Python 3 on your ARM device by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run your code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Adapting Java to run on ARM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When talking about Java to run on ARM devices, it is a little bit different.
    Java uses a hybrid compiler – in other words, a two-phase compiler. This means
    that it generates an intermediate code called bytecode and is interpreted by a
    **Java Virtual Machine** (**JVM)**. This bytecode is a cross-platform code and,
    following the Java philosophy of *compile once and run everywhere*, it means that
    you can compile using the platform you want, and it will run on any other platform
    without modifications. So, let’s see how to perform cross-compiling for a basic
    Java program that can run on an ARMv7 and an ARMv8 64-bit device.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Java JDK on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install Java on Linux, execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the current repositories of Ubuntu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the official JDK 8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test whether `javac` runs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Installing Java JDK on a Mac
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you don’t have Java installed on your Mac, follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '(*Optional*) Download Java JDK from the following link and choose the architecture
    that you need, such as Linux, Mac, or Windows: [https://www.oracle.com/java/technologies/javase-downloads.html](https://www.oracle.com/java/technologies/javase-downloads.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (*Optional*) Download and run the installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test whether Java exists or whether it was installed correctly, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Test whether the compiler is installed by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Cross-compiling from x86_64 to ARM with Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Java is a language that generates an intermediate code called bytecode, which
    runs on the JVM. Let’s say that you have a basic code in a file called `Example.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute your code, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile it, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will generate the intermediate code in a file called `Example.class`, which
    can be executed by the JVM. Let’s do this in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the bytecode, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, copy `Example.class` to another device and run it with the proper JVM using
    the `java` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained all the basic concepts about edge computing and how it
    relates to other concepts, such as fog computing, MEC, and cloudlets. It also
    explained how containers and orchestrators such as Docker, containerd, and Kubernetes
    can help you to build your own edge computing system, using different configurations,
    depending on your own use case. At the end of the chapter, we covered how you
    can run and compile your software on edge devices using ARM processors, using
    the cross-compiling technique with Go, Python, Rust, and Java languages.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few questions to test your new knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the edge and edge computing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What infrastructure configurations can you use to build an edge computing system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can containers and orchestrators help you to build edge computing systems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is cross-compiling and how can you use it to run your software on ARM devices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some additional resources that you can check out to learn more about
    edge computing:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Near, Far or Tiny: Defining and Managing Edge Computing in a Cloud Native
    World*, *Keith Basil*: [https://vmblog.com/archive/2021/04/27/near-far-or-tiny-defining-and-managing-edge-computing-in-a-cloud-native-world.aspx](https://vmblog.com/archive/2021/04/27/near-far-or-tiny-defining-and-managing-edge-computing-in-a-cloud-native-world.aspx
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is Edge Computing: The Network Edge Explained*, *Eric Hamilton*:, *Cloudwards*
    (2018): [https://www.cloudwards.net/what-is-edge-computing](https://www.cloudwards.net/what-is-edge-computing
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*IoT and Edge Computing for Architects* – *Second Edition*, *Perry Lea*, *Packt
    Publishing* (2020)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The IoT blog of Cisco*: [https://blogs.cisco.com/internet-of-things](https://blogs.cisco.com/internet-of-things
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A secure data aggregation protocol for fog computing based smart grids*: [https://www.researchgate.net/publication/325638338_A_secure_data_aggregation_protocol_for_fog_computing_based_smart_grids.ng](https://www.researchgate.net/publication/325638338_A_secure_data_aggregation_protocol_for_fog_computing_based_smart_grids.ng
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*HarmonyCloud promotes edge computing implementation*: [https://www.cncf.io/blog/2021/08/31/harmonycloud-promotes-edge-computing-implementation](https://www.cncf.io/blog/2021/08/31/harmonycloud-promotes-edge-computing-implementation
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kubernetes – Bridging the Gap between 5G and Intelligent Edge Computing*:
    [https://www.cncf.io/blog/2021/03/01/kubernetes-bridging-the-gap-between-5g-and-intelligent-edge-computing](https://www.cncf.io/blog/2021/03/01/kubernetes-bridging-the-gap-between-5g-and-intelligent-edge-computing
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CNCF YouTube video list of Kubernetes on Edge Day 2021*: [https://www.youtube.com/watch?v=W1v2Gb6URsk&list=PLj6h78yzYM2PuR1pP14DBLW7aku1Ia520](https://www.youtube.com/watch?v=W1v2Gb6URsk&list=PLj6h78yzYM2PuR1pP14DBLW7aku1Ia520
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cross-Compiling using Rust for Mac*: [https://github.com/messense/homebrew-macos-cross-toolchains](https://github.com/messense/homebrew-macos-cross-toolchains
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cross-Compiling with Python*: [https://crossenv.readthedocs.io/en/latest/quickstart.html](https://crossenv.readthedocs.io/en/latest/quickstart.html
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*For instructions to download and install OpenJDK*: [https://openjdk.java.net/install](https://openjdk.java.net/install)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
