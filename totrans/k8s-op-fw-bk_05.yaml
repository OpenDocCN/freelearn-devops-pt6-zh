- en: '*Chapter 3*: Designing an Operator – CRD, API, and Target Reconciliation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The lessons from the previous chapters have helped us understand the foundational
    basics of the Operator Framework. In [*Chapter 1*](B18147_01_ePub.xhtml#_idTextAnchor015),
    *Introducing the Operator Framework*, we covered the conceptual pillars of the
    Operator Framework and the purposes they serve. Then, in [*Chapter 2*](B18147_02_ePub.xhtml#_idTextAnchor032),
    *Understanding How Operators Interact with Kubernetes*, we discussed some general
    principles of software design in the context of **Kubernetes** and the **Operator
    Framework**. Together, these chapters have established a baseline understanding
    of Operators and their development in broad terms. Now, we will be applying this
    knowledge with examples and begin designing our own Operator.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by defining a simple problem that our Operator is going to solve.
    In this case, that will be managing a basic deployment of an application with
    a single Pod. Over the next few chapters, we will add functionality to this Operator
    with specific code examples, but before we can start coding our sample Operator,
    we must first walk through the design process. Building on the generic definitions
    and steps we've already discussed with a concrete example will provide a context
    with which to frame the earlier lessons in practical terms.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process will cover a few different steps in order to lay out the core
    aspects of our Operator. These will include drawing out the **application programming
    interfaces** (**APIs**), **CustomResourceDefinitions** (**CRDs**), and reconciliation
    logic that will make our Operator work. Along the way, these steps will be related
    back to the lessons discussed earlier and industry-standard best practices for
    Operators. We''ll break this process into the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Describing the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing an API and a CRD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with other required resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a target reconciliation loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling upgrades and downgrades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using failure reporting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won't start writing any actual code yet besides some **YAML Ain't Markup
    Language** (**YAML**) snippets where applicable. However, we will use some pseudocode
    to better visualize how our actual code will work once we initialize the project
    with the Operator **software development kit** (**SDK**) in [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK*.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many software projects can be defined with a user story in the following format:
    *As a [user] I want to [action], so that [reason].* We''ll also do that here,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*As a cluster administrator, I want to use an Operator to manage my nginx application
    so that its health and monitoring are automatically managed for me.*'
  prefs: []
  type: TYPE_NORMAL
- en: For our use case (designing an Operator), we don't care about the specific application
    right now. For that reason, our *application* is just going to be a basic nginx
    sample Pod. We will assume that this represents any single-Pod application with
    basic **input/output** (**I/O**) needs. While this may seem too abstract, the
    focus will be on building an Operator around the application.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we have identified from this user story is that we will be building
    the Operator for cluster administrators. From the previous chapter, we know this
    means that the Operator's users will have a better understanding of the cluster
    architecture than most end users and that they will need higher levels of direct
    control over the Operand. We can also assume that most cluster administrators
    will be comfortable interacting directly with the Operator rather than through
    an intermediary frontend application.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of this user story identifies the functional objective of the
    Operator. Specifically, this Operator is going to manage the Deployment of a single-Pod
    application. In this case, *manage* is a vague term that we will assume to mean
    create and maintain the required Kubernetes resources to run the application.
    These resources will be, at minimum, a Deployment. We will need to expose some
    of the options of this Deployment through the Operator, such as the container
    port for nginx.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the user story provides our motivation for running the Operator. The
    cluster administrators want to have the application's *health and monitoring*
    managed by the Operator. Application health can mean a lot of different things,
    but generally, this comes down to maintaining high uptime for the application
    and recovering from any crashes, if possible. Monitoring the application can also
    be done in a number of ways, usually in the form of metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, from all of the preceding information, we have identified that we want
    a very basic Operator that can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploy an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the application running if it fails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Report on the health status of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the simplest functions that an Operator can serve. In later
    chapters, we'll build on these requests a bit more. But in the interest of starting
    with a solid foundation upon which to iterate later, this will be our **minimum
    viable product** (**MVP**). Henceforward, therefore, this is the basic Operator
    design we will be referencing when referring to our examples.
  prefs: []
  type: TYPE_NORMAL
- en: Based on these criteria, we can try to define our Operator in terms of the Capability
    Model covered in [*Chapter 1*](B18147_01_ePub.xhtml#_idTextAnchor015), *Introducing
    the Operator Framework* (recall that the Capability Model defines five levels
    of Operator functionality, from *Basic Install* to *Auto Pilot*). We know that
    the Operator will be able to install the Operand, as well as manage any additional
    required resources. We would like it to be able to report on the status of the
    Operand as well and provide configuration through its CRD. These are all the criteria
    for a Level I Operator. In addition, it would be great if our Operator could handle
    upgrades to qualify it as a Level II Operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good start for the initial Operator design. With a full picture of
    the problem we are trying to solve, we can now begin to brainstorm how we will
    solve it. To do that, we can start by designing how our Operator will be represented
    in the cluster API.
  prefs: []
  type: TYPE_NORMAL
- en: Designing an API and a CRD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we covered in [*Chapter 1*](B18147_01_ePub.xhtml#_idTextAnchor015), *Introducing
    the Operator Framework*, and [*Chapter 2*](B18147_02_ePub.xhtml#_idTextAnchor032),
    *Understanding How Operators Interact with Kubernetes*, the use of a CRD is a
    defining characteristic of Operators to create an object for users to interact
    with. This object creates an interface for controlling the Operator. In this way,
    the **Custom Resource** (**CR**) object is a window into the Operator's main functions.
  prefs: []
  type: TYPE_NORMAL
- en: As with any good window, the Operator's CRD must be built well. It must be clear
    enough to expose the details of the Operator while being secure enough to keep
    out harsh weather and burglars, and as with a window, the CRD's design should
    follow local building codes to ensure that it is built up to the expected standards
    of the environment. In our case, those building codes are the Kubernetes API conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Following the Kubernetes API design conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though a CRD is a custom object that can be created by anyone, there are
    still best practices to keep in mind. This is because the CRD exists within the
    Kubernetes API, which defines its conventions so that there are certain expectations
    when interacting with the API. These conventions are documented in the Kubernetes
    community at [https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md).
    However, this documentation is extensive and covers the requirements for all kinds
    of API objects, not just Operator CRDs. There are, however, a few key elements
    that are relevant to our purpose, as outlined here (Note: some of these fields
    will be discussed in more detail later in the chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: 'All API objects must have two fields: `kind` and `apiVersion`. These fields
    make it possible for Kubernetes API clients to decode the object. `Kind` represents
    the name of the object type—for example, `MyOperator`—and `apiVersion` is, aptly,
    the version of the API for that object. For example, your Operator may ship API
    versions `v1alpha1`, `v1beta1`, and `v1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'API objects should also have the following fields (though they are not required):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resourceVersion` and `generation`, both of which help to track changes to
    an object. However, these fields serve different purposes. The `resourceVersion`
    field is an internal reference that is incremented every time an object is modified,
    which serves to help with concurrency control. For example, when trying to update
    an Operand Deployment, you will make two client calls: `Get()` and `Update()`.
    When calling `Update()`, the API can detect if the object''s `resourceVersion`
    field has changed on the server (which would indicate that another controller
    has modified the object before we updated it) and reject the update. In contrast,
    `generation` serves to keep track of the relevant updates to an object. For example,
    a Deployment that has recently rolled out a new version would have its `generation`
    field updated. These values can be used to reference older generations or ensure
    that new ones are of the expected generation number (that is, *current+1*).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`creationTimestamp` and `deletionTimestamp`, which serve as helpful reference
    points for the age of an object. With `creationTimestamp`, for example, you can
    easily reference the age of an Operator''s Deployment based on when its CRD was
    created. Similarly, `deletionTimestamp` serves to indicate that a deletion request
    has been sent to the API server for that object.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`labels` and `annotations`, which serve similar purposes but are semantically
    different. Applying `labels` to an object serves to organize objects by criteria
    that are easily filtered through the API. On the other hand, `annotations` exposes
    metadata about the object.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'API objects should have `spec` and `status` fields. We will cover `status`
    in more detail later in the chapter (under *Using failure reporting*), but for
    now, there are some conventions around it to keep in mind, as outlined here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditions reported in an object's `status` field should be clearly self-explanatory
    without the need for additional context to understand them.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditions should respect the same API compatibility rules as any other field.
    In order to maintain backward compatibility, condition definitions should not
    change once defined.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditions can report either `True` or `False` as their normal operating state.
    There is no set guideline for which one should be the standard mode; it is up
    to the developer to consider readability in the definition of the condition. For
    example, a `Ready=true` condition can have the same meaning as one called `NotReady=false`,
    but the former is much easier to understand.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditions should represent the current known state of the cluster, rather than
    reporting transitions between states. As we will cover in the *Designing a target
    reconciliation loop* section, many Kubernetes controllers are written with a level-triggered
    design (meaning they operate based on the current state of the cluster rather
    than incoming events alone). So, an Operator reporting conditions based on its
    current state helps to maintain this mutual design assumption of being able to
    build the current state of the cluster in memory at any time. However, for long
    transitionary phases, the `Unknown` condition can be used if necessary.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sub-objects within an API object should be represented as lists, rather than
    maps; for example, our nginx deployment may need several different named ports
    to be specified through the Operator CRD. This means that they should be represented
    as a list, with each item in the list having fields for `name` and `port`, as
    opposed to a map where the key for each entry is the `name` of the port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional fields should be implemented as pointer values in order to easily distinguish
    between zero and unset values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The convention for fields with units is to include the units in the field name—for
    example, `restartTimeoutSeconds`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just some of the many API conventions, but they are important to know
    as you design your Operator's CRD and API. Adhering to the guidelines of API design
    ensures that other components in the Kubernetes ecosystem (including the platform
    itself) can make appropriate assumptions about your Operator. With these guidelines
    in mind, we can move on to the next step of designing our own CRD schema.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a CRD schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already discussed CRDs and their importance to Operators, but up until
    this point, we haven't looked in depth at how a CRD is composed. Now that we know
    the problem our example Operator is going to solve, we can begin looking at the
    options we want to expose through its CRD and get an idea of what those will look
    like to users.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it is best to see an example CRD and examine each section to understand
    its purpose, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first two fields, `apiVersion` and `kind`, define that this is a CRD. Even
    though we are trying to define a blueprint of our own custom objects, that blueprint
    must exist within a `CustomResourceDefinition` object first. From this, the API
    server will know how to parse the CRD data to create instances of our CR.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `metadata.Name` field defines the name of our CRD (not the custom
    object created from the CRD). To be more specific, this is the name of the blueprint,
    not the objects created from the blueprint. For example, we could retrieve this
    CRD design using `kubectl get crd/myoperator.operator.example.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Within `spec` is where the CRD begins to actually define the CR objects we want
    to create. The `group` defines a custom API group to which new objects will belong.
    Using a unique name here helps to prevent collisions with other objects and APIs
    in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The `names` section defines different ways in which our objects can be referenced.
    Here, only `kind` and `plural` are required (as the others can be inferred from
    these two). Just as any other type of object in the cluster is accessible via
    its `kind` or `plural` form (for example, `kubectl get pods`), our CRs will be
    accessible the same way with commands such as `kubectl edit myoperator/foo`. Even
    though most Operators will (and should) only have one CR object in the cluster,
    these fields are still required.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `scope` defines custom objects as namespace- or cluster-scoped. The differences
    between these two were covered in detail in [*Chapter 1*](B18147_01_ePub.xhtml#_idTextAnchor015),
    *Introducing the Operator Framework*. The available options for this field are
    `Cluster` and `Namespaced`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Versions` provides a list of the different API versions that will be available
    for our CR. As your Operator evolves over time and new features are added or removed,
    you will need to introduce new versions of the Operator''s CR. For backward compatibility
    and support, you should continue to ship older versions of the resource to provide
    users a transitory period after which the version can be safely deprecated. This
    is why this field provides a list of versions. The API server is aware of each
    version and can operate effectively on an object that is created and used in any
    available version in this list.'
  prefs: []
  type: TYPE_NORMAL
- en: Each version in the list contains schematic information about the object itself
    that uniquely identifies the structure of that version in `openAPIV3Schema`. In
    this example, the `openAPIV3Schema` section has been intentionally omitted. We
    have done that because this section is usually very long and complex. However,
    in recent versions of Kubernetes, this section is required in order to provide
    a **structural schema** for the CRD.
  prefs: []
  type: TYPE_NORMAL
- en: A structural schema is an object schema that is based on **OpenAPI version 3
    (V3) validation**. OpenAPI defines validation rules for each field that can be
    used to validate field data when objects are created or updated. These validation
    rules include the type of data for the field, as well as other information such
    as allowed string patterns and enumerated values. The structural schema requirement
    for CRDs ensures consistent, reliably stored representations of the objects.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the complex nature of OpenAPI validation schemas, it is not recommended
    to write them by hand. Instead, the use of generated tools such as **Kubebuilder**
    (which is used by the Operator SDK) is recommended. Extensive and flexible validation
    rules can be defined directly on the Go types for CRDs using the various Kubebuilder
    markers, which are available for full reference at [https://book.kubebuilder.io/reference/generating-crd.html](https://book.kubebuilder.io/reference/generating-crd.html).
  prefs: []
  type: TYPE_NORMAL
- en: The next sections of the individual version definitions are `served` and `storage`,
    which set whether this version is served via REST APIs and if this is the version
    that should be used as the storage representation. Only one version can be set
    as the storage version for a CRD.
  prefs: []
  type: TYPE_NORMAL
- en: The final sections, `subresources` and `status`, are related because they define
    a `status` field that will be used to report information on the current state
    of the Operator. We will cover that field and its uses in more detail under *Using
    failure reporting*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored the structure of a CRD and have an idea of what one
    should look like, we can design one for our example nginx Operator.
  prefs: []
  type: TYPE_NORMAL
- en: Example Operator CRD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the preceding problem statement, we know that our Operator is initially
    going to simply deploy an instance of nginx in the cluster. We also now know that
    our Operator''s CRD will provide a `spec` field with various options to control
    the Operand Deployment. But what kind of settings should we expose? Our Operand
    is fairly simple, so let''s start with a few basic options that we are defining
    to configure a simple nginx Pod, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`port`—This will be the port number that we want to expose the nginx Pod on
    within the cluster. Since nginx is a web server, this will allow us to modify
    the accessible port without having to directly touch the nginx Pod, because the
    Operator will handle safely changing it for us.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replicas`—This is a bit redundant because the number of replicas for any Kubernetes
    Deployment can be adjusted through the Deployment itself. But in the interest
    of abstracting control of the Operand away into a **user interface** (**UI**)
    behind the management of an Operator, we will provide this option. This way, an
    administrator (or other application) can scale the Operand with the added handling
    and reporting of our Operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forceRedeploy`—This field is interesting because it will effectively be a
    **no-operation** (**no-op**) against the Operand in terms of how it functions.
    However, including a field in the Operator CRD that can be set to any arbitrary
    value allows us a way to instruct the Operator to trigger a new rollout of the
    Operand without having to modify any actual settings. Having that functionality
    is useful for stuck Deployments where manual intervention can resolve the issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This works because the Operator watches for changes to relevant resources in
    the cluster, one of which being its own CRD (more on this in the *Designing a
    target reconciliation loop* section). This watch is necessary so that the Operator
    knows when to update an Operand. So, including a no-op field can be enough for
    the Operator to know to redeploy the Operand without needing to make any actual
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'These three settings together will make the basis of our Operator''s CRD `spec`.
    With this, we know that as an object in the cluster the CR object will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is the CR itself, not the CRD, as shown in an example earlier.
    We are using a generic `name: instance` value here because we will probably only
    have one instance of the Operator running in a namespace at a time. We also haven''t
    included the `forceRedeploy` field here because that will be optional.'
  prefs: []
  type: TYPE_NORMAL
- en: This object could be retrieved with the `kubectl get -o yaml nginxoperator/instance`
    command if we define our CRD right. Thankfully, the Operator SDK and Kubebuilder
    will help us generate that.
  prefs: []
  type: TYPE_NORMAL
- en: Working with other required resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the CRD, our Operator will be responsible for managing a number of other
    cluster resources as well. Right now, this is the nginx Deployment that will be
    created as our Operand, as well as a ServiceAccount, Role, and RoleBinding for
    the Operator. What we need to understand is how the Operator will know the definition
    of those resources.
  prefs: []
  type: TYPE_NORMAL
- en: Somewhere, the resources need to be written as Kubernetes cluster objects. Just
    as you would create a Deployment by hand (for example, with `kubectl create -f`),
    the definitions of necessary resources can be packaged with the Operator code
    in a couple of different ways. This can be done easily with templates if you are
    creating your Operator with Helm or Ansible, but for Operators written in **Go**,
    we need to consider our options.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to package these resources so that the Operator can create them is
    by defining them directly in the Operator''s code. All Kubernetes objects are
    based on corresponding Go type definitions, so we have the ability to create Deployments
    (or any resource, for that matter) directly in the Operator by declaring the resources
    as variables. Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The convenience of defining objects in code in this way is helpful for development.
    This approach provides a transparent definition that is clearly available and
    immediately usable by the Kubernetes API clients. However, there are some drawbacks
    to this. First, it is not very human-readable. Users will be familiar with interacting
    with Kubernetes objects represented as YAML or **JavaScript Object Notation**
    (**JSON**), wherein the type definitions for each field are not present. This
    information is unnecessary and superfluous for most users. So, any users who are
    interested in seeing the resource definitions clearly or modifying them may find
    themselves lost deep in the Operator's code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is an alternative to defining resources as Go types directly.
    There is a helpful package called `go-bindata` (available at [github.com/go-bindata/go-bindata](http://github.com/go-bindata/go-bindata))
    that compiles declarative YAML files into your Go binary so that they can be accessible
    by code. Newer versions of Go (1.16+) also now include the `go:embed` compiler
    directive to do this without an external tool such as `go-bindata`. So, we can
    simplify the preceding Deployment definition like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This is much more readable for the average user. It is also easily maintained,
    and you can provide different versions of various resources within named directories
    in your Operator's code base. This is good for code organization, and also simplifies
    your options for **continuous integration** (**CI**) checks against the validity
    of these type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover how to use `go-bindata` and `go:embed` in more detail in [*Chapter
    4*](B18147_04_ePub.xhtml#_idTextAnchor066), *Developing an Operator with the Operator
    SDK*, but for now, we know how we can package our additional resources to be available
    in the Operator. This is a key design consideration that benefits our users and
    maintainers.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a target reconciliation loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have defined our Operator's UI by designing a CRD to represent it
    in the cluster and itemized the Operand resources that it will manage, we can
    move on to the core logic of the Operator. This logic is nestled within the main
    reconciliation loop.
  prefs: []
  type: TYPE_NORMAL
- en: As described in earlier chapters, Operators function on the premise of reconciling
    the current state of the cluster with the desired state set by users. They do
    this by periodically checking what that current state is. These checks are usually
    triggered by certain events that are related to the Operand. For example, an Operator
    will monitor the Pods in its target Operand namespace and react to the creation
    or deletion of a Pod. It is up to the Operator developers to define which events
    are of interest to the Operator.
  prefs: []
  type: TYPE_NORMAL
- en: Level- versus edge-based event triggering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an event triggers the Operator's reconciliation loop, the logic does not
    receive the context of the whole event. Rather, the Operator must re-evaluate
    the entire state of the cluster to perform its reconciliation logic. This is known
    as **level-based triggering**. The alternative to this kind of design is **edge-based
    triggering**. In an edge-based system, the Operator logic would function only
    on the event itself.
  prefs: []
  type: TYPE_NORMAL
- en: The trade-off between these two system designs is in efficiency for reliability.
    Edge-based systems are much more efficient because they do not need to re-evaluate
    the entire state and can only act on the relevant information. However, an edge-based
    design can suffer from inconsistent and unreliable data—for example, if events
    are lost.
  prefs: []
  type: TYPE_NORMAL
- en: Level-based systems, on the other hand, are always aware of the entire state
    of the system. This makes them more suitable for large-scale distributed systems
    such as Kubernetes clusters. While these terms originally stem from concepts related
    to electronic circuits, they also relate well to software design in context. More
    information is available at [https://venkateshabbarapu.blogspot.com/2013/03/edge-triggered-vs-level-triggered.html](https://venkateshabbarapu.blogspot.com/2013/03/edge-triggered-vs-level-triggered.html).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difference between these design choices allows us to think
    about how the reconciliation logic will function. By going with a level-based
    triggering approach, we can be sure that the Operator will not lose any information
    or miss any events, as the cluster state representation in its memory will always
    eventually catch up to reality. However, we must consider the requirements for
    implementing a level-based design. Specifically, the Operator must have the information
    necessary to build the entire relevant cluster state in memory each time an event
    triggers reconciliation.
  prefs: []
  type: TYPE_NORMAL
- en: Designing reconcile logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reconcile loop is the core function of the Operator. This is the function
    that is called when the Operator receives an event, and it's where the main logic
    of the Operator is written. Additionally, this loop should ideally be designed
    to manage one CRD, rather than overload a single control loop with multiple responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the Operator SDK to scaffold an Operator project, the reconciliation
    loop will have a function signature like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is a method of a `Controller` object (which can be any name;
    we use `Controller` in this example, but it could just as easily be `FooOperator`).
    This object will be instantiated during the startup of the Operator. It then takes
    two parameters: `context.Context` and `ctrl.Request`. Finally, it returns a `ctrl.Result`
    parameter and, if applicable, an `error` parameter, We will go into more detail
    about these types and their specific roles in [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK*, but for now, understand that the
    core reconciliation loop of an Operator is built upon very little information
    about the event that triggered reconciliation. Note that the Operator''s CRD and
    information about the cluster state are not passed to this loop; nor is anything
    else.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the Operator is level-driven, the `Reconcile` function should instead
    build the status of the cluster itself. In pseudocode, this often looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the basic layout for our Operator''s reconciliation loop as well.
    The general process, broken into steps, is this:'
  prefs: []
  type: TYPE_NORMAL
- en: First, check for an existing Operator CRD object. As we know, the Operator CRD
    contains the configuration settings for how the Operator should function. It's
    considered a best practice that Operators should not manage their own CRD, so
    if there isn't one on the cluster, then immediately return with an error. This
    error will show up in the Operator's Pod logs and indicate to the user that they
    should create a CRD object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, check for the existence of relevant resources in the cluster. For our
    current use case, that will be the Operand Deployment. If the Deployment does
    not exist, then it is the Operator's job to create it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, if relevant resources already existed on the cluster, then check that
    they are configured in accordance with the settings in the Operator CRD. If not,
    then update the resources in the cluster with the intended values. While we could
    just update every time (because we know the desired state without having to look
    at the current state), it's a good practice to check for differences first. This
    helps minimize excessive API calls over updating indiscriminately. Making unnecessary
    updates also increases the chance of an update hot loop, where the Operator's
    updates to the resources create events that trigger the reconciliation loop that
    handles that object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These three steps rely heavily on access to the Kubernetes API via the standard
    API clients. The Operator SDK provides functions that help make it easy to instantiate
    these clients and pass them to the Operator's control loop.
  prefs: []
  type: TYPE_NORMAL
- en: Handling upgrades and downgrades
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As Operator developers, we are concerned with the versioning of two primary
    applications: the Operand and the Operator itself. Seamless upgrades are also
    the core feature of a Level II Operator, which we have decided is our goal for
    the initial Operator design. For that reason, we must ensure that our Operator
    can handle upgrades for both itself and the nginx Operand. For our use case, upgrading
    the Operand is fairly straightforward. We can simply pull the new image tag and
    update the Operand Deployment. However, if the Operand changed significantly,
    then the Operator may also need to be updated in order to properly manage the
    new Operand version.'
  prefs: []
  type: TYPE_NORMAL
- en: Operator upgrades arise when changes to the Operator code, API, or both need
    to be shipped to users. **Operator Lifecycle Manager** (**OLM**) makes upgrading
    Operators with newer released versions easy from a user standpoint. The Operator's
    **ClusterServiceVersion** (**CSV**) allows developers to define specific upgrade
    paths for maintainers to provide specific information about new versions that
    replace older versions. This will be covered in more detail in [*Chapter 7*](B18147_07_ePub.xhtml#_idTextAnchor108),
    *Installing and Running Operators with the Operator Lifecycle Manager*, when we
    actually write a CSV for our Operator.
  prefs: []
  type: TYPE_NORMAL
- en: There may also be a scenario where the Operator's CRD changes in incompatible
    ways (for example, deprecation of an old field). In this scenario, your Operator's
    API version should be increased (for example, from `v1alpha1` to `v1alpha2` or
    `v1beta1`). The new version should also be shipped with the existing version's
    CRD. This is the reason why the CRD's `versions` field is a list of version definitions,
    and it allows users the ability to transition from one version to the next thanks
    to simultaneous support of both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall, however, that out of this list of versions there may only be one that
    is the designated storage version. It is also excessive to ship every previous
    API version forever (eventually, older versions will need to be completely removed
    after an appropriate deprecation timeline has passed). When it is time to permanently
    remove support for deprecated API versions, the storage version may also need
    to be updated as well. This can cause issues for users who still have the old
    version of the Operator CRD installed as the storage version in their cluster.
    The `kube-storage-version-migrator` tool ([https://github.com/kubernetes-sigs/kube-storage-version-migrator](https://github.com/kubernetes-sigs/kube-storage-version-migrator))
    helps with this by providing a migration process for existing objects in the cluster.
    The storage version can be migrated with a `Migration` object, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: When this object is created, `kube-storage-version-migrator` will see it and
    update any existing objects that are stored in the cluster to the specified version.
    This only needs to be done once, and it can even be automated by packaging this
    object as an additional resource in the Operator. Future versions of Kubernetes
    will automate this process fully (see *KEP-2855*, [https://github.com/kubernetes/enhancements/pull/2856](https://github.com/kubernetes/enhancements/pull/2856)).
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for successful version transitions early on will pay off with future
    maintenance of your Operator. However, not everything can always go smoothly,
    and it's impossible to prepare for every possible scenario. This is why it is
    important for an Operator to have sufficient error reporting and handling as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using failure reporting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to failures, there are two things we need to worry about: failures
    in the Operand, and failures in the Operator itself. Sometimes, these two instances
    may even be related (for example, the Operand is failing in an unexpected way
    that the Operator does not know how to resolve). When any errors occur, it''s
    an important job of the Operator to report those errors to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: When an error happens during the Operator's reconciliation loop, the Operator
    must decide what to do next. In implementations with the Operator SDK, the reconcile
    logic is able to identify when an error has occurred and attempt the loop again.
    If the error continues to prevent the reconciliation from succeeding, the loop
    can exponentially back off and wait longer between each attempt in the hope that
    whichever condition is causing the failure will be resolved. However, when an
    Operator reaches this state, the error should still be exposed to the user in
    some way.
  prefs: []
  type: TYPE_NORMAL
- en: Error reporting can be easily done in a few ways. The main methods for reporting
    failures are logging, status updates, and events. Each approach offers different
    advantages, but a sophisticated Operator design will utilize all three in elegant
    harmony.
  prefs: []
  type: TYPE_NORMAL
- en: Reporting errors with logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to report any error is with basic logging. This is the way
    that most software projects report information to the user, not just Kubernetes
    Operators. That's because logged output is fairly easy to implement and intuitive
    to follow for most users. This reasoning is especially true considering the availability
    of logging libraries such as `kubectl logs pod/my-pod`. However, there are some
    downsides to relying on just logging for significant errors.
  prefs: []
  type: TYPE_NORMAL
- en: First, Kubernetes Pod logs are not persistent. When a Pod crashes and exits,
    its logs are only available until the failed Pod is cleaned up by the cluster's
    **garbage collection** (**GC**) processes. This makes debugging a failure particularly
    difficult as the user is in a race against time. Additionally, if an Operator
    is working diligently to fix the issue, then the user is also racing against their
    own automation system, which is supposed to help them, not hinder them.
  prefs: []
  type: TYPE_NORMAL
- en: Second, logs can be a lot of information to parse. Besides just the relevant
    Operator logs you may write yourself, your Operator will be built on many libraries
    and dependencies that inject their own information into the logged output. This
    can create a cumbersome mess of logs that require work to sort through. While
    there are, of course, tools such as `grep` that make it relatively easy to search
    through lots of text, your users may not always know exactly which text to search
    for in the first place. This can create serious delays when debugging an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Logs are helpful for tracing procedural steps in an Operator or for low-level
    debugging. However, they are not great at bringing failures to the immediate attention
    of users. Pod logs do not last long, and they are often drowned out by irrelevant
    logs. In addition, logs themselves usually do not provide much human-readable
    context for debugging. This is why important failures that require attention are
    better handled by status updates and events.
  prefs: []
  type: TYPE_NORMAL
- en: Reporting errors with status updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier in the chapter when discussing Kubernetes API conventions
    and CRD design, an Operator CRD should provide two important fields: `spec` and
    `status`. While `spec` represents the desired state of the cluster and accepts
    input from the user, `status` serves to report the current state of the cluster
    and should only be updated as a form of output.'
  prefs: []
  type: TYPE_NORMAL
- en: By utilizing the `status` field to report the health of your Operator and its
    Operand, you can easily highlight important state information in a readable format.
    This format is based on the condition type, which is provided by the Kubernetes
    API machinery.
  prefs: []
  type: TYPE_NORMAL
- en: A condition reports its name along with a Boolean value indicating whether the
    condition is currently present. For example, an Operator could report the `OperandReady=false`
    condition to show that the Operand is not healthy. There is also a field within
    the condition called `Reason`, which allows developers to provide a more readable
    explanation of the current status. As of Kubernetes `1.23`, the `Condition` `Type`
    field has a maximum length of `316` characters, and its `Reason` field can be
    up to `1,024` characters.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes API clients provide functions to report conditions easily, such
    as `metav1.SetStatusCondition(conditions *[]metav1.Condition, newCondition metav1.Condition`).
    These functions (and the `Condition` type itself) exist under the `k8s.io/apimachinery/pkg/apis/meta/v1`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an Operator''s CRD `status` field, the conditions look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: For our nginx deployment Operator, we'll start by reporting a condition that
    is simply called `Ready`. We'll set the status of this condition to `True` on
    the successful startup of the Operator, and change it to `False` in the event
    that the Operator fails a reconciliation loop (along with a `Reason` field explaining
    the failure in more detail). We may end up finding more Conditions that will make
    sense to add later, but given the initial simplicity of the Operator, this should
    be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Using conditions helps show the current state of the Operator and its managed
    resources, but these only show up in the `status` section of the Operator's CRD.
    However, we can combine them with events to make the error reporting available
    throughout the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Reporting errors with events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes events are a native API object, just like Pods or any other object
    in the cluster. Events are aggregated and show up when using `kubectl describe`
    to describe a Pod. They can also be monitored and filtered by themselves with
    `kubectl get events`. Their availability within the Kubernetes API makes them
    understandable by other applications as well, such as alerting systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of listing a Pod''s events is shown here, where we see five different
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Warning` event that has occurred three times, showing that the Pod failed
    to be scheduled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Normal` event once the Pod was successfully scheduled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Three more `Normal` events as the Pod's container images were pulled, created,
    and successfully started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see these events in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Events can relay more information than conditions thanks to a much more complex
    object design. While events include a `Reason` and a `Message` field (analogous
    to conditions' `Type` and `Reason` fields, respectively), they also include information
    such as `Count` (which shows the number of times this event has occurred), `ReportingController`
    (which shows the originating controller of the event), and `Type` (which can be
    used to filter events of different severity levels).
  prefs: []
  type: TYPE_NORMAL
- en: The `Type` field can currently be used to categorize cluster events as `Normal`
    or `Warning`. This means that, similar to how a condition can report a successful
    state, events can also be used to show that certain functions completed successfully
    (such as startup or upgrades).
  prefs: []
  type: TYPE_NORMAL
- en: For a Pod to report events to the cluster, the code needs to implement an `EventRecorder`
    object. This object should be passed throughout the controller and broadcasts
    events to the cluster. The Operator SDK and Kubernetes clients provide boilerplate
    code to set this up properly.
  prefs: []
  type: TYPE_NORMAL
- en: Besides reporting events, your Operator will also react to events in the cluster.
    This goes back to the essential foundation of an Operator's event-triggered design.
    There are code patterns to design which types of events the Operator is interested
    in reacting to, wherein you can add logic to filter out specific events. This
    will be covered in detail in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a sophisticated error-reporting system utilizes logs, status,
    and events to provide a full picture of the state of the application. Each method
    provides its own benefits, and together they weave a beautiful tapestry of debuggability
    that helps administrators track down failures and resolve issues.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter outlined the details of an Operator we would like to build. Beginning
    with a description of the problem (in this case, a simple Operator to manage an
    nginx Pod) gave a solid foundation of the solutions that are available to work
    with. This step even provided enough information to set a goal for the capability
    level of this Operator (*Level II – Seamless Upgrades*).
  prefs: []
  type: TYPE_NORMAL
- en: The next step was outlining what the Operator CRD will look like. To do this,
    we first noted some relevant conventions in the Kubernetes API that are helpful
    to ensure the Operator conforms to expected standards for Kubernetes objects.
    We then broke down the structure of a CRD and explained how each section relates
    to the corresponding CR object. Finally, we drafted an example of what the Operator's
    CR will look like in the cluster to get a concrete idea of the expectation from
    users.
  prefs: []
  type: TYPE_NORMAL
- en: After designing the CRD, we considered our options for managing additional resources
    as well. For an Operator written in Go, it makes sense to package additional resources
    (such as RoleBinding and ServiceAccount definitions) as YAML files. These files
    can be compiled into the Operator binary with `go-bindata` and `go:embed`.
  prefs: []
  type: TYPE_NORMAL
- en: The next step in the design is the target reconciliation loop. This comprises
    the core logic of the Operator and is what makes the Operator a useful, functional
    application. This process began with understanding the difference between level-
    and edge-triggered event processing and why it is better for Operators to be level-based.
    We then discussed the basic steps of an Operator's reconcile loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two sections discussed the topics of upgrades, downgrades, and error
    reporting. With upgrades and downgrades, we covered the use cases for shipping
    and supporting multiple API versions simultaneously, as well as the need to occasionally
    migrate storage versions in existing installations. The section about error reporting
    focused on the three main ways that applications can expose health information
    to users: logging, status conditions, and events.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take everything we have decided on as our initial
    design and compose it into actual code. This will involve initializing a project
    with the Operator SDK, generating an API that will become the Operator's CRD,
    and coding target reconciliation logic. Essentially, we will apply the knowledge
    from this chapter to a hands-on exercise in Operator development.
  prefs: []
  type: TYPE_NORMAL
