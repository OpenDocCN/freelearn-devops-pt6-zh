<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Solutions</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>This section contains the worked-out answers for the activities present in each lesson. Note that in case of descriptive questions, your answers might not match the ones provided in this section completely. As long as the essence of the answers remain the same, you can consider them correct.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 1:  Kubernetes Design Patterns</h1>
                </header>
            
            <article>
                
<p>Following are the activity solutions for this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Activity: Running a Web Server with Synchronization</h1>
                </header>
            
            <article>
                
<p><span>In the <kbd>sidecar.yaml</kbd> file, pod definition with two containers, namely <kbd>server</kbd> and <kbd>sync</kbd>, is provided. In the server container, httpd serves the source volume on port 80. In the sync container, git runs with every 30 seconds to synchronize the source volume. These two containers work independently; however, they are sharing the source volume to achieve file synchronization:<br/></span></p>
<pre><span>apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>       name: sidecar<br/>spec:<br/>     containers:<br/>...<br/>volumes:<br/>- emptyDir: {}<br/>    name: source </span></pre>
<p><span>Follow these steps to get the solution:<br/></span></p>
<ol>
<li><span>Create the pod with the following command:<br/></span></li>
</ol>
<pre style="padding-left: 60px"> <span>kubectl apply -f sidecar.yaml </span></pre>
<ol start="2">
<li>Check whether the pod is ready with the name sidecar:<span><br/></span></li>
</ol>
<pre style="padding-left: 60px"> <span>kubectl get pod sidecar </span></pre>
<ol start="3">
<li>When the pod is ready, check the logs of synchronization sidecar container:<span><br/></span></li>
</ol>
<pre style="padding-left: 60px"> <span>kubectl logs sidecar -c sync<br/></span></pre>
<ol start="4">
<li>Forward the server port of the pod to localhost with the following command:<span><br/></span></li>
</ol>
<pre style="padding-left: 60px"> <span>kubectl port-forward sidecar 8000:80<br/></span></pre>
<ol start="5">
<li>Open<span> </span><kbd>localhost:8000</kbd><span> </span>in the browser. It is expected to see a 2048 game.<span><br/></span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Activity: Running a Web Server after Content Preparation</h1>
                </header>
            
            <article>
                
<p><span>In the <kbd>init-container.yaml</kbd> file, pod definition with one initialization and one main container, namely <kbd>content</kbd> and <kbd>server</kbd>, is provided. In the content container, <kbd>"Welcome from Packt"</kbd> is written into the index file. In the server container, nginx serves the source volume on port 80. These two containers work independently; however, they are sharing the <kbd>workdir</kbd> volume to achieve file preparation:<br/></span></p>
<pre><span>apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>      name: init-container<br/>spec:<br/>     initContainers:<br/>-<br/>...<br/>volumes:<br/>- name: workdir<br/>    emptyDir: {} </span></pre>
<p class="mce-root">Follow these steps to get the solution:<span><br/></span></p>
<ol>
<li><span>Create the pod with the following command:<br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>kubectl apply -f init-container.yaml<br/></span></pre>
<ol start="2">
<li>Check the state of the initialization container:<span><br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>kubectl describe pod init-container<br/></span></pre>
<ol start="3">
<li>When the pod is running, forward the server port of the pod to localhost with the following command:<span><br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>kubectl port-forward init-container 8000:80 </span></pre>
<ol start="4">
<li>In another terminal, check the content of the server with the following command:<span><br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>curl localhost:8000<br/></span></pre>
<ol start="5">
<li>Run the following command for cleanup:<span><br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>kubectl delete deployment go-client </span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Activity: Injecting Data into Applications</h1>
                </header>
            
            <article>
                
<p><span>In the <kbd>inject.yaml</kbd> file, there is a pod definition with one container that logs its runtime information in every 10 seconds. Resource requests and limits are defined for memory and cpu for utilization and performance information.<br/>
Environment variables are defined with <kbd>valueFrom</kbd> blocks which shows that values are filled during runtime:<br/></span></p>
<p><span>Follow these steps to get the solution:<br/></span></p>
<ol>
<li>Create the pod with the following command:<span><br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>kubectl apply -f inject.yaml<br/></span></pre>
<ol start="2">
<li>Check whether the inject pod is ready:<span><br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>kubectl get pod inject<br/></span></pre>
<ol start="3">
<li>When the pod is ready, check the logs:<span><br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>kubectl logs inject<br/></span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 2:  Kubernetes Client Libraries</h1>
                </header>
            
            <article>
                
<p><span>Following are the activity solutions for this chapter.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Activity: Using the Kubernetes Go Client inside the Cluster</h1>
                </header>
            
            <article>
                
<ol>
<li><span>Create a deployment with the Docker image of the example client from the previous exercise:<br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>kubectl run go-client --image=onuryilmaz/k8s-clientexample:go<br/></span></pre>
<ol start="2">
<li>Wait until the pod is running by using the following command:<span><br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>kubectl get pods -w<br/></span></pre>
<ol start="3">
<li>Get the logs of the deployment pod with the following command:<span><br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>kubectl logs $(kubectl get pods --selector run=go-client -o jsonpath="{.items[0].metadata.name}")</span></pre>


            </article>

            
        </section>
    </body></html>