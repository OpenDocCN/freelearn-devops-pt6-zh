- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Understanding Kubernetes and Helm
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 和 Helm
- en: Thank you for choosing this book, *Learn Helm*. If you are interested in this
    book, you are probably aware of the challenges that modern applications bring.
    Teams face tremendous pressure to ensure that applications are lightweight and
    scalable. Applications must also be highly available and able to withstand varying
    loads. Historically, applications have most commonly been deployed as monoliths
    or large, single-tiered applications served on a single system. As time has progressed,
    the industry has shifted toward a microservice approach or small, multi-tiered
    applications served on multiple systems. Often deployed using container technology,
    the industry has started leveraging tools such as Kubernetes to orchestrate and
    scale their containerized microservices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢你选择本书《学习 Helm》。如果你对本书感兴趣，那么你可能已经意识到现代应用所带来的挑战。团队面临巨大的压力，必须确保应用是轻量且可扩展的。应用还必须具有高度可用性，能够承受不同的负载。历史上，应用通常以单体或大型单一层次的应用形式部署在单一系统上。随着时间的推移，行业逐渐转向微服务架构，或者将应用拆分成多个小型的多层次应用，部署在多个系统上。行业中开始采用容器技术，并利用
    Kubernetes 等工具来编排和扩展其容器化的微服务。
- en: Kubernetes, however, comes with its own set of challenges. While it is an effective
    container orchestration tool, it presents a steep learning curve that can be difficult
    for teams to overcome. One tool that helps simplify the challenges of running
    workloads on Kubernetes is Helm. Helm allows users to more simply deploy and manage
    the life cycle of Kubernetes applications. It abstracts many of the complexities
    behind configuring Kubernetes applications and allows teams to be more productive
    on the platform.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Kubernetes 也带来了自己的挑战。虽然它是一个有效的容器编排工具，但它有一个陡峭的学习曲线，团队可能难以克服。这时，Helm 就能帮助简化在
    Kubernetes 上运行工作负载的挑战。Helm 让用户可以更加简单地部署和管理 Kubernetes 应用的生命周期。它抽象了配置 Kubernetes
    应用时的许多复杂性，使团队在该平台上变得更加高效。
- en: In this book, you will explore each of the benefits offered by Helm and discover
    how Helm makes application deployment much simpler on Kubernetes. You will first
    assume the role of an end user, consuming Helm charts written by the community
    and learning the best practices behind leveraging Helm as a package manager. As
    this book progresses, you will assume the role of a chart developer and learn
    how to package Kubernetes applications in ways that are easily consumable and
    efficient. Toward the end of this book, you’ll learn about advanced patterns around
    application management and security with Helm.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将带你探索 Helm 所提供的每一项优势，并发现 Helm 如何简化在 Kubernetes 上的应用部署。你将首先扮演终端用户的角色，使用社区编写的
    Helm charts，并学习如何作为包管理器利用 Helm 的最佳实践。随着本书的深入，你将转变为 chart 开发者，学习如何以易于使用且高效的方式打包
    Kubernetes 应用。在本书的最后，你将了解关于应用管理和安全的 Helm 高级模式。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: From monoliths to modern microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从单体架构到现代微服务
- en: What is Kubernetes?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Kubernetes？
- en: Deploying a Kubernetes application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署 Kubernetes 应用
- en: Approaches to resource management
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源管理的方法
- en: Resource configuration challenges
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源配置挑战
- en: Helm to the rescue!
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm 来拯救我们！
- en: From monoliths to modern microservices
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从单体架构到现代微服务
- en: Software applications are a fundamental component of most modern technology.
    Whether they take the form of a word processor, web browser, or streaming service,
    they enable user interaction to complete one or more tasks. Applications have
    a long and storied history, from the days of **Electronic Numerical Integrator
    and Computer** (**ENIAC**)—the first general-purpose computer—to taking man to
    the moon in the Apollo space missions, to the rise of the **World Wide Web** (**WWW**),
    social media, and online retail.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 软件应用是现代科技中大多数技术的核心组成部分。无论它们是文字处理软件、网页浏览器还是流媒体服务，应用程序都使得用户能够完成一个或多个任务。应用程序有着悠久而丰富的历史，从**电子数值积分与计算机**（**ENIAC**）——第一台通用计算机——到载人登月的阿波罗太空任务，再到**万维网**（**WWW**）、社交媒体和在线零售的兴起。
- en: These applications can operate on a wide range of platforms and systems, leveraging
    either physical or virtual computing resources. Depending on their purpose and
    resource requirements, entire machines may be dedicated to serving the compute
    and/or storage needs of an application. Fortunately, thanks in part to the realization
    of Moore’s law, the power and performance of microprocessors initially increased
    with each passing year, along with the overall cost associated with the physical
    resources used. This trend has subsided in recent years, but the advent of this
    trend and its persistence for the first 30 years of the existence of processors
    was instrumental to the advances in technology.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序可以在广泛的各种平台和系统上运行，利用物理或虚拟计算资源。根据它们的目的和资源需求，整个机器可能专门用于为应用程序提供计算和/或存储需求。幸运的是，部分归功于摩尔定律的实现，微处理器的性能和处理能力最初随着每年的推移不断提高，同时与所使用的物理资源相关的总体成本也在降低。尽管这种趋势在近年来有所减缓，但这一趋势的出现及其在处理器存在的前30年中的持续性对技术进步起到了重要作用。
- en: Software developers took full advantage of this opportunity and bundled more
    features and components into their applications. As a result, a single application
    could consist of several smaller components, each of which, on its own, could
    be written as its own individual services. Initially, bundling components together
    yielded several benefits, including a simplified deployment process. However,
    as industry trends began to change and businesses focused more on the ability
    to deliver features more rapidly, the design of a single deployable application
    brought with it a number of challenges. Whenever a change was required, the entire
    application and all of its underlying components needed to be validated once again
    to ensure the change had no adverse features. This process potentially required
    coordination from multiple teams, which slowed the overall delivery of the feature.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发人员充分利用了这一机会，将更多的功能和组件捆绑到他们的应用程序中。结果，单一应用程序可能包含多个小型组件，每个组件本身都可以作为单独的服务来编写。最初，将组件捆绑在一起带来了多个好处，包括简化的部署过程。然而，随着行业趋势的变化，企业越来越关注更快速交付功能的能力，单一可部署应用程序的设计带来了许多挑战。每当需要更改时，整个应用程序及其所有基础组件都需要重新验证，以确保更改不会引入不良特性。这个过程可能需要多个团队之间的协调，从而减缓了整体功能交付的速度。
- en: 'Delivering features more rapidly, especially across traditional divisions within
    organizations, was also something that organizations wanted. This concept of rapid
    delivery is fundamental to a practice called **development-operations** (**DevOps**),
    whose rise in popularity occurred around 2010\. DevOps encouraged more iterative
    changes to applications over time, instead of extensive planning prior to development.
    In order to be sustainable in this new model, architectures evolved from being
    a single large application to instead favoring several smaller applications that
    could be delivered faster. Because of this change in thinking, the more traditional
    application design was labeled as **monolithic**. This new approach of breaking
    components down into separate applications coined a name for these components:
    **microservices**. The traits that were inherent in microservices applications
    brought with them several desirable features, including the ability to develop
    and deploy services concurrently from one another as well as to scale them (increase
    the number of instances) independently.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 提供更快速的功能交付，尤其是在组织内部的传统部门之间，也是组织所期望的。这种快速交付的概念是**开发运维**（**DevOps**）的基础，该概念在2010年左右开始流行。DevOps鼓励对应用程序进行更多的迭代性更改，而不是在开发之前进行大量的规划。为了在这种新模式中保持可持续性，架构从单一的大型应用程序演变为更倾向于多个小型应用程序，这些应用程序可以更快速地交付。由于这种思维方式的变化，传统的应用程序设计被标记为**单体式**。这种将组件拆分成独立应用程序的新方法为这些组件创造了一个名字：**微服务**。微服务应用程序所固有的特征带来了几个可取的特点，包括能够并行开发和部署各个服务，并且可以独立地进行扩展（增加实例数量）。
- en: The change in software architecture from monolithic to microservices also resulted
    in re-evaluating how applications are packaged and deployed at runtime. Traditionally,
    entire machines were dedicated to either one or two applications. Now, as microservices
    resulted in the overall reduction of resources required for a single application,
    dedicating an entire machine to one or two microservices was no longer viable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从单体架构到微服务架构的转变，还导致了重新评估如何在运行时打包和部署应用程序。传统上，整个机器要么专门用于一个应用程序，要么专门用于两个应用程序。而现在，随着微服务减少了单个应用程序所需的资源，将整台机器专门用于一两个微服务变得不再可行。
- en: Fortunately, a technology called **containers** was introduced and gained popularity
    in filling in the gaps for many missing features needed to create a microservices
    runtime environment. Red Hat defines a container as “*a set of one or more processes
    that are isolated from the rest of the system and includes all of the files necessary
    to run*”(https://www.redhat.com/en/topics/containers/whats-a-linux-container#:~:text=A%20Linux%C2%AE%20container%20is,testing%2C%20and%20finally%20to%20production.).
    Containerized technology has a long history in computing, dating back to the 1970s.
    Many of the foundational container technologies, including **chroots** (the ability
    to change the root directory of a process and any of its children to a new location
    on the filesystem) and **jails**, are still in use today.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，一种名为**容器**的技术应运而生，并在填补许多创建微服务运行环境所需缺失的功能方面变得非常流行。Red Hat将容器定义为“*一组与系统其余部分隔离的进程，并包括运行所需的所有文件*”（https://www.redhat.com/en/topics/containers/whats-a-linux-container#:~:text=A%20Linux%C2%AE%20container%20is,testing%2C%20and%20finally%20to%20production.）。容器化技术在计算领域有着悠久的历史，追溯到1970年代。许多基础的容器技术，包括**chroots**（能够将进程及其子进程的根目录更改到文件系统中的新位置）和**jails**，至今仍在使用。
- en: The combination of a simple and portable packaging model, along with the ability
    to create many isolated sandboxes on each physical machine or **virtual machine**
    (**VM**), led to the rapid adoption of containers in the microservices space.
    This rise in container popularity in the mid-2010s can also be attributed to Docker,
    which brought containers to the masses through simplified packaging and runtimes
    that could be utilized on Linux, macOS, and Windows. The ability to distribute
    container images with ease led to the increase in the popularity of container
    technologies. This was because first-time users did not need to know how to create
    images but instead could make use of existing images that were created by others.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 简单且可移植的打包模型与能够在每台物理机器或**虚拟机**（**VM**）上创建多个隔离沙箱的能力相结合，推动了容器在微服务领域的快速采用。2010年代中期容器受欢迎的增长，亦可归因于Docker，它通过简化的打包和运行时，使得容器技术得以在Linux、macOS和Windows上普及。容器镜像的分发变得更加容易，推动了容器技术的普及。这是因为初次使用者无需了解如何创建镜像，而是可以使用其他人创建的现成镜像。
- en: Containers and microservices became a match made in heaven. Applications had
    a packaging and distribution mechanism, along with the ability to share the same
    compute footprint while taking advantage of being isolated from one another. However,
    as more and more containerized microservices were deployed, the overall management
    became a concern. How do you ensure the health of each running container? What
    do you do if a container fails? What happens if your underlying machine does not
    have the compute capacity required? Enter Kubernetes, which helped answer this
    need for container orchestration.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和微服务成就了天作之合。应用程序有了打包和分发机制，同时可以共享相同的计算资源，并且能享受彼此隔离的好处。然而，随着越来越多的容器化微服务被部署，整体管理也成为了一个问题。如何确保每个运行中的容器的健康状况？如果容器失败，应该怎么办？如果底层机器没有足够的计算能力该怎么办？于是，Kubernetes应运而生，帮助解决了容器编排的需求。
- en: In the next section, we will discuss how Kubernetes works and provides value
    to an enterprise.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Kubernetes如何工作以及它如何为企业创造价值。
- en: What is Kubernetes?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Kubernetes？
- en: '**Kubernetes**, often abbreviated as **k8s** (pronounced as *kaytes*), is an
    open source container orchestration platform. Originating from Google’s proprietary
    orchestration tool, Borg, the project was open sourced in 2015 and was renamed
    Kubernetes. Following the v1.0 release on July 21, 2015, Google and the Linux
    Foundation partnered to form the **Cloud Native Computing Foundation** (**CNCF**),
    which acts as the current maintainer of the Kubernetes project.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes**，常简称为**k8s**（发音为*kaytes*），是一个开源的容器编排平台。Kubernetes起源于谷歌的专有编排工具Borg，该项目在2015年开源并更名为Kubernetes。随着2015年7月21日v1.0版本的发布，谷歌与Linux基金会合作，成立了**云原生计算基金会**（**CNCF**），该基金会是Kubernetes项目的当前维护者。'
- en: The word *Kubernetes* is a Greek word, meaning *helmsman* or *pilot*. A helmsman
    is a person who is in charge of steering a ship and works closely with the ship’s
    officer to ensure a safe and steady course, along with the overall safety of the
    crew. Having similar responsibilities with regard to containers and microservices,
    Kubernetes is in charge of the orchestration and scheduling of containers. It
    is in charge of *steering* those containers to proper worker nodes that can handle
    their workloads. Kubernetes will also help ensure the safety of those microservices
    by providing **high availability** (**HA**) and health checks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kubernetes*这个词源自希腊语，意思是*舵手*或*驾驶员*。舵手是负责操控船只的人，他与船上的官员密切合作，以确保航行安全和稳妥，同时保障船员的整体安全。Kubernetes在容器和微服务方面承担着类似的责任，负责容器的编排和调度。它负责*引导*这些容器到合适的工作节点，以便能够处理其工作负载。Kubernetes还通过提供**高可用性**（**HA**）和健康检查来确保这些微服务的安全。'
- en: Let’s review some of the ways Kubernetes helps simplify the management of containerized
    workloads.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下Kubernetes如何简化容器化工作负载的管理。
- en: Container orchestration
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器编排
- en: The most prominent feature of Kubernetes is container orchestration. This is
    a fairly loaded term, so we’ll break it down into different pieces.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes最显著的特性是容器编排。这是一个相当复杂的术语，因此我们将其拆解为不同的部分。
- en: 'Container orchestration is about placing containers on certain machines from
    a pool of compute resources based on their requirements. The simplest use case
    for container orchestration is for deploying containers on machines that can handle
    their resource requirements. In the following diagram, there is an application
    that requests 2 **Gibibytes** (**Gi**) of memory (Kubernetes resource requests
    typically use their *power-of-two* values, which in this case is roughly equivalent
    to 2 **gigabytes** (**GB**)) and one **central processing unit** (**CPU**) core.
    This means that the container will be allocated 2 Gi of memory and 1 CPU core
    from the underlying machine that it is scheduled on. It is up to Kubernetes to
    track which machines, or **nodes**, have the required resources available and
    to place an incoming container on that machine. If a node does not have enough
    resources to satisfy the request, the container will not be scheduled on that
    node. If none of the nodes in a cluster have enough resources to run the workload,
    the container will not be deployed. Once a node has enough resources free, the
    container will be deployed on the node with sufficient resources:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 容器编排是根据容器的需求，将容器部署到一组计算资源中的特定机器上。容器编排的最简单用例是将容器部署到能够满足其资源需求的机器上。在下图中，某个应用程序请求2
    **Gibibytes**（**Gi**）的内存（Kubernetes资源请求通常使用*二次幂*值，在本例中大致相当于2 **gigabytes**（**GB**））和一个**中央处理单元**（**CPU**）核心。这意味着容器将从其被调度到的底层机器上分配2
    Gi内存和1个CPU核心。Kubernetes负责跟踪哪些机器或**节点**拥有所需的资源，并将传入的容器调度到这些机器上。如果某个节点没有足够的资源来满足请求，容器将不会被调度到该节点。如果集群中没有任何节点有足够的资源来运行该工作负载，容器将不会被部署。一旦某个节点有足够的空闲资源，容器将被部署到具有足够资源的节点上：
- en: '![Figure 1.1 – Kubernetes orchestration and scheduling'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1 – Kubernetes编排与调度'
- en: '](img/Figure_1.1_B17979.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.1_B17979.jpg)'
- en: Figure 1.1 – Kubernetes orchestration and scheduling
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – Kubernetes编排与调度
- en: Container orchestration relieves you of the effort required to track the available
    resources on machines. Kubernetes and other monitoring tools provide insight into
    these metrics. So, a developer can simply declare the number of resources they
    expect a container to use, and Kubernetes will take care of the rest on the backend.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 容器编排让你不再需要跟踪机器上可用资源的工作。Kubernetes 和其他监控工具提供了这些指标的洞察。因此，开发者只需声明容器预计使用的资源数量，Kubernetes
    会在后台处理剩下的工作。
- en: HA
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高可用性（HA）
- en: Another benefit of Kubernetes is that it provides features that help take care
    of redundancy and HA. HA is a characteristic that prevents application downtime.
    It’s performed by a load balancer, which splits incoming traffic across multiple
    instances of an application. The premise of HA is that if one instance of an application
    goes down, other instances are still available to accept incoming traffic. In
    this regard, downtime is avoided, and the end user—whether a human or another
    microservice—remains completely unaware that there was a failed instance of the
    application. Kubernetes provides a networking mechanism, called a *service*, that
    allows applications to be load-balanced. We will talk about services in greater
    detail later on, in the *Deploying a Kubernetes application* section of this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的另一个好处是，它提供了帮助处理冗余和高可用性的功能。高可用性（HA）是一种防止应用程序停机的特性。它通过负载均衡器来执行，将传入的流量分配到应用程序的多个实例上。高可用性的前提是，如果某个应用实例出现故障，其他实例仍然可以接受传入的流量。在这种情况下，可以避免停机，最终用户——无论是人类还是另一个微服务——都不会意识到有一个应用实例出现了故障。Kubernetes
    提供了一种称为*服务*的网络机制，允许应用程序进行负载均衡。我们将在本章的*部署 Kubernetes 应用程序*部分详细讨论服务。
- en: Scalability
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Given the lightweight nature of containers and microservices, developers can
    use Kubernetes to rapidly scale their workloads, both horizontally and vertically.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于容器和微服务的轻量级特性，开发者可以使用 Kubernetes 快速扩展他们的工作负载，进行水平和垂直扩展。
- en: Horizontal scaling is the act of deploying more container instances. If a team
    running their workloads on Kubernetes were expecting increased load, they could
    simply tell Kubernetes to deploy more instances of their application. Since Kubernetes
    is a container orchestrator, developers would not need to worry about the physical
    infrastructure that those applications would be deployed on. It would simply locate
    a node within the cluster with the available resources and deploy the additional
    instances there. Each extra instance would be added to a load-balancing pool,
    which would allow the application to continue to be highly available.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展是部署更多容器实例的过程。如果一个团队在 Kubernetes 上运行其工作负载并预计负载增加，他们可以简单地告诉 Kubernetes 部署更多实例的应用程序。由于
    Kubernetes 是一个容器编排工具，开发者无需担心应用程序将部署在哪些物理基础设施上。它会在集群中找到一个具有可用资源的节点，并在那里部署额外的实例。每个额外的实例都会被添加到负载均衡池中，从而使应用程序继续保持高可用性。
- en: Vertical scaling is the act of allocating additional memory and CPU to an application.
    Developers can modify the resource requirements of their applications while they
    are running. This will prompt Kubernetes to redeploy the running instances and
    reschedule them on nodes that can support the new resource requirements. Depending
    on how this is configured, Kubernetes can redeploy each instance in a way that
    prevents downtime while the new instances are being deployed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直扩展是为应用程序分配额外的内存和 CPU。开发者可以在应用程序运行时修改其资源需求。这将促使 Kubernetes 重新部署正在运行的实例，并将它们重新调度到可以支持新资源需求的节点上。根据配置的方式，Kubernetes
    可以重新部署每个实例，避免在新实例部署期间发生停机。
- en: Active community
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活跃的社区
- en: The Kubernetes community is an incredibly active open source community. As a
    result, Kubernetes frequently receives patches and new features. The community
    has also made many contributions to documentation, both to the official Kubernetes
    documentation and to professional or hobbyist blog websites. In addition to documentation,
    the community is highly involved in planning and attending meetups and conferences
    around the world, which helps increase education about the platform and innovation
    surrounding it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 社区是一个非常活跃的开源社区。因此，Kubernetes 经常收到补丁和新特性。社区还对文档做出了许多贡献，包括官方 Kubernetes
    文档以及专业或业余博客网站。除了文档外，社区还积极参与全球范围内的规划、聚会和会议，这有助于提高对平台的教育和创新。
- en: Another benefit of Kubernetes’ large community is the number of different tools
    built to augment the abilities that are provided. Helm is one such tool. As we’ll
    see later in this chapter and throughout this book, Helm—a tool built by members
    of the Kubernetes community—vastly improves a developer’s experience by simplifying
    application deployments and life cycle management.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 大型社区的另一个好处是，许多不同的工具被构建出来以增强所提供的能力。Helm 就是其中一个工具。正如我们在本章和本书中将看到的那样，Helm——一个由
    Kubernetes 社区成员构建的工具——通过简化应用程序部署和生命周期管理，极大地改善了开发人员的体验。
- en: With an understanding of the benefits Kubernetes brings to managing containerized
    workloads, let’s now discuss how an application can be deployed in Kubernetes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了 Kubernetes 在管理容器化工作负载中的优势后，接下来我们将讨论如何在 Kubernetes 中部署应用程序。
- en: Deploying a Kubernetes application
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中部署应用程序
- en: 'Deploying an application on Kubernetes is fundamentally similar to deploying
    an application outside of Kubernetes. All applications, whether containerized
    or not, must consider the following configuration details:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上部署应用程序的基本方式与在 Kubernetes 外部部署应用程序类似。所有应用程序，无论是否容器化，都必须考虑以下配置细节：
- en: Networking
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: Persistent storage and file mounts
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久存储和文件挂载
- en: Resource allocation
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源分配
- en: Availability and redundancy
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性与冗余
- en: Runtime configuration
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时配置
- en: Security
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Configuring these details on Kubernetes is done by interacting with the Kubernetes
    **application programming interface** (**API**). The Kubernetes API serves as
    a set of endpoints that can be interacted with to view, modify, or delete different
    Kubernetes resources, many of which are used to configure different details of
    an application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上配置这些细节是通过与 Kubernetes **应用程序编程接口**（**API**）进行交互来完成的。Kubernetes
    API 作为一组端点，可以通过这些端点查看、修改或删除不同的 Kubernetes 资源，其中许多资源用于配置应用程序的不同细节。
- en: 'There are many different Kubernetes API resources, but the following table
    shows some of the most common ones:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 有许多不同的 API 资源，但下表展示了一些最常见的资源：
- en: '| **Resource Name** | **Definition** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **资源名称** | **定义** |'
- en: '| Pod | The smallest deployable unit in Kubernetes. Encapsulates one or more
    containers. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| Pod | Kubernetes 中最小的可部署单元。封装一个或多个容器。 |'
- en: '| `Deployment` | Used to deploy and manage a set of Pods. Maintains the desired
    amount of Pod replicas (1 by default). |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `Deployment` | 用于部署和管理一组 Pod。保持所需数量的 Pod 副本（默认 1 个）。 |'
- en: '| `StatefulSet` | Similar to a Deployment resource, except a StatefulSet maintains
    a sticky identity for each Pod replica and can also provision PersistentVolumeClaims
    resources (explained further down in this table) unique to each Pod. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `StatefulSet` | 类似于 Deployment 资源，不同之处在于 StatefulSet 为每个 Pod 副本维护一个粘性身份，并且可以为每个
    Pod 提供独特的 PersistentVolumeClaim 资源（在下文表格中进一步解释）。 |'
- en: '| `Service` | Used to load-balance between Pod replicas. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `Service` | 用于在 Pod 副本之间进行负载均衡。 |'
- en: '| `Ingress` | Provides external access to services within the cluster. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `Ingress` | 提供集群内部服务的外部访问。 |'
- en: '| `ConfigMap` | Stores application configuration to decouple configuration
    from code. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `ConfigMap` | 存储应用程序配置，以将配置与代码解耦。 |'
- en: '| `Secret` | Used to store sensitive data such as credentials and keys. Data
    stored in Secrets resources are only obfuscated using Base64 encoding, so administrators
    must ensure that proper access controls are in place. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `Secret` | 用于存储敏感数据，如凭证和密钥。存储在 Secrets 资源中的数据仅通过 Base64 编码进行模糊化，因此管理员必须确保实施了适当的访问控制。
    |'
- en: '| `PersistentVolumeClaim` | A request for storage by a user. Used to provide
    persistence for running Pods. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `PersistentVolumeClaim` | 用户请求的存储。用于为运行中的 Pod 提供持久化。 |'
- en: '| `Role` | Represents a set of permissions to be allowed against the Kubernetes
    API. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `Role` | 表示一组允许在 Kubernetes API 上执行的权限。 |'
- en: '| `RoleBinding` | Grants the permissions defined in a role to a user or set
    of users. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `RoleBinding` | 将角色中定义的权限授予一个或一组用户。 |'
- en: Table 1.1 – Common Kubernetes resources
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 – 常见的 Kubernetes 资源
- en: Creating resources is central to deploying and managing an application on Kubernetes,
    but what does a user need to do to create them? We will explore this question
    further in the next section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建资源是部署和管理 Kubernetes 上应用程序的核心，但用户需要做些什么来创建这些资源呢？我们将在下一部分进一步探讨这个问题。
- en: Approaches to resource management
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源管理方法
- en: In order to deploy an application on Kubernetes, we need to interact with the
    Kubernetes API to create resources. `kubectl` is the tool we use to talk to the
    Kubernetes API. `kubectl` is a **command-line interface** (**CLI**) tool used
    to abstract the complexity of the Kubernetes API from end users, allowing them
    to more efficiently work on the platform.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Kubernetes上部署一个应用程序，我们需要与Kubernetes API交互来创建资源。`kubectl`是我们用来与Kubernetes
    API沟通的工具。`kubectl`是一个**命令行界面**（**CLI**）工具，用于将Kubernetes API的复杂性抽象化，让最终用户更高效地在平台上工作。
- en: Let’s discuss how `kubectl` can be used to manage Kubernetes resources.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下如何使用`kubectl`来管理Kubernetes资源。
- en: Imperative and declarative configurations
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式和声明式配置
- en: 'The `kubectl` tool provides a series of subcommands to create and modify resources
    in an imperative fashion. Here is a small list of these commands:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`工具提供了一系列子命令，以命令式的方式创建和修改资源。以下是这些命令的一小部分：'
- en: '`create`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`'
- en: '`describe`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe`'
- en: '`edit`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edit`'
- en: '`delete`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`'
- en: 'The `kubectl` commands follow a common format, as shown here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`命令遵循一种常见格式，如下所示：'
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `verb` refers to one of the `kubectl` subcommands, and the `noun` refers
    to a particular Kubernetes resource. For example, the following command can be
    run to create a deployment:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`verb`指的是`kubectl`子命令中的一个动词，`noun`指的是特定的Kubernetes资源。例如，以下命令可以用于创建一个部署：'
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This would instruct `kubectl` to talk to the Deployment API endpoint and create
    a new deployment called `my-deployment`, using the `busybox` image from Docker
    Hub.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示`kubectl`与部署API端点通信，使用来自Docker Hub的`busybox`镜像创建一个名为`my-deployment`的新部署。
- en: 'You could use `kubectl` to get more information on the deployment that was
    created by using the `describe` subcommand, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`kubectl`通过`describe`子命令获取关于已创建部署的更多信息，如下所示：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command would retrieve information about the deployment and format the
    result in a readable format that allows developers to inspect the live `my-deployment`
    deployment on Kubernetes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将获取关于部署的信息，并以易读的格式显示结果，允许开发人员检查Kubernetes上正在运行的`my-deployment`部署。
- en: 'If a change to the deployment was desired, a developer could use the `edit`
    subcommand to modify it in place, like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更改部署，开发人员可以使用`edit`子命令在原地修改它，如下所示：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command would open a text editor, allowing you to modify the deployment.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会打开文本编辑器，允许你修改该部署。
- en: 'When it comes to deleting a resource, the user could run the `delete` subcommand,
    as illustrated here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要删除资源时，用户可以运行`delete`子命令，如下所示：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This would call the appropriate API endpoint to delete the `my-deployment` deployment.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用相应的API端点来删除`my-deployment`部署。
- en: 'Kubernetes resources, once created, exist in the cluster as **JavaScript Object
    Notation** (**JSON**) resource files, which can be exported as **YAML Ain’t Markup
    Language** (**YAML**) files for greater human readability. An example resource
    in YAML format can be seen here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes资源一旦创建，就会以**JavaScript对象表示法**（**JSON**）资源文件的形式存在于集群中，这些文件可以导出为**YAML不是标记语言**（**YAML**）格式文件，以提高人类可读性。以下是YAML格式的示例资源：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding YAML format presents a very basic use case. It deploys the `busybox`
    image from Docker Hub and runs the `sleep` command indefinitely to keep the Pod
    running.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述YAML格式展示了一个非常基础的用例。它从Docker Hub部署`busybox`镜像，并运行`sleep`命令，保持Pod处于运行状态。
- en: While it may be easier to create resources imperatively using the `kubectl`
    subcommands we have just described, Kubernetes allows you to directly manage the
    YAML resources in a declarative fashion to gain more control over resource creation.
    The `kubectl` subcommands do not always let you configure all the possible resource
    options, but creating YAML files directly allows you to more flexibly create resources
    and fill in the gaps that the `kubectl` subcommands may contain.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用我们刚刚描述的`kubectl`子命令以命令式方式创建资源可能更为简单，但Kubernetes也允许你以声明式方式直接管理YAML资源，从而获得更高的资源创建控制力。`kubectl`子命令并不总是允许你配置所有可能的资源选项，但直接创建YAML文件则能让你更灵活地创建资源，并填补`kubectl`子命令可能存在的空白。
- en: When creating resources declaratively, users first write out the resource they
    want to create in YAML format. Next, they use the `kubectl` tool to apply the
    resource against the Kubernetes API. While in imperative configuration developers
    use `kubectl` subcommands to manage resources, declarative configuration relies
    primarily on only one subcommand—`apply`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明式创建资源时，用户首先以 YAML 格式编写要创建的资源。然后，他们使用 `kubectl` 工具将该资源应用到 Kubernetes API 上。而在命令式配置中，开发人员使用
    `kubectl` 子命令来管理资源，声明式配置则主要依赖一个子命令——`apply`。
- en: 'Declarative configuration often takes the following form:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式配置通常呈现以下形式：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command gives Kubernetes a YAML resource that contains a resource specification,
    although the JSON format can be used as well. Kubernetes infers the action to
    perform on resources (create or modify) based on whether or not they exist.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令向 Kubernetes 提供一个包含资源规范的 YAML 资源，尽管也可以使用 JSON 格式。Kubernetes 根据资源是否存在来推断执行的操作（创建或修改）。
- en: 'An application may be configured declaratively by following these steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下步骤声明性地配置应用：
- en: 'First, the user can create a file called `deployment.yaml` and provide a YAML-formatted
    specification for the deployment. We will use the same example as before, as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，用户可以创建一个名为 `deployment.yaml` 的文件，并提供一个 YAML 格式的部署规范。我们将使用之前的相同示例，如下所示：
- en: '[PRE7]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A deployment can then be created with the following command:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用以下命令来创建部署：
- en: '[PRE8]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Upon running this command, Kubernetes will attempt to create a deployment in
    the way you specified.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 执行该命令后，Kubernetes 将尝试按照你指定的方式创建部署。
- en: 'If you wanted to make a change to the deployment by changing the number of
    replicas to `2`, you would first modify the `deployment.yaml` file, as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想通过将副本数更改为 `2` 来修改部署，首先需要修改 `deployment.yaml` 文件，如下所示：
- en: '[PRE9]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You would then apply the change with `kubectl apply`, like this:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以使用 `kubectl apply` 应用更改，如下所示：
- en: '[PRE10]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After running that command, Kubernetes would apply the provided deployment declaration
    over the previously applied deployment. At this point, the application would scale
    up from a replica value of `1` to `2`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 执行该命令后，Kubernetes 会将提供的部署声明应用到之前已应用的部署上。此时，应用将从副本数量 `1` 扩展到 `2`。
- en: 'When it comes to deleting an application, the Kubernetes documentation actually
    recommends doing so in an imperative manner; that is, using the `delete` subcommand
    instead of `apply`, as illustrated here:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在删除应用时，Kubernetes 文档实际上推荐采用命令式方式，即使用 `delete` 子命令而不是 `apply`，如图所示：
- en: '[PRE11]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the `delete` subcommand uses the `–f` flag to delete the resource
    from the given file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`delete` 子命令使用 `–f` 标志从指定的文件中删除资源。
- en: With an understanding of how Kubernetes resources are created, let’s now discuss
    some of the challenges involved in resource configuration.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了 Kubernetes 资源的创建方式后，我们现在来讨论一些资源配置中涉及的挑战。
- en: Resource configuration challenges
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源配置挑战
- en: 'In the previous section, we covered how Kubernetes has two different configuration
    methods—imperative and declarative. One question to consider is this: *What challenges
    do users need to be aware of when creating Kubernetes resources with imperative
    and declarative methodologies?*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们讨论了 Kubernetes 有两种不同的配置方法——命令式和声明式。一个需要考虑的问题是：*在使用命令式和声明式方法创建 Kubernetes
    资源时，用户需要意识到哪些挑战？*
- en: Let’s discuss some of the most common challenges.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些最常见的挑战。
- en: The many types of Kubernetes resources
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 资源的多种类型
- en: First of all, as described in the *Deploying a Kubernetes application* section,
    there are many different types of resources in Kubernetes. In order to be effective
    on Kubernetes, developers need to be able to determine which resources are required
    to deploy their applications, and they need to understand them at a deep enough
    level to configure them appropriately. This requires a lot of knowledge of and
    training on the platform. While understanding and creating resources may already
    sound like a large hurdle, this is actually just the beginning of many different
    operational challenges.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如在 *部署 Kubernetes 应用* 部分所述，Kubernetes 中有许多不同类型的资源。为了在 Kubernetes 上有效运行，开发人员需要能够确定部署应用所需的资源，并且需要在足够深入的层次上理解它们，以便适当配置。这需要大量的平台知识和培训。虽然理解并创建资源可能听起来已经是一个很大的障碍，但这实际上只是许多不同操作挑战的开始。
- en: Keeping live and local states in sync
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持实时和本地状态同步
- en: A method of configuring Kubernetes resources that we would encourage is to maintain
    their configuration in source control for teams to edit and share, which also
    allows the source control repository to become the source of truth. The configuration
    defined in source control (referred to as the *local state*) is then created by
    applying them to the Kubernetes environment, and the resources become *live* or
    enter what can be called a *live state*. This sounds simple enough, but what happens
    when developers need to make changes to their resources? The proper answer would
    be to modify the files in source control and apply the changes to synchronize
    the local state to the live state. However, this isn’t what always ends up happening.
    It is often simpler, in the short term, to modify the live resource in place with
    `kubectl edit` or `kubectl patch` and completely skip over modifying the local
    files. This results in state inconsistency between local and live states and is
    an act that makes scaling on Kubernetes difficult.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议的 Kubernetes 资源配置方法是将其配置保存在源代码管理中，供团队编辑和共享，这也使得源代码管理仓库成为“真理之源”。源代码管理中定义的配置（称为*本地状态*）通过应用到
    Kubernetes 环境中来创建，然后这些资源变得*活跃*，或进入可以称之为*活跃状态*的状态。听起来似乎很简单，但当开发者需要对其资源进行修改时会发生什么？正确的做法是修改源代码管理中的文件并应用更改，以便将本地状态与活跃状态同步。然而，实际情况往往不是这样。短期内，更简单的做法是直接在活跃资源上使用`kubectl
    edit`或`kubectl patch`进行修改，完全跳过修改本地文件。这会导致本地状态与活跃状态之间的不一致，从而使得在 Kubernetes 上进行扩展变得困难。
- en: Application life cycles are hard to manage
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序生命周期难以管理
- en: Life cycle management is a loaded term, but in this context, we’ll refer to
    it as the concept of installing, upgrading, and rolling back applications. In
    the Kubernetes world, an installation would include API resources for deploying
    and configuring an application. The initial installation would create what we
    refer to here as version 1 of an application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期管理是一个含义丰富的术语，但在此背景下，我们将其定义为安装、升级和回滚应用程序的概念。在 Kubernetes 的世界里，安装包括部署和配置应用程序的
    API 资源。初次安装将创建我们这里称为应用程序版本 1 的内容。
- en: An upgrade, then, can be thought of as a modification to one or many of those
    Kubernetes resources. Each batch of edits can be thought of as a single upgrade.
    A developer could modify a single service resource, which would bump the version
    number to version 2\. The developer could then modify a deployment, a configmap,
    and a service at the same time, bumping the version count to version 3.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 升级可以被看作是对一个或多个 Kubernetes 资源的修改。每一批编辑可以看作是一次单独的升级。开发者可以修改单一的服务资源，这样版本号就会提升到版本
    2。开发者随后可以同时修改部署、配置映射和服务，将版本号提升到版本 3。
- en: As newer versions of an application continue to be rolled out onto Kubernetes,
    it becomes more difficult to keep track of changes that have occurred across relevant
    API resources. Kubernetes, in most cases, does not have an inherent way of keeping
    a history of changes. While this makes upgrades harder to keep track of, it also
    makes restoring a prior version of an application much more difficult. Say, for
    example, a developer previously made an incorrect edit on a particular resource.
    How would a team know where to roll back to? The `n-1` case is particularly easy
    to work out, as that is the most recent version. What happens, however, if the
    latest stable release was five versions ago? Teams often end up scrambling to
    resolve issues because they cannot quickly identify the latest stable configuration
    that worked previously.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新版应用程序不断在 Kubernetes 上发布，跟踪相关 API 资源发生的变化变得更加困难。Kubernetes 在大多数情况下没有内建的方式来保留变更历史。虽然这使得升级更难跟踪，但也使得恢复先前版本的应用程序变得更加困难。例如，假设开发者之前在某个资源上进行了错误编辑。团队如何知道应该回滚到哪个版本？`n-1`的情况相对容易解决，因为它是最近的版本。然而，如果最新的稳定版本是在五个版本之前呢？团队往往会因为无法快速识别之前曾经有效的最新稳定配置而陷入混乱。
- en: Resource files are static
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源文件是静态的
- en: This is a challenge that primarily affects the declarative configuration style
    of applying YAML resources. Part of the difficulty in following a declarative
    approach is that Kubernetes resource files are not natively designed to be parameterized.
    Resource files are largely designed to be written out in full before being applied,
    and the contents remain the **source of truth** (**SOT**) until the file is modified.
    When dealing with Kubernetes, this can be a frustrating reality. Some API resources
    can be lengthy, containing many different customizable fields, and it can be quite
    cumbersome to write and configure YAML resources in full.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个主要影响声明式配置风格应用 YAML 资源的挑战。遵循声明式方法的困难部分在于，Kubernetes 资源文件本身并不是为了参数化而设计的。资源文件大多设计为在应用之前先完全编写好，且文件内容在修改之前始终是**事实来源**（**SOT**）。在处理
    Kubernetes 时，这可能是一个令人沮丧的现实。一些 API 资源可能非常长，包含许多不同的可定制字段，编写和配置完整的 YAML 资源可能非常繁琐。
- en: Static files lend themselves to becoming boilerplate. **Boilerplate** represents
    text or code that remains largely consistent in different but similar contexts.
    This becomes an issue if developers manage multiple different applications, where
    they could potentially manage multiple different deployment resources, multiple
    different services, and so on. In comparing the different applications’ resource
    files, you may find large numbers of similar YAML configurations between them.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 静态文件容易变成模板。**模板**指的是在不同但相似的上下文中基本保持一致的文本或代码。如果开发者管理多个不同的应用程序，并且可能管理多个不同的部署资源、多个不同的服务等，那么这就成为了一个问题。在比较不同应用程序的资源文件时，你可能会发现它们之间有大量相似的
    YAML 配置。
- en: 'The following screenshot depicts an example of two resources with significant
    boilerplate configuration between them. The blue text denotes lines that are boilerplate,
    while the red text denotes lines that are unique:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了两个资源示例，它们之间有大量相似的模板配置。蓝色文本表示模板行，红色文本表示独特的行：
- en: '![](img/Figure_1.2_B17979.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_1.2_B17979.jpg)'
- en: Figure 1.2 – An example of two resources with boilerplate
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 两个资源的模板示例
- en: Notice, in this example, that both files are almost exactly the same. When managing
    files that are as similar as this, boilerplate becomes a major headache for teams
    managing their applications in a declarative fashion.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，两个文件几乎完全相同。在管理如此相似的文件时，模板成为了团队以声明式方式管理应用程序的一大难题。
- en: Helm to the rescue!
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm 来救场了！
- en: Over time, the Kubernetes community discovered that creating and maintaining
    Kubernetes resources to deploy applications is difficult. This prompted the development
    of a simple yet powerful tool that would allow teams to overcome the challenges
    posed by deploying applications on Kubernetes. The tool that was created is called
    Helm. **Helm** is an open source tool used for packaging and deploying applications
    on Kubernetes. It is often referred to as the **Kubernetes package manager** because
    of its similarities to any other package manager you would find on your favorite
    **operating system** (**OS**). Helm is widely used throughout the Kubernetes community
    and is a CNCF graduated project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，Kubernetes 社区发现创建和维护 Kubernetes 资源以部署应用程序是一项困难的任务。这促使了一个简单但强大的工具的开发，该工具可以帮助团队克服在
    Kubernetes 上部署应用程序所带来的挑战。这个工具叫做 Helm。**Helm** 是一个开源工具，用于在 Kubernetes 上打包和部署应用程序。由于其与任何你最喜欢的**操作系统**（**OS**）中的包管理器类似，它通常被称为
    **Kubernetes 包管理器**。Helm 在 Kubernetes 社区中被广泛使用，是一个 CNCF 毕业项目。
- en: Given Helm’s similarities to traditional package managers, let’s begin exploring
    Helm by first reviewing how a package manager works.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于 Helm 与传统包管理器的相似性，让我们先从回顾包管理器的工作原理开始，来探索 Helm。
- en: Understanding package managers
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解包管理器
- en: Package managers are used to simplify the process of installing, upgrading,
    reverting, and removing a system’s applications. These applications are defined
    as packages that contain metadata around target software and its dependencies.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器用于简化安装、升级、回滚和删除系统应用程序的过程。这些应用程序被定义为包含目标软件及其依赖关系元数据的包。
- en: The idea behind package managers is simple. First, the user passes the name
    of a software package as an argument. The package manager then performs a lookup
    against a repository to see whether that package exists. If it is found, the package
    manager installs the application defined by the package and its dependencies to
    specified locations on the system.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器背后的思想很简单。首先，用户将软件包的名称作为参数传递。然后，包管理器会对仓库进行查找，看看该包是否存在。如果找到，包管理器会安装由该软件包定义的应用程序及其依赖项，并将其安装到系统中指定的位置。
- en: 'Package managers make managing software very easy. As an example, let’s imagine
    you wanted to install `htop`, a Linux system monitor, to a Fedora machine. Installing
    this would be as simple as typing a single command, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器使得软件管理变得非常容易。举个例子，假设你想要在 Fedora 系统上安装 `htop`，一个 Linux 系统监控工具。安装这个软件只需要输入一条命令，如下所示：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This instructs `dnf`, the Fedora package manager, to find `htop` in the Fedora
    package repository and install it. `dnf` also takes care of installing the `htop`
    package’s dependencies, so you don’t have to worry about installing its requirements
    beforehand. After `dnf` finds the `htop` package from the upstream repository,
    it asks you whether you’re sure you want to proceed. The `--assumeyes` flag automatically
    answers yes to this question and any other prompts that `dnf` may potentially
    ask.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这条命令指示 Fedora 包管理器 `dnf` 在 Fedora 包仓库中查找 `htop` 并安装它。`dnf` 还会处理安装 `htop` 包的依赖项，因此你不必担心提前安装其要求。在
    `dnf` 从上游仓库找到 `htop` 包后，它会询问你是否确定要继续操作。`--assumeyes` 标志会自动回答“是”，并对 `dnf` 可能提出的其他任何提示作出回应。
- en: 'Over time, newer versions of `htop` may appear in the upstream repository.
    `dnf` and other package managers allow users to efficiently upgrade to new versions
    of the software. The subcommand that allows users to upgrade using `dnf` is `upgrade`,
    as illustrated here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，`htop` 的新版本可能会出现在上游仓库中。`dnf` 和其他包管理器允许用户高效地升级到软件的最新版本。允许用户使用 `dnf` 升级的子命令是
    `upgrade`，如下所示：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This instructs `dnf` to upgrade `htop` to its latest version. It also upgrades
    its dependencies to the versions specified in the package’s metadata.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这条命令指示 `dnf` 将 `htop` 升级到最新版本，同时也将其依赖项升级到包元数据中指定的版本。
- en: 'While moving forward is often better, package managers also allow users to
    move backward and revert an application to a prior version if necessary. `dnf`
    does this with the `downgrade` subcommand, as illustrated here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管向前推进通常更好，但包管理器也允许用户回退并在必要时将应用程序恢复到先前的版本。`dnf` 使用 `downgrade` 子命令来实现这一点，如下所示：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a powerful process because the package manager allows users to quickly
    roll back if a critical bug or vulnerability is reported.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强大的过程，因为包管理器允许用户在报告出关键错误或漏洞时快速回滚。
- en: 'If you want to remove an application completely, a package manager can take
    care of that as well. `dnf` provides the `remove` subcommand for this purpose,
    as illustrated here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想完全删除一个应用程序，包管理器也可以帮你处理。`dnf` 提供了 `remove` 子命令来实现这一目的，如下所示：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this section, we reviewed how the `dnf` package manager on Fedora can be
    used to manage a software package. Helm, as the Kubernetes package manager, is
    similar to `dnf`, both in its purpose and functionality. While `dnf` is used to
    manage applications on Fedora, Helm is used to manage applications on Kubernetes.
    We will explore this in greater detail next.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了如何使用 Fedora 上的 `dnf` 包管理器来管理软件包。作为 Kubernetes 的包管理器，Helm 与 `dnf` 相似，无论是其目的还是功能。`dnf`
    用于管理 Fedora 上的应用程序，而 Helm 用于管理 Kubernetes 上的应用程序。接下来我们将深入探讨这一点。
- en: The Kubernetes package manager
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 包管理器
- en: Given that Helm was designed to provide an experience similar to that of package
    managers, experienced users of `dnf` or similar tools will immediately understand
    Helm’s basic concepts. Things become more complicated, however, when talking about
    the specific implementation details. `dnf` operates on **RPM Package Manager**
    (**RPM**) packages that provide executables, dependency information, and metadata.
    Helm, on the other hand, works with **charts**. A Helm chart can be thought of
    as a Kubernetes package. Charts contain the declarative Kubernetes resource files
    required to deploy an application. Similar to an RPM package, it can also declare
    one or more dependencies that the application needs in order to run.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Helm的设计目标是提供类似于包管理器的体验，`dnf`或类似工具的经验用户将立即理解Helm的基本概念。然而，谈到具体的实现细节时，事情变得更加复杂。`dnf`操作的是**RPM包管理器**（**RPM**）包，这些包提供可执行文件、依赖关系信息和元数据。而Helm则使用**图表**。可以将Helm图表视为Kubernetes包。图表包含了部署应用所需的声明性Kubernetes资源文件。类似于RPM包，它还可以声明应用运行所需的一个或多个依赖项。
- en: Helm relies on repositories to provide widespread access to charts. Chart developers
    create declarative YAML files, package them into charts, and publish them to chart
    repositories. End users then use Helm to search for existing charts to deploy
    onto Kubernetes, similar to how end users of `dnf` will search for RPM packages
    to deploy to Fedora.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Helm依赖于仓库来提供对图表的广泛访问。图表开发人员创建声明性的YAML文件，将其打包成图表，并将其发布到图表仓库。最终用户然后使用Helm搜索现有的图表，并将其部署到Kubernetes，类似于`dnf`的最终用户搜索RPM包并将其部署到Fedora。
- en: 'Let’s go through a basic example. Helm can be used to deploy Redis, an in-memory
    cache, to Kubernetes by using a chart from an upstream repository. This can be
    performed using Helm’s `install` command, as illustrated here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个基本示例。Helm可以通过使用来自上游仓库的图表将Redis（一个内存缓存）部署到Kubernetes。可以使用Helm的`install`命令来执行此操作，如下所示：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This would install the `redis` chart from the `bitnami` repository to a Kubernetes
    namespace called `redis`. This installation would be referred to as the initial
    revision, or the initial installation of a Helm chart.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从`bitnami`仓库安装`redis`图表到名为`redis`的Kubernetes命名空间。此安装将被称为初始修订版，或者Helm图表的初始安装。
- en: 'If a new version of the `redis` chart becomes available, users can upgrade
    to the new version using the `upgrade` command, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`redis`图表发布了新版本，用户可以使用`upgrade`命令升级到新版本，如下所示：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This would upgrade `redis` to meet the specification defined by the newer `redis`
    chart.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这将升级`redis`，以满足新版`redis`图表定义的规范。
- en: 'With OSs, users should be concerned about rollbacks if a bug or vulnerability
    is found. The same concern exists with applications on Kubernetes, and Helm provides
    the `rollback` command to handle this use case, as illustrated here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于操作系统，如果发现bug或漏洞，用户应该关注回滚问题。Kubernetes上的应用也存在相同的担忧，Helm提供了`rollback`命令来处理这种用例，如下所示：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This command would roll `redis` back to its first revision.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将`redis`回滚到其第一个修订版。
- en: 'Finally, Helm provides the ability to remove `redis` altogether with the `uninstall`
    command, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Helm提供了使用`uninstall`命令完全删除`redis`的功能，如下所示：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Compare `dnf` and Helm’s subcommands, and the functions they serve in the following
    table. Notice that `dnf` and Helm offer similar commands that provide a similar
    **user experience** (**UX**):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 比较`dnf`和Helm的子命令，以及它们在下表中所执行的功能。请注意，`dnf`和Helm提供了类似的命令，提供类似的**用户体验**（**UX**）：
- en: '| `dnf` subcommands | Helm subcommands | Purpose |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `dnf`子命令 | Helm子命令 | 目的 |'
- en: '| `install` | `Install` | Install an application and its dependencies. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `install` | `Install` | 安装应用程序及其依赖项。 |'
- en: '| `upgrade` | `Upgrade` | Upgrade an application to a newer version. Upgrade
    dependencies as specified by the target package. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `upgrade` | `Upgrade` | 将应用程序升级到较新版本。根据目标软件包的要求升级依赖项。 |'
- en: '| `downgrade` | `rollback` | Revert an application to a previous version. Revert
    dependencies as specified by the target package. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `downgrade` | `rollback` | 将应用程序恢复到先前的版本。根据目标软件包的要求恢复依赖项。 |'
- en: '| `remove` | `uninstall` | Delete an application. Each tool has a different
    philosophy around handling dependencies. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `remove` | `uninstall` | 删除应用程序。每个工具对处理依赖项有不同的哲学。 |'
- en: Table 1.2 – Purpose of dnf and Helm subcommands
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.2 – dnf和Helm子命令的目的
- en: With an understanding of how Helm functions as a package manager, let’s discuss
    in greater detail the benefits that Helm brings to Kubernetes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Helm 作为包管理器的功能后，让我们更详细地讨论 Helm 为 Kubernetes 带来的好处。
- en: The benefits of Helm
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm 的好处
- en: Earlier in this chapter, we reviewed how Kubernetes applications are created
    by managing Kubernetes resources, and we discussed some of the challenges involved.
    Here are a few ways Helm can overcome these challenges.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之前，我们回顾了 Kubernetes 应用程序是如何通过管理 Kubernetes 资源来创建的，并讨论了其中的一些挑战。以下是 Helm 如何克服这些挑战的几种方式。
- en: Abstracting the complexity of Kubernetes resources
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象 Kubernetes 资源的复杂性
- en: Let’s assume that a developer has been given the task of deploying a WordPress
    instance onto Kubernetes. The developer would need to create the resources required
    to configure its containers, network, and storage. The amount of Kubernetes knowledge
    required to configure such an application from scratch is high and is a big hurdle
    for new—and even intermediate Kubernetes users—to clear.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设开发人员被要求将 WordPress 实例部署到 Kubernetes 上。开发人员需要创建配置其容器、网络和存储所需的资源。要从头开始配置此类应用程序所需的
    Kubernetes 知识很高，这是新手甚至中级 Kubernetes 用户需要跨越的一个大障碍。
- en: With Helm, a developer tasked with deploying a WordPress instance could simply
    search for WordPress charts from upstream chart repositories. These charts would
    have already been written by chart developers in the community and would already
    contain the declarative configuration required to deploy WordPress and a backing
    database. Vendor-owned chart repositories also tend to be well maintained, so
    teams using charts from them would not need to worry about keeping Kubernetes
    resources up to date. In this regard, developers with this kind of task would
    act as simple end users that consume Helm in a similar way to any other package
    manager.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Helm，负责部署 WordPress 实例的开发人员可以简单地从上游 chart 仓库中搜索 WordPress chart。这些 chart
    已经由社区中的 chart 开发者编写，并且已经包含了部署 WordPress 和后端数据库所需的声明式配置。供应商拥有的 chart 仓库通常也会得到很好的维护，因此使用这些仓库中的
    chart 的团队无需担心保持 Kubernetes 资源的最新状态。在这方面，承担此类任务的开发人员将像使用任何其他包管理器一样，充当简单的终端用户，消费
    Helm。
- en: Maintaining an ongoing history of revisions
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 维护修订历史的持续更新
- en: Helm has a concept called **release history**. When a Helm chart is installed
    for the first time, Helm adds that initial revision to the history. The history
    is further modified as revisions increase via upgrades, keeping various snapshots
    of how the application was configured at varying revisions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 有一个叫做**发布历史**的概念。当 Helm chart 第一次安装时，Helm 会将该初始修订版本添加到历史记录中。随着修订版本通过升级不断增加，历史记录会进一步修改，保留不同修订版本下应用程序配置的快照。
- en: 'The following diagram depicts an ongoing history of revisions. The squares
    in blue illustrate resources that have been modified from their previous versions:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了修订历史的持续过程。蓝色的方框表示已经从先前版本修改过的资源：
- en: '![Figure 1.3 – An example of a revision history'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.3 – 修订历史的示例'
- en: '](img/Figure_1.3_B17979.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.3_B17979.jpg)'
- en: Figure 1.3 – An example of a revision history
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.3 – 修订历史的示例
- en: The process of tracking each revision provides opportunities for rollback. Rollbacks
    in Helm are very simple. Users simply point Helm to a previous revision, and Helm
    reverts the live state to that of the selected revision. Helm allows users to
    roll back their applications as far as they desire, even back to the very first
    installation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪每次修订的过程提供了回滚的机会。Helm 中的回滚非常简单。用户只需将 Helm 指向先前的修订版本，Helm 会将实时状态还原为所选修订版本的状态。Helm
    允许用户根据需要将应用程序回滚到任何时间点，甚至是最初的安装版本。
- en: Configuring declarative resources in a dynamic fashion
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以动态方式配置声明式资源
- en: One of the biggest hassles with creating resources declaratively is that Kubernetes
    resources are static and cannot be parameterized. As you may recall from earlier,
    this results in resources becoming boilerplate across applications and similar
    configurations, making it more difficult for teams to configure their applications
    as code. Helm alleviates these issues by introducing **values** and **templates**.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 创建声明式资源时最大的麻烦之一是 Kubernetes 资源是静态的，无法参数化。如您从之前所述，资源在应用程序和类似配置之间变得一成不变，这使得团队更难将应用程序配置为代码。Helm
    通过引入**值**和**模板**来缓解这些问题。
- en: Values can be thought of as parameters for charts. Templates are dynamically
    generated files based on a given set of values. These two constructs give chart
    developers the ability to write Kubernetes resources that are generated based
    on values that end users provide. By doing so, applications managed by Helm become
    more flexible, have less boilerplate, and are easier to maintain.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 值可以被视为图表的参数。模板是基于一组给定的值动态生成的文件。这两个构造为图表开发人员提供了根据最终用户提供的值生成Kubernetes资源的能力。通过这样做，Helm
    管理的应用程序变得更加灵活，减少了冗余代码，并且更易于维护。
- en: 'Values and templates allow users to do things such as this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 值和模板允许用户执行类似以下操作：
- en: Parameterize common fields, such as the image name in a deployment and the ports
    in a service.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化常见字段，例如部署中的镜像名称和服务中的端口。
- en: Generate long pieces of YAML configuration based on user input, such as volume
    mounts in a deployment or the data in a ConfigMap.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户输入生成长篇的 YAML 配置，例如在部署中的卷挂载或 ConfigMap 中的数据。
- en: Include or exclude resources based on user input.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户输入包含或排除资源。
- en: The ability to dynamically generate declarative resource files makes it simpler
    to create YAML-based resources while still ensuring that applications are deployed
    in an easily reproducible fashion.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 动态生成声明性资源文件的能力使得创建基于 YAML 的资源变得更加简单，同时确保应用程序以易于重现的方式进行部署。
- en: Simplifying local and live state synchronization
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化本地状态和实时状态的同步。
- en: Package managers prevent users from having to manage all of the intricate details
    of an application and its dependencies. The same idea holds true with Helm. Using
    Helm’s `values` construct, users can provide configuration changes across an application’s
    life cycle by managing a small number of parameters instead of multiple full-length
    YAML resources. When the local state (values/parameters) is updated, Helm propagates
    the configuration change out to the relevant resources in Kubernetes. This workflow
    keeps Helm in control of managing intricate Kubernetes details and encourages
    users to manage the state locally instead of updating live resources directly.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器防止用户需要管理应用程序及其依赖关系的所有复杂细节。Helm 也遵循相同的理念。使用 Helm 的`values`构造，用户可以通过管理少量参数而不是多个完整的
    YAML 资源，提供应用程序生命周期中的配置更改。当本地状态（值/参数）更新时，Helm 会将配置更改传播到 Kubernetes 中相关的资源。这种工作流程使
    Helm 控制 Kubernetes 细节的管理，并鼓励用户在本地管理状态，而不是直接更新实时资源。
- en: Deploying resources in an intelligent order
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以智能的顺序部署资源。
- en: Helm simplifies application deployments by having a pre-determined order in
    which Kubernetes resources need to be created. This ordering exists to ensure
    that dependent resources are deployed first. For example, Secret instances and
    ConfigMap instances should be created before deployments, since a deployment would
    likely consume those resources as volumes. Helm performs this ordering without
    any interaction from the user, so this complexity is abstracted and prevents users
    from needing to understand the order in which resources should be applied.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 通过预定的顺序简化了应用程序部署，该顺序规定了 Kubernetes 资源需要创建的先后顺序。这一顺序确保依赖的资源优先部署。例如，Secret
    实例和 ConfigMap 实例应在部署之前创建，因为部署很可能会将这些资源作为卷使用。Helm 在无需用户干预的情况下执行这一顺序，因此这种复杂性被抽象化，防止用户需要理解资源应当以何种顺序应用。
- en: Providing automated life cycle hooks
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供自动化的生命周期挂钩。
- en: 'Similar to other package managers, Helm provides the ability to define life
    cycle hooks. Life cycle hooks are actions that take place automatically at different
    stages of an application’s life cycle. They can be used to do things such as the
    following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他包管理器类似，Helm 提供了定义生命周期挂钩的能力。生命周期挂钩是在应用程序生命周期的不同阶段自动执行的操作。它们可以用于执行以下任务：
- en: Perform a data backup on an upgrade.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在升级时执行数据备份。
- en: Restore data on a rollback.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在回滚时恢复数据。
- en: Validate a Kubernetes environment prior to installation.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安装之前验证 Kubernetes 环境。
- en: Life cycle hooks are valuable because they abstract complexities around tasks
    that may not be Kubernetes-specific. For example, a Kubernetes user may not be
    familiar with the best practices behind backing up a database or may not know
    when such a task should be performed. Life cycle hooks allow experts to write
    automation that handles various life cycle tasks and prevents users from needing
    to handle them on their own.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期钩子非常有价值，因为它们抽象了可能不是 Kubernetes 特有的任务的复杂性。例如，Kubernetes 用户可能不熟悉备份数据库的最佳实践，或者不知道何时应该执行此类任务。生命周期钩子允许专家编写自动化程序，处理各种生命周期任务，避免用户需要自行处理这些任务。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we began by exploring the trend of adopting microservice-based
    architectures to decompose monoliths into smaller applications. The creation of
    microservices that are more lightweight and easier to manage has led to utilizing
    containers as a packaging and runtime format to produce releases more frequently.
    By adopting containers, additional operational challenges were introduced and
    solved by using Kubernetes as a container orchestration platform to manage the
    container life cycle.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时，我们探讨了采用基于微服务的架构将单体应用拆解为更小型应用的趋势。创建更加轻量、易于管理的微服务，推动了容器作为打包和运行时格式的使用，从而实现了更频繁的发布。通过采用容器，引入了额外的运维挑战，并通过使用
    Kubernetes 作为容器编排平台来管理容器生命周期，解决了这些挑战。
- en: 'Our discussion turned to the various ways Kubernetes applications can be configured.
    These resources can be expressed using two distinct styles of application configuration:
    imperative and declarative. Each of these configuration styles contributes to
    a set of challenges involved in deploying Kubernetes applications, including the
    amount of knowledge required to understand how Kubernetes resources work and the
    challenge of managing application life cycles.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了 Kubernetes 应用程序可以配置的不同方式。这些资源可以通过两种不同的应用配置风格来表达：命令式和声明式。这两种配置风格各自带来了部署
    Kubernetes 应用程序时所面临的一些挑战，包括理解 Kubernetes 资源如何工作的知识量，以及管理应用生命周期的挑战。
- en: To better manage each of the assets that comprise an application, Helm was introduced
    as the package manager for Kubernetes. Through its rich feature set, the full
    life cycle of applications from installation, upgrading, and, rollback to deletion
    can be managed with ease.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地管理构成应用程序的各项资产，引入了 Helm 作为 Kubernetes 的包管理器。通过其丰富的功能集，可以轻松管理应用程序的完整生命周期，包括安装、升级、回滚和删除。
- en: In the next chapter, we’ll walk through the process of installing Helm and preparing
    an environment that can be used for following along with this book’s examples.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 Helm 安装过程，并准备一个可以跟随本书示例的环境。
- en: Further reading
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For more information about the Kubernetes resources that make up an application,
    please see the *Understanding Kubernetes Objects* page from the Kubernetes documentation
    at [https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/](B17979_01.xhtml#_idTextAnchor015).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有关构成应用程序的 Kubernetes 资源的更多信息，请参阅 Kubernetes 文档中的*理解 Kubernetes 对象*页面：[https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/](B17979_01.xhtml#_idTextAnchor015)。
- en: To reinforce some of the benefits of Helm discussed in this chapter, please
    refer to the *Using Helm* page of the Helm documentation at [https://helm.sh/docs/intro/using_helm/](B17979_01.xhtml#_idTextAnchor037).
    (This page also dives into some basic usage around Helm, which will be discussed
    throughout this book in greater detail.)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强化本章中讨论的 Helm 的一些优势，请参阅 Helm 文档中的*使用 Helm*页面：[https://helm.sh/docs/intro/using_helm/](B17979_01.xhtml#_idTextAnchor037)。（此页面还深入探讨了
    Helm 的一些基本用法，本书将在后续章节中详细讨论。）
- en: Questions
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Here are some questions to test your knowledge of the chapter:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些测试你对本章知识掌握情况的问题：
- en: What is the difference between a monolithic and a microservices application?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单体应用和微服务应用有什么区别？
- en: What is Kubernetes? What kinds of problems was it designed to solve?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Kubernetes？它是为解决什么样的问题而设计的？
- en: What are some of the `kubectl` commands commonly used when deploying applications
    to Kubernetes?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在向 Kubernetes 部署应用程序时，常用的 `kubectl` 命令有哪些？
- en: What challenges are often involved in deploying applications to Kubernetes?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在向 Kubernetes 部署应用程序时通常会遇到哪些挑战？
- en: How does Helm function as a Kubernetes package manager? How does it address
    the challenges posed by Kubernetes?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Helm 如何作为 Kubernetes 包管理器运作？它如何解决 Kubernetes 带来的挑战？
- en: Imagine you want to roll back an application deployed on Kubernetes. Which Helm
    command allows you to perform this action? How does Helm keep track of your changes
    to make this rollback possible?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你想回滚一个部署在 Kubernetes 上的应用程序。哪个 Helm 命令可以执行这个操作？Helm 如何跟踪你的更改以使得回滚成为可能？
- en: What are the four primary Helm commands?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Helm 的四个主要命令是什么？
