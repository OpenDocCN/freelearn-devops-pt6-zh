<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Kubernetes Client Libraries</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>Kubernetes provides multiple options for creating applications with the Kubernetes API. These options include tools such as <kbd>kubectl</kbd>, <kbd>helm</kbd>, <kbd>kops</kbd>, and <kbd>kubeadm</kbd>; and client libraries, which are officially supported or community-maintained. However, it is essential that you know the capabilities and boundaries of the clients in order to create applications that interact with Kubernetes.</span></p>
<p class="mce-root"><span>In this chapter, you will learn how to access the Kubernetes API directly and use Kubernetes client libraries. Firstly, direct access to the Kubernetes API will be explained, and responses from the Kubernetes API will be demonstrated. Following that, official and community-maintained libraries will be given, including detailed information and example applications. Throughout this chapter, you'll develop applications that connect to the Kubernetes API, inside and outside the cluster.<br/></span></p>
<p><span>By the end of this chapter, you will be able to:</span></p>
<ul>
<li><span>Evaluate the Kubernetes API request and response style</span></li>
<li><span>Connect to the Kubernetes API using HTTP</span></li>
<li><span>Find and use official client libraries</span></li>
<li><span>Write, run, and deploy client library applications</span></li>
<li><span>Evaluate community-maintained client libraries for further projects<br/></span></li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing the Kubernetes API</h1>
                </header>
            
            <article>
                
<p><span>Kubernetes consists of several loosely-coupled components, with the principal idea of managing versioned resources. Kubernetes components can be divided into two sections: the control plane and node components. The control plane consists of the API Server, Controller Managers, and Schedulers. The API Server is the core management component and has the following functionalities:</span></p>
<ul>
<li><span>Serves a REST API for the clients outside the cluster and Kubernetes components inside the cluster</span></li>
<li><span>Creates, deletes, and updates all of the Kubernetes resources, such as pods, deployments, and services</span></li>
<li><span>Stores the state of the objects in a distributed key/value store<br/></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kubernetes API Style</h1>
                </header>
            
            <article>
                
<p><span>The Kubernetes API is a RESTful service that requires all clients to create, read, update, and delete resources using HTTP requests, such as <kbd>GET</kbd>, <kbd>PUT</kbd>, <kbd>POST</kbd>, and <kbd>DELETE</kbd>. Client applications such as <kbd>kubectl</kbd> or client libraries in various programming languages implement the API response and request types. For communication, the Kubernetes API accepts and returns JSON data, just like most of the RESTful services that are available.<br/></span></p>
<div class="packt_infobox"><span><strong>Representational State Transfer</strong> (<strong>REST</strong>) is an architectural style for web applications so that they can use HTTP requests. As a convention, <kbd>GET</kbd> is used for reading resources, <kbd>POST</kbd> is used for creating resources, <kbd>PUT</kbd> is used for updating resources, and <kbd>DELETE</kbd> is used for deleting resources.<br/></span></div>
<p><span>Servers that apply the RESTful API are expected to have clients without any knowledge of server structure. Likewise, the server should provide all related information for the client so that it can operate and interact with itself.</span></p>
<p><span><strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) is a popular and lightweight data exchange format. JSON is suitable for machine parsing and generation, and is human-readable and expressive. Although written in JavaScript, JSON is supported by multiple languages and is a crucial data type of modern asynchronous browser/server communication.</span></p>
<p><span>In the following section, the Kubernetes API response style will be explored by calling an API server REST endpoint.<br/></span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting a JSON Response from the Kubernetes API</h1>
                </header>
            
            <article>
                
<p><span>This section shows how to retrieve raw data from the Kubernetes API by using <kbd>kubectl</kbd> and analyze the data as a JSON object for the parts of the resource.</span></p>
<p><span>Let's begin by implementing the following steps:<br/></span></p>
<ol>
<li><span>Get the raw data with the following command:</span></li>
</ol>
<pre style="padding-left: 60px"><span>kubectl get --raw /api/v1/namespaces/kube-system</span></pre>
<ol start="2">
<li>As a result, you will see a JSON response. Let's get the same command and format the output:</li>
</ol>
<pre style="padding-left: 60px"><span>kubectl get --raw /api/v1/namespaces/kube-system | python -m json.tool<br/></span></pre>
<p style="padding-left: 60px">If Python is not locally installed, any online JSON formatter can be used by copying and pasting the output.</p>
<ol start="3">
<li>The JSON response shows the structure of a Kubernetes API resource:</li>
</ol>
<pre style="padding-left: 60px">{<br/>"apiVersion": "v1",<br/>"kind": "Namespace",<br/>"metadata": {<br/>    "creationTimestamp": "2018-04-15T10:21:34Z",<br/>    "name": "kube-system",<br/>    "resourceVersion": "81",<br/>    "selfLink": "/api/v1/namespaces/kube-system",<br/>    "uid": "c5db1188-4096-11e8-903d-0800273b4d24"<br/>},<span><br/></span></pre>
<p><span>Kubernetes API resources have <kbd>"apiVersion"</kbd> since all resources are versioned in the system. <kbd>"kind"</kbd> shows the type of the resource and <kbd>"metadata"</kbd> has all of the meta information, such as the creation timestamp, labels, or annotations. <kbd>"spec"</kbd> is the part where all properties of the resource are listed. Finally, most of the resources have a <kbd>"status"</kbd> section to show their state, errors, or messages (if any).<br/></span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing the Kubernetes API</h1>
                </header>
            
            <article>
                
<p><span>The Kubernetes API server is secure, requiring all incoming connections to be authenticated. There are two common ways of connecting and securely communicating with the Kubernetes API server. The first one is by using the reverse proxy functionality of kubectl and the second one is by using the API server credentials. These approaches can be summarized as follows:<br/></span></p>
<ul>
<li><span>The reverse proxy Kubernetes API with kubectl:</span>
<ul>
<li><span>The Kubectl proxy command starts a proxy server between the localhost and the Kubernetes API server.</span></li>
<li><span>All incoming requests are forwarded to the remote Kubernetes API server port.</span></li>
<li><span>The API server identity is verified by using self-signed certificates so that no <strong>Man-in-the-Middle</strong> (<strong>MITM</strong>) attacks are is possible.</span></li>
<li><span>kubectl handles authentication to the API server. This is a recommended approach in the official Kubernetes documentation.</span></li>
<li><span>Further development is ongoing; client-side load balancing and failover features could be provided in the future.</span></li>
</ul>
</li>
<li><span>Provides the API server address and credentials directly:</span>
<ul>
<li><span>The API server address and credentials are available within and outside the cluster and they can be provided as parameters.</span></li>
<li><span>This is an alternative approach and should be used as a last resort if the client application cannot work with a reversed proxy.</span></li>
<li><span>In order to protect from MITM attacks, certificates should be imported to the clients, for example, through browsers.</span></li>
</ul>
</li>
</ul>
<p><span>In the following activity, connecting to the Kubernetes API by using the <kbd>kubectl</kbd> proxy is carried out to create a new Kubernetes namespace. With this method, <kbd>kubectl</kbd> securely connects to the API server with its own credentials and creates a proxy for the applications on the local system.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting to the Kubernetes API and Creating Namespaces</h1>
                </header>
            
            <article>
                
<p><span>In this section, you are assigned the job of creating namespaces for tests by using the Kubernetes API. Tests are running outside the cluster and communicate with the Kubernetes API. In order to run tests in their own namespaces, you need to create a namespace. With the successful completion of this task, a new namespace will be created within Kubernetes by sending JSON data. </span>Let's ensure to follow these steps before starting with our <span>example</span>:</p>
<ul>
<li><span>Create a proxy with kubectl and make it available to all applications on the local system</span></li>
<li><span>Use JSON and cURL to communicate with the Kubernetes API</span></li>
<li><span>Gather the JSON structure of the namespace resource by querying kubesystem and use it as a template<br/></span></li>
</ul>
<p>Let's begin by implementing the following steps:</p>
<ol>
<li><span>Start the reverse proxy with the following command:</span></li>
</ol>
<pre style="padding-left: 60px"><span>kubectl proxy --port=8080<br/></span></pre>
<ol start="2">
<li>In another terminal, create an HTTP request to the forwarded port:</li>
</ol>
<pre style="padding-left: 60px"><span>curl http://localhost:8080/api/v1/namespaces/kube-system<br/></span></pre>
<p style="padding-left: 60px"><span>The response is expected to be a JSON structure similar to the following:<br/></span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7abbc564-ca11-4aee-b64d-853f2c238915.png" style=""/></div>
<ol start="3">
<li>Using the response of <em>Step 2</em> as a template, create a simple namespace JSON object:</li>
</ol>
<pre style="padding-left: 60px"><span>{<br/>"apiVersion":"v1",<br/>"kind":"Namespace",<br/>"metadata":{<br/>"name":"packt-client"<br/>}<br/>}</span></pre>
<ol start="4">
<li>Create the new namespace by using <kbd>curl</kbd> with the payload data from <em>Step 3</em>:</li>
</ol>
<pre style="padding-left: 60px"><span>curl -X POST http://localhost:8080/api/v1/namespaces/ \<br/>--header "Content-Type: application/json" \<br/>--data \<br/>'{"apiVersion":"v1","kind":"Namespace","metadata":{"name":"packt-client"}}'<br/></span></pre>
<p style="padding-left: 60px"><span>As a result of this command, the newly created namespace data will be received:</span></p>
<div class="CDPAlignCenter CDPAlign" style="padding-left: 60px"><img src="assets/0f9024d6-4866-4623-ad2c-9ca54246b42c.png" style=""/></div>
<ol start="5">
<li>You can run the following command for cleanup:</li>
</ol>
<pre style="padding-left: 60px"><span>kubectl delete namespace packt-client<br/></span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing the Kubernetes API inside a Cluster</h1>
                </header>
            
            <article>
                
<p><span>Accessing the Kubernetes API outside the cluster is mostly done for operational bases where human interaction is required. In addition to outside communication, accessing the Kubernetes API inside the cluster to make requests to the API server is also possible. It enables writing applications and running them inside the cluster, which could convert operational knowledge into applications.</span></p>
<p><span>For all of the pods in the cluster, Kubernetes injects service accounts – they are the recommended way of authenticating to the Kubernetes API server. For each pod, the following information and credentials related to service accounts are mounted<br/>
by default:<br/></span></p>
<ul>
<li><span><strong>Service account and token</strong>: <kbd>/var/run/secrets/kubernetes.io/serviceaccount/token</kbd></span></li>
<li><span><strong>Certificate bundle</strong>: <kbd>/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</kbd></span></li>
<li><span><strong>Namespace</strong>: <kbd>/var/run/secrets/kubernetes.io/serviceaccount/namespace</kbd></span></li>
</ul>
<div class="packt_infobox"><span>Using this information within the cluster forms a secure way of connecting to the Kubernetes API server and making requests. </span><span>The service account, which is an authentication mechanism in Kubernetes, uses signed tokens to verify requests. They are created and managed by the Kubernetes API server. For each pod running in Kubernetes, service account tokens are mounted, and they enable pods to communicate with the Kubernetes API server. </span><span>Further information is available in the official documentation: <a href="https://kubernetes.io/docs/admin/authentication">https://kubernetes.io/docs/admin/authentication</a>.<br/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">To Connect to the Kubernetes API inside a Cluster</h1>
                </header>
            
            <article>
                
<p><span>In this section, we'll create a simple application to query the Kubernetes API and get the details of the kube-system namespace. However, this application should run inside the cluster and work as a Kubernetes native application. We'll </span><span>query the Kubernetes API within a cluster with the injected environment variables and certificates in the pods.</span></p>
<p class="mce-root"/>
<p><span>Let's begin by implementing the following steps:<br/></span></p>
<ol>
<li><span>Start a cURL instance inside the cluster and wait until it is up and running:<br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>kubectl run curl --image=tutum/curl --rm -it<br/></span></pre>
<ol start="2">
<li>Inside the pod, check the security credentials:</li>
</ol>
<pre style="padding-left: 60px"><span>ls /var/run/secrets/kubernetes.io/serviceaccount/<br/></span></pre>
<p style="padding-left: 60px"><span>You'll get the following output:<br/></span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/33a4ec4e-4602-47db-84d5-277b215b3718.png" style=""/></div>
<ol start="3">
<li>Check that the Kubernetes API server has the related environment variables:</li>
</ol>
<pre style="padding-left: 60px">env | grep KUBE<span> </span></pre>
<p style="padding-left: 60px"><span>You'll get the following output:<br/></span></p>
<div class="CDPAlignCenter CDPAlign" style="padding-left: 120px"><img src="assets/dccd7f87-ed37-4ef0-8403-304c6d921ff0.png" style=""/></div>
<ol start="4">
<li>Combine all of the credentials and address information together with the following commands:</li>
</ol>
<pre style="padding-left: 60px"><span>APISERVER=https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT<br/>TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)<br/>CACERT=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt<br/>NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)</span></pre>
<ol start="5">
<li>With the collected environment variables from <em>Step 4</em>, create and send an HTTP request by using cURL:</li>
</ol>
<pre style="padding-left: 60px"><span>curl --header "Authorization: Bearer $TOKEN" --cacert<br/>$CACERT $APISERVER/api/v1/namespaces/kube-system </span></pre>
<p><span>By using the preceding command, a GET request will be sent to the <kbd>/api/v1/namespaces/kube-system</kbd> endpoint. In order to authenticate to the API server, a bearer token is sent as a header, and certificate authority information is provided.</span></p>
<p><span>As a result of this command, the requested namespace information will be retrieved from the API server:<br/></span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/32f0bb5d-baac-4ebd-b8bb-9a3385becd49.png" style=""/></div>
<p><span>The Kubernetes API is the core management service and it is a secure RESTful service that consumes JSON. It requires all of the clients to be authenticated, and both outside and inside cluster connections are possible. In the following section, client libraries for various programming languages are presented that implement the Kubernetes API.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Official Client Libraries</h1>
                </header>
            
            <article>
                
<p><span>Applications that consume the Kubernetes REST API should implement API calls, including request and response types. Considering the rich set of Kubernetes resources that are provided to us, developing and maintaining API implementation becomes complex. Fortunately, Kubernetes has a rich set of official client libraries that are implemented in various programming languages. Client libraries do not only handle requests and responses, but also handle authentication to the API server. Besides, most of the client libraries can discover and connect to the Kubernetes API server if it is running inside the cluster.</span></p>
<p><span>In this section, official Go and Python client libraries will be presented. The client repositories, documentation, how to install, and how to create simple applications that are running inside and outside the clusters will be covered.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Go Client Library</h1>
                </header>
            
            <article>
                
<p><span>Go, which is also of en referred to as Golang, is a programming language that was created by Google in 2009. Prominent features of Go include the following:</span></p>
<ul>
<li><span>It is statically typed so that the compiler ensures object types and conversions are working</span></li>
<li><span>It has memory safety with no development concerns</span></li>
<li><span>It has garbage collection with a minimal overhead</span></li>
<li><span>The structural typing of objects is based on their composition</span></li>
<li><span>It has first-citizen concurrency handling with primitives such as go routines and channels</span></li>
</ul>
<p><span>Go is a free, open source programming language that has compilers and environment tools. Go became popular within cloud-native applications because the aforementioned features are well-fitting to the requirements of scalable and reliable applications. Some of the most notable projects that use Go as their primary language are as follows:</span></p>
<ul>
<li><span>Docker</span></li>
<li><span>Kubernetes</span></li>
<li><span>Terraform</span></li>
<li><span><span>OpenShift</span></span></li>
<li><span>Consul</span></li>
<li><span>Bitcoin Lightning Network</span></li>
<li><span>InfluxDB</span></li>
<li><span>CockroachDB<br/></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Repository</h1>
                </header>
            
            <article>
                
<p>Kubernetes' Go client, namely client-go, is part of the Kubernetes official project, which is available at <a href="https://github.com/kubernetes/client-go">https://github.com/kubernetes/client-go</a>.</p>
<p>It is the oldest and the most comprehensive client library. Kubernetes resource handlers of the client library are generated with the official source code generators from Kubernetes. In addition, client-go is widely used inside Kubernetes projects,<br/>
such as kubectl, helm, and kops.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Documentation</h1>
                </header>
            
            <article>
                
<p>The Go client repository consists of the following packages and respective focus areas:</p>
<ul>
<li><kbd>kubernetes</kbd>: Clientset to access the Kubernetes API</li>
<li><kbd>discovery</kbd>: Discover APIs supported by the Kubernetes API server</li>
<li><kbd>dynamic</kbd>: Dynamic client to perform generic API access</li>
<li><kbd>transport</kbd>: Authentication and connection start</li>
<li><kbd>tools/cache</kbd>: Helpers for writing controllers</li>
</ul>
<p>The Go client follows the official documentation style of the Go language and it is available at <a href="https://godoc.org/k8s.io/client-go">https://godoc.org/k8s.io/client-go</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installation</h1>
                </header>
            
            <article>
                
<p>In the Go language, its toolset provides the <kbd>go get</kbd> command as a standard way of downloading and installing packages with their dependencies. This command downloads the default branch and the latest changes from source control version providers. However, specific versions of the Kubernetes client are designed to work with particular versions of dependencies. Therefore, the standard <kbd>go get</kbd> command is not usable. Instead, dependency management solutions proposed for Go should be used to work with <kbd>client-go</kbd> reliably.</p>
<p>In other words, the required version of client-go should be decided, and then the dependency manager downloads it with the corresponding dependencies. This concept of handling dependencies is called <strong>vendoring</strong>. Accordingly, dependency managers collect the dependency libraries and put them in the <kbd>vendor</kbd> folder.</p>
<p>For a Go application that uses the <kbd>client-go</kbd> library, all related libraries and their dependencies should be collected under the vendor folder for reliable and repeatable builds.</p>
<div class="packt_infobox">The Kubernetes Go client supports multiple dependency management tools, such as dep, godeps, and glide. In addition, the required steps for casual users who do not want to use any dependency management tools are provided in the official documentation of client-go: <a href="https://github.com/kubernetes/client-go/blob/master/INSTALL.md">https://github.com/kubernetes/client-go/blob/master/INSTALL.md</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating Configuration</h1>
                </header>
            
            <article>
                
<p>The Go client library provides the necessary functionalities to connect to the Kubernetes API server. It is easy to create the configuration so that you can communicate outside the cluster and inside the cluster. You can do so with the following code snippets:</p>
<pre>// Create configuration outside the cluster config, err = clientcmd.BuildConfigFromFlags("", kubeconfigPath)<br/>// Create configuration inside the cluster config, err = rest.InClusterConfig()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating Clientset</h1>
                </header>
            
            <article>
                
<p>Clientset contains the clients for each groupof resources and provides access to them. With its redacted version, as shown in the following code, it can be seen that every group of resources have their clients implemented in the client library:</p>
<pre><span>type Clientset struct {<br/>       ...<br/>       appsV1 *appsv1.AppsV1Client<br/>       ...<br/>       batchV1 *batchv1.BatchV1Client<br/>       coreV1 *corev1.CoreV1Client<br/>       eventsV1beta1 *eventsv1beta1.EventsV1beta1Client<br/>       networkingV1 *networkingv1.NetworkingV1Client<br/></span></pre>
<pre><span>       rbacV1 *rbacv1.RbacV1Client<br/>       storageV1beta1 *storagev1beta1.StorageV1beta1Client<br/>       storageV1 *storagev1.StorageV1Client<br/> }</span></pre>
<p><span>Using the configuration from the previous step, clientset can be created with the following code snippet:</span></p>
<pre><span>// Create clientset from configuration<br/> clientset, err := kubernetes.NewForConfig(config)<br/></span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making API Calls</h1>
                </header>
            
            <article>
                
<p><span>After creating the configuration and clientset, API calls can finally be carried out. All of the Kubernetes resources can be listed, updated, created, or deleted by using the clients in the provided clientset. Some examples are shown in the following code snippet:</span></p>
<pre><span>// Request all pods from all namespaces<br/>pods, err :=<br/>clientset.CoreV1().Pods(v1.NamespaceAll).List(metav1.ListOptions{})<br/> </span>// Get deployment packt from the default namespace<br/><span>deployments, err := clientset.AppsV1().Deployments(v1.NamespaceDefault).Get("packt", metav1.GetOptions{})<br/>// Delete statefulset test from namespace packt<br/>clientset.AppsV1().StatefulSets("packt").Delete("test", &amp;amp;metav1.DeleteOptions{})<br/> </span></pre>
<div class="packt_infobox"><span>Code snippets are provided for the configuration, client creation, and making API calls using the Kubernetes Go client in the previous sections. The complete application code is provided in <kbd>go/main.go</kbd>, bringing together all of the snippets at <a href="https://goo.gl/wJBjG5">https://goo.gl/wJBjG5</a>.<br/></span></div>
<p>We can note the following points in the <kbd>main.go</kbd> file:</p>
<ul>
<li>In the main function that was started at <em>line 19</em>, all of the variables are defined, and the command-line arguments are parsed at <em>line 30</em>.</li>
<li>Configuration is created from <kbd>kubeconfig</kbd>, and as a fallback method, it is created by in-cluster methods between <em>lines 33</em> and <em>42</em>.</li>
<li>Clientset is created at <em>line 45</em>.</li>
<li>Between <em>lines 51</em> and <em>65</em>, an indefinite loop is defined with 10 seconds of sleep at the end of iterations.</li>
<li>At every iteration of this loop, pods from all namespaces are requested at <em>line 53</em>. The response is printed to the console between <em>lines 58</em> and <em>62</em>.</li>
</ul>
<p>In the following <span>example</span>, an application combining all of the code snippets in the previous sections is built and run. It shows you how to build a Go application and use it outside the cluster. Although the application seems straightforward, the flow and codebase creates a foundation for complex automation requirements.<span><br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">To Use the Kubernetes Go Client outside the Cluster</h1>
                </header>
            
            <article>
                
<p><span>In this section, we'll learn to build and run a Go application, consuming Kubernetes Go client and connecting the application outside the cluster. </span><span>Go applications are built by using go toolset commands such as go build. However, this requires the installation of Go locally. In this example, we will use the official Docker image of the Go language without any installation on the local machine:</span></p>
<ol>
<li><span>Create a cross-platform build using the official Docker container by using the following command:</span></li>
</ol>
<pre style="padding-left: 60px">cd go<br/><span>make build</span></pre>
<ol start="2">
<li>Start the application using the executable we created in <em>Step 1</em> and the <kbd>kubeconfig</kbd> file location:</li>
</ol>
<pre style="padding-left: 60px"><span>./client --kubeconfig=$HOME/.kube/config<br/></span></pre>
<p><span>You will see the following output:<br/></span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e58345f5-359c-4a91-a83c-06e7412d75b0.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Activity: Using the Kubernetes Go Client inside the Cluster</h1>
                </header>
            
            <article>
                
<p><strong>Scenario</strong></p>
<p><span>You are assigned the task of deploying a Go application that lists all of the pods in Kubernetes. Besides this, the application will run inside the cluster and receive information about its cluster.</span></p>
<p><strong>Aim</strong></p>
<p><span>To run an application that consumes the Go client library inside the Kubernetes cluster.</span></p>
<p><strong>Prerequisites</strong></p>
<ol>
<li><span>Use the Docker image <kbd>onuryilmaz/k8s-client-example:go</kbd> image, which contains the executable from the previous example.</span></li>
<li><span>Deploy the application and check the logs to see whether it is working as expected.</span></li>
</ol>
<p><strong>Steps for Completion</strong></p>
<ol>
<li><span>Create a deployment with the Docker image of the example client from the previous example.</span></li>
<li><span>Wait until the pod is running.</span></li>
<li><span>Get the logs of the deployment pod.</span></li>
</ol>
<p style="padding-left: 60px">With this command, the logs of the pod are retrieved with a subcommand. In the subcommand, all pods are retrieved with the selector label of <kbd>run</kbd> equal to <kbd>go-client</kbd>, and the name of the first pod is gathered. Logs should indicate the client itself, in addition to other pods in the cluster:<span><br/></span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8c5a13bf-69dd-4d0d-a354-f7a3d71f74bd.png" style=""/></div>
<ol start="4">
<li>Run the following command for cleanup:</li>
</ol>
<pre style="padding-left: 60px">kubectl delete deployment go-client</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Python Client Library</h1>
                </header>
            
            <article>
                
<p>Python is a high-level and general-purpose programming language that was first released in 1990. It is one of the most popular open source programming languages, used in various areas, including machine learning, data processing, web development, and scripting. The essential feature of Python is that the language is interpreted with dynamic type checking. Python owes its popularity to its clear programming style and focus on code readability. In modern cloud-native environments, Python is mostly used for infrastructure and automation. In addition to its popularity and widespread usage, Kubernetes has an official client library that's implemented in Python.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Repository</h1>
                </header>
            
            <article>
                
<p>The Kubernetes Python client is part of the official client repository and is available at <a href="https://github.com/kubernetes-client/python">https://github.com/kubernetes-client/python</a>.</p>
<p>The Python client is an OpenAPI compliant client, which means that Swagger tools generate resource definitions. The client library is still in progress, and its capabilities should be checked from the repository before using them in production. The Python client, like every other Kubernetes client, attempts to support a set of predefined functionalities, and it is classified as "Silver" according to its coverage.</p>
<div class="packt_infobox"><span>The OpenAPI is a specification for describing RESTful APIs. Using the OpenAPI specification, it is possible to create an implementation for clients and services, including all of the corresponding operations. <br/>
<br/></span> <span>Swagger is the tooling ecosystem for developing APIs, which is defined in OpenAPI. Swagger provides both open source and commercial tools to create applications for the provided specification.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installation</h1>
                </header>
            
            <article>
                
<p><span>There are two ways of installing the client library so that you can create a development environment. The first way is to download the source code and build:</span></p>
<pre><span>$ git clone --recursive https://github.com/kubernetes-client/<br/>python.git<br/>$ cd python<br/>$ python setup.py install</span></pre>
<p><span>The second way is to download the package from the Python Package Index by using a package manager such as <kbd>pip</kbd>:</span></p>
<pre><span>$ pip install kubernetes</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client Usage</h1>
                </header>
            
            <article>
                
<p><span>In the previous section, a Go application that lists all the pods was developed. The same functionality as the previous application is performed in Python in this section. With the clean code and readability philosophy of Python, the same functionality is handled in around ten lines of code, as follows:</span></p>
<pre><span>from kubernetes import client, config<br/>import time<br/>config.load_incluster_config()<br/>v1 = client.CoreV1Api()<br/>while True:<br/>         ret = v1.list_pod_for_all_namespaces(watch=False)<br/>         print('There are {:d} pods in the cluster:'.format(len(ret.items)))<br/>         for i in ret.items:<br/>                print('{:s}/{:s}'.format((i.metadata.namespace, i.metadata.name))<br/>         time.sleep(10)<br/></span></pre>
<p><span>These are the critical points to mention about the preceding code snippet:</span></p>
<ul>
<li><span>In <em>line 3</em>, the in-cluster configuration, and in <em>line 5</em>, the client for the <kbd>corev1</kbd> API are created.</span></li>
<li><span>Starting in <em>line 8</em>, an infinite loop starts with a sleep of 10 seconds at each iteration.</span></li>
<li><span>In <em>line 9</em>, all pods are requested from the <kbd>v1</kbd> client and the response is parsed and written to the console.<br/></span></li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Packaging</h1>
                </header>
            
            <article>
                
<p><span>The Python application should run inside a container, like all services running on Kubernetes. Thus, the client library defined in this section is packaged with the following Dockerfile. This container definition enables the application to run its isolated environment with its dependencies:</span></p>
<pre><span>FROM python:3<br/>RUN pip install kubernetes<br/>ADD . /client.py<br/>CMD ["python", "./client.py"]</span></pre>
<div class="packt_infobox"><span><br/>
Please refer to the complete code at: <a href="https://goo.gl/z78SKr">https://goo.gl/z78SKr</a>.</span></div>
<p><span>The following are remarks about the preceding code:</span></p>
<ul>
<li><span>The container has the basis of Python supporting version 3.</span></li>
<li><span>The Kubernetes Python client library is installed using <kbd>pip</kbd> in <em>line 3</em>.</span></li>
<li><span>The client application is copied into the container in <em>line 5</em> and started in <em>line 7</em>.</span></li>
</ul>
<p><span>In the following section, the code snippets presented for Python are utilized to work in a Kubernetes cluster. The complete code is packaged as a Docker container with its dependencies. With this container, the application is deployed to Kubernetes in an isolated way, which follows a microservice architecture.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the Kubernetes Python Client inside the Cluster</h1>
                </header>
            
            <article>
                
<p><span>In this section, we'll deploy a Python application that lists all of the pods and consumes the Python client library inside Kubernetes. Besides this, the application will run inside the cluster and gather information about its cluster.</span></p>
<p><span>Before starting with the implementation, we need to use the Docker image <kbd>onuryilmaz/k8s-client-example:python</kbd>, which was built using the Dockerfile in the last section. We also need to deploy the application as a deployment and check the logs to see whether it is working as expected. Let's begin by implementing the following steps:<br/></span></p>
<ol>
<li><span>Create a deployment with the Docker image of the example client:<br/></span></li>
</ol>
<pre style="padding-left: 60px"><span>kubectl run python-client -it --image=onuryilmaz/k8sclient-example:python</span></pre>
<p style="padding-left: 60px"><span>With this command, a deployment with the name python-client will be created with the Docker image <kbd>onuryilmaz/k8s-client-example:python</kbd> in an interactive mode so that logs will be printed to the console.</span></p>
<p style="padding-left: 60px"><span>Logs should indicate the client itself, in addition to other pods in the cluster:<br/></span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/34faffbf-f9cb-4356-8c29-6c32952de9ef.png" style=""/></div>
<ol start="2">
<li>Run the following command for cleanup:<span><br/></span></li>
</ol>
<pre style="padding-left: 60px"> <span>kubectl delete deployment python-client<br/></span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other Official Client Libraries</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>In this chapter, two official Kubernetes client libraries have been covered:</span></p>
<ul>
<li class="mce-root"><span><strong>Go</strong>: This is a statically typed compiler-based language</span></li>
<li class="mce-root"><span><strong>Python</strong>: This is a dynamically typed and interpreted language</span></li>
</ul>
<p class="mce-root"><span>Official client libraries also include some additional programming languages:</span></p>
<ul>
<li class="mce-root"><span><strong>Java</strong>: <a href="https://github.com/kubernetes-client/java">https://github.com/kubernetes-client/java</a></span></li>
<li class="mce-root"><span><strong>.NET</strong>: <a href="https://github.com/kubernetes-client/csharp">https://github.com/kubernetes-client/csharp</a></span></li>
<li class="mce-root"><span><strong>JavaScript</strong>: <a href="https://github.com/kubernetes-client/javascript">https://github.com/kubernetes-client/javascript</a></span></li>
</ul>
<p class="mce-root"><span>For the capabilities and hurdles of these libraries, you should check their corresponding repositories since they are all still in the development phase.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Community-Maintained Client Libraries</h1>
                </header>
            
            <article>
                
<p><span>Kubernetes has an active and collaborative open source community, which has also increased its popularity. There are around 20 community-maintained client libraries that are listed in the Kubernetes documentation, which cover the following languages:</span></p>
<ul>
<li><span>Clojure</span></li>
<li><span>Go</span></li>
<li><span>Java</span></li>
<li><span>Lisp</span></li>
<li><span>Node.js</span></li>
<li><span>Perl</span></li>
<li><span>PHP</span></li>
<li><span>Python</span></li>
<li><span>Ruby</span></li>
<li><span>Scala</span></li>
<li><span>dotNet</span></li>
<li><span>Elixir</span></li>
</ul>
<p><span>There are some critical points to consider before using a community-maintained client library:<br/></span></p>
<ul>
<li><span><span><strong>Aim of the library</strong>: It is crucial to consider the aim of the development team and library. Although it seems not directly related to the software itself, it affects how the client library is developed. For instance, some libraries focus on simplicity and compromise on capability coverage. If the vision of your application and the client library don't match, it would be difficult to maintain the application in the long run.</span></span></li>
<li><span><strong>Version and support</strong>: Official libraries support specific Kubernetes API versions and maintain a compatibility matrix. It is critical to work with the client libraries that work with your Kubernetes cluster, and it is also essential to get support for future Kubernetes versions. A community-maintained client library could be very suitable today but depreciate in six months if not supported.<br/></span></li>
<li><span><strong>Community interest</strong>: If the considered client library is open source, its community should be alive and interested in making the library better. It is very common to see some libraries start very well but not be maintained due to a missing community. It is not advised to use a client library with old issues without any comments or pull requests that are not reviewed for a very long time.<br/></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span>In this chapter, Kubernetes API access and client libraries were discussed. Although there are various tools for communicating with Kubernetes, knowing the Kubernetes API itself and the client libraries is crucial for creating game-changing automation and orchestration tasks.<br/>
Firstly, the Kubernetes API style and how to connect using HTTP clients was presented. Following that, the client libraries of Kubernetes were covered, and we focused on two official client libraries. For both Go and Python, how to install, write code, package, and deploy this code into cluster steps was done with demonstrations and activities.<br/>
Finally, community-maintained libraries for different language preferences or custom requirements were shown. With the knowledge and hands-on experience of Kubernetes client libraries, higher levels of automation and extending Kubernetes is possible. In the following chapter, the best practices covered in the first chapter and the client libraries included in this chapter are gathered together to create applications that extend Kubernetes.<br/></span></p>


            </article>

            
        </section>
    </body></html>