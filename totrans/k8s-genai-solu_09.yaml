- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security Best Practices for Deploying GenAI on Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the security best practices for deploying GenAI
    applications on **Kubernetes** (**K8s**). We will begin by introducing the concept
    of “defense in depth” and then cover the key pillars of securing GenAI workloads
    – supply chain, host, network, and runtime security. Additionally, we will cover
    best practices for the management of secrets and the principle of least privilege
    to prevent unauthorized access to critical data and application credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defense in depth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: K8s security considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional considerations for GenAI apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing security best practices in a chatbot app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be using the following, the first of which requires
    you to set up an account and create an access token:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hugging** **Face**: [https://huggingface.co/join](https://huggingface.co/join)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Amazon EKS cluster setup, as illustrated in [*Chapter 3*](B31108_03.xhtml#_idTextAnchor039)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defense in depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to protect an application in the cloud is by using the concept
    of **defense in depth** ([https://csrc.nist.gov/glossary/term/defense_in_depth](https://csrc.nist.gov/glossary/term/defense_in_depth)).
    This is a strategy that implements multiple layers of security to protect against
    threats across different attack vectors. *Figure 9**.1* shows a conceptual view
    of defense in depth, where each concentric circle represents a layer or attack
    vector we would like to secure.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look over this concept for security best practices, and then we will dive
    deeper for every layer, specific to containers and K8s.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Layered security model](img/B31108_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Layered security model
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are details about the layers depicted in the preceding figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User data**: This is the innermost core of the system containing sensitive
    user data, such as user passwords, **personally identifiable information** (**PII**),
    and so on. To protect this layer, data encryption at rest and transit should be
    used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration**: Sensitive configuration data for an application includes
    environment variables, application settings, secrets, and API keys required for
    the application to function. Lapses in configuration settings could lead to data
    leaks, privilege escalation, or compromised application behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application code**: Vulnerabilities in application code can lead to exploits,
    such as SQL injection or remote code execution. To prevent this, users should
    conduct regular static and dynamic code analysis, promptly patch vulnerabilities,
    and update dependencies to the latest secure versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependencies**: Code dependencies include libraries, frameworks, and external
    packages that the application relies on. Vulnerable or outdated dependencies are
    one of the most common entry points for attackers. To prevent this, users should
    regularly scan dependencies for vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containers**: The container runtime and images could also create another
    threat vector, as misconfigured or untrusted containers can escalate privileges,
    attack the host, or expose sensitive information. To prevent this, users could
    use image signing to verify the authenticity of images and implement runtime security
    using tools such as **Falco** to watch out for malicious behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host**: This is the underlying server or node where containers are deployed.
    The host kernel is shared among all containers, making it a critical security
    layer. If the host is compromised, all containers can be affected. To prevent
    this, it is recommended to harden the host operating system by disabling unused
    services, applying patches, and using container-optimized operating systems, such
    as **Bottlerocket**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned about the concept of defense in depth, a strategy
    that implements multiple layers of security to protect against threats across
    different attack vectors. We also looked at a conceptual view of various attack
    vectors and best practices in each layer. In the next section, let’s look at key
    security considerations when deploying workloads in K8s.
  prefs: []
  type: TYPE_NORMAL
- en: K8s security considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered the concept of defense in depth at a high level, let’s
    discuss containers and K8s security best practices. Thinking about **container
    security** is critical in the cloud environment, as containers operate in a dynamic
    and shared environment.
  prefs: []
  type: TYPE_NORMAL
- en: Containers encapsulate *software* and *dependencies* making them highly portable;
    however, this portability also introduces a set of risks. A comprehensive security
    strategy should address vulnerabilities across the container lifecycle – from
    *build pipelines* to *runtime environments*.
  prefs: []
  type: TYPE_NORMAL
- en: Key areas of focus include securing the supply chain, protecting the host system,
    and monitoring runtime activity. Each layer of security adds resilience against
    potential threats, and by following the best practices, one can ensure the safe
    deployment and operation of containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the key areas we will dive deeper into as part of
    this container security:'
  prefs: []
  type: TYPE_NORMAL
- en: Supply chain security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secrets management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supply chain security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The container supply chain encompasses all the stages from building an image
    to deploying and monitoring it in production, as shown in *Figure 9**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Container supply chain](img/B31108_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Container supply chain
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss the first five phases and their corresponding security best
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: '**Build phase**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During the build phase, malicious/vulnerable code can enter the container image
    through unverified dependencies or insecure configurations. To secure the build
    phase, one should only use trusted base images from verified sources. To minimize
    the attack surface and improve security, consider using lightweight parent images
    for your containers. **Alpine Linux** ([https://hub.docker.com/_/alpine](https://hub.docker.com/_/alpine)),
    **distroless** ([https://www.docker.com/blog/is-your-container-image-really-distroless/](https://www.docker.com/blog/is-your-container-image-really-distroless/)),
    or **scratch** ([https://hub.docker.com/_/scratch](https://hub.docker.com/_/scratch))
    images have fewer built-in packages, limiting the potential vulnerabilities, and
    are generally recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**DockerSlim** ([https://github.com/slimtoolkit/slim](https://github.com/slimtoolkit/slim))
    is an open source tool that helps optimize container images by reducing their
    size, thus improving security by identifying only the parts that are required
    at runtime. This significantly reduces the attack surface and enhances performance
    without altering the functionality of the containerized application.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also recommended to enforce the immutability of container images by using
    declarative Dockerfiles and reproducible builds. An `latest` tag is mutable, meaning
    it can point to different images over time as new images are pushed, whereas a
    tag such as `v1.0` is immutable, as it ensures that it always references the same
    image, regardless of future pushes. Immutability is particularly beneficial for
    GenAI applications to ensure the training/fine-tuning jobs and inference images
    are built against a consistent environment, maintain model integrity, and simplify
    troubleshooting efforts.
  prefs: []
  type: TYPE_NORMAL
- en: A **multi-stage build** ([https://docs.docker.com/build/building/multi-stage/](https://docs.docker.com/build/building/multi-stage/))
    is a technique used in the build phase that allows you to break down the build
    process into multiple discrete stages. Each stage can focus on a specific task
    using an appropriate parent image, such as compiling code or installing dependencies,
    and then selectively copy only the necessary artifacts into the final, minimal
    image.
  prefs: []
  type: TYPE_NORMAL
- en: For GenAI applications, multi-stage builds help ensure that large training frameworks,
    data preprocessing scripts, or model optimization steps can selectively be excluded
    from the final production image. This results in smaller, more secure, and efficient
    images that can be quickly deployed for inference.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test phase**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Undetected vulnerabilities and misconfigurations in images can lead to issues
    downstream. To mitigate this, it is recommended to integrate automated security
    testing into CI/CD pipelines with tools such as **Snyk** ([https://snyk.io/](https://snyk.io/)).
    You should perform static analysis on code and dynamic testing on built images
    to uncover vulnerabilities. Ensure that your testing process also covers compliance
    with internal security policies and relevant industry standards. Incorporate test
    cases to assess resource usage, verify adherence to least-privilege principles,
    and monitor runtime behaviors. By doing so, you can help maintain secure, compliant,
    and predictable operations throughout the software lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: '**Store phase**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During the image store phase in container registries, images can be tampered
    with or can contain outdated dependencies. To safely secure images, it is recommended
    to use secured container registries such as **Amazon** **ECR** ([https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)).
  prefs: []
  type: TYPE_NORMAL
- en: You should also enable image signing and verification using tools such as Docker
    Content Trust or Cosign. **AWS Signer** ([https://docs.aws.amazon.com/signer/latest/developerguide/Welcome.html](https://docs.aws.amazon.com/signer/latest/developerguide/Welcome.html))
    is a fully managed service that allows you to digitally sign code, applications,
    and containers to ensure the integrity and authenticity of your software.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that only signed container images are deployed in production, a **policy-as-code
    solution** such as **Open Policy Agent** (**OPA**) or its K8s-native implementation,
    **OPA Gatekeeper** ([https://github.com/open-policy-agent/gatekeeper](https://github.com/open-policy-agent/gatekeeper)),
    is recommended. OPA Gatekeeper is an open source project that leverages OPA to
    enforce policies in K8s clusters. It enables administrators to implement fine-grained
    governance by validating and mutating K8s resources against predefined constraints.
    Gatekeeper uses **custom resource definitions** (**CRDs**) to define these policies
    and constraints, allowing users to tailor governance to their specific needs.
    It operates as an admission controller, ensuring that any resource not complying
    with the defined rules is denied during creation or updates. Additionally, it
    supports auditing capabilities, enabling users to identify and remediate policy
    violations in existing resources. **Role-based access control** (**RBAC**) is
    also recommended to restrict access to images, and users should regularly clean
    up unused or deprecated images to reduce potential attack surfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encrypt phase**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sensitive data in images should always be intercepted. One should avoid embedding
    secrets (e.g., API keys or passwords) directly in images to prevent leaks in case
    of a potentially compromised container image.
  prefs: []
  type: TYPE_NORMAL
- en: You can use secret management tools such as **HashiCorp Vault** ([https://www.hashicorp.com/products/vault](https://www.hashicorp.com/products/vault)),
    **Kubernetes Secrets** ([https://kubernetes.io/docs/concepts/configuration/secret/](https://kubernetes.io/docs/concepts/configuration/secret/)),
    or **AWS Secrets Manager** ([https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html))
    to store the secrets. For example, AWS Secrets Manager is a secure service for
    managing secrets, such as database credentials, API keys, and other sensitive
    configuration data. By encrypting secrets with **AWS Key Management Service**
    (**AWS KMS**) and enabling fine-grained access control through **AWS Identity
    and Access Management** (**AWS IAM**), Secrets Manager ensures that sensitive
    data is protected and accessible only to authorized users and applications. It
    also supports version control and the automatic rotation of secrets, reducing
    the risks of credential exposure and minimizing manual overhead.
  prefs: []
  type: TYPE_NORMAL
- en: To integrate external secret management solutions with K8s, you can use projects
    such as **secrets-store-csi-driver** ([https://github.com/kubernetes-sigs/secrets-store-csi-driver](https://github.com/kubernetes-sigs/secrets-store-csi-driver)),
    which allows K8s to mount multiple secrets, keys, and certificates stored in external
    secrets stores into K8s Pods as a volume. Once the volume is attached, the data
    in it is mounted into the container’s filesystem. Refer to the AWS documentation
    at [https://docs.aws.amazon.com/secretsmanager/latest/userguide/integrating_csi_driver.html](https://docs.aws.amazon.com/secretsmanager/latest/userguide/integrating_csi_driver.html)
    for an example walkthrough of using AWS Secrets Manager in an Amazon EKS cluster.
    In the case of GenAI applications, external API keys from **Hugging Face** and
    **OpenAI** can safely be stored in these solutions, and applications can securely
    access them during the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scan phase**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vulnerabilities in images or dependencies can lead to exploitation by bad actors.
    To prevent this, images should be continuously scanned during the build and store
    phases. Most container registry solutions provide this capability out of the box,
    or open source tools such as **Trivy** ([https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy))
    can be used to scan container images for vulnerabilities. These tools identify
    potential risks by analyzing image layers against known vulnerability databases
    (e.g., CVE databases), providing early detection of issues.
  prefs: []
  type: TYPE_NORMAL
- en: In cloud environments, more advanced image scanning options are also available.
    For example, Amazon ECR supports advanced vulnerability scanning through **Amazon
    Inspector** ([https://aws.amazon.com/inspector/](https://aws.amazon.com/inspector/)),
    a managed service designed to automate security assessments. This integration
    provides enhanced, continuous scanning for container images in ECR, ensuring they
    remain secure throughout their lifecycle. Amazon Inspector can scan container
    images in ECR automatically, without requiring manual triggers, whenever a new
    image is pushed or updated. Refer to the Amazon ECR documentation at [https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-scanning.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-scanning.html)
    to learn more about these options and how to enable them on your container repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Host security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Securing the host environment for containers is critical, as multiple containers
    can share the host operating system and kernel. The following are some of the
    best practices and strategies for securing container hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploy in private subnets**: Deploying hosts/worker nodes in private subnets
    minimizes exposure to external threats by restricting direct access from the internet.
    To expose applications to the public internet, deploy load balancer resources
    in public subnets using K8s load balancer or Ingress resource types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disable SSH access**: SSH access should be limited to minimizing the attack
    vector. Instead, **session management tools** such as **AWS Systems Manager**
    (**SSM**) ([https://aws.amazon.com/systems-manager/](https://aws.amazon.com/systems-manager/))
    should be used for secure, auditable access to hosts without exposing SSH. If
    SSH is necessary, enforce key-based authentication and restrict access using security
    groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` and enforce the usage of IMDSv2, as shown in the following Terraform code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Encrypt all storage**: Encrypting storage protects sensitive data on the
    host in case of physical or logical compromise. Use AWS KMS to encrypt **Amazon
    Elastic Block Store** (**Amazon EBS**) volumes attached to the host. If using
    EC2 instances with an **NVMe** instance store, all the data is encrypted using
    an XTS-AES-256 block cipher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Harden the node Amazon Machine Image (AMI)**: A hardened AMI reduces vulnerabilities
    by including only the necessary software, configurations, and security settings.
    Use container-optimized operating systems such as Bottlerocket ([https://aws.amazon.com/bottlerocket/](https://aws.amazon.com/bottlerocket/)),
    which are built from the ground up with containers in mind. They often include
    features such as a read-only root filesystem, atomic updates, and minimal tooling
    tailored to running containers efficiently and securely. You should disable and
    uninstall unused software to reduce the attack surface and configure the operating
    system according to CIS benchmarks for Docker, Kubernetes, and Linux. Use **AppArmor**
    ([https://apparmor.net/](https://apparmor.net/)), **SELinux** ([https://www.redhat.com/en/topics/linux/what-is-selinux](https://www.redhat.com/en/topics/linux/what-is-selinux)),
    or **seccomp** ([https://kubernetes.io/docs/tutorials/security/seccomp/](https://kubernetes.io/docs/tutorials/security/seccomp/))
    to restrict container privileges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container runtime security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Securing containers at runtime is critical to prevent privilege escalations
    and unauthorized access. This involves limiting resources, restricting privileges,
    enforcing security standards, and integrating monitoring and policy tools. The
    following are the core runtime security practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Provide only the resources required for normal operation**: Unrestricted
    resource allocation can lead to **denial-of-service** (**DoS**) attacks and cluster
    instability, where some containers can consume entire node resources. To prevent
    this, you should define CPU and memory limits in K8s manifests reflecting the
    optimal resources a container might need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`securityContext`, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'securityContext:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'capabilities:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'drop:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- ALL'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Follow Pod Security Standards**: Adherence to Pod Security Standards ensures
    that containers comply with best practices for security configurations. Use the
    K8s built-in Pod Security Admission to enforce standards such as restricted profiles.
    Also, isolate workloads using namespaces with different security levels (e.g.,
    restricted or baseline). Pod Security Standards define three different policy
    levels (privileged, baseline, and restricted) to broadly cover the security spectrum.
    You can apply labels and annotations on namespaces to specify the desired level
    of security configuration, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Network security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Network security in K8s is critical for securing data and applications in a
    containerized environment. The distributed nature of K8s presents unique challenges
    for securing network traffic. The following are some key considerations and best
    practices for ensuring network security in K8s:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network segmentation and isolation**: K8s **namespaces** provide a way to
    isolate resources and workloads within a cluster, acting as separate security
    boundaries. Network segmentation can be enforced using **NetworkPolicy** resources,
    discussed in [*Chapter 8*](B31108_08.xhtml#_idTextAnchor097), which define rules
    for controlling ingress (incoming) and egress (outgoing) traffic at the Pod level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Securing Pod-to-Pod communication**: By default, K8s allows communication
    between Pods, which can expose K8s clusters to security risks. Implementing zero-trust
    principles ensures that Pods communicate only with explicitly authorized peers.
    Service mesh technologies such as **Istio** or **Linkerd** provide mTLS for encryption
    and authentication, ensuring secure and authenticated Pod-to-Pod communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ingress and egress security**: Ingress security focuses on controlling and
    securing incoming traffic to the cluster, often using HTTPS with TLS certificates
    for encryption. Additional protection, such as **web application firewalls** (**WAFs**),
    help detect and block malicious traffic. Egress security involves restricting
    Pods’ outbound traffic to prevent unauthorized access to external resources, which
    can be enforced using egress policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API server protection**: The K8s API server is a critical management point,
    requiring strong security measures. RBAC restricts user permissions based on roles,
    while authentication mechanisms such as **OpenID Connect** (**OIDC**) or AWS IAM
    ensure that only authorized users access the server. Network policies or firewalls
    should further limit access to the API server from trusted sources only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DNS security**: CoreDNS, the default DNS server in K8s, should be secured
    against spoofing and related attacks. While enabling encrypted DNS protocols such
    as **DNS-over-TLS** or **DNS-over-HTTPS** ([https://www.cloudflare.com/learning/dns/dns-over-tls/](https://www.cloudflare.com/learning/dns/dns-over-tls/))
    is technically possible, it is not commonly implemented by default in K8s. Instead,
    use network policies to restrict which Pods can query the CoreDNS server, thereby
    reducing the risk of unauthorized requests. Additionally, ensure CoreDNS points
    to trusted upstream resolvers, employing **DNSSEC** ([https://www.internetsociety.org/deploy360/dnssec/basics/](https://www.internetsociety.org/deploy360/dnssec/basics/))
    for integrity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network monitoring**: Monitoring network traffic is crucial for detecting
    and mitigating threats. Tools such as Cilium, Calico, Sysdig, service meshes,
    or Datadog provide visibility into cluster traffic, enabling cluster administrators
    to identify suspicious behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Securing external connections**: Connections to external services, such as
    cloud provider services or databases, should be encrypted and authenticated. K8s
    Secrets offer a secure way to manage credentials for external connections, ensuring
    that sensitive information (such as API keys and passwords) remains protected
    from unauthorized access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secrets management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Secrets management in K8s is a critical component for securing and managing
    sensitive information, such as API keys, passwords, certificates, and tokens.
    K8s provides built-in mechanisms to manage Secrets but securing them requires
    careful configuration and the following best practices to mitigate risks of unauthorized
    access or accidental exposure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**K8s Secrets resource**: K8s provides a native resource called **Secrets**,
    which is used to store sensitive data in a Base64-encoded format. Secrets are
    mounted into Pods as environment variables or files, enabling applications to
    access them without embedding sensitive data directly in container images or configuration
    files. While convenient, the Base64 encoding is not encryption, so additional
    security measures are necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encrypting Secrets at rest**: By default, K8s stores Secrets in **etcd**,
    the cluster’s key-value store. To protect this sensitive information, it is essential
    to enable encryption at rest for etcd. When using managed K8s services such as
    Amazon EKS, etcd volumes are encrypted by default using AWS managed encryption
    keys. As an additional security measure, you can also use techniques such as envelope
    encryption to encrypt the Secret values before writing to the etcd database. In
    Amazon EKS, you can utilize AWS KMS to enable envelope encryption; refer to the
    AWS documentation at [https://docs.aws.amazon.com/eks/latest/userguide/envelope-encryption.html](https://docs.aws.amazon.com/eks/latest/userguide/envelope-encryption.html)
    to learn more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access control with RBAC**: RBAC is a fundamental part of securing Secrets
    in K8s. RBAC policies should enforce the principle of least privilege, granting
    users, Pods, and Services access only to the Secrets they need. Properly configured
    roles and role bindings help prevent unauthorized users or applications from accessing
    sensitive information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`secrets-store-csi-driver` plugin or other operators, enabling seamless access
    to externally managed secrets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automating Secret rotation**: Rotating Secrets regularly reduces the risk
    of long-term compromise. K8s secrets do not natively support automatic rotation,
    but external secret management tools often include this capability. Integrating
    such tools into K8s workflows allows you to periodically update secrets without
    disrupting applications, ensuring compliance with security best practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protecting Secrets in transit**: Sensitive data, including secrets, must
    be protected as it travels between clients, nodes, and the etcd store. Enable
    TLS encryption when exchanging sensitive credentials both with internal and external
    systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auditing and monitoring access to Secrets**: Audit logging is essential for
    monitoring access to secrets and detecting potential misuse. K8s can generate
    audit logs for API actions, including those involving secrets. Integrating these
    logs with centralized monitoring tools or **security information and event management**
    (**SIEM**) solutions helps administrators detect suspicious activity and respond
    promptly. Secret management tools also provide audit logs, which can be integrated
    into SIEM solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we looked at various security considerations when running containerized
    workloads in K8s, including supply chain security, host security, network security,
    and the importance of securing sensitive information using K8s Secrets. In the
    next section, let’s explore additional security considerations specific to GenAI
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Additional considerations for GenAI apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deploying GenAI applications on K8s often involves proprietary model artifacts,
    large volumes of sensitive training data, and sophisticated inference requests
    that can originate from untrusted sources. Beyond the standard practices of K8s
    security, you must consider new attack vectors related to model integrity, data
    privacy, software supply chain vulnerabilities, and the isolation of high-value
    hardware resources such as GPUs. Let’s explore some of those considerations now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data privacy and compliance**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GenAI models often rely on proprietary and sensitive datasets stored in data
    lakes, data hubs, and data warehouses for training and fine-tuning. In our walkthrough
    ([*Chapter 5*](B31108_05.xhtml#_idTextAnchor062)), we used **Amazon S3** buckets
    to store the datasets used during the fine-tuning process. Depending on the data
    classification and regulatory requirements, you must implement appropriate security
    controls such as data encryption at rest, strict access control policies, and
    auditing. When accessing these data repositories from GenAI applications running
    on K8s, ensure that all communications are encrypted using TLS and follow the
    principle of least privilege by leveraging K8s and related mechanisms. When running
    GenAI applications on Amazon EKS, you can leverage **IAM Roles for Service Accounts**
    (**IRSA**) ([https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html](https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html))
    or **EKS Pod Identity** ([https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html](https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html))
    features to obtain temporary IAM credentials and access data from other services
    such as Amazon S3.
  prefs: []
  type: TYPE_NORMAL
- en: IAM Roles for Service Accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IRSA was introduced in 2019 to associate fine-grained IAM roles with K8s service
    accounts. Applications running in K8s Pods can assume the role using their **service
    account identity** and access other AWS services based on the role permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the high-level steps involved in the process; refer to the
    Amazon EKS documentation at [https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html](https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html)
    for detailed guidance:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up an OIDC provider in AWS IAM for the Amazon EKS cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create fine-grained IAM policies to grant necessary permissions on AWS services.
    Refer to the security best practices documentation at [https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#grant-least-privilege](https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#grant-least-privilege)
    for guidance on creating IAM policies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an IAM role with the permission policies from *Step 2* and a trust policy
    for the K8s service account to the **assume** role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a K8s service account and annotate it with the IAM role from *Step 3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Deploy the K8s application using the annotated service account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When an application uses the AWS SDK to access other AWS resources, the SDK
    will invoke `AssumeRoleWithWebIdentity`, an AWS **Security Token Service** (**STS**)
    API operation that allows an application to assume an IAM role using a trusted
    web identity token, instead of long-lived access keys or IAM users, to fetch temporary
    IAM credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 9**.3* summarizes these steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Overview of IRSA](img/B31108_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Overview of IRSA
  prefs: []
  type: TYPE_NORMAL
- en: This illustrates how IAM roles are securely assumed by Pods in an Amazon EKS
    cluster using IRSA and the `AssumeRoleWithWebIdentity` ([https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html))
    mechanism. When a Pod associated with an annotated service account is created,
    the Pod Identity webhook running in the EKS control plane mutates the Pod specification
    to mount the projected service account token. The AWS SDK running in the Pod then
    uses that token to call AWS STS using the `AssumeRoleWithWebIdentity` API. STS
    verifies the token against the OIDC provider, checks the IAM role’s trust policy,
    and returns temporary AWS credentials, which the Pod uses to securely access other
    AWS resources.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will cover the recently introduced **EKS Pod Identity** feature, which
    further simplifies the IAM permission process.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon EKS Pod Identity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In 2023, AWS introduced the EKS Pod Identity feature as an evolution to IRSA
    to streamline the experience of setting up IAM permissions for K8s applications.
    It removed a lot of underlying complexities of IRSA, such as setting up OIDC providers
    in IAM, complex trust policies, annotating service accounts, and so on. EKS Pod
    Identity introduced new APIs to create Pod Identity associations between K8s service
    accounts and IAM roles, thus eliminating the need for OIDC providers, service
    account annotations, and so on. The high-level steps involved are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Install `eks-pod-identity-agent deamonset` on the EKS cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create fine-grained IAM policies granting necessary permissions on AWS services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an IAM role with the permission policies from *Step 2* and a trust policy
    for the EKS Pod Identity principal to the assume role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a Pod Identity association between the IAM role and the K8s service
    account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Deploy the K8s application using the service account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: EKS Pod Identity also introduced support for session tags to the temporary credentials
    assigned to each Pod, including attributes such as the cluster name, namespace,
    Pod UID, service account name, and so on. These tags allow administrators to configure
    a single IAM role that can be used across various service accounts, granting or
    restricting access to AWS resources based on matching tags. By incorporating role
    session tags, organizations can create more granular security boundaries between
    clusters and workloads, while continuing to leverage the same IAM roles and policies.
  prefs: []
  type: TYPE_NORMAL
- en: Secure model endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we talk about securing GenAI model endpoints, we should secure the fine-tuned
    model artifacts, model weights, and so on. After the fine-tuning process, you
    can securely store those model artifacts in object store services such as Amazon
    S3 using appropriate access controls, or package them along with the container
    image and push it to the container registry. You can securely source the credentials
    using one of the previously discussed approaches (IRSA or EKS Pod Identity) to
    access the respective AWS services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the models are built, `443` and deploy TLS certificates from ACM on the
    K8s load balancer service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can apply the annotations to a K8s Ingress resource backed by
    the AWS ALB to create an HTTPS listener secured with a TLS certificate from ACM,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, you can attach **AWS WAF** ([https://aws.amazon.com/waf/](https://aws.amazon.com/waf/))
    to the AWS ALB (K8s Ingress resource) to protect the model endpoints against common
    attack vectors, including injection attacks, malicious content inputs, and so
    on. You can use the following annotation to attach AWS WAF with AWS ALB.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we explored best practices for deploying GenAI workloads in
    K8s. We looked at the IRSA and EKS Pod Identity features to securely provide temporary
    IAM credentials to K8s applications. This is particularly important for GenAI
    applications, as it ensures secure, least-privilege access to sensitive training
    data or model artifacts stored in Amazon S3\. We also looked at techniques for
    protecting model endpoints, including enforcing TLS for encrypted communications
    and integrating a WAF to defend against common attack vectors. In the next section,
    we will implement these security best practices in our chatbot application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing security best practices in a chatbot app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will implement the security best practices discussed in
    the previous sections in our e-commerce chatbot application. We already implemented
    some of these in previous chapters, such as IRSA in [*Chapter 5*](B31108_05.xhtml#_idTextAnchor062),
    and K8s network policies in [*Chapter 8*](B31108_08.xhtml#_idTextAnchor097). Let’s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Container image encryption**: Amazon ECR stores container images in Amazon
    S3 buckets that ECR manages and, by default, uses the server-side encryption feature
    of S3 to encrypt the data at rest. It uses the **Advanced Encryption Standard**
    (**AES**) encryption algorithm using encryption keys managed by the S3 service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can verify this on the ECR repositories we created using the following AWS
    command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: resource "aws_kms_key" "ecr_kms_key" {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: deletion_window_in_days = 7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: enable_key_rotation = true
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: resource "aws_kms_alias" "ecr_kms_alias" {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: name = "alias/ecr-kms-key"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: target_key_id = aws_kms_key.ecr_kms_key.key_id
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: resource "aws_ecr_repository" "sample-app-repo" {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: name = "sample-app-repo"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: encryption_configuration {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: encryption_type = "KMS"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: kms_key  = aws_kms_key.ecr_kms_key.arn
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'image_tag_mutability attribute to IMMUTABLE in the ecr.tf file, as shown in
    the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ecr.tf` file, which enables enhanced scanning on the `my-llama-finetuned`
    ECR repository in our AWS account. Alternatively, you can download the source
    code from the GitHub repository at [https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/ecr.tf](https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/ecr.tf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This configuration ensures that images are scanned both when they are pushed
    and continuously thereafter for any new vulnerabilities:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following Terraform commands to apply this configuration in your AWS
    account:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Host security**: Harden the security of the worker nodes by using a purpose-built
    operation system such as Bottlerocket. This includes only the essential software
    required to run containers and ensures that the underlying software is always
    secure. It also improves the node start-up time from ~1.5 minutes to 20 seconds,
    based on a customer case study ([https://aws.amazon.com/bottlerocket/](https://aws.amazon.com/bottlerocket/)).
    Additionally, configure the worker nodes to use the latest version of IMDSv2 ([https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html))
    to limit access to sensitive metadata. The following code snippet highlights the
    use of Bottlerocket EKS AMIs and IMDSv2; the complete source code is available
    in the GitHub repository at [https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/eks.tf](https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/eks.tf):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**K8s Pod Security Standards**: Implementing K8s Pod Security Standards is
    critical to ensuring your workloads operate with the least privilege, thereby
    reducing the risk of privilege escalation and container escapes. Since our chatbot
    application is deployed in the default namespace, we can use the following command
    to enforce a baseline security policy while receiving warnings for more restrictive
    settings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test the enforced policy by attempting to run a pod with privileged settings
    using the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ export HUGGING_FACE_TOKEN=<<Your Token goes here>>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'secrets-store-csi-driver and secrets-store-csi-provider-aws add-ons in the
    EKS cluster to integrate external secret stores with K8s via a secrets-store-csi-provider-aws
    integrates AWS Secrets Manager and AWS Systems Manager Parameter Store with Kubernetes.
    To set up these add-ons in your EKS cluster, download the addons.tf file from
    the GitHub repository at https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/addons.tf
    and run the following commands:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: $ kubectl get ds -n kube-system
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: NAME
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: secrets-store-csi-driver
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'my-llama-finetuned K8s Pod can receive temporary IAM credentials using the
    EKS Pod Identity feature. To set up these resources, download the iam.tf file
    from the GitHub repository at https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/iam.tf
    and run the following commands:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'my-llama-finetuned application using the my-llama-sa service account. This
    approach securely injects the AWS Secrets Manager secret into your application
    container without exposing it in the Kubernetes manifest. To redeploy the app,
    download the finetuned-inf-deploy.yaml file from the GitHub repository at https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/inference/finetuned-inf-deploy.yaml.
    Then, update the ECR image name with your own and execute the following command:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: In this section, we implemented multiple security best practices in our chatbot
    application running on EKS. We ensured ECR image immutability to prevent image
    tag overwrites, hardened host security using Bottlerocket AMIs, enabled IMDSv2,
    and applied Pod Security Standards to enforce least privilege execution. Additionally,
    we implemented encryption at rest, integrated vulnerability scanning to our container
    images in Amazon ECR, and enhanced Kubernetes secrets management through encrypted
    secrets and external solutions such as AWS Secrets Manager via `secrets-store-csi-driver`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the security best practices for deploying applications
    on K8s, with a focus on defense in depth and securing key aspects of the container
    ecosystem, including supply chain, host, network, runtime, and secret management.
  prefs: []
  type: TYPE_NORMAL
- en: Defense in depth is a concept that involves multiple layers of security to safeguard
    against different attack vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Containers, being portable, introduce unique risks that require proactive measures
    at every lifecycle stage, from build to runtime. Supply chain security emphasizes
    securing container images during the build, test, and storage phases. Host security
    focuses on safeguarding the underlying server hosting containers. Runtime security
    ensures secure container operation by limiting privileges, enforcing resource
    limits, and using tools such as Falco for anomaly detection. Network security
    leverages namespaces, network policies, and service meshes such as Istio for segmentation
    and encryption. Secret management is essential for securely handling sensitive
    information. IRSA and EKS Pod Identity features can be used to securely provide
    temporary IAM credentials to K8s applications. GenAI workloads can leverage these
    features to securely access sensitive training data or export model artifacts
    in Amazon S3\. GenAI model endpoints can be protected against common vectors using
    WAF solutions and enforcing TLS for encrypted communications. By integrating these
    best practices, K8s deployments can achieve robust security against evolving threats.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focused on K8s security best practices; in the next chapter, we
    will start diving into GPU resource optimization for K8s, which is one of the
    most expensive resources for GenAI applications.
  prefs: []
  type: TYPE_NORMAL
