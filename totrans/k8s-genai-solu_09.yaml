- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Security Best Practices for Deploying GenAI on Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes上部署GenAI的安全最佳实践
- en: In this chapter, we will explore the security best practices for deploying GenAI
    applications on **Kubernetes** (**K8s**). We will begin by introducing the concept
    of “defense in depth” and then cover the key pillars of securing GenAI workloads
    – supply chain, host, network, and runtime security. Additionally, we will cover
    best practices for the management of secrets and the principle of least privilege
    to prevent unauthorized access to critical data and application credentials.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在**Kubernetes**（**K8s**）上部署GenAI应用的安全最佳实践。我们将从介绍“深度防御”概念开始，然后涵盖保护GenAI工作负载的关键支柱——供应链、安全主机、安全网络和运行时安全。此外，我们还将介绍管理机密信息的最佳实践以及最小权限原则，以防止未经授权访问关键数据和应用凭证。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主要内容：
- en: Defense in depth
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度防御
- en: K8s security considerations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: K8s安全考虑事项
- en: Additional considerations for GenAI apps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GenAI应用的额外考虑事项
- en: Implementing security best practices in a chatbot app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在聊天机器人应用中实施安全最佳实践
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will be using the following, the first of which requires
    you to set up an account and create an access token:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下内容，首先需要你设置一个账户并创建访问令牌：
- en: '**Hugging** **Face**: [https://huggingface.co/join](https://huggingface.co/join)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hugging** **Face**：[https://huggingface.co/join](https://huggingface.co/join)'
- en: An Amazon EKS cluster setup, as illustrated in [*Chapter 3*](B31108_03.xhtml#_idTextAnchor039)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如[*第3章*](B31108_03.xhtml#_idTextAnchor039)所示，亚马逊EKS集群的设置
- en: Defense in depth
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度防御
- en: The best way to protect an application in the cloud is by using the concept
    of **defense in depth** ([https://csrc.nist.gov/glossary/term/defense_in_depth](https://csrc.nist.gov/glossary/term/defense_in_depth)).
    This is a strategy that implements multiple layers of security to protect against
    threats across different attack vectors. *Figure 9**.1* shows a conceptual view
    of defense in depth, where each concentric circle represents a layer or attack
    vector we would like to secure.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 保护云中应用的最佳方式是使用**深度防御**概念（[https://csrc.nist.gov/glossary/term/defense_in_depth](https://csrc.nist.gov/glossary/term/defense_in_depth)）。这是一种实施多层安全的策略，旨在保护免受不同攻击向量的威胁。*图
    9.1*展示了深度防御的概念图，每个同心圆表示我们希望保护的某一层或攻击向量。
- en: Let’s look over this concept for security best practices, and then we will dive
    deeper for every layer, specific to containers and K8s.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾一下安全最佳实践的概念，然后再针对容器和K8s的每一层深入探讨。
- en: '![Figure 9.1 – Layered security model](img/B31108_09_1.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 分层安全模型](img/B31108_09_1.jpg)'
- en: Figure 9.1 – Layered security model
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 分层安全模型
- en: 'The following are details about the layers depicted in the preceding figure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述图中所示各层的详细信息：
- en: '**User data**: This is the innermost core of the system containing sensitive
    user data, such as user passwords, **personally identifiable information** (**PII**),
    and so on. To protect this layer, data encryption at rest and transit should be
    used.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户数据**：这是系统中最内层的核心，包含敏感的用户数据，如用户密码、**个人身份信息**（**PII**）等。为了保护这一层，应该使用数据静态和传输中的加密。'
- en: '**Configuration**: Sensitive configuration data for an application includes
    environment variables, application settings, secrets, and API keys required for
    the application to function. Lapses in configuration settings could lead to data
    leaks, privilege escalation, or compromised application behavior.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：应用的敏感配置数据包括环境变量、应用设置、机密信息以及应用运行所需的API密钥。配置设置上的疏忽可能导致数据泄漏、权限提升或应用行为被破坏。'
- en: '**Application code**: Vulnerabilities in application code can lead to exploits,
    such as SQL injection or remote code execution. To prevent this, users should
    conduct regular static and dynamic code analysis, promptly patch vulnerabilities,
    and update dependencies to the latest secure versions.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用代码**：应用代码中的漏洞可能导致攻击，如SQL注入或远程代码执行。为防止此类问题，用户应定期进行静态和动态代码分析，及时修复漏洞，并更新依赖项到最新的安全版本。'
- en: '**Dependencies**: Code dependencies include libraries, frameworks, and external
    packages that the application relies on. Vulnerable or outdated dependencies are
    one of the most common entry points for attackers. To prevent this, users should
    regularly scan dependencies for vulnerabilities.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**：代码依赖项包括应用程序依赖的库、框架和外部包。脆弱或过时的依赖项是攻击者最常见的入口点之一。为了防止这种情况，用户应定期扫描依赖项以发现漏洞。'
- en: '**Containers**: The container runtime and images could also create another
    threat vector, as misconfigured or untrusted containers can escalate privileges,
    attack the host, or expose sensitive information. To prevent this, users could
    use image signing to verify the authenticity of images and implement runtime security
    using tools such as **Falco** to watch out for malicious behavior.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：容器运行时和镜像也可能创建另一个威胁向量，因为配置错误或不受信任的容器可能会提升权限、攻击主机或暴露敏感信息。为了防止这种情况，用户可以使用镜像签名来验证镜像的真实性，并使用如**Falco**之类的工具实施运行时安全，监控恶意行为。'
- en: '**Host**: This is the underlying server or node where containers are deployed.
    The host kernel is shared among all containers, making it a critical security
    layer. If the host is compromised, all containers can be affected. To prevent
    this, it is recommended to harden the host operating system by disabling unused
    services, applying patches, and using container-optimized operating systems, such
    as **Bottlerocket**.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机**：这是部署容器的底层服务器或节点。主机内核在所有容器之间共享，这使得它成为一个关键的安全层。如果主机被攻破，所有容器都可能受到影响。为了防止这种情况，建议通过禁用未使用的服务、应用补丁以及使用优化过的容器操作系统（如**Bottlerocket**）来加固主机操作系统。'
- en: In this section, we learned about the concept of defense in depth, a strategy
    that implements multiple layers of security to protect against threats across
    different attack vectors. We also looked at a conceptual view of various attack
    vectors and best practices in each layer. In the next section, let’s look at key
    security considerations when deploying workloads in K8s.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了深度防御的概念，这是一种通过实施多层安全策略来防范不同攻击向量威胁的策略。我们还从概念上看了各种攻击向量和每一层的最佳实践。在下一节中，我们将讨论在
    K8s 中部署工作负载时的关键安全考虑事项。
- en: K8s security considerations
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: K8s 安全考虑
- en: Now that we have covered the concept of defense in depth at a high level, let’s
    discuss containers and K8s security best practices. Thinking about **container
    security** is critical in the cloud environment, as containers operate in a dynamic
    and shared environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从高层次了解了深度防御的概念，让我们讨论一下容器和 K8s 的安全最佳实践。在云环境中思考**容器安全**至关重要，因为容器在一个动态和共享的环境中运行。
- en: Containers encapsulate *software* and *dependencies* making them highly portable;
    however, this portability also introduces a set of risks. A comprehensive security
    strategy should address vulnerabilities across the container lifecycle – from
    *build pipelines* to *runtime environments*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 容器将*软件*和*依赖项*封装在一起，使其高度便携；然而，这种便携性也带来了一些风险。全面的安全策略应当解决容器生命周期中的漏洞——从*构建流水线*到*运行时环境*。
- en: Key areas of focus include securing the supply chain, protecting the host system,
    and monitoring runtime activity. Each layer of security adds resilience against
    potential threats, and by following the best practices, one can ensure the safe
    deployment and operation of containers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关注的关键领域包括保护供应链、保护主机系统和监控运行时活动。每一层安全都增加了对潜在威胁的韧性，通过遵循最佳实践，可以确保容器的安全部署和运行。
- en: 'The following are some of the key areas we will dive deeper into as part of
    this container security:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将深入探讨的容器安全的一些关键领域：
- en: Supply chain security
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应链安全
- en: Host security
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机安全
- en: Runtime security
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时安全
- en: Network security
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络安全
- en: Secrets management
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密管理
- en: Supply chain security
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 供应链安全
- en: The container supply chain encompasses all the stages from building an image
    to deploying and monitoring it in production, as shown in *Figure 9**.2*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 容器供应链包括从构建镜像到在生产环境中部署和监控镜像的所有阶段，如*图 9.2*所示。
- en: '![Figure 9.2 – Container supply chain](img/B31108_09_2.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 容器供应链](img/B31108_09_2.jpg)'
- en: Figure 9.2 – Container supply chain
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 容器供应链
- en: Now, let’s discuss the first five phases and their corresponding security best
    practices.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论前五个阶段及其相应的安全最佳实践。
- en: '**Build phase**'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建阶段**'
- en: During the build phase, malicious/vulnerable code can enter the container image
    through unverified dependencies or insecure configurations. To secure the build
    phase, one should only use trusted base images from verified sources. To minimize
    the attack surface and improve security, consider using lightweight parent images
    for your containers. **Alpine Linux** ([https://hub.docker.com/_/alpine](https://hub.docker.com/_/alpine)),
    **distroless** ([https://www.docker.com/blog/is-your-container-image-really-distroless/](https://www.docker.com/blog/is-your-container-image-really-distroless/)),
    or **scratch** ([https://hub.docker.com/_/scratch](https://hub.docker.com/_/scratch))
    images have fewer built-in packages, limiting the potential vulnerabilities, and
    are generally recommended.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建阶段，恶意/易受攻击的代码可能通过未经验证的依赖项或不安全的配置进入容器镜像。为了保障构建阶段的安全，应该只使用来自验证源的可信基础镜像。为了最小化攻击面并提高安全性，考虑使用轻量级的父镜像。**Alpine
    Linux** ([https://hub.docker.com/_/alpine](https://hub.docker.com/_/alpine))、**distroless**
    ([https://www.docker.com/blog/is-your-container-image-really-distroless/](https://www.docker.com/blog/is-your-container-image-really-distroless/))
    或 **scratch** ([https://hub.docker.com/_/scratch](https://hub.docker.com/_/scratch))
    镜像内置的包较少，限制了潜在的漏洞，因此通常被推荐使用。
- en: '**DockerSlim** ([https://github.com/slimtoolkit/slim](https://github.com/slimtoolkit/slim))
    is an open source tool that helps optimize container images by reducing their
    size, thus improving security by identifying only the parts that are required
    at runtime. This significantly reduces the attack surface and enhances performance
    without altering the functionality of the containerized application.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**DockerSlim** ([https://github.com/slimtoolkit/slim](https://github.com/slimtoolkit/slim))
    是一个开源工具，帮助通过减少容器镜像的大小来优化镜像，从而通过识别运行时所需的部分来提高安全性。这显著减少了攻击面，并在不改变容器化应用功能的情况下提升了性能。'
- en: It is also recommended to enforce the immutability of container images by using
    declarative Dockerfiles and reproducible builds. An `latest` tag is mutable, meaning
    it can point to different images over time as new images are pushed, whereas a
    tag such as `v1.0` is immutable, as it ensures that it always references the same
    image, regardless of future pushes. Immutability is particularly beneficial for
    GenAI applications to ensure the training/fine-tuning jobs and inference images
    are built against a consistent environment, maintain model integrity, and simplify
    troubleshooting efforts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 还建议通过使用声明式的 Dockerfile 和可重复构建来强制执行容器镜像的不可变性。`latest` 标签是可变的，这意味着随着新镜像的推送，它可能会指向不同的镜像，而像
    `v1.0` 这样的标签是不可变的，因为它确保始终引用相同的镜像，无论未来如何推送。不可变性对于 GenAI 应用特别有利，可以确保训练/微调任务和推理镜像是在一致的环境下构建的，维护模型完整性，并简化故障排除工作。
- en: A **multi-stage build** ([https://docs.docker.com/build/building/multi-stage/](https://docs.docker.com/build/building/multi-stage/))
    is a technique used in the build phase that allows you to break down the build
    process into multiple discrete stages. Each stage can focus on a specific task
    using an appropriate parent image, such as compiling code or installing dependencies,
    and then selectively copy only the necessary artifacts into the final, minimal
    image.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**多阶段构建** ([https://docs.docker.com/build/building/multi-stage/](https://docs.docker.com/build/building/multi-stage/))
    是一种在构建阶段使用的技术，它允许将构建过程分解为多个独立的阶段。每个阶段可以使用适当的父镜像专注于特定任务，比如编译代码或安装依赖项，然后选择性地将仅需要的工件复制到最终的最小镜像中。'
- en: For GenAI applications, multi-stage builds help ensure that large training frameworks,
    data preprocessing scripts, or model optimization steps can selectively be excluded
    from the final production image. This results in smaller, more secure, and efficient
    images that can be quickly deployed for inference.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 GenAI 应用，多阶段构建有助于确保大型训练框架、数据预处理脚本或模型优化步骤可以有选择地从最终的生产镜像中排除。这将生成更小、更安全且高效的镜像，能够快速部署进行推理。
- en: '**Test phase**'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**测试阶段**'
- en: Undetected vulnerabilities and misconfigurations in images can lead to issues
    downstream. To mitigate this, it is recommended to integrate automated security
    testing into CI/CD pipelines with tools such as **Snyk** ([https://snyk.io/](https://snyk.io/)).
    You should perform static analysis on code and dynamic testing on built images
    to uncover vulnerabilities. Ensure that your testing process also covers compliance
    with internal security policies and relevant industry standards. Incorporate test
    cases to assess resource usage, verify adherence to least-privilege principles,
    and monitor runtime behaviors. By doing so, you can help maintain secure, compliant,
    and predictable operations throughout the software lifecycle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像中的未检测到的漏洞和配置错误可能导致下游问题。为减轻这种风险，建议将自动化安全测试集成到CI/CD管道中，使用像**Snyk**（[https://snyk.io/](https://snyk.io/)）这样的工具。你应对代码进行静态分析，并对构建后的镜像进行动态测试，以发现漏洞。确保你的测试过程还涵盖与内部安全政策和相关行业标准的合规性。结合测试用例评估资源使用情况，验证最小权限原则的遵守情况，并监控运行时行为。通过这样做，你可以帮助在整个软件生命周期中保持安全、合规和可预测的操作。
- en: '**Store phase**'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**存储阶段**'
- en: During the image store phase in container registries, images can be tampered
    with or can contain outdated dependencies. To safely secure images, it is recommended
    to use secured container registries such as **Amazon** **ECR** ([https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器注册表的镜像存储阶段，镜像可能会被篡改或包含过时的依赖项。为了安全地保护镜像，建议使用像**Amazon** **ECR**（[https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)）这样的安全容器注册表。
- en: You should also enable image signing and verification using tools such as Docker
    Content Trust or Cosign. **AWS Signer** ([https://docs.aws.amazon.com/signer/latest/developerguide/Welcome.html](https://docs.aws.amazon.com/signer/latest/developerguide/Welcome.html))
    is a fully managed service that allows you to digitally sign code, applications,
    and containers to ensure the integrity and authenticity of your software.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该使用像Docker Content Trust或Cosign这样的工具启用镜像签名和验证。**AWS Signer**（[https://docs.aws.amazon.com/signer/latest/developerguide/Welcome.html](https://docs.aws.amazon.com/signer/latest/developerguide/Welcome.html)）是一个完全托管的服务，允许你对代码、应用程序和容器进行数字签名，以确保软件的完整性和真实性。
- en: To ensure that only signed container images are deployed in production, a **policy-as-code
    solution** such as **Open Policy Agent** (**OPA**) or its K8s-native implementation,
    **OPA Gatekeeper** ([https://github.com/open-policy-agent/gatekeeper](https://github.com/open-policy-agent/gatekeeper)),
    is recommended. OPA Gatekeeper is an open source project that leverages OPA to
    enforce policies in K8s clusters. It enables administrators to implement fine-grained
    governance by validating and mutating K8s resources against predefined constraints.
    Gatekeeper uses **custom resource definitions** (**CRDs**) to define these policies
    and constraints, allowing users to tailor governance to their specific needs.
    It operates as an admission controller, ensuring that any resource not complying
    with the defined rules is denied during creation or updates. Additionally, it
    supports auditing capabilities, enabling users to identify and remediate policy
    violations in existing resources. **Role-based access control** (**RBAC**) is
    also recommended to restrict access to images, and users should regularly clean
    up unused or deprecated images to reduce potential attack surfaces.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保在生产环境中仅部署签名的容器镜像，建议使用**政策即代码解决方案**，例如**Open Policy Agent**（**OPA**）或其K8s原生实现**OPA
    Gatekeeper**（[https://github.com/open-policy-agent/gatekeeper](https://github.com/open-policy-agent/gatekeeper)）。OPA
    Gatekeeper是一个开源项目，它利用OPA在K8s集群中执行策略。它使管理员能够通过根据预定义约束验证和修改K8s资源来实施精细的治理。Gatekeeper使用**自定义资源定义**（**CRDs**）来定义这些策略和约束，从而使用户能够根据特定需求定制治理。它作为一个准入控制器，确保在创建或更新时，任何不符合定义规则的资源都将被拒绝。此外，它支持审计功能，使用户能够识别和修复现有资源中的政策违规行为。还建议使用**基于角色的访问控制**（**RBAC**）来限制对镜像的访问，用户应定期清理未使用或弃用的镜像，以减少潜在的攻击面。
- en: '**Encrypt phase**'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**加密阶段**'
- en: Sensitive data in images should always be intercepted. One should avoid embedding
    secrets (e.g., API keys or passwords) directly in images to prevent leaks in case
    of a potentially compromised container image.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像中的敏感数据应始终被拦截。应该避免将秘密（如API密钥或密码）直接嵌入镜像中，以防止在容器镜像可能被攻破时泄露。
- en: You can use secret management tools such as **HashiCorp Vault** ([https://www.hashicorp.com/products/vault](https://www.hashicorp.com/products/vault)),
    **Kubernetes Secrets** ([https://kubernetes.io/docs/concepts/configuration/secret/](https://kubernetes.io/docs/concepts/configuration/secret/)),
    or **AWS Secrets Manager** ([https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html))
    to store the secrets. For example, AWS Secrets Manager is a secure service for
    managing secrets, such as database credentials, API keys, and other sensitive
    configuration data. By encrypting secrets with **AWS Key Management Service**
    (**AWS KMS**) and enabling fine-grained access control through **AWS Identity
    and Access Management** (**AWS IAM**), Secrets Manager ensures that sensitive
    data is protected and accessible only to authorized users and applications. It
    also supports version control and the automatic rotation of secrets, reducing
    the risks of credential exposure and minimizing manual overhead.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用像 **HashiCorp Vault** ([https://www.hashicorp.com/products/vault](https://www.hashicorp.com/products/vault))、**Kubernetes
    Secrets** ([https://kubernetes.io/docs/concepts/configuration/secret/](https://kubernetes.io/docs/concepts/configuration/secret/))
    或 **AWS Secrets Manager** ([https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html))
    这样的机密管理工具来存储机密。例如，AWS Secrets Manager 是一个安全的机密管理服务，用于管理数据库凭证、API 密钥和其他敏感配置数据。通过
    **AWS Key Management Service** (**AWS KMS**) 加密机密，并通过 **AWS Identity and Access
    Management** (**AWS IAM**) 启用细粒度的访问控制，Secrets Manager 确保敏感数据受到保护，仅授权用户和应用程序可以访问。它还支持版本控制和机密的自动轮换，减少了凭证泄露的风险，并最小化了手动操作的开销。
- en: To integrate external secret management solutions with K8s, you can use projects
    such as **secrets-store-csi-driver** ([https://github.com/kubernetes-sigs/secrets-store-csi-driver](https://github.com/kubernetes-sigs/secrets-store-csi-driver)),
    which allows K8s to mount multiple secrets, keys, and certificates stored in external
    secrets stores into K8s Pods as a volume. Once the volume is attached, the data
    in it is mounted into the container’s filesystem. Refer to the AWS documentation
    at [https://docs.aws.amazon.com/secretsmanager/latest/userguide/integrating_csi_driver.html](https://docs.aws.amazon.com/secretsmanager/latest/userguide/integrating_csi_driver.html)
    for an example walkthrough of using AWS Secrets Manager in an Amazon EKS cluster.
    In the case of GenAI applications, external API keys from **Hugging Face** and
    **OpenAI** can safely be stored in these solutions, and applications can securely
    access them during the runtime.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要将外部机密管理解决方案与 K8s 集成，可以使用像 **secrets-store-csi-driver** ([https://github.com/kubernetes-sigs/secrets-store-csi-driver](https://github.com/kubernetes-sigs/secrets-store-csi-driver))
    这样的项目，该项目允许 K8s 将存储在外部机密存储中的多个机密、密钥和证书挂载到 K8s Pods 中作为卷。一旦卷被挂载，数据就会被载入容器的文件系统。请参阅
    AWS 文档 [https://docs.aws.amazon.com/secretsmanager/latest/userguide/integrating_csi_driver.html](https://docs.aws.amazon.com/secretsmanager/latest/userguide/integrating_csi_driver.html)，了解如何在
    Amazon EKS 集群中使用 AWS Secrets Manager 的示例教程。在 GenAI 应用程序的情况下，**Hugging Face** 和
    **OpenAI** 的外部 API 密钥可以安全地存储在这些解决方案中，应用程序可以在运行时安全地访问它们。
- en: '**Scan phase**'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**扫描阶段**'
- en: Vulnerabilities in images or dependencies can lead to exploitation by bad actors.
    To prevent this, images should be continuously scanned during the build and store
    phases. Most container registry solutions provide this capability out of the box,
    or open source tools such as **Trivy** ([https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy))
    can be used to scan container images for vulnerabilities. These tools identify
    potential risks by analyzing image layers against known vulnerability databases
    (e.g., CVE databases), providing early detection of issues.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像或依赖项中的漏洞可能会被恶意行为者利用。为了防止这种情况，应在构建和存储阶段持续扫描镜像。大多数容器注册表解决方案提供开箱即用的此功能，或者可以使用像
    **Trivy** ([https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy))
    这样的开源工具来扫描容器镜像中的漏洞。这些工具通过分析镜像层与已知漏洞数据库（例如 CVE 数据库）进行对比，从而识别潜在的风险，提供早期问题检测。
- en: In cloud environments, more advanced image scanning options are also available.
    For example, Amazon ECR supports advanced vulnerability scanning through **Amazon
    Inspector** ([https://aws.amazon.com/inspector/](https://aws.amazon.com/inspector/)),
    a managed service designed to automate security assessments. This integration
    provides enhanced, continuous scanning for container images in ECR, ensuring they
    remain secure throughout their lifecycle. Amazon Inspector can scan container
    images in ECR automatically, without requiring manual triggers, whenever a new
    image is pushed or updated. Refer to the Amazon ECR documentation at [https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-scanning.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-scanning.html)
    to learn more about these options and how to enable them on your container repositories.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，还提供了更先进的镜像扫描选项。例如，Amazon ECR支持通过**Amazon Inspector**([https://aws.amazon.com/inspector/](https://aws.amazon.com/inspector/))，这是一项旨在自动化安全评估的托管服务，进行高级漏洞扫描。此集成提供了增强的、持续的容器镜像扫描，确保它们在整个生命周期中保持安全。Amazon
    Inspector可以自动扫描ECR中的容器镜像，无需手动触发，每当新镜像被推送或更新时，都会进行扫描。有关这些选项以及如何在容器库中启用它们的详细信息，请参考Amazon
    ECR文档：[https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-scanning.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-scanning.html)。
- en: Host security
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机安全
- en: 'Securing the host environment for containers is critical, as multiple containers
    can share the host operating system and kernel. The following are some of the
    best practices and strategies for securing container hosts:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为容器的主机环境提供安全保障至关重要，因为多个容器可能共享主机操作系统和内核。以下是确保容器主机安全的一些最佳实践和策略：
- en: '**Deploy in private subnets**: Deploying hosts/worker nodes in private subnets
    minimizes exposure to external threats by restricting direct access from the internet.
    To expose applications to the public internet, deploy load balancer resources
    in public subnets using K8s load balancer or Ingress resource types.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署在私有子网中**：将主机/工作节点部署在私有子网中，可以通过限制来自互联网的直接访问，最小化暴露于外部威胁的风险。为了将应用程序暴露给公共互联网，可以使用K8s负载均衡器或Ingress资源类型，将负载均衡器资源部署在公共子网中。'
- en: '**Disable SSH access**: SSH access should be limited to minimizing the attack
    vector. Instead, **session management tools** such as **AWS Systems Manager**
    (**SSM**) ([https://aws.amazon.com/systems-manager/](https://aws.amazon.com/systems-manager/))
    should be used for secure, auditable access to hosts without exposing SSH. If
    SSH is necessary, enforce key-based authentication and restrict access using security
    groups.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁用SSH访问**：SSH访问应限制到最小化攻击面。相反，应该使用**会话管理工具**，例如**AWS Systems Manager**（**SSM**）([https://aws.amazon.com/systems-manager/](https://aws.amazon.com/systems-manager/))，以便在不暴露SSH的情况下实现对主机的安全、可审计访问。如果必须使用SSH，强制实施基于密钥的身份验证，并使用安全组限制访问。'
- en: '`1` and enforce the usage of IMDSv2, as shown in the following Terraform code:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`并强制使用IMDSv2，如以下Terraform代码所示：'
- en: '[PRE0]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Encrypt all storage**: Encrypting storage protects sensitive data on the
    host in case of physical or logical compromise. Use AWS KMS to encrypt **Amazon
    Elastic Block Store** (**Amazon EBS**) volumes attached to the host. If using
    EC2 instances with an **NVMe** instance store, all the data is encrypted using
    an XTS-AES-256 block cipher.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密所有存储**：加密存储可以保护主机上的敏感数据，以防止物理或逻辑攻击。使用AWS KMS加密附加到主机的**Amazon Elastic Block
    Store**（**Amazon EBS**）卷。如果使用带有**NVMe**实例存储的EC2实例，则所有数据都将使用XTS-AES-256块加密算法进行加密。'
- en: '**Harden the node Amazon Machine Image (AMI)**: A hardened AMI reduces vulnerabilities
    by including only the necessary software, configurations, and security settings.
    Use container-optimized operating systems such as Bottlerocket ([https://aws.amazon.com/bottlerocket/](https://aws.amazon.com/bottlerocket/)),
    which are built from the ground up with containers in mind. They often include
    features such as a read-only root filesystem, atomic updates, and minimal tooling
    tailored to running containers efficiently and securely. You should disable and
    uninstall unused software to reduce the attack surface and configure the operating
    system according to CIS benchmarks for Docker, Kubernetes, and Linux. Use **AppArmor**
    ([https://apparmor.net/](https://apparmor.net/)), **SELinux** ([https://www.redhat.com/en/topics/linux/what-is-selinux](https://www.redhat.com/en/topics/linux/what-is-selinux)),
    or **seccomp** ([https://kubernetes.io/docs/tutorials/security/seccomp/](https://kubernetes.io/docs/tutorials/security/seccomp/))
    to restrict container privileges.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加固节点 Amazon 机器映像 (AMI)**：加固的 AMI 通过仅包含必要的软件、配置和安全设置来减少漏洞。使用容器优化的操作系统，如 Bottlerocket
    ([https://aws.amazon.com/bottlerocket/](https://aws.amazon.com/bottlerocket/))，它是从零开始构建，专为容器设计。它们通常包含只读根文件系统、原子更新和最小化的工具集，这些工具集旨在高效且安全地运行容器。你应该禁用并卸载未使用的软件，以减少攻击面，并根据
    CIS 基准配置操作系统，适用于 Docker、Kubernetes 和 Linux。使用 **AppArmor** ([https://apparmor.net/](https://apparmor.net/))、**SELinux**
    ([https://www.redhat.com/en/topics/linux/what-is-selinux](https://www.redhat.com/en/topics/linux/what-is-selinux))
    或 **seccomp** ([https://kubernetes.io/docs/tutorials/security/seccomp/](https://kubernetes.io/docs/tutorials/security/seccomp/))
    来限制容器权限。'
- en: Container runtime security
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器运行时安全
- en: 'Securing containers at runtime is critical to prevent privilege escalations
    and unauthorized access. This involves limiting resources, restricting privileges,
    enforcing security standards, and integrating monitoring and policy tools. The
    following are the core runtime security practices:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时保护容器对防止权限升级和未经授权的访问至关重要。这包括限制资源、限制权限、执行安全标准以及集成监控和策略工具。以下是核心的运行时安全实践：
- en: '**Provide only the resources required for normal operation**: Unrestricted
    resource allocation can lead to **denial-of-service** (**DoS**) attacks and cluster
    instability, where some containers can consume entire node resources. To prevent
    this, you should define CPU and memory limits in K8s manifests reflecting the
    optimal resources a container might need.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅提供正常运行所需的资源**：无限制的资源分配可能导致 **拒绝服务**（**DoS**）攻击和集群不稳定，某些容器可能会消耗整个节点的资源。为了防止这种情况，你应该在
    K8s 清单中定义 CPU 和内存限制，反映容器可能需要的最佳资源。'
- en: '`securityContext`, as shown here:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`securityContext`，如下所示：'
- en: '[PRE1]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'securityContext:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'securityContext:'
- en: 'capabilities:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'capabilities:'
- en: 'drop:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'drop:'
- en: '- ALL'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- ALL'
- en: '...'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: '[PRE2]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Follow Pod Security Standards**: Adherence to Pod Security Standards ensures
    that containers comply with best practices for security configurations. Use the
    K8s built-in Pod Security Admission to enforce standards such as restricted profiles.
    Also, isolate workloads using namespaces with different security levels (e.g.,
    restricted or baseline). Pod Security Standards define three different policy
    levels (privileged, baseline, and restricted) to broadly cover the security spectrum.
    You can apply labels and annotations on namespaces to specify the desired level
    of security configuration, as shown here:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遵循 Pod 安全标准**：遵守 Pod 安全标准确保容器符合最佳的安全配置实践。使用 K8s 内置的 Pod 安全准入来强制执行如限制性配置文件等标准。同时，使用不同安全级别（例如，限制性或基准）的命名空间隔离工作负载。Pod
    安全标准定义了三种不同的策略级别（特权、基准和限制），广泛覆盖安全范围。你可以在命名空间上应用标签和注释，以指定所需的安全配置级别，如下所示：'
- en: '[PRE3]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Network security
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络安全
- en: 'Network security in K8s is critical for securing data and applications in a
    containerized environment. The distributed nature of K8s presents unique challenges
    for securing network traffic. The following are some key considerations and best
    practices for ensuring network security in K8s:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: K8s 中的网络安全对于保护容器化环境中的数据和应用程序至关重要。K8s 的分布式特性为安全网络流量带来了独特的挑战。以下是一些确保 K8s 网络安全的关键考虑因素和最佳实践：
- en: '**Network segmentation and isolation**: K8s **namespaces** provide a way to
    isolate resources and workloads within a cluster, acting as separate security
    boundaries. Network segmentation can be enforced using **NetworkPolicy** resources,
    discussed in [*Chapter 8*](B31108_08.xhtml#_idTextAnchor097), which define rules
    for controlling ingress (incoming) and egress (outgoing) traffic at the Pod level.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络分段与隔离**：K8s **命名空间** 提供了一种在集群内隔离资源和工作负载的方法，充当独立的安全边界。可以使用 **NetworkPolicy**
    资源来强制执行网络分段，如在 [*第 8 章*](B31108_08.xhtml#_idTextAnchor097) 中讨论的那样，它定义了控制 Pod 层级的入口（传入）和出口（传出）流量的规则。'
- en: '**Securing Pod-to-Pod communication**: By default, K8s allows communication
    between Pods, which can expose K8s clusters to security risks. Implementing zero-trust
    principles ensures that Pods communicate only with explicitly authorized peers.
    Service mesh technologies such as **Istio** or **Linkerd** provide mTLS for encryption
    and authentication, ensuring secure and authenticated Pod-to-Pod communication.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护 Pod 到 Pod 的通信**：默认情况下，K8s 允许 Pods 之间的通信，这可能会使 K8s 集群暴露于安全风险之下。实施零信任原则确保
    Pods 仅与明确授权的对等体进行通信。像 **Istio** 或 **Linkerd** 这样的服务网格技术提供 mTLS 进行加密和身份验证，确保 Pod
    到 Pod 之间的通信安全且已验证。'
- en: '**Ingress and egress security**: Ingress security focuses on controlling and
    securing incoming traffic to the cluster, often using HTTPS with TLS certificates
    for encryption. Additional protection, such as **web application firewalls** (**WAFs**),
    help detect and block malicious traffic. Egress security involves restricting
    Pods’ outbound traffic to prevent unauthorized access to external resources, which
    can be enforced using egress policies.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入口和出口安全**：入口安全侧重于控制和保护进入集群的流量，通常使用带有 TLS 证书的 HTTPS 进行加密。额外的保护措施，如 **Web 应用防火墙**（**WAFs**），有助于检测和阻止恶意流量。出口安全涉及限制
    Pods 的外向流量，以防止未经授权访问外部资源，可以通过出口策略来强制执行。'
- en: '**API server protection**: The K8s API server is a critical management point,
    requiring strong security measures. RBAC restricts user permissions based on roles,
    while authentication mechanisms such as **OpenID Connect** (**OIDC**) or AWS IAM
    ensure that only authorized users access the server. Network policies or firewalls
    should further limit access to the API server from trusted sources only.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 服务器保护**：K8s API 服务器是一个关键的管理点，需要采取强有力的安全措施。RBAC 根据角色限制用户权限，而像 **OpenID
    Connect**（**OIDC**）或 AWS IAM 等身份验证机制确保只有授权用户才能访问该服务器。网络策略或防火墙应进一步限制只有来自受信源的访问才能进入
    API 服务器。'
- en: '**DNS security**: CoreDNS, the default DNS server in K8s, should be secured
    against spoofing and related attacks. While enabling encrypted DNS protocols such
    as **DNS-over-TLS** or **DNS-over-HTTPS** ([https://www.cloudflare.com/learning/dns/dns-over-tls/](https://www.cloudflare.com/learning/dns/dns-over-tls/))
    is technically possible, it is not commonly implemented by default in K8s. Instead,
    use network policies to restrict which Pods can query the CoreDNS server, thereby
    reducing the risk of unauthorized requests. Additionally, ensure CoreDNS points
    to trusted upstream resolvers, employing **DNSSEC** ([https://www.internetsociety.org/deploy360/dnssec/basics/](https://www.internetsociety.org/deploy360/dnssec/basics/))
    for integrity.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DNS 安全**：CoreDNS 是 K8s 中的默认 DNS 服务器，应该防范欺骗和相关攻击。虽然启用加密 DNS 协议如 **DNS-over-TLS**
    或 **DNS-over-HTTPS** ([https://www.cloudflare.com/learning/dns/dns-over-tls/](https://www.cloudflare.com/learning/dns/dns-over-tls/))
    在技术上是可行的，但 K8s 默认并不常实现这一功能。相反，使用网络策略来限制哪些 Pods 可以查询 CoreDNS 服务器，从而减少未经授权请求的风险。此外，确保
    CoreDNS 指向可信的上游解析器，并采用 **DNSSEC** ([https://www.internetsociety.org/deploy360/dnssec/basics/](https://www.internetsociety.org/deploy360/dnssec/basics/))
    来确保数据完整性。'
- en: '**Network monitoring**: Monitoring network traffic is crucial for detecting
    and mitigating threats. Tools such as Cilium, Calico, Sysdig, service meshes,
    or Datadog provide visibility into cluster traffic, enabling cluster administrators
    to identify suspicious behavior.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络监控**：监控网络流量对于检测和缓解威胁至关重要。像 Cilium、Calico、Sysdig、服务网格或 Datadog 这样的工具可以提供集群流量的可见性，使集群管理员能够识别可疑行为。'
- en: '**Securing external connections**: Connections to external services, such as
    cloud provider services or databases, should be encrypted and authenticated. K8s
    Secrets offer a secure way to manage credentials for external connections, ensuring
    that sensitive information (such as API keys and passwords) remains protected
    from unauthorized access.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护外部连接**：与外部服务（如云服务提供商服务或数据库）的连接应当加密并进行身份验证。K8s Secrets 提供了一种安全的方式来管理外部连接的凭据，确保敏感信息（如
    API 密钥和密码）不被未经授权的访问。'
- en: Secrets management
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Secrets 管理
- en: 'Secrets management in K8s is a critical component for securing and managing
    sensitive information, such as API keys, passwords, certificates, and tokens.
    K8s provides built-in mechanisms to manage Secrets but securing them requires
    careful configuration and the following best practices to mitigate risks of unauthorized
    access or accidental exposure:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: K8s 中的 Secrets 管理是保护和管理敏感信息（如 API 密钥、密码、证书和令牌）的关键组成部分。K8s 提供了内置机制来管理 Secrets，但要确保其安全，需要仔细配置并遵循以下最佳实践，以降低未经授权访问或意外泄露的风险：
- en: '**K8s Secrets resource**: K8s provides a native resource called **Secrets**,
    which is used to store sensitive data in a Base64-encoded format. Secrets are
    mounted into Pods as environment variables or files, enabling applications to
    access them without embedding sensitive data directly in container images or configuration
    files. While convenient, the Base64 encoding is not encryption, so additional
    security measures are necessary.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**K8s Secrets 资源**：K8s 提供了一种名为 **Secrets** 的原生资源，用于以 Base64 编码格式存储敏感数据。Secrets
    会作为环境变量或文件挂载到 Pods 中，使得应用程序能够访问它们，而无需直接在容器镜像或配置文件中嵌入敏感数据。尽管方便，但 Base64 编码并非加密，因此需要采取额外的安全措施。'
- en: '**Encrypting Secrets at rest**: By default, K8s stores Secrets in **etcd**,
    the cluster’s key-value store. To protect this sensitive information, it is essential
    to enable encryption at rest for etcd. When using managed K8s services such as
    Amazon EKS, etcd volumes are encrypted by default using AWS managed encryption
    keys. As an additional security measure, you can also use techniques such as envelope
    encryption to encrypt the Secret values before writing to the etcd database. In
    Amazon EKS, you can utilize AWS KMS to enable envelope encryption; refer to the
    AWS documentation at [https://docs.aws.amazon.com/eks/latest/userguide/envelope-encryption.html](https://docs.aws.amazon.com/eks/latest/userguide/envelope-encryption.html)
    to learn more.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密静态 Secrets**：默认情况下，K8s 将 Secrets 存储在 **etcd** 中，这是集群的键值存储。为了保护这些敏感信息，必须启用
    etcd 的静态加密。当使用如 Amazon EKS 这样的托管 K8s 服务时，etcd 卷默认会使用 AWS 托管的加密密钥进行加密。作为额外的安全措施，您还可以使用如封装加密的技术，在写入
    etcd 数据库之前加密 Secret 值。在 Amazon EKS 中，您可以利用 AWS KMS 启用封装加密；请参考 AWS 文档 [https://docs.aws.amazon.com/eks/latest/userguide/envelope-encryption.html](https://docs.aws.amazon.com/eks/latest/userguide/envelope-encryption.html)
    了解更多信息。'
- en: '**Access control with RBAC**: RBAC is a fundamental part of securing Secrets
    in K8s. RBAC policies should enforce the principle of least privilege, granting
    users, Pods, and Services access only to the Secrets they need. Properly configured
    roles and role bindings help prevent unauthorized users or applications from accessing
    sensitive information.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RBAC 访问控制**：RBAC 是保护 K8s Secrets 的基础部分。RBAC 策略应当执行最小权限原则，仅授予用户、Pods 和 Services
    访问其所需的 Secrets。正确配置的角色和角色绑定有助于防止未经授权的用户或应用程序访问敏感信息。'
- en: '`secrets-store-csi-driver` plugin or other operators, enabling seamless access
    to externally managed secrets.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secrets-store-csi-driver` 插件或其他操作符，支持无缝访问外部管理的机密数据。'
- en: '**Automating Secret rotation**: Rotating Secrets regularly reduces the risk
    of long-term compromise. K8s secrets do not natively support automatic rotation,
    but external secret management tools often include this capability. Integrating
    such tools into K8s workflows allows you to periodically update secrets without
    disrupting applications, ensuring compliance with security best practices.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化 Secret 轮换**：定期轮换 Secrets 可降低长期泄露的风险。K8s 的 Secrets 本身不原生支持自动轮换，但外部的秘密管理工具通常包含此功能。将这些工具集成到
    K8s 工作流中，可以在不干扰应用程序的情况下定期更新 secrets，确保遵循安全最佳实践。'
- en: '**Protecting Secrets in transit**: Sensitive data, including secrets, must
    be protected as it travels between clients, nodes, and the etcd store. Enable
    TLS encryption when exchanging sensitive credentials both with internal and external
    systems.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护传输中的机密**：敏感数据，包括机密信息，在客户端、节点和etcd存储之间传输时必须得到保护。在与内部和外部系统交换敏感凭据时，请启用TLS加密。'
- en: '**Auditing and monitoring access to Secrets**: Audit logging is essential for
    monitoring access to secrets and detecting potential misuse. K8s can generate
    audit logs for API actions, including those involving secrets. Integrating these
    logs with centralized monitoring tools or **security information and event management**
    (**SIEM**) solutions helps administrators detect suspicious activity and respond
    promptly. Secret management tools also provide audit logs, which can be integrated
    into SIEM solutions.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计和监控机密访问**：审计日志对于监控机密访问和检测潜在的滥用行为至关重要。K8s可以生成API操作的审计日志，包括涉及机密的操作。将这些日志与集中监控工具或**安全信息和事件管理**（**SIEM**）解决方案集成，帮助管理员检测可疑活动并及时响应。机密管理工具也提供审计日志，这些日志可以集成到SIEM解决方案中。'
- en: In this section, we looked at various security considerations when running containerized
    workloads in K8s, including supply chain security, host security, network security,
    and the importance of securing sensitive information using K8s Secrets. In the
    next section, let’s explore additional security considerations specific to GenAI
    applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了在K8s中运行容器化工作负载时的各种安全考虑因素，包括供应链安全、主机安全、网络安全，以及使用K8s机密保护敏感信息的重要性。在下一节中，让我们探讨一些针对GenAI应用程序的额外安全考虑因素。
- en: Additional considerations for GenAI apps
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GenAI应用程序的额外考虑事项
- en: 'Deploying GenAI applications on K8s often involves proprietary model artifacts,
    large volumes of sensitive training data, and sophisticated inference requests
    that can originate from untrusted sources. Beyond the standard practices of K8s
    security, you must consider new attack vectors related to model integrity, data
    privacy, software supply chain vulnerabilities, and the isolation of high-value
    hardware resources such as GPUs. Let’s explore some of those considerations now:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在K8s上部署GenAI应用程序通常涉及专有模型工件、大量敏感的训练数据，以及可能来自不受信任源的复杂推理请求。除了K8s安全的标准做法外，还必须考虑与模型完整性、数据隐私、软件供应链漏洞以及高价值硬件资源（如GPU）隔离相关的新攻击向量。让我们现在来探索一些这些考虑因素：
- en: '**Data privacy and compliance**'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**数据隐私和合规性**'
- en: GenAI models often rely on proprietary and sensitive datasets stored in data
    lakes, data hubs, and data warehouses for training and fine-tuning. In our walkthrough
    ([*Chapter 5*](B31108_05.xhtml#_idTextAnchor062)), we used **Amazon S3** buckets
    to store the datasets used during the fine-tuning process. Depending on the data
    classification and regulatory requirements, you must implement appropriate security
    controls such as data encryption at rest, strict access control policies, and
    auditing. When accessing these data repositories from GenAI applications running
    on K8s, ensure that all communications are encrypted using TLS and follow the
    principle of least privilege by leveraging K8s and related mechanisms. When running
    GenAI applications on Amazon EKS, you can leverage **IAM Roles for Service Accounts**
    (**IRSA**) ([https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html](https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html))
    or **EKS Pod Identity** ([https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html](https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html))
    features to obtain temporary IAM credentials and access data from other services
    such as Amazon S3.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: GenAI模型通常依赖存储在数据湖、数据中心和数据仓库中的专有和敏感数据集进行训练和微调。在我们的演示中（[*第5章*](B31108_05.xhtml#_idTextAnchor062)），我们使用**Amazon
    S3**存储桶存储了微调过程中使用的数据集。根据数据分类和法规要求，必须实施适当的安全控制措施，例如静态数据加密、严格的访问控制政策和审计。当从在K8s上运行的GenAI应用程序访问这些数据存储库时，确保所有通信都通过TLS加密，并通过利用K8s和相关机制遵循最小权限原则。在Amazon
    EKS上运行GenAI应用程序时，您可以利用**服务账户的IAM角色**（**IRSA**）([https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html](https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html))
    或**EKS Pod身份**([https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html](https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html))特性来获取临时的IAM凭证并访问来自其他服务的数据，如Amazon
    S3。
- en: IAM Roles for Service Accounts
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务账户的IAM角色
- en: IRSA was introduced in 2019 to associate fine-grained IAM roles with K8s service
    accounts. Applications running in K8s Pods can assume the role using their **service
    account identity** and access other AWS services based on the role permissions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: IRSA于2019年推出，用于将细粒度的IAM角色与K8s服务账户关联。运行在K8s Pod中的应用程序可以使用它们的**服务账户身份**假设该角色，并根据角色权限访问其他AWS服务。
- en: 'The following are the high-level steps involved in the process; refer to the
    Amazon EKS documentation at [https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html](https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html)
    for detailed guidance:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该过程中的高层次步骤；有关详细指导，请参考Amazon EKS文档：[https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html](https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html)：
- en: Set up an OIDC provider in AWS IAM for the Amazon EKS cluster.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS IAM中为Amazon EKS集群设置OIDC提供程序。
- en: Create fine-grained IAM policies to grant necessary permissions on AWS services.
    Refer to the security best practices documentation at [https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#grant-least-privilege](https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#grant-least-privilege)
    for guidance on creating IAM policies.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建细粒度的IAM策略，为AWS服务授予必要的权限。有关创建IAM策略的指导，请参考[https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#grant-least-privilege](https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#grant-least-privilege)中的安全最佳实践文档。
- en: 'Create an IAM role with the permission policies from *Step 2* and a trust policy
    for the K8s service account to the **assume** role:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有*步骤2*权限策略的IAM角色，并为K8s服务账户创建信任策略以**假设**角色：
- en: '[PRE4]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a K8s service account and annotate it with the IAM role from *Step 3*:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个K8s服务账户，并使用*步骤3*中的IAM角色进行注释：
- en: '[PRE5]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Deploy the K8s application using the annotated service account:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用注释的服务账户部署K8s应用程序：
- en: '[PRE6]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When an application uses the AWS SDK to access other AWS resources, the SDK
    will invoke `AssumeRoleWithWebIdentity`, an AWS **Security Token Service** (**STS**)
    API operation that allows an application to assume an IAM role using a trusted
    web identity token, instead of long-lived access keys or IAM users, to fetch temporary
    IAM credentials.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序使用AWS SDK访问其他AWS资源时，SDK将调用`AssumeRoleWithWebIdentity`，这是一个AWS **安全令牌服务**（**STS**）API操作，允许应用程序使用受信的Web身份令牌，而不是长期访问密钥或IAM用户，来获取临时的IAM凭证。
- en: '*Figure 9**.3* summarizes these steps:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图9.3*总结了这些步骤：'
- en: '![Figure 9.3 – Overview of IRSA](img/B31108_09_3.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – IRSA概览](img/B31108_09_3.jpg)'
- en: Figure 9.3 – Overview of IRSA
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – IRSA概览
- en: This illustrates how IAM roles are securely assumed by Pods in an Amazon EKS
    cluster using IRSA and the `AssumeRoleWithWebIdentity` ([https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html))
    mechanism. When a Pod associated with an annotated service account is created,
    the Pod Identity webhook running in the EKS control plane mutates the Pod specification
    to mount the projected service account token. The AWS SDK running in the Pod then
    uses that token to call AWS STS using the `AssumeRoleWithWebIdentity` API. STS
    verifies the token against the OIDC provider, checks the IAM role’s trust policy,
    and returns temporary AWS credentials, which the Pod uses to securely access other
    AWS resources.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了如何通过IRSA和`AssumeRoleWithWebIdentity`（[https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html)）机制，安全地由Amazon
    EKS集群中的Pod假设IAM角色。当与注释服务账户关联的Pod被创建时，运行在EKS控制平面中的Pod身份webhook会修改Pod规格，以挂载投影的服务账户令牌。然后，运行在Pod中的AWS
    SDK使用该令牌调用AWS STS，使用`AssumeRoleWithWebIdentity` API。STS通过OIDC提供程序验证令牌，检查IAM角色的信任策略，并返回临时AWS凭证，Pod使用这些凭证安全地访问其他AWS资源。
- en: Next, we will cover the recently introduced **EKS Pod Identity** feature, which
    further simplifies the IAM permission process.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍最近推出的**EKS Pod身份**功能，它进一步简化了IAM权限过程。
- en: Amazon EKS Pod Identity
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Amazon EKS Pod身份
- en: 'In 2023, AWS introduced the EKS Pod Identity feature as an evolution to IRSA
    to streamline the experience of setting up IAM permissions for K8s applications.
    It removed a lot of underlying complexities of IRSA, such as setting up OIDC providers
    in IAM, complex trust policies, annotating service accounts, and so on. EKS Pod
    Identity introduced new APIs to create Pod Identity associations between K8s service
    accounts and IAM roles, thus eliminating the need for OIDC providers, service
    account annotations, and so on. The high-level steps involved are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2023 年，AWS 引入了 EKS Pod Identity 功能，作为 IRSA 的演变，旨在简化为 K8s 应用设置 IAM 权限的体验。它去除了许多
    IRSA 的底层复杂性，如在 IAM 中设置 OIDC 提供者、复杂的信任策略、标注服务账户等。EKS Pod Identity 引入了新的 API 来创建
    K8s 服务账户与 IAM 角色之间的 Pod Identity 关联，从而无需 OIDC 提供者、服务账户注释等。涉及的高层步骤如下：
- en: Install `eks-pod-identity-agent deamonset` on the EKS cluster.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 EKS 集群上安装 `eks-pod-identity-agent deamonset`。
- en: Create fine-grained IAM policies granting necessary permissions on AWS services.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建细粒度的 IAM 策略，为 AWS 服务授予必要的权限。
- en: 'Create an IAM role with the permission policies from *Step 2* and a trust policy
    for the EKS Pod Identity principal to the assume role:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 IAM 角色，授予来自*步骤 2*的权限策略，并为 EKS Pod Identity 主体创建一个信任策略，以便它可以假设该角色：
- en: '[PRE7]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a Pod Identity association between the IAM role and the K8s service
    account:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IAM 角色和 K8s 服务账户之间创建 Pod Identity 关联：
- en: '[PRE8]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Deploy the K8s application using the service account:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用服务账户部署 K8s 应用：
- en: '[PRE9]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: EKS Pod Identity also introduced support for session tags to the temporary credentials
    assigned to each Pod, including attributes such as the cluster name, namespace,
    Pod UID, service account name, and so on. These tags allow administrators to configure
    a single IAM role that can be used across various service accounts, granting or
    restricting access to AWS resources based on matching tags. By incorporating role
    session tags, organizations can create more granular security boundaries between
    clusters and workloads, while continuing to leverage the same IAM roles and policies.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: EKS Pod Identity 还支持为分配给每个 Pod 的临时凭证引入会话标签，包括集群名称、命名空间、Pod UID、服务账户名称等属性。这些标签使得管理员能够配置一个可跨多个服务账户使用的
    IAM 角色，根据匹配的标签授予或限制对 AWS 资源的访问。通过引入角色会话标签，组织可以在集群和工作负载之间创建更精细的安全边界，同时继续使用相同的 IAM
    角色和策略。
- en: Secure model endpoints
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护模型端点
- en: Before we talk about securing GenAI model endpoints, we should secure the fine-tuned
    model artifacts, model weights, and so on. After the fine-tuning process, you
    can securely store those model artifacts in object store services such as Amazon
    S3 using appropriate access controls, or package them along with the container
    image and push it to the container registry. You can securely source the credentials
    using one of the previously discussed approaches (IRSA or EKS Pod Identity) to
    access the respective AWS services.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论如何保护 GenAI 模型端点之前，我们应该先保护好微调后的模型工件、模型权重等。微调过程完成后，您可以通过适当的访问控制将这些模型工件安全地存储在对象存储服务（如
    Amazon S3）中，或者将它们与容器镜像一起打包并推送到容器注册表。您可以使用之前讨论的方式（IRSA 或 EKS Pod Identity）安全地获取凭证，以访问相应的
    AWS 服务。
- en: 'Once the models are built, `443` and deploy TLS certificates from ACM on the
    K8s load balancer service:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 构建好模型后，`443` 并在 K8s 负载均衡服务上部署 ACM 的 TLS 证书：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, you can apply the annotations to a K8s Ingress resource backed by
    the AWS ALB to create an HTTPS listener secured with a TLS certificate from ACM,
    as shown in the following code snippet:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以将注释应用于由 AWS ALB 支持的 K8s Ingress 资源，创建一个受 ACM TLS 证书保护的 HTTPS 监听器，如下所示的代码片段所示：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Additionally, you can attach **AWS WAF** ([https://aws.amazon.com/waf/](https://aws.amazon.com/waf/))
    to the AWS ALB (K8s Ingress resource) to protect the model endpoints against common
    attack vectors, including injection attacks, malicious content inputs, and so
    on. You can use the following annotation to attach AWS WAF with AWS ALB.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以将 **AWS WAF**（[https://aws.amazon.com/waf/](https://aws.amazon.com/waf/)）附加到
    AWS ALB（K8s Ingress 资源）上，以保护模型端点免受常见攻击向量的侵害，包括注入攻击、恶意内容输入等。您可以使用以下注释将 AWS WAF
    与 AWS ALB 关联。
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this section, we explored best practices for deploying GenAI workloads in
    K8s. We looked at the IRSA and EKS Pod Identity features to securely provide temporary
    IAM credentials to K8s applications. This is particularly important for GenAI
    applications, as it ensures secure, least-privilege access to sensitive training
    data or model artifacts stored in Amazon S3\. We also looked at techniques for
    protecting model endpoints, including enforcing TLS for encrypted communications
    and integrating a WAF to defend against common attack vectors. In the next section,
    we will implement these security best practices in our chatbot application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了在 K8s 中部署 GenAI 工作负载的最佳实践。我们研究了 IRSA 和 EKS Pod 身份功能，以安全地为 K8s 应用程序提供临时
    IAM 凭证。对于 GenAI 应用程序来说，这一点尤为重要，因为它确保了对存储在 Amazon S3 中的敏感训练数据或模型工件的安全、最小权限访问。我们还探讨了保护模型端点的技术，包括强制
    TLS 加密通信并集成 WAF 以防范常见攻击向量。在下一节中，我们将在我们的聊天机器人应用程序中实现这些安全最佳实践。
- en: Implementing security best practices in a chatbot app
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在聊天机器人应用中实施安全最佳实践
- en: 'In this section, we will implement the security best practices discussed in
    the previous sections in our e-commerce chatbot application. We already implemented
    some of these in previous chapters, such as IRSA in [*Chapter 5*](B31108_05.xhtml#_idTextAnchor062),
    and K8s network policies in [*Chapter 8*](B31108_08.xhtml#_idTextAnchor097). Let’s
    get started:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将会在我们的电子商务聊天机器人应用程序中实现前面讨论的安全最佳实践。我们已经在前几章实现了其中一些，例如 [*第 5 章*](B31108_05.xhtml#_idTextAnchor062)
    中的 IRSA 和 [*第 8 章*](B31108_08.xhtml#_idTextAnchor097) 中的 K8s 网络策略。让我们开始吧：
- en: '**Container image encryption**: Amazon ECR stores container images in Amazon
    S3 buckets that ECR manages and, by default, uses the server-side encryption feature
    of S3 to encrypt the data at rest. It uses the **Advanced Encryption Standard**
    (**AES**) encryption algorithm using encryption keys managed by the S3 service.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器镜像加密**：Amazon ECR 将容器镜像存储在 Amazon S3 桶中，由 ECR 管理，默认情况下，使用 S3 的服务器端加密功能对数据进行静态加密。它使用
    **高级加密标准**（**AES**）加密算法，使用由 S3 服务管理的加密密钥。'
- en: 'We can verify this on the ECR repositories we created using the following AWS
    command:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用以下 AWS 命令在我们创建的 ECR 仓库中验证此操作：
- en: '[PRE13]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: resource "aws_kms_key" "ecr_kms_key" {
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: resource "aws_kms_key" "ecr_kms_key" {
- en: deletion_window_in_days = 7
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: deletion_window_in_days = 7
- en: enable_key_rotation = true
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: enable_key_rotation = true
- en: '}'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: resource "aws_kms_alias" "ecr_kms_alias" {
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: resource "aws_kms_alias" "ecr_kms_alias" {
- en: name = "alias/ecr-kms-key"
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: name = "alias/ecr-kms-key"
- en: target_key_id = aws_kms_key.ecr_kms_key.key_id
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: target_key_id = aws_kms_key.ecr_kms_key.key_id
- en: '}'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: resource "aws_ecr_repository" "sample-app-repo" {
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: resource "aws_ecr_repository" "sample-app-repo" {
- en: name = "sample-app-repo"
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: name = "sample-app-repo"
- en: encryption_configuration {
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: encryption_configuration {
- en: encryption_type = "KMS"
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: encryption_type = "KMS"
- en: kms_key  = aws_kms_key.ecr_kms_key.arn
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: kms_key  = aws_kms_key.ecr_kms_key.arn
- en: '}'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: 'image_tag_mutability attribute to IMMUTABLE in the ecr.tf file, as shown in
    the following code snippet:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 ecr.tf 文件中将 image_tag_mutability 属性设置为 IMMUTABLE，如下所示代码片段：
- en: '[PRE14]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`ecr.tf` file, which enables enhanced scanning on the `my-llama-finetuned`
    ECR repository in our AWS account. Alternatively, you can download the source
    code from the GitHub repository at [https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/ecr.tf](https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/ecr.tf)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ecr.tf` 文件，它在我们 AWS 账户中的 `my-llama-finetuned` ECR 仓库上启用了增强扫描功能。或者，您也可以从 GitHub
    仓库下载源代码：[https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/ecr.tf](https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/ecr.tf)'
- en: 'This configuration ensures that images are scanned both when they are pushed
    and continuously thereafter for any new vulnerabilities:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此配置确保镜像在推送时以及随后持续扫描，以检测任何新漏洞：
- en: '[PRE16]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the following Terraform commands to apply this configuration in your AWS
    account:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行以下 Terraform 命令以在您的 AWS 账户中应用此配置：
- en: '[PRE17]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Host security**: Harden the security of the worker nodes by using a purpose-built
    operation system such as Bottlerocket. This includes only the essential software
    required to run containers and ensures that the underlying software is always
    secure. It also improves the node start-up time from ~1.5 minutes to 20 seconds,
    based on a customer case study ([https://aws.amazon.com/bottlerocket/](https://aws.amazon.com/bottlerocket/)).
    Additionally, configure the worker nodes to use the latest version of IMDSv2 ([https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html))
    to limit access to sensitive metadata. The following code snippet highlights the
    use of Bottlerocket EKS AMIs and IMDSv2; the complete source code is available
    in the GitHub repository at [https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/eks.tf](https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/eks.tf):'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机安全**：通过使用专门设计的操作系统（如 Bottlerocket）来增强工作节点的安全性。这只包括运行容器所需的必要软件，并确保底层软件始终保持安全。根据客户案例研究，它还将节点启动时间从约
    1.5 分钟缩短到 20 秒（链接：[https://aws.amazon.com/bottlerocket/](https://aws.amazon.com/bottlerocket/)）。此外，配置工作节点以使用最新版本的
    IMDSv2（链接：[https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html)），限制对敏感元数据的访问。以下代码片段展示了如何使用
    Bottlerocket EKS AMI 和 IMDSv2；完整的源代码可以在 GitHub 仓库中找到，链接：[https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/eks.tf](https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/eks.tf)：'
- en: '[PRE18]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**K8s Pod Security Standards**: Implementing K8s Pod Security Standards is
    critical to ensuring your workloads operate with the least privilege, thereby
    reducing the risk of privilege escalation and container escapes. Since our chatbot
    application is deployed in the default namespace, we can use the following command
    to enforce a baseline security policy while receiving warnings for more restrictive
    settings:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**K8s Pod 安全标准**：实施 K8s Pod 安全标准对确保你的工作负载以最小权限运行至关重要，从而降低特权提升和容器逃逸的风险。由于我们的聊天机器人应用部署在默认命名空间中，我们可以使用以下命令来强制执行基础安全策略，同时针对更严格的设置接收警告：'
- en: '[PRE19]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Test the enforced policy by attempting to run a pod with privileged settings
    using the following command:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下命令通过尝试运行具有特权设置的 pod 来测试强制执行的策略：
- en: '[PRE20]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: $ export HUGGING_FACE_TOKEN=<<Your Token goes here>>
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ export HUGGING_FACE_TOKEN=<<你的令牌放这里>>
- en: 'secrets-store-csi-driver and secrets-store-csi-provider-aws add-ons in the
    EKS cluster to integrate external secret stores with K8s via a secrets-store-csi-provider-aws
    integrates AWS Secrets Manager and AWS Systems Manager Parameter Store with Kubernetes.
    To set up these add-ons in your EKS cluster, download the addons.tf file from
    the GitHub repository at https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/addons.tf
    and run the following commands:'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 EKS 集群中使用 secrets-store-csi-driver 和 secrets-store-csi-provider-aws 插件，通过
    secrets-store-csi-provider-aws 集成 AWS Secrets Manager 和 AWS Systems Manager Parameter
    Store 与 Kubernetes 集成，从而将外部秘密存储与 K8s 集成。要在 EKS 集群中设置这些插件，请从 GitHub 仓库下载 addons.tf
    文件，链接：[https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/addons.tf](https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/addons.tf)，然后运行以下命令：
- en: '[PRE21]'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: $ kubectl get ds -n kube-system
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ kubectl get ds -n kube-system
- en: NAME
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: NAME
- en: secrets-store-csi-driver
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: secrets-store-csi-driver
- en: 'my-llama-finetuned K8s Pod can receive temporary IAM credentials using the
    EKS Pod Identity feature. To set up these resources, download the iam.tf file
    from the GitHub repository at https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/iam.tf
    and run the following commands:'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: my-llama-finetuned K8s Pod 可以使用 EKS Pod 身份特性接收临时 IAM 凭证。要设置这些资源，请从 GitHub 仓库下载
    iam.tf 文件，链接：[https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/iam.tf](https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/iam.tf)，然后运行以下命令：
- en: '[PRE22]'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'my-llama-finetuned application using the my-llama-sa service account. This
    approach securely injects the AWS Secrets Manager secret into your application
    container without exposing it in the Kubernetes manifest. To redeploy the app,
    download the finetuned-inf-deploy.yaml file from the GitHub repository at https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/inference/finetuned-inf-deploy.yaml.
    Then, update the ECR image name with your own and execute the following command:'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: my-llama-finetuned 应用程序使用 my-llama-sa 服务账户。这种方法可以安全地将 AWS Secrets Manager 的秘密注入到应用程序容器中，而不会在
    Kubernetes 清单中暴露。要重新部署该应用程序，请从 GitHub 仓库下载 finetuned-inf-deploy.yaml 文件，链接为 https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/inference/finetuned-inf-deploy.yaml。然后，使用您自己的
    ECR 镜像名称更新该文件，并执行以下命令：
- en: '[PRE23]'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this section, we implemented multiple security best practices in our chatbot
    application running on EKS. We ensured ECR image immutability to prevent image
    tag overwrites, hardened host security using Bottlerocket AMIs, enabled IMDSv2,
    and applied Pod Security Standards to enforce least privilege execution. Additionally,
    we implemented encryption at rest, integrated vulnerability scanning to our container
    images in Amazon ECR, and enhanced Kubernetes secrets management through encrypted
    secrets and external solutions such as AWS Secrets Manager via `secrets-store-csi-driver`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们在运行于 EKS 的聊天机器人应用程序中实施了多项安全最佳实践。我们确保了 ECR 镜像不可变性，以防止镜像标签被覆盖，使用 Bottlerocket
    AMI 强化主机安全，启用了 IMDSv2，并应用了 Pod 安全标准来强制执行最小权限执行。此外，我们还实施了静态数据加密，将漏洞扫描集成到 Amazon
    ECR 中的容器镜像，并通过加密的秘密和 AWS Secrets Manager 等外部解决方案增强了 Kubernetes 的秘密管理，后者通过 `secrets-store-csi-driver`
    实现。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the security best practices for deploying applications
    on K8s, with a focus on defense in depth and securing key aspects of the container
    ecosystem, including supply chain, host, network, runtime, and secret management.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们讨论了在 K8s 上部署应用程序的安全最佳实践，重点介绍了深度防御和容器生态系统的关键安全方面，包括供应链、安全主机、网络、运行时和密钥管理。
- en: Defense in depth is a concept that involves multiple layers of security to safeguard
    against different attack vectors.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 深度防御是一种安全理念，涉及多层次的安全措施，以防范不同的攻击向量。
- en: Containers, being portable, introduce unique risks that require proactive measures
    at every lifecycle stage, from build to runtime. Supply chain security emphasizes
    securing container images during the build, test, and storage phases. Host security
    focuses on safeguarding the underlying server hosting containers. Runtime security
    ensures secure container operation by limiting privileges, enforcing resource
    limits, and using tools such as Falco for anomaly detection. Network security
    leverages namespaces, network policies, and service meshes such as Istio for segmentation
    and encryption. Secret management is essential for securely handling sensitive
    information. IRSA and EKS Pod Identity features can be used to securely provide
    temporary IAM credentials to K8s applications. GenAI workloads can leverage these
    features to securely access sensitive training data or export model artifacts
    in Amazon S3\. GenAI model endpoints can be protected against common vectors using
    WAF solutions and enforcing TLS for encrypted communications. By integrating these
    best practices, K8s deployments can achieve robust security against evolving threats.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 容器由于其可移植性，带来了独特的风险，需要在每个生命周期阶段采取主动措施，从构建到运行时。供应链安全强调在构建、测试和存储阶段保护容器镜像。主机安全专注于保护托管容器的底层服务器。运行时安全通过限制权限、强制执行资源限制，并使用如
    Falco 这样的工具进行异常检测，确保容器的安全操作。网络安全利用命名空间、网络策略以及像 Istio 这样的服务网格进行隔离和加密。密钥管理对于安全处理敏感信息至关重要。IRSA
    和 EKS Pod 身份功能可以安全地为 K8s 应用程序提供临时 IAM 凭证。GenAI 工作负载可以利用这些功能安全地访问敏感的训练数据或将模型工件导出到
    Amazon S3。GenAI 模型端点可以通过 WAF 解决方案和强制执行 TLS 来防止常见攻击向量，并确保加密通信。通过集成这些最佳实践，K8s 部署可以在应对不断发展的威胁时实现强大的安全性。
- en: This chapter focused on K8s security best practices; in the next chapter, we
    will start diving into GPU resource optimization for K8s, which is one of the
    most expensive resources for GenAI applications.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本章集中讨论了 K8s 安全最佳实践；在下一章中，我们将开始深入探讨 K8s 的 GPU 资源优化，这是 GenAI 应用程序中最昂贵的资源之一。
