- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enabling Secure Inter-Service Communication with Tanzu Service Mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise software has changed significantly in the last few years. Some of
    you reading this may remember when most software was written as a single monolith
    by a small team of developers. The application had to be deployed, updated, started,
    stopped, and scaled as a single unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'As software began to evolve in the early to mid-2000s, demands on software
    and software developers started to grow along four axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time to value**: Teams were expected to deliver bug fixes, improvements,
    and new value-delivering features on ever-shrinking timelines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elasticity**: Teams needed to scale “hot” services independently and deploy
    individual features without having to build, test, and deploy the entire monolith
    all at once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault-tolerance**: When an individual service failed or started to degrade,
    it shouldn’t affect other services, and the system should be able to work around
    the problematic service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Programming languages and frameworks**: The technology landscape began to
    move too quickly for monolithic applications to keep up. Developers felt stifled
    and constrained by the older, less agile technology.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These demands led to the near-universal adoption of design patterns such as
    microservices ([https://en.wikipedia.org/wiki/Microservices](https://en.wikipedia.org/wiki/Microservices)).
    Furthermore, as microservices came to predominate software development and teams
    became more independent and autonomous, new architecture paradigms began to emerge,
    specifically hybrid and multi-cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hybrid cloud**: This refers to deploying apps consisting of legacy VMs, Kubernetes
    services, serverless functions, and possibly other technologies such as **Platform-as-a-Service**
    (**PaaS**) across an on-premises data center and the public cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-cloud**: This refers to deploying an application across multiple **Virtual
    Private Clouds** (**VPCs**) across one or more cloud providers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Google has some interesting material on these architectures here: [https://cloud.google.com/architecture/hybrid-and-multi-cloud-patterns-and-practices](https://cloud.google.com/architecture/hybrid-and-multi-cloud-patterns-and-practices).'
  prefs: []
  type: TYPE_NORMAL
- en: For reasons we’ll discuss shortly, Tanzu Service Mesh is the ideal tool for
    teams tasked with securely and consistently delivering fixes and features while
    operating in complex modern environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why Tanzu Service Mesh?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Features and capabilities of Tanzu Service Mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get started with Tanzu Service Mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to perform key day-2 operations on Tanzu Service Mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GSLB with NSX-T Advanced Load Balancer and Tanzu Service Mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, let’s jump in and dive deep into why a team might need Tanzu Service
    Mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Why Tanzu Service Mesh?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tanzu Service Mesh is a tool built expressly to enable the meaningful business
    outcomes we just described (fast time to value, elasticity, fault tolerance, and
    so on) while operating in the context of a hybrid or multi-cloud environment.
    Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: How do we deliver a faster time to value when we have to update 100 dependent
    services whenever a core service moves from one cloud to another?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we realize the full value of an elastic system if every cloud has a different
    process and toolset for deploying and scaling?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same goes for detecting and remediating faults. Are we fully benefitting
    from a resilient system if we have to maintain different tools for monitoring,
    alerting, and remediating across clouds?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s say that you were to invest the time and effort to centralize tooling
    and monitoring to work across multiple clouds. How do you keep your tech up to
    date as languages, frameworks, and technologies continue their inexorable forward
    march? Is the continued ongoing investment worthwhile?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tanzu Service Mesh sits squarely in the middle of this problem space, bringing
    the benefits of large, distributed microservice architectures to multi and hybrid
    cloud architectures. It may help to visualize the problem space: delivering business
    outcomes across clouds and on-premises, across multiple technologies and frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.1 – Business outcomes across clouds and technologies](img/B18145_11_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Business outcomes across clouds and technologies
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve scratched the surface of why you would want to use this tool,
    let’s dive deep into the features and capabilities that enable those *whys*.
  prefs: []
  type: TYPE_NORMAL
- en: Features and capabilities of Tanzu Service Mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are eight concrete features that Tanzu Service Mesh provides. These features
    enable the specific capabilities necessary to accomplish what we described in
    the previous section: how we deliver tangible outcomes in a multi or hybrid cloud
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Out-of-the-box enablement of hybrid and multi-cloud architectures**: With
    a few clicks in the UI or API calls, you can onboard multiple different clouds
    and architectures (Kubernetes, legacy, serverless) into a single virtual space
    where you can quickly and easily stand up any of the various industry standard
    multi-cloud or hybrid cloud architectures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Effortlessly move apps between clouds**: You can deploy your app in a different
    VPC, a different platform (VMs versus Kubernetes), or even an entirely different
    cloud provider without affecting dependent apps and services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automatic high availability**: You can deploy the same service to multiple
    clouds and the service mesh will automatically load balance between them. This
    includes transparently failing over from one cloud to another when the service
    fails in one location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SLO tracking with AutoScaling**: Tanzu Service Mesh allows you to define
    **Service-Level Objectives** (**SLOs**), track your error budget relative to the
    SLOs, and even autoscale services when SLOs aren’t being met.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End-to-end mTLS**: With zero operator effort or toil, Tanzu Service Mesh
    uses sidecars to secure all inter-service traffic in both directions. This allows
    for guaranteed client and server identity, which can be used to further secure
    the services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security policies and auditing**: With bi-directional TLS, client and server
    IDs are cryptographically guaranteed. This allows you to create airtight *allow*
    and *deny* policies that dictate which services can communicate with each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full workload visualization**: Tanzu Service Mesh gives a real-time visualization
    of all the services in the mesh, complete with metrics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tight control over deployments**: Tanzu Service Mesh gives you all the tools
    in the Istio toolbox to control rollouts of a service: traffic shaping, canary
    deploys, A/B testing, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With those features, I hope you now understand why you would use Tanzu Service
    Mesh. Now, let’s get our hands dirty and get started with it.
  prefs: []
  type: TYPE_NORMAL
- en: How to get started with Tanzu Service Mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tanzu Service Mesh consists of controllers that install into your Kubernetes
    clusters as well as a central SaaS global control plane. The SaaS control plane
    does a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: Manages installation of Tanzu Service Mesh components onto Kubernetes clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically updates those components as necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sends global configuration down to those controllers (for example, the location
    of services on other clusters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manages and deploys policies on the Kubernetes clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathers metrics to enable visualization and SLOs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get started with Tanzu Service Mesh, let’s log into our VMware Cloud Services
    Console and select the **Tanzu Service Mesh** tile from the list of services.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Tanzu Service Mesh is the one product in this book that’s neither free to use
    nor provides a self-service avenue to enable a trial. If you don’t currently have
    a license for Tanzu Service Mesh, you’ll need to reach out to your VMware Account
    Executive to set up a trial. If that’s not possible, much of what we’ll cover
    in this section is also included in a free VMware hands-on lab for Tanzu Service
    Mesh located here: [https://labs.hol.vmware.com/HOL/catalogs/lab/8509](https://labs.hol.vmware.com/HOL/catalogs/lab/8509).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The VMware Cloud Services Console is located here: https://console.cloud.vmware.com/csp/gateway/portal/#/consumer/services/organization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Launch Service** from the **Tanzu Service Mesh** tile, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.2 – Launching Tanzu Service Mesh](img/B18145_11_02.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Launching Tanzu Service Mesh
  prefs: []
  type: TYPE_NORMAL
- en: Once we launch the Tanzu Service Mesh app, we’re ready to onboard our Kubernetes
    clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Onboarding Kubernetes clusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example requires two separate clusters with the ability to create `LoadBalancer`
    services. You can refer to the *Appendix* to explore your options for standing
    up Kubernetes clusters. For this exercise, I’d strongly recommend using one of
    the public cloud offerings (EKS, AKS, GKE, or TKG on the public cloud) simply
    because they make it very easy to stand up `LoadBalancer` services, which are
    a must-have for this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to onboard your clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **New Workflow** | **Onboard** **New Cluster**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog, give your cluster a name (for example, `cluster-1`) and click
    **Generate Security Token**. This will generate some credentials that your Kubernetes
    cluster will use to connect to the SaaS control plane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From your terminal, make sure that you have kubectl pointed to your first cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, copy each of the kubectl commands from the UI into your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first command installs the control plane components. These components will
    turn around and install Istio locally, as well as check in with the global SaaS
    control plane to check for updates.
  prefs: []
  type: TYPE_NORMAL
- en: The second command creates a Kubernetes secret that will be used to authenticate
    to the global SaaS control plane.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, click the green **Install Tanzu Service Mesh** button. That will instruct
    the components running on your Kubernetes cluster to pull down and install the
    Istio data plane components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat this entire process for your second Kubernetes cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point, you should have Tanzu Service Mesh up and running on both of
    your clusters and they should be visible in the Tanzu Service Mesh UI in the **Clusters**
    pane. You should see something like what’s shown in the following screenshot.
    You’ll notice that we have four nodes on each cluster but no services yet:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.3 – Two clusters onboarded](img/B18145_11_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Two clusters onboarded
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll need to create a namespace in each cluster that we’ll use as our
    Global Namespace in Tanzu Service Mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Tanzu Service Mesh Global Namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `acme` in each cluster. Now, all the services in the `acme` namespace on
    cluster 1 can see all the services in the `acme` namespace on cluster 2, and vice
    versa. Here’s how we go about creating the GNS across our two onboarded clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and create the namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must create the logical GNS in the Tanzu Service Mesh UI. Here are
    the steps at a high level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `acme-gns`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a domain for the GNS. This will be how services find each other, so I’d
    recommend against something that may need to resolve via DNS (for example, `acme.com`,
    `mygns.net`). Instead, I chose to use `devsecops-acme.gns` as something that won’t
    be confused with a public domain name. For future steps to work without additional
    changes, I’d recommend using the same domain for your GNS.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see something like the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.4 – Naming and selecting a unique domain](img/B18145_11_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Naming and selecting a unique domain
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll need to map the `acme` namespace within each of our two clusters
    to this GNS on the **Namespace Mapping** screen, as per the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.5 – Global Namespace Mapping](img/B18145_11_05.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Global Namespace Mapping
  prefs: []
  type: TYPE_NORMAL
- en: 'For the remaining screens, you can accept the defaults. In the end, you should
    see your GNS in the **GNS Overview** tab in the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.6 – New GNS](img/B18145_11_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – New GNS
  prefs: []
  type: TYPE_NORMAL
- en: Now that our GNS is up and running, it’s time to deploy some services to our
    clusters that will communicate over the GNS.
  prefs: []
  type: TYPE_NORMAL
- en: Installing services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The files in the following steps will install a simple microservice-based application
    called *Acme Fitness*. If you chose `devsecops-acme.gns` as your domain, you can
    deploy these files as-is; otherwise, you’ll need to update the internal references
    to reflect your domain name. The manifests can be found here: [https://github.com/PacktPublishing/DevSecOps-in-Practice-with-VMware-Tanzu/tree/main/chapter-12](https://github.com/PacktPublishing/DevSecOps-in-Practice-with-VMware-Tanzu/tree/main/chapter-12):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you’re pointing to your first Kubernetes cluster and deploying the
    YAML manifest for `cluster-1`. It’s important to note `-n acme` at the end of
    the commands. You need to explicitly declare that these services are to be deployed
    to the `acme` namespace. This will install a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: Secrets that apps will use to talk to their data services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several data services (MongoDB, Redis, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some microservice-based applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A gateway, which is like a virtual L7 load balancer that tells Tanzu Service
    Mesh where to route certain incoming requests. In our case, this is the only external-facing
    application running on the cluster, so we’ll route all requests coming in from
    outside the cluster to our frontend service, which we have called `shopping`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, switch to `cluster-2` and deploy that manifest. Here are the commands
    I used to deploy the services into both of my Kubernetes clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve installed the services across two clusters, let’s verify that
    the app is up and running. Switch your kubectl context back to the first cluster
    and get the details of the `istio-ingressgateway` service in the `istio-system`
    namespace. If you’re running on EKS, you might get the hostname of a load balancer;
    otherwise, you may see an IPv4 address. Grab the hostname or external IP and plug
    it into your browser using `http`, not `https`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how I got the service. Notice that I’m pointed at the first cluster
    and I’m on EKS, so I’m getting a load balancer hostname as my *external IP*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And here’s what you’d expect to see in the browser. If the yoga mat and water
    bottle images appear, then you know everything is working. The page itself is
    hosted in cluster 1 and the catalog is hosted in cluster 2!
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.7 – Acme Fitness deployed across two clusters](img/B18145_11_07.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Acme Fitness deployed across two clusters
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll need to generate some inter-service traffic so that the Tanzu Service
    Mesh UI can visualize all the connections.
  prefs: []
  type: TYPE_NORMAL
- en: Generating application traffic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some things you can do to make sure that all the services get some
    traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the login button next to the shopping cart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Log in with the following credentials – username: `dwight` password: `vmware1!`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click the **Catalog** link at the top of the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browse to an item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add it to your cart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click the **Shopping** **Cart** button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click **Proceed** **to Checkout**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go through the checkout process. Any 16-digit number will work for a credit
    card number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can return to the GNS screen for our `acme-gns` in the Tanzu Service
    Mesh UI. You should see all the services spread across the two clusters, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.8 – Tanzu Service Mesh service visualization](img/B18145_11_08.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Tanzu Service Mesh service visualization
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you have successfully done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Stood up a new Service Mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Onboarded multiple clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Federated them into a GNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployed a distributed app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verified the app’s functionality and cross-cluster communications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s an impressive list for day one. Now, let’s move on to some operations
    you may consider after you’ve accomplished your day-1 checklist.
  prefs: []
  type: TYPE_NORMAL
- en: How to perform key day-2 operations on Tanzu Service Mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have a distributed application successfully working across
    two Kubernetes clusters. If you were doing this in a real production environment,
    there are some *day-2* concerns you’d want to address. For example, it’s great
    that the catalog service can run on a separate cluster, but what if that cluster
    goes down? How could we load balance across instances on multiple clusters?
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we’re living in a world where deployment, upkeep, measuring, and
    monitoring of services are often the responsibility of **Site Reliability Engineers**
    (**SREs**). If you were the SRE for Acme Fitness, you would have already identified
    **Service-Level Indicators** (**SLIs**) and defined SLOs for your services. Tanzu
    Service Mesh greatly simplifies this by allowing you to define your SLIs and SLOs
    right in the Tanzu Service Mesh UI and measure how your services are meeting those
    SLOs using real-time metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling service high availability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let’s address making a service highly available. In our example app,
    most of the services are on `cluster-1`, while the catalog and its data store
    are on `cluster-2`. Tanzu Service Mesh lets us stand up additional instances of
    a service across multiple clusters and automatically load balances between all
    the instances as they come online.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, let’s just deploy another instance of the catalog service
    onto `cluster-1`. We can do that very easily by targeting `cluster-1` and applying
    the `cluster-2` deployment manifest, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we go back to the app and access the catalog a few times, we should
    see a visualization like the one shown in the following screenshot. Notice how
    Tanzu Service Mesh automatically load balances between the two catalog instances:
    one in `cluster-1` and the other in `cluster-2`:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.9 – Automatic load balancing across multiple clusters](img/B18145_11_09.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Automatic load balancing across multiple clusters
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s track some SLOs.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and measuring SLOs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this task, we’ll walk through the desired outcome and the steps we follow
    to achieve that outcome. We’ll show some screenshots along the way so we can double-check
    our work. Then, we’ll talk about what the various fields represent.
  prefs: []
  type: TYPE_NORMAL
- en: Desired outcome
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s say that we’re the SREs for Acme Fitness and we have an SLO for the catalog
    service that it be up and healthy 99.99% of the time, sometimes called *four nines
    uptime*. In our case, we define *healthy* as having 90% of our requests complete
    within 100 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go into the Tanzu Service Mesh UI and define this SLO so that we can have
    Tanzu Service Mesh accurately measure how well we’re meeting this SLO.
  prefs: []
  type: TYPE_NORMAL
- en: Site Reliability Engineering
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re not familiar with the concepts of SREs, SLOs, and SLIs, I’d strongly
    recommend reading the *Site Reliability Engineering* book. You can get an eBook
    or hard copy from the usual sources, or you can read it for free online from the
    Google SRE website: [https://sre.google/](https://sre.google/).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the SLO
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From the Tanzu Service Mesh UI, navigate to **New Workflow** | **New SLO Policy**
    | **Monitored SLO**. This will launch a wizard. You can fill in the first screen’s
    form values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`acme-catalog-health`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GNS` `Policy`, GNS=`acme-gns`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Level Indicators**: p90 Latency is less than 100 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Level Objective**: The service should be healthy 99.99% of the time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click **Next**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the second screen, select the *catalog* service and click next. You could
    choose to apply this SLO to multiple services if you want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you’ll be shown a summary like this one. Notice that it calculates
    the approximate monthly budget of time your service can be outside of the healthy
    range. As the service goes into an unhealthy state over a month, the budget will
    be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.10 – SLO details](img/B18145_11_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – SLO details
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can view your services’ performance relative to their SLOs by navigating
    to **Policies** | **SLOs** and clicking on the name of your SLO. Here’s one I
    set up previously with an unreasonable latency threshold of 5 ms. This was to
    demonstrate what things look like when you don’t meet your error budget:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.11 – SLO in the red](img/B18145_11_11.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – SLO in the red
  prefs: []
  type: TYPE_NORMAL
- en: This shows us that we have an error budget of 4 minutes and 19 seconds for the
    month to be in an unhealthy state, and we’ve already exceeded that budget by just
    over 3 minutes. SLOs are incredibly powerful tools for SREs and they’re very easy
    to set up and maintain in Tanzu Service Mesh. Now, let’s move on to some other
    day-2 tasks that might be of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Other day-2 operations for further research
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To comprehensively cover all the day-2 functionality wrapped up in Tanzu Service
    Mesh would potentially double the length of this book; so, with that in mind,
    here’s a list of some items for further exploration, along with links to the relevant
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Actionable SLOs**: You can configure your SLO to perform auto-healing actions
    when an SLI falls out of range. For example, when latency gets too high, Tanzu
    Service Mesh can autoscale the service to better handle the load: [https://docs.vmware.com/en/VMware-Tanzu-Service-Mesh/services/slos-with-tsm/GUID-1B9A2D61-D264-44FB-8A06-40277AD42A8E.html](https://docs.vmware.com/en/VMware-Tanzu-Service-Mesh/services/slos-with-tsm/GUID-1B9A2D61-D264-44FB-8A06-40277AD42A8E.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Onboard some External Services**: Some services live outside of Kubernetes
    but need to participate in the mesh: [https://docs.vmware.com/en/VMware-Tanzu-Service-Mesh/services/using-tanzu-service-mesh-guide/GUID-F7DC3814-0C3B-42E8-94A1-64B4B182D783.html](https://docs.vmware.com/en/VMware-Tanzu-Service-Mesh/services/using-tanzu-service-mesh-guide/GUID-F7DC3814-0C3B-42E8-94A1-64B4B182D783.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create a Public Service**: This is a service that is reachable from the internet
    or a network outside the scope of the service mesh, such as an on-premises corporate
    network: [https://docs.vmware.com/en/VMware-Tanzu-Service-Mesh/services/using-tanzu-service-mesh-guide/GUID-58A3FA7C-4EFC-44B2-B37B-D2152CB16359.html](https://docs.vmware.com/en/VMware-Tanzu-Service-Mesh/services/using-tanzu-service-mesh-guide/GUID-58A3FA7C-4EFC-44B2-B37B-D2152CB16359.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve thoroughly covered some day-2 tasks, let’s dive deep into one
    particularly important one, **Global Server Load** **Balancing** (**GSLB**).
  prefs: []
  type: TYPE_NORMAL
- en: GSLB with NSX-T Advanced Load Balancer and Tanzu Service Mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One particular day-2 task that is worthy of its own section is implementing
    GSLB with Tanzu Service Mesh and NSX Advanced Load Balancer.
  prefs: []
  type: TYPE_NORMAL
- en: NSX Advanced Load Balancer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**NSX Advanced Load Balancer** (**NSX-ALB**) is a product that, while not technically
    part of the Tanzu portfolio, complements it very well. You can learn more about
    it, especially as it pertains to GSLB, here: https://avinetworks.com/docs/20.1/gslb-architecture-terminology-object-model/#gslbsites.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, NSX-ALB is a powerful software load balancer that’s completely API-driven,
    allowing for tight integrations with other API-driven technologies such as Kubernetes
    or Tanzu Service Mesh. In addition to enabling the usual functions of an enterprise
    load balancer such as VIPs, traffic policies, and WAF, it also provides a robust
    DNS implementation, which makes it especially useful for GSLB. The following is
    a rough diagram of how Tanzu Service Mesh and NSX-ALB work alongside your corporate
    DNS (or public DNS) to provide access to services across data centers, multiple
    regions, and different cloud providers:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF1.12 – NSX Advanced Load Balancer and Tanzu Service Mesh](img/B18145_11_12.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – NSX Advanced Load Balancer and Tanzu Service Mesh
  prefs: []
  type: TYPE_NORMAL
- en: Before we can fully understand how Tanzu Service Mesh works with NSX-ALB’s GSLB,
    let’s quickly describe how NSX-ALB does GSLB on its own.
  prefs: []
  type: TYPE_NORMAL
- en: Detour – GSLB without Tanzu Service Mesh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NSX ALB enables GSLB by implementing a DNS that will return the IP of a working
    instance of the service. Here’s the sequence of events:'
  prefs: []
  type: TYPE_NORMAL
- en: The client asks their local DNS server for an IP address for `shopping.gslb.acme.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The local DNS forwards to the authoritative DNS server for `gslb.acme.com`,
    which lives in the New York data center.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The authoritative DNS server, depending on the GSLB load balancing strategy
    and the health of the service instances, will return one of three IP addresses:
    the instance in the New York data center, the instance in the London data center,
    or the instance in AWS Oregon. Let’s say it returns `20.30.40.50`, which is the
    IP address of the NSX ALB Service Engines in the New York data center.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client makes an HTTPS request to `20.30.40.50` with an SNI header of `shopping.gslb.acme.com.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The NSX ALB Service Engine knows that requests with that particular SNI get
    routed to the `shopping` service in the `acme` namespace in the Kubernetes cluster
    running locally in the data center.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client successfully orders his yoga mat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s layer in Tanzu Service Mesh.
  prefs: []
  type: TYPE_NORMAL
- en: GSLB with NSX-ALB and Tanzu Service Mesh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything from the previous section still applies, but rather than an operator
    manually setting up GSLB for the `shopping` service, she registers it in the service
    mesh as a `public` service ([https://docs.vmware.com/en/VMware-Tanzu-Service-Mesh/services/using-tanzu-service-mesh-guide/GUID-58A3FA7C-4EFC-44B2-B37B-D2152CB16359.html](https://docs.vmware.com/en/VMware-Tanzu-Service-Mesh/services/using-tanzu-service-mesh-guide/GUID-58A3FA7C-4EFC-44B2-B37B-D2152CB16359.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, she integrates Tanzu Service Mesh with her NSX ALB instances. Finally,
    Tanzu Service Mesh automatically begins to configure GSLB. Wherever the `shopping`
    service is deployed in the GNS, Tanzu Service Mesh will configure the GSLB DNS
    resolver to point to a cluster containing that service. You can read about this
    process in detail here: [https://docs.vmware.com/en/VMware-Tanzu-Service-Mesh/services/using-tanzu-service-mesh-guide/GUID-896EA3FA-17EA-49E2-B981-5C9634E45512.html](https://docs.vmware.com/en/VMware-Tanzu-Service-Mesh/services/using-tanzu-service-mesh-guide/GUID-896EA3FA-17EA-49E2-B981-5C9634E45512.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we onboarded onto Tanzu Service Mesh, deployed a real-world
    application, discussed day-2 operations, and even covered GSLB, a very advanced
    topic. In the next chapter, we’ll attempt to put all the pieces together and paint
    a picture of what “good” looks like when using the entire Tanzu portfolio. I hope
    you’ll continue!
  prefs: []
  type: TYPE_NORMAL
