- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service Mesh Observability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distributed systems built using microservice architecture are complex and unpredictable.
    Irrespective of how diligent you have been in writing code, failures, meltdowns,
    memory leaks, and so on are highly likely to happen. The best strategy to handle
    such an incident is to proactively observe systems to identify any failures or
    situations that might lead to failures or any other adverse behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observing systems help you understand system behavior and the underlying causes
    behind faults so that you can confidently troubleshoot issues and analyze the
    effects of potential fixes. In this chapter, you will read about why observability
    is important, how to collect telemetry information from Istio, the different types
    of metrics available and how to fetch them via APIs, and how to enable distributed
    tracing. We will do so by discussing the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding observability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metric scraping using Prometheus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing Istio metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing telemetry using Grafana
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing distributed tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without further delay, let’s start with understanding observability.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The technical prerequisites for this chapter are the same as the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding observability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of **observability** was originally introduced as part of **control
    theory**, which deals with the control of self-regulated dynamic systems. Control
    theory is an abstract concept and has interdisciplinary applications; it basically
    provides a model governing the application of system inputs to drive a system
    to a desired state while maximizing its stability and performance.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Observability in control theory](img/B17989_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Observability in control theory
  prefs: []
  type: TYPE_NORMAL
- en: The observability of a system is a measure of how well we can understand the
    internal state of that system, based on the signals and observation of its external
    outputs. It is then used by controllers to apply compensating control to the system
    to drive it to the desired state. A system is considered observable if it emits
    signals, which the controller can use to determine the system’s status.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of IT, *systems* are software systems, and *controllers* are operators
    who are other software systems or sometimes human operators, such as **site reliability
    engineers** (**SREs**), who rely on measurements provided by observable systems.
    If you want your software systems to be resilient and self-regulated, then it
    is important that all parts of your software systems are also observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another concept to remember is **telemetry data**, which is the data transmitted
    by systems used for the observability of the systems. Usually, they are logs,
    event traces, and metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logs**: These are information emitted by software systems in verbose format.
    Logs are usually the data emitted by an application and are premeditated at the
    time an application is designed. Logs are used heavily by developers to troubleshoot
    code by correlating logs with the code blocks emitting them. Logs can be structured,
    meaning that all log entries follow a specific pattern that makes it easier for
    observability systems to ingest and comprehend them. Logs can also be unstructured,
    which unfortunately is the case for the majority of the logs. Istio generates
    a full record of each request, including source and destination metadata.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traces**: In distributed systems or applications, tracing is the means of
    finding how a request or an activity was processed and executed across multiple
    components. Traces are made up of spans that describe execution/software processing
    within a system. Multiple spans are then put together to provide a trace of a
    request being executed. Traces describe the relationship between various systems
    and how they partnered together to complete a task. For tracing to work in distributed
    systems, it is important to share a context between all systems, and those contexts
    are usually in the form of correlation IDs or something similar, which all participating
    systems can understand and honor. Istio generates distributed trace spans for
    each service, providing details of request flows and interdependency between various
    services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`500` response code. **Saturation** shows how many system resources, such as
    memory, CPU, network, and storage, are utilized by your system. Istio generates
    the metric data for both data and control planes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All this telemetry data is used in conjunction to provide the observability
    of systems. There are various types of open source and commercial software available
    for observing software systems; Istio includes various tools out of the box, which
    we briefly discussed in *Chapter 2*. Prometheus and Grafana are shipped out of
    the box with Istio; in the next section, we will install Prometheus and Grafana
    and configure them to collect Istio’s metrics data.
  prefs: []
  type: TYPE_NORMAL
- en: Metric scraping using Prometheus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Prometheus** is open source system monitoring software, which stores all
    metric information along with the timestamps of when they were recorded. What
    differentiates Prometheus from other monitoring software is its powerful multidimensional
    data model and a powerful query language called **PromQL**. It works by collecting
    data from various targets and then analyzing and crunching it to produce metrics.
    Systems can also implement HTTP endpoints that provide metrics data; these endpoints
    are then called by Prometheus to collect metrics data from the applications. The
    process of gathering metrics data from various HTTP endpoints is also called **scraping**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As illustrated in the following figure, the Istio control plane and data plane
    components expose endpoints that emit metrics, and Prometheus is configured to
    scrape these endpoints to collect metrics data and store it in a time series database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Metric scraping using Prometheus](img/B17989_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Metric scraping using Prometheus
  prefs: []
  type: TYPE_NORMAL
- en: We will describe the process in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Prometheus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Istio already provides a sample installation file available in `/sample/addons/
    prometheus.yaml`, which is good enough as a starting point. We have modified the
    file slightly to cater to applications that support strict mTLS mode only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The changes in our file, `01-prometheus.yaml`, in comparison to the out-of-the-box
    file, are that we have provisioned Istio certificates for Prometheus by injecting
    a sidecar and configuring it to write the certificate to a shared volume, which
    is then mounted onto the Prometheus container. The sidecar is just for mounting
    and managing the certificates and doesn’t intercept any inbound and outbound requests.
    You will find the changes in `Chapter7/01-prometheus.yaml` .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check what has been installed in the `istio-system` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will look at how we can deploy the sample application.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a sample application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s deploy the `sockshop` application with `istio-injection` enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `sockshop/devops/deploy/kubernetes/manifests/00-sock-shop-ns.yaml` with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, deploy the `sockshop` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will configure an Ingress gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, make some calls from the browser to send traffic to the frontend service
    as you’ve been doing in the previous chapters. We will then check some metrics
    scraped by Prometheus to access the dashboard, using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'From the dashboard, we will first check that Prometheus is scraping the metrics.
    We can do so by clicking on **Status** | **Targets** on the Prometheus dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The Prometheus configuration](img/B17989_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – The Prometheus configuration
  prefs: []
  type: TYPE_NORMAL
- en: You will see all targets from which Prometheus is scraping the metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the dashboard, we will fire up a query to get a total request between the
    `istio-` Ingress gateway and the frontend service, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 7.4 – PromQL](img/B17989_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – PromQL
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, the name of the metric is `istio_requests_total`,
    and the fields in curly brackets are known as `istio_requests_total` metric whose
    dimensions are `destination_service`, `response_code`, `source_app`, and `namespace`
    to match the `front-end.sock-shop.svc.cluster.local`, `200`, `istio-ingressgateway`,
    and `sock-shop` values respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In response, we receive a metric count of `51` and other dimensions as part
    of the metric.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make another query to check how many requests to the catalog service
    have been generated from the frontend service, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note in the query how we have provided `reporter` = `"source"`, which means
    we want metrics reported by the frontend Pod.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – PromQL istio_request_total from the frontend to the catalog](img/B17989_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – PromQL istio_request_total from the frontend to the catalog
  prefs: []
  type: TYPE_NORMAL
- en: If you change `reporter = "destination"`, you will see similar metrics but reported
    by the catalog Pod.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.6 – PromQL istio_request_total from the frontend to the catalo\uFEFF\
    gue, reported by the catalog sidecar](img/B17989_07_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – PromQL istio_request_total from the frontend to the catalogue,
    reported by the catalog sidecar
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also check the database connection between the catalog service and the
    MySQL catalog database, using the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 7.7 – PromQL TCP connections between catalogue and catalogue-db](img/B17989_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – PromQL TCP connections between catalogue and catalogue-db
  prefs: []
  type: TYPE_NORMAL
- en: The metric data shows that the catalog service made seven TCP connections.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used default metric configuration. In the next section, we will
    read about how these metrics are configured and how to customize them by adding
    new metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Istio metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Istio provides flexibility to observe metrics other than what comes out of
    the box. This provides flexibility to observe application-specific metrics. With
    that in mind, let’s begin by looking at the `/stats/prometheus` endpoint exposed
    by the sidecar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows sample data returned by this endpoint, which
    is also scraped by Prometheus and is the same data you saw using the dashboard
    in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.8 – Istio metric\uFEFF, dimension\uFEFFs, and value](img/B17989_07_08.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Istio metric, dimensions, and value
  prefs: []
  type: TYPE_NORMAL
- en: 'The metric is organized in the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Metric name**: This is the name of the metric exported by Istio. Out-of-the-box
    Istio generates many metric details, which can be found at [https://istio.io/latest/docs/reference/config/metrics/#metrics](https://istio.io/latest/docs/reference/config/metrics/#metrics).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metric dimensions**: These are the various fields that are part of a metric.
    These fields are called dimensions in the context of Prometheus and labels in
    the context of an Istio metric. Details about standard label parts of Istio metrics
    are available at [https://istio.io/latest/docs/reference/config/metrics/#labels](https://istio.io/latest/docs/reference/config/metrics/#labels).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metric value**: This is the value of the metric and can be a counter, gauge,
    or histogram.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **counter** is used to track the occurrence of an event. Counters are continuously
    increasing values exposed as time series. Some examples of metrics with counter-type
    values are request counts, bytes received, and TCP connections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **gauge** is a snapshot of a measurement at a single point in time. It is
    used to measure metrics such as CPU consumption and memory consumption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the name suggests, **histograms** are used for measuring observations spread
    over a period. They are also the most complex metric to measure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The telemetry component of Istio is implemented by the `proxy-wasm` plugin.
    We will read more about this in *Chapter 9*, but for now, just understand it as
    a means to build extensions for **Envoy**. You can find these filters using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The filters run WebAssembly at different points of request execution and collect
    various metrics. Using the same technique, you can easily customize Istio metrics
    by adding/removing new dimensions. You can also add new metrics or override any
    existing metrics. We will discuss how to achieve this in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dimensions to the Istio metric
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `istio_request_total` metric doesn’t have any dimensions for a request path
    – that is, we cannot count how many requests we are receiving for individual request
    paths. We will configure an EnvoyFilter to include `request.url_path` in the `request_total`
    metric. Please note that `istio_` is a prefix added by Prometheus; the actual
    metric name in the context of Istio is `request_total`.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss EnvoyFilter in *Chapter 9*, so if you want to jump to that chapter
    to understand the various ways of extending Istio, please do so; alternatively,
    you can also read about this filter at https://istio.io/latest/docs/reference/config/networking/envoy-filter/#EnvoyFilter-PatchContext.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following configuration, we have created an EnvoyFilter that is applied
    to frontend Pods, using the condition in `workloadSelector`, in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we apply `configPatch` to `HTTP_FILTER` for inbound traffic flow to the
    sidecar. Other options are `SIDECAR_OUTBOUND` and `GATEWAY`. The patch is applied
    to HTTP connection manager filters and, in particular, the `istio.stats` subfilter;
    this is the filter we discussed in the previous section and is responsible for
    Istio telemetry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that the proxy version, which is 1.16, must match the Istio version you
    have installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will replace the configuration of the `istio.stats` filter with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this configuration, we are modifying the `metrics` field by adding a new
    dimension called `request.url.path` with the same value as the `request.url.path`
    attribute of Envoy. To remove any existing dimension – for example, `response_flag`
    – please use the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, apply the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Istio will not include the newly added `request.url.path` dimension
    for Prometheus; the following annotations need to be applied to include `request.url_path`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the changes to the frontend deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You will now be able to see the new dimension added to the `istio_requests_total`
    metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – The new metric dimension](img/B17989_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – The new metric dimension
  prefs: []
  type: TYPE_NORMAL
- en: You can add any Envoy attributes as a dimension to the metric, and you can find
    the full list of available attributes at [https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Istio metric
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also create a new Istio metric using EnvoyFilter, similar to what you
    used to create custom metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we have created new metrics using `definitions` and
    also added another dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, apply the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also annotate the frontend Pod with `sidecar.istio.io/statsInclusionPrefixes`
    so that the `request_total_bymethod` metric is included for Prometheus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be a good idea to restart the frontend Pod to make sure that the annotation
    is applied. After applying the changes, you can scrape the Prometheus endpoint
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, using the Prometheus dashboard, check that the new metric is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – New metrics](img/B17989_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – New metrics
  prefs: []
  type: TYPE_NORMAL
- en: With this, you should now be able to create a new Istio metric with dimensions,
    as well as updating dimensions for any existing metrics. In the next section,
    we will look at Grafana, which is yet another powerful observability utility.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing telemetry using Grafana
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Grafana** is open source software used for the visualization of telemetry
    data. It provides an easy-to-use and interactive option for visualizing observability
    metrics. Grafana also helps to unify telemetry data from various systems in a
    centralized place, providing a unified view of observability across all your systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Istio installation provides sample manifests for Grafana, located in `samples/addons`.
    Install Grafana using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have installed Grafana, you can open the Grafana dashboard using the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This should open the Grafana dashboard, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.11 – Grafana \uFEFFdashboard](img/B17989_07_11.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Grafana dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Grafana already includes the following dashboards for Istio:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Istio Control Plane Dashboard**: This provides charts showing resource consumption
    by Istio’s control plane components. It also provides metrics on the interaction
    between the control plane and the data plane, including xDS push, errors during
    configuration sync, and conflicts in the configuration between the data plane
    and the control plane.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Istio Mesh Dashboard**: This provides a summary view of the mesh. The dashboard
    provides a summary view of requests, errors, gateways, and policies, as well as
    details about services and their associated latency during request processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Istio Performance Dashboard**: This provides charts that show the resource
    utilization of Istio components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Istio Service and Workload Dashboards**: This provides metrics about the
    request-response for each service and workload. Using this dashboard, you can
    find more granular details about how services and workloads are behaving. You
    can search for a metric based on various dimensions, as discussed in the *Metric
    scraping using* *Prometheus* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Istio Service Dashboard](img/B17989_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Istio Service Dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Another powerful feature of Grafana is **alerting**, where you can create alerts
    based on certain kinds of events. In the following example, we will create one
    such alert:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an alert when `response_code` is not equal to `200`, based on the `istio_request_total`
    metric in the last 10 minutes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Creating alerts in Grafana](img/B17989_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Creating alerts in Grafana
  prefs: []
  type: TYPE_NORMAL
- en: Configure an alert to be raised when the count of a request with a `~=200` response
    code is more than 3 in the past 10 minutes; this is also called the **threshold**.
    We will also configure the frequency of evaluation for this alert and the threshold
    for firing the alert. In the following example, we have set the alert to be evaluated
    every minute but fired after 5 minutes. By adjusting these parameters, we can
    prevent the alert from being fired too soon or too late.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Configuring the threshold to raise an alert](img/B17989_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Configuring the threshold to raise an alert
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you configure the name of the alert rule and where the alert should be
    stored in Grafana:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Adding details about the alert](img/B17989_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – Adding details about the alert
  prefs: []
  type: TYPE_NORMAL
- en: 'After configuring the name of the rule, you configure labels, which are a way
    to associate alerts with notification policies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Alert notifications](img/B17989_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – Alert notifications
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you configure contact points that need to be notified when an alert is
    raised:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.17 – Configure contact points](img/B17989_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17 – Configure contact points
  prefs: []
  type: TYPE_NORMAL
- en: And finally, you create a notification policy, which specifies the contact points
    that will be notified about the alert.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.18 – Configuring a notification policy](img/B17989_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.18 – Configuring a notification policy
  prefs: []
  type: TYPE_NORMAL
- en: 'You finally have your alert configured. Now, go ahead and disable the catalog
    service in `sockshop.com`, make a few requests from the website, and you will
    see the following alert fired in Grafana:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19 – Alerts raised due to a failure caused by catalog service outage](img/B17989_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19 – Alerts raised due to a failure caused by catalog service outage
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw an example of how we can use Grafana to visualize various
    metrics produced by Istio. Grafana provides comprehensive tooling to visualize
    data, which helps in uncovering new opportunities as well as unearthing any issues
    occurring within your system.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing distributed tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Distributed tracing** helps you understand the journey of a request through
    various IT systems. In the context of microservices, distributed tracing helps
    you understand the flow of requests through various microservices, helps you to
    diagnose any issues a request might be encountering, and helps you quickly diagnose
    any failure or performance issues.'
  prefs: []
  type: TYPE_NORMAL
- en: In Istio, you can enable distributed tracing without needing to make any changes
    in application code, provided your application forwards all tracing headers to
    upstream services. Istio supports integrations with various distributed tracing
    systems; Jaeger is one such supported system, which is also provided as an add-on
    with Istio. Istio distributed tracing is built upon Envoy, where tracing information
    is sent directly to the tracing backend from Envoy. The tracing information comprises
    `x-request-id`, `x-b3-trace-id`, `x-b3-span-id`, `x-b3-parent-spanid`, `x-b3-sampled`,
    `x-b3-flags`, and `b3`. These custom headers are created by Envoy for every request
    that flows through Envoy. Envoy forwards these headers to the associated application
    container in the Pod. The application container then needs to ensure that these
    headers are not truncated and, rather, forwarded to any upstream services in the
    mesh. The proxied application then needs to propagate these headers in all outbound
    requests from the application.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about headers at [https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/observability/tracing](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/observability/tracing).
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will learn how to install Jaeger and enable distributed
    tracing for the `sockshop` example.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling distributed tracing with Jaeger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jaeger is open source distributed tracing software, originally developed by
    Uber Technologies and later donated to CNCF. Jaeger is used to monitor and troubleshoot
    microservices-based systems. It is used primarily for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Distributed context propagation and transaction monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice dependency analysis and troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding bottlenecks in distributed architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yuri Shkuro, the creator of Jaeger, published a book called *Mastering Distributor
    Tracing* ([https://www.shkuro.com/books/2019-mastering-distributed-tracing](https://www.shkuro.com/books/2019-mastering-distributed-tracing))
    that explains many aspects of Jaeger design and operations. You can read more
    about Jaeger at [https://www.jaegertracing.io/](https://www.jaegertracing.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will install and configure Jaeger in Istio.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kubernetes manifest file for deploying Jaeger is already available in `samples/addons/jaeger.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This code block installs Jaeger in the `istio-system` namespace. You can open
    the dashboard using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the `sockshop` application wasn’t designed to propagate the
    headers, so for this scenario, we will make use of the `bookinfo` application
    as an example with Istio. But before that, we will deploy the `httpbin` application
    to understand the Zipkin tracing headers injected by Istio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s make a request to `httpbin` and check the response headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the response, note the headers injected by Istio – `x-b3-parentspanid`,
    `x-b3-sampled`, `x-b3-spanid`, and `x-b3-traceid`. These headers are also called
    B3 headers, which are used for trace context propagation across a service boundary:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1` means yes and `0` means prohibited.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**x-b3-traceid**: This is 8 or 16 bytes in length, indicating the overall ID
    of the trace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**x-b3-parentspanid**: This is 8 bytes in length and represents the position
    of the parent operation in the trace tree. Every span will have a parent span
    unless it is the root itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**x-b3-spanid**: This is 8 bytes in length and represents the position of the
    current operation in the trace tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the response from `httpbin`, the request is traversed to the Ingress gateway
    and then to `httpbin`. The B3 headers were injected by Istio as soon as the request
    arrived at the Ingress gateway. The span ID generated by the Ingress gateway is
    `5c0572d9e4ed5415`, which is a parent of the `httpbin` span that has a span ID
    of `743b39197aaca61f`. Both the Ingress gateway and `httpbin` spans will have
    the same trace ID because they are part of the same trace. As the Ingress gateway
    is the root span, it will have no `parentspanid`. In this example, there are only
    two hops and, thus, two spans. If there were more, they all would have generated
    the B3 headers because the value of `x-b3-sampled` is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about these headers at [https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers.html](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you are familiar with `x-b3` headers injected by Istio, let’s deploy
    the sample `bookinfo` application and configure the Ingress. If you have not created
    a `Chapter7` namespace, then please do so with Istio injection enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `Chapter7/bookinfo-gateway.yaml` configures `bookshop.com` as the
    host; we did it so that it can run along with `sock-shop.com`. Once the Ingress
    configuration is deployed, you can access `bookinfo` using the external IP of
    the `istio-ingress` gateway service. Please use `/productpage` as the URI. Go
    ahead and make some requests to the `bookinfo` app, after which you can check
    the Jaeger dashboard and select **productpage.Chapter7** as the service. Once
    you have selected the service, you can click on **Find Traces**, which will then
    show a detailed view of the latest traces for the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20 – The Jaeger dashboard](img/B17989_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 – The Jaeger dashboard
  prefs: []
  type: TYPE_NORMAL
- en: A **trace** in Jaeger is a representation of a request execution and is composed
    of multiple **spans**; the trace records the path taken and traversed by a request.
    A trace is made up of multiple spans; a span represents a unit of work and is
    used to track specific operations made by a request. The first span represents
    the **root span**, which is a request from start to finish; each subsequent span
    provides a more in-depth context of what has happened in that part of the request
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can click on any of the traces on the dashboard. The following is an example
    of a trace with eight spans:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21 – Trace and spans in Jaeger](img/B17989_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.21 – Trace and spans in Jaeger
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshots, you can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The request took 78.69 milliseconds in `istio-ingressgateway`, which is also
    the root span. The request was then forwarded to the `productpage` upstream service
    at port `9080`. If you look at the next child span, you will see that the time
    taken in `istio-ingressgateway` is 78.69 – 76.73 milliseconds = 1.96 milliseconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.22 – The root span of BookInfo](img/B17989_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.22 – The root span of BookInfo
  prefs: []
  type: TYPE_NORMAL
- en: The request was then received by the `productpage` service at 867 microseconds
    in the overall processing timeline. It took 76.73 milliseconds to process the
    request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.23 – The request arriving on the product page](img/B17989_07_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.23 – The request arriving on the product page
  prefs: []
  type: TYPE_NORMAL
- en: The `productpage` service did some processing between 867 microseconds and 5.84
    milliseconds, and after that, it invoked the `details` service at port `9080`.
    It took 12.27 milliseconds to make the round trip to the `details` service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.24 – The request from the product page to the details service](img/B17989_07_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.24 – The request from the product page to the details service
  prefs: []
  type: TYPE_NORMAL
- en: The request was then received by the `details` service after 7.14 milliseconds,
    and it took 1.61 milliseconds to process the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.25 – The request arriving at the details service](img/B17989_07_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.25 – The request arriving at the details service
  prefs: []
  type: TYPE_NORMAL
- en: 'I have not illustrated the rest of the spans, but I hope you get an idea of
    the benefits of doing this exercise. The example we just went through raises some
    intriguing observations:'
  prefs: []
  type: TYPE_NORMAL
- en: By comparing the start time of the third and fourth spans, it is clear that
    it took 1.3 milliseconds for the request to depart from the product page and arrive
    on the details page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The details page took only 1.6 milliseconds to process the request, but it took
    12.27 milliseconds for the product page to receive the request and send it to
    the details page, which highlights some inefficiencies in the product page implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can explore further by clicking on the dropdown in the top-right corner
    of the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26 – Other options to see the tracing details](img/B17989_07_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.26 – Other options to see the tracing details
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Trace Spans Table** option is very useful in presenting a summarized
    view of the time taken by multiple spans to process requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.27 – The trace span table in Jaeger](img/B17989_07_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.27 – The trace span table in Jaeger
  prefs: []
  type: TYPE_NORMAL
- en: 'Tracing comes at the cost of performance, and it is not ideal to trace all
    requests because they will cause performance degradation. We installed Istio in
    a demo profile, which by default samples all requests. This can be controlled
    by the following configuration map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can control the sampling rate by providing the correct value for `sampling`
    in `tracing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be controlled at the deployment level – for example, we can configure
    the product page to sample only 1% of the requests by adding the following to
    `bookinfo.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The entire configuration is available in `Chapter7/bookinfo-samplingdemo.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about how distributed tracing can be performed using
    Jaeger without making any changes in the application code, provided your application
    can forward `x-b3` headers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we read about how Istio makes systems observable by generating
    various telemetry data. Istio provides various metrics that can then be used by
    Istio operators to fine-tune and optimize a system. This is all achieved by Envoy,
    which generates various metrics that are then scraped by Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: Istio allows you to configure new metrics as well as add new dimensions to existing
    metrics. You learned how to use Prometheus to query various metrics using PromQL
    and build queries that can provide insight into your system, as well as business
    operations. We later installed Grafana to visualize the metrics collected by Prometheus,
    even though there are a number of out-of-the-box dashboards provided for Istio,
    and you can easily add new dashboards, configure alerts, and create policies on
    how these alerts should be distributed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we installed Jaeger to perform distributed tracing to understand how
    a request is processed in a distributed system, and we did all this without needing
    to modify the application code. This chapter provides the foundational understanding
    of how Istio makes systems observable, resulting in systems that are not only
    healthy but also optimal.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the various issues you may face when
    operating Istio and how to troubleshoot them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Scaling, Extending,and Optimizing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part takes you into advanced topics of Istio. You will read about various
    architectures for deploying Istio to production environments. You will also explore
    various options to extend the Istio data plane and learn why it is a very useful
    and powerful feature of Istio. Istio provides great flexibility for virtual machine-based
    workloads so, in this part, you will read about how to extend Istio to virtual
    machines. Toward the end of this part, you will read various tips for troubleshooting
    Istio and best practices to operate and configure Istio in production. We will
    finish the book by summarizing what we have learned and applying this to another
    sample application, along with discussing eBPF and how you can learn more about
    Istio. The appendix provides you with valuable details about other Service Mesh
    technologies and will help you get comparable knowledge of Istio in regard to
    other options.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 8*, *Scaling Istio to Multiple Clusters Deployments A Kubernetes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 9*, *Extending Istio Data Plane*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 10*, *Deploying Istio Service Mesh for Non-Kubernetes Workloads*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 11*, *Troubleshooting and Operating Istio*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 12*, *Summarizing What We Have Learned and Next Steps*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
