- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Security with GitOps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitOps 安全性
- en: Implementing GitOps offers several benefits for the security of software development
    processes. By using Git as a central source for configuration and code, the integrity
    and traceability of environments can be ensured. In this chapter, we will explore
    the various aspects of security in the context of GitOps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 GitOps 为软件开发过程的安全性提供了多个好处。通过将 Git 用作配置和代码的中央源，可以确保环境的完整性和可追溯性。在本章中，我们将探讨
    GitOps 背景下的安全性各个方面。
- en: We will begin by examining the well-known **Cockpit** and **Fleet** approaches
    and use them to highlight various security considerations when using Argo CD.
    Next, we will focus on **Kyverno** as a **policy engine** that acts as a gatekeeper,
    defining what is allowed on the cluster and which deployments are even permitted.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从分析广为人知的 **Cockpit** 和 **Fleet** 方法开始，并通过它们突出使用 Argo CD 时的各种安全考虑。接下来，我们将重点关注
    **Kyverno** 作为 **策略引擎**，它充当门卫，定义集群中允许的操作以及哪些部署是被允许的。
- en: The topic of permissions plays a central role in the context of GitOps. Therefore,
    we will discuss the secure handling of secrets and introduce two tools that have
    already been successfully adopted in the industry.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 权限问题在 GitOps 的背景中占据核心地位。因此，我们将讨论安全处理密钥，并介绍已在行业中成功采用的两种工具。
- en: From the perspective of the platform team, we will consider the provisioning
    of context information such as cert-manager, Ingress Controllers, and so on for
    developers. Here, we will use the proven **Kubernetes Service Catalog** principle
    and explore its secure application and updating.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从平台团队的角度，我们将考虑为开发人员提供上下文信息，如 cert-manager、Ingress 控制器等。在这里，我们将使用经过验证的 **Kubernetes
    服务目录** 原则，并探索其安全应用和更新。
- en: 'Finally, we will take a look at the **KubeClarity** tool, which provides clarity
    about vulnerabilities in running applications on various levels, such as the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看看 **KubeClarity** 工具，它能清晰地显示运行应用程序中的漏洞，包括以下各个层级：
- en: '**Configuration**: Misconfigurations of Kubernetes resources'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：Kubernetes 资源的错误配置'
- en: '**Images**: Vulnerabilities in the container images used'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜像**：容器镜像中的漏洞'
- en: '**Code**: Security vulnerabilities in the application code'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码**：应用代码中的安全漏洞'
- en: In addition, we will briefly dive into the OS level or kernel level and look
    at the **Falco** tool. This tool can be used to detect suspicious activity on
    the host, such as when operations are executed that should not be executed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将简要介绍操作系统级别或内核级别，并查看 **Falco** 工具。该工具可用于检测主机上的可疑活动，例如执行不应执行的操作。
- en: The goal of this chapter is to illuminate the different perspectives on different
    layers and thus gain a better understanding of how GitOps can help teams improve
    security.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是阐明不同层面的不同视角，从而更好地理解 GitOps 如何帮助团队提升安全性。
- en: 'We will cover the following main topics in the chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中讨论以下主要话题：
- en: Hardening declarative GitOps CD on Kubernetes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加固 Kubernetes 上的声明式 GitOps CD
- en: Committing everything to Git? What about Secrets?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容提交到 Git 吗？那密钥怎么办？
- en: Leveraging a policy engine for policy-as-code practices
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用策略引擎进行政策即代码实践
- en: Automating security scanning and compliance
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化安全扫描与合规性
- en: Keeping your platform catalog up-to-date
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持平台目录的最新状态
- en: Hardening declarative GitOps CD on Kubernetes
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加固 Kubernetes 上的声明式 GitOps CD
- en: In this section, we’ll delve into the practices essential for hardening declarative
    GitOps **continuous delivery** (**CD**) on Kubernetes, focusing on enhancing security
    and reducing the risk of misconfigurations – a leading cause of cloud breaches.
    The shift toward cloud-native technologies has simplified the complexity of systems,
    operational theories, and skillsets, offering a clearer and more secure framework
    for building and managing applications. However, the security of these systems
    extends beyond just the software development and supply chain aspects; it crucially
    involves addressing the configuration vulnerabilities.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将深入探讨加固 Kubernetes 上声明式 GitOps **持续交付**（**CD**）所必需的实践，重点提升安全性并减少配置错误的风险——这是云安全漏洞的主要原因之一。向云原生技术的转变简化了系统、操作理论和技能的复杂性，为构建和管理应用提供了更清晰、更安全的框架。然而，这些系统的安全性不仅仅涉及软件开发和供应链方面；它还至关重要地涉及解决配置漏洞。
- en: Addressing configuration vulnerabilities
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决配置漏洞
- en: Cloud-native technologies streamline skillsets, operational theories, and system
    complexities, enhancing the understandability and security of system architectures.
    However, the primary cloud security risk remains misconfiguration, often overlooked
    amid the focus on developmental and supply chain security. The adoption of the
    GitOps pattern, particularly for progressive application delivery, has become
    widespread, offering a more secure alternative to traditional direct-to-production
    build servers. This method employs a Git repository for changes, enabling pre-deployment
    security assessments and minimizing privilege escalation and configuration drift.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生技术简化了技能组合、操作理论和系统复杂性，提升了系统架构的可理解性和安全性。然而，主要的云安全风险仍然是配置错误，这往往在专注于开发和供应链安全时被忽视。GitOps模式的采用，特别是在渐进式应用交付方面，已经变得广泛，提供了一种比传统的直接构建到生产环境的服务器更安全的替代方案。这种方法使用Git仓库来管理更改，能够进行部署前的安全评估，并最大限度地减少权限提升和配置漂移。
- en: The Cloud Native Computing Foundation commissioned **ControlPlane** [*1*] to
    conduct a detailed threat modeling analysis on Argo CD, a tool emblematic of the
    GitOps approach, focusing on its deployment in a multi-tenant Kubernetes environment.
    This analysis revealed 19 identified threats, with 6 classified as high priority,
    emphasizing the need for rigorous security measures. Recommendations for hardening
    include enhancing password management, integrating **single sign-on**, and applying
    strict **Role Based Access Contro** (**RBAC)** principles to limit access to sensitive
    information.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生计算基金会委托**ControlPlane**[*1*]对Argo CD进行详细的威胁建模分析，Argo CD是GitOps方法的典型工具，重点关注其在多租户Kubernetes环境中的部署。该分析揭示了19个已识别的威胁，其中6个被列为高优先级，强调了需要采取严格安全措施的必要性。硬化建议包括加强密码管理、集成**单点登录**、并应用严格的**基于角色的访问控制**（**RBAC**）原则，以限制对敏感信息的访问。
- en: The report from ControlPlane [*1*] also provides visual attack trees for the
    most critical threats, aiding stakeholders in understanding and mitigating risks,
    alongside a comprehensive overview of the Argo CD deployment architecture. It
    includes Terraform code for replicating the setup, ensuring that security controls
    can be effectively validated. These measures, grounded in the report’s findings,
    aim to fortify the security of Argo CD deployments, aligning them with organizational
    security standards and maximizing the benefits of using GitOps within cloud-native
    ecosystems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 来自ControlPlane的报告[*1*]还提供了最关键威胁的可视化攻击树，帮助利益相关者理解并减轻风险，同时对Argo CD部署架构提供全面概述。报告中包括用于复制设置的Terraform代码，确保能够有效验证安全控制。这些措施基于报告的发现，旨在加强Argo
    CD部署的安全性，使其符合组织的安全标准，并最大化GitOps在云原生生态系统中的应用优势。
- en: We will integrate parts from the report and combine them with the well-known
    Cockpit and Fleet approach. The report in question is from 2023, featuring *Argo
    CD version 2.67*, and some issues may have already been resolved with newer Argo
    CD releases. At the time of writing, *Argo CD version 2.10** is considered stable.
    We will compare specific points from the report against *Argo CD* *Version 2.10**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从报告中整合部分内容，并将其与广为人知的Cockpit和Fleet方法结合起来。该报告来自2023年，涉及*Argo CD版本2.67*，一些问题可能已经在更新的Argo
    CD版本中得到解决。撰写本文时，*Argo CD版本2.10*被认为是稳定版本。我们将对比报告中的具体内容与*Argo CD* *版本2.10*进行比较。
- en: 'In this section, we will not go through the entire report but will select a
    few items to discuss. Each potential threat will be abbreviated as **ATM-ID**,
    with priorities defined from low to high. These will be divided into three categories.
    *Table 13.1* depicts the **Change Impact Assessment** (**CIA**) as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会逐一讲解整个报告，而是选择几个项目进行讨论。每个潜在威胁将缩写为**ATM-ID**，并根据优先级从低到高进行分类。这些威胁将分为三类。*表13.1*展示了**变更影响评估**（**CIA**）如下：
- en: '| **Confidentiality** | High | Cluster takeover (Operations, Tenant) due to
    leak of admin credentials |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **机密性** | 高 | 由于管理员凭证泄露导致集群接管（操作、租户） |'
- en: '| Medium | Sensitive information related to application or cluster state is
    exfiltrated |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 中等 | 敏感信息与应用或集群状态相关被泄露 |'
- en: '| Low | Non-sensitive information leakage |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 低 | 非敏感信息泄露 |'
- en: '| **Integrity** | High | Compromise of source code repositories and application
    deployments |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **完整性** | 高 | 源代码仓库和应用部署被破坏 |'
- en: '| Medium | Application sync fails due to misconfiguration/invalid configuration
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 中等 | 因配置错误/无效配置导致应用同步失败 |'
- en: '| Low | Non-critical operation is blocked due to misconfiguration/invalid configuration
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 低 | 由于配置错误/无效配置，非关键操作被阻止 |'
- en: '| **Availability** | High | Cluster (Operations, Tenant) subject to **Denial
    of** **Service** (**DoS**) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **可用性** | 高 | 集群（操作、租户）面临**拒绝服务**（**DoS**）风险 |'
- en: '| Medium | Managed applications are blocked for a significant period |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 中 | 托管的应用程序在一段时间内被阻止 |'
- en: '| Low | Managed app synchronization is blocked for a short period |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 低 | 托管的应用程序同步在短时间内被阻止 |'
- en: Table 13.1 – Change Impact Assessment [1]
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表13.1 – 变更影响评估 [1]
- en: Enhancing password management and RBAC
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强密码管理和RBAC
- en: 'Let’s now examine where we can identify parts of the threats within our Cockpit
    and Fleet approach. This will be indicated in *Figure 13**.1* with an exclamation
    mark and an ID:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来查看我们在Cockpit和Fleet方法中可以识别出威胁的部分。这将在*图13.1*中用感叹号和ID标出：
- en: '![Figure 13.1 – Cockpit and Fleet approach combined with a threat model](img/B22100_13_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – Cockpit和Fleet方法结合威胁模型](img/B22100_13_01.jpg)'
- en: Figure 13.1 – Cockpit and Fleet approach combined with a threat model
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – Cockpit和Fleet方法结合威胁模型
- en: 'Now, the first ID, *ATM-004*, is located in *Table 13.2* under the category
    *Argo* *CDs RBAC*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第一个ID，*ATM-004*，位于*表13.2*中的*Argo* *CDs RBAC*类别下：
- en: '| **ID** | **UID** | **Category** | **Priority** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | **UID** | **类别** | **优先级** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| ATM-004 | KR-AR-002 | Argo CD RBAC | High |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| ATM-004 | KR-AR-002 | Argo CD RBAC | 高 |'
- en: 'Table 13.2 – ATM-004: UI local users’ credentials never expire, and don’t have
    strong authentication'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 表13.2 – ATM-004：UI本地用户的凭证永不过期，并且没有强身份验证
- en: The risk here is that the Argo CD UI local users’ credentials never expire and
    are solely based on a username and password without secondary authentication.
    The priority is already set too high. Considering the Cockpit, which has access
    to the remaining clusters, in my opinion, it becomes even more critical.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的风险在于，Argo CD UI本地用户的凭证永不过期，且仅基于用户名和密码，没有二次身份验证。优先级已经设置得过高。考虑到Cockpit可以访问其他集群，我个人认为这一点变得更加关键。
- en: The danger is that unauthorized changes could occur if the credentials were
    to be compromised.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 危险在于，如果凭证被泄露，可能会发生未经授权的更改。
- en: Important note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '**OAuth2** and **OpenID Connect** (**OIDC**) are protocols for secure authorization
    and authentication. OAuth2 allows secure resource access, while OIDC, built on
    OAuth2, adds user identity verification. They ensure secure data sharing without
    exposing credentials, enhancing application security through token-based authentication.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth2**和**OpenID Connect** (**OIDC**)是安全授权和身份验证协议。OAuth2允许安全地访问资源，而OIDC则在OAuth2的基础上添加了用户身份验证。它们通过基于令牌的身份验证，确保在不暴露凭证的情况下安全地共享数据，从而增强了应用程序的安全性。'
- en: '**Dex** is an open source identity service that uses OIDC to authenticate users
    and provide access to various applications and services.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dex**是一个开源身份服务，使用OIDC对用户进行身份验证，并提供对各种应用程序和服务的访问。'
- en: '**Microsoft Entra ID**, formerly **Azure Active Directory** (**AAD**), is a
    cloud-based identity and access management service provided by Microsoft.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**Microsoft Entra ID**，前身为**Azure Active Directory** (**AAD**)，是微软提供的一种基于云的身份与访问管理服务。'
- en: It is therefore recommended to use the local admin account only for initial
    configuration and then switch to single sign-on through the provided Dex server
    and an OIDC provider that supports OAuth2, such as Microsoft Entra ID, allowing
    the mapping of roles to corresponding groups. Subsequently, the admin access should
    be disabled, as admin access does not provide more extensive permissions than
    the highest mapping of the admin group to an Azure group.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，建议仅在初始配置时使用本地管理员账户，然后通过提供的Dex服务器和支持OAuth2的OIDC提供程序（如Microsoft Entra ID）切换到单点登录，从而实现角色与相应组的映射。随后，应禁用管理员访问，因为管理员访问并不会提供比将管理员组映射到Azure组的最高权限更广泛的权限。
- en: 'This can then be adjusted in the `argocd-rbac-cm` configmap as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以在`argocd-rbac-cm`配置映射中进行如下调整：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Subsequently, the local admin can be disabled in `argocd-cm`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，可以在`argocd-cm`中禁用本地管理员：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we also consider that the admin password (*ATM-003*) exists as a Kubernetes
    Secret, then hopefully, it’s clear how dangerous it can be if an attacker gains
    access either to a Fleet cluster or, even worse, to the Cockpit, which enables
    access to the *ServiceAccounts* and thus to the remaining clusters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还考虑到管理员密码（*ATM-003*）作为 Kubernetes Secret 存在，那么希望它能清楚地说明，如果攻击者获得了 Fleet 集群的访问权限，或者更糟的是，获得了
    Cockpit 的访问权限，从而能够访问 *ServiceAccounts* 进而访问其他集群，这可能会有多么危险。
- en: '| **ID** | **UID** | **Category** | **Priority** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | **UID** | **类别** | **优先级** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| ATM-003 | KR-AR-001 | Argo CD RBAC | High |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| ATM-003 | KR-AR-001 | Argo CD RBAC | 高 |'
- en: 'Table 13.3 – ATM-003: Initial admin password is stored as a Kubernetes Secret'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.3 – ATM-003：初始管理员密码作为 Kubernetes Secret 存储
- en: If attackers gain access to a Fleet cluster or, even worse, to the Cockpit,
    which controls the *ServiceAccounts* and thus allows access to the remaining clusters,
    there is a significant risk involved. This situation could lead to *unauthorized
    changes* in the Argo CD configuration due to unauthorized reading of the Argo
    CD initial admin password from Kubernetes Secrets.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者获得对 Fleet 集群的访问权限，或者更糟的是，获得对控制 *ServiceAccounts* 的 Cockpit 的访问权限，从而可以访问其余集群，则存在重大风险。这种情况可能导致由于未经授权读取
    Argo CD 初始管理员密码从 Kubernetes Secrets 中，导致 Argo CD 配置的*未经授权更改*。
- en: Therefore, it is recommended to rotate the Argo CD admin password and delete
    the secret, as Argo CD only creates the secret for access purposes but does not
    need the secret itself. According to Argo CD’s documentation, the secret serves
    no other purpose than to store the initially generated password in clear text,
    and can safely be deleted at any time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，建议旋转 Argo CD 管理员密码并删除该秘密，因为 Argo CD 仅创建该秘密用于访问目的，但不需要该秘密本身。根据 Argo CD 的文档，该秘密仅用于存储初始生成的密码的明文，并且可以在任何时候安全地删除。
- en: 'To modify the admin password, follow the subsequent steps. It’s recommended
    to pass this guidance on to every user or team managing a fleet cluster. The optimal
    approach is to transition to OIDC and then deactivate the admin account as previously
    outlined. However, if you need to change the password, you should adhere to the
    following procedures:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改管理员密码，请按照以下步骤操作。建议将此指南传递给每个管理舰队集群的用户或团队。最佳做法是过渡到 OIDC，然后按照之前的说明停用管理员账户。然而，如果需要更改密码，则应遵循以下程序：
- en: Important note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: These commands are run on a Unix-like operating system such as Ubuntu, Debian,
    or other Linux distributions, as well as on macOS.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令在类似 Unix 的操作系统上运行，如 Ubuntu、Debian 或其他 Linux 发行版，以及 macOS。
- en: 'First, forward to `argocd server`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，转发到 `argocd server`：
- en: '[PRE2]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The password can be easily accessed using the Argo CD **command-line** **interface**
    (**CLI**):'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密码可以通过 Argo CD **命令行** **接口**（**CLI**）轻松访问：
- en: '[PRE3]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: argocd login <ARGOCD_SERVER>
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: argocd login <ARGOCD_SERVER>
- en: '[PRE4]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Change the password using the following command:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令更改密码：
- en: '[PRE5]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As an alternative to the previous steps, you can use a shorter method by combining
    the commands into one line, as in the following:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为之前步骤的替代方法，您可以通过将命令合并成一行来使用更简洁的方法，如下所示：
- en: '[PRE6]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, update the password as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按如下方式更新密码：
- en: '[PRE7]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, kill the forwarding process running in the background as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按如下方式终止在后台运行的转发进程：
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we’ve updated the password, let’s examine the final part, *ATM-006*
    (*Table 13.4*), which becomes particularly significant in the context of the Cockpit
    and Fleet approach:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更新了密码，让我们来看最后一部分，*ATM-006*（*表 13.4*），它在 Cockpit 和 Fleet 方法的背景下尤为重要：
- en: '| **ID** | **UID** | **Category** | **Priority** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | **UID** | **类别** | **优先级** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| ATM-006 | KR-ASM-001 | Argo CD Secrets Management | High |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| ATM-006 | KR-ASM-001 | Argo CD 秘密管理 | 高 |'
- en: 'Table 13.4 – ATM-006: Never-expiring tenant cluster credentials are stored
    as Kubernetes Secrets'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.4 – ATM-006：永不过期的租户集群凭据作为 Kubernetes Secrets 存储
- en: The risk here is that Argo CD tenant cluster credentials are stored as Kubernetes
    Secrets, and the Argo CD `argocd-manager` service account token on the tenant
    cluster is configured never to expire.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的风险在于 Argo CD 租户集群凭据作为 Kubernetes Secrets 存储，并且租户集群上的 Argo CD `argocd-manager`
    服务账户令牌配置为永不过期。
- en: Consequently, an attacker could perform unauthorized actions on the tenant cluster
    due to unauthorized access to the never-expiring tenant bearer token from the
    Kubernetes Secret.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，攻击者可能会由于未经授权访问 Kubernetes Secret 中的永不过期的租户承载令牌，从而在租户集群上执行未经授权的操作。
- en: Depending on the provider and Kubernetes distribution, different mitigation
    strategies can be applied. It is advised to use **workload identities or managed
    identities**, especially in services such as Azure Kubernetes Service, allowing
    clusters to access Azure resources without secrets. Alternatively, consider leveraging
    an external **key management service** (e.g., **AWS Key Management Service**)
    to securely manage and expose Argo CD tenant cluster credentials. It’s crucial
    to ensure that Argo CD’s tenant cluster bearer tokens are rotated regularly, aligning
    with organizational security policies. For manual rotation, deleting the corresponding
    Kubernetes Secret in the tenant cluster will trigger the creation of a new token.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 根据提供商和 Kubernetes 分发版本的不同，可以应用不同的缓解策略。建议使用 **工作负载身份或托管身份**，特别是在像 Azure Kubernetes
    服务等服务中，这样可以让集群在没有机密的情况下访问 Azure 资源。或者，可以考虑利用外部的 **密钥管理服务**（例如 **AWS 密钥管理服务**）来安全管理和暴露
    Argo CD 租户集群凭证。至关重要的是，确保 Argo CD 租户集群的持有令牌定期轮换，遵循组织的安全政策。对于手动轮换，删除租户集群中相应的 Kubernetes
    Secret 将触发新令牌的创建。
- en: However, the aim of this section is not to address all security vulnerabilities,
    as I consider it unnecessary to cover them all due to their vast diversity. This
    section is intended to raise awareness of the potential security gaps that can
    arise when using GitOps and how to attempt to counteract them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本节的目的是不讨论所有安全漏洞，因为我认为由于其多样性，覆盖所有漏洞是没有必要的。本节旨在提高对使用 GitOps 时可能出现的安全漏洞的意识，以及如何尝试应对这些问题。
- en: '*Figure 13**.2* should now make it clear that we have only mitigated three
    out of many possible high-level attacks:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13.2* 现在应该能够清楚地表明，我们仅减轻了三种可能的高级攻击：'
- en: '![Figure 13.2 – Cockpit and Fleet approach combined with the threat model –
    the reduced attack vector view](img/B22100_13_02.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – Cockpit 和 Fleet 方法结合威胁模型 – 减少攻击面视图](img/B22100_13_02.jpg)'
- en: Figure 13.2 – Cockpit and Fleet approach combined with the threat model – the
    reduced attack vector view
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – Cockpit 和 Fleet 方法结合威胁模型 – 减少攻击面视图
- en: Mechanisms commonly supported by most systems, such as firewall rules, should
    be implemented to restrict access to Cockpit clusters exclusively tospecified
    IP address ranges. Similarly, access to Fleet clusters can be limited using firewalls,
    potentially originating from the Cockpit cluster itself and confined to certain
    IP spaces. It’s crucial to secure cluster access, particularly to the Cockpit,
    with **multi-factor authentication** (**MFA**) to significantly reduce the initial
    attack vector. Whenever feasible, perpetual tokens should be replaced with identity
    solutions to facilitate access without the need for secrets.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数系统常见的机制，如防火墙规则，应当被实现，以限制对 Cockpit 集群的访问，确保只有指定的 IP 地址范围可以访问。同样，访问 Fleet 集群的权限也可以通过防火墙进行限制，防火墙可能来自
    Cockpit 集群本身，并且仅限于某些 IP 范围。保护集群访问尤其是 Cockpit 集群的安全至关重要，**多因素身份验证**（**MFA**）可以显著减少初始攻击面。尽可能地，应该用身份解决方案替换永久令牌，从而无需使用机密就能便捷访问。
- en: I strongly advise delving into the *Threat Model* document provided by **ControlPlane**.
    It includes detailed **attack trees** that illustrate how exploiting multiple
    vulnerabilities can have profound impacts. This comprehensive understanding is
    essential for effectively safeguarding your infrastructure.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议深入了解 **ControlPlane** 提供的 *威胁模型* 文档。文档中包括详细的 **攻击树**，展示了如何利用多个漏洞可能带来深远影响。对这些内容的全面了解对于有效保护你的基础设施至关重要。
- en: The next section is about the fact that GitOps takes the approach that everything
    is in Git, but what about secrets? This section looks at how to store secrets
    securely in Git.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论 GitOps 的做法，即一切都在 Git 中，但机密怎么办？本节将探讨如何在 Git 中安全存储机密。
- en: Committing everything to Git? What about Secrets?
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有内容都提交到 Git 中？那机密怎么办？
- en: In a GitOps workflow, the idea of committing every piece of configuration to
    Git repositories is central. It ensures that the entire state of your infrastructure
    is declaratively represented and can be versioned, audited, and reviewed. However,
    this approach presents a challenge when it comes to handling secrets, such as
    passwords, tokens, and private keys. Storing such sensitive information plainly
    in Git repositories is not secure. This is where tools such as Sealed Secrets
    and External Secrets come into play, providing secure mechanisms to manage secrets
    in a GitOps workflow.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitOps 工作流中，将每一项配置提交到 Git 仓库是核心思想。这确保了您的基础设施的整个状态被声明式地表示，并且可以进行版本控制、审计和审查。然而，这种方法在处理机密信息（如密码、令牌和私钥）时会带来挑战。将这些敏感信息直接存储在
    Git 仓库中并不安全。这时，像密封机密和外部机密这样的工具就派上用场，它们为在 GitOps 工作流中管理机密提供了安全的机制。
- en: Sealed Secrets
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密封机密
- en: Sealed Secrets [*2*] is a Kubernetes controller and toolset, designed to encrypt
    secrets that can safely be stored in Git repositories. When you apply the sealed
    secret to your cluster, the Sealed Secrets controller decrypts it and creates
    a regular Kubernetes secret. This process allows you to manage your secrets’ life
    cycle through Git without exposing the sensitive content.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 密封机密 [*2*] 是一个 Kubernetes 控制器和工具集，旨在加密可以安全存储在 Git 仓库中的机密。当您将密封机密应用到集群时，Sealed
    Secrets 控制器会解密它并创建一个常规的 Kubernetes 机密。这个过程允许您通过 Git 管理机密的生命周期，而不会暴露敏感内容。
- en: 'Use it as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如下使用：
- en: '`kubeseal` CLI tool on your local machine, as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地机器上使用`kubeseal` CLI 工具，如下所示：
- en: '[PRE9]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Key-pair**: Generate a key-pair or use the certificate from the deployed
    Sealed Secrets Operator:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**密钥对**：生成密钥对或使用部署的 Sealed Secrets Operator 中的证书：'
- en: '[PRE10]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Sealing Secrets**: Use the kubeseal CLI to encrypt your secret. The CLI generates
    a *SealedSecret* resource, which you can commit to your Git repository:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**密封机密**：使用 kubeseal CLI 工具加密您的机密。CLI 会生成一个*SealedSecret* 资源，您可以将其提交到您的 Git
    仓库中：'
- en: '[PRE11]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Automation with GitOps**: Integrate this process into your GitOps workflows.
    Whenever you update your sealed secrets in Git, your CI/CD pipeline can automatically
    apply them to your cluster.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**与 GitOps 的自动化**：将此过程集成到您的 GitOps 工作流中。每当您在 Git 中更新密封机密时，您的 CI/CD 流水线可以自动将其应用到集群中。'
- en: External Secrets
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部机密
- en: External Secrets [*3*] is an open source project that integrates external secret
    management systems such as **AWS Secrets Manager**, **Azure Key Vault**, and **Google
    Secret Manager** with Kubernetes. It allows you to securely inject secrets into
    your applications without having to expose them in your Git repositories.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 外部机密 [*3*] 是一个开源项目，它将外部机密管理系统（如 **AWS Secrets Manager**、**Azure Key Vault**
    和 **Google Secret Manager**）与 Kubernetes 集成。它允许您安全地将机密注入到应用程序中，而无需在 Git 仓库中暴露这些机密。
- en: 'Use it as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如下使用：
- en: '**Deployment**: Deploy the External Secrets Operator in your Kubernetes cluster:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部署**：在您的 Kubernetes 集群中部署 External Secrets Operator：'
- en: '[PRE12]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Configuration**: Define an *ExternalSecret* resource that specifies the external
    secret store and the secret key. The operator fetches the secret from the external
    store and creates a Kubernetes secret in the cluster:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置**：定义一个*ExternalSecret* 资源，指定外部机密存储和机密密钥。操作器从外部存储中获取机密，并在集群中创建一个 Kubernetes
    机密：'
- en: '[PRE13]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Applying External Secrets**: Commit the *ExternalSecret* resource to your
    Git repository. The External Secrets Operator will automatically create or update
    the Kubernetes secret in your cluster based on the external source.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用外部机密**：将*ExternalSecret* 资源提交到您的 Git 仓库。External Secrets Operator 将根据外部源自动在您的集群中创建或更新
    Kubernetes 机密。'
- en: '**Integration with GitOps**: Incorporate External Secrets into your GitOps
    pipelines. Changes to the *ExternalSecret* definitions in your Git repo trigger
    the operator to sync the secrets, ensuring your cluster’s secrets are always up-to-date.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**与 GitOps 集成**：将外部机密纳入您的 GitOps 流水线。对 Git 仓库中*ExternalSecret* 定义的更改会触发操作器同步机密，确保您的集群机密始终保持最新。'
- en: The choice of tools depends on various factors. For instance, if you don’t have
    a vault for storing secrets, keys, or certificates, then External Secrets might
    not be suitable. Initially, a connection from the External Secrets Operator to
    the Secret Store or **ClusterSecretStore** must be established. In our projects,
    we utilize managed identities to ensure this. Otherwise, you typically need an
    ID and a secret, which can be challenging to manage securely with GitOps at scale,
    as the ID and secret must be securely transferred to the cluster, possibly through
    a CI/CD pipeline. A significant advantage of External Secrets is its ability to
    fetch secrets at runtime without dependency on the cluster.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 工具的选择取决于各种因素。例如，如果您没有用于存储机密、密钥或证书的金库，那么 External Secrets 可能不适合。最初，必须建立 External
    Secrets Operator 与 Secret Store 或 **ClusterSecretStore** 之间的连接。在我们的项目中，我们利用托管身份来确保这一点。否则，通常需要一个
    ID 和一个密钥，这在大规模的 GitOps 环境中可能难以安全管理，因为 ID 和密钥必须通过 CI/CD 流水线安全传输到集群。External Secrets
    的一个显著优势是它可以在运行时获取机密，而无需依赖集群。
- en: However, access to a secrets manager through a vault is not always available.
    Therefore, the Sealed Secrets Operator, particularly in on-premises environments,
    is currently considered the industry standard.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过金库访问机密管理器并非始终可用。因此，Sealed Secrets Operator，尤其是在本地环境中，目前被认为是业界标准。
- en: Teams need to decide which option is the better choice. In my opinion, both
    options are solid and integrate very well into the GitOps ecosystem. This not
    only allows for the secure storage of secrets, keys, and certificates while embracing
    the GitOps approach but also opens up entirely new possibilities with GitOps at
    scale, such as deploying a pull secret across a specific registry. The platform
    team, by combining External Secrets and Kyverno, can deploy a secret across all
    clusters, and Kyverno distributes it across the namespaces. As a result, every
    team has the pull secret necessary to pull images from a central image registry.
    This enhances security since every image can be subjected to scanning, and it
    provides an overview of the images in operation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 团队需要决定哪种选项更适合。在我看来，这两种选项都很稳固，并且能够很好地融入 GitOps 生态系统。这不仅可以在采用 GitOps 方法的同时安全地存储机密、密钥和证书，还为
    GitOps 大规模应用开辟了全新的可能性，例如在特定注册表中部署拉取机密。平台团队通过结合 External Secrets 和 Kyverno，可以将机密部署到所有集群中，Kyverno
    会将其分发到各个命名空间。因此，每个团队都有必要的拉取机密，可以从中央镜像注册表拉取镜像。这增强了安全性，因为每个镜像都可以进行扫描，并提供操作中镜像的概览。
- en: By leveraging Sealed Secrets and External Secrets, you can maintain the GitOps
    principle of storing all configurations in Git while securely managing your secrets.
    These tools help you automate the management of secrets, keeping your infrastructure
    secure and your deployments consistent.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 Sealed Secrets 和 External Secrets，您可以在安全管理机密的同时，保持 GitOps 原则，即将所有配置存储在
    Git 中。这些工具帮助您自动化机密管理，保持基础设施安全并确保部署一致性。
- en: Every tool that is added to the Kubernetes Service Catalog increases the likelihood
    that more security vulnerabilities will be introduced into the system. We will
    look at how to maintain your catalog in the next section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个添加到 Kubernetes 服务目录中的工具都会增加系统引入更多安全漏洞的可能性。我们将在下一部分讨论如何维护您的目录。
- en: In the following section, we will delve into enhancing security through GitOps
    and a **policy engine**. This approach enables proactive measures during deployment,
    determining what is permissible to deploy and identifying associated risks. This
    preemptive strategy ensures that only secure, compliant configurations make their
    way into production, thereby reinforcing your security posture.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将深入探讨通过 GitOps 和 **策略引擎**增强安全性。这种方法能够在部署过程中采取主动措施，确定允许部署的内容并识别相关风险。这种前瞻性策略确保只有安全且符合要求的配置才能进入生产环境，从而强化您的安全姿态。
- en: Leveraging a policy engine for policy-as-code practices
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用策略引擎进行政策即代码实践
- en: In the contemporary landscape of software development, the way we ensure security
    and compliance within our systems has significantly evolved. A pivotal aspect
    of this evolution is the adoption of policy-as-code practices, which enable the
    integration of governance and security policies directly into the development
    and operational processes. Within this context, policy engines such as Kyverno
    [*4*] and **Open Policy Agent** (**OPA**) [*5*] play a crucial role. These tools
    empower organizations to define and enforce their security, compliance, and governance
    requirements as code, thereby ensuring consistent application and transparency
    across their infrastructures and applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的软件开发领域，我们确保系统安全性和合规性的方法发生了显著变化。这一变化的关键方面是采纳了政策即代码的实践，使得治理和安全策略能够直接融入开发和操作流程。在这种背景下，Kyverno
    [*4*] 和 **Open Policy Agent** (**OPA**) [*5*] 等策略引擎发挥着至关重要的作用。这些工具使组织能够将其安全、合规性和治理要求定义为代码，从而确保其基础设施和应用程序的一致性和透明性。
- en: Kyverno and OPA are both powerful, flexible tools designed specifically to implement
    policy as code in Kubernetes environments and beyond. Kyverno focuses on simplifying
    Kubernetes security by using a user-friendly, Kubernetes-native syntax that allows
    developers to define and enforce security policies directly within their CI/CD
    pipelines. On the other hand, OPA is a more general-purpose policy engine that
    employs a highly flexible, domain-agnostic language called **Rego**, enabling
    the creation and implementation of fine-grained, context-aware policies across
    a variety of software systems.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Kyverno 和 OPA 都是功能强大、灵活的工具，专门用于在 Kubernetes 环境及其他场景中实现政策即代码。Kyverno 侧重于通过使用用户友好的、原生的
    Kubernetes 语法简化 Kubernetes 安全性，允许开发人员直接在 CI/CD 管道中定义和执行安全策略。另一方面，OPA 是一个更为通用的策略引擎，采用了一种名为
    **Rego** 的高度灵活、与领域无关的语言，使得在多种软件系统中创建和实施细粒度、上下文感知的策略成为可能。
- en: Integrating these policy engines into a GitOps-based workflow architecture significantly
    enhances security, as it ensures the continuous enforcement and validation of
    compliance. By adopting GitOps, teams can manage their infrastructure and application
    setups as code, creating a versioned, repeatable, and automatable environment.
    Incorporating Kyverno or OPA into this process means that changes to infrastructure
    or applications are automatically validated against predefined policies before
    being implemented. This ensures that all deployments comply with organizational
    security standards and that potential security vulnerabilities or configuration
    errors are proactively identified and remediated before they impact the production
    environment.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些策略引擎集成到基于 GitOps 的工作流架构中显著提升了安全性，因为它确保了合规性的持续执行和验证。通过采用 GitOps，团队能够将基础设施和应用程序设置作为代码进行管理，创建一个版本化、可重复和可自动化的环境。在这一过程中融入
    Kyverno 或 OPA 意味着基础设施或应用程序的更改将在实施之前自动根据预定义的策略进行验证。这确保了所有部署符合组织的安全标准，并且能够在对生产环境产生影响之前主动识别并修复潜在的安全漏洞或配置错误。
- en: Integrating Kyverno and OPA
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成 Kyverno 和 OPA
- en: In this part, we explore how integrating tools such as Kyverno and OPA into
    the development and operational workflow not only enhances security and compliance
    but also promotes efficiency and speed in development cycles. *Automating* policy
    enforcement within the GitOps framework allows teams to deliver faster and more
    securely, leading to more robust, secure applications and infrastructures.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分将探讨如何将 Kyverno 和 OPA 等工具集成到开发和操作工作流中，不仅增强安全性和合规性，还促进开发周期的效率和速度。在 GitOps 框架内
    *自动化* 策略执行，使团队能够更快速、更安全地交付，从而打造更强大、更安全的应用程序和基础设施。
- en: 'We will focus on Kyverno to facilitate a better understanding, as I believe
    it’s a tool that users can comprehend more easily without the need to learn Rego.
    However, before delving into that, let’s examine the layer at which Kyverno operates
    and its integration with GitOps. *Figure 13**.3* will elaborate on these subjects:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点关注 Kyverno，以便更好地理解，因为我认为这是一个用户可以更轻松理解的工具，而无需学习 Rego。然而，在深入讨论之前，让我们先看一下
    Kyverno 操作的层次以及它与 GitOps 的集成。*图 13.3* 将详细阐述这些内容：
- en: '![Figure 13.3 – Kyverno operation layer and GitOps](img/B22100_13_03.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – Kyverno 操作层与 GitOps](img/B22100_13_03.jpg)'
- en: Figure 13.3 – Kyverno operation layer and GitOps
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – Kyverno 操作层与 GitOps
- en: As illustrated, Kyverno operates across both layers, effectively acting as a
    gatekeeper. When you attempt to deploy something that violates its rules, Kyverno
    intervenes, causing the deployment to fail. However, Kyverno’s capabilities extend
    beyond this; it can also validate already-running services within the Kubernetes
    cluster or mutate resources. This versatility justifies positioning Kyverno between
    these layers, making it an advantageous choice.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，Kyverno 在两个层次上运作，充当有效的守门人。当你尝试部署违反其规则的内容时，Kyverno 会介入，导致部署失败。然而，Kyverno
    的功能不仅限于此；它还可以验证 Kubernetes 集群中已运行的服务，或对资源进行修改。这种多功能性使得将 Kyverno 放置在这些层之间成为一个有利的选择。
- en: Leveraging GitOps, you can deploy the Kyverno instance across every cluster
    in the fleet, ensuring consistent policy enforcement. Additionally, the *define
    once, deploy everywhere* approach facilitates multi-cluster deployment, streamlining
    the management of policies across various environments. By collaborating with
    the security team, you can implement different rulesets tailored to specific environments,
    enhancing the security and compliance of your deployments. This synergy between
    Kyverno and GitOps not only simplifies governance but also fortifies the infrastructure’s
    overall security posture.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 GitOps，你可以在整个集群中部署 Kyverno 实例，确保一致的策略执行。此外，*一次定义，处处部署*的方法简化了多集群部署，优化了跨不同环境的策略管理。通过与安全团队合作，你可以实施针对特定环境的不同规则集，增强部署的安全性和合规性。Kyverno
    与 GitOps 之间的协同作用不仅简化了治理，还强化了基础设施的整体安全态势。
- en: Now, let’s look at how it works in the praxis.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下它在实际操作中的表现。
- en: Hands on – let’s put theory into practice *[6]*
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践操作 – 让我们将理论付诸实践 *[6]*
- en: 'First, we establish a streamlined folder structure for the Kubernetes Service
    Catalog, as in the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为 Kubernetes 服务目录建立一个简化的文件夹结构，如下所示：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By initiating the deployment of `kyverno-applicationset.yaml`, you will target
    every fleet cluster identified by the `env=prod` or `env=development` labels.
    This deployment not only sets up the Kyverno tool across these clusters but also
    applies a specific set of policies from the `kustomize` folder to each one. In
    our illustration, we utilize a basic base folder; however, you have the flexibility
    to configure distinct folders – for instance, for different stages. These can
    be aligned with the cluster labels, enabling you to deploy the appropriate ruleset
    to the corresponding cluster. Such an arrangement proves beneficial for implementing
    more lenient policies in development clusters and stricter ones in production
    environments.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启动 `kyverno-applicationset.yaml` 的部署，你将针对每个被 `env=prod` 或 `env=development`
    标签标识的集群进行部署。该部署不仅在这些集群上设置 Kyverno 工具，还会将 `kustomize` 文件夹中的特定策略应用到每个集群。在我们的示例中，我们使用了一个基础的文件夹结构；然而，你可以灵活配置不同的文件夹——例如，用于不同阶段的文件夹。这些文件夹可以与集群标签对齐，从而使你能够将适当的规则集部署到相应的集群。这种安排对于在开发集群中实施更宽松的策略、在生产环境中实施更严格的策略非常有益。
- en: Now, let’s examine an example policy that will be deployed across every fleet
    cluster matching the specified labels. We’ll focus on the `disallow-latest-tag.yaml`
    policy.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一个示例策略，它将在每个匹配指定标签的集群上部署。我们将重点关注 `disallow-latest-tag.yaml` 策略。
- en: 'In the first part, we see the annotations, the `Best Practices` category, and
    then the version, the severity classification, which subject is affected, and
    the description of which negative consequences can result from it. I find it nice
    and compact, clear, and easy to configure:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中，我们看到注释、`最佳实践`类别，然后是版本、严重性分类、受影响的主题，以及由此可能引发的负面后果描述。我觉得它简洁明了，清晰易懂，且易于配置：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the subsequent section under specifications, we observe that the action
    is designated as `Audit` rather than `Enforce`, implying that it is not compulsory.
    Following this, two rules are established. The initial rule conducts a validation
    of the container’s tag using the `*:*` pattern, ensuring it adheres to specific
    criteria. Subsequently, the second rule escalates to the resource level, applying
    a broader scope by targeting the pods directly. It stipulates a constraint that
    the pattern with the `latest` tag must not be used, reinforcing the governance
    over the deployment practices:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In practice, it looks like this: when the rule is applied and an attempt is
    made to deploy a pod and its contained container with the `latest` tag, the deployment
    is blocked. Let’s try to deploy a Nginx pod with the `latest` image tag:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now you can get a Kyverno `policyreport` like the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output should be like the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, we violated the best practices policy, specifically the `disallow-latest-tag`
    policy.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: I refer to this setup as a gatekeeper because it allows you to dictate, through
    simple rules, what can and cannot be deployed into the cluster. However, the capabilities
    of this setup extend further. For instance, you can configure Kyverno policies
    to enforce image signing or to ensure that only images from certain registries
    are allowed to be pulled, among other things. A policy engine is a powerful tool.
    In contrast to the gatekeeper, Kyverno or OPA also operates on already-deployed
    resources or resources that passed the gate and are therefore placed between the
    two layers, as shown in *Figure 13**.3*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: When combined with the GitOps approach, it opens up new possibilities that transcend
    team boundaries, enhancing the security of projects. This integration not only
    streamlines the deployment processes but also ensures that the operational standards
    are consistently met, thereby bolstering the overall security posture of the infrastructure.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how to increase security on two different
    layers using two different tools.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Automating security scanning and compliance
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In today’s fast-paced and security-conscious IT environment, maintaining continuous
    security and compliance is crucial. Automated security scanning and compliance
    are integral components of a robust cybersecurity strategy, especially in Kubernetes
    clusters where applications and services are dynamically scaled and updated. Here,
    we’ll discuss how the **KubeClarity** [*7*] or **Falco** [*8*] tool can be utilized
    to enhance your security posture in Kubernetes environments. The following image
    illustrates the level at which KubeClarity operates:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – KubeClarity operation layer](img/B22100_13_04.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – KubeClarity operation layer
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: KubeClarity is an open source tool designed for security scanning and compliance
    analysis in Kubernetes environments. It provides a comprehensive overview of the
    potential vulnerabilities in your container images and Kubernetes configurations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: KubeClarity
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s first understand how KubeClarity enhances security:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability scanning**: KubeClarity scans container images for known vulnerabilities,
    utilizing various databases and vulnerability tracking sources. It provides detailed
    insights into the security flaws within your images, along with their severity
    levels, enabling you to prioritize fixes.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compliance assurance**: The tool checks your Kubernetes configurations against
    best practices and compliance standards, ensuring that your deployments adhere
    to industry and organizational security policies.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous monitoring**: KubeClarity continuously monitors your containerized
    applications for new vulnerabilities, providing real-time alerts and updates.
    This ongoing vigilance helps maintain a secure Kubernetes environment.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By integrating KubeClarity within a GitOps framework, an organization can significantly
    enhance its security and compliance posture, ensuring that its Kubernetes clusters
    are fortified against evolving threats. This adoption of GitOps principles allows
    for the automation of security scans and compliance checks, making these processes
    more consistent, efficient, and scalable. The proactive approach to security facilitated
    by KubeClarity not only protects your infrastructure but also fosters trust with
    customers by demonstrating a commitment to maintaining a secure and compliant
    environment. The continuous monitoring and automatic alignment with security policies
    enabled by GitOps ensure that any deviations are quickly detected and rectified,
    maintaining a robust defense against potential vulnerabilities.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Falco
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Falco is an open source tool for real-time security monitoring and analysis,
    specifically designed for Kubernetes environments. It functions as an **intrusion
    detection system** (**IDS**), enabling teams to detect anomalous activities in
    their applications and infrastructures that could indicate security breaches or
    other threats. The following picture illustrates the level at which Falco operates.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Falco operation layer](img/B22100_13_05.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Falco operation layer
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Falco operates at the system level (*Figure 13**.5*), monitoring the underlying
    Linux kernel functionality, or more precisely, the system-level activities of
    container orchestration platforms. It utilizes Linux kernel capabilities, particularly
    **extended BPF** (**Berkeley Packet Filter**) or traditional **system calls**
    (**syscalls**) monitoring through a kernel module, to observe and analyze system-wide
    events in real time. Falco can capture and evaluate system calls from applications
    running inside containers, identifying unusual or undesirable behavior.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of integrating Falco with GitOps are as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated security monitoring**: By integrating Falco into a GitOps pipeline,
    security policies can be defined as code and automatically applied to every change
    in the infrastructure or applications, enabling continuous and automated monitoring
    of security standards.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time alerts**: Falco can be configured to send real-time alerts when
    a defined rule is violated. In a GitOps environment, these alerts can facilitate
    swift responses to potential security incidents.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency and compliance**: With GitOps, Falco configurations can be versioned,
    reviewed, and automatically deployed, ensuring consistent enforcement of security
    policies across different environments.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transparency and traceability:** All changes to Falco policies are recorded
    in Git, providing a clear audit trail. This promotes transparency regarding security
    monitoring and facilitates compliance with regulatory requirements.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Falco into the GitOps strategy allows teams not only to enhance
    their security posture but also to adopt a proactive approach to identifying and
    responding to security threats in their Kubernetes environment.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: However, every tool also brings potential risks with it, even if it is intended
    to increase security, which is why maintenance should not be neglected and attention
    should be paid to this when designing or selecting the tools. This is exactly
    what we will discuss briefly in the next section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Keeping your platform catalog up-to-date
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The content of this section has been extensively covered already in [*Chapter
    5*](B22100_05.xhtml#_idTextAnchor081) under the *Bonus – maintenance with GitOps
    at scale and KSC* section. It serves as a reminder that with every tool added,
    the catalog grows, and a keen focus on security should be maintained.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: When a **Common Vulnerabilities and Exposures** (**CVE**) threat is revealed
    and you opt for the Cockpit and Fleet approach, adopting GitOps at scale also
    facilitates a vulnerability-management-at-scale strategy. Therefore, this aspect
    should be considered particularly early in the development of a concept.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Implementing such a strategy ensures that as your infrastructure expands, your
    approach to handling vulnerabilities scales accordingly. This proactive stance
    helps in quickly addressing security issues across the entire fleet, maintaining
    the integrity and security of your systems. Early integration of these practices
    into your conceptual framework is crucial to establishing a robust, scalable,
    and secure infrastructure.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude the chapter, *Figure 13**.6* illustrates the stages or gates that
    the packet (application or service) must pass through, highlighting where various
    security mechanisms can intervene to scan the packet as thoroughly as possible:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Security on multiple layers](img/B22100_13_06.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Security on multiple layers
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, a packet might pass through certain stages, hence the necessity
    for tools such as Falco and Kyverno to enable continuous scanning. These tools
    thrive on defined rules, which, fortunately, can be easily deployed with GitOps.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, it should have become clear that security doesn’t operate on
    just a single layer and shouldn’t be enforced by just one team. Security is a
    cultural issue that can be expanded with approaches such as GitOps and tools such
    as Argo CD at scale, which can include defining rulesets or policies. Security
    doesn’t stop with tools; it also encompasses how one handles sensitive data such
    as secrets and keeps third-party tools in the ecosystem up-to-date and secure.
    Effective security practices require collaboration across teams, continuous monitoring,
    and proactive management to ensure a robust and resilient infrastructure.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll explore the integration of FinOps with GitOps to
    achieve sustainable, cost-effective operations. We’ll cover core FinOps principles,
    cost forecasting, optimization, and understanding the carbon footprint. Additionally,
    we’ll look at future trends in GitOps, including AI-driven automation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: References
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1] [https://github.com/argoproj/](https://github.com/argoproj/)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2] [https://github.com/bitnami-labs/sealed-secrets](https://github.com/bitnami-labs/sealed-secrets)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3] [https://external-secrets.io/latest/](https://external-secrets.io/latest/)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4] [https://kyverno.io](https://kyverno.io)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5] [https://www.openpolicyagent.org](https://www.openpolicyagent.org)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6] [https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes/tree/main/chapter13](https://github.com/PacktPublishing/GitOps-for-Kubernetes-Deployment/tree/main/chapter13)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7] [https://github.com/openclarity/kubeclarity](https://github.com/openclarity/kubeclarity)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[8] [https://falco.org](https://falco.org)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
