- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security with GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing GitOps offers several benefits for the security of software development
    processes. By using Git as a central source for configuration and code, the integrity
    and traceability of environments can be ensured. In this chapter, we will explore
    the various aspects of security in the context of GitOps.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by examining the well-known **Cockpit** and **Fleet** approaches
    and use them to highlight various security considerations when using Argo CD.
    Next, we will focus on **Kyverno** as a **policy engine** that acts as a gatekeeper,
    defining what is allowed on the cluster and which deployments are even permitted.
  prefs: []
  type: TYPE_NORMAL
- en: The topic of permissions plays a central role in the context of GitOps. Therefore,
    we will discuss the secure handling of secrets and introduce two tools that have
    already been successfully adopted in the industry.
  prefs: []
  type: TYPE_NORMAL
- en: From the perspective of the platform team, we will consider the provisioning
    of context information such as cert-manager, Ingress Controllers, and so on for
    developers. Here, we will use the proven **Kubernetes Service Catalog** principle
    and explore its secure application and updating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will take a look at the **KubeClarity** tool, which provides clarity
    about vulnerabilities in running applications on various levels, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration**: Misconfigurations of Kubernetes resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Images**: Vulnerabilities in the container images used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code**: Security vulnerabilities in the application code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, we will briefly dive into the OS level or kernel level and look
    at the **Falco** tool. This tool can be used to detect suspicious activity on
    the host, such as when operations are executed that should not be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to illuminate the different perspectives on different
    layers and thus gain a better understanding of how GitOps can help teams improve
    security.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following main topics in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Hardening declarative GitOps CD on Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Committing everything to Git? What about Secrets?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging a policy engine for policy-as-code practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating security scanning and compliance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping your platform catalog up-to-date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardening declarative GitOps CD on Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll delve into the practices essential for hardening declarative
    GitOps **continuous delivery** (**CD**) on Kubernetes, focusing on enhancing security
    and reducing the risk of misconfigurations – a leading cause of cloud breaches.
    The shift toward cloud-native technologies has simplified the complexity of systems,
    operational theories, and skillsets, offering a clearer and more secure framework
    for building and managing applications. However, the security of these systems
    extends beyond just the software development and supply chain aspects; it crucially
    involves addressing the configuration vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing configuration vulnerabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cloud-native technologies streamline skillsets, operational theories, and system
    complexities, enhancing the understandability and security of system architectures.
    However, the primary cloud security risk remains misconfiguration, often overlooked
    amid the focus on developmental and supply chain security. The adoption of the
    GitOps pattern, particularly for progressive application delivery, has become
    widespread, offering a more secure alternative to traditional direct-to-production
    build servers. This method employs a Git repository for changes, enabling pre-deployment
    security assessments and minimizing privilege escalation and configuration drift.
  prefs: []
  type: TYPE_NORMAL
- en: The Cloud Native Computing Foundation commissioned **ControlPlane** [*1*] to
    conduct a detailed threat modeling analysis on Argo CD, a tool emblematic of the
    GitOps approach, focusing on its deployment in a multi-tenant Kubernetes environment.
    This analysis revealed 19 identified threats, with 6 classified as high priority,
    emphasizing the need for rigorous security measures. Recommendations for hardening
    include enhancing password management, integrating **single sign-on**, and applying
    strict **Role Based Access Contro** (**RBAC)** principles to limit access to sensitive
    information.
  prefs: []
  type: TYPE_NORMAL
- en: The report from ControlPlane [*1*] also provides visual attack trees for the
    most critical threats, aiding stakeholders in understanding and mitigating risks,
    alongside a comprehensive overview of the Argo CD deployment architecture. It
    includes Terraform code for replicating the setup, ensuring that security controls
    can be effectively validated. These measures, grounded in the report’s findings,
    aim to fortify the security of Argo CD deployments, aligning them with organizational
    security standards and maximizing the benefits of using GitOps within cloud-native
    ecosystems.
  prefs: []
  type: TYPE_NORMAL
- en: We will integrate parts from the report and combine them with the well-known
    Cockpit and Fleet approach. The report in question is from 2023, featuring *Argo
    CD version 2.67*, and some issues may have already been resolved with newer Argo
    CD releases. At the time of writing, *Argo CD version 2.10** is considered stable.
    We will compare specific points from the report against *Argo CD* *Version 2.10**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will not go through the entire report but will select a
    few items to discuss. Each potential threat will be abbreviated as **ATM-ID**,
    with priorities defined from low to high. These will be divided into three categories.
    *Table 13.1* depicts the **Change Impact Assessment** (**CIA**) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Confidentiality** | High | Cluster takeover (Operations, Tenant) due to
    leak of admin credentials |'
  prefs: []
  type: TYPE_TB
- en: '| Medium | Sensitive information related to application or cluster state is
    exfiltrated |'
  prefs: []
  type: TYPE_TB
- en: '| Low | Non-sensitive information leakage |'
  prefs: []
  type: TYPE_TB
- en: '| **Integrity** | High | Compromise of source code repositories and application
    deployments |'
  prefs: []
  type: TYPE_TB
- en: '| Medium | Application sync fails due to misconfiguration/invalid configuration
    |'
  prefs: []
  type: TYPE_TB
- en: '| Low | Non-critical operation is blocked due to misconfiguration/invalid configuration
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Availability** | High | Cluster (Operations, Tenant) subject to **Denial
    of** **Service** (**DoS**) |'
  prefs: []
  type: TYPE_TB
- en: '| Medium | Managed applications are blocked for a significant period |'
  prefs: []
  type: TYPE_TB
- en: '| Low | Managed app synchronization is blocked for a short period |'
  prefs: []
  type: TYPE_TB
- en: Table 13.1 – Change Impact Assessment [1]
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing password management and RBAC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now examine where we can identify parts of the threats within our Cockpit
    and Fleet approach. This will be indicated in *Figure 13**.1* with an exclamation
    mark and an ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Cockpit and Fleet approach combined with a threat model](img/B22100_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Cockpit and Fleet approach combined with a threat model
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the first ID, *ATM-004*, is located in *Table 13.2* under the category
    *Argo* *CDs RBAC*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ID** | **UID** | **Category** | **Priority** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ATM-004 | KR-AR-002 | Argo CD RBAC | High |'
  prefs: []
  type: TYPE_TB
- en: 'Table 13.2 – ATM-004: UI local users’ credentials never expire, and don’t have
    strong authentication'
  prefs: []
  type: TYPE_NORMAL
- en: The risk here is that the Argo CD UI local users’ credentials never expire and
    are solely based on a username and password without secondary authentication.
    The priority is already set too high. Considering the Cockpit, which has access
    to the remaining clusters, in my opinion, it becomes even more critical.
  prefs: []
  type: TYPE_NORMAL
- en: The danger is that unauthorized changes could occur if the credentials were
    to be compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**OAuth2** and **OpenID Connect** (**OIDC**) are protocols for secure authorization
    and authentication. OAuth2 allows secure resource access, while OIDC, built on
    OAuth2, adds user identity verification. They ensure secure data sharing without
    exposing credentials, enhancing application security through token-based authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dex** is an open source identity service that uses OIDC to authenticate users
    and provide access to various applications and services.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microsoft Entra ID**, formerly **Azure Active Directory** (**AAD**), is a
    cloud-based identity and access management service provided by Microsoft.'
  prefs: []
  type: TYPE_NORMAL
- en: It is therefore recommended to use the local admin account only for initial
    configuration and then switch to single sign-on through the provided Dex server
    and an OIDC provider that supports OAuth2, such as Microsoft Entra ID, allowing
    the mapping of roles to corresponding groups. Subsequently, the admin access should
    be disabled, as admin access does not provide more extensive permissions than
    the highest mapping of the admin group to an Azure group.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can then be adjusted in the `argocd-rbac-cm` configmap as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Subsequently, the local admin can be disabled in `argocd-cm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we also consider that the admin password (*ATM-003*) exists as a Kubernetes
    Secret, then hopefully, it’s clear how dangerous it can be if an attacker gains
    access either to a Fleet cluster or, even worse, to the Cockpit, which enables
    access to the *ServiceAccounts* and thus to the remaining clusters.
  prefs: []
  type: TYPE_NORMAL
- en: '| **ID** | **UID** | **Category** | **Priority** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ATM-003 | KR-AR-001 | Argo CD RBAC | High |'
  prefs: []
  type: TYPE_TB
- en: 'Table 13.3 – ATM-003: Initial admin password is stored as a Kubernetes Secret'
  prefs: []
  type: TYPE_NORMAL
- en: If attackers gain access to a Fleet cluster or, even worse, to the Cockpit,
    which controls the *ServiceAccounts* and thus allows access to the remaining clusters,
    there is a significant risk involved. This situation could lead to *unauthorized
    changes* in the Argo CD configuration due to unauthorized reading of the Argo
    CD initial admin password from Kubernetes Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is recommended to rotate the Argo CD admin password and delete
    the secret, as Argo CD only creates the secret for access purposes but does not
    need the secret itself. According to Argo CD’s documentation, the secret serves
    no other purpose than to store the initially generated password in clear text,
    and can safely be deleted at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify the admin password, follow the subsequent steps. It’s recommended
    to pass this guidance on to every user or team managing a fleet cluster. The optimal
    approach is to transition to OIDC and then deactivate the admin account as previously
    outlined. However, if you need to change the password, you should adhere to the
    following procedures:'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: These commands are run on a Unix-like operating system such as Ubuntu, Debian,
    or other Linux distributions, as well as on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, forward to `argocd server`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The password can be easily accessed using the Argo CD **command-line** **interface**
    (**CLI**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: argocd login <ARGOCD_SERVER>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the password using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As an alternative to the previous steps, you can use a shorter method by combining
    the commands into one line, as in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, update the password as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, kill the forwarding process running in the background as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we’ve updated the password, let’s examine the final part, *ATM-006*
    (*Table 13.4*), which becomes particularly significant in the context of the Cockpit
    and Fleet approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ID** | **UID** | **Category** | **Priority** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ATM-006 | KR-ASM-001 | Argo CD Secrets Management | High |'
  prefs: []
  type: TYPE_TB
- en: 'Table 13.4 – ATM-006: Never-expiring tenant cluster credentials are stored
    as Kubernetes Secrets'
  prefs: []
  type: TYPE_NORMAL
- en: The risk here is that Argo CD tenant cluster credentials are stored as Kubernetes
    Secrets, and the Argo CD `argocd-manager` service account token on the tenant
    cluster is configured never to expire.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, an attacker could perform unauthorized actions on the tenant cluster
    due to unauthorized access to the never-expiring tenant bearer token from the
    Kubernetes Secret.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the provider and Kubernetes distribution, different mitigation
    strategies can be applied. It is advised to use **workload identities or managed
    identities**, especially in services such as Azure Kubernetes Service, allowing
    clusters to access Azure resources without secrets. Alternatively, consider leveraging
    an external **key management service** (e.g., **AWS Key Management Service**)
    to securely manage and expose Argo CD tenant cluster credentials. It’s crucial
    to ensure that Argo CD’s tenant cluster bearer tokens are rotated regularly, aligning
    with organizational security policies. For manual rotation, deleting the corresponding
    Kubernetes Secret in the tenant cluster will trigger the creation of a new token.
  prefs: []
  type: TYPE_NORMAL
- en: However, the aim of this section is not to address all security vulnerabilities,
    as I consider it unnecessary to cover them all due to their vast diversity. This
    section is intended to raise awareness of the potential security gaps that can
    arise when using GitOps and how to attempt to counteract them.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13**.2* should now make it clear that we have only mitigated three
    out of many possible high-level attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Cockpit and Fleet approach combined with the threat model –
    the reduced attack vector view](img/B22100_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Cockpit and Fleet approach combined with the threat model – the
    reduced attack vector view
  prefs: []
  type: TYPE_NORMAL
- en: Mechanisms commonly supported by most systems, such as firewall rules, should
    be implemented to restrict access to Cockpit clusters exclusively tospecified
    IP address ranges. Similarly, access to Fleet clusters can be limited using firewalls,
    potentially originating from the Cockpit cluster itself and confined to certain
    IP spaces. It’s crucial to secure cluster access, particularly to the Cockpit,
    with **multi-factor authentication** (**MFA**) to significantly reduce the initial
    attack vector. Whenever feasible, perpetual tokens should be replaced with identity
    solutions to facilitate access without the need for secrets.
  prefs: []
  type: TYPE_NORMAL
- en: I strongly advise delving into the *Threat Model* document provided by **ControlPlane**.
    It includes detailed **attack trees** that illustrate how exploiting multiple
    vulnerabilities can have profound impacts. This comprehensive understanding is
    essential for effectively safeguarding your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The next section is about the fact that GitOps takes the approach that everything
    is in Git, but what about secrets? This section looks at how to store secrets
    securely in Git.
  prefs: []
  type: TYPE_NORMAL
- en: Committing everything to Git? What about Secrets?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a GitOps workflow, the idea of committing every piece of configuration to
    Git repositories is central. It ensures that the entire state of your infrastructure
    is declaratively represented and can be versioned, audited, and reviewed. However,
    this approach presents a challenge when it comes to handling secrets, such as
    passwords, tokens, and private keys. Storing such sensitive information plainly
    in Git repositories is not secure. This is where tools such as Sealed Secrets
    and External Secrets come into play, providing secure mechanisms to manage secrets
    in a GitOps workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Sealed Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sealed Secrets [*2*] is a Kubernetes controller and toolset, designed to encrypt
    secrets that can safely be stored in Git repositories. When you apply the sealed
    secret to your cluster, the Sealed Secrets controller decrypts it and creates
    a regular Kubernetes secret. This process allows you to manage your secrets’ life
    cycle through Git without exposing the sensitive content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubeseal` CLI tool on your local machine, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Key-pair**: Generate a key-pair or use the certificate from the deployed
    Sealed Secrets Operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Sealing Secrets**: Use the kubeseal CLI to encrypt your secret. The CLI generates
    a *SealedSecret* resource, which you can commit to your Git repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Automation with GitOps**: Integrate this process into your GitOps workflows.
    Whenever you update your sealed secrets in Git, your CI/CD pipeline can automatically
    apply them to your cluster.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: External Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: External Secrets [*3*] is an open source project that integrates external secret
    management systems such as **AWS Secrets Manager**, **Azure Key Vault**, and **Google
    Secret Manager** with Kubernetes. It allows you to securely inject secrets into
    your applications without having to expose them in your Git repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployment**: Deploy the External Secrets Operator in your Kubernetes cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Configuration**: Define an *ExternalSecret* resource that specifies the external
    secret store and the secret key. The operator fetches the secret from the external
    store and creates a Kubernetes secret in the cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Applying External Secrets**: Commit the *ExternalSecret* resource to your
    Git repository. The External Secrets Operator will automatically create or update
    the Kubernetes secret in your cluster based on the external source.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Integration with GitOps**: Incorporate External Secrets into your GitOps
    pipelines. Changes to the *ExternalSecret* definitions in your Git repo trigger
    the operator to sync the secrets, ensuring your cluster’s secrets are always up-to-date.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The choice of tools depends on various factors. For instance, if you don’t have
    a vault for storing secrets, keys, or certificates, then External Secrets might
    not be suitable. Initially, a connection from the External Secrets Operator to
    the Secret Store or **ClusterSecretStore** must be established. In our projects,
    we utilize managed identities to ensure this. Otherwise, you typically need an
    ID and a secret, which can be challenging to manage securely with GitOps at scale,
    as the ID and secret must be securely transferred to the cluster, possibly through
    a CI/CD pipeline. A significant advantage of External Secrets is its ability to
    fetch secrets at runtime without dependency on the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: However, access to a secrets manager through a vault is not always available.
    Therefore, the Sealed Secrets Operator, particularly in on-premises environments,
    is currently considered the industry standard.
  prefs: []
  type: TYPE_NORMAL
- en: Teams need to decide which option is the better choice. In my opinion, both
    options are solid and integrate very well into the GitOps ecosystem. This not
    only allows for the secure storage of secrets, keys, and certificates while embracing
    the GitOps approach but also opens up entirely new possibilities with GitOps at
    scale, such as deploying a pull secret across a specific registry. The platform
    team, by combining External Secrets and Kyverno, can deploy a secret across all
    clusters, and Kyverno distributes it across the namespaces. As a result, every
    team has the pull secret necessary to pull images from a central image registry.
    This enhances security since every image can be subjected to scanning, and it
    provides an overview of the images in operation.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging Sealed Secrets and External Secrets, you can maintain the GitOps
    principle of storing all configurations in Git while securely managing your secrets.
    These tools help you automate the management of secrets, keeping your infrastructure
    secure and your deployments consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Every tool that is added to the Kubernetes Service Catalog increases the likelihood
    that more security vulnerabilities will be introduced into the system. We will
    look at how to maintain your catalog in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will delve into enhancing security through GitOps
    and a **policy engine**. This approach enables proactive measures during deployment,
    determining what is permissible to deploy and identifying associated risks. This
    preemptive strategy ensures that only secure, compliant configurations make their
    way into production, thereby reinforcing your security posture.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging a policy engine for policy-as-code practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the contemporary landscape of software development, the way we ensure security
    and compliance within our systems has significantly evolved. A pivotal aspect
    of this evolution is the adoption of policy-as-code practices, which enable the
    integration of governance and security policies directly into the development
    and operational processes. Within this context, policy engines such as Kyverno
    [*4*] and **Open Policy Agent** (**OPA**) [*5*] play a crucial role. These tools
    empower organizations to define and enforce their security, compliance, and governance
    requirements as code, thereby ensuring consistent application and transparency
    across their infrastructures and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Kyverno and OPA are both powerful, flexible tools designed specifically to implement
    policy as code in Kubernetes environments and beyond. Kyverno focuses on simplifying
    Kubernetes security by using a user-friendly, Kubernetes-native syntax that allows
    developers to define and enforce security policies directly within their CI/CD
    pipelines. On the other hand, OPA is a more general-purpose policy engine that
    employs a highly flexible, domain-agnostic language called **Rego**, enabling
    the creation and implementation of fine-grained, context-aware policies across
    a variety of software systems.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating these policy engines into a GitOps-based workflow architecture significantly
    enhances security, as it ensures the continuous enforcement and validation of
    compliance. By adopting GitOps, teams can manage their infrastructure and application
    setups as code, creating a versioned, repeatable, and automatable environment.
    Incorporating Kyverno or OPA into this process means that changes to infrastructure
    or applications are automatically validated against predefined policies before
    being implemented. This ensures that all deployments comply with organizational
    security standards and that potential security vulnerabilities or configuration
    errors are proactively identified and remediated before they impact the production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Kyverno and OPA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this part, we explore how integrating tools such as Kyverno and OPA into
    the development and operational workflow not only enhances security and compliance
    but also promotes efficiency and speed in development cycles. *Automating* policy
    enforcement within the GitOps framework allows teams to deliver faster and more
    securely, leading to more robust, secure applications and infrastructures.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will focus on Kyverno to facilitate a better understanding, as I believe
    it’s a tool that users can comprehend more easily without the need to learn Rego.
    However, before delving into that, let’s examine the layer at which Kyverno operates
    and its integration with GitOps. *Figure 13**.3* will elaborate on these subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Kyverno operation layer and GitOps](img/B22100_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Kyverno operation layer and GitOps
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated, Kyverno operates across both layers, effectively acting as a
    gatekeeper. When you attempt to deploy something that violates its rules, Kyverno
    intervenes, causing the deployment to fail. However, Kyverno’s capabilities extend
    beyond this; it can also validate already-running services within the Kubernetes
    cluster or mutate resources. This versatility justifies positioning Kyverno between
    these layers, making it an advantageous choice.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging GitOps, you can deploy the Kyverno instance across every cluster
    in the fleet, ensuring consistent policy enforcement. Additionally, the *define
    once, deploy everywhere* approach facilitates multi-cluster deployment, streamlining
    the management of policies across various environments. By collaborating with
    the security team, you can implement different rulesets tailored to specific environments,
    enhancing the security and compliance of your deployments. This synergy between
    Kyverno and GitOps not only simplifies governance but also fortifies the infrastructure’s
    overall security posture.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at how it works in the praxis.
  prefs: []
  type: TYPE_NORMAL
- en: Hands on – let’s put theory into practice *[6]*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we establish a streamlined folder structure for the Kubernetes Service
    Catalog, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By initiating the deployment of `kyverno-applicationset.yaml`, you will target
    every fleet cluster identified by the `env=prod` or `env=development` labels.
    This deployment not only sets up the Kyverno tool across these clusters but also
    applies a specific set of policies from the `kustomize` folder to each one. In
    our illustration, we utilize a basic base folder; however, you have the flexibility
    to configure distinct folders – for instance, for different stages. These can
    be aligned with the cluster labels, enabling you to deploy the appropriate ruleset
    to the corresponding cluster. Such an arrangement proves beneficial for implementing
    more lenient policies in development clusters and stricter ones in production
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine an example policy that will be deployed across every fleet
    cluster matching the specified labels. We’ll focus on the `disallow-latest-tag.yaml`
    policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first part, we see the annotations, the `Best Practices` category, and
    then the version, the severity classification, which subject is affected, and
    the description of which negative consequences can result from it. I find it nice
    and compact, clear, and easy to configure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the subsequent section under specifications, we observe that the action
    is designated as `Audit` rather than `Enforce`, implying that it is not compulsory.
    Following this, two rules are established. The initial rule conducts a validation
    of the container’s tag using the `*:*` pattern, ensuring it adheres to specific
    criteria. Subsequently, the second rule escalates to the resource level, applying
    a broader scope by targeting the pods directly. It stipulates a constraint that
    the pattern with the `latest` tag must not be used, reinforcing the governance
    over the deployment practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In practice, it looks like this: when the rule is applied and an attempt is
    made to deploy a pod and its contained container with the `latest` tag, the deployment
    is blocked. Let’s try to deploy a Nginx pod with the `latest` image tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can get a Kyverno `policyreport` like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we violated the best practices policy, specifically the `disallow-latest-tag`
    policy.
  prefs: []
  type: TYPE_NORMAL
- en: I refer to this setup as a gatekeeper because it allows you to dictate, through
    simple rules, what can and cannot be deployed into the cluster. However, the capabilities
    of this setup extend further. For instance, you can configure Kyverno policies
    to enforce image signing or to ensure that only images from certain registries
    are allowed to be pulled, among other things. A policy engine is a powerful tool.
    In contrast to the gatekeeper, Kyverno or OPA also operates on already-deployed
    resources or resources that passed the gate and are therefore placed between the
    two layers, as shown in *Figure 13**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: When combined with the GitOps approach, it opens up new possibilities that transcend
    team boundaries, enhancing the security of projects. This integration not only
    streamlines the deployment processes but also ensures that the operational standards
    are consistently met, thereby bolstering the overall security posture of the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how to increase security on two different
    layers using two different tools.
  prefs: []
  type: TYPE_NORMAL
- en: Automating security scanning and compliance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In today’s fast-paced and security-conscious IT environment, maintaining continuous
    security and compliance is crucial. Automated security scanning and compliance
    are integral components of a robust cybersecurity strategy, especially in Kubernetes
    clusters where applications and services are dynamically scaled and updated. Here,
    we’ll discuss how the **KubeClarity** [*7*] or **Falco** [*8*] tool can be utilized
    to enhance your security posture in Kubernetes environments. The following image
    illustrates the level at which KubeClarity operates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – KubeClarity operation layer](img/B22100_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – KubeClarity operation layer
  prefs: []
  type: TYPE_NORMAL
- en: KubeClarity is an open source tool designed for security scanning and compliance
    analysis in Kubernetes environments. It provides a comprehensive overview of the
    potential vulnerabilities in your container images and Kubernetes configurations.
  prefs: []
  type: TYPE_NORMAL
- en: KubeClarity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s first understand how KubeClarity enhances security:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability scanning**: KubeClarity scans container images for known vulnerabilities,
    utilizing various databases and vulnerability tracking sources. It provides detailed
    insights into the security flaws within your images, along with their severity
    levels, enabling you to prioritize fixes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compliance assurance**: The tool checks your Kubernetes configurations against
    best practices and compliance standards, ensuring that your deployments adhere
    to industry and organizational security policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous monitoring**: KubeClarity continuously monitors your containerized
    applications for new vulnerabilities, providing real-time alerts and updates.
    This ongoing vigilance helps maintain a secure Kubernetes environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By integrating KubeClarity within a GitOps framework, an organization can significantly
    enhance its security and compliance posture, ensuring that its Kubernetes clusters
    are fortified against evolving threats. This adoption of GitOps principles allows
    for the automation of security scans and compliance checks, making these processes
    more consistent, efficient, and scalable. The proactive approach to security facilitated
    by KubeClarity not only protects your infrastructure but also fosters trust with
    customers by demonstrating a commitment to maintaining a secure and compliant
    environment. The continuous monitoring and automatic alignment with security policies
    enabled by GitOps ensure that any deviations are quickly detected and rectified,
    maintaining a robust defense against potential vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Falco
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Falco is an open source tool for real-time security monitoring and analysis,
    specifically designed for Kubernetes environments. It functions as an **intrusion
    detection system** (**IDS**), enabling teams to detect anomalous activities in
    their applications and infrastructures that could indicate security breaches or
    other threats. The following picture illustrates the level at which Falco operates.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Falco operation layer](img/B22100_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Falco operation layer
  prefs: []
  type: TYPE_NORMAL
- en: Falco operates at the system level (*Figure 13**.5*), monitoring the underlying
    Linux kernel functionality, or more precisely, the system-level activities of
    container orchestration platforms. It utilizes Linux kernel capabilities, particularly
    **extended BPF** (**Berkeley Packet Filter**) or traditional **system calls**
    (**syscalls**) monitoring through a kernel module, to observe and analyze system-wide
    events in real time. Falco can capture and evaluate system calls from applications
    running inside containers, identifying unusual or undesirable behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of integrating Falco with GitOps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated security monitoring**: By integrating Falco into a GitOps pipeline,
    security policies can be defined as code and automatically applied to every change
    in the infrastructure or applications, enabling continuous and automated monitoring
    of security standards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time alerts**: Falco can be configured to send real-time alerts when
    a defined rule is violated. In a GitOps environment, these alerts can facilitate
    swift responses to potential security incidents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency and compliance**: With GitOps, Falco configurations can be versioned,
    reviewed, and automatically deployed, ensuring consistent enforcement of security
    policies across different environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transparency and traceability:** All changes to Falco policies are recorded
    in Git, providing a clear audit trail. This promotes transparency regarding security
    monitoring and facilitates compliance with regulatory requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Falco into the GitOps strategy allows teams not only to enhance
    their security posture but also to adopt a proactive approach to identifying and
    responding to security threats in their Kubernetes environment.
  prefs: []
  type: TYPE_NORMAL
- en: However, every tool also brings potential risks with it, even if it is intended
    to increase security, which is why maintenance should not be neglected and attention
    should be paid to this when designing or selecting the tools. This is exactly
    what we will discuss briefly in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping your platform catalog up-to-date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The content of this section has been extensively covered already in [*Chapter
    5*](B22100_05.xhtml#_idTextAnchor081) under the *Bonus – maintenance with GitOps
    at scale and KSC* section. It serves as a reminder that with every tool added,
    the catalog grows, and a keen focus on security should be maintained.
  prefs: []
  type: TYPE_NORMAL
- en: When a **Common Vulnerabilities and Exposures** (**CVE**) threat is revealed
    and you opt for the Cockpit and Fleet approach, adopting GitOps at scale also
    facilitates a vulnerability-management-at-scale strategy. Therefore, this aspect
    should be considered particularly early in the development of a concept.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing such a strategy ensures that as your infrastructure expands, your
    approach to handling vulnerabilities scales accordingly. This proactive stance
    helps in quickly addressing security issues across the entire fleet, maintaining
    the integrity and security of your systems. Early integration of these practices
    into your conceptual framework is crucial to establishing a robust, scalable,
    and secure infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude the chapter, *Figure 13**.6* illustrates the stages or gates that
    the packet (application or service) must pass through, highlighting where various
    security mechanisms can intervene to scan the packet as thoroughly as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Security on multiple layers](img/B22100_13_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Security on multiple layers
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, a packet might pass through certain stages, hence the necessity
    for tools such as Falco and Kyverno to enable continuous scanning. These tools
    thrive on defined rules, which, fortunately, can be easily deployed with GitOps.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, it should have become clear that security doesn’t operate on
    just a single layer and shouldn’t be enforced by just one team. Security is a
    cultural issue that can be expanded with approaches such as GitOps and tools such
    as Argo CD at scale, which can include defining rulesets or policies. Security
    doesn’t stop with tools; it also encompasses how one handles sensitive data such
    as secrets and keeps third-party tools in the ecosystem up-to-date and secure.
    Effective security practices require collaboration across teams, continuous monitoring,
    and proactive management to ensure a robust and resilient infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll explore the integration of FinOps with GitOps to
    achieve sustainable, cost-effective operations. We’ll cover core FinOps principles,
    cost forecasting, optimization, and understanding the carbon footprint. Additionally,
    we’ll look at future trends in GitOps, including AI-driven automation.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1] [https://github.com/argoproj/](https://github.com/argoproj/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2] [https://github.com/bitnami-labs/sealed-secrets](https://github.com/bitnami-labs/sealed-secrets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3] [https://external-secrets.io/latest/](https://external-secrets.io/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4] [https://kyverno.io](https://kyverno.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5] [https://www.openpolicyagent.org](https://www.openpolicyagent.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6] [https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes/tree/main/chapter13](https://github.com/PacktPublishing/GitOps-for-Kubernetes-Deployment/tree/main/chapter13)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7] [https://github.com/openclarity/kubeclarity](https://github.com/openclarity/kubeclarity)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[8] [https://falco.org](https://falco.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
