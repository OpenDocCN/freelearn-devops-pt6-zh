- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll take a closer look at containers, dive deeper into container
    technology and the container ecosystem, and discover tooling that is commonly
    used.
  prefs: []
  type: TYPE_NORMAL
- en: An old Chinese proverb states, “*What I hear, I forget. What I see, I remember.
    What I do,* *I understand*.”
  prefs: []
  type: TYPE_NORMAL
- en: Starting with this chapter, we will get our hands dirty and try building images
    and running containers to get a deeper understanding and first-hand practical
    experience. Even though KCNA is a multi-choice exam, it is very important to do
    things first-hand as this experience will help you in the future. **Don’t just
    read the code snippets – make sure you execute them completely, especially if
    you have no previous experience with containers.** You’ll need any computer running
    a recent version of Linux, Windows, or macOS and a working internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring container technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Docker and running containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building container images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the example files and code snippets used in this chapter have been uploaded
    to this book’s GitHub repository at [https://github.com/PacktPublishing/Becoming-KCNA-Certified](https://github.com/PacktPublishing/Becoming-KCNA-Certified).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker has been around for quite a few years, so you may have heard about it
    before. For many people, the name *Docker* itself is synonymous with *container*.
    However, there are so many things called *Docker* that it is easy to get confused:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Inc.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Engine**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dockerd** (**Docker daemon**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker CLI**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Hub**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Registry**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Swarm**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Compose**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Desktop**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dockershim**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s clarify each one.
  prefs: []
  type: TYPE_NORMAL
- en: For starters, *Docker Inc.* (as a company) did not invent the technology behind
    containers, but it created easy-to-use tools from the list that helped kickstart
    broader container adoption. The company was founded in 2008 and was initially
    called dotCloud.
  prefs: []
  type: TYPE_NORMAL
- en: '*Docker Engine* is an open source software bundle for building and containerizing
    applications. It is a piece of client-server software that consists of a daemon
    service known as `docker`.'
  prefs: []
  type: TYPE_NORMAL
- en: Containerization
  prefs: []
  type: TYPE_NORMAL
- en: Containerization is the process of packaging software application code with
    dependencies (libraries, frameworks, and more) in a container. Containers can
    be moved between environments independently of the infrastructure’s operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: When you install a Docker engine, you essentially install two things – the `dockerd`
    service and the CLI. `dockerd` constantly runs and listens for commands to do
    any operations with containers such as starting new, stopping existing, restarting
    containers, and so on. Those commands might be issued using the `docker` CLI,
    or a common tool such as `curl`. We will be using the `docker` CLI in this chapter’s
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Next on our list is *Docker Hub* ([https://hub.docker.com/](https://hub.docker.com/)),
    a public container image registry. As you may recall, a container image is a predefined
    static template that we use as a base for starting new containers. Now, where
    do we get the images from? Docker Hub can be one such place. It is an online repository
    service offered by Docker Inc. where thousands of container images with different
    environments (**Ubuntu**, **Centos**, **Fedora**, and **Alpine Linux**) as well
    as popular software such as **Nginx**, **Postgres**, **MySQL**, **Redis**, and
    **Elasticsearch** are hosted. Docker Hub allows you to find, share, and store
    container images that can be easily pulled (downloaded) over the internet to the
    host where you need to create a new container. It’s worth mentioning that Docker
    Hub is not the only such service – others include **Quay** ([https://quay.io/](https://quay.io/)),
    **Google Container Registry** ([https://cloud.google.com/container-registry](https://cloud.google.com/container-registry)),
    and **Amazon Elastic Container** **Registry** ([https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to *Docker Registry* which is today managed at CNCF as a project
    named *Distribution*. It is an open source server-side application that can be
    used for storing and distributing Docker images. The main difference compared
    to Docker Hub is that Docker Registry is a piece of software that you can just
    take, install, and run within your organization at no cost, whereas Docker Hub
    is a *registry as a service* with some additional paid features. Docker Registry
    can be used to store and serve container images with software that your *dev*
    teams are developing.
  prefs: []
  type: TYPE_NORMAL
- en: '*Docker Swarm* is next on our list and its purpose is cluster management and
    container orchestration. Swarm is similar to Kubernetes; however, it is only compatible
    with Docker Engine (meaning no other container runtimes are supported) and has
    significantly fewer features and limited customizations compared to Kubernetes.
    That is the reason it did not receive such wide adoption as Kubernetes did.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Docker Compose* is another Docker tool that allows you to define and share
    multi-container applications specifications. With Compose, you can define multiple
    containers that need to communicate with each other as a part of one application
    in a single **YAML** formatted file. For example, you can bootstrap a *Django*
    web application with a database running in two containers and define that the
    database has to start first, as well as expose certain ports of containers. Compose
    might be handy for some local development with Docker, but it is not compatible
    with Kubernetes, so we are not going to cover it in any more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Docker Desktop* is a combination of Docker Engine, the `docker` CLI, Docker
    Compose, Kubernetes, and some other tools for Windows/macOS that comes with its
    own **graphical user interface** (**GUI**). That’s right – Docker Desktop even
    packages Kubernetes and K8s clients for local development. Docker Desktop is free
    for non-commercial use but paid if used in organizations. There is also a beta
    version available for Ubuntu and Debian Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Dockershim* is a software compatibility layer that was created to allow Kubernetes
    (its *kubelet* component, to be precise) to communicate with `dockerd` (Docker
    daemon). As you might remember from the previous chapters, Kubernetes does not
    have its own container runtime (software for performing basic operations with
    containers such as starting, stopping, and deleting). In the early versions, Kubernetes
    only supported Docker to operate containers. As the container ecosystem evolved
    with `dockerd` did not have an OCI standardized interface, a translation layer
    between Kubernetes and `dockerd` called **Dockershim** was created. *Dockershim*
    has been deprecated since Kubernetes version 1.20 and with the 1.24 release, it
    has been completely removed from K8s.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ve reached the end of our list. Despite the number of alternatives
    that have appeared over the years, Docker Engine and the Docker tooling are still
    actively used by thousands of development teams and organizations across the globe.
    The following diagram demonstrates how, using the Docker CLI, we can communicate
    with the Docker daemon, which fetches the images from Docker Registry to create
    containers locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Docker architecture](img/B18970_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Docker architecture
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will install some of the Docker tools to see it
    in action and finally get our hands on containers.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring container technology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we move on to the practical part, we still need to figure out the technology
    behind containers and who created it. The technology behind Linux containers was
    developed quite a long time ago and is based on two fundamental kernel features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**cgroups** (**control groups**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Namespaces**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cgroups
  prefs: []
  type: TYPE_NORMAL
- en: cgroups is a mechanism that allows processes to be organized into hierarchical
    groups. How resources (CPU, memory, disk I/O throughput, and so on) are used by
    those groups can be limited, monitored, and controlled.
  prefs: []
  type: TYPE_NORMAL
- en: '*cgroups* were initially developed by engineers at Google and first released
    in 2007\. Since early 2008, cgroups functionality was merged into the Linux kernel
    and has been present ever since. In 2016, a revised version of cgroups was released
    and it is now known as cgroups version 2.'
  prefs: []
  type: TYPE_NORMAL
- en: Even before cgroups, in 2002, the Linux namespaces feature was developed.
  prefs: []
  type: TYPE_NORMAL
- en: Linux kernel namespaces
  prefs: []
  type: TYPE_NORMAL
- en: This Linux feature allows you to partition kernel resources in such a way that
    one set of processes sees one set of resources while another set of processes
    sees a different set of resources. Linux namespaces are used to isolate processes
    from each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different types of namespaces, each with its own properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`root` (superuser) but be limited to its own namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` thanks to namespaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network namespace**: This allows you to run an independent network stack
    with its own routing table, IP addresses, connection tracking, and more for a
    set of processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mount namespace**: This allows you to have independent mount points within
    a namespace. This means a process in a namespace can have different mounts without
    it affecting the host filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interprocess communication (IPC)**: This allows you to isolate Linux interprocess
    communication mechanisms such as shared memory, semaphores, and message queues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UNIX Time-Sharing (UTS)**: This allows you to have different hostnames and
    domain names for different processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may sound complicated, but don’t worry – namespaces and cgroups are not
    part of the KCNA exam, so you don’t need to know about every namespace and what
    they do. However, since those are at the core of container technology, it is helpful
    to have an idea, plus you are always given bonus points if you can explain how
    containers work under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, *cgroups* and *namespaces* are the building blocks of containers.
    cgroups allow you to monitor and control computational resources for a process
    (or a set of processes), whereas namespaces isolate the processes at different
    system levels. Both functionalities can also be used without containers, and there’s
    plenty of software that makes use of this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Enough theory – let’s get some practice! In the next section, we will install
    Docker tooling and start our first container.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker and running containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are running Windows or macOS, you can download and install Docker Desktop
    from https://docs.docker.com/desktop/. If you are running a recent version of
    Ubuntu Linux, there is a version of Docker Desktop for you too. If you are running
    another Linux distribution, you’ll have to install Docker Engine. You can find
    detailed instructions for your distribution at https://docs.docker.com/engine/install/.
    Please pick a *stable* release for installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you restart your computer, make sure that Docker Desktop is running. On
    Linux, you might have to execute the following code in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want it to start automatically in case of a system restart, you can
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of the OS or tooling that you’ve installed (Desktop or Engine), it
    will come with the Docker CLI that we will be using, which is simply called `docker`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s make sure that Docker was installed correctly and running by checking
    the version. Open the terminal and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you are on Linux and you have not added your user to the docker group after
    the installation, you’ll have to call the Docker CLI with superuser privileges,
    so all docker commands should be prefixed with `sudo`. For the preceding example,
    the command will be `sudo` `docker --version`.
  prefs: []
  type: TYPE_NORMAL
- en: Your output might look slightly different – perhaps you’ll have a newer version
    installed. If the preceding command did not work, but Docker is installed, make
    sure that Docker Desktop (if you’re on macOS or Windows) or the Docker daemon
    (if you’re on Linux) is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s start our first container with Ubuntu 22.04:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output that you’ll see should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Wow! We are now running `bash` inside an Ubuntu container. It might take a few
    seconds for the image to be downloaded, but as soon as it is ready, you’ll see
    the command-line prompt running as a `root` user inside a newly spawned container.
  prefs: []
  type: TYPE_NORMAL
- en: So, what exactly happened when we called `docker run`?
  prefs: []
  type: TYPE_NORMAL
- en: '`docker run` executes a command inside a new container; it requires the name
    of the container image where the command will be executed (`ubuntu` in the preceding
    example), optionally the tag of the image (`22.04` here), and the command to be
    executed (simply `bash` here).'
  prefs: []
  type: TYPE_NORMAL
- en: The `-i` argument is the same as `--interactive`, and it means we’d like to
    be running our command in interactive mode. `-t`, which is the same as `--tty`,
    will allocate a pseudo-TTY (emulated terminal).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may remember, images are templates for container environments. We have
    asked for an `ubuntu` environment tagged with version `22.04`. In the first few
    lines of output, we saw that the image was not found locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the requested image with a particular tag was not downloaded previously,
    it will be automatically downloaded (pulled) from the Docker Hub library and you
    should be able to see the download progress while it is happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s exit the container and try running it again. Simply type `exit`
    in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, execute the same command we did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Was it faster this time? Yes, because we already have the `ubuntu:22.04` image
    cached locally, so we don’t need to download it again. Therefore, the container
    was started immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice that the hostname after `root@` is different this time – `e5d98a473adf`
    versus `d752b475a54e`? *(Note: you will see your unique container names here.)*
    This is because we have started a new container that is based on the same `ubuntu`
    image. When we start a new container, we don’t modify the read-only source image;
    instead, we create a new writable filesystem layer on top of the image. The following
    diagram shows such a layered approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Container layers](img/B18970_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Container layers
  prefs: []
  type: TYPE_NORMAL
- en: When we start a container, we add a new layer, which allows modifications to
    be made to the container image copy. This way, we can create any number of containers
    from the same base image without modifying the initial read-only image layer.
    The major benefit of this approach is that **in container layers, we only store
    the difference with the image layer**, which means significant disk space savings
    when used at scale.
  prefs: []
  type: TYPE_NORMAL
- en: The images can also consist of multiple layers, where one layer might be originating
    from another one. In the following section, we will learn how to build new images
    and include the software that we like inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feel free to explore our container environment and `exit` it when you’re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When we called `exit` in the first container, it exited; later, when we called
    `docker run` again, a new container was created. Now that both containers have
    exited, we have an image layer stored on the disk, as well as two different container
    layers based on the `ubuntu:22.04` base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the container layers only keep track of differences from the base image,
    we won’t be able to remove the base image until all the container layers have
    been deleted. Let’s get the list of images we have locally by running the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we attempt to delete the `ubuntu:22.04` image with the `docker rmi` command,
    we’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also execute the `docker ps` command to see all *running* containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: An empty table means no containers are currently running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can execute `docker ps --all` to see all the containers on the
    local system, including those that have exited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Try removing those exited containers with `docker rm` `CONTAINER ID`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the image should be deleted too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`sha256` are the digests of image layers; they are unique and immutable identifiers.
    If we assign a different tag to our `ubuntu` image instead of `22.04` and try
    to pull (download) the same image from Docker Hub again, Docker will recognize
    that we already have an image with this digest and will do nothing except tag
    it again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try one more thing – pulling another Docker image without any tags. If
    you simply `pull` the image, no container is going to be started, but this will
    save download time the next time a new container is started from that image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, if we don’t specify the tag explicitly, `latest` will be taken
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we will learn more about the meaning of the `latest`
    tag, tagging in general, and building images with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Building container images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how to start containers and pull images, we’ll learn what
    should be done to create new container images. Since the image layer is immutable,
    you can create new images with the software of your choice to build an image by
    adding new layers on top of existing ones. There are two ways this can be done
    with Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: Interactively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The interactive way is to create an image from an existing container. Let’s
    say you start a container with the Ubuntu 22.04 environment, install additional
    packages, and expose port `80`. To create a new image, we can use the `docker`
    `commit` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The image name will be in the `REPOSITORY:TAG` format. If no tag is given, then
    `latest` will be added automatically. If no repository was specified, the image
    name will be a **unique identifier** (**UUID**). The tag, as well as the name
    (which is the same as the image repository’s name), can be changed or applied
    after the build.
  prefs: []
  type: TYPE_NORMAL
- en: While the interactive method is quick and easy, it should not be used under
    normal circumstances because it is a manual, error-prone process and the resulting
    images might be larger with many unnecessary layers.
  prefs: []
  type: TYPE_NORMAL
- en: The second, better option for building images is using Dockerfiles.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: A Dockerfile is a text file containing instructions for building an image. It
    supports running shell scripts, installing additional packages, adding and copying
    files, defining commands executed by default, exposing ports, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at a simplistic Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you’ve probably already guessed, the `FROM` instruction defines the base
    image with a tag for the image we are going to build. The base image can also
    be one of our previously built local images or an image from the registry. `RUN`
    instructs to execute `apt-get update` and then install `curl` and `vim` packages.
    `LABEL` is simply any metadata you’d like to add to the image. If you copy the
    preceding contents to a file called `Dockerfile`, you’ll be able to build a new
    image by calling `docker build` in the same folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With `-t myubuntuimage`, we have specified the name of the image without the
    actual tag. This means that the `latest` tag will be applied to the image by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things we need to clarify about the `latest` tag, as it can
    be misleading:'
  prefs: []
  type: TYPE_NORMAL
- en: '`latest` is applied by default if no tag is given during the build'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`latest` is pulled by default if no tag is given during image download or container
    run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`latest` is not updated dynamically; you can tag any image as `latest` – even
    an older version of the same image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the best practice is to tag images with something more descriptive
    rather than relying on `latest`. For instance, an incrementable version of the
    packaged application (v.0.32, v.1.7.1, and so on) can be used as a tag or even
    the build timestamp. The timestamp allows us to determine when the image was built
    without the need to inspect each image metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly go back to the instructions supported in Dockerfiles. We’ve already
    learned about `FROM`, `RUN`, and `LABEL`, but there are more:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ADD`: This is used to copy files and directories *into* the Docker image (from
    a build location or remote URLs).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY`: This is used to copy files *within* the Docker image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD`: This is used to define the default executable of a Docker image (only
    the last `CMD` instruction will be respected). `CMD` can be easily overridden
    at container runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENTRYPOINT`: This is similar to `CMD` and allows us to define the executable
    of an image when a container is started. It can ban be used together with `CMD`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPOSE`: This tells us that the application in an image will be listening
    on a particular network port at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENV`: This is used to set any environment variables in the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USER`: This sets the username or `RUN`, `CMD`, or `ENTRYPOINT` instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VOLUME`: This is used to create a mount point with the given name and marks
    it for use with externally mounted volumes (for example, from the host where the
    container will be started).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WORKDIR`: This sets the working (current) directory for `RUN`, `CMD`, and
    `ENTRYPOINT` instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A quick note about `CMD` and `ENTRYPOINT`: they are similar, yet not the same.
    We could specify either `CMD`, `ENTRYPOINT`, or both in our Dockerfile. If we
    specify both, then `CMD` acts as a parameter for `ENTRYPOINT`. Since `CMD` is
    a bit easier to override at runtime, then typically, `ENTRYPOINT` is the executable
    and `CMD` is the argument in such scenarios. For example, we could set `ENTRYPOINT`
    to `/bin/cat` and use `CMD` to give a path to a file we want to concatenate (`/etc/hosts`;
    `/etc/group`, and so on). For many public images from Docker Hub, `ENTRYPOINT`
    is set to `/bin/sh -c` by default.'
  prefs: []
  type: TYPE_NORMAL
- en: This list is not meant to be a complete reference of instructions supported
    by Dockerfiles, but it mentions the most used instructions that cover 99% of scenarios.
    In addition, you don’t often build containers on your laptop or local workstation;
    instead, you use a modern CI/CD system or an automated build from Docker Hub as
    an alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s understand what a development workflow might look like when containers
    are in use:'
  prefs: []
  type: TYPE_NORMAL
- en: Software developers write application code in their language of choice – for
    instance, **Python**, **Java**, **Ruby**, **Node.js**, **Golang**, or anything
    else.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to learn a new programming language – any software that runs
    in a Linux environment will run inside a container too.
  prefs: []
  type: TYPE_NORMAL
- en: The code is tested and pushed to a GitHub repository or other version control
    system. The CI/CD or a third-party solution is triggered when a change is made
    to the source code; the application is packaged inside a container image according
    to the defined Dockerfile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dockerfile instructions will be used to copy the code and run and install it
    inside the container image layer. These instructions vary, depending on the language
    and the OS environment that’s chosen. For example, a Node.js application will
    likely require `yarn install` to run, whereas a Python application will be installed
    with the help of a `pip` command, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image is built, tagged, and pushed (uploaded) to an image registry. This
    might be, for example, a private repository in Docker Hub, a repository offered
    by a cloud provider, or even your own registry maintained within the company.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, the image can be downloaded and run by a container orchestrator
    such as Kubernetes, by a server with a container runtime, or simply by other team
    members with the Docker tooling they have installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you may remember, one of the main features of containers is *portability*
    – a container running on one host will also run on another host. This means that
    you can have a container image with Alpine Linux and run it on both your laptop
    with Fedora Linux or on an Ubuntu-based Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: But wait – can we run Linux containers on Windows or vice versa? Not really.
    First, we need to distinguish between Linux containers and Windows containers.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Everything in this book and the KCNA exam itself is only about Linux containers.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you are running Docker Desktop on Windows, it is using a minimal **Linuxkit**
    virtual machine in the background. Windows containers are different and might
    use one of the two distinct isolation modes (**WSL 2** or **Hyper-V**) available
    today in the Microsoft operating system. Docker Desktop allows you to switch between
    *Windows containers* and *Linux containers* if you are running on Windows. However,
    keep in mind that more than 90% of the servers in the world run Linux, so unless you
    are going to run Windows-only applications in containers, you are fine to only
    learn about and use Linux containers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gained experience with (Linux) containers and learned that
    the technology behind containers has existed for many years and is based on *cgroups*
    and kernel *namespaces*.
  prefs: []
  type: TYPE_NORMAL
- en: Docker has introduced tooling that’s aimed at developers and engineers looking
    for a universal and simple way to package and share applications. Before containers,
    it has often been the case that an application could work in the development environment
    but fail in the production environment because of unmet dependencies or incorrect
    versions that have been installed. Containers have fixed this problem by bundling
    the application with all the dependencies and system packages in a template known
    as a container image.
  prefs: []
  type: TYPE_NORMAL
- en: Container images can be stored in registries that support private and public
    repositories and allow you to share them with different teams. **Docker Hub**,
    **Quay**, and **Google Container Registry** (**GCR**) are some of the most well-known
    container image registries today that can be reached over the internet. An image
    that’s pushed (uploaded) to the registry can then be pulled (downloaded) by a
    container orchestrator such as Kubernetes or simply by a server with a container
    runtime over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Images are used to create containers, so a container is a running instance of
    an image. When a container is started with a writable filesystem, a layer is created
    on top of the immutable image layer. Containers and images can have multiple layers
    and we can start as many containers as we want from a single image. Containers
    are more lightweight compared to VMs and are very fast to start.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that to build a container image with Docker, we can leverage
    an interactive or Dockerfile method. With Dockerfile, we define a set of instructions
    that will be executed to build an image with our containerized application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue exploring containers by learning about
    the runtimes and pluggable interfaces provided by Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter’s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following features describes containers (pick two)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Portability between environments
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Large image size
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Small image size
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: High security
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is true (pick two)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Applications are easy to package in containers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Applications are easy to package in virtual machines
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Container images are easy to share
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: VM images are easy to share
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What programming language do developers have to learn to run their code in containers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dockerlang
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Golang
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None – containers allow the same languages that are supported by the OS environment
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following problems do containers address (pick two)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unmet dependencies between environments
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Bugs in application code
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Need to test application code
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Long VM startup times
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is used by containers (pick two)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cgroups`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`hwmon`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`acpi`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kernel namespaces`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following can be used to share container images (pick two)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker Hub
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker Swarm
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker Registry
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is true about container images (pick two)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They can only be built with Dockerfiles
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: They include immutable filesystem layers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The newest image is always tagged as the latest
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: They can be built interactively
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following applies when starting a new container (pick two)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new writable filesystem layer is created
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The requested image is always pulled
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An image is pulled if the requested tag (SHA digest) is not found locally
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A new Linux kernel is loaded
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is true about container image tags (pick two)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every image must have tags
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The latest tag is applied automatically on build, unless overridden
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The same image cannot have multiple tags
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The same image can have multiple names (repositories) and tags
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a new container be created using Docker tooling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`docker run`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`docker exec`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`docker spawn`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`docker launch`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While this chapter provided an insight into the container ecosystem and the
    knowledge needed to pass the KCNA exam, it doesn’t cover all the features of Docker
    tooling nor describes cgroups and namespaces in detail. If you’d like to go the
    extra mile, you are encouraged to check out the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'cgroups v1: [https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt](https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Namespaces: [https://man7.org/linux/man-pages/man7/namespaces.7.html](https://man7.org/linux/man-pages/man7/namespaces.7.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting started with Docker: [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Best practices for writing Dockerfiles: [https://docs.docker.com/develop/develop-images/dockerfile_best-practices/](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
