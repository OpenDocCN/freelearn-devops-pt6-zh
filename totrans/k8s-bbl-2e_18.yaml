- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Security in Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 中的安全性
- en: Authentication and authorization are the cornerstones of modern software systems
    in terms of providing the necessary identity management and access management,
    respectively. Many people confuse these two terms, despite the fact that they
    are quite different processes. Authentication has to do with the verification
    of the identity of a user, normally through some kind of mechanism like usernames
    and passwords, while authorization is all about what an authenticated user can
    access or do within a system. Authentication always comes first, after which authorization
    would take place in order for the system to be interacted with by verified users.
    Kubernetes extends this further with another model called **Role-Based Access
    Control** (**RBAC**), which allows an administrator to define roles with certain
    privileges and then assign those roles to users, hence effectively implementing
    the principle of least privilege and allowing fine-grained access control.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 认证和授权是现代软件系统的基石，分别提供必要的身份管理和访问管理。尽管这两个过程有所不同，但许多人仍然混淆这两个术语。认证是指验证用户身份的过程，通常通过用户名和密码等机制来实现；而授权则是指一个已认证的用户可以访问或执行系统中的哪些操作。认证总是优先于授权，只有通过认证的用户，系统才会根据授权进行交互。Kubernetes
    在此基础上进一步扩展了另一个模型，称为**基于角色的访问控制**（**RBAC**），该模型允许管理员定义具有特定权限的角色，并将这些角色分配给用户，从而有效地实施最小权限原则，并实现细粒度的访问控制。
- en: Apart from Identity and Access Management, Kubernetes has a number of other
    security mechanisms to harden the rest of the components further. Being the most
    mature and widely adopted container orchestration platform, the design of Kubernetes
    places a lot of emphasis on the security of a wide range of components within
    clusters, nodes, containers, networks, and applications through the mitigation
    of risks at many layers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了身份和访问管理，Kubernetes 还拥有许多其他的安全机制，进一步加强其他组件的安全性。作为最成熟和最广泛采用的容器编排平台，Kubernetes
    的设计非常重视集群、节点、容器、网络和应用程序中各种组件的安全性，通过在多个层次上缓解风险来确保安全。
- en: Next, this chapter goes into some of the basic Kubernetes security concepts,
    from the different ways in which the system can flexibly authenticate-in X509
    client certificates or tokens from OpenID Connect. In specialized cases, for example,
    the integration with LDAP, Kubernetes provides additional options. For example,
    the possibility of using an authenticating proxy or webhooks is also recommended.
    Then we will review the **RBAC** model from the platform that gives administrators
    control over access to resources in the cluster and allows them to manage users
    and groups along with ServiceAccounts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，本章将介绍一些基础的 Kubernetes 安全概念，包括系统灵活认证的不同方式——如 X509 客户端证书或来自 OpenID Connect
    的令牌。在一些特殊情况下，例如与 LDAP 的集成，Kubernetes 提供了额外的选项。例如，使用认证代理或 Webhooks 的可能性也是推荐的。接着，我们将回顾平台中的**RBAC**模型，它赋予管理员对集群中资源访问的控制权，并允许他们管理用户、组和
    ServiceAccounts。
- en: 'We will also introduce one advanced feature in Kubernetes: Admission Controllers.
    An Admission Controller enforces security policies at the point of resource admission
    to validate and control resources before they enter the cluster. Admission controllers
    provide an additional layer of defense by governing resource requests through
    the enforcement of policies on the creation and modification of resources.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍 Kubernetes 中的一个高级功能：Admission Controllers。Admission Controller 在资源进入集群时执行安全策略，以验证和控制资源。Admission
    Controllers 通过在资源创建和修改时强制执行策略，为资源请求提供了额外的防护层。
- en: Pods and containers themselves need to be secured, as these are the runtimes
    of the workloads or applications that could interact with sensitive information.
    Kubernetes provides a set of `securityContext` options that enable administrators
    to declare particular security settings for containers; this includes forcing
    containers to run as non-root. Equally important will be network security, and
    we’ll discuss how NetworkPolicies provide a mechanism to segregate and secure
    pod communication inside the cluster by controlling traffic flow at a granular
    level.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 和容器本身需要得到保护，因为它们是工作负载或应用程序的运行时，可能会与敏感信息交互。Kubernetes 提供了一套 `securityContext`
    选项，使管理员能够为容器声明特定的安全设置；这包括强制容器以非 root 用户身份运行。同样重要的是网络安全，我们将讨论如何通过 NetworkPolicies
    提供一种机制，通过控制流量流动来在集群内隔离并保护 Pod 通信，从而实现细粒度的安全管理。
- en: We’ll then move to container runtime security. We will look at gVisor and Kata
    Containers as options for runtime, which introduce more security boundaries between
    either a user-space kernel to intercept system calls or a lightweight VM environment
    per container, respectively, which provides the speed of containers but the security
    of a VM.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将讨论容器运行时的安全性。我们将研究 gVisor 和 Kata Containers 作为运行时的选项，它们分别通过用户空间内核拦截系统调用或为每个容器提供轻量级虚拟机环境，在提供容器速度的同时增强虚拟机的安全性。
- en: Lastly, and most importantly, private registry credentials hold the key to guaranteeing
    security around container images inside the cluster. We will go through how Kubernetes
    handles these credentials safely – ensuring that only authorized components have
    access to them. By the end of this chapter, you will have a deeper understanding
    of these advanced security concepts and tools in Kubernetes. You will see precisely
    how to enhance your cluster’s security posture, reduce risks, and have the best
    defense against possible vulnerabilities. With such measures, you will be able
    to secure your Kubernetes deployments at every layer, from identity management
    right through to runtime isolation, and reinforce the robustness of your containerized
    applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也是最重要的，私有注册表凭证是确保集群内部容器镜像安全的关键。我们将逐步讲解 Kubernetes 如何安全地处理这些凭证——确保只有经过授权的组件可以访问它们。到本章结束时，您将更深入地理解
    Kubernetes 中的这些高级安全概念和工具。您将确切了解如何增强集群的安全性，降低风险，并为可能的漏洞提供最好的防御。通过这些措施，您将能够在每一层保护您的
    Kubernetes 部署，从身份管理到运行时隔离，并增强容器化应用程序的稳健性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Authentication and Authorization – User Access Control
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证与授权 —— 用户访问控制
- en: Admission Control – Security Policies and Checks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入场控制 —— 安全策略和检查
- en: Securing Pods and Containers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护 Pods 和容器
- en: Managing Secrets and Registry Credentials
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理机密和注册表凭证
- en: Technical Requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的内容：
- en: A Kubernetes cluster to be deployed. We recommend using a multi-node o*r* cloud-based
    Kubernetes cluster.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个待部署的 Kubernetes 集群。我们推荐使用多节点的*云端* Kubernetes 集群。
- en: The Kubernetes CLI (`kubectl`) installed on your local machine and configured
    to manage your Kubernetes cluster.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已在您的本地机器上安装并配置 Kubernetes CLI（`kubectl`），用于管理您的 Kubernetes 集群。
- en: Basic Kubernetes cluster deployment (local and cloud-based) and `kubectl` installation
    were covered in *Chapter 3*, *Installing Your First Kubernetes Cluster*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的*第三章*《安装您的第一个 Kubernetes 集群》已涵盖了基础的 Kubernetes 集群部署（本地和云端）以及 `kubectl` 的安装。
- en: The previous chapters (*15*, *16*, and *17*) of this book have provided you
    with an overview of how to deploy a fully functional Kubernetes cluster on different
    cloud platforms and install the requisite CLIs to manage them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前几章（*第15章*、*第16章*、*第17章*）已经为您提供了如何在不同的云平台上部署功能完备的 Kubernetes 集群的概述，并安装了管理它们所需的
    CLI 工具。
- en: 'You can download the latest code samples for this chapter from the official
    GitHub repository: [https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter18](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter18).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从官方 GitHub 仓库下载本章的最新代码示例：[https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter18](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter18)。
- en: Authentication and Authorization – User Access Control
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证与授权 —— 用户访问控制
- en: It gives grounds for access control in ensuring that only authenticated and
    authorized users can use Kubernetes resources. Authentication verifies the identity
    of a user, while authorization decides what an authenticated user is allowed to
    do within the cluster. Kubernetes offers flexibility in authenticating via X509
    certificates, OpenID Connect, token-based, and other approaches. Coupled with
    the verification process, RBAC does offer fine granular control over what users
    can do, thus helping administrators manage a wide range of permissions efficiently
    – a subject that will be dealt with in further detail in the following sections.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 认证为访问控制提供了依据，确保只有经过认证和授权的用户才能使用 Kubernetes 资源。认证验证用户的身份，而授权则决定认证用户在集群内可以执行的操作。Kubernetes
    在认证方面提供了灵活性，支持 X509 证书、OpenID Connect、基于令牌等多种方式。结合验证过程，RBAC 确实提供了细粒度的控制，帮助管理员高效地管理各种权限——这是接下来章节将详细讨论的内容。
- en: Let us start with authentication in the next section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在下一部分开始讲解认证。
- en: Authentication and User Management
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证和用户管理
- en: The Kubernetes API server provides RESTful endpoints for managing the Kubernetes
    cluster and acts as the frontend to the shared state of the cluster. All interactions
    with the cluster, from users to internal components, are channeled through the
    Kubernetes API server, which acts as a frontend to the cluster’s shared state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 服务器提供用于管理 Kubernetes 集群的 RESTful 端点，并充当集群共享状态的前端。所有与集群的交互，从用户到内部组件，都会通过
    Kubernetes API 服务器进行，它充当集群共享状态的前端。
- en: Let us see how the authentication mechanism works in Kubernetes in the next
    sections.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的部分中看看 Kubernetes 中的认证机制是如何工作的。
- en: The authentication workflow in Kubernetes
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes 中的认证工作流
- en: 'Just like a high-security facility, your Kubernetes cluster needs robust security
    measures to protect its resources. This involves a layered approach with several
    key components working together, as shown in the following figure:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一个高安全性设施一样，你的 Kubernetes 集群需要强大的安全措施来保护其资源。这涉及一种分层的方法，其中多个关键组件共同工作，如下图所示：
- en: '![](img/B22019_18_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_18_01.png)'
- en: 'Figure 18.1: Request to Kubernetes API goes through several stages (source:
    https://kubernetes.io/docs/concepts/security/controlling-access/)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.1：请求 Kubernetes API 会经过多个阶段（来源：https://kubernetes.io/docs/concepts/security/controlling-access/）
- en: '**Authentication**: This acts as the first line of defense, verifying the identity
    of anyone trying to access the Kubernetes API server. Imagine it like a security
    guard checking IDs at the entrance. Users might use passwords, tokens, or special
    certificates to prove they’re authorized.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：它作为第一道防线，验证任何试图访问 Kubernetes API 服务器的人的身份。可以把它想象成门口的保安检查身份。用户可能使用密码、令牌或特殊证书来证明他们已获得授权。'
- en: '**Authorization**: Once someone’s identity is confirmed, authorization determines
    what they can actually do within the cluster. Think of it as granting specific
    access levels. Users might have permission to view resources, but not modify them,
    or they might be authorized to create new resources but only in specific areas.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：一旦某人的身份被确认，授权决定了他们在集群内实际上能做什么。可以把它理解为授予特定的访问权限。用户可能有权限查看资源，但不能修改它们，或者他们可能被授权在特定区域内创建新资源。'
- en: '**Admission Control**: This stage adds an extra layer of scrutiny. Imagine
    it like a security scanner at the entrance. Admission control modules can inspect
    incoming requests, ensuring they comply with predefined security policies. They
    can even modify requests to enforce specific rules or reject them entirely if
    they pose a threat.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准入控制**：这一阶段增加了额外的审查层。可以将其理解为入口处的安全扫描仪。准入控制模块可以检查传入的请求，确保它们符合预定义的安全政策。它们甚至可以修改请求，强制执行特定的规则，或者如果请求构成威胁，则完全拒绝。'
- en: '**Auditing**: Just like keeping a log of who enters and exits a secure facility,
    auditing in Kubernetes keeps a record of all activity within the cluster. This
    includes actions taken by users, applications, and even the control plane itself.
    These logs are invaluable for monitoring suspicious activity and maintaining a
    secure environment.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计**：就像记录谁进出一个安全设施一样，Kubernetes 的审计功能会记录集群内的所有活动。这包括用户、应用程序，甚至控制平面本身的操作。这些日志对监控可疑活动和维持安全环境至关重要。'
- en: By working together, these security measures create a layered defense system,
    ensuring that only authorized users can access your Kubernetes cluster and that
    their actions comply with established security policies.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些安全措施相互配合，形成了一个分层防御系统，确保只有授权用户能够访问你的 Kubernetes 集群，并且他们的行为符合已建立的安全政策。
- en: We will learn some more details about the authentication mechanism in the next
    section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一部分了解更多关于认证机制的细节。
- en: Authentication to the Kubernetes API
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes API 的认证
- en: Kubernetes API authentication ensures that only authorized users or services
    are allowed to talk to the resources running in a cluster. Each incoming request
    goes through an authentication setup, which is done in a chain of authenticator
    modules that are configured.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 认证确保只有授权的用户或服务可以与集群中的资源进行通信。每个传入请求都必须经过一系列身份验证模块的设置，这些模块已被配置。
- en: 'Requests to the API are always one of the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对 API 的请求总是以下列之一进行：
- en: Associated with an external, normal user or a **ServiceAccount** defined in
    the Kubernetes cluster.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与外部、普通用户或在 Kubernetes 集群中定义的 **ServiceAccount** 相关联。
- en: Treated as *anonymous* requests if the cluster has been configured to allow
    anonymous requests.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果集群已配置为允许匿名请求，则视为*匿名*请求。
- en: This is determined in the *authentication* process – the entire HTTP request
    is used as input to the process, but usually only request headers or the client
    certificate is analyzed. Authentication is carried out by authentication modules
    that depend on the cluster configuration. Your cluster may have multiple authenticator
    modules enabled, and then each of them is executed in sequence until one succeeds.
    If the request fails to authenticate, the API server will either respond with
    an HTTP status code of `401 (unauthorized)` or, if anonymous requests are enabled,
    treat it as anonymous.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这在*身份验证*过程中决定——整个HTTP请求作为输入传入该过程，但通常只分析请求头或客户端证书。身份验证由依赖于集群配置的身份验证模块执行。你的集群可能启用了多个身份验证模块，每个模块会按顺序执行，直到有一个成功。如果请求身份验证失败，API服务器将响应`401
    (unauthorized)` HTTP状态码，或者如果启用了匿名请求，则将其视为匿名请求。
- en: Anonymous requests are essentially mapped to a special username called `system:anonymous`
    and a group called `system:unauthenticated`. This means that you can organize
    your authorization to resources for such requests, just as you can for other users
    or ServiceAccounts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名请求本质上映射到一个特殊的用户名`system:anonymous`和一个叫做`system:unauthenticated`的组。这意味着你可以像管理其他用户或服务账户一样，管理这些请求的资源授权。
- en: 'Since all operations inside and outside the cluster must go through the Kubernetes
    API server, this means that all of them must go through the authentication process.
    This includes the operations of internal cluster components and Pods, which query
    the API server. For you, as an external user of the cluster, any requests that
    you make using `kubectl` commands or directly to the Kubernetes API server will
    also go through the authentication process:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集群内外的所有操作必须通过Kubernetes API服务器，这意味着所有操作都必须经过身份验证过程。这包括内部集群组件和Pod的操作，它们会查询API服务器。作为集群的外部用户，你通过`kubectl`命令或直接向Kubernetes
    API服务器发出的任何请求也会经过身份验证过程：
- en: '**Normal users**: Such users are managed *externally*, independent from the
    Kubernetes cluster. Currently, Kubernetes does not provide any objects to represent
    such users. The external management of users may be as simple (but *not* recommended)
    as static user-password files passed to the API server using the `token-auth-file`
    argument in the static Pod definition file `/etc/kubernetes/manifests/kube-apiserver.yaml`
    inside your control plane nodes (AKA master nodes) during startup. For production
    environments, leverage existing **identity providers** (**IdPs**) like **Google**,
    **GitHub**, **Azure Active Directory** (**AAD**), or **AWS IAM** to manage users.
    Integrate your Kubernetes cluster with these IdPs using **OpenID Connect** **(OIDC**
    – [https://openid.net/connect/](https://openid.net/connect/)) tokens for a seamless
    authentication experience. Remember, regular user accounts in Kubernetes are global
    and don’t have namespace restrictions.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**普通用户**：这些用户是*外部管理*的，独立于Kubernetes集群。目前，Kubernetes没有提供任何对象来表示这些用户。外部管理用户的方式可以像通过`token-auth-file`参数在静态Pod定义文件`/etc/kubernetes/manifests/kube-apiserver.yaml`中将静态的用户密码文件传递给API服务器（这通常发生在控制平面节点，即主节点启动时），尽管这种方法简单（但*不*推荐）。在生产环境中，应利用现有的**身份提供者**（**IdPs**），如**Google**、**GitHub**、**Azure
    Active Directory**（**AAD**）或**AWS IAM**来管理用户。使用**OpenID Connect**（**OIDC**）令牌将Kubernetes集群与这些身份提供者集成，提供无缝的身份验证体验。请记住，Kubernetes中的常规用户账户是全局性的，并且没有命名空间限制。'
- en: '**Service accounts**: These are managed by the Kubernetes cluster and modeled
    as ServiceAccount objects. You can create and manage service accounts just like
    any other resource in Kubernetes, for example, using `kubectl` and YAML manifest
    files. This type of account is intended for processes in cluster components or
    running in Pods. The credentials for ServiceAccounts will be created as Secrets
    (manually or via TokenRequest API) that are mounted into Pods so that the container
    process can use them to talk to the Kubernetes API server. When a process authenticates
    using a `ServiceAccount` token, it is seen as a user called `system:serviceaccount:<namespace>:<serviceAccountName>`.
    Note that ServiceAccounts are namespaced.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ServiceAccount**: 这些由 Kubernetes 集群管理，并建模为 ServiceAccount 对象。您可以像在 Kubernetes
    中管理任何其他资源一样，例如使用`kubectl`和 YAML 清单文件来创建和管理服务帐户。此类帐户适用于集群组件中或运行在 Pod 中的进程。ServiceAccounts
    的凭据将作为 Secrets（手动创建或通过 TokenRequest API）创建，并挂载到 Pod 中，以便容器进程可以使用它们与 Kubernetes
    API 服务器进行通信。当进程使用`ServiceAccount`令牌进行身份验证时，它被视为名为`system:serviceaccount:<namespace>:<serviceAccountName>`的用户。请注意，ServiceAccounts
    是命名空间的。'
- en: As you can see, user management in Kubernetes is a mixture of different approaches
    that should fit all the needs of different organizations. The key takeaway here
    is that after the authentication process, the request will be either rejected
    (optionally treated as anonymous) or treated as coming from a particular user.
    The `username` attribute may be provided by the external user management system,
    as in the case of normal users, or it will be `system:serviceaccount:<namespace>:<serviceAccountName>`
    for ServiceAccounts. Additionally, the request will have more attributes associated
    with it, such as **User ID** (**UID**), **groups**, and **extra fields**. This
    information is used for authorization processes based on RBAC, which we will explain
    in the next sections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Kubernetes 中的用户管理是一种不同方法的混合，应该适合不同组织的所有需求。这里的关键是，在认证过程之后，请求将被拒绝（可选地视为匿名）或被视为来自特定用户。外部用户管理系统可以提供`username`属性，例如普通用户的情况，或者对于
    ServiceAccounts，它将是`system:serviceaccount:<namespace>:<serviceAccountName>`。此外，请求将具有更多与之相关的属性，如**用户ID**（**UID**）、**组**和**额外字段**。这些信息用于基于
    RBAC 的授权过程，我们将在下一节中进行解释。
- en: Now, let’s look at the authentication methods that you can use with Kubernetes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看您可以在 Kubernetes 中使用的认证方法。
- en: Authentication Methods in Kubernetes
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes 中的认证方法
- en: The various authentications, in general, help in securely controlling access
    in Kubernetes to the API server. To validate users and services, a variety of
    authentication strategies can be enabled. Each is suited to different use cases
    and levels of security. These include tokens and certificates that verify the
    identities of both human users and applications interacting with the cluster.
    The good thing about the Kubernetes API server is that it provides support for
    multiple authentication mechanisms, so clusters can be configured using a combination
    of the previously-mentioned methods. In the following section, we will present
    some common authentication methods such as Static Token files, ServiceAccount
    tokens, X.509 client certificates, and OpenID Connect tokens.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，各种认证方法帮助安全地控制对 Kubernetes API 服务器的访问。为了验证用户和服务，可以启用多种认证策略。每种策略都适用于不同的用例和安全级别。这些策略包括验证人类用户和与集群交互的应用程序身份的令牌和证书。Kubernetes
    API 服务器的一个优点是它支持多种认证机制，因此可以使用前述方法的组合来配置集群。在接下来的部分中，我们将介绍一些常见的认证方法，如静态令牌文件、ServiceAccount
    令牌、X.509 客户端证书和 OpenID Connect 令牌。
- en: Static token files
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 静态令牌文件
- en: This method is the most basic one that Kubernetes offers for managing normal
    users. The approach somewhat resembles the `/etc/shadow` and `/etc/passwd` files
    in Unix/Linux systems. Note, however, that it is *not* recommended and is considered
    *unsecure* for production clusters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是 Kubernetes 提供给普通用户管理的最基本方法之一。这种方法在某种程度上类似于 Unix/Linux 系统中的`/etc/shadow`和`/etc/passwd`文件。但请注意，不建议在生产集群中使用，因为它被认为是不安全的。
- en: 'In this method, you define a `.csv` file where each line has the following
    format:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，您需要定义一个`.csv`文件，其中每行具有以下格式：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, you pass the file when starting the Kubernetes API server process using
    the `token-auth-file` parameter in the static Pod definition file `/etc/kubernetes/manifests/kube-apiserver.yaml`
    inside your control plane nodes (AKA master nodes):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To authenticate against the API server, you need to use a standard HTTP **bearer
    authentication scheme** for your requests. This means that your requests will
    need to use an additional header that’s in the following form:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Based on this request information, the Kubernetes API server will match the
    token against the static token file and assign user attributes based on the matched
    record.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `kubectl`, you must modify your `kubeconfig`. You can do this using
    the `kubectl` command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After that, you need to create and use context with this user for your requests
    using the `kubectl config use-context` command.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: In Kubernetes versions prior to 1.19, there was a similar authentication method
    that allowed us to use an HTTP **basic authentication scheme** and a file passed
    by the `basic-auth-file` parameter to the API server. This method is no longer
    supported due to security reasons.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram visualizes the principles behind this method of authentication:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.1 – Static token file authentication in Kubernetes'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B22019_18_02.png)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.2: Static token file authentication in Kubernetes'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: We can now summarize the advantages and disadvantages of using the static token
    file method for authentication.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of the static token file method are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to configure.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to understand.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages of the static token file method are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: It is unsecure; exposing a token file compromises all cluster users.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requires that we manually manage users.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new users or removing existing ones requires that we restart the Kubernetes
    API server.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating any tokens requires that we restart the Kubernetes API server.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes extra effort to replicate the Token file content to every control plane
    node when you have a high availability control plane with multiple control plane
    nodes.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, this method is good for development environments and learning the
    principles behind authentication in Kubernetes, but it is not recommended for
    production use cases. Next, we will take a look at authenticating users using
    ServiceAccount tokens.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: ServiceAccount tokens
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we mentioned in the introduction to this section, ServiceAccounts are meant
    for in-cluster identities for processes running in Pod containers or for cluster
    components. However, they can be used for authenticating external requests as
    well.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: ServiceAccounts are Kubernetes objects and can be managed like any other resource
    in the cluster; that is, by using `kubectl` or raw HTTP requests to the API server.
    The tokens for ServiceAccounts are **JSON Web Tokens** (**JWTs**) and will be
    generated on-demand or using the `kubectl create token` command.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Every Kubernetes namespace has a pre-created ServiceAccount named `default`.
    Pods without a specified ServiceAccount automatically inherit this default account
    for authorization within the cluster. You can verify a Pod’s ServiceAccount using
    `kubectl get pods/<podname> -o yaml` and checking the `spec.serviceAccountName`
    field.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Kubernetes 命名空间都有一个预创建的名为 `default` 的 ServiceAccount。没有指定 ServiceAccount
    的 Pod 会自动继承该默认账户以进行集群内的授权。你可以使用 `kubectl get pods/<podname> -o yaml` 来验证 Pod 的
    ServiceAccount，并检查 `spec.serviceAccountName` 字段。
- en: 'Usually, when defining a Pod, you can specify what ServiceAccount should be
    used for processes running in the containers. You can do this using `.spec.serviceAccountName`
    in the Pod specification. The JWT token will be injected into the container; then,
    the process inside can use it in the HTTP bearer authentication scheme to authenticate
    to the Kubernetes API server. This is only necessary if it interacts with the
    API server in any way, for example, if it needs to discover other Pods in the
    cluster. We have summarized this authentication method in the following diagram:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在定义 Pod 时，你可以指定用于容器中运行的进程的 ServiceAccount。你可以在 Pod 规范中使用 `.spec.serviceAccountName`
    来实现这一点。JWT 令牌将被注入到容器中；然后，容器内的进程可以在 HTTP 承载身份验证方案中使用它来认证 Kubernetes API 服务器。只有当它与
    API 服务器有任何交互时，这才是必要的，例如，如果它需要发现集群中的其他 Pod。我们已在下图中总结了这种身份验证方法：
- en: '![Figure 18.2 – ServiceAccount authentication in Kubernetes'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 18.2 – Kubernetes 中的 ServiceAccount 身份验证'
- en: '](img/B22019_18_03.png)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B22019_18_03.png)'
- en: 'Figure 18.3: ServiceAccount authentication in Kubernetes'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.3：Kubernetes 中的 ServiceAccount 身份验证
- en: This also shows why ServiceAccount tokens can be used for external requests
    – the API server does not care about the origin of the request; all it is interested
    in is the bearer token that comes with the request header. Again, you can use
    this token in `kubectl` or in raw HTTP requests to the API server. Please note
    that this is generally not a recommended way to use ServiceAccounts, but it can
    be used in some scenarios, especially when you are unable to use an external authentication
    provider for normal users.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这也说明了为什么 ServiceAccount 令牌可以用于外部请求——API 服务器并不关心请求的来源；它关心的是随请求头一起传递的承载令牌。再次强调，你可以在
    `kubectl` 中或者通过直接的 HTTP 请求发送到 API 服务器时使用此令牌。请注意，这通常不是推荐的使用 ServiceAccount 的方式，但在某些场景下它是可行的，尤其是当你无法为普通用户使用外部身份验证提供者时。
- en: 'Prior to version 1.22, Kubernetes automatically generated API credentials for
    ServiceAccounts using Secrets. These Secrets contained tokens that Pods could
    mount for access. This approach had limitations:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.22 版本之前，Kubernetes 使用 Secrets 自动为 ServiceAccount 生成 API 凭证。这些 Secrets 包含
    Pod 可以挂载以访问的令牌。这种方法有一些局限性：
- en: '**Static Tokens**: Secrets stored tokens in plain text, posing a security risk
    if compromised.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态令牌**：Secrets 存储的令牌是明文的，如果泄露会带来安全风险。'
- en: '**Limited Control**: Token lifespans and permissions were not easily managed.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限控制**：令牌的生命周期和权限不易管理。'
- en: 'Starting from version 1.22, Kubernetes switched to a more secure approach.
    Pods now obtain tokens directly using the **TokenRequest** API. These tokens are
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从 1.22 版本开始，Kubernetes 转向了一种更安全的方法。Pod 现在通过 **TokenRequest** API 直接获取令牌。这些令牌如下所示：
- en: '**Short-lived**: Tokens have limited lifespans, reducing the impact of potential
    compromise.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**短生命周期**：令牌的生命周期有限，减少了潜在泄露的影响。'
- en: '**Mounted into Pods**: Tokens are automatically mounted as volumes, eliminating
    the need for pre-stored Secrets.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动挂载到 Pods 中**：令牌会自动挂载为卷，消除了预存 Secret 的需求。'
- en: While automatic mounting is preferred, you can still manually create Secrets
    for service account tokens. This might be useful for tokens requiring longer lifespans,
    but it’s important to prioritize automatic token mounting for enhanced security
    in most scenarios.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自动挂载是首选方法，但你仍然可以手动为服务账户令牌创建 Secrets。对于需要更长生命周期的令牌，这可能是有用的，但在大多数场景中，优先使用自动令牌挂载来增强安全性。
- en: 'As we learned, Kubernetes automatically mounts Service Account API credentials
    within Pods for streamlined access. To disable this behavior and manage tokens
    differently, set `automountServiceAccountToken: false` either in the ServiceAccount
    manifest or within the Pod specification. This setting applies to all Pods referencing
    the ServiceAccount unless overridden by the specific Pod configuration. If both
    are defined, the Pod’s setting takes precedence. Refer to the documentation for
    more details ([https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#opt-out-of-api-credential-automounting](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#opt-out-of-api-credential-automounting)).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们所学到的，Kubernetes 自动在 Pod 中挂载 Service Account API 凭据以简化访问。要禁用此行为并以不同方式管理令牌，请在
    ServiceAccount 清单或 Pod 规范中设置 `automountServiceAccountToken: false`。此设置适用于所有引用该
    ServiceAccount 的 Pod，除非由特定 Pod 配置覆盖。如果两者都定义了，则 Pod 的设置优先。有关详细信息，请参阅文档（[https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#opt-out-of-api-credential-automounting](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#opt-out-of-api-credential-automounting)）。'
- en: 'We will now demonstrate how you can create and manage ServiceAccounts and how
    you can use JWT tokens to authenticate when using `kubectl`. This will also give
    a sneak peek into RBAC, which we are going to look at in more detail in the next
    section. Please follow these steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将演示如何创建和管理 ServiceAccounts，以及在使用 `kubectl` 时如何使用 JWT 令牌进行身份验证。这还将让我们一窥即将在下一节详细介绍的
    RBAC。请按照以下步骤操作：
- en: 'Create a YAML manifest for a new Namespace and a ServiceAccount as follows.
    We will configure RBAC for this account so that it can only read Pods in that
    namespace:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Namespace 和一个 ServiceAccount 的 YAML 清单如下。我们将为此帐户配置 RBAC，使其仅能读取该命名空间中的
    Pods：
- en: '[PRE4]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that you can also use the *imperative* command `kubectl create serviceaccount
    example-sa` to create the resources.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您还可以使用 *命令式* 命令 `kubectl create serviceaccount example-sa` 创建资源。
- en: 'Create a YAML manifest for a `Role` object named `pod-reader` in the `example-ns`
    namespace. This role will allow you to get, watch, and list Pods in this namespace.
    The `01_serviceaccount/pod-reader-role.yaml` YAML manifest file has the following
    contents:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `example-ns` 命名空间中为名为 `pod-reader` 的 `Role` 对象创建一个 YAML 清单。此角色将允许您获取、监视和列出此命名空间中的
    Pods。`01_serviceaccount/pod-reader-role.yaml` YAML 清单文件的内容如下：
- en: '[PRE5]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a YAML manifest for `RoleBinding` named `reads-pods`. This is what *associates*
    the role that we created with our `example-sa` ServiceAccount – the account will
    now have the privilege of read-only access to Pods, and nothing more. The `01_serviceaccount/read-pods-rolebinding.yaml`
    YAML manifest file has the following contents:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `reads-pods` 的 `RoleBinding` 的 YAML 清单。这是 *关联* 我们创建的角色与我们的 `example-sa`
    ServiceAccount 的操作 - 此帐户现在将具有对 Pods 的只读访问权限，没有其他权限。`01_serviceaccount/read-pods-rolebinding.yaml`
    YAML 清单文件的内容如下：
- en: '[PRE6]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can apply all the manifest files to the cluster at once using the `kubectl
    apply` command:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `kubectl apply` 命令一次性将所有清单文件应用到集群中：
- en: '[PRE7]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we will create a Token for the ServiceAccount as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将如下创建一个 ServiceAccount 的 Token：
- en: '[PRE8]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Collect the JWT token from the command output, which you can use to authenticate
    as that ServiceAccount. If you are interested, you can inspect the contents of
    the JWT using [https://jwt.io/](https://jwt.io/) as shown in the following figure:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令输出中收集 JWT 令牌，您可以使用该令牌作为该 ServiceAccount 的身份验证。如果您感兴趣，可以使用 [https://jwt.io/](https://jwt.io/)
    检查 JWT 的内容，如下图所示：
- en: '![](img/B22019_18_04.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_18_04.png)'
- en: 'Figure 18.4: Inspecting a JWT for ServiceAccount'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.4：检查 ServiceAccount 的 JWT
- en: As you can see, the JWT maps to the `example-sa` ServiceAccount in the `example-ns`
    namespace. Additionally, you can identify that the actual username (marked as
    a `subject` in the payload) that will be mapped to in Kubernetes is `system:serviceaccount:example-ns:example-sa`,
    as we explained previously.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，JWT 映射到 `example-ns` 命名空间中的 `example-sa` ServiceAccount。此外，您可以确定在 Kubernetes
    中将映射到的实际用户名（在负载中标记为 `subject`）是 `system:serviceaccount:example-ns:example-sa`，正如我们之前解释的那样。
- en: 'With this token, we can set up kubeconfig to test it. First, you need to create
    a user in your `kubeconfig` using the following command:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此令牌，我们可以设置 kubeconfig 进行测试。首先，您需要使用以下命令在您的 `kubeconfig` 中创建一个用户：
- en: '[PRE9]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Where the `example-sa` is the new ServiceAccount you have created and also replace
    `<your-token>` with the token string you collected earlier.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `example-sa` 是您创建的新 ServiceAccount，并将 `<your-token>` 替换为您之前收集的令牌字符串。
- en: 'Create a new context that uses this user in the `kubeconfig`. You also need
    to know the cluster name that you are connecting to right now – you can check
    it using the `kubectl config view` command. Use the `kubectl config set-context`
    command to create a new context:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用此用户的新上下文，`kubeconfig`中也需要知道您当前连接的集群名称——您可以使用`kubectl config view`命令查看。使用`kubectl
    config set-context`命令创建新上下文：
- en: '[PRE10]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For example, use the following command to create a new context named `example-sa-context`
    with minikube as the target cluster and `example-sa` as the user:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用以下命令创建一个名为`example-sa-context`的新上下文，目标集群为minikube，用户为`example-sa`：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Before we switch to the newly created context, let us create a simple nginx
    Pod in the `example-ns` namespace. Copy the sample YAML `Chapter18/references/sa-demo-nginx-pod.yaml`
    to `Chapter18/01_serviceaccount/nginx-pod.yaml` and apply the configuration:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在切换到新创建的上下文之前，让我们在`example-ns`命名空间中创建一个简单的nginx Pod。将示例YAML文件`Chapter18/references/sa-demo-nginx-pod.yaml`复制到`Chapter18/01_serviceaccount/nginx-pod.yaml`并应用配置：
- en: '[PRE12]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Also, before you switch to the new context, you may want to check the name
    of the context that you are currently using by utilizing the `kubectl config current-context`
    command. This will make it easier to go back to your old cluster admin context:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在切换到新上下文之前，您可能想要使用`kubectl config current-context`命令检查当前使用的上下文名称。这将使您更容易回到旧的集群管理员上下文：
- en: '[PRE13]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, switch to the new context using the following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令切换到新上下文：
- en: '[PRE14]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also verify the identity of the credential you are currently using
    as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以通过以下方式验证您当前使用的凭证身份：
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We are now ready to verify that our authentication works and that the RBAC
    roles allow read-only access to Pods in the `example-ns` namespace. First, try
    getting Pods:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备验证我们的身份验证是否有效，并且RBAC角色是否允许对`example-ns`命名空间中的Pods进行只读访问。首先，尝试获取Pods：
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This worked as expected! Now, try getting Pods from the `kube-system` namespace:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这按预期工作！现在，尝试从`kube-system`命名空间获取Pods：
- en: '[PRE17]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have authenticated correctly, but the action was forbidden by RBAC authorization,
    which is what we expected. Lastly, let’s try getting Service objects:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经正确认证，但由于RBAC授权限制，操作被禁止，这正是我们预期的。最后，让我们尝试获取服务对象：
- en: '[PRE18]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is also expected as the RBAC is not configured for the ServiceAccount to
    view or list the Service resources in the `example-ns` namespace.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是预期的，因为RBAC未配置ServiceAccount以查看或列出`example-ns`命名空间中的服务资源。
- en: As you can see, we have successfully used our ServiceAccount token for authentication
    and we have verified that our privileges work correctly. You can now switch back
    to your old `kubectl` context using the `kubectl config use-context <context-name>`
    command.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经成功地使用ServiceAccount令牌进行身份验证，并验证了我们的权限正常工作。您现在可以使用`kubectl config use-context
    <context-name>`命令切换回您的旧`kubectl`上下文。
- en: The preceding procedure of configuring the `kubectl` context with a bearer token
    can be used for the static token file authentication method as well.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 配置`kubectl`上下文与bearer令牌的上述过程也可以用于静态令牌文件身份验证方法。
- en: Let’s summarize what the advantages and disadvantages of using ServiceAccount
    tokens for authentication are.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下使用ServiceAccount令牌进行身份验证的优缺点。
- en: 'The advantages of using ServiceAccount tokens are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ServiceAccount令牌的优点如下：
- en: Easy to configure and use, similar to static token files.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和使用简单，类似于静态令牌文件。
- en: Entirely managed by the Kubernetes cluster, so there’s no need for external
    authentication providers.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全由Kubernetes集群管理，因此无需外部身份验证提供者。
- en: ServiceAccounts are namespaced.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ServiceAccounts是命名空间级的。
- en: 'The disadvantages of using ServiceAccount tokens are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ServiceAccount令牌的缺点如下：
- en: ServiceAccounts are intended for processes running in Pod containers to give
    them identity and let them use Kubernetes RBAC. *It is not a best practice for
    a user to use the ServiceAccount token*.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ServiceAccounts旨在为在Pod容器中运行的进程提供身份，并允许它们使用Kubernetes RBAC。*用户使用ServiceAccount令牌并不是最佳实践*。
- en: In general, using ServiceAccount tokens for external authentication is only
    good for development and test scenarios when you cannot integrate with external
    authentication providers. However, for production clusters, it is not the best
    option, mainly due to security concerns. Now, let’s take a look at using X.509
    client certificates for Kubernetes API authentication.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，使用 ServiceAccount 令牌进行外部认证仅适用于开发和测试场景，当你无法与外部认证提供商集成时。然而，对于生产集群来说，这不是最佳选择，主要是由于安全问题。现在，让我们来看看如何使用
    X.509 客户端证书进行 Kubernetes API 认证。
- en: X.509 client certificates
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: X.509 客户端证书
- en: Using X.509 client certificates is one of the industry standards for authentication
    processes. There is one important catch, however – you need to have good means
    of managing certificate signing, revoking, and rotation. Otherwise, you may hit
    very similar security issues as with using ServiceAccount tokens. You can learn
    more about X.509 certificates and the processes around them at [https://www.ssl.com/faqs/what-is-an-x-509-certificate/](https://www.ssl.com/faqs/what-is-an-x-509-certificate/).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 X.509 客户端证书是认证过程中一种行业标准。然而，有一个重要的注意事项——你需要有良好的证书签名、吊销和轮换管理手段。否则，你可能会遇到与使用
    ServiceAccount 令牌类似的安全问题。你可以在 [https://www.ssl.com/faqs/what-is-an-x-509-certificate/](https://www.ssl.com/faqs/what-is-an-x-509-certificate/)
    上了解更多关于 X.509 证书及其相关流程的信息。
- en: 'This method works in Kubernetes as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在 Kubernetes 中的工作原理如下：
- en: 'The Kubernetes API server starts with the `client-ca-file` argument. This provides
    **certificate authority** (**CA**) information to be used to validate client certificates
    presented to the API server. You can configure a custom CA certificate here or
    use the default CA created as part of the cluster deployment. For example, if
    you are using minikube, you can see a default CA file already configured in `kube-apiserver`
    as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes API 服务器通过 `client-ca-file` 参数启动。这个参数提供 **证书颁发机构**（**CA**）信息，用于验证提供给
    API 服务器的客户端证书。你可以在这里配置自定义的 CA 证书，或者使用集群部署过程中创建的默认 CA。例如，如果你使用的是 minikube，你可以看到在
    `kube-apiserver` 中已经配置了一个默认的 CA 文件，如下所示：
- en: '[PRE19]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Users who want to authenticate against the API server need to request an X.509
    client certificate from the CA. This should be a secure and audited process. The
    subject common name (the `CN` attribute in the subject) of the certificate is
    used as the `username` attribute when authentication is successful. Note that
    as of Kubernetes 1.19, you can use the Certificates API to manage signing requests.
    More information is available in the official documentation: [https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/](https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/).'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要对 API 服务器进行认证的用户需要从 CA 请求一个 X.509 客户端证书。这应该是一个安全且经过审计的过程。证书的主题公共名称（证书主题中的
    `CN` 属性）在认证成功时会作为 `username` 属性使用。请注意，从 Kubernetes 1.19 开始，你可以使用证书 API 来管理签名请求。更多信息请参阅官方文档：[https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/](https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/)。
- en: 'The user must present the client certificate during authentication to the API
    server, which validates the certificate against the CA. Based on that, the request
    goes through the authentication process successfully or is rejected. Again, if
    you are using a minikube cluster, you are already utilizing the certificate-based
    authentication, as shown in the following example:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户必须在认证过程中向 API 服务器提供客户端证书，服务器将证书与 CA 进行验证。基于此，请求会成功通过认证过程或被拒绝。再次提醒，如果你使用的是
    minikube 集群，那么你已经在使用基于证书的认证，如下例所示：
- en: '[PRE20]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'While using the `kubectl` commands, users can configure this method of authentication
    in kubeconfig using the `kubectl config set-credentials` command, as we learned
    earlier. We have summarized this process in the following diagram:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `kubectl` 命令时，用户可以通过 `kubectl config set-credentials` 命令在 kubeconfig 中配置这种认证方法，正如我们之前所学到的那样。我们在下图中总结了这个过程：
- en: '![Figure 18.4 – X.509 client certificate authentication in Kubernetes'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 18.4 – Kubernetes 中的 X.509 客户端证书认证'
- en: '](img/B22019_18_05.png)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B22019_18_05.png)'
- en: 'Figure 18.5: X.509 client certificate authentication in Kubernetes'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.5：Kubernetes 中的 X.509 客户端证书认证
- en: Please note that this visualizes the case when initial CSR by the user is handled
    by the Certificate API in a Kubernetes cluster. This does not need to be the case
    as CA may be external to the cluster, and the Kubernetes API server can rely on
    a copy of the CA `.pem` file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这展示的是用户初始 CSR 由 Kubernetes 集群中的证书 API 处理的情况。实际上，不必如此，因为 CA 可能位于集群外部，Kubernetes
    API 服务器可以依赖于 CA `.pem` 文件的副本。
- en: 'In the following hands-on exercise, we will generate and configure certificate-based
    authentication in Kubernetes:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的实操练习中，我们将生成并配置 Kubernetes 中的证书认证：
- en: 'Start with creating a private key using the `openssl` command:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `openssl` 命令开始创建私钥：
- en: '[PRE21]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Generate a **CertificateSigningRequest** (**CSR**):'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成**证书签名请求**（**CSR**）：
- en: '[PRE22]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Gather the CSR data and encode it using base64:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集 CSR 数据并使用 base64 编码：
- en: '[PRE23]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we need to create a `CertificateSigningRequest` resource with **Certificates
    API**; let us use the `csr.yaml` file as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要使用**证书 API**创建一个 `证书签名请求` 资源；让我们按如下方式使用 `csr.yaml` 文件：
- en: '[PRE24]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create the `CertificateSigningRequest`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `证书签名请求`：
- en: '[PRE25]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now the administrators (or the users with the `certificatesigningrequests`
    privilege) can see the CSR resources:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，管理员（或具有 `certificatesigningrequests` 权限的用户）可以查看 CSR 资源：
- en: '[PRE26]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Check and approve the CSR as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式检查并批准 CSR：
- en: '[PRE27]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once the CSR is approved, gather the certificate data from the approved CSR
    resource as follows; the following command will extract the data to `iamgini.crt`
    file:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 CSR 被批准，从批准的 CSR 资源中获取证书数据，具体操作如下；以下命令会将数据提取到 `iamgini.crt` 文件：
- en: '[PRE28]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we have the private key and certificate as follows (you can delete the
    `.csr` file as it is not required anymore):'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有了私钥和证书，具体如下（可以删除 `.csr` 文件，因为不再需要）：
- en: '[PRE29]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we will configure the `kubeconfig` with our new user and context; create
    a new user entry in the `kubeconfig` as follows (remember to use the full path
    of the key and certificate file):'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用新用户和上下文来配置 `kubeconfig`；按如下方式在 `kubeconfig` 中创建一个新用户条目（记得使用密钥和证书文件的完整路径）：
- en: '[PRE30]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a new context with the new user:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新用户创建一个新上下文：
- en: '[PRE31]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, the kubeconfig is updated with the new user and context. Let us test the
    access. Change the kubeconfig context as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，kubeconfig 已更新为新用户和上下文。让我们测试访问权限。按如下方式更改 kubeconfig 上下文：
- en: '[PRE32]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Verify the context and connection:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证上下文和连接：
- en: '[PRE33]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Congratulations; you have configured a new user with X509 certificate-based
    authentication. But remember, the user will not be able to do any kind of operation
    until you configure the appropriate RBAC resources.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜；你已经配置了基于 X509 证书的认证新用户。但请记住，在配置适当的 RBAC 资源之前，该用户无法执行任何操作。
- en: 'Based on what we have learned, we can summarize the advantages of this method
    as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们所学的内容，我们可以总结此方法的优点如下：
- en: It’s a much more secure process than using ServiceAccount tokens or static token
    files.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个比使用 ServiceAccount 令牌或静态令牌文件更安全的过程。
- en: Being unable to store certificates in the cluster means that it is not possible
    to compromise all certificates. X.509 client certificates can be used for high-privileged
    user accounts.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法在集群中存储证书意味着无法危及所有证书。X.509 客户端证书可以用于高权限用户账户。
- en: X.509 client certificates can be revoked on demand. This is very important in
    case of security incidents.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X.509 客户端证书可以按需撤销。这在发生安全事件时非常重要。
- en: 'The disadvantages of X.509 client certificate authentication are as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: X.509 客户端证书认证的缺点如下：
- en: Certificates have an expiry date, which means they cannot be valid indefinitely.
    For simple use cases in development, this is a disadvantage. From a security perspective,
    in production clusters, this is a huge *advantage. But remember to ensure the
    certificate is stored safely as the file-based authentication mechanism is a security
    risk; the file could be stolen and used for unauthorized access*.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书有有效期，这意味着它们不能无限期有效。对于开发中的简单用例，这是一个缺点。从安全角度来看，在生产集群中，这是一个巨大的*优点。但请记住，确保证书安全存储，因为基于文件的认证机制存在安全风险；文件可能被窃取并用于未经授权的访问*。
- en: Monitoring certificate expiration, revocation, and rotation must be handled.
    This should be an automated process so that we can quickly react in the case of
    security incidents.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须处理证书到期、撤销和轮换监控。这应该是一个自动化过程，以便在发生安全事件时我们能够迅速响应。
- en: Using client certificates in the browser for authentication is troublesome,
    for example, when you would like to authenticate to Kubernetes Dashboard.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中使用客户端证书进行认证是麻烦的，例如，当您想要认证到Kubernetes Dashboard时。
- en: The key takeaway is that using X.509 client certificates is secure but requires
    sophisticated certificate management so that we have all the benefits. Now, we
    will take a look at OpenID Connect tokens, which is the recommended method for
    cloud environments.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 关键要点是，使用X.509客户端证书是安全的，但需要复杂的证书管理，以便我们能获得所有的好处。现在，我们将看看OpenID Connect令牌，它是云环境中推荐的方法。
- en: OpenID Connect tokens
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: OpenID Connect令牌
- en: Using **OpenID Connect** (**OIDC**), you can achieve a **single sign-on** (**SSO**)
    experience for your Kubernetes cluster (and possibly other resources in your organization).
    OIDC is an authentication layer that’s created on top of OAuth 2.0, which allows
    third-party applications to verify the identity of the end-user and obtain basic
    user profile information. OIDC uses JWTs, which you can obtain using flows that
    conform to the OAuth 2.0 specifications. The most significant issue with using
    OIDC for authenticating in Kubernetes is the limited availability of OpenID providers.
    But if you are deploying in a cloud environment, all tier 1 cloud service providers
    such as Microsoft Azure, Amazon Web Services, and Google Cloud Platform have their
    versions of OpenID providers. The beauty of *managed* Kubernetes cluster deployments
    in the cloud, such as AKS Amazon EKS, and Google Kubernetes Engine, is that they
    provide *integration* with their native OpenID provider out of the box or by a
    simple flip of a configuration switch. In other words, you do not need to worry
    about reconfiguring the Kubernetes API server and making it work with your chosen
    OpenID provider – you get it alongside the managed solution. If you are interested
    in learning more about the OIDC protocol, you can refer to the official web page
    at [https://openid.net](https://openid.net).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**OpenID Connect**（**OIDC**），您可以为您的Kubernetes集群（以及可能是组织中的其他资源）实现**单点登录**（**SSO**）体验。OIDC是一个建立在OAuth
    2.0之上的认证层，它允许第三方应用程序验证终端用户的身份并获取基本的用户个人信息。OIDC使用JWT，这些JWT可以通过符合OAuth 2.0规范的流程获取。使用OIDC进行Kubernetes认证的最大问题是OpenID提供者的可用性有限。但如果您在云环境中部署，所有一级云服务提供商，如Microsoft
    Azure、Amazon Web Services和Google Cloud Platform，都有自己的OpenID提供者版本。云中托管的Kubernetes集群部署（如AKS、Amazon
    EKS和Google Kubernetes Engine）的优势在于，它们提供与其本地OpenID提供者的即插即用集成，或者只需简单的配置开关。换句话说，您无需担心重新配置Kubernetes
    API服务器并使其与所选的OpenID提供者一起工作——您将与托管解决方案一起获得它。如果您有兴趣了解更多有关OIDC协议的信息，可以参考[https://openid.net](https://openid.net)的官方网站。
- en: For more details and more specific flows, such as in the context of AAD please
    take a look at [https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多细节和更具体的流程，如AAD的上下文，请查看[https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc)。
- en: 'In the following diagram, you can see the basics of the OIDC authentication
    flow on Kubernetes:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，您可以看到Kubernetes中OIDC认证流程的基础：
- en: '![Figure 18.5 – OpenID Connect authentication in Kubernetes'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图18.5 – Kubernetes中的OpenID Connect认证'
- en: '](img/B22019_18_06.png)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B22019_18_06.png)'
- en: 'Figure 18.6: OIDC authentication in Kubernetes'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.6：Kubernetes中的OIDC认证
- en: The most important thing is that the OpenID provider is responsible for the
    SSO experience and managing the bearer tokens. Additionally, the Kubernetes API
    server must validate the bearer token that’s received against the OpenID provider.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，OpenID提供者负责单点登录（SSO）体验以及管理承载令牌。此外，Kubernetes API服务器必须验证收到的承载令牌，并与OpenID提供者进行对比。
- en: 'Using OIDC has the following advantages:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OIDC具有以下优点：
- en: You get SSO experience, which you can use with other services in your organization.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以获得单点登录（SSO）体验，您可以与组织中的其他服务一起使用。
- en: Most of the cloud service providers have their own OpenID providers that easily
    integrate with their managed Kubernetes offerings.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数云服务提供商都有自己的OpenID提供者，这些提供者能够轻松与其托管的Kubernetes服务集成。
- en: It can be also used with other OpenID providers and non-cloud deployments –
    this requires a bit more configuration though.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它也可以与其他OpenID提供者和非云部署一起使用——不过这需要更多的配置。
- en: It’s a secure and scalable solution.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个安全且可扩展的解决方案。
- en: 'The disadvantages of the OIDC approach can be summarized as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes has no web interface where you can trigger the authentication process.
    This means that you need to get the credentials by manually requesting them from
    the IdP. In managed cloud Kubernetes offerings, this is often solved by additional
    simple tooling to generate `kubeconfig` with credentials.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OIDC tokens can be revoked by the IdP if it supports the token endpoint revocation
    feature. This allows you to invalidate tokens before their expiration time, for
    example, if a user’s account is compromised. However, not all IdPs support this
    feature, and Kubernetes doesn’t handle token revocation itself.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OIDC in Kubernetes
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Kubernetes does not provide an integrated OpenID Connect Identity Provider.
    Thus, it relies on the external ones provided either by cloud providers or stand-alone
    tools. As we mentioned earlier in this section, the most popular cloud environments
    – like AWS, GCP, and Azure – natively provide OIDC integration in their managed
    Kubernetes offerings, which makes it pretty straightforward to enable SSO. Alternatively,
    the identity providers can also be set up independently for every organization
    using tools such as Dex, Keycloak, UAA, or OpenUnison for the non-cloud or self-managed
    Kubernetes clusters.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Identity Provider Requirements in Kubernetes
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For an OIDC identity provider to work with Kubernetes, it has to satisfy a
    number of important prerequisites:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '**Support OIDC Discovery**: OIDC discovery simplifies configuration efforts
    as through it all information about IdP endpoints and public keys are made available.
    Kubernetes reads the IdP’s public keys from the discovery endpoint to validate
    OIDC tokens.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transport Layer Security** (**TLS**) **Compliance**: The identity provider
    shall handle TLS to handle non-obsolete ciphers as sensitive authentication data
    handling is at stake.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CA-Signed Certificate**: Whether by using a commercial CA or a self-signed
    certificate, the certificate of the identity provider must have the `CA` flag
    set to `TRUE`. This is because Kubernetes uses Go’s TLS client which strictly
    enforces this requirement so that Kubernetes can safely trust the identity provider’s
    certificates during user token verification.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the self-deployer of an identity provider without a commercial CA, such
    tools as the Dex gencert script may be used to create a compliant CA certificate
    along with the signing key.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list contains some of the popular OIDC Identity Providers for
    Kubernetes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '**Dex**: One of the more lightweight, open-source popular IdPs intended for
    use in a Kubernetes environment. it supports OIDC and works well with the authentication
    workflow that Kubernetes expects. Dex works by hooking into other external IdPs
    such as LDAP, GitHub, and Google, which would make it a good choice for organizations
    with more complicated identity scenarios.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keycloak**: This is an open-source IdP that offers a more powerful feature
    set with extensive support for OIDC and SAML. Besides core functionality, Keycloak
    supports enterprise-grade features such as user federation and RBAC. Keycloak
    would be a good fit if you want to have more control or customization in your
    authentication setup.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Keycloak**：这是一个开源身份提供者（IdP），提供强大的功能集，广泛支持 OIDC 和 SAML。除了核心功能外，Keycloak 还支持企业级功能，如用户联合和基于角色的访问控制（RBAC）。如果你希望在身份验证设置中拥有更多控制或定制，Keycloak
    会是一个不错的选择。'
- en: '**OpenUnison**: Another IdP that is optimized for Kubernetes is OpenUnison,
    with features like natively integrating the Kubernetes RBAC and identity federation.
    It should be popular with enterprises that are ready to engage a prebuilt solution
    optimized to their own needs for securing Kubernetes.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenUnison**：另一个为 Kubernetes 优化的 IdP 是 OpenUnison，具备像本地集成 Kubernetes RBAC
    和身份联合等功能。它应该会受到准备好采用预构建解决方案、并根据自身需求对 Kubernetes 进行安全配置的企业的青睐。'
- en: '**Cloud Foundry User Account and Authentication** (**UAA**): This is an open-source
    multi-purpose IdP originating from Cloud Foundry. It supports OIDC and does an
    extremely strong job with cloud platform and enterprise authentication system
    integrations, making it suitable for more complex Kubernetes deployments in hybrid
    cloud environments.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cloud Foundry 用户账户与认证**（**UAA**）：这是一个开源的多用途身份提供者，源自 Cloud Foundry。它支持 OIDC，并在云平台和企业认证系统集成方面表现非常强大，非常适合在混合云环境中部署更复杂的
    Kubernetes 集群。'
- en: Configuring OIDC with Kubernetes API Server
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 配置 Kubernetes API 服务器的 OIDC
- en: 'Enabling OIDC in Kubernetes will involve some configuration of the Kubernetes
    API server with certain OIDC-related flags. The major configurations include the
    following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中启用 OIDC 需要对 Kubernetes API 服务器进行一些配置，使用特定的 OIDC 相关标志。主要配置包括以下内容：
- en: '`oidc-issuer-url`: The URL of the OIDC provider. It is used by Kubernetes for
    verification of token authenticity.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oidc-issuer-url`：OIDC 提供者的 URL。Kubernetes 使用它来验证令牌的真实性。'
- en: '`oidc-client-id string`: The client ID to use when authenticating with the
    IdP when Kubernetes is the client.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oidc-client-id string`：在 Kubernetes 作为客户端时，用于与 IdP 进行身份验证时的客户端 ID。'
- en: '`oidc-username-claim`: Specifies which claim in the token should map to the
    Kubernetes username.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oidc-username-claim`：指定令牌中的哪个声明应该映射到 Kubernetes 用户名。'
- en: '`oidc-groups-claim`: Maps the groups in the IdP to Kubernetes groups, in order
    to manage RBAC roles.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oidc-groups-claim`：将 IdP 中的组映射到 Kubernetes 组，以便管理 RBAC 角色。'
- en: For further details on configuring specific OIDC identity providers, you can
    refer to the official resources such as Dex for Kubernetes Guide ([https://dexidp.io/docs/guides/kubernetes/](https://dexidp.io/docs/guides/kubernetes/))
    or OpenID Connect Authentication in Kubernetes ([https://kubernetes.io/docs/reference/access-authn-authz/authentication/](https://kubernetes.io/docs/reference/access-authn-authz/authentication/)).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 关于配置特定 OIDC 身份提供者的更多细节，你可以参考官方资源，例如 Kubernetes 指南中的 Dex ([https://dexidp.io/docs/guides/kubernetes/](https://dexidp.io/docs/guides/kubernetes/))
    或 Kubernetes 中的 OpenID Connect 认证 ([https://kubernetes.io/docs/reference/access-authn-authz/authentication/](https://kubernetes.io/docs/reference/access-authn-authz/authentication/))。
- en: The key takeaway about OIDC is that this is your best bet when configuring authentication
    for Kubernetes, especially if you are deploying production clusters in the cloud.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 OIDC 的一个关键要点是，这是配置 Kubernetes 身份验证时最好的选择，尤其是在你部署生产集群到云环境中时。
- en: Other methods
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他方法
- en: Kubernetes offers a few other authentication methods that you can use. They
    are mainly intended for advanced use cases, such as integrating with LDAP or Kerberos.
    The first one is an **authenticating proxy**.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了几种其他认证方法供你使用。这些方法主要用于高级用例，例如与 LDAP 或 Kerberos 集成。第一个是 **认证代理**。
- en: When you use an authenticating proxy in front of the Kubernetes API server,
    you can configure the API server to use certain HTTP headers to extract authentication
    user information from them. In other words, your authenticating proxy is doing
    the job of authenticating the user and passing down this information alongside
    the request in the form of additional headers.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Kubernetes API 服务器前使用认证代理时，可以配置 API 服务器使用某些 HTTP 头部来提取认证用户信息。换句话说，你的认证代理在执行用户认证的工作，并将这部分信息以附加头部的形式随请求一起传递。
- en: You can find more information in the official documentation ([https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authenticating-proxy](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authenticating-proxy)).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is known as **webhook token authentication**, whereby the Kubernetes
    API server uses an external service to verify the bearer tokens. The external
    service receives the information in the form of a TokenReview object from the
    API server via an HTTP POST request, performs verification, and sends back a TokenReview
    object with additional information about the result.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Find more information from the official documentation (https://kuberntes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes also uses another common authentication method called **bootstrap
    tokens**. But bootstrap tokens are not used for general authentication but for
    the cluster node. Bootstrap tokens are a special type of secret in Kubernetes
    that simplify adding new nodes to a cluster. Stored in the `kube-system` namespace,
    these short-lived tokens allow the API server to authenticate kubelets (programs
    running on nodes) during the initial connection. This streamlines the bootstrapping
    process, making it easier to join new nodes or create new clusters from scratch.
    They can be used with or without the kubeadm tool and work seamlessly with Kubelet
    TLS Bootstrapping for secure communication. Refer to the documentation ([https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens](https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens))
    to learn about authentication with bootstrap tokens and TLS bootstrapping.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: In general, you need the authenticating proxy and webhook token authentication
    methods in special cases where you want to integrate with existing identity providers
    in your organization that are not supported by Kubernetes out of the box.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at authorization and RBAC in Kubernetes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Authorization and introduction to RBAC
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Security in Kubernetes relies on two crucial processes: **authentication**
    and **authorization**. Authentication verifies the identity of a user attempting
    to access the system, ensuring they are who they claim to be. This initial step
    typically involves checking credentials like usernames and passwords or tokens.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Following successful authentication, authorization comes into play. This process
    determines what actions a user can perform within the system. In Kubernetes, the
    API server evaluates a user’s identity (derived from authentication) along with
    other request attributes, such as the specific API endpoint or action being requested.
    Based on pre-defined policies or external services, authorization modules decide
    whether to allow or deny the request.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is the first step in determining the identity of the user, whereas
    authorization is the next step when verifying if the user can perform the action
    they want to.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Access controls based on specific object fields are handled by admission controllers,
    which occur after authorization and only if authorization allows the request.
    We will learn about admission controllers in the later sections of this chapter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: In the Kubernetes API server, authenticating a request results in a set of additional
    request attributes such as **user**, **group**, **API request verb**, **HTTP request
    verb**, and so on. These are then passed further to authorization modules that,
    based on these attributes, answer whether the user is allowed to do the action
    or not. If the request is denied by any of the modules, the user will be presented
    with an HTTP status code of `403 (Forbidden)`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: This is an important difference between HTTP status codes. If you receive `401
    (Unauthorized)`, this means that you have been not recognized by the system; for
    example, you have provided incorrect credentials or the user does not exist. If
    you receive `403 (Forbidden)`, this means that authentication has been successful
    and you have been recognized, but you are not *allowed* to do the action you requested.
    This is useful when debugging issues regarding access to a Kubernetes cluster.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes has a few authorization modes available that can be enabled by using
    the `authorization-mode` argument when starting the Kubernetes API server, as
    follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following are the authorization modes available in Kubernetes:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '**RBAC**: This allows you to organize access control and management with roles
    and privileges. RBAC is one of the industry standards for access management, also
    outside of Kubernetes. Roles can be assigned to users in the system, which gives
    them certain privileges and access. In this way, you can achieve very fine-grained
    access management that can be used to enforce the **principle of least privilege**.
    For example, you can define a role in the system that allows you to access certain
    files on a network share. Then, you can assign such roles to individual users
    in groups in the system to allow them to access these files. This can be done
    by associating the user with a role – in Kubernetes, you model this using the
    **RoleBinding** and **ClusterRoleBinding** objects. In this way, multiple users
    can be assigned a role, and a single user can have multiple roles assigned. Please
    note that in Kubernetes, RBAC is *permissive*, which means that there are no *deny*
    rules. Everything is denied by default, and you have to define *allow* rules instead.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute-Based Access Control (ABAC)**: This is part of the access control
    paradigm and is not only used in Kubernetes, which uses policies based on the
    attributes of the user, resource, and environment. This is a very fine-grained
    access control approach – you can, for example, define that the user can access
    a given file, but only if the user has clearance to access confidential data (user
    attribute), the owner of the file is Mike (resource attribute), and the user tries
    to access the file from an internal network (environment attribute). So, policies
    are sets of attributes that must be present together for the action to be performed.
    In Kubernetes, this is modeled using Policy objects. For example, you can define
    that the authenticated user, `mike`, can read any Pods in the `default` namespace.
    If you want to give the same access to user `bob`, then you need to create a new
    Policy for user `bob`.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node**: This is a special-purpose authorization mode used for authorizing
    API requests made by `kubelet` in the cluster.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Webhook**: This mode is similar to webhooks for authentication. You can define
    an external service that needs to handle HTTP POST requests with a **SubjectAccessReview**
    object that’s sent by the Kubernetes API server. This service must process the
    request and determine if the request should be allowed or denied. The response
    from the service should contain `SubjectAccessReview`, along with information,
    on whether the subject is allowed access. Based on that, the Kubernetes API server
    will either proceed with the request or reject it with an HTTP status code of
    `403`. This approach is useful when you are integrating with existing access control
    solutions in the organization.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AlwaysAllow**: This grants unrestricted access to all requests, and is only
    suitable for testing environments due to security concerns.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AlwaysDeny**: This blocks all requests, and is useful solely for testing
    purposes to establish a baseline for authorization.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently, RBAC is considered an industry standard in Kubernetes due to its
    flexibility and ease of management. For this reason, RBAC is the only authentication
    mode we are going to describe in more detail.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: RBAC mode in Kubernetes
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using RBAC in Kubernetes involves the following types of API resources that
    belong to the `rbac.authorization.k8s.io` API group:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '**Role** and **ClusterRole**: They define a set of permissions. Each `rule`
    in Role says which verb(s) are allowed for which API resource(s). The only difference
    between Role and ClusterRole is that Role is namespace-scoped, whereas ClusterRole
    is global.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RoleBinding** and **ClusterRoleBinding**: They associate users or a set of
    users (alternatively, groups or ServiceAccounts) with a given Role. Similarly,
    RoleBinding is namespace-scoped, while ClusterRoleBinding is cluster-wide. Please
    note that ClusterRoleBinding works with ClusterRole, but RoleBinding works with
    both ClusterRole and Role.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these Kubernetes objects can be managed using `kubectl` and YAML manifests,
    just as you do with Pods, Services, and so on.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now demonstrate this in practice. In the previous section, we showed
    a basic RBAC configuration for a service account that was being used for authentication
    using `kubectl`. The example that we are going to use here will be a bit different
    and will involve creating a Pod that runs under a *dedicated* service account
    and periodically queries the Kubernetes API server for a list of Pods. In general,
    having dedicated service accounts for running your Pods is a good practice and
    makes it possible to ensure the principle of least privilege. For example, if
    your Pod needs to get the list of Pods in the cluster but does not need to create
    a new Pod, the ServiceAccount for this Pod should have a role assigned that allows
    you to list Pods, nothing more. Follow these steps to configure this example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating a dedicated namespace for the objects with the following
    YAML file:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Create namespace by applying the YAML
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To demonstrate, let us create a sample nginx Pod in the same namespace using
    the `02_rbac/nginx-pod.yaml` definition:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Please note, that the `nginx` Pod is not doing anything here; we need the Pod
    `pod-logger-app` to fetch the `nginx` Pod details in the `rbac-demo-ns` namespace
    later.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a ServiceAccount named `pod-logger`. Create a YAML manifest named
    `pod-logger-serviceaccount.yaml`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Apply the manifest to the cluster using the following command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a role named `pod-reader`. This role will only allow the `get`, `watch`,
    and `list` verbs on `pods` resources in the Kubernetes RESTful API. In other words,
    this translates into an `/api/v1/namespaces/rbac-demo-ns/pods` endpoint in the
    API. Note that `apiGroups` specified as `""` mean the `core` API group. The structure
    of the `pod-reader-role.yaml` manifest file is as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Apply the manifest to the cluster using the following command:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we would normally create a RoleBinding object to associate the service
    account with the role. But to make this demonstration more interesting, we will
    create a Pod that’s running under the `pod-logger` service account. This will
    essentially make the Pod unable to query the API for Pods because it will be *unauthorized*
    (remember that everything is denied by default in RBAC). Create a YAML manifest
    named `pod-logger-app.yaml` for a Pod called `pod-logger-app`, running without
    any additional controllers:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, the most important fields are `.spec.serviceAccountName`, which specifies
    the service account that the Pod should run under, and the `command` in the container
    definition, which we have overridden to periodically query the Kubernetes API.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us apply the `02_rbac/pod-logger-app.yaml` to create the Pod as follows:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Assigning the `pod-logger` service account, as explained in the previous section,
    will result in a Secret with a bearer JWT for this account to be mounted in the
    container filesystem under `/var/run/secrets/kubernetes.io/serviceaccount/token`.
    Let us verify this using `kubectl exec`, as follows:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The overridden commands run an infinite loop in a Linux shell (e.g., bash) in
    10-second intervals. In each iteration, we query the Kubernetes API endpoint (`https://kubernetes/api/v1/namespaces/rbac-demo-ns/pods`)
    for Pods in the `rbac-demo-ns` namespace with the HTTP `GET` method using the
    `curl` command. To properly authenticate, we pass the contents of `/var/run/secrets/kubernetes.io/serviceaccount/token`
    as a **bearer** token in the `Authorization` header for the request. Additionally,
    we pass a CA certificate path to verify the remote server using the `cacert` argument.
    The certificate is injected into `/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`
    by the Kubernetes runtime. When you inspect its logs, you should expect to see
    a bunch of messages with an HTTP status code of `403 (Forbidden).` This is because
    the ServiceAccount does not have a RoleBinding type that associates it with the
    `pod-reader` Role yet.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start following the logs of the `pod-logger-app` Pod using the following command:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In a new console window (or by ending the logs with the *Ctrl + F* command),
    we will create and apply a RoleBinding that *associates* the `pod-logger` ServiceAccount
    with the `pod-reader` Role. Create a YAML manifest named `read-pods-rolebinding.yaml`
    that contains the following contents:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'There are three key components in the RoleBinding manifest: `name`, which is
    used to identify the user; `subjects`, which reference the users, groups, or service
    accounts; and `roleRef`, which references the role.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the RoleBinding manifest file using the following command:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now check the `pod-logger-app` logs again; you will see that the Pod was able
    to successfully retrieve the list of Pods in the `rbac-demo-ns` namespace. In
    other words, the request was successfully authorized:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Lastly, you can delete the RoleBinding type using the following command:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, if you inspect the logs of the `pod-logger-app` Pod again, you will see
    that the requests are denied with an HTTP status code of `403` again.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! You have successfully used RBAC in Kubernetes to be able to
    read the Pods in the cluster for a Pod running under ServiceAccount. To clean
    up the Kubernetes environment, you can delete the `rbac-demo-ns` namespace so
    that the resources you created will be removed as part of the namespace removal.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: As we have explored authentication and authorization, in the next section, let
    us learn about another security feature in Kubernetes called admission controllers.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Admission Control – Security Policies and Checks
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a security checkpoint at a critical facility. Admission controllers
    in Kubernetes function similarly for your cluster. They act as gatekeepers, intercepting
    requests to the Kubernetes API server before resources are created, deleted, or
    modified. These controllers can validate or modify the requests based on predefined
    rules, ensuring that only authorized and properly configured resources enter the
    system. Also note that admission controllers do not (and cannot) block requests
    to read (get, watch, or list) objects.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Several key features of Kubernetes rely on specific admission controllers to
    function correctly. Therefore, a Kubernetes API server without the appropriate
    admission controllers is incomplete and will not support all expected features.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of admission controllers:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '**Validation controllers**: These controllers meticulously examine incoming
    requests. If they find anything suspicious or non-compliant with set policies,
    they reject the request entirely.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutation controllers**: These controllers have the power to modify requests
    before they are stored permanently. They can, for instance, add missing security
    annotations or adjust resource limits.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s get introduced to the two-phase admission process.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: The Two-Phase Admission Process
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Admission control in Kubernetes operates in a two-step process, ensuring only
    compliant resources enter your cluster.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The high-level flow taken by the mutation and validation phases of Kubernetes
    admission control is represented by the following figure. This flow takes incoming
    requests into Kubernetes to process in a manner that first does the appropriate
    mutations for modifying or enriching requests before doing any actual validation
    to see if the request meets all required security and policy validations that
    are required.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'This sequence is exposed to the flow, showing the way, Kubernetes enforces
    consistency, security, and policy compliance before allowing any changes to the
    cluster state:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_18_07.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.7: Admission controllers in the API request processing flow (image
    source: https://kubernetes.io/blog/2019/03/21/a-guide-to-kubernetes-admission-controllers/)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a breakdown of each phase.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Mutation Phase
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Mutation phase is a step in admission control in Kubernetes, where controllers
    running in the role of mutation controllers will change the incoming API requests
    to make them compliant with cluster policies before further processing. Such controllers
    basically act like “molders,” which not only see to it that the requests are consistent
    with established settings but can also automatically add or adjust settings, for
    example, defaults or security labels. This makes the system maintain the policy
    compliance and alignment of configurations without manual input.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few examples presented here for this phase:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Adding missing security annotations to pods.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting resource requests and limits for pods based on pre-defined rules.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting sidecar containers for specific functionalities.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation Phase
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is during the Validation phase, in this sequence, that Kubernetes admission
    control completes a controller’s doing in the preceding Mutation phase. Controllers
    then closely scrutinize incoming requests that might have been modified by some
    controller. Often referred to as the “guardians,” these controllers check requests
    for adherence to cluster policies and security standards. It is an important phase
    in the prevention of misconfiguration and unauthorized changes that maintain cluster
    integrity and security by rejecting requests not meeting set criteria.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the example actions are listed here:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Approve the request if it adheres to set criteria (e.g., resource quotas, security
    standards).
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reject the request if it violates any policies, providing informative error
    messages.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will learn how to turn off and turn on admission controllers
    in Kubernetes.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Enabling and disabling Admission controllers
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To check which Admission controllers are enabled, you typically need to inspect
    the configuration of the **Kubernetes API server**. This is often done by accessing
    the configuration file where the API server is defined, usually located in the
    system’s configuration directories or managed through a configuration management
    tool. Look for the `--enable-admission-plugins` flag, which specifies the list
    of admission controllers currently active.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in a minikube environment, you can SSH into the minikube VM using
    the `minikube ssh` command. Once inside, you can locate and inspect the `kube-apiserver.yaml`
    file, typically found in `/etc/kubernetes/manifests/`. Use `sudo cat /etc/kubernetes/manifests/kube-apiserver.yaml`
    to view its contents and look for the `--enable-admission-plugins` flag:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To modify the list of enabled plugins, edit this file with a text editor like
    nano or vi, adjust the plugins as needed, and then save your changes. The kubelet
    watches the manifest files and will automatically restart the API server (recreate
    the Pod) if it detects any changes to the manifest file.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to turn off the default admissions controllers as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the following section, we will learn the list of admission controllers available
    in Kubernetes.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Common Admission Controllers
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Kubernetes, the admission controllers are built into the `kube-apiserver`
    and should only be configured by the cluster administrator. Among these controllers,
    two are particularly notable: **MutatingAdmissionWebhook** and **ValidatingAdmissionWebhook**.
    These controllers execute the respective mutating and validating admission control
    webhooks that are configured through the API:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Controls**: `AlwaysAdmit` (deprecated), `AlwaysDeny` (deprecated),
    `AlwaysPullImages`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defaults**: `DefaultStorageClass`, `DefaultTolerationSecond`s'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: `DenyEscalatingExec`, `DenyServiceExternalIPs`, `PodSecurityPolicy`,
    `SecurityContextDeny`'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Management**: `LimitRanger`, `ResourceQuota`, `RuntimeClass`'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object Lifecycle**: `NamespaceAutoProvision`, `NamespaceExists`, `NamespaceLifecycle`,
    P`ersistentVolumeClaimResize`, `StorageObjectInUseProtection`'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node Management**: `NodeRestriction`, `TaintNodesByCondition`'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Webhooks**: `MutatingAdmissionWebhook`, `ValidatingAdmissionWebhook`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Others**: `EventRateLimit`, `LimitPodHardAntiAffinityTopology`, `OwnerReferencesPermissionEnforcement`,
    `PodNodeSelector` (deprecated), `Priority`, `ServiceAccount`'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are numerous advantages to using admission controllers in a Kubernetes
    cluster. Let us learn about a few in the next section.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of Admission Controllers
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are multiple advantages of using admission controllers in your Kubernetes
    clusters, including the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '**Enhanced Security**: By enforcing security policies like pod security standards,
    admission controllers help keep your cluster safe from unauthorized or vulnerable
    deployments.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policy Enforcement**: You can define rules for resource usage, image pulling,
    and more, which admission controllers will automatically enforce.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency and Standardization**: Admission controllers ensure that resources
    across your cluster adhere to established best practices and configurations.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, the admission controllers section has emphasized that admission
    controllers play a very important role in ensuring the security of Kubernetes,
    and this is through the Mutation and Validation phases. We learned how the mutation
    controllers run modifications on the requests to make sure they comply with cluster
    policies, while validation controllers ensure none other than those meeting the
    security standards are processed. In all, the foregoing processes improve the
    overall state of the security of the Kubernetes clusters by assuring compliance
    and prohibiting unauthorized changes.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, let us learn about how to secure workloads in Kubernetes
    using Security Context and NetworkPolicies.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Securing Pods and Containers
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing Pods and containers is essential to keeping your Kubernetes environment
    in a healthy state, since these directly interact with workloads and sensitive
    data. In the next sections, we are going to talk about how the securityContext
    settings and NetworkPolicies can enforce strict access controls and isolation
    in place to strengthen the security of Pods and containers in your cluster.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Securing Pods and Containers in Kubernetes Using Security Context
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Kubernetes, a **securityContext** defines a set of security settings that
    determine how a Pod or container operates within the cluster. This allows you
    to enforce security best practices and minimize the attack surface by restricting
    privileges and controlling access.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: The primary purpose of securityContext is to enhance the security of your Kubernetes
    clusters by defining how a pod or container should run within the cluster. By
    specifying security settings, you can ensure that your applications adhere to
    the principle of least privilege, reducing the potential for malicious activities
    and accidental misconfigurations.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: A typical use case for securityContext is to run containers as non-root users.
    This prevents containers from having unnecessary permissions, thereby limiting
    the potential damage if a container is compromised. Additionally, you can configure
    other security settings such as read-only filesystems and fine-grained capabilities
    to further strengthen your cluster’s security posture.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Key Components of SecurityContext
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s a breakdown of the key components of a securityContext along with illustrative
    examples.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: User and Group
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This security context specifies the user and group ID, under which processes
    inside the container will run. By enforcing the principle of least privilege,
    it grants containers only the minimum permissions necessary to function. The following
    code snippet shows a typical example of a Pod definition with the securityContext
    configured:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Linux Capabilities
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Capabilities are special privileges that can be granted to containers beyond
    the limitations of a user. securityContext allows you to define which capabilities
    a container should have, enabling specific functionalities without providing full
    root access, as shown in the following example:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Refer to the Linux capabilities documentation to learn more ([https://linux-audit.com/kernel/capabilities/linux-capabilities-hardening-linux-binaries-by-removing-setuid/](https://linux-audit.com/kernel/capabilities/linux-capabilities-hardening-linux-binaries-by-removing-setuid/)).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Privileged Mode
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Read-Only Root Filesystem
  id: totrans-370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This securityContext allows you to configure the container to have a read-only
    root filesystem. This enhances security by preventing accidental or malicious
    modifications to the base system:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There are a few more SecurityContext settings such as **Security Enhanced Linux**
    (**SELinux**), **AppArmor** ([https://kubernetes.io/docs/tutorials/security/apparmor/](https://kubernetes.io/docs/tutorials/security/apparmor/)),
    **Seccomp**, and so on. Refer to [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
    to learn more.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: You also need to know where is the best place in the configuration you can apply
    SecurityContext; let us learn that in the next section.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Applying SecurityContext at Pod and Container Levels
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Kubernetes, the securityContext can be applied at both the pod level and
    the container level, offering flexibility in defining security settings for your
    applications.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Pod-Level SecurityContext
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When applied at the pod level, the securityContext settings are inherited by
    all containers within the pod. This is useful for setting default security configurations
    that should apply uniformly across all containers in the pod:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Container-Level SecurityContext
  id: totrans-380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When applied at the container level, the securityContext settings only affect
    the specific container. This allows for more granular control, where different
    containers within the same pod can have different security configurations.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the following section, let us demonstrate the Security Context with an example
    Pod.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Applying Security Context to a Pod
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following example creates a Pod with a container that runs with a `read-only`
    root filesystem and specifies non-root user and group IDs:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the preceding YAML, note the following:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '`runAsUser`and `runAsGroup`: These settings ensure that the container runs
    with a specific non-root user ID and group ID, following the principle of least
    privilege.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readOnlyRootFilesystem`: This setting mounts the container’s root filesystem
    as read-only, preventing any accidental or malicious modifications to the base
    system.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create the Pod using the YAML as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Once the Pod is created, let us test a few commands inside the container to
    verify the securityContext we applied:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You can see the Read-only filesystem error; this is expected.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
    to learn more about the security context in Kubernetes.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: The next section introduces the control of network flow in Kubernetes using
    the **NetworkPolicy** object. You will see that you can build a kind of network
    firewall directly in Kubernetes so that you can prevent Pods from being able to
    reach one another.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Securing Pods using the NetworkPolicy object
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **NetworkPolicy** object is the last resource kind we need to discover as
    part of this chapter to have an overview of services in this chapter. NetworkPolicy
    will allow you to define network firewalls directly implemented in your cluster.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Why do you need NetworkPolicy?
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have to manage a real Kubernetes workload in production, you’ll have
    to deploy more and more applications onto it, and it is possible that these applications
    will have to communicate with each other.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Achieving communication between applications is really one of the fundamental
    objectives of a microservice architecture. Most of this communication will be
    done through the network, and the network is forcibly something that you want
    to secure by using firewalls.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes has its own implementation of network firewalls called NetworkPolicy.
    Say that you want one nginx resource to be accessible on port `80` from a particular
    IP address and to block any other traffic that doesn’t match these requirements.
    To do that, you’ll need to use NetworkPolicy and attach it to that Pod.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'NetworkPolicy brings three benefits, as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: You can build egress/ingress rules based on **Classless Inter-Domain Routing**
    (**CIDR**) blocks.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can build egress/ingress rules based on Pods labels and selectors (just
    as we’ve seen before with services’ and Pods’ association).
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can build egress/ingress rules based on namespaces (a notion we will discover
    in the next chapter).
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, keep in mind that for NetworkPolicy to work, you’ll need to have a
    Kubernetes cluster with a CNI plugin installed. CNI plugins are generally not
    installed by default on Kubernetes. If you’re using minikube for learning purposes,
    the good news is that it has an integration with Calico, which is a CNI plugin
    with NetworkPolicy support implemented out of the box. You just need to recreate
    the `minikube` cluster this way:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If you’re using Kubernetes on top of a cloud platform, we suggest you read the
    documentation of your cloud provider in order to verify which CNI options your
    cloud platform offers and whether it implements NetworkPolicy support.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Pods are not isolated by default
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, in Kubernetes, Pods are not isolated and any Pod can be reached
    by any other Pod without any constraint.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t use NetworkPolicy, Pods will remain just like that: accessible
    by everything without any constraint. Once you attach the NetworkPolicy to a Pod,
    the rules described on the NetworkPolicy will be applied to the Pod.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'To establish communication between two Pods associated with network policies,
    both sides must be open. It means Pod *A* must have an egress rule to Pod *B*,
    and Pod *B* must have an ingress rule from Pod *A*; otherwise, the traffic will
    be denied. The following figure illustrates this:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – One of the Pods is broken but the service will still forward
    traffic to it'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B22019_18_08.png)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.8: One of the Pods is broken but the service will still forward traffic
    to it'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you’ll have to troubleshoot NetworkPolicy because it can be
    the root cause of a lot of issues. Let’s now configure a NetworkPolicy between
    two Pods by using labels and selectors.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Configuring NetworkPolicy with labels and selectors
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, let’s create two nginx Pods to demonstrate our example. To demonstrate
    the isolation, we will use two separate namespaces in this example. You will learn
    more about Kubernetes namespace a in *Chapter 6*, *Namespaces, Quotas, and Limits
    for Multi-Tenancy in Kubernetes*.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Implementing complete communication isolation within a namespace can be complex
    and have unintended consequences. Carefully evaluate your needs and potential
    impacts before applying any restrictions.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the namespaces and two Pods with two distinct labels so that they
    become easier to target with the NetworkPolicy.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `web1` namespace with `nginx1` pod will be created as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Also, the `web2` namespace with a `nginx2` pod will be created as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the previous code snippets, we used namespaces (`web1` and `web2`) instead
    of deploying to the `default` namespace.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the resources and verify the Pods as follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now that the two Pods are created with distinct labels inside different namespaces,
    we use the `-o wide` flag to get the IP address of both Pods. Run a `curl` command
    from the `nginx1` Pod to reach the `nginx2` Pod, to confirm that by default, network
    traffic is allowed because no NetworkPolicy is created at this point. The code
    is illustrated here; `10.244.120.72` is the IP address of the `nginx2` Pod in
    the `web2` namespace:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you can see, we correctly received the nginx home page from the `nginx2`
    Pod.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s block all the ingress traffic to the `web2` namespace explicitly.
    To do that, we can create a default policy as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the preceding YAML snippet, note the following:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '`podSelector: {}`: Selects pods to which the NetworkPolicy applies. In this
    case, {} selects all pods in the namespace. This means that the rules defined
    in the NetworkPolicy *will apply to all pods in the namespace*, regardless of
    their labels.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`policyTypes: - Ingress`: Specifies the type of policy being applied, which
    is “Ingress” in this case. This means that the NetworkPolicy will control incoming
    (ingress) traffic to the selected pods.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ingress: []`: Defines the list of ingress rules for the NetworkPolicy. In
    this case, the list is empty (`[]`), indicating that there are no specific ingress
    rules defined. Therefore, all incoming traffic to the selected pods will be denied
    by default.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s apply this deny policy to our `web2` namespace to block all incoming
    (ingress) traffic as follows:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We will try to access the `nginx2` pod from `nginx1` pod now and see the output:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It is clear from the previous output that the traffic to `web2` namespace and
    Pods are denied with the `default-deny-ingress` NetworkPolicy resource.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add NetworkPolicy to `nginx2` in the `web2` namespace to explicitly
    allow traffic coming from the Pod `nginx1` in the `web1` namespace. Here is how
    to proceed with the YAML code:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Please note the `namespaceSelector.matchLabels` here with the `project: web1`
    label, which we used for `web1` namespace explicitly for this purpose. Let’s apply
    this NetworkPolicy, as follows:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, let’s run the same `curl` command we did before, as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As you can see, it works just like it did before. Why? For the following two
    reasons:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '`nginx2` now explicitly allows ingress traffic on port `80` from `nginx1` in
    the `web1` namepsace; everything else is denied.'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nginx1` has no NetworkPolicy, and thus, egress traffic to everything is allowed
    for it.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that if no NetworkPolicy is set on the Pod, the default behaviour
    applies—everything is allowed for the Pod.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: We strongly encourage you to make a habit of using NetworkPolicy along with
    your Pod. Lastly, please be aware that NetworkPolicy can also be used to build
    firewalls based on CIDR blocks. It might be useful, especially if your Pods are
    called from outside the cluster. Otherwise, when you need to configure firewalls
    between Pods, it is recommended to proceed with labels and selectors as you already
    did with the services’ configuration.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will focus on yet another important aspect of securing Kubernetes,
    namely Securing Communication via TLS Certificates between Kubernetes components.
    In this section, we will talk about how the TLS certificate helps in securing
    the data in transit and ensures secure interactions among various components that
    make up the ecosystem of Kubernetes.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Securing Communication – TLS Certificates Between Kubernetes Components
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Kubernetes, secure communication between various components is critical.
    **Transport Layer Security** (**TLS**), and **Secure Sockets Layer** (**SSL**),
    play a crucial role in encrypting data transmissions and establishing trust between
    services.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: By implementing **TLS with mutual authentication** (**mTLS**), both the client
    and server involved in communication can verify each other’s identities using
    digital certificates issued by a trusted CA. This adds a layer of security by
    preventing unauthorized access and ensuring data integrity.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of how TLS certificates are used in Kubernetes:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '**API Server to etcd**: The API server, the central control plane component,
    communicates with etcd, the distributed key-value store, to manage cluster state.
    Utilizing mTLS between these components safeguards sensitive cluster data from
    interception or tampering.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ingress Controller to Services**: The ingress controller, acting as a single
    entry point for external traffic, routes requests to backend services. Implementing
    mTLS between the ingress controller and services ensures that only authorized
    services receive traffic, mitigating potential security breaches.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal Service Communication**: Services within the cluster can also leverage
    mTLS for secure communication. This is particularly important for services that
    handle sensitive data or require strong authentication.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Meshes – for instance, Istio:** These types of service mesh have
    a variety of advanced traffic management and security capabilities, such as automatic
    mTLS between microservices. This makes the process of securing service-to-service
    communication easier without having to embed these communications with TLS configuration
    in the code that developers manage.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load Balancers:** Applications deployed behind a load balancer can also be
    used to secure communication between the load balancer and backend services with
    the use of TLS. In a configuration like this, the data will remain encrypted along
    the entire path.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another security mechanism would be enabling IPSec within a Kubernetes cluster
    to encrypt network traffic between nodes. This may be useful in the protection
    of the traffic in cloud environments or between various data centers.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through the deployment of TLS certificates with mTLS, Kubernetes administrators
    significantly bolster the security of their clusters. This approach encrypts communication
    paths, verifies the identities of communicating components, and mitigates risks
    associated with unauthorized data access or tampering.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to enable container security using special
    containers such as gVisor and Kata Containers.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Container Security – gVisor and Kata Containers
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditional containers share the host operating system kernel with other applications
    running on the machine, which can pose security risks if a container vulnerability
    allows access to the underlying system. **gVisor** and **Kata Containers** emerge
    as alternative container runtime technologies that prioritize security. Let us
    learn about them in the next sections.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: gVisor (Guest Virtual Machine Supervisor)
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: gVisor is a lightweight virtual machine implemented in user space. It acts as
    a sandbox for each container, isolating it from the host kernel and other containers.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows the high-level architecture of gVisor.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_18_09.png)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.9: gVisor architecture'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: By virtualizing kernel functionalities for each container, gVisor ensures that
    container vulnerabilities cannot directly compromise the host system. It establishes
    a robust isolation boundary, even in compromised container scenarios. gVisor is
    best suited for environments requiring the highest level of security isolation,
    despite potentially higher resource overhead.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Kata Containers
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kata Containers utilize lightweight VMs that are similar to traditional VMs
    but optimized for container workloads. Kata Containers offers a secure execution
    environment by isolating containers within lightweight VMs. This enhanced isolation
    strengthens security compared to standard containers while maintaining performance
    efficiency.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: The following figure demonstrates how Kata Containers are different from traditional
    container technologies.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_18_10.png)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.10: Kata Containers versus traditional containers (source: https://katacontainers.io/learn/)'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Kata Containers are recommended when balancing strong security with optimal
    performance, particularly for resource-intensive workloads.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Using RuntimeClass for Security Profiles
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Kubernetes, utilize the `runtimeClassName` field in your pod spec to specify
    the container runtime environment. Here is an example configuration:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This setup directs Kubernetes to use the Kata Containers runtime for enhanced
    security isolation.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: We learned several important things about Kubernetes security in this chapter.
    Before we conclude the chapter, let us learn about another security topic in the
    next section, which is about accessing private registries and container images.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Managing Secrets and Registry Credentials
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kubernetes, registry credentials are necessary for securely pulling container
    images from private registries that require authentication. Without these credentials,
    Kubernetes pods cannot access images stored in private repositories. Managing
    these credentials securely is crucial to ensure that only authorized pods can
    retrieve and use specific container images.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Using `kubectl create secret docker-registry` simplifies the management of container
    registry credentials in Kubernetes. It ensures security by encrypting secrets
    at rest, making them accessible only to authorized nodes. This approach reduces
    complexity compared to manual methods, minimizing errors and improving operational
    efficiency. Moreover, it seamlessly integrates with Kubernetes pod specifications,
    allowing straightforward configuration of `imagePullSecrets` to authenticate pod
    access to private container registries.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Using kubectl to create a Docker registry secret
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate, here’s how you can create a Docker registry secret and integrate
    it into a Kubernetes pod configuration:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Replace `your-registry.com`, `your_username`, `your_password`, and `your-email@example.com`
    with your actual registry details.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your Pod YAML to use the newly created secret for pulling images from
    the private registry:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Ensure `my-registry-secret` matches the name used when creating the Docker registry
    secret.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: When Kubernetes creates the Pod, the image will be pulled from the private registry
    using the imagePullSecrets as the authentication credentials.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have reached the end of this long chapter about Kubernetes
    security.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered *authentication* and *authorization* in Kubernetes. First,
    we provided an overview of the available authentication methods in Kubernetes
    and explained how you can use ServiceAccount tokens for external user authentication.
    Next, we focused on RBAC in Kubernetes. You learned how to use Roles, ClusterRoles,
    RoleBindings, and ClusterRoleBindings to manage authorization in your cluster.
    We demonstrated a practical use case of RBAC for ServiceAccounts by creating a
    Pod that can list Pods in the cluster using the Kubernetes API (respecting the
    principle of least privilege).
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: After that, we learned about Admission Controllers in Kubernetes and what controllers
    are available to secure your Kubernetes cluster. We also learned about SecurityContext
    and different samples for securityContext configurations. We also discovered how
    to control traffic flow between Pods by using an object called NetworkPolicy that
    behaves like a networking firewall within the cluster. As part of the container
    security, we explored the alternative container runtimes such as Kata Containers
    and gVisor options. Finally, we learned how to configure the credentials for the
    private container registries. In the next chapter, we are going to dive deep into
    advanced techniques for scheduling Pods.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Controlling Access to the Kubernetes API**: [https://kubernetes.io/docs/concepts/security/controlling-access](https://kubernetes.io/docs/concepts/security/controlling-access)'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managing Service Accounts**: [https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/](https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/)'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configure Service Accounts for Pods**: [https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/)'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certificates and Certificate Signing Requests**: [https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/](https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/)'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: [https://kubernetes.io/docs/reference/access-authn-authz/authorization/](https://kubernetes.io/docs/reference/access-authn-authz/authorization/)'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What is OpenID Connect**: [https://openid.net/developers/how-connect-works/](https://openid.net/developers/how-connect-works/
    )'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Admission controller**: [https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers)'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security Context**: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context](https://kubernetes.io/docs/tasks/configure-pod-container/security-context)/'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code119001106479081656.png)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
