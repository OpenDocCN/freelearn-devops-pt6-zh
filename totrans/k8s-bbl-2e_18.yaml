- en: '18'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and authorization are the cornerstones of modern software systems
    in terms of providing the necessary identity management and access management,
    respectively. Many people confuse these two terms, despite the fact that they
    are quite different processes. Authentication has to do with the verification
    of the identity of a user, normally through some kind of mechanism like usernames
    and passwords, while authorization is all about what an authenticated user can
    access or do within a system. Authentication always comes first, after which authorization
    would take place in order for the system to be interacted with by verified users.
    Kubernetes extends this further with another model called **Role-Based Access
    Control** (**RBAC**), which allows an administrator to define roles with certain
    privileges and then assign those roles to users, hence effectively implementing
    the principle of least privilege and allowing fine-grained access control.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from Identity and Access Management, Kubernetes has a number of other
    security mechanisms to harden the rest of the components further. Being the most
    mature and widely adopted container orchestration platform, the design of Kubernetes
    places a lot of emphasis on the security of a wide range of components within
    clusters, nodes, containers, networks, and applications through the mitigation
    of risks at many layers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, this chapter goes into some of the basic Kubernetes security concepts,
    from the different ways in which the system can flexibly authenticate-in X509
    client certificates or tokens from OpenID Connect. In specialized cases, for example,
    the integration with LDAP, Kubernetes provides additional options. For example,
    the possibility of using an authenticating proxy or webhooks is also recommended.
    Then we will review the **RBAC** model from the platform that gives administrators
    control over access to resources in the cluster and allows them to manage users
    and groups along with ServiceAccounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also introduce one advanced feature in Kubernetes: Admission Controllers.
    An Admission Controller enforces security policies at the point of resource admission
    to validate and control resources before they enter the cluster. Admission controllers
    provide an additional layer of defense by governing resource requests through
    the enforcement of policies on the creation and modification of resources.'
  prefs: []
  type: TYPE_NORMAL
- en: Pods and containers themselves need to be secured, as these are the runtimes
    of the workloads or applications that could interact with sensitive information.
    Kubernetes provides a set of `securityContext` options that enable administrators
    to declare particular security settings for containers; this includes forcing
    containers to run as non-root. Equally important will be network security, and
    we’ll discuss how NetworkPolicies provide a mechanism to segregate and secure
    pod communication inside the cluster by controlling traffic flow at a granular
    level.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll then move to container runtime security. We will look at gVisor and Kata
    Containers as options for runtime, which introduce more security boundaries between
    either a user-space kernel to intercept system calls or a lightweight VM environment
    per container, respectively, which provides the speed of containers but the security
    of a VM.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, and most importantly, private registry credentials hold the key to guaranteeing
    security around container images inside the cluster. We will go through how Kubernetes
    handles these credentials safely – ensuring that only authorized components have
    access to them. By the end of this chapter, you will have a deeper understanding
    of these advanced security concepts and tools in Kubernetes. You will see precisely
    how to enhance your cluster’s security posture, reduce risks, and have the best
    defense against possible vulnerabilities. With such measures, you will be able
    to secure your Kubernetes deployments at every layer, from identity management
    right through to runtime isolation, and reinforce the robustness of your containerized
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and Authorization – User Access Control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admission Control – Security Policies and Checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing Pods and Containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Secrets and Registry Credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes cluster to be deployed. We recommend using a multi-node o*r* cloud-based
    Kubernetes cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kubernetes CLI (`kubectl`) installed on your local machine and configured
    to manage your Kubernetes cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic Kubernetes cluster deployment (local and cloud-based) and `kubectl` installation
    were covered in *Chapter 3*, *Installing Your First Kubernetes Cluster*.
  prefs: []
  type: TYPE_NORMAL
- en: The previous chapters (*15*, *16*, and *17*) of this book have provided you
    with an overview of how to deploy a fully functional Kubernetes cluster on different
    cloud platforms and install the requisite CLIs to manage them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the latest code samples for this chapter from the official
    GitHub repository: [https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter18](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter18).'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and Authorization – User Access Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It gives grounds for access control in ensuring that only authenticated and
    authorized users can use Kubernetes resources. Authentication verifies the identity
    of a user, while authorization decides what an authenticated user is allowed to
    do within the cluster. Kubernetes offers flexibility in authenticating via X509
    certificates, OpenID Connect, token-based, and other approaches. Coupled with
    the verification process, RBAC does offer fine granular control over what users
    can do, thus helping administrators manage a wide range of permissions efficiently
    – a subject that will be dealt with in further detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Let us start with authentication in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and User Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Kubernetes API server provides RESTful endpoints for managing the Kubernetes
    cluster and acts as the frontend to the shared state of the cluster. All interactions
    with the cluster, from users to internal components, are channeled through the
    Kubernetes API server, which acts as a frontend to the cluster’s shared state.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how the authentication mechanism works in Kubernetes in the next
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: The authentication workflow in Kubernetes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like a high-security facility, your Kubernetes cluster needs robust security
    measures to protect its resources. This involves a layered approach with several
    key components working together, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_18_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.1: Request to Kubernetes API goes through several stages (source:
    https://kubernetes.io/docs/concepts/security/controlling-access/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: This acts as the first line of defense, verifying the identity
    of anyone trying to access the Kubernetes API server. Imagine it like a security
    guard checking IDs at the entrance. Users might use passwords, tokens, or special
    certificates to prove they’re authorized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: Once someone’s identity is confirmed, authorization determines
    what they can actually do within the cluster. Think of it as granting specific
    access levels. Users might have permission to view resources, but not modify them,
    or they might be authorized to create new resources but only in specific areas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Admission Control**: This stage adds an extra layer of scrutiny. Imagine
    it like a security scanner at the entrance. Admission control modules can inspect
    incoming requests, ensuring they comply with predefined security policies. They
    can even modify requests to enforce specific rules or reject them entirely if
    they pose a threat.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auditing**: Just like keeping a log of who enters and exits a secure facility,
    auditing in Kubernetes keeps a record of all activity within the cluster. This
    includes actions taken by users, applications, and even the control plane itself.
    These logs are invaluable for monitoring suspicious activity and maintaining a
    secure environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By working together, these security measures create a layered defense system,
    ensuring that only authorized users can access your Kubernetes cluster and that
    their actions comply with established security policies.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn some more details about the authentication mechanism in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication to the Kubernetes API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes API authentication ensures that only authorized users or services
    are allowed to talk to the resources running in a cluster. Each incoming request
    goes through an authentication setup, which is done in a chain of authenticator
    modules that are configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Requests to the API are always one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Associated with an external, normal user or a **ServiceAccount** defined in
    the Kubernetes cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Treated as *anonymous* requests if the cluster has been configured to allow
    anonymous requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is determined in the *authentication* process – the entire HTTP request
    is used as input to the process, but usually only request headers or the client
    certificate is analyzed. Authentication is carried out by authentication modules
    that depend on the cluster configuration. Your cluster may have multiple authenticator
    modules enabled, and then each of them is executed in sequence until one succeeds.
    If the request fails to authenticate, the API server will either respond with
    an HTTP status code of `401 (unauthorized)` or, if anonymous requests are enabled,
    treat it as anonymous.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous requests are essentially mapped to a special username called `system:anonymous`
    and a group called `system:unauthenticated`. This means that you can organize
    your authorization to resources for such requests, just as you can for other users
    or ServiceAccounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since all operations inside and outside the cluster must go through the Kubernetes
    API server, this means that all of them must go through the authentication process.
    This includes the operations of internal cluster components and Pods, which query
    the API server. For you, as an external user of the cluster, any requests that
    you make using `kubectl` commands or directly to the Kubernetes API server will
    also go through the authentication process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal users**: Such users are managed *externally*, independent from the
    Kubernetes cluster. Currently, Kubernetes does not provide any objects to represent
    such users. The external management of users may be as simple (but *not* recommended)
    as static user-password files passed to the API server using the `token-auth-file`
    argument in the static Pod definition file `/etc/kubernetes/manifests/kube-apiserver.yaml`
    inside your control plane nodes (AKA master nodes) during startup. For production
    environments, leverage existing **identity providers** (**IdPs**) like **Google**,
    **GitHub**, **Azure Active Directory** (**AAD**), or **AWS IAM** to manage users.
    Integrate your Kubernetes cluster with these IdPs using **OpenID Connect** **(OIDC**
    – [https://openid.net/connect/](https://openid.net/connect/)) tokens for a seamless
    authentication experience. Remember, regular user accounts in Kubernetes are global
    and don’t have namespace restrictions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service accounts**: These are managed by the Kubernetes cluster and modeled
    as ServiceAccount objects. You can create and manage service accounts just like
    any other resource in Kubernetes, for example, using `kubectl` and YAML manifest
    files. This type of account is intended for processes in cluster components or
    running in Pods. The credentials for ServiceAccounts will be created as Secrets
    (manually or via TokenRequest API) that are mounted into Pods so that the container
    process can use them to talk to the Kubernetes API server. When a process authenticates
    using a `ServiceAccount` token, it is seen as a user called `system:serviceaccount:<namespace>:<serviceAccountName>`.
    Note that ServiceAccounts are namespaced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, user management in Kubernetes is a mixture of different approaches
    that should fit all the needs of different organizations. The key takeaway here
    is that after the authentication process, the request will be either rejected
    (optionally treated as anonymous) or treated as coming from a particular user.
    The `username` attribute may be provided by the external user management system,
    as in the case of normal users, or it will be `system:serviceaccount:<namespace>:<serviceAccountName>`
    for ServiceAccounts. Additionally, the request will have more attributes associated
    with it, such as **User ID** (**UID**), **groups**, and **extra fields**. This
    information is used for authorization processes based on RBAC, which we will explain
    in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the authentication methods that you can use with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication Methods in Kubernetes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The various authentications, in general, help in securely controlling access
    in Kubernetes to the API server. To validate users and services, a variety of
    authentication strategies can be enabled. Each is suited to different use cases
    and levels of security. These include tokens and certificates that verify the
    identities of both human users and applications interacting with the cluster.
    The good thing about the Kubernetes API server is that it provides support for
    multiple authentication mechanisms, so clusters can be configured using a combination
    of the previously-mentioned methods. In the following section, we will present
    some common authentication methods such as Static Token files, ServiceAccount
    tokens, X.509 client certificates, and OpenID Connect tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Static token files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method is the most basic one that Kubernetes offers for managing normal
    users. The approach somewhat resembles the `/etc/shadow` and `/etc/passwd` files
    in Unix/Linux systems. Note, however, that it is *not* recommended and is considered
    *unsecure* for production clusters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this method, you define a `.csv` file where each line has the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you pass the file when starting the Kubernetes API server process using
    the `token-auth-file` parameter in the static Pod definition file `/etc/kubernetes/manifests/kube-apiserver.yaml`
    inside your control plane nodes (AKA master nodes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To authenticate against the API server, you need to use a standard HTTP **bearer
    authentication scheme** for your requests. This means that your requests will
    need to use an additional header that’s in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Based on this request information, the Kubernetes API server will match the
    token against the static token file and assign user attributes based on the matched
    record.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `kubectl`, you must modify your `kubeconfig`. You can do this using
    the `kubectl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After that, you need to create and use context with this user for your requests
    using the `kubectl config use-context` command.
  prefs: []
  type: TYPE_NORMAL
- en: In Kubernetes versions prior to 1.19, there was a similar authentication method
    that allowed us to use an HTTP **basic authentication scheme** and a file passed
    by the `basic-auth-file` parameter to the API server. This method is no longer
    supported due to security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram visualizes the principles behind this method of authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.1 – Static token file authentication in Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B22019_18_02.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.2: Static token file authentication in Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: We can now summarize the advantages and disadvantages of using the static token
    file method for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of the static token file method are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to configure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages of the static token file method are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is unsecure; exposing a token file compromises all cluster users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requires that we manually manage users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new users or removing existing ones requires that we restart the Kubernetes
    API server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating any tokens requires that we restart the Kubernetes API server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes extra effort to replicate the Token file content to every control plane
    node when you have a high availability control plane with multiple control plane
    nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, this method is good for development environments and learning the
    principles behind authentication in Kubernetes, but it is not recommended for
    production use cases. Next, we will take a look at authenticating users using
    ServiceAccount tokens.
  prefs: []
  type: TYPE_NORMAL
- en: ServiceAccount tokens
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we mentioned in the introduction to this section, ServiceAccounts are meant
    for in-cluster identities for processes running in Pod containers or for cluster
    components. However, they can be used for authenticating external requests as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: ServiceAccounts are Kubernetes objects and can be managed like any other resource
    in the cluster; that is, by using `kubectl` or raw HTTP requests to the API server.
    The tokens for ServiceAccounts are **JSON Web Tokens** (**JWTs**) and will be
    generated on-demand or using the `kubectl create token` command.
  prefs: []
  type: TYPE_NORMAL
- en: Every Kubernetes namespace has a pre-created ServiceAccount named `default`.
    Pods without a specified ServiceAccount automatically inherit this default account
    for authorization within the cluster. You can verify a Pod’s ServiceAccount using
    `kubectl get pods/<podname> -o yaml` and checking the `spec.serviceAccountName`
    field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, when defining a Pod, you can specify what ServiceAccount should be
    used for processes running in the containers. You can do this using `.spec.serviceAccountName`
    in the Pod specification. The JWT token will be injected into the container; then,
    the process inside can use it in the HTTP bearer authentication scheme to authenticate
    to the Kubernetes API server. This is only necessary if it interacts with the
    API server in any way, for example, if it needs to discover other Pods in the
    cluster. We have summarized this authentication method in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.2 – ServiceAccount authentication in Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B22019_18_03.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.3: ServiceAccount authentication in Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: This also shows why ServiceAccount tokens can be used for external requests
    – the API server does not care about the origin of the request; all it is interested
    in is the bearer token that comes with the request header. Again, you can use
    this token in `kubectl` or in raw HTTP requests to the API server. Please note
    that this is generally not a recommended way to use ServiceAccounts, but it can
    be used in some scenarios, especially when you are unable to use an external authentication
    provider for normal users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to version 1.22, Kubernetes automatically generated API credentials for
    ServiceAccounts using Secrets. These Secrets contained tokens that Pods could
    mount for access. This approach had limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static Tokens**: Secrets stored tokens in plain text, posing a security risk
    if compromised.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited Control**: Token lifespans and permissions were not easily managed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Starting from version 1.22, Kubernetes switched to a more secure approach.
    Pods now obtain tokens directly using the **TokenRequest** API. These tokens are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Short-lived**: Tokens have limited lifespans, reducing the impact of potential
    compromise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mounted into Pods**: Tokens are automatically mounted as volumes, eliminating
    the need for pre-stored Secrets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While automatic mounting is preferred, you can still manually create Secrets
    for service account tokens. This might be useful for tokens requiring longer lifespans,
    but it’s important to prioritize automatic token mounting for enhanced security
    in most scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we learned, Kubernetes automatically mounts Service Account API credentials
    within Pods for streamlined access. To disable this behavior and manage tokens
    differently, set `automountServiceAccountToken: false` either in the ServiceAccount
    manifest or within the Pod specification. This setting applies to all Pods referencing
    the ServiceAccount unless overridden by the specific Pod configuration. If both
    are defined, the Pod’s setting takes precedence. Refer to the documentation for
    more details ([https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#opt-out-of-api-credential-automounting](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#opt-out-of-api-credential-automounting)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now demonstrate how you can create and manage ServiceAccounts and how
    you can use JWT tokens to authenticate when using `kubectl`. This will also give
    a sneak peek into RBAC, which we are going to look at in more detail in the next
    section. Please follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a YAML manifest for a new Namespace and a ServiceAccount as follows.
    We will configure RBAC for this account so that it can only read Pods in that
    namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that you can also use the *imperative* command `kubectl create serviceaccount
    example-sa` to create the resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a YAML manifest for a `Role` object named `pod-reader` in the `example-ns`
    namespace. This role will allow you to get, watch, and list Pods in this namespace.
    The `01_serviceaccount/pod-reader-role.yaml` YAML manifest file has the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a YAML manifest for `RoleBinding` named `reads-pods`. This is what *associates*
    the role that we created with our `example-sa` ServiceAccount – the account will
    now have the privilege of read-only access to Pods, and nothing more. The `01_serviceaccount/read-pods-rolebinding.yaml`
    YAML manifest file has the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can apply all the manifest files to the cluster at once using the `kubectl
    apply` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will create a Token for the ServiceAccount as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Collect the JWT token from the command output, which you can use to authenticate
    as that ServiceAccount. If you are interested, you can inspect the contents of
    the JWT using [https://jwt.io/](https://jwt.io/) as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_18_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.4: Inspecting a JWT for ServiceAccount'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the JWT maps to the `example-sa` ServiceAccount in the `example-ns`
    namespace. Additionally, you can identify that the actual username (marked as
    a `subject` in the payload) that will be mapped to in Kubernetes is `system:serviceaccount:example-ns:example-sa`,
    as we explained previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this token, we can set up kubeconfig to test it. First, you need to create
    a user in your `kubeconfig` using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where the `example-sa` is the new ServiceAccount you have created and also replace
    `<your-token>` with the token string you collected earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new context that uses this user in the `kubeconfig`. You also need
    to know the cluster name that you are connecting to right now – you can check
    it using the `kubectl config view` command. Use the `kubectl config set-context`
    command to create a new context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For example, use the following command to create a new context named `example-sa-context`
    with minikube as the target cluster and `example-sa` as the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we switch to the newly created context, let us create a simple nginx
    Pod in the `example-ns` namespace. Copy the sample YAML `Chapter18/references/sa-demo-nginx-pod.yaml`
    to `Chapter18/01_serviceaccount/nginx-pod.yaml` and apply the configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, before you switch to the new context, you may want to check the name
    of the context that you are currently using by utilizing the `kubectl config current-context`
    command. This will make it easier to go back to your old cluster admin context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, switch to the new context using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also verify the identity of the credential you are currently using
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now ready to verify that our authentication works and that the RBAC
    roles allow read-only access to Pods in the `example-ns` namespace. First, try
    getting Pods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This worked as expected! Now, try getting Pods from the `kube-system` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have authenticated correctly, but the action was forbidden by RBAC authorization,
    which is what we expected. Lastly, let’s try getting Service objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is also expected as the RBAC is not configured for the ServiceAccount to
    view or list the Service resources in the `example-ns` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have successfully used our ServiceAccount token for authentication
    and we have verified that our privileges work correctly. You can now switch back
    to your old `kubectl` context using the `kubectl config use-context <context-name>`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding procedure of configuring the `kubectl` context with a bearer token
    can be used for the static token file authentication method as well.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s summarize what the advantages and disadvantages of using ServiceAccount
    tokens for authentication are.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of using ServiceAccount tokens are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to configure and use, similar to static token files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entirely managed by the Kubernetes cluster, so there’s no need for external
    authentication providers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ServiceAccounts are namespaced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages of using ServiceAccount tokens are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ServiceAccounts are intended for processes running in Pod containers to give
    them identity and let them use Kubernetes RBAC. *It is not a best practice for
    a user to use the ServiceAccount token*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, using ServiceAccount tokens for external authentication is only
    good for development and test scenarios when you cannot integrate with external
    authentication providers. However, for production clusters, it is not the best
    option, mainly due to security concerns. Now, let’s take a look at using X.509
    client certificates for Kubernetes API authentication.
  prefs: []
  type: TYPE_NORMAL
- en: X.509 client certificates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using X.509 client certificates is one of the industry standards for authentication
    processes. There is one important catch, however – you need to have good means
    of managing certificate signing, revoking, and rotation. Otherwise, you may hit
    very similar security issues as with using ServiceAccount tokens. You can learn
    more about X.509 certificates and the processes around them at [https://www.ssl.com/faqs/what-is-an-x-509-certificate/](https://www.ssl.com/faqs/what-is-an-x-509-certificate/).
  prefs: []
  type: TYPE_NORMAL
- en: 'This method works in Kubernetes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kubernetes API server starts with the `client-ca-file` argument. This provides
    **certificate authority** (**CA**) information to be used to validate client certificates
    presented to the API server. You can configure a custom CA certificate here or
    use the default CA created as part of the cluster deployment. For example, if
    you are using minikube, you can see a default CA file already configured in `kube-apiserver`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Users who want to authenticate against the API server need to request an X.509
    client certificate from the CA. This should be a secure and audited process. The
    subject common name (the `CN` attribute in the subject) of the certificate is
    used as the `username` attribute when authentication is successful. Note that
    as of Kubernetes 1.19, you can use the Certificates API to manage signing requests.
    More information is available in the official documentation: [https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/](https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The user must present the client certificate during authentication to the API
    server, which validates the certificate against the CA. Based on that, the request
    goes through the authentication process successfully or is rejected. Again, if
    you are using a minikube cluster, you are already utilizing the certificate-based
    authentication, as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While using the `kubectl` commands, users can configure this method of authentication
    in kubeconfig using the `kubectl config set-credentials` command, as we learned
    earlier. We have summarized this process in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.4 – X.509 client certificate authentication in Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B22019_18_05.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.5: X.509 client certificate authentication in Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this visualizes the case when initial CSR by the user is handled
    by the Certificate API in a Kubernetes cluster. This does not need to be the case
    as CA may be external to the cluster, and the Kubernetes API server can rely on
    a copy of the CA `.pem` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following hands-on exercise, we will generate and configure certificate-based
    authentication in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with creating a private key using the `openssl` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate a **CertificateSigningRequest** (**CSR**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Gather the CSR data and encode it using base64:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to create a `CertificateSigningRequest` resource with **Certificates
    API**; let us use the `csr.yaml` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `CertificateSigningRequest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now the administrators (or the users with the `certificatesigningrequests`
    privilege) can see the CSR resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check and approve the CSR as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the CSR is approved, gather the certificate data from the approved CSR
    resource as follows; the following command will extract the data to `iamgini.crt`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have the private key and certificate as follows (you can delete the
    `.csr` file as it is not required anymore):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will configure the `kubeconfig` with our new user and context; create
    a new user entry in the `kubeconfig` as follows (remember to use the full path
    of the key and certificate file):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new context with the new user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the kubeconfig is updated with the new user and context. Let us test the
    access. Change the kubeconfig context as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify the context and connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Congratulations; you have configured a new user with X509 certificate-based
    authentication. But remember, the user will not be able to do any kind of operation
    until you configure the appropriate RBAC resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on what we have learned, we can summarize the advantages of this method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a much more secure process than using ServiceAccount tokens or static token
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being unable to store certificates in the cluster means that it is not possible
    to compromise all certificates. X.509 client certificates can be used for high-privileged
    user accounts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X.509 client certificates can be revoked on demand. This is very important in
    case of security incidents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages of X.509 client certificate authentication are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Certificates have an expiry date, which means they cannot be valid indefinitely.
    For simple use cases in development, this is a disadvantage. From a security perspective,
    in production clusters, this is a huge *advantage. But remember to ensure the
    certificate is stored safely as the file-based authentication mechanism is a security
    risk; the file could be stolen and used for unauthorized access*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring certificate expiration, revocation, and rotation must be handled.
    This should be an automated process so that we can quickly react in the case of
    security incidents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using client certificates in the browser for authentication is troublesome,
    for example, when you would like to authenticate to Kubernetes Dashboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key takeaway is that using X.509 client certificates is secure but requires
    sophisticated certificate management so that we have all the benefits. Now, we
    will take a look at OpenID Connect tokens, which is the recommended method for
    cloud environments.
  prefs: []
  type: TYPE_NORMAL
- en: OpenID Connect tokens
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using **OpenID Connect** (**OIDC**), you can achieve a **single sign-on** (**SSO**)
    experience for your Kubernetes cluster (and possibly other resources in your organization).
    OIDC is an authentication layer that’s created on top of OAuth 2.0, which allows
    third-party applications to verify the identity of the end-user and obtain basic
    user profile information. OIDC uses JWTs, which you can obtain using flows that
    conform to the OAuth 2.0 specifications. The most significant issue with using
    OIDC for authenticating in Kubernetes is the limited availability of OpenID providers.
    But if you are deploying in a cloud environment, all tier 1 cloud service providers
    such as Microsoft Azure, Amazon Web Services, and Google Cloud Platform have their
    versions of OpenID providers. The beauty of *managed* Kubernetes cluster deployments
    in the cloud, such as AKS Amazon EKS, and Google Kubernetes Engine, is that they
    provide *integration* with their native OpenID provider out of the box or by a
    simple flip of a configuration switch. In other words, you do not need to worry
    about reconfiguring the Kubernetes API server and making it work with your chosen
    OpenID provider – you get it alongside the managed solution. If you are interested
    in learning more about the OIDC protocol, you can refer to the official web page
    at [https://openid.net](https://openid.net).
  prefs: []
  type: TYPE_NORMAL
- en: For more details and more specific flows, such as in the context of AAD please
    take a look at [https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, you can see the basics of the OIDC authentication
    flow on Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.5 – OpenID Connect authentication in Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B22019_18_06.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.6: OIDC authentication in Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing is that the OpenID provider is responsible for the
    SSO experience and managing the bearer tokens. Additionally, the Kubernetes API
    server must validate the bearer token that’s received against the OpenID provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using OIDC has the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: You get SSO experience, which you can use with other services in your organization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the cloud service providers have their own OpenID providers that easily
    integrate with their managed Kubernetes offerings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be also used with other OpenID providers and non-cloud deployments –
    this requires a bit more configuration though.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s a secure and scalable solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages of the OIDC approach can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes has no web interface where you can trigger the authentication process.
    This means that you need to get the credentials by manually requesting them from
    the IdP. In managed cloud Kubernetes offerings, this is often solved by additional
    simple tooling to generate `kubeconfig` with credentials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OIDC tokens can be revoked by the IdP if it supports the token endpoint revocation
    feature. This allows you to invalidate tokens before their expiration time, for
    example, if a user’s account is compromised. However, not all IdPs support this
    feature, and Kubernetes doesn’t handle token revocation itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OIDC in Kubernetes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Kubernetes does not provide an integrated OpenID Connect Identity Provider.
    Thus, it relies on the external ones provided either by cloud providers or stand-alone
    tools. As we mentioned earlier in this section, the most popular cloud environments
    – like AWS, GCP, and Azure – natively provide OIDC integration in their managed
    Kubernetes offerings, which makes it pretty straightforward to enable SSO. Alternatively,
    the identity providers can also be set up independently for every organization
    using tools such as Dex, Keycloak, UAA, or OpenUnison for the non-cloud or self-managed
    Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Identity Provider Requirements in Kubernetes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For an OIDC identity provider to work with Kubernetes, it has to satisfy a
    number of important prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Support OIDC Discovery**: OIDC discovery simplifies configuration efforts
    as through it all information about IdP endpoints and public keys are made available.
    Kubernetes reads the IdP’s public keys from the discovery endpoint to validate
    OIDC tokens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transport Layer Security** (**TLS**) **Compliance**: The identity provider
    shall handle TLS to handle non-obsolete ciphers as sensitive authentication data
    handling is at stake.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CA-Signed Certificate**: Whether by using a commercial CA or a self-signed
    certificate, the certificate of the identity provider must have the `CA` flag
    set to `TRUE`. This is because Kubernetes uses Go’s TLS client which strictly
    enforces this requirement so that Kubernetes can safely trust the identity provider’s
    certificates during user token verification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the self-deployer of an identity provider without a commercial CA, such
    tools as the Dex gencert script may be used to create a compliant CA certificate
    along with the signing key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list contains some of the popular OIDC Identity Providers for
    Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dex**: One of the more lightweight, open-source popular IdPs intended for
    use in a Kubernetes environment. it supports OIDC and works well with the authentication
    workflow that Kubernetes expects. Dex works by hooking into other external IdPs
    such as LDAP, GitHub, and Google, which would make it a good choice for organizations
    with more complicated identity scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keycloak**: This is an open-source IdP that offers a more powerful feature
    set with extensive support for OIDC and SAML. Besides core functionality, Keycloak
    supports enterprise-grade features such as user federation and RBAC. Keycloak
    would be a good fit if you want to have more control or customization in your
    authentication setup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenUnison**: Another IdP that is optimized for Kubernetes is OpenUnison,
    with features like natively integrating the Kubernetes RBAC and identity federation.
    It should be popular with enterprises that are ready to engage a prebuilt solution
    optimized to their own needs for securing Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud Foundry User Account and Authentication** (**UAA**): This is an open-source
    multi-purpose IdP originating from Cloud Foundry. It supports OIDC and does an
    extremely strong job with cloud platform and enterprise authentication system
    integrations, making it suitable for more complex Kubernetes deployments in hybrid
    cloud environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring OIDC with Kubernetes API Server
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Enabling OIDC in Kubernetes will involve some configuration of the Kubernetes
    API server with certain OIDC-related flags. The major configurations include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`oidc-issuer-url`: The URL of the OIDC provider. It is used by Kubernetes for
    verification of token authenticity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oidc-client-id string`: The client ID to use when authenticating with the
    IdP when Kubernetes is the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oidc-username-claim`: Specifies which claim in the token should map to the
    Kubernetes username.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oidc-groups-claim`: Maps the groups in the IdP to Kubernetes groups, in order
    to manage RBAC roles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For further details on configuring specific OIDC identity providers, you can
    refer to the official resources such as Dex for Kubernetes Guide ([https://dexidp.io/docs/guides/kubernetes/](https://dexidp.io/docs/guides/kubernetes/))
    or OpenID Connect Authentication in Kubernetes ([https://kubernetes.io/docs/reference/access-authn-authz/authentication/](https://kubernetes.io/docs/reference/access-authn-authz/authentication/)).
  prefs: []
  type: TYPE_NORMAL
- en: The key takeaway about OIDC is that this is your best bet when configuring authentication
    for Kubernetes, especially if you are deploying production clusters in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Other methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Kubernetes offers a few other authentication methods that you can use. They
    are mainly intended for advanced use cases, such as integrating with LDAP or Kerberos.
    The first one is an **authenticating proxy**.
  prefs: []
  type: TYPE_NORMAL
- en: When you use an authenticating proxy in front of the Kubernetes API server,
    you can configure the API server to use certain HTTP headers to extract authentication
    user information from them. In other words, your authenticating proxy is doing
    the job of authenticating the user and passing down this information alongside
    the request in the form of additional headers.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information in the official documentation ([https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authenticating-proxy](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authenticating-proxy)).
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is known as **webhook token authentication**, whereby the Kubernetes
    API server uses an external service to verify the bearer tokens. The external
    service receives the information in the form of a TokenReview object from the
    API server via an HTTP POST request, performs verification, and sends back a TokenReview
    object with additional information about the result.
  prefs: []
  type: TYPE_NORMAL
- en: Find more information from the official documentation (https://kuberntes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication).
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes also uses another common authentication method called **bootstrap
    tokens**. But bootstrap tokens are not used for general authentication but for
    the cluster node. Bootstrap tokens are a special type of secret in Kubernetes
    that simplify adding new nodes to a cluster. Stored in the `kube-system` namespace,
    these short-lived tokens allow the API server to authenticate kubelets (programs
    running on nodes) during the initial connection. This streamlines the bootstrapping
    process, making it easier to join new nodes or create new clusters from scratch.
    They can be used with or without the kubeadm tool and work seamlessly with Kubelet
    TLS Bootstrapping for secure communication. Refer to the documentation ([https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens](https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens))
    to learn about authentication with bootstrap tokens and TLS bootstrapping.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you need the authenticating proxy and webhook token authentication
    methods in special cases where you want to integrate with existing identity providers
    in your organization that are not supported by Kubernetes out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at authorization and RBAC in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization and introduction to RBAC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Security in Kubernetes relies on two crucial processes: **authentication**
    and **authorization**. Authentication verifies the identity of a user attempting
    to access the system, ensuring they are who they claim to be. This initial step
    typically involves checking credentials like usernames and passwords or tokens.'
  prefs: []
  type: TYPE_NORMAL
- en: Following successful authentication, authorization comes into play. This process
    determines what actions a user can perform within the system. In Kubernetes, the
    API server evaluates a user’s identity (derived from authentication) along with
    other request attributes, such as the specific API endpoint or action being requested.
    Based on pre-defined policies or external services, authorization modules decide
    whether to allow or deny the request.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is the first step in determining the identity of the user, whereas
    authorization is the next step when verifying if the user can perform the action
    they want to.
  prefs: []
  type: TYPE_NORMAL
- en: Access controls based on specific object fields are handled by admission controllers,
    which occur after authorization and only if authorization allows the request.
    We will learn about admission controllers in the later sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the Kubernetes API server, authenticating a request results in a set of additional
    request attributes such as **user**, **group**, **API request verb**, **HTTP request
    verb**, and so on. These are then passed further to authorization modules that,
    based on these attributes, answer whether the user is allowed to do the action
    or not. If the request is denied by any of the modules, the user will be presented
    with an HTTP status code of `403 (Forbidden)`.
  prefs: []
  type: TYPE_NORMAL
- en: This is an important difference between HTTP status codes. If you receive `401
    (Unauthorized)`, this means that you have been not recognized by the system; for
    example, you have provided incorrect credentials or the user does not exist. If
    you receive `403 (Forbidden)`, this means that authentication has been successful
    and you have been recognized, but you are not *allowed* to do the action you requested.
    This is useful when debugging issues regarding access to a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes has a few authorization modes available that can be enabled by using
    the `authorization-mode` argument when starting the Kubernetes API server, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the authorization modes available in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RBAC**: This allows you to organize access control and management with roles
    and privileges. RBAC is one of the industry standards for access management, also
    outside of Kubernetes. Roles can be assigned to users in the system, which gives
    them certain privileges and access. In this way, you can achieve very fine-grained
    access management that can be used to enforce the **principle of least privilege**.
    For example, you can define a role in the system that allows you to access certain
    files on a network share. Then, you can assign such roles to individual users
    in groups in the system to allow them to access these files. This can be done
    by associating the user with a role – in Kubernetes, you model this using the
    **RoleBinding** and **ClusterRoleBinding** objects. In this way, multiple users
    can be assigned a role, and a single user can have multiple roles assigned. Please
    note that in Kubernetes, RBAC is *permissive*, which means that there are no *deny*
    rules. Everything is denied by default, and you have to define *allow* rules instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute-Based Access Control (ABAC)**: This is part of the access control
    paradigm and is not only used in Kubernetes, which uses policies based on the
    attributes of the user, resource, and environment. This is a very fine-grained
    access control approach – you can, for example, define that the user can access
    a given file, but only if the user has clearance to access confidential data (user
    attribute), the owner of the file is Mike (resource attribute), and the user tries
    to access the file from an internal network (environment attribute). So, policies
    are sets of attributes that must be present together for the action to be performed.
    In Kubernetes, this is modeled using Policy objects. For example, you can define
    that the authenticated user, `mike`, can read any Pods in the `default` namespace.
    If you want to give the same access to user `bob`, then you need to create a new
    Policy for user `bob`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node**: This is a special-purpose authorization mode used for authorizing
    API requests made by `kubelet` in the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Webhook**: This mode is similar to webhooks for authentication. You can define
    an external service that needs to handle HTTP POST requests with a **SubjectAccessReview**
    object that’s sent by the Kubernetes API server. This service must process the
    request and determine if the request should be allowed or denied. The response
    from the service should contain `SubjectAccessReview`, along with information,
    on whether the subject is allowed access. Based on that, the Kubernetes API server
    will either proceed with the request or reject it with an HTTP status code of
    `403`. This approach is useful when you are integrating with existing access control
    solutions in the organization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AlwaysAllow**: This grants unrestricted access to all requests, and is only
    suitable for testing environments due to security concerns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AlwaysDeny**: This blocks all requests, and is useful solely for testing
    purposes to establish a baseline for authorization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently, RBAC is considered an industry standard in Kubernetes due to its
    flexibility and ease of management. For this reason, RBAC is the only authentication
    mode we are going to describe in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: RBAC mode in Kubernetes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using RBAC in Kubernetes involves the following types of API resources that
    belong to the `rbac.authorization.k8s.io` API group:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Role** and **ClusterRole**: They define a set of permissions. Each `rule`
    in Role says which verb(s) are allowed for which API resource(s). The only difference
    between Role and ClusterRole is that Role is namespace-scoped, whereas ClusterRole
    is global.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RoleBinding** and **ClusterRoleBinding**: They associate users or a set of
    users (alternatively, groups or ServiceAccounts) with a given Role. Similarly,
    RoleBinding is namespace-scoped, while ClusterRoleBinding is cluster-wide. Please
    note that ClusterRoleBinding works with ClusterRole, but RoleBinding works with
    both ClusterRole and Role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these Kubernetes objects can be managed using `kubectl` and YAML manifests,
    just as you do with Pods, Services, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now demonstrate this in practice. In the previous section, we showed
    a basic RBAC configuration for a service account that was being used for authentication
    using `kubectl`. The example that we are going to use here will be a bit different
    and will involve creating a Pod that runs under a *dedicated* service account
    and periodically queries the Kubernetes API server for a list of Pods. In general,
    having dedicated service accounts for running your Pods is a good practice and
    makes it possible to ensure the principle of least privilege. For example, if
    your Pod needs to get the list of Pods in the cluster but does not need to create
    a new Pod, the ServiceAccount for this Pod should have a role assigned that allows
    you to list Pods, nothing more. Follow these steps to configure this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating a dedicated namespace for the objects with the following
    YAML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create namespace by applying the YAML
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate, let us create a sample nginx Pod in the same namespace using
    the `02_rbac/nginx-pod.yaml` definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Please note, that the `nginx` Pod is not doing anything here; we need the Pod
    `pod-logger-app` to fetch the `nginx` Pod details in the `rbac-demo-ns` namespace
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a ServiceAccount named `pod-logger`. Create a YAML manifest named
    `pod-logger-serviceaccount.yaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the manifest to the cluster using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a role named `pod-reader`. This role will only allow the `get`, `watch`,
    and `list` verbs on `pods` resources in the Kubernetes RESTful API. In other words,
    this translates into an `/api/v1/namespaces/rbac-demo-ns/pods` endpoint in the
    API. Note that `apiGroups` specified as `""` mean the `core` API group. The structure
    of the `pod-reader-role.yaml` manifest file is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the manifest to the cluster using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we would normally create a RoleBinding object to associate the service
    account with the role. But to make this demonstration more interesting, we will
    create a Pod that’s running under the `pod-logger` service account. This will
    essentially make the Pod unable to query the API for Pods because it will be *unauthorized*
    (remember that everything is denied by default in RBAC). Create a YAML manifest
    named `pod-logger-app.yaml` for a Pod called `pod-logger-app`, running without
    any additional controllers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the most important fields are `.spec.serviceAccountName`, which specifies
    the service account that the Pod should run under, and the `command` in the container
    definition, which we have overridden to periodically query the Kubernetes API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us apply the `02_rbac/pod-logger-app.yaml` to create the Pod as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assigning the `pod-logger` service account, as explained in the previous section,
    will result in a Secret with a bearer JWT for this account to be mounted in the
    container filesystem under `/var/run/secrets/kubernetes.io/serviceaccount/token`.
    Let us verify this using `kubectl exec`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The overridden commands run an infinite loop in a Linux shell (e.g., bash) in
    10-second intervals. In each iteration, we query the Kubernetes API endpoint (`https://kubernetes/api/v1/namespaces/rbac-demo-ns/pods`)
    for Pods in the `rbac-demo-ns` namespace with the HTTP `GET` method using the
    `curl` command. To properly authenticate, we pass the contents of `/var/run/secrets/kubernetes.io/serviceaccount/token`
    as a **bearer** token in the `Authorization` header for the request. Additionally,
    we pass a CA certificate path to verify the remote server using the `cacert` argument.
    The certificate is injected into `/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`
    by the Kubernetes runtime. When you inspect its logs, you should expect to see
    a bunch of messages with an HTTP status code of `403 (Forbidden).` This is because
    the ServiceAccount does not have a RoleBinding type that associates it with the
    `pod-reader` Role yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start following the logs of the `pod-logger-app` Pod using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a new console window (or by ending the logs with the *Ctrl + F* command),
    we will create and apply a RoleBinding that *associates* the `pod-logger` ServiceAccount
    with the `pod-reader` Role. Create a YAML manifest named `read-pods-rolebinding.yaml`
    that contains the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are three key components in the RoleBinding manifest: `name`, which is
    used to identify the user; `subjects`, which reference the users, groups, or service
    accounts; and `roleRef`, which references the role.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the RoleBinding manifest file using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now check the `pod-logger-app` logs again; you will see that the Pod was able
    to successfully retrieve the list of Pods in the `rbac-demo-ns` namespace. In
    other words, the request was successfully authorized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, you can delete the RoleBinding type using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, if you inspect the logs of the `pod-logger-app` Pod again, you will see
    that the requests are denied with an HTTP status code of `403` again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! You have successfully used RBAC in Kubernetes to be able to
    read the Pods in the cluster for a Pod running under ServiceAccount. To clean
    up the Kubernetes environment, you can delete the `rbac-demo-ns` namespace so
    that the resources you created will be removed as part of the namespace removal.
  prefs: []
  type: TYPE_NORMAL
- en: As we have explored authentication and authorization, in the next section, let
    us learn about another security feature in Kubernetes called admission controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Admission Control – Security Policies and Checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a security checkpoint at a critical facility. Admission controllers
    in Kubernetes function similarly for your cluster. They act as gatekeepers, intercepting
    requests to the Kubernetes API server before resources are created, deleted, or
    modified. These controllers can validate or modify the requests based on predefined
    rules, ensuring that only authorized and properly configured resources enter the
    system. Also note that admission controllers do not (and cannot) block requests
    to read (get, watch, or list) objects.
  prefs: []
  type: TYPE_NORMAL
- en: Several key features of Kubernetes rely on specific admission controllers to
    function correctly. Therefore, a Kubernetes API server without the appropriate
    admission controllers is incomplete and will not support all expected features.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of admission controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Validation controllers**: These controllers meticulously examine incoming
    requests. If they find anything suspicious or non-compliant with set policies,
    they reject the request entirely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutation controllers**: These controllers have the power to modify requests
    before they are stored permanently. They can, for instance, add missing security
    annotations or adjust resource limits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s get introduced to the two-phase admission process.
  prefs: []
  type: TYPE_NORMAL
- en: The Two-Phase Admission Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Admission control in Kubernetes operates in a two-step process, ensuring only
    compliant resources enter your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The high-level flow taken by the mutation and validation phases of Kubernetes
    admission control is represented by the following figure. This flow takes incoming
    requests into Kubernetes to process in a manner that first does the appropriate
    mutations for modifying or enriching requests before doing any actual validation
    to see if the request meets all required security and policy validations that
    are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sequence is exposed to the flow, showing the way, Kubernetes enforces
    consistency, security, and policy compliance before allowing any changes to the
    cluster state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_18_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.7: Admission controllers in the API request processing flow (image
    source: https://kubernetes.io/blog/2019/03/21/a-guide-to-kubernetes-admission-controllers/)'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a breakdown of each phase.
  prefs: []
  type: TYPE_NORMAL
- en: Mutation Phase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Mutation phase is a step in admission control in Kubernetes, where controllers
    running in the role of mutation controllers will change the incoming API requests
    to make them compliant with cluster policies before further processing. Such controllers
    basically act like “molders,” which not only see to it that the requests are consistent
    with established settings but can also automatically add or adjust settings, for
    example, defaults or security labels. This makes the system maintain the policy
    compliance and alignment of configurations without manual input.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few examples presented here for this phase:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding missing security annotations to pods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting resource requests and limits for pods based on pre-defined rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting sidecar containers for specific functionalities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation Phase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is during the Validation phase, in this sequence, that Kubernetes admission
    control completes a controller’s doing in the preceding Mutation phase. Controllers
    then closely scrutinize incoming requests that might have been modified by some
    controller. Often referred to as the “guardians,” these controllers check requests
    for adherence to cluster policies and security standards. It is an important phase
    in the prevention of misconfiguration and unauthorized changes that maintain cluster
    integrity and security by rejecting requests not meeting set criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the example actions are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Approve the request if it adheres to set criteria (e.g., resource quotas, security
    standards).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reject the request if it violates any policies, providing informative error
    messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will learn how to turn off and turn on admission controllers
    in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling and disabling Admission controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To check which Admission controllers are enabled, you typically need to inspect
    the configuration of the **Kubernetes API server**. This is often done by accessing
    the configuration file where the API server is defined, usually located in the
    system’s configuration directories or managed through a configuration management
    tool. Look for the `--enable-admission-plugins` flag, which specifies the list
    of admission controllers currently active.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in a minikube environment, you can SSH into the minikube VM using
    the `minikube ssh` command. Once inside, you can locate and inspect the `kube-apiserver.yaml`
    file, typically found in `/etc/kubernetes/manifests/`. Use `sudo cat /etc/kubernetes/manifests/kube-apiserver.yaml`
    to view its contents and look for the `--enable-admission-plugins` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: To modify the list of enabled plugins, edit this file with a text editor like
    nano or vi, adjust the plugins as needed, and then save your changes. The kubelet
    watches the manifest files and will automatically restart the API server (recreate
    the Pod) if it detects any changes to the manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to turn off the default admissions controllers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the following section, we will learn the list of admission controllers available
    in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Common Admission Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Kubernetes, the admission controllers are built into the `kube-apiserver`
    and should only be configured by the cluster administrator. Among these controllers,
    two are particularly notable: **MutatingAdmissionWebhook** and **ValidatingAdmissionWebhook**.
    These controllers execute the respective mutating and validating admission control
    webhooks that are configured through the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Controls**: `AlwaysAdmit` (deprecated), `AlwaysDeny` (deprecated),
    `AlwaysPullImages`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defaults**: `DefaultStorageClass`, `DefaultTolerationSecond`s'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: `DenyEscalatingExec`, `DenyServiceExternalIPs`, `PodSecurityPolicy`,
    `SecurityContextDeny`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Management**: `LimitRanger`, `ResourceQuota`, `RuntimeClass`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object Lifecycle**: `NamespaceAutoProvision`, `NamespaceExists`, `NamespaceLifecycle`,
    P`ersistentVolumeClaimResize`, `StorageObjectInUseProtection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node Management**: `NodeRestriction`, `TaintNodesByCondition`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Webhooks**: `MutatingAdmissionWebhook`, `ValidatingAdmissionWebhook`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Others**: `EventRateLimit`, `LimitPodHardAntiAffinityTopology`, `OwnerReferencesPermissionEnforcement`,
    `PodNodeSelector` (deprecated), `Priority`, `ServiceAccount`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are numerous advantages to using admission controllers in a Kubernetes
    cluster. Let us learn about a few in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of Admission Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are multiple advantages of using admission controllers in your Kubernetes
    clusters, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enhanced Security**: By enforcing security policies like pod security standards,
    admission controllers help keep your cluster safe from unauthorized or vulnerable
    deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policy Enforcement**: You can define rules for resource usage, image pulling,
    and more, which admission controllers will automatically enforce.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency and Standardization**: Admission controllers ensure that resources
    across your cluster adhere to established best practices and configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, the admission controllers section has emphasized that admission
    controllers play a very important role in ensuring the security of Kubernetes,
    and this is through the Mutation and Validation phases. We learned how the mutation
    controllers run modifications on the requests to make sure they comply with cluster
    policies, while validation controllers ensure none other than those meeting the
    security standards are processed. In all, the foregoing processes improve the
    overall state of the security of the Kubernetes clusters by assuring compliance
    and prohibiting unauthorized changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, let us learn about how to secure workloads in Kubernetes
    using Security Context and NetworkPolicies.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Pods and Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing Pods and containers is essential to keeping your Kubernetes environment
    in a healthy state, since these directly interact with workloads and sensitive
    data. In the next sections, we are going to talk about how the securityContext
    settings and NetworkPolicies can enforce strict access controls and isolation
    in place to strengthen the security of Pods and containers in your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Pods and Containers in Kubernetes Using Security Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Kubernetes, a **securityContext** defines a set of security settings that
    determine how a Pod or container operates within the cluster. This allows you
    to enforce security best practices and minimize the attack surface by restricting
    privileges and controlling access.
  prefs: []
  type: TYPE_NORMAL
- en: The primary purpose of securityContext is to enhance the security of your Kubernetes
    clusters by defining how a pod or container should run within the cluster. By
    specifying security settings, you can ensure that your applications adhere to
    the principle of least privilege, reducing the potential for malicious activities
    and accidental misconfigurations.
  prefs: []
  type: TYPE_NORMAL
- en: A typical use case for securityContext is to run containers as non-root users.
    This prevents containers from having unnecessary permissions, thereby limiting
    the potential damage if a container is compromised. Additionally, you can configure
    other security settings such as read-only filesystems and fine-grained capabilities
    to further strengthen your cluster’s security posture.
  prefs: []
  type: TYPE_NORMAL
- en: Key Components of SecurityContext
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s a breakdown of the key components of a securityContext along with illustrative
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: User and Group
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This security context specifies the user and group ID, under which processes
    inside the container will run. By enforcing the principle of least privilege,
    it grants containers only the minimum permissions necessary to function. The following
    code snippet shows a typical example of a Pod definition with the securityContext
    configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Linux Capabilities
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Capabilities are special privileges that can be granted to containers beyond
    the limitations of a user. securityContext allows you to define which capabilities
    a container should have, enabling specific functionalities without providing full
    root access, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the Linux capabilities documentation to learn more ([https://linux-audit.com/kernel/capabilities/linux-capabilities-hardening-linux-binaries-by-removing-setuid/](https://linux-audit.com/kernel/capabilities/linux-capabilities-hardening-linux-binaries-by-removing-setuid/)).
  prefs: []
  type: TYPE_NORMAL
- en: Privileged Mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Read-Only Root Filesystem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This securityContext allows you to configure the container to have a read-only
    root filesystem. This enhances security by preventing accidental or malicious
    modifications to the base system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: There are a few more SecurityContext settings such as **Security Enhanced Linux**
    (**SELinux**), **AppArmor** ([https://kubernetes.io/docs/tutorials/security/apparmor/](https://kubernetes.io/docs/tutorials/security/apparmor/)),
    **Seccomp**, and so on. Refer to [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to know where is the best place in the configuration you can apply
    SecurityContext; let us learn that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Applying SecurityContext at Pod and Container Levels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Kubernetes, the securityContext can be applied at both the pod level and
    the container level, offering flexibility in defining security settings for your
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Pod-Level SecurityContext
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When applied at the pod level, the securityContext settings are inherited by
    all containers within the pod. This is useful for setting default security configurations
    that should apply uniformly across all containers in the pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Container-Level SecurityContext
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When applied at the container level, the securityContext settings only affect
    the specific container. This allows for more granular control, where different
    containers within the same pod can have different security configurations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In the following section, let us demonstrate the Security Context with an example
    Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Security Context to a Pod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following example creates a Pod with a container that runs with a `read-only`
    root filesystem and specifies non-root user and group IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding YAML, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`runAsUser`and `runAsGroup`: These settings ensure that the container runs
    with a specific non-root user ID and group ID, following the principle of least
    privilege.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readOnlyRootFilesystem`: This setting mounts the container’s root filesystem
    as read-only, preventing any accidental or malicious modifications to the base
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create the Pod using the YAML as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the Pod is created, let us test a few commands inside the container to
    verify the securityContext we applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: You can see the Read-only filesystem error; this is expected.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
    to learn more about the security context in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: The next section introduces the control of network flow in Kubernetes using
    the **NetworkPolicy** object. You will see that you can build a kind of network
    firewall directly in Kubernetes so that you can prevent Pods from being able to
    reach one another.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Pods using the NetworkPolicy object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **NetworkPolicy** object is the last resource kind we need to discover as
    part of this chapter to have an overview of services in this chapter. NetworkPolicy
    will allow you to define network firewalls directly implemented in your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Why do you need NetworkPolicy?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have to manage a real Kubernetes workload in production, you’ll have
    to deploy more and more applications onto it, and it is possible that these applications
    will have to communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Achieving communication between applications is really one of the fundamental
    objectives of a microservice architecture. Most of this communication will be
    done through the network, and the network is forcibly something that you want
    to secure by using firewalls.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes has its own implementation of network firewalls called NetworkPolicy.
    Say that you want one nginx resource to be accessible on port `80` from a particular
    IP address and to block any other traffic that doesn’t match these requirements.
    To do that, you’ll need to use NetworkPolicy and attach it to that Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'NetworkPolicy brings three benefits, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can build egress/ingress rules based on **Classless Inter-Domain Routing**
    (**CIDR**) blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can build egress/ingress rules based on Pods labels and selectors (just
    as we’ve seen before with services’ and Pods’ association).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can build egress/ingress rules based on namespaces (a notion we will discover
    in the next chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, keep in mind that for NetworkPolicy to work, you’ll need to have a
    Kubernetes cluster with a CNI plugin installed. CNI plugins are generally not
    installed by default on Kubernetes. If you’re using minikube for learning purposes,
    the good news is that it has an integration with Calico, which is a CNI plugin
    with NetworkPolicy support implemented out of the box. You just need to recreate
    the `minikube` cluster this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If you’re using Kubernetes on top of a cloud platform, we suggest you read the
    documentation of your cloud provider in order to verify which CNI options your
    cloud platform offers and whether it implements NetworkPolicy support.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Pods are not isolated by default
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, in Kubernetes, Pods are not isolated and any Pod can be reached
    by any other Pod without any constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t use NetworkPolicy, Pods will remain just like that: accessible
    by everything without any constraint. Once you attach the NetworkPolicy to a Pod,
    the rules described on the NetworkPolicy will be applied to the Pod.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To establish communication between two Pods associated with network policies,
    both sides must be open. It means Pod *A* must have an egress rule to Pod *B*,
    and Pod *B* must have an ingress rule from Pod *A*; otherwise, the traffic will
    be denied. The following figure illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – One of the Pods is broken but the service will still forward
    traffic to it'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B22019_18_08.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.8: One of the Pods is broken but the service will still forward traffic
    to it'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you’ll have to troubleshoot NetworkPolicy because it can be
    the root cause of a lot of issues. Let’s now configure a NetworkPolicy between
    two Pods by using labels and selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring NetworkPolicy with labels and selectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, let’s create two nginx Pods to demonstrate our example. To demonstrate
    the isolation, we will use two separate namespaces in this example. You will learn
    more about Kubernetes namespace a in *Chapter 6*, *Namespaces, Quotas, and Limits
    for Multi-Tenancy in Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing complete communication isolation within a namespace can be complex
    and have unintended consequences. Carefully evaluate your needs and potential
    impacts before applying any restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the namespaces and two Pods with two distinct labels so that they
    become easier to target with the NetworkPolicy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `web1` namespace with `nginx1` pod will be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the `web2` namespace with a `nginx2` pod will be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippets, we used namespaces (`web1` and `web2`) instead
    of deploying to the `default` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the resources and verify the Pods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the two Pods are created with distinct labels inside different namespaces,
    we use the `-o wide` flag to get the IP address of both Pods. Run a `curl` command
    from the `nginx1` Pod to reach the `nginx2` Pod, to confirm that by default, network
    traffic is allowed because no NetworkPolicy is created at this point. The code
    is illustrated here; `10.244.120.72` is the IP address of the `nginx2` Pod in
    the `web2` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we correctly received the nginx home page from the `nginx2`
    Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s block all the ingress traffic to the `web2` namespace explicitly.
    To do that, we can create a default policy as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding YAML snippet, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`podSelector: {}`: Selects pods to which the NetworkPolicy applies. In this
    case, {} selects all pods in the namespace. This means that the rules defined
    in the NetworkPolicy *will apply to all pods in the namespace*, regardless of
    their labels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`policyTypes: - Ingress`: Specifies the type of policy being applied, which
    is “Ingress” in this case. This means that the NetworkPolicy will control incoming
    (ingress) traffic to the selected pods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ingress: []`: Defines the list of ingress rules for the NetworkPolicy. In
    this case, the list is empty (`[]`), indicating that there are no specific ingress
    rules defined. Therefore, all incoming traffic to the selected pods will be denied
    by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s apply this deny policy to our `web2` namespace to block all incoming
    (ingress) traffic as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We will try to access the `nginx2` pod from `nginx1` pod now and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: It is clear from the previous output that the traffic to `web2` namespace and
    Pods are denied with the `default-deny-ingress` NetworkPolicy resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add NetworkPolicy to `nginx2` in the `web2` namespace to explicitly
    allow traffic coming from the Pod `nginx1` in the `web1` namespace. Here is how
    to proceed with the YAML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note the `namespaceSelector.matchLabels` here with the `project: web1`
    label, which we used for `web1` namespace explicitly for this purpose. Let’s apply
    this NetworkPolicy, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s run the same `curl` command we did before, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it works just like it did before. Why? For the following two
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nginx2` now explicitly allows ingress traffic on port `80` from `nginx1` in
    the `web1` namepsace; everything else is denied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nginx1` has no NetworkPolicy, and thus, egress traffic to everything is allowed
    for it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that if no NetworkPolicy is set on the Pod, the default behaviour
    applies—everything is allowed for the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: We strongly encourage you to make a habit of using NetworkPolicy along with
    your Pod. Lastly, please be aware that NetworkPolicy can also be used to build
    firewalls based on CIDR blocks. It might be useful, especially if your Pods are
    called from outside the cluster. Otherwise, when you need to configure firewalls
    between Pods, it is recommended to proceed with labels and selectors as you already
    did with the services’ configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will focus on yet another important aspect of securing Kubernetes,
    namely Securing Communication via TLS Certificates between Kubernetes components.
    In this section, we will talk about how the TLS certificate helps in securing
    the data in transit and ensures secure interactions among various components that
    make up the ecosystem of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Communication – TLS Certificates Between Kubernetes Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Kubernetes, secure communication between various components is critical.
    **Transport Layer Security** (**TLS**), and **Secure Sockets Layer** (**SSL**),
    play a crucial role in encrypting data transmissions and establishing trust between
    services.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing **TLS with mutual authentication** (**mTLS**), both the client
    and server involved in communication can verify each other’s identities using
    digital certificates issued by a trusted CA. This adds a layer of security by
    preventing unauthorized access and ensuring data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of how TLS certificates are used in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API Server to etcd**: The API server, the central control plane component,
    communicates with etcd, the distributed key-value store, to manage cluster state.
    Utilizing mTLS between these components safeguards sensitive cluster data from
    interception or tampering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ingress Controller to Services**: The ingress controller, acting as a single
    entry point for external traffic, routes requests to backend services. Implementing
    mTLS between the ingress controller and services ensures that only authorized
    services receive traffic, mitigating potential security breaches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal Service Communication**: Services within the cluster can also leverage
    mTLS for secure communication. This is particularly important for services that
    handle sensitive data or require strong authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Meshes – for instance, Istio:** These types of service mesh have
    a variety of advanced traffic management and security capabilities, such as automatic
    mTLS between microservices. This makes the process of securing service-to-service
    communication easier without having to embed these communications with TLS configuration
    in the code that developers manage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load Balancers:** Applications deployed behind a load balancer can also be
    used to secure communication between the load balancer and backend services with
    the use of TLS. In a configuration like this, the data will remain encrypted along
    the entire path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another security mechanism would be enabling IPSec within a Kubernetes cluster
    to encrypt network traffic between nodes. This may be useful in the protection
    of the traffic in cloud environments or between various data centers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through the deployment of TLS certificates with mTLS, Kubernetes administrators
    significantly bolster the security of their clusters. This approach encrypts communication
    paths, verifies the identities of communicating components, and mitigates risks
    associated with unauthorized data access or tampering.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to enable container security using special
    containers such as gVisor and Kata Containers.
  prefs: []
  type: TYPE_NORMAL
- en: Container Security – gVisor and Kata Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditional containers share the host operating system kernel with other applications
    running on the machine, which can pose security risks if a container vulnerability
    allows access to the underlying system. **gVisor** and **Kata Containers** emerge
    as alternative container runtime technologies that prioritize security. Let us
    learn about them in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: gVisor (Guest Virtual Machine Supervisor)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: gVisor is a lightweight virtual machine implemented in user space. It acts as
    a sandbox for each container, isolating it from the host kernel and other containers.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows the high-level architecture of gVisor.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_18_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.9: gVisor architecture'
  prefs: []
  type: TYPE_NORMAL
- en: By virtualizing kernel functionalities for each container, gVisor ensures that
    container vulnerabilities cannot directly compromise the host system. It establishes
    a robust isolation boundary, even in compromised container scenarios. gVisor is
    best suited for environments requiring the highest level of security isolation,
    despite potentially higher resource overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Kata Containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kata Containers utilize lightweight VMs that are similar to traditional VMs
    but optimized for container workloads. Kata Containers offers a secure execution
    environment by isolating containers within lightweight VMs. This enhanced isolation
    strengthens security compared to standard containers while maintaining performance
    efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure demonstrates how Kata Containers are different from traditional
    container technologies.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_18_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.10: Kata Containers versus traditional containers (source: https://katacontainers.io/learn/)'
  prefs: []
  type: TYPE_NORMAL
- en: Kata Containers are recommended when balancing strong security with optimal
    performance, particularly for resource-intensive workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Using RuntimeClass for Security Profiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Kubernetes, utilize the `runtimeClassName` field in your pod spec to specify
    the container runtime environment. Here is an example configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This setup directs Kubernetes to use the Kata Containers runtime for enhanced
    security isolation.
  prefs: []
  type: TYPE_NORMAL
- en: We learned several important things about Kubernetes security in this chapter.
    Before we conclude the chapter, let us learn about another security topic in the
    next section, which is about accessing private registries and container images.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Secrets and Registry Credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kubernetes, registry credentials are necessary for securely pulling container
    images from private registries that require authentication. Without these credentials,
    Kubernetes pods cannot access images stored in private repositories. Managing
    these credentials securely is crucial to ensure that only authorized pods can
    retrieve and use specific container images.
  prefs: []
  type: TYPE_NORMAL
- en: Using `kubectl create secret docker-registry` simplifies the management of container
    registry credentials in Kubernetes. It ensures security by encrypting secrets
    at rest, making them accessible only to authorized nodes. This approach reduces
    complexity compared to manual methods, minimizing errors and improving operational
    efficiency. Moreover, it seamlessly integrates with Kubernetes pod specifications,
    allowing straightforward configuration of `imagePullSecrets` to authenticate pod
    access to private container registries.
  prefs: []
  type: TYPE_NORMAL
- en: Using kubectl to create a Docker registry secret
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate, here’s how you can create a Docker registry secret and integrate
    it into a Kubernetes pod configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Replace `your-registry.com`, `your_username`, `your_password`, and `your-email@example.com`
    with your actual registry details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your Pod YAML to use the newly created secret for pulling images from
    the private registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Ensure `my-registry-secret` matches the name used when creating the Docker registry
    secret.
  prefs: []
  type: TYPE_NORMAL
- en: When Kubernetes creates the Pod, the image will be pulled from the private registry
    using the imagePullSecrets as the authentication credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have reached the end of this long chapter about Kubernetes
    security.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered *authentication* and *authorization* in Kubernetes. First,
    we provided an overview of the available authentication methods in Kubernetes
    and explained how you can use ServiceAccount tokens for external user authentication.
    Next, we focused on RBAC in Kubernetes. You learned how to use Roles, ClusterRoles,
    RoleBindings, and ClusterRoleBindings to manage authorization in your cluster.
    We demonstrated a practical use case of RBAC for ServiceAccounts by creating a
    Pod that can list Pods in the cluster using the Kubernetes API (respecting the
    principle of least privilege).
  prefs: []
  type: TYPE_NORMAL
- en: After that, we learned about Admission Controllers in Kubernetes and what controllers
    are available to secure your Kubernetes cluster. We also learned about SecurityContext
    and different samples for securityContext configurations. We also discovered how
    to control traffic flow between Pods by using an object called NetworkPolicy that
    behaves like a networking firewall within the cluster. As part of the container
    security, we explored the alternative container runtimes such as Kata Containers
    and gVisor options. Finally, we learned how to configure the credentials for the
    private container registries. In the next chapter, we are going to dive deep into
    advanced techniques for scheduling Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Controlling Access to the Kubernetes API**: [https://kubernetes.io/docs/concepts/security/controlling-access](https://kubernetes.io/docs/concepts/security/controlling-access)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managing Service Accounts**: [https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/](https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configure Service Accounts for Pods**: [https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certificates and Certificate Signing Requests**: [https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/](https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: [https://kubernetes.io/docs/reference/access-authn-authz/authorization/](https://kubernetes.io/docs/reference/access-authn-authz/authorization/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What is OpenID Connect**: [https://openid.net/developers/how-connect-works/](https://openid.net/developers/how-connect-works/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Admission controller**: [https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security Context**: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context](https://kubernetes.io/docs/tasks/configure-pod-container/security-context)/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code119001106479081656.png)'
  prefs: []
  type: TYPE_IMG
