<html><head></head><body>
		<div id="_idContainer075">
			<h1 id="_idParaDest-145" class="chapter-number"><a id="_idTextAnchor144"/>7</h1>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor145"/>GitOps with Flux for Edge Applications</h1>
			<p>Previous chapters have already covered the basics of building your home lab using K3s. It’s time to implement simple use cases that you can use in edge computing. This chapter covers how to implement GitOps for your applications using Flux in edge computing environments, starting with the basic theory of GitOps and the necessary tools to manage a Git repository for deployments. Then, we will look at how to install Flux to implement a basic GitOps workflow for a demo application. This chapter includes how to automate <a id="_idIndexMarker476"/>an application deployment using a <strong class="bold">mono repository</strong> (<strong class="bold">monorepo</strong>) configuration, the Helm operator, and the image updater feature of Flux. Finally, we will end the chapter with the installation of basic monitoring dashboards in Flux, essential troubleshooting commands for Flux, and how to uninstall Flux.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Implementing GitOps for edge computing</li>
				<li>Flux and its architecture</li>
				<li>Designing GitOps with Flux for edge applications</li>
				<li>Building your container image with GitHub Actions</li>
				<li>Installing and configuring Flux for GitOps</li>
				<li>Troubleshooting Flux installations </li>
				<li>Installing Flux monitoring dashboards</li>
				<li>Uninstalling Flux</li>
			</ul>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor146"/>Technical requirements</h1>
			<p>In this chapter, to implement GitOps using Flux, you will need the following:</p>
			<ul>
				<li>Three single node K3s clusters using a device with an <strong class="bold">ARM</strong> processor such as a Raspberry Pi.</li>
				<li>Previous experience with Git.</li>
				<li>GitHub repository and its token; you also need some basic experience using Git.</li>
				<li>Docker Hub account to push new image releases of your application.</li>
			</ul>
			<p>With this, you are ready for this first use case to implement GitOps at the edge using Flux. So, let’s get started.</p>
			<p>For more detail and code snippets, check out this resource on GitHub: <a href="https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch7">https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch7</a></p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/>Implementing GitOps for edge computing</h1>
			<p>To start <a id="_idIndexMarker477"/>this topic, let’s get started with the <a id="_idIndexMarker478"/>concept of GitOps. The <a href="https://www.gitops.tech/">https://www.gitops.tech/</a> website states: “<em class="italic">GitOps is a way of implementing Continuous Deployment for cloud native applications. It focuses on a developer-centric experience when operating infrastructure, by using tools developers are already familiar with, including Git and Continuous Deployment tools</em>.” This <a id="_idIndexMarker479"/>means that GitOps helps you with your <strong class="bold">continuous deployment</strong> (<strong class="bold">CD</strong>) in general. In software engineering, it is common to refer to continuous <a id="_idIndexMarker480"/>deployment and continuous delivery with the CD acronym.</p>
			<p>Also, the GitLab page <a href="https://about.gitlab.com/topics/gitops">https://about.gitlab.com/topics/gitops</a> mentions that GitOps contains the following basic components:</p>
			<ul>
				<li><strong class="bold">Infrastructure as code</strong> (<strong class="bold">IaC</strong>): This refers to a declarative way to provide infrastructure <a id="_idIndexMarker481"/>or deployments for your applications.</li>
				<li><strong class="bold">Merge requests or pull requests</strong> (<strong class="bold">PRs</strong>): A <a id="_idIndexMarker482"/>way to <a id="_idIndexMarker483"/>manage infrastructure or application code updates across multiple changes and collaborators. </li>
				<li><strong class="bold">Source code management</strong> (<strong class="bold">SCM</strong>): Systems such as Git enable merge request- <a id="_idIndexMarker484"/>or pull request-based workflows and a mechanism to manage this, usually using a Git repository. In this way, a team can have an approval-and-review mechanism to apply changes.</li>
				<li><strong class="bold">Continuous integration and continuous delivery</strong> (<strong class="bold">CI/CD</strong>): CI and CD include, by nature, all the processes of building, checking, and deploying applications <a id="_idIndexMarker485"/>and changes to those software applications. GitOps is used to automate CD for a cloud native application.</li>
			</ul>
			<p>In this <a id="_idIndexMarker486"/>chapter, you will find tools that provide mechanisms for CI/CD automation pipelines. Let’s pay attention to the following diagram <a id="_idIndexMarker487"/>that shows a summary of how GitOps works:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B16945_07_01.jpg" alt="Figure 7.1 – GitOps&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – GitOps</p>
			<p>The basics of starting with GitOps are outlined here, as depicted in <em class="italic">Figure 7.1</em>: </p>
			<ol>
				<li value="1"><strong class="bold">Commit code to the source</strong>: Here, a <a id="_idIndexMarker488"/>developer makes changes and pushes their changes to a source or repository—for example, a Git repository hosted at GitHub.</li>
				<li><strong class="bold">Synchronize changes</strong>: A GitOps tool such as, for example, Flux periodically detects changes in the source.</li>
				<li><strong class="bold">Provision or reconcile changes</strong>: Once the GitOps tool detects changes, it aims to automate the process of updating a deployment based on the declarative configuration changes found. This could include processes to modify, such as changing <a id="_idIndexMarker489"/>configurations, updating the container image for an application using containers, and so on. Sometimes, if a resource or deployment doesn’t exist, you have to provision resources or reconcile these, comparing changes. This means that a GitOps tool regularly works with declarative definitions to reflect the state of your infrastructure or application.</li>
			</ol>
			<p>Finally, the user will see changes when accessing their application, and you can also add some additional processes such as notifications if a process was finalized, or an alert if something fails.</p>
			<p>In general, this is how a GitOps process works and how a GitOps tool operates. In this chapter, we are going to focus on Flux as our GitOps tool, to implement GitOps processes to automate our applications’ deployments and updates.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor148"/>GitOps principles</h2>
			<p>There are <a id="_idIndexMarker490"/>some principles that you have to follow if you are using GitOps to automate your CD pipelines. Based on <em class="italic">Weaveworks</em>, these principles are as follows:</p>
			<ul>
				<li><strong class="bold">Declarative definitions</strong>: You can often <a id="_idIndexMarker491"/>find these definitions using <strong class="bold">YAML</strong> files, but they <a id="_idIndexMarker492"/>could also be found in other formats such as <strong class="bold">JSON</strong>.</li>
				<li><strong class="bold">State of your applications versioned with Git</strong>: GitOps tools use Git repositories to store changes and states for applications.</li>
				<li><strong class="bold">Approve changes that can be applied automatically to your resources</strong>: Git repositories or services provide ways to automate a trigger tool when some changes or merges are detected.</li>
				<li><strong class="bold">Software agents listening to changes notifying or alerting</strong>: GitOps tools also have daemons listening to changes in a ready-to-launch action, such as changing <a id="_idIndexMarker493"/>a repository with a new image tag in the case of applications using containers.</li>
			</ul>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>GitOps benefits</h2>
			<p>Now you know how a GitOps tool works and how GitOps processes help you to automate <a id="_idIndexMarker494"/>your CD pipeline, it’s time to find out about the benefits of GitOps.</p>
			<p>Based on <em class="italic">Weaveworks</em>, these are as follows:</p>
			<ul>
				<li><strong class="bold">Increased productivity</strong>: An automated process reduces the execution time; in this case, more changes and updates made for your applications in less time.</li>
				<li><strong class="bold">Enhanced developer experience</strong>: GitOps tools usually launch automated processes on your Git repository, and these will be launched automatically without knowing the internals of how it works—for example, for applications using Kubernetes, a developer doesn’t have to know Kubernetes in some cases. However, this depends on how your application is structured.</li>
				<li><strong class="bold">Improved stability</strong>: Logs of GitOps tools are included by default, which helps to meet some security and monitoring features.</li>
				<li><strong class="bold">Higher reliability</strong>: GitOps tools give you the ability to implement rollback mechanisms, reducing downtime for your applications if a change has an impact on the operation of your system.</li>
				<li><strong class="bold">Consistency and standardization</strong>: GitOps tools have structures to define your applications, and give you best practices for your applications’ definitions, pipelines, or updates.</li>
				<li><strong class="bold">Stronger security guarantees</strong>: GitOps tools have security features such as cryptography for secrets, and tracking and managing changes. This brings a way to secure your applications.</li>
			</ul>
			<p>Now, let’s move on to understand how GitOps works in a cloud native context.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>GitOps, cloud native, and edge computing</h2>
			<p>As we know, <strong class="bold">cloud native</strong> refers to <a id="_idIndexMarker495"/>the use of applications using technologies such <a id="_idIndexMarker496"/>as containers, microservices, and CI/CD in the context of a <strong class="bold">development-operations</strong> (<strong class="bold">DevOps</strong>) culture. So, you <a id="_idIndexMarker497"/>can find an intersection for this concept when a GitOps tool is designed to run on cloud native environments—for example, Kubernetes clusters.</p>
			<p>A GitOps tool can help you to automate the CD process for your Kubernetes applications. Tools such as Argo CD or Flux can help you to implement GitOps for your applications. </p>
			<p>But in this chapter, we are going to focus more on applications that run in low-resource environments using ARM processors. In this case, Flux has support for ARM while Argo CD doesn’t. This chapter focuses on implementing GitOps with Flux using ARM devices. So, let’s get started with a brief introduction to Flux in the next section.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Flux and its architecture</h1>
			<p>The Flux <a id="_idIndexMarker498"/>website, <a href="https://fluxcd.io">https://fluxcd.io</a>, says: “<em class="italic">Flux is a set of continuous and progressive delivery solutions for Kubernetes that are open and extensible</em>.” Flux gives you <a id="_idIndexMarker499"/>the ability to have your Kubernetes clusters in sync with the <a id="_idIndexMarker500"/>source that contains declarative definitions of your applications, commonly stored in Git repositories. </p>
			<p>Flux also uses the Kubernetes API to manage its objects. It also uses its own GitOps Toolkit, which gives you the tools to build a CD system on top of Kubernetes. You can see how Flux works in the following diagram:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B16945_07_02.jpg" alt="Figure 7.2 – Flux architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Flux architecture</p>
			<p>This diagram reflects a typical workflow for GitOps, starting with a commit and a GitOps tool that is <a id="_idIndexMarker501"/>constantly checking for changes in the application’s definitions—in this case, YAML files. When Flux detects this change, it automatically provisions for the reconciliation of your applications, based on declarative definitions.</p>
			<p>To bring <a id="_idIndexMarker502"/>essential functionalities to GitOps, Flux provides the following main features:</p>
			<ul>
				<li>Support for Git repositories of multiple providers</li>
				<li>Supported integrations for tools such as Kustomize and Helm</li>
				<li>Event-triggered and periodic reconciliation</li>
				<li>Integration <a id="_idIndexMarker503"/>with Kubernetes <strong class="bold">role-based access control</strong> (<strong class="bold">RBAC</strong>)</li>
				<li>Alerting external systems (webhook senders)</li>
				<li>External events handling (webhook receivers)</li>
				<li>Automated container image updates to Git (image scanning and patching)</li>
			</ul>
			<p>As a GitOps tool for Kubernetes, Flux could be installed on ARM devices. In this way, Flux could be a good match for edge computing. But first, let’s look at how Flux matches edge computing requirements.</p>
			<p>Flux matches edge computing requirements for the following reasons:</p>
			<ul>
				<li>Has less complexity for GitOps compared with tools such as Argo CD, Tekton, and others</li>
				<li>Can be installed on ARM devices for low-resource environments</li>
				<li>Requires low resource consumption to operate</li>
			</ul>
			<p>This is how <a id="_idIndexMarker504"/>Flux works and how it matches edge computing requirements. Now, let’s see how we are going to organize our applications to implement GitOps for the edge using Flux in the next section.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Designing GitOps with Flux for edge applications </h1>
			<p>We are <a id="_idIndexMarker505"/>going to implement GitOps for <a id="_idIndexMarker506"/>edge computing with Flux, but first, we have to explain the whole workflow and the main parts of this implementation. For this, let’s explore the following diagram, which explains the components and workflow of GitOps, implementing an image automation updater for your applications:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B16945_07_03.jpg" alt="Figure 7.3 – Flux GitOps implementation using image updater feature"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Flux GitOps implementation using image updater feature</p>
			<p>Our GitOps <a id="_idIndexMarker507"/>workflow implementation <a id="_idIndexMarker508"/>has the following steps:</p>
			<ol>
				<li value="1">A developer changes the application and submits changes with a PR to be merged into the main branch. You could make changes and push them directly to the main branch, but this is not a good practice since you may have submitted broken or unreviewed changes. In later examples of this chapter, we use GitHub to host our Git repository.</li>
				<li>The repository has activated GitHub Actions and triggered a small pipeline just to build an image.</li>
				<li>An image is built in the pipeline and tagged with a new version, then it is pushed to the public Docker registry. In most business scenarios, you have to use private repositories in the cloud or on-premises.</li>
				<li>The image updater feature checks for new changes and tags for previous newly generated images that your application is going to use.</li>
				<li>Once Flux <a id="_idIndexMarker509"/>detects the new image, it looks for files configured to be updated with the new image tag. Once Flux <a id="_idIndexMarker510"/>updates the files’ definitions with the new tag, the changes are pushed to the repository.</li>
				<li>Flux detects changes in the definition of files that were updated with the new image tag. Then, Flux triggers a reconciliation process to update your applications.</li>
				<li>Objects in the Kubernetes cluster associated with the definition files are updated. Then, your application will run with the new image.</li>
			</ol>
			<p>To implement the GitOps workflow just described, we are assuming the next networking and GitHub configurations:</p>
			<ul>
				<li>Single node K3s clusters using the <strong class="source-inline">192.168.0.0/24</strong> network so that they can access the same network. You can use a different private network such as the <strong class="source-inline">172.16.0.0/16</strong> or <strong class="source-inline">10.0.0.0/8</strong> networks, for example.</li>
				<li>Each cluster is using MetalLB as the bare metal load balancer service, using different IP ranges for load balancing. Cluster 1 is using IP addresses in the range of <strong class="source-inline">192.168.0.51-60</strong>, cluster 2 is using <strong class="source-inline">192.168.0.61-70</strong>, and cluster 3 is using <strong class="source-inline">192.168.0.71-80</strong> to do some basic IP address distribution for this network. The first addresses are typically used by the default load balancer of Traefik, so this IP address could be different in your network. Take a look at <a href="B16945_05_Final_PG.xhtml#_idTextAnchor097"><em class="italic">Chapter 5</em></a>, <em class="italic">K3s Homelab for Edge Computing Experiments</em>, to configure MetalLB using the same or similar IP ranges.</li>
				<li>You have <a id="_idIndexMarker511"/>a GitHub account <a id="_idIndexMarker512"/>and a token to access or create repositories in your account. Here’s what we’re doing:<ul><li>We are using the https://github.com/sergioarmgpl/fluxappdemo GitHub repository, which contains a basic Helm chart to deploy in our clusters. You can find more details about the application in the repository link.</li></ul></li>
			</ul>
			<p>With this, we are ready to start implementing this scenario in the next section.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>Creating a simple monorepo for GitOps</h2>
			<p>For our GitOps implementation, we are going to use a monorepo. We have chosen to do this to <a id="_idIndexMarker513"/>reduce the management of many repositories and centralize all work in a single repository. For this use case, we are going to organize our cluster configurations and applications’ definitions in a single repository. Let’s explore the following screenshot to understand how our new repository will be organized:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B16945_07_04.jpg" alt="Figure 7.4 – Monorepo structure&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Monorepo structure</p>
			<p>Now let’s <a id="_idIndexMarker514"/>describe what each directory and file does, as follows:</p>
			<ul>
				<li><strong class="source-inline">clusters</strong>: This is the main directory that contains all the configuration of Flux and deployments in separated directories.</li>
				<li><strong class="source-inline">cluster1</strong>-<strong class="source-inline">cluster3</strong>: Inside these folders, the definitions of Flux and your applications are organized. <strong class="source-inline">cluster1</strong> will be the cluster in charge of updating YAML definitions for the application for all clusters. So, <strong class="source-inline">cluster2</strong> and <strong class="source-inline">cluster3</strong> don’t need the image updater components in their installations.</li>
				<li><strong class="source-inline">flux-system</strong>: Contains Flux definitions to deploy it. Includes the <strong class="source-inline">gotk-components.yaml</strong>, <strong class="source-inline">gotk-sync.yaml</strong>, and <strong class="source-inline">kustomization.yaml</strong> files, which configure different components to implement our image updater GitOps workflow.</li>
				<li><strong class="source-inline">manifests</strong>: Contains the necessary definitions to deploy your application. </li>
				<li><strong class="source-inline">namespace.yaml</strong>: Creates a production namespace for your application.</li>
				<li><strong class="source-inline">helm-charts.yaml</strong>: A definition to access your Helm chart.</li>
				<li><strong class="source-inline">helm-release.yaml</strong>: Includes a definition and values to deploy your application <a id="_idIndexMarker515"/>using the Helm chart defined in <strong class="source-inline">helm-charts.yaml</strong>.</li>
				<li><strong class="source-inline">app-demo-registry.yaml</strong>: Contains an image to scan on Docker Hub.</li>
				<li><strong class="source-inline">app-demo-policy.yaml</strong>: Contains an expression to check inside files where you want to update the container image. </li>
				<li><strong class="source-inline">flux-system-automation.yaml</strong>: Looks for a folder to update changes.</li>
			</ul>
			<p>This repository is designed for your applications. It is a monorepo for a production environment with different clusters. You can do more complex configurations using Kustomize, but that is out of the scope of this chapter.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You can also find some approaches to how to organize your repositories on the Flux website. For more information, check out the following link: <a href="https://fluxcd.io/docs/guides/repository-structure">https://fluxcd.io/docs/guides/repository-structure</a>.</p>
			<p>Now, it’s time to see the workflow that we are going to implement in our GitOps use case for edge computing.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>Understanding the application and GitHub Actions</h2>
			<p>To start implementing GitOps with Flux, we have to set a small pipeline that creates a container <a id="_idIndexMarker516"/>image every time we modify the source code of our application. To simplify our work, this configuration will be based on the <a href="https://github.com/sergioarmgpl/fluxappdemo">https://github.com/sergioarmgpl/fluxappdemo</a> repository, which contains a simple Python application using Flask. This application has two directories: <strong class="source-inline">src</strong> and <strong class="source-inline">.github/workflows</strong>. The <strong class="source-inline">src</strong> directory contains the source of the application, while the <strong class="source-inline">workflows</strong> folder has <a id="_idIndexMarker517"/>the GitHub Actions configuration. </p>
			<p>So, let’s first explore the <strong class="source-inline">src</strong> directory. You can see an overview of the repository in the following screenshot:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B16945_07_05.jpg" alt="Figure 7.5 – fluxappdemo repository&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – fluxappdemo repository</p>
			<p>The <strong class="source-inline">src</strong> directory contains the following files:</p>
			<ul>
				<li><strong class="source-inline">Dockerfile</strong>: This has the configuration to build a Docker image; it also calls a small unit test included in <strong class="source-inline">tests.py</strong>.</li>
				<li><strong class="source-inline">Operations.py</strong>: This has a class called <strong class="source-inline">Operations</strong> that contains a <strong class="source-inline">runningInfo</strong> method. This function receives two parameters: <strong class="source-inline">msg1</strong> and <strong class="source-inline">msg2</strong>. With these parameters, it returns the following message: <strong class="source-inline">Running app &lt;msg1&gt; in namespace &lt;msg2&gt;</strong>.</li>
				<li><strong class="source-inline">build_push.sh</strong>: This is a sample script to build an image manually. It receives two parameters; the first one is your Docker username and the second is a tag for the image. You can run it as follows:<p class="source-code"><strong class="bold">$ /bin/bash build_push.sh &lt;DOCKER_USERNAME&gt; &lt;IMAGE_TAG&gt;</strong></p></li>
				<li><strong class="source-inline">index.py</strong>: This is <a id="_idIndexMarker518"/>the main Python file to run our application. It has a function called <strong class="source-inline">hello_world</strong> that gets the <strong class="source-inline">MESSAGE</strong> and <strong class="source-inline">NAMESPACE</strong> environment variables and then calls the <strong class="source-inline">runningInfo</strong> function to return the following message: <strong class="source-inline">Running app &lt;MESSAGE&gt; in namespace &lt;NAMESPACE&gt;</strong>. So, every time you call the application in <strong class="source-inline">route /</strong> and port <strong class="source-inline">5000</strong>, it will show the message, then <strong class="source-inline">route /_health return Running message, /_version a custom message</strong>. You could use this route to explore the application. To take a look at the code, check out the following link: <a href="https://github.com/sergioarmgpl/fluxappdemo/blob/main/src/index.py">https://github.com/sergioarmgpl/fluxappdemo/blob/main/src/index.py</a>.</li>
				<li><strong class="source-inline">requirements.txt</strong>: Includes all the necessary libraries to run the code.</li>
				<li><strong class="source-inline">tests.py</strong>: This file includes a small test for the <strong class="source-inline">runningInfo</strong> function inside the <strong class="source-inline">Operations</strong> class.</li>
			</ul>
			<p>You can see an overview of the <strong class="source-inline">src</strong> directory in the following screenshot:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B16945_07_06.jpg" alt="Figure 7.6 – src directory with source code&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – src directory with source code</p>
			<p><strong class="source-inline">.github/workflows</strong> contains a <strong class="source-inline">github-actions-fluxappdemo.yml</strong> file. This file <a id="_idIndexMarker519"/>contains a CI pipeline definition that builds and pushes your container ARM image using the following name and tag format: <strong class="source-inline">&lt;DOCKER_USER&gt;/fluxappdemo:RELEASE.YEAR-MONTH-DAYT-HOUR-MINUTE-SECONDZ</strong>.</p>
			<p><strong class="source-inline">DOCKER_USER</strong> is your Docker username.</p>
			<p>You can see this file in the following screenshot:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B16945_07_07.jpg" alt="Figure 7.7 – GitHub Actions workflows file&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – GitHub Actions workflows file</p>
			<p>With this brief explanation, let’s move on to configure your own pipeline to build and push your container image.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor155"/>Building your container image with GitHub Actions</h1>
			<p>To build <a id="_idIndexMarker520"/>and push your image with GitHub <a id="_idIndexMarker521"/>Actions, you should follow the given steps:</p>
			<ol>
				<li value="1">Fork the <a href="https://github.com/sergioarmgpl/fluxappdemo">https://github.com/sergioarmgpl/fluxappdemo</a> repository. This is going to create a repository named <strong class="source-inline">https://github.com/&lt;GITHUB_USER&gt;/fluxappdemo</strong>.</li>
			</ol>
			<p><strong class="source-inline">GITHUB_USER</strong> is the username of your GitHub account. Replace it with your own username.</p>
			<ol>
				<li value="2">Create <strong class="source-inline">DOCKERHUB_USERNAME</strong> and <strong class="source-inline">DOCKERHUB_TOKEN</strong> secrets for your repository. These will be created as encrypted secrets for a repository. To create the secrets, open the following page in the browser: <strong class="source-inline">https://github.com/&lt;GITHUB_USER&gt;/fluxappdemo/settings/secrets/actions</strong>.</li>
			</ol>
			<p>After adding the variables, your repository will look like this:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B16945_07_08.jpg" alt="Figure 7.8 – GitHub repository secrets&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – GitHub repository secrets</p>
			<ol>
				<li value="3">Modify the <strong class="source-inline">.github/workflows/github-actions-fluxappdemo.yml</strong> file in the last line in the <strong class="source-inline">tags</strong> section with your user. It will look like this:<p class="source-code"><strong class="bold">tags: &lt;DOCKER_USER&gt;/fluxappdemo</strong></p></li>
			</ol>
			<p>Here, <strong class="source-inline">DOCKER_USER</strong> is your Docker Hub username.</p>
			<ol>
				<li value="4">Commit <a id="_idIndexMarker522"/>and push the changes.</li>
				<li>(<em class="italic">Optional</em>) To check <a id="_idIndexMarker523"/>whether your GitHub action is running, you can check out the following link: <strong class="source-inline">https://github.com/&lt;GITHUB_USER&gt;/fluxappdemo/actions</strong>. The following screenshot provides an example of how this should look:</li>
			</ol>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B16945_07_09.jpg" alt="Figure 7.9 – GitHub Actions showing current workflows&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – GitHub Actions showing current workflows</p>
			<ol>
				<li value="6">(<em class="italic">Optional</em>) To check <a id="_idIndexMarker524"/>new container <a id="_idIndexMarker525"/>tags created for your account, check out the following link: <strong class="source-inline">https://hub.docker.com/repository/docker/&lt;DOCKERHUB_USERNAME&gt;/fluxappdemo/tags</strong>. The following screenshot provides an example of how this should look:</li>
			</ol>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B16945_07_10.jpg" alt="Figure 7.10 – Docker Hub tags for a repository&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Docker Hub tags for a repository</p>
			<ol>
				<li value="7">(<em class="italic">Optional</em>) To test whether your GitHub Actions pipeline works, modify the source code of the <a id="_idIndexMarker526"/>application inside the <strong class="source-inline">src</strong> directory <a id="_idIndexMarker527"/>and commit and push the changes. Then, a new workflow will be running.</li>
			</ol>
			<p class="callout-heading">Important Note</p>
			<p class="callout">For more information about creating encrypted secrets for a repository, check out the following link: <a href="https://docs.github.com/en/actions/security-guides/encrypted-secrets">https://docs.github.com/en/actions/security-guides/encrypted-secrets</a>. To create a token to access your Docker Hub account to push new images, check out this link: <a href="https://docs.docker.com/docker-hub/access-tokens">https://docs.docker.com/docker-hub/access-tokens</a>. Finally, to fork a repository, check out the following link: <a href="https://docs.github.com/en/get-started/quickstart/fork-a-repo">https://docs.github.com/en/get-started/quickstart/fork-a-repo</a>.</p>
			<p>Now that we have configured a GitHub Actions pipeline to automate the creation of a container image with its tags, it’s time to start configuring Flux to complete our GitOps workflow in the next section.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor156"/>Installing and configuring Flux for GitOps</h1>
			<p>Before configuring Flux, let’s understand what we are going to install in this section. In this section, we are <a id="_idIndexMarker528"/>going to install Flux and its components <a id="_idIndexMarker529"/>that detect new image tags for your container. Once new images are detected, Flux modifies the <strong class="source-inline">HelmRelease</strong> definition file inside your deployment repository. Then, Flux will automatically reconcile changes, updating the application deployment defined in this <strong class="source-inline">HelmRelease</strong> file that is using the Helm chart published at <a href="https://sergiops.xyz/helm-charts">https://sergiops.xyz/helm-charts</a>. Together with the GitHub Actions workflow defined in the <em class="italic">Building your container image with GitHub Actions</em> section, the complete workflow is going to work like this:</p>
			<ol>
				<li value="1">The user pushes changes from its local repository copy to the original source code repository located at <strong class="source-inline">https://github.com/&lt;GITHUB_USER&gt;/fluxappdemo</strong>.</li>
				<li>GitHub Actions builds and pushes the image to Docker Hub at <strong class="source-inline">https://hub.docker.com/repository/docker/&lt;DOCKER_USER&gt;/fluxappdemo</strong>.</li>
				<li>Flux detects the new tag generated when the image was updated.</li>
				<li>Flux replaces the <strong class="source-inline">HelmRelease</strong> definition with the new tag. For this, Flux modifies, commits, and pushes the changes to the repository with your deployment definitions at <strong class="source-inline">https://github.com/&lt;GITHUB_USER&gt;/fluxdemo-production.git</strong>.</li>
				<li>Flux reconciles the changes, and the application is updated with the new image tag.</li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">&lt;GITHUB_USER&gt;</strong> and <strong class="source-inline">&lt;DOCKER_USER&gt;</strong> values have to be replaced with your GitHub and Docker users.</p>
			<p>To start building this use case scenario with Flux, you have to install the Flux <strong class="bold">CLI</strong>. Here’s how to do it: </p>
			<ol>
				<li value="1">To install the Flux CLI on Linux, run the following command:<p class="source-code"><strong class="bold">$ curl -s https://fluxcd.io/install.sh | sudo bash</strong></p></li>
				<li>Or, if you have macOS, you can install Flux with Homebrew using the following command:<p class="source-code"><strong class="bold">$ brew install fluxcd/tap/flux</strong></p></li>
			</ol>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You can check for alternative installation at the official website, <a href="https://fluxcd.io">https://fluxcd.io</a>.</p>
			<p>Now, you have to install the Flux image updater feature, necessary to automate the CD process every <a id="_idIndexMarker530"/>time that a new image tag is detected. To install Flux <a id="_idIndexMarker531"/>and all necessary components, follow the given steps on each cluster:</p>
			<ol>
				<li value="1">Set your environment variables; in this case, we need to set our GitHub user and the token of our GitHub account, as follows:<p class="source-code"><strong class="bold">$ export GITHUB_USER=&lt;YOUR_USER&gt;</strong></p><p class="source-code"><strong class="bold">$ export GITHUB_TOKEN=&lt;YOUR_GITHUB_TOKEN&gt;</strong></p><p class="source-code"><strong class="bold">$ export DOCKER_USER=&lt;YOUR_DOCKER_USERNAME&gt;</strong></p></li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">Check out the following link to create a token for your GitHub account: <a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token">https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token</a>.</p>
			<ol>
				<li value="2">Let’s set the email address and username associated with your GitHub account. For this, run the following commands:<p class="source-code"><strong class="bold">$ git config --global user.email "&lt;YOUR_EMAIL&gt;"</strong></p><p class="source-code"><strong class="bold">$ git config --global user.name "&lt;YOUR_NAME&gt;"</strong></p></li>
				<li>Now, install Flux and all the necessary components for image updater implementation. For this, run the following commands:<p class="source-code"><strong class="bold">$ CLUSTER_N=1</strong></p><p class="source-code"><strong class="bold">$ flux bootstrap github \</strong></p><p class="source-code"><strong class="bold">--kubeconfig /etc/rancher/k3s/k3s.yaml \</strong></p><p class="source-code"><strong class="bold">--components-extra=image-reflector-controller,image-automation-controller \</strong></p><p class="source-code"><strong class="bold">--owner=$GITHUB_USER \</strong></p><p class="source-code"><strong class="bold">--repository=fluxdemo-production \</strong></p><p class="source-code"><strong class="bold">--branch=main \</strong></p><p class="source-code"><strong class="bold">--path=./clusters/cluster$CLUSTER_N \</strong></p><p class="source-code"><strong class="bold">--read-write-key \</strong></p><p class="source-code"><strong class="bold">--personal</strong></p></li>
			</ol>
			<p>The <strong class="source-inline">repository</strong> parameter <a id="_idIndexMarker532"/>is the name of the GitHub <a id="_idIndexMarker533"/>repository to create— for example, <strong class="source-inline">fluxdemo-production</strong>.</p>
			<p><strong class="source-inline">CLUSTER_N</strong> is an environment variable with the number of the cluster where you are installing Flux—for example, <strong class="source-inline">CLUSTER_1</strong>. The YAML files used to install Flux will be stored inside the <strong class="source-inline">clusters/production/&lt;CLUSTER_N&gt;</strong> directory.</p>
			<p>The process will show the message <strong class="bold">waiting for Kustomization “flux-system/flux-system” to be reconciled</strong>. Once Flux is installed, you will see the message <strong class="bold">all components are healthy</strong>.</p>
			<p>This command is going to create a repository with your user account. The link to access this repository will be <strong class="source-inline">https://github.com/&lt;GITHUB_USER&gt;/fluxdemo-production.git</strong>.</p>
			<p><strong class="source-inline">GITHUB_USER</strong> is the name of your GitHub username. Replace this value in the link with your own.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Omit the <strong class="source-inline">--components-extra=image-reflector-controller,image-automation-controller</strong> line for <strong class="source-inline">cluster2</strong> and <strong class="source-inline">cluster3</strong>. <strong class="source-inline">cluster1</strong> is in charge of updating the application definitions for all clusters. Also refer to the help for this command by running <strong class="source-inline">flux bootstrap github --help</strong> for more options, especially if you are using an organization or enterprise or another versioning tool.</p>
			<ol>
				<li value="4">Clone the <a id="_idIndexMarker534"/>new repository and change it into this directory:<p class="source-code"><strong class="bold">$ git clone https://github.com/$GITHUB_USER/fluxdemo-production.git</strong></p><p class="source-code"><strong class="bold">$ cd fluxdemo-production</strong></p></li>
			</ol>
			<p>This is going <a id="_idIndexMarker535"/>to ask you to enter your username and password to clone your repository. This will be used in the next steps to customize and create deployment definitions. Proceed as follows:</p>
			<ol>
				<li value="1">Create a namespace for your application inside a directory called <strong class="source-inline">clusters/&lt;clusterN&gt;/manifests</strong>. For this, run the following commands: <p class="source-code"><strong class="bold">$ mkdir -p ./clusters/cluster$CLUSTER_N/manifests</strong></p><p class="source-code"><strong class="bold">$ kubectl create ns production --dry-run=client -o YAML &gt; ./clusters/cluster$CLUSTER_N/manifests/namespace.yaml</strong></p></li>
			</ol>
			<p>Create a Helm chart source Flux object to point to your own Helm chart, as follows:</p>
			<p class="source-code"><strong class="bold">$ flux create source helm helm-charts \</strong></p>
			<p class="source-code"><strong class="bold">--kubeconfig /etc/rancher/k3s/k3s.yaml \</strong></p>
			<p class="source-code"><strong class="bold">--url=https://sergiops.xyz/helm-charts \</strong></p>
			<p class="source-code"><strong class="bold">--interval=1m \</strong></p>
			<p class="source-code"><strong class="bold">--namespace=production \</strong></p>
			<p class="source-code"><strong class="bold">--export &gt; ./clusters/cluster$CLUSTER_N/manifests/helm-charts.yaml</strong></p>
			<p>In this example, we <a id="_idIndexMarker536"/>are using a Helm chart with a sample <a id="_idIndexMarker537"/>application in <a href="https://sergiops.xyz/helm-charts">https://sergiops.xyz/helm-charts</a>.</p>
			<ol>
				<li value="2">Create a Flux <strong class="source-inline">HelmRelease</strong> object to create a YAML definition for your application deployment, as follows:<p class="source-code"><strong class="bold">$ flux create helmrelease app-demo --chart app-demo \</strong></p><p class="source-code"><strong class="bold">--source HelmRepository/helm-charts.production \</strong></p><p class="source-code"><strong class="bold">--chart-version 0.0.1 \</strong></p><p class="source-code"><strong class="bold">--interval=1m \</strong></p><p class="source-code"><strong class="bold">--namespace production \</strong></p><p class="source-code"><strong class="bold">--export &gt; ./clusters/cluster$CLUSTER_N/manifests/helm-release.yaml</strong></p></li>
			</ol>
			<p>Let’s add a section called <strong class="source-inline">values</strong> to the file by running the following command:</p>
			<p class="source-code"><strong class="bold">cat &lt;&lt; EOF &gt;&gt; ./clusters/cluster$CLUSTER_N/manifests/helm-release.yaml</strong></p>
			<p class="source-code"><strong class="bold">  values:</strong></p>
			<p class="source-code"><strong class="bold">    replicaCount: 3</strong></p>
			<p class="source-code"><strong class="bold">    containerPort: 5000</strong></p>
			<p class="source-code"><strong class="bold">    dockerImage: $DOCKER_USER/fluxappdemo:RELEASE.2022-01-16T05-42-20Z # {"\$imagepolicy": "flux-system:app-demo"}</strong></p>
			<p class="source-code"><strong class="bold">    namespace: "production"</strong></p>
			<p class="source-code"><strong class="bold">    domain: "app-demo-cluster$CLUSTER_N.domain.tld"</strong></p>
			<p class="source-code"><strong class="bold">    changeCause: "First Deployment cluster $CLUSTER_N"</strong></p>
			<p class="source-code"><strong class="bold">    message: "cluster$CLUSTER_N"</strong></p>
			<p class="source-code"><strong class="bold">    appname: "app-demo-cluster$CLUSTER_N"</strong></p>
			<p class="source-code"><strong class="bold">    node: "machine$CLUSTER_N"</strong></p>
			<p class="source-code"><strong class="bold">EOF</strong></p>
			<p>Pay <a id="_idIndexMarker538"/>attention to the commented line <strong class="source-inline"># {"$imagepolicy": "flux-system:app-demo"}</strong>.</p>
			<p>This part <a id="_idIndexMarker539"/>tells Flux to find where to replace the image with the new tag. Finally, the file will look like this:</p>
			<p class="source-code"><strong class="bold">apiVersion: helm.toolkit.fluxcd.io/v2beta1</strong></p>
			<p class="source-code"><strong class="bold">kind: HelmRelease</strong></p>
			<p class="source-code"><strong class="bold">metadata:</strong></p>
			<p class="source-code"><strong class="bold">  name: app-demo</strong></p>
			<p class="source-code"><strong class="bold">  namespace: production</strong></p>
			<p class="source-code"><strong class="bold">spec:</strong></p>
			<p class="source-code"><strong class="bold">  chart:</strong></p>
			<p class="source-code"><strong class="bold">    spec:</strong></p>
			<p class="source-code"><strong class="bold">      chart: app-demo</strong></p>
			<p class="source-code"><strong class="bold">      sourceRef:</strong></p>
			<p class="source-code"><strong class="bold">        kind: HelmRepository</strong></p>
			<p class="source-code"><strong class="bold">        name: helm-charts</strong></p>
			<p class="source-code"><strong class="bold">        namespace: production</strong></p>
			<p class="source-code"><strong class="bold">      version: 0.0.1</strong></p>
			<p class="source-code"><strong class="bold">  interval: 1m0s</strong></p>
			<p class="source-code"><strong class="bold">  values:</strong></p>
			<p class="source-code"><strong class="bold">    replicaCount: 3</strong></p>
			<p class="source-code"><strong class="bold">    containerPort: 5000</strong></p>
			<p class="source-code"><strong class="bold">    dockerImage: &lt;DOCKER_USER&gt;/fluxappdemo:RELEASE.2022-01-16T05-42-20Z # {"$imagepolicy": "flux-system:app-demo"} </strong></p>
			<p class="source-code"><strong class="bold">    namespace: "production"</strong></p>
			<p class="source-code"><strong class="bold">    domain: "app-demo-cluster1.domain.tld"</strong></p>
			<p class="source-code"><strong class="bold">    changeCause: "First Deployment cluster 1"</strong></p>
			<p class="source-code"><strong class="bold">    message: "cluster1"</strong></p>
			<p class="source-code"><strong class="bold">    appname: "app-demo-cluster1"</strong></p>
			<p class="source-code"><strong class="bold">    node: "machine1"</strong></p>
			<p>This <strong class="source-inline">HelmRelease</strong> object <a id="_idIndexMarker540"/>provided with the Flux installation <a id="_idIndexMarker541"/>provides a declarative way to parametrize a deployment. In this case, the values inside the <strong class="source-inline">values</strong> section correspond to the different parameters that you can send to our Helm chart. The creation of Helm charts is out of the scope of this book, but you can find good resources at the end of the chapter in the <em class="italic">Further reading</em> section.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can check the repository at <a href="https://github.com/sergioarmgpl/fluxdemo-production">https://github.com/sergioarmgpl/fluxdemo-production</a> to see the final results of creating and modifying configuration files for your demo application with the previous commands.</p>
			<p>This <strong class="source-inline">HelmRelease</strong> object is stored in a file and is the object that you need to modify, commit, and push your changes to your repository. After this, Flux detects the <a id="_idIndexMarker542"/>changes and updates your application. This <a id="_idIndexMarker543"/>file is inside of your repository in the <strong class="source-inline">clusters/cluster$CLUSTER_N/manifests/helm-release.yaml</strong> path. In this way, you can test how Flux updates your application, where the <strong class="source-inline">CLUSTER_N</strong> variable is the cluster number that you are modifying.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you want to create your own Helm chart repository, you can check out <a href="https://helm.sh/docs/topics/chart_repository">https://helm.sh/docs/topics/chart_repository</a> and go to the <em class="italic">GitHub Pages e</em><a href="https://sergiops.xyz/helm-charts"><em class="italic">xample</em> section. In this example,</a> we are using the charts located at <a href="https://sergiops.xyz/helm-charts">https://sergiops.xyz/helm-charts</a> and <a href="https://github.com/sergioarmgpl/helm-charts/tree/gh-pages">https://github.com/sergioarmgpl/helm-charts/tree/gh-pages</a>. You can check or clone this repository to create your own.</p>
			<p><em class="italic">You can omit Steps 11-13 if you are configuring cluster2 and cluster3 because cluster1 will be in charge of updating all the deployments’ definitions.</em></p>
			<ol>
				<li value="3">(<em class="italic">Optional</em>) Create an image repository to detect new releases or tags for your image, as follows:<p class="source-code"><strong class="bold">$ flux create image repository app-demo \</strong></p><p class="source-code"><strong class="bold">--kubeconfig /etc/rancher/k3s/k3s.yaml \</strong></p><p class="source-code"><strong class="bold">--image=$DOCKER_USER/fluxappdemo \</strong></p><p class="source-code"><strong class="bold">--namespace=flux-system \</strong></p><p class="source-code"><strong class="bold">--interval=1m \</strong></p><p class="source-code"><strong class="bold">--export &gt; ./clusters/cluster$CLUSTER_N/manifests/app-demo-registry.yaml</strong></p></li>
				<li>(<em class="italic">Optional</em>) Create an image policy to define an expression to match to detect new image <a id="_idIndexMarker544"/>tags or releases from your image registry. This use <a id="_idIndexMarker545"/>case is going to use the following format to tag the new Docker images:</li>
			</ol>
			<p><strong class="source-inline">RELEASE.YEAR-MONTH-DAYT-HOUR-MINUTE-SECONDZ</strong></p>
			<p>This convention is based on RFC3339 and ISO 7601, which refers to the standards for date and time on the internet:</p>
			<p class="source-code"><strong class="bold">$ flux create image policy app-demo \ </strong></p>
			<p class="source-code"><strong class="bold">--image-ref=app-demo \ </strong></p>
			<p class="source-code"><strong class="bold">--namespace=flux-system \ </strong></p>
			<p class="source-code"><strong class="bold">--select-alpha=asc \</strong></p>
			<p class="source-code"><strong class="bold">--filter-regex='^RELEASE\.(?P&lt;timestamp&gt;.*)Z$' \</strong></p>
			<p class="source-code"><strong class="bold">--filter-extract='$timestamp' \</strong></p>
			<p class="source-code"><strong class="bold">--export &gt; ./clusters/cluster$CLUSTER_N/manifests/app-demo-policy.yaml</strong></p>
			<ol>
				<li value="5">(<em class="italic">Optional</em>) Now, it’s time to put all the pieces together. For this, you have to create an <strong class="source-inline">ImageUpdateAutomation</strong> object, which is going to detect new releases and update the images in your deployments’ YAML definitions. In the following case, it’s going to check the folder clusters to update all the YAML definitions:<p class="source-code"><strong class="bold">$ flux create image update flux-system \</strong></p><p class="source-code"><strong class="bold">--git-repo-ref=flux-system \</strong></p><p class="source-code"><strong class="bold">--git-repo-path="./clusters" \</strong></p><p class="source-code"><strong class="bold">--checkout-branch=main \</strong></p><p class="source-code"><strong class="bold">--push-branch=main \</strong></p><p class="source-code"><strong class="bold">--author-name=&lt;AUTHOR_NAME&gt; \</strong></p><p class="source-code"><strong class="bold">--author-email=&lt;AUTHOR_EMAIL&gt; \</strong></p><p class="source-code"><strong class="bold">--commit-template="{{range .Updated.Images}}{{println .}}{{end}}" \</strong></p><p class="source-code"><strong class="bold">--export &gt; ./clusters/cluster$CLUSTER_N/manifests/flux-system-automation.yaml</strong></p></li>
			</ol>
			<p>You have to change the <strong class="source-inline">&lt;AUTHOR_NAME&gt;</strong> and <strong class="source-inline">&lt;AUTHOR_EMAIL&gt;</strong> tags with your own values. This will appear as the commit author when Flux pushes changes for image tags.</p>
			<ol>
				<li value="6">Commit and <a id="_idIndexMarker546"/>push the changes to the repository with the <a id="_idIndexMarker547"/>following commands:<p class="source-code"><strong class="bold">$ git add -A</strong></p><p class="source-code"><strong class="bold">$ git commit -m "feat: App YAML definitions"</strong></p><p class="source-code"><strong class="bold">$ git push origin main</strong></p></li>
			</ol>
			<p>The <strong class="source-inline">push</strong> command is going to ask you for the user and the token that you previously created, to access your GitHub account.</p>
			<p>Now, you can build a new image, and you can wait for Flux to automatically update your <strong class="source-inline">HelmRelease</strong> file with the new image detected. After 1 minute or more, you can expect the change to have been made. You will expect to see a commit in your repository made by Flux with the new tag detected, to troubleshoot whether the image updater is working.</p>
			<ol>
				<li value="7">(<em class="italic">Optional</em>) You can force Flux to apply this configuration by running the Flux reconciliation process with the following command:<p class="source-code"><strong class="bold">$ flux reconcile kustomization flux-system --with-source --kubeconfig /etc/rancher/k3s/k3s.yaml</strong></p></li>
				<li>The Helm chart is going to provision a <strong class="source-inline">LoadBalancer</strong> service type. To find the provisioned IP address, run the following command:<p class="source-code"><strong class="bold">$ IP_LOADBALANCER=$(kubectl get svc app-demo-cluster$CLUSTER_N-srv --output jsonpath='{.status.loadBalancer.ingress[0].ip}' -n production)</strong></p></li>
			</ol>
			<p>Here, the <strong class="source-inline">IP_LOADBALANCER</strong> variable contains the IP of the load balancer created by the <strong class="source-inline">HelmRelease</strong> definition, which is the endpoint for your application <a id="_idIndexMarker548"/>in this cluster. You can check the value by <a id="_idIndexMarker549"/>running the following command:</p>
			<p class="source-code"><strong class="bold">$ echo $IP_LOADBALANCER</strong></p>
			<p>Using <em class="italic">Figure 7.4</em> as a reference, you will expect to see an IP address such as <strong class="source-inline">192.168.0.52</strong>.</p>
			<ol>
				<li value="9">Let’s say that, for example, the returned IP is <strong class="source-inline">192.168.0.52</strong>. You can access your application with the following URL: <strong class="source-inline">http://192.168.0.52:5000</strong>. You can test to access other routes—for example, <strong class="source-inline">/_version</strong> or <strong class="source-inline">/_health</strong>.</li>
			</ol>
			<p>Now that you have installed Flux, you can start testing the auto-reconciliation to update your files by committing and pushing the changes of your <strong class="source-inline">HelmRelease</strong> files. The auto-reconciliation updates everything Flux detects in new image tags of your applications. This process is described in the previous section, <em class="italic">Designing GitOps with Flux for edge applications</em>. After this, you can continue with the next section to learn how to troubleshoot your installation.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor157"/>Troubleshooting Flux installations</h1>
			<p>There are <a id="_idIndexMarker550"/>a few useful commands that can help you to troubleshoot your installation; in this section, we’re going to find out what these are. So, let’s proceed as follows:</p>
			<ol>
				<li value="1">To reconcile Flux changes in Flux, run the following command:<p class="source-code"><strong class="bold">$ watch flux get images all --all-namespaces --kubeconfig /etc/rancher/k3s/k3s.yaml</strong></p></li>
			</ol>
			<p>This command is going to show new tags detected for your container, and how these new tags are set up in your <strong class="source-inline">HelmRelease</strong> YAML definition file.</p>
			<ol>
				<li value="2">To check the image repositories in Flux, run the following command:<p class="source-code"><strong class="bold">$ flux get image repository app-demo --kubeconfig /etc/rancher/k3s/k3s.yaml --namespace=production</strong></p></li>
				<li>To check <a id="_idIndexMarker551"/>the current policy in your cluster, run the following command:<p class="source-code"><strong class="bold">$ flux get image policy app-demo --kubeconfig /etc/rancher/k3s/k3s.yaml --namespace=production</strong></p></li>
				<li>To get all images configured in your Flux installation, run the following command: <p class="source-code"><strong class="bold">$ flux get images all --all-namespaces --kubeconfig /etc/rancher/k3s/k3s.yaml</strong></p></li>
				<li>To reconcile YAML definition changes in your cluster, run the following command:<p class="source-code"><strong class="bold">$ flux reconcile kustomization flux-system --with-source --kubeconfig /etc/rancher/k3s/k3s.yaml</strong></p></li>
				<li>To watch in real time how image detection and updates to your repositories are running, run the following command: <p class="source-code"><strong class="bold">$ watch flux get images all --all-namespaces --kubeconfig /etc/rancher/k3s/k3s.yaml</strong></p></li>
				<li>To check your application deployments, run the following command:<p class="source-code"><strong class="bold">$ kubectl get deploy -n production</strong></p></li>
				<li>To check your Pods, run the following command:<p class="source-code"><strong class="bold">$ kubectl get pods -n production</strong></p></li>
			</ol>
			<p>You have now learned these essential commands to troubleshoot your Flux system.</p>
			<p>In the next section, we are going to explore Flux monitoring dashboards.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor158"/>Installing Flux monitoring dashboards</h1>
			<p>Flux itself doesn’t include a graphical user interface for management but integrates some useful dashboards <a id="_idIndexMarker552"/>using Prometheus and Grafana to visualize the state of your deployments. These dashboards have to be installed on each cluster. To install this feature, follow the next steps:</p>
			<ol>
				<li value="1">Configure the Git repository that contains monitoring stack definitions for its installation. The configuration will listen for changes every 30 minutes. The code is illustrated here:<p class="source-code"><strong class="bold">$ flux create source git monitoring \</strong></p><p class="source-code"><strong class="bold">--interval=30m \</strong></p><p class="source-code"><strong class="bold">--kubeconfig /etc/rancher/k3s/k3s.yaml \</strong></p><p class="source-code"><strong class="bold">--url=https://github.com/fluxcd/flux2 \</strong></p><p class="source-code"><strong class="bold">--branch=main</strong></p></li>
				<li>Install <strong class="source-inline">kube-prometheus-stack</strong>, which is going to be used to configure Prometheus for your dashboards. This stack will be installed in the <strong class="source-inline">monitoring</strong> namespace. The code is illustrated in the following snippet:<p class="source-code"><strong class="bold">$ flux create kustomization monitoring-stack \</strong></p><p class="source-code"><strong class="bold">--interval=1h \</strong></p><p class="source-code"><strong class="bold">--kubeconfig /etc/rancher/k3s/k3s.yaml \</strong></p><p class="source-code"><strong class="bold">--prune=true \</strong></p><p class="source-code"><strong class="bold">--source=monitoring \</strong></p><p class="source-code"><strong class="bold">--path="./manifests/monitoring/kube-prometheus-stack" \</strong></p><p class="source-code"><strong class="bold">--health-check="Deployment/kube-prometheus-stack-operator.monitoring" \</strong></p><p class="source-code"><strong class="bold">--health-check="Deployment/kube-prometheus-stack-grafana.monitoring" \</strong></p><p class="source-code"><strong class="bold">--health-check-timeout="5m0s"</strong></p></li>
				<li>Install Grafana and configure your Flux dashboards, storing data in Prometheus and visualizing <a id="_idIndexMarker553"/>this across preconfigured dashboards in Grafana. The code is illustrated in the following snippet:<p class="source-code"><strong class="bold">$ flux create kustomization monitoring-config \</strong></p><p class="source-code"><strong class="bold">--interval=1h \</strong></p><p class="source-code"><strong class="bold">--kubeconfig /etc/rancher/k3s/k3s.yaml \</strong></p><p class="source-code"><strong class="bold">--prune=true \</strong></p><p class="source-code"><strong class="bold">--source=monitoring \</strong></p><p class="source-code"><strong class="bold">--path="./manifests/monitoring/monitoring-config"</strong></p></li>
				<li>Access the dashboards using the next command:<p class="source-code"><strong class="bold">$ kubectl -n monitoring port-forward svc/kube-prometheus-stack-grafana --address 0.0.0.0 3000:80</strong></p></li>
			</ol>
			<p>This is going to open port <strong class="source-inline">3000</strong> of your dashboard. Remember that the IP address that you have to access is the IP of the node where you are accessing this dashboard.</p>
			<p>Access the dashboard using the following URL: <strong class="source-inline">http://&lt;NODE_IP_ADDRESS&gt;:3000/d/flux-control-plane</strong>.</p>
			<p><strong class="source-inline">NODE_IP_ADDRESS</strong> is the IP address cluster node where you are running the command shown in this step. </p>
			<ol>
				<li value="5">To access the dashboard, use the next credentials:<ul><li>Username: <strong class="source-inline">admin</strong></li><li>Password: <strong class="source-inline">prom-operator</strong></li></ul></li>
			</ol>
			<p>The login screen will look like this:</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B16945_07_11.jpg" alt="Figure 7.11 – Grafana login form&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Grafana login form</p>
			<p>Once you <a id="_idIndexMarker554"/>are logged in, you will be redirected to the dashboard URL previously mentioned.</p>
			<ol>
				<li value="6">Once the dashboard is opened, it will look like this:</li>
			</ol>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B16945_07_12.jpg" alt="Figure 7.12 – Grafana Flux control plane dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – Grafana Flux control plane dashboard</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Remember that you can customize this dashboard and create your own dashboards. For more information about this dashboard, you can visit the following link: <a href="https://fluxcd.io/docs/guides/monitoring">https://fluxcd.io/docs/guides/monitoring</a>.</p>
			<p>Your Grafana <a id="_idIndexMarker555"/>dashboards are now installed successfully, and you can see the state of your deployments. Now, it’s time to learn how to uninstall Flux in the next section. </p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/>Uninstalling Flux</h1>
			<p>Once you <a id="_idIndexMarker556"/>don’t need the Flux installation anymore, you can run the following command:</p>
			<p class="source-code">$ flux uninstall -s --namespace=flux-system --kubeconfig /etc/rancher/k3s/k3s.yaml</p>
			<p>This is going to uninstall Flux from your Kubernetes cluster. Now, it’s time to finish the chapter.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/>Summary</h1>
			<p>In this chapter, we learned how GitOps works and how you can implement GitOps using GitHub Actions and Flux. Flux could be useful to automate your deployments on an edge environment, using a single Git repository. For this, we learned how Flux can implement GitOps to update your applications at the edge using the HelmRelease object and the image updater feature. Flux can manage your application cluster without using an external way to expose the Kubernetes API of your cluster, which is the case with tools such as Argo CD. This can be translated into cost savings and a more effective tool for edge environments using ARM devices. Argo CD, on the other hand, doesn’t support ARM and needs a way to expose your Kubernetes API from your cluster to connect the cluster to Argo CD using a public load balancer or a virtual machine on the internet. In the next chapter, we are going to learn how to add basic observability and traffic splitting to your applications using Linkerd.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor161"/>Questions</h1>
			<p>Here are a few questions to validate your new knowledge:</p>
			<ul>
				<li>How can GitHub Actions help me to implement GitOps at the edge?</li>
				<li>How can I implement GitOps using Flux?</li>
				<li>Which other features does Flux have that can help me to implement GitOps?</li>
				<li>How can I troubleshoot my Helm releases with Flux?</li>
				<li>How can I apply this simple use case in my edge computing scenarios?</li>
				<li>How can I structure my repositories for GitOps?</li>
			</ul>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor162"/>Further reading</h1>
			<p>You can refer to the following references for more information on the topics covered in this chapter:</p>
			<ul>
				<li><em class="italic">What is GitOps?</em>: <a href="https://www.gitops.tech">https://www.gitops.tech</a></li>
				<li><em class="italic">Dev Leaders Compare Continuous Delivery vs Continuous Deployment vs Continuous Integration</em>: <a href="https://stackify.com/continuous-delivery-vs-continuous-deployment-vs-continuous-integration">https://stackify.com/continuous-delivery-vs-continuous-deployment-vs-continuous-integration</a></li>
				<li>Quickstart on using GitHub: <a href="https://docs.github.com/en/get-started/quickstart">https://docs.github.com/en/get-started/quickstart</a></li>
				<li>GitHub Actions to build container images: <a href="https://github.com/docker/build-push-action">https://github.com/docker/build-push-action</a></li>
				<li>Docker Hub: <a href="https://hub.docker.com">https://hub.docker.com</a></li>
				<li>Creating secrets on GitHub Actions: <a href="https://docs.github.com/en/actions/security-guides/encrypted-secrets">https://docs.github.com/en/actions/security-guides/encrypted-secrets</a></li>
				<li>Date and time internet standard: <a href="https://datatracker.ietf.org/doc/html/rfc3339">https://datatracker.ietf.org/doc/html/rfc3339</a></li>
				<li>Creating a public Helm chart with GitHub Pages: <a href="mailto:https://medium.com/@mattiaperi/create-a-public-helm-chart-repository-with-github-pages-49b180dbb417">https://medium.com/@mattiaperi/create-a-public-helm-chart-repository-with-github-pages-49b180dbb417</a></li>
				<li>Creating a Helm chart repository: <a href="https://harness.io/blog/helm-chart-repo ">https://harness.io/blog/helm-chart-repo</a></li>
				<li>How to structure your Flux repositories: <a href="https://fluxcd.io/docs/guides/repository-structure">https://fluxcd.io/docs/guides/repository-structure</a></li>
				<li><em class="italic">Flux Documentation</em>: <a href="https://fluxcd.io/docs">https://fluxcd.io/docs</a></li>
				<li>Flux Helm releases: <a href="https://fluxcd.io/docs/guides/helmreleases">https://fluxcd.io/docs/guides/helmreleases</a></li>
				<li>Flux, Kustomize, and Helm example: <a href="https://github.com/fluxcd/flux2-kustomize-helm-example">https://github.com/fluxcd/flux2-kustomize-helm-example</a></li>
			</ul>
		</div>
	</body></html>