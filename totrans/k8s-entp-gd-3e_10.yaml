- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying a Secured Kubernetes Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes Dashboard is a very helpful tool for understanding how your cluster
    is running. It’s often the first thing someone will install when learning Kubernetes
    because it shows you something. Even after the beginning stage, dashboards provide
    a tremendous amount of information very quickly in a way that isn’t possible using
    `kubectl`. On one screen, you can quickly see what workloads are running, where,
    how many resources they’re using, and if you need to update them, you can do so
    quickly. Too often, the dashboard is called “insecure” or difficult to access.
    In this chapter, we’re going to show you how the dashboard is in fact quite secure
    and how to make it easy to access.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the Kubernetes Dashboard, Kubernetes clusters are made up of more than
    the API server and the `kubelet`. Clusters are generally made up of additional
    applications that need to be secured, such as container registries, source control
    systems, pipeline services, GitOps applications, and monitoring systems. The users
    of your cluster will often need to interact with these applications directly.
  prefs: []
  type: TYPE_NORMAL
- en: While many clusters are focused on authenticating access to user-facing applications
    and services, cluster solutions are not given the same first-class status. Users
    are often asked to use kubectl’s port-forward or proxy capability to access these
    systems. This method of access is an anti-pattern from a security and user experience
    standpoint. The first exposure users and administrators will have to this anti-pattern
    is the Kubernetes Dashboard. This chapter will detail why this method of access
    is an anti-pattern and how to properly access the dashboard. We’ll walk you through
    how not to deploy a secure web application and point out the issues and risks
    so that you’ll know what to look for when being advised on how to access management
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the Kubernetes Dashboard as a way to learn about web application security
    and how to apply those patterns in your own cluster. These lessons will work with
    not just the dashboard but also other cluster-focused applications such as the
    **Kiali dashboard** for Istio, Grafana, Prometheus, ArgoCD, and other cluster
    management applications.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll spend some time talking about local dashboards and how to evaluate
    their security. This is a popular trend, but not universal. It’s important to
    understand the security of both approaches, and we’ll explore them in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How does the dashboard know who you are?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding dashboard security risks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the dashboard with a reverse proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the dashboard with OpenUnison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s changed in the Kubernetes Dashboard 7.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having covered what we’ll work through in this chapter, next, let’s work through
    the technical requirements for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the exercises in this chapter, you will require a fresh KinD cluster
    from *Chapter 2*, *Deploying Kubernetes Using KinD*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the code for this chapter at the following GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter10](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter10).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting help
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We do our best to test everything, but there are sometimes half a dozen systems
    or more in our integration labs. Given the fluid nature of technology, sometimes
    things that work in our environment don’t work in yours. Don’t worry, we’re here
    to help! Open an issue on our GitHub repo at [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/issues](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/issues)
    and we’ll be happy to help you out!
  prefs: []
  type: TYPE_NORMAL
- en: How does the dashboard know who you are?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes Dashboard is a powerful web application for quickly accessing
    your cluster from inside a browser. It lets you browse your namespaces and view
    the status of nodes and even provides a shell you can use to access pods directly.
    There is a fundamental difference between using the dashboard and `kubectl`. The
    dashboard, being a web application, needs to manage your session, whereas `kubectl`
    does not. This means there’s a different set of security issues during deployment
    that are often not accounted for, leading to severe consequences. In this section,
    we’ll explore how the dashboard identifies users and interacts with the API server.
  prefs: []
  type: TYPE_NORMAL
- en: Dashboard architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the specifics of how the dashboard authenticates a user,
    it’s important to understand the basics of how the dashboard works. The dashboard,
    at a high level, has three logical layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User interface**: This is the Angular + HTML frontend that is displayed in
    your browser and that you interact with'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middle tier**: The frontend interacts with a set of APIs hosted in the dashboard’s
    container to translate calls from the frontend into Kubernetes API calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API server**: The middle-tier API interacts directly with the Kubernetes
    API server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This three-layered architecture of the Kubernetes Dashboard can be seen in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Kubernetes Dashboard architecture ](img/B21165_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Kubernetes Dashboard logical architecture'
  prefs: []
  type: TYPE_NORMAL
- en: When a user interacts with the dashboard, the user interface makes calls to
    the middle tier, which in turn makes calls to the API server. The dashboard doesn’t
    know how to collect credentials; there’s no place to supply a username or password
    to log in to the Dashboard. It has a very simple session mechanism system based
    on cookies, but for the most part, the dashboard doesn’t really know, or care,
    who the currently logged-in user is. The only thing the dashboard cares about
    is what token to use when communicating with the API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is the logical architecture, the physical architecture divides these
    components across different containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B21165_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Kubernetes Dashboard container architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with vertion 7.0, the dashboard is now broken into five components
    in their own containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web**: The user interface for the dashboard, serving the HTML and JavaScript
    rendered by your browser. This component has no authentication and doesn’t need
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Api**: This container hosts the workhorse of the dashboard. It’s the component
    that interacts with the API server on your behalf. This container needs to know
    who you are.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auth**: The auth container is used to tell the frontend if your token is
    valid. If the token isn’t valid, the UI will redirect you to login by providing
    the token to the API server for verification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metrics**: This container provides a metrics endpoint for **Prometheus**
    of the Kubernetes Dashboard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ingress Controller**: Since each of these containers provide their own path
    from the same host, something needs to combine them into a single URL. The default
    deployment includes Kong’s `Ingress` controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you looked at the pods running in *Chapter 6*, you’ll notice that neither
    `Kong` nor the `auth` container are running. We’ll cover that a bit later. Now
    that we understand how the dashboard is architected, how does the dashboard know
    who you are? Let’s walk through the options.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways that the dashboard can determine who a user is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Token from login/uploaded kubectl configuration**: The dashboard can prompt
    the user for their `kubectl` configuration file or for a bearer token to use.
    Once a token is provided, the UI uses it as a header to the API container. There
    is no session management. When the token is no longer valid, the user is redirected
    back to the login screen to upload a new token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Token from a reverse proxy**: If there’s an authorization header containing
    a bearer token in requests from the user interface to the middle tier, the middle
    tier will use that bearer token in requests to the API server. This is the most
    secure option and the implementation that will be detailed in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’ve read our previous editions, or have used previous versions of the
    dashboard, you may be wondering what happened to using the dashboard’s own identity
    and skipping login. The architectural changes in version 7.x meant the removal
    of this option. No matter what, there *MUST* be an `Authorization` header with
    a token in each request. This is a very positive development as it makes it very
    hard to deploy a dashboard that can be taken over by an anonymous request. In
    fact, we removed the section of this chapter that talked about how to compromise
    an improperly deployed dashboard because that attack vector is no longer valid.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the rest of this chapter, the first option will be explored as an
    anti-pattern for accessing the dashboard, and we will explain why the reverse
    proxy pattern is the best option for accessing a cluster’s dashboard implementation
    from a security standpoint and a user experience standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now try to understand dashboard security risks.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dashboard security risks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The question of the dashboard’s security often comes up when setting up a new
    cluster. Securing the dashboard boils down to how the dashboard is deployed, rather
    than if the dashboard itself is secure. Going back to the architecture of the
    dashboard application, there is no sense of “security” being built in. The middle
    tier simply passes a token to the API server.
  prefs: []
  type: TYPE_NORMAL
- en: When talking about any kind of IT security, it’s important to look at it through
    the lens of *defense in depth*. This is the idea that any system should have multiple
    layers of security. If one fails, there are other layers to fill the gap until
    the failed layers can be addressed. A single failure doesn’t give an attacker
    direct access.
  prefs: []
  type: TYPE_NORMAL
- en: The most often cited incident related to the dashboard’s security was the breach
    of Tesla in 2018 by crypto miners. Attackers were able to access pods running
    in Tesla’s clusters because the dashboard wasn’t secured.
  prefs: []
  type: TYPE_NORMAL
- en: The cluster’s pods had access to tokens that provided the attackers with access
    to Tesla’s cloud providers where the attackers ran their crypto-mining systems.
    It’s important to note that this attack would not have worked in version 7.x and
    above because the `api` container will not accept requests that don’t have `Authorization`
    headers.
  prefs: []
  type: TYPE_NORMAL
- en: Dashboards in general are often an attack vector because they make it easy to
    find what attackers are looking for and can easily be deployed insecurely. Illustrating
    this point, at KubeCon NA 2019, a **Capture the Flag** (**CTF**) challenge was
    presented where one of the scenarios was a developer “accidentally” exposing the
    cluster’s dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: The CTF challenge is available as a home lab at [https://securekubernetes.com/](https://securekubernetes.com/).
    It’s a highly recommended resource for anyone learning the Kubernetes security.
    In addition to being educational (and terrifying), it’s also really fun!
  prefs: []
  type: TYPE_NORMAL
- en: Since we can no longer deploy a dashboard without some kind of authentication,
    we’re going to focus on the security issues of using `ServiceAccount` tokens and
    the default. Additionally, there is no encryption between Kong and the downstream
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Dashboard Security Issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The version 7.x dashboard eliminated the ability to deploy the dashboard without
    a login, but there are still some security issues with the default deployment
    that should be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, deploy the dashboard to your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When you inspect the pods, you’ll notice that there are now the five containers
    we described earlier. There’s also a `NodePort` service for the `Kong` ingress
    gateway. While you can choose to deploy a different `Ingress`, we’re going to
    focus on the defaults. You’ll also see there’s also no encryption from Kong to
    the pods.
  prefs: []
  type: TYPE_NORMAL
- en: Using a token to log in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A user may upload a token to the dashboard on the login screen. As discussed
    earlier, the dashboard will take the user’s bearer token and use it with all requests
    to the API server. While this may appear to provide a secure solution, it brings
    its own issues. The dashboard isn’t `kubectl` and doesn’t know how to refresh
    tokens as they expire. This means that a token would need to be fairly long-lived
    to be useful. It would require either creating service accounts that can be used
    or making your OpenID Connect `id_tokens` longer-lived. Both options would negate
    much of the security put in place by leveraging OpenID Connect for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: As has been repeated throughout the book, `ServiceAccount` tokens were never
    meant to be used outside of the cluster. You’ll need to distribute the token,
    and of course since it’s a bearer token it’s easy to lose, maybe it gets checked
    in to a git repo, or can be leaked by some buggy code. There’s also no difference
    between a token that is used by the dashboard vs Kubernetes, so a leaked token
    can be used directly against the Kubernetes API. While this solution exists to
    make it relatively easy to use the dashboard, it shouldn’t be used in production.
  prefs: []
  type: TYPE_NORMAL
- en: Having looked at the issues with a token login into the dashboard, next we’ll
    look at the issues with the default installation and lack of encryption.
  prefs: []
  type: TYPE_NORMAL
- en: Unencrypted Connections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default dashboard Helm chart doesn’t encrypt connections from the Ingress
    controller, Kong by default, to the individual containers. Regardless of how you
    authenticate to the dashboard, this can be a serious security antipattern. As
    we’ve discussed, a bearer token can be used by anyone with network access, which
    means a lost token from an unencrypted network connection can lead to a serious
    breach. Even if using short-lived tokens, this is a worrying design choice. Whenever
    you build in security, it’s important to use a defense-in-depth approach, where
    you never have a single point of failure. In this case, the lack of encryption
    means that you could have that single point of failure by not having any fall
    back.
  prefs: []
  type: TYPE_NORMAL
- en: When you deploy your dashboard, you should enable encryption between the reverse
    proxy and the api container. We’ll walk through that in the next section. The
    web and metrics containers aren’t as important. The auth container doesn’t support
    any encryption, which is an issue, but with the right configuration can be bypassed.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to rely on a service mesh like Istio. If you enable
    a mesh, you could use that to rely on for encryption, but that’s an additional
    component to add.
  prefs: []
  type: TYPE_NORMAL
- en: Given how easy it is to create an internal certificate authority, there really
    isn’t any reason to not have these connections encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: While we’ve focussed on the security concerns of the default Kubernetes Dashboard
    installation, we’ll next move on to how to correctly deploy the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the dashboard with a reverse proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proxies are a common pattern in Kubernetes; there are proxies at every layer
    in a Kubernetes cluster. The proxy pattern is also used by most service mesh implementations
    on Kubernetes, creating sidecars that will intercept requests. The difference
    between the reverse proxy described here and these proxies is in their intent.
    Microservice proxies often do not carry a session, whereas web applications need
    a session to manage the state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the architecture of a Kubernetes Dashboard with
    a reverse proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B21165_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Kubernetes Dashboard with a reverse proxy'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reverse proxy shown in *Figure 10.3* performs four roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Routing:** Each of the containers used by the dashboard has its own path
    off of the host URL. The reverse proxy is responsible for routing requests to
    the correct container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication**: The reverse proxy intercepts unauthenticated requests (or
    stale sessions) and triggers the authentication process with an OpenID Connect
    identity provider to authenticate the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session management**: The Kubernetes Dashboard is a user-facing application.
    It should have the typical controls put in place to support session timeouts and
    revocation. Be wary of a reverse proxy that stores all session data in a cookie.
    These methods are difficult to revoke.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identity injection**: Once the proxy has authenticated a user, it needs to
    be able to inject an HTTP authorization header on each request that is a JWT identifying
    the logged-in user, is signed by the same OpenID Connect identity provider, and
    has the same issuer and recipient as the API server. The exception to this is
    using impersonation, which, as discussed in *Chapter 6*, *Integrating Authentication
    into Your Cluster*, injects specific headers into the requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What’s important is that when you configure your reverse proxy, it should:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Encrypt traffic to the api and the auth containers: These two containers are
    the ones that need the user’s token, so encryption is important. Since the auth
    container doesn’t support any encryption, you may want to just bypass this container
    entirely. We’ll explain this more in the next section when we talk about how OpenUnison
    integrates with the dashboard.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Manage and renew tokens: There’s no reason to use long-lived tokens with your
    reverse proxy. It should be able to renew them based on how long the token is
    good for.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Combining these means eliminating the Kong Ingress controller. It’s not needed
    anymore because your authenticating reverse proxy is doing the work.
  prefs: []
  type: TYPE_NORMAL
- en: The reverse proxy does not need to run on the cluster. Depending on your setup,
    it may be advantageous to do so, especially when utilizing impersonation with
    your cluster. When using impersonation, the reverse proxy uses a service account’s
    token, so it’s best for that token to never leave the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The focus of this chapter has been on the Kubernetes project’s dashboard. There
    are multiple options for dashboard functionality. Next, we’ll explore how these
    dashboards interact with the API server and how to evaluate their security.
  prefs: []
  type: TYPE_NORMAL
- en: Local dashboards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common theme among third-party dashboards is to run locally on your workstation
    and use a Kubernetes SDK to interact with the API server the same way `kubectl`
    would. These tools offer the benefit of not having to deploy additional infrastructure
    to secure them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio Code’s Kubernetes plugin is an example of a local application
    leveraging direct API server connections. When launching the plugin, Visual Studio
    Code accesses your current `kubectl` configuration and interacts with the API
    server using that configuration. It will even refresh an OpenID Connect token
    when it expires:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Visual Studio Code with the Kubernetes plugin ](img/B21165_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Visual Studio Code with the Kubernetes plugin'
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes plugin for Visual Studio Code is able to refresh its OpenID Connect
    token because it’s built with the client-go SDK, the same client libraries used
    by `kubectl`. When evaluating a client dashboard, make sure it works with your
    authentication type, even if it isn’t OpenID Connect. Many of the SDKs for Kubernetes
    don’t support OpenID Connect token refreshes. The Java and Python SDKs only recently
    (as of the published date of this book) began supporting the refresh of OpenID
    Connect tokens the way the client-go SDK does. When evaluating a local dashboard,
    make sure it’s able to leverage your short-lived tokens and can refresh them as
    needed, just like `kubectl` can.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no shortage of different dashboards in the Kubernetes ecosystem, all
    with their own spins on management. I don’t want to simply provide a list of these
    dashboards without giving you an in-depth review of their benefits and security
    impacts. Instead, let’s focus on what’s important when evaluating which dashboard
    you want to use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the dashboard is web-based:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it support OpenID Connect directly?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can it run behind a reverse proxy and accept both tokens and impersonation headers?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it require any permissions for its own service account? Do these permissions
    adhere to a least-privilege approach?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the dashboard is local:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the client SDK support OpenID Connect, with the ability to automatically
    refresh tokens as `kubectl` does, using the client-go SDK?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These are important evaluation questions not just for the Kubernetes Dashboard,
    but for dashboards that you may use for other cluster management applications.
    As an example, the **TektonCD dashboard**, which is a web application for managing
    your pipelines, requires deleting several RBAC bindings to make sure the dashboard
    has to use the user’s identity and can’t be co-opted to use its `ServiceAccount`
    identity.
  prefs: []
  type: TYPE_NORMAL
- en: Other cluster-level applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The introduction of this chapter discussed how a cluster is made up of several
    applications besides Kubernetes. Other applications will likely follow the same
    model as the dashboard for security, and the reverse proxy method is a better
    method for exposing those applications than `kubectl` port-forwarding, even when
    the application has no built-in security. Take the common Prometheus stack as
    an example. Grafana has support for user authentication, but Prometheus and Alert
    Manager do not.
  prefs: []
  type: TYPE_NORMAL
- en: How would you track who had access to these systems or when they were accessed
    using port-forwarding?
  prefs: []
  type: TYPE_NORMAL
- en: Using a reverse proxy, logs of each URL and the user that was authenticated
    to access the URL can be forwarded to a central log management system and analyzed
    by a **Security Information and Event Manager** (**SIEM**) providing an additional
    layer of visibility into a cluster’s usage.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the dashboard, using a reverse proxy with these applications provides
    a layered security approach. It offloads session management from the application
    in question and provides the capability to have enhanced authentication measures
    in place such as multi-factor authentication and session revocation. These benefits
    will lead to a more secure and easier-to-use cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now discuss how to integrate the dashboard with OpenUnison.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the dashboard with OpenUnison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topic of how OpenUnison injects identity headers using impersonation was
    covered in *Chapter 6*, *Integrating Authentication into Your Cluster*, but not
    how OpenUnison injects a user’s identity into the dashboard with an OpenID Connect
    integrated cluster. It worked, but it wasn’t explained. This section will use
    the OpenUnison implementation as an example of how to build a reverse proxy for
    the dashboard. Use the information in this section to get a better understanding
    of API security or to build your own solution for dashboard authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OpenUnison deployment comprises two integrated applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The OpenID Connect Identity Provider & Login Portal**: This application hosts
    the login process and the discovery URLs used by the API server to get the keys
    needed to validate an `id_token`. It also hosts the screens where you can obtain
    your token for `kubectl`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The dashboard**: A reverse proxy application that authenticates to the integrated
    OpenID Connect identity provider and injects the user’s `id_token` into each request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This diagram shows how the dashboard’s user interface interacts with its server-side
    component with a reverse proxy injecting the user’s `id_token`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B21165_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: OpenUnison integration with the dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard uses the same OpenID Connect identity provider as the API server
    but doesn’t use the `id_token` provided by it. Instead, OpenUnison has a plugin
    that will generate a new `id_token` independent of the identity provider with
    the user’s identity data in it. OpenUnison can do this because the key used to
    generate an `id_token` for the OpenID Connect identity provider, used by `kubectl`
    and the API server, is stored in OpenUnison. This is different from how you would
    integrate the dashboard with KeyCloak or Dex because you would need an additional
    component to authenticate users and maintain the `id_token` that is injected into
    the requests. This is often done with the OAuth2 proxy, which would need to be
    integrated with both your identity provider (i.e., Dex or KeyCloak), the dashboard,
    and your ingress controller. OpenUnison did all these steps for you.
  prefs: []
  type: TYPE_NORMAL
- en: A new, short-lived token is generated separately from the OpenID Connect session
    used with `kubectl`. This way, the token can be refreshed independently of a `kubectl`
    session. This process provides the benefits of a 1- to 2-minute token life with
    the convenience of a direct login process.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also notice that there is no auth container. The auth container’s only
    role is to return some JSON to tell the UI that the user is still authenticated.
    Since this container doesn’t support any encryption, we don’t bother calling it
    and instead generate the JSON directly in OpenUnison. This cuts out the need for
    the auth container and any issues that might arise from not having a TLS network
    connection with a bearer token.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an eye for security, you may point out that this method has a glaring
    single point of failure in the security model: a user’s credentials! An attacker
    generally just needs to ask for credentials in order to get them. This is often
    done via email in an attack called phishing, where an attacker sends a victim
    a link to a page that looks like their login page but really just collects credentials.
    This is why multi-factor authentication is so important for infrastructure systems.'
  prefs: []
  type: TYPE_NORMAL
- en: In a 2019 study, Google showed that multi-factor authentication stopped 99%
    of automated and phishing attacks ([https://security.googleblog.com/2019/05/new-research-how-effective-is-basic.xhtml](https://security.googleblog.com/2019/05/new-research-how-effective-is-basic.xhtml)).
    Adding multi-factor authentication to the identity provider OpenUnison authenticates
    against, or integrating it directly into OpenUnison, is one of the most effective
    ways to secure the dashboard and your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at what’s changed with the new release of the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: What’s changed in the Kubernetes Dashboard 7.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve spent this chapter talking about the 7.0 dashboard, but as is often true
    in enterprises the old 2.7 dashboard is still in use and probably will be for
    a while. The major difference between the 2.7 version and the 7.0 version that
    is coming is that the API layer and the frontend layer are broken up into multiple
    containers in 7.0\. This was done by the maintainers to make it easier to support
    more complex use cases, so keep an eye on this project!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the security of the Kubernetes Dashboard in detail.
    First, we walked through the architecture and how the dashboard passes your identity
    information on to the API server. We then explored how the dashboard gets compromised,
    and finally, we detailed how to correctly deploy the dashboard securely.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you can now provide a secure tool to your users. Many users
    prefer the simplicity of accessing the dashboard via a web browser. Adding multi-factor
    authentication adds an additional layer of security and peace of mind. When your
    security team questions the security of the dashboard, you’ll have the answers
    needed to satisfy their concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous three chapters focused on the security of the Kubernetes APIs.
    Next, in *Chapter 11*, *Extending Security Using Open Policy Agent*, we’ll explore
    securing the soft underbelly of every Kubernetes deployment: nodes!'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dashboard is insecure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How can the dashboard identify a user?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A token injected from a reverse proxy or provided by the login form
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Username and password
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: service account
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Multi-factor authentication
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the dashboard track the session state?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sessions are stored in etcd
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Sessions are stored in custom resource objects called `DashboardSession`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: There are no sessions
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If a token is uploaded, it’s encrypted and stored in the browser as a cookie
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When using a token, how often can the dashboard refresh it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once a minute
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Every thirty seconds
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When the token expires
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the best way to deploy the dashboard?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `kubectl` port-forward
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `kubectl` proxy
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: With a secret Ingress host
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Behind a reverse proxy
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The dashboard doesn’t support impersonation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: OpenUnison is the only reverse proxy that supports the dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a – There must be a token
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c – When your token expires, you’ll be asked for a new one
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d – The dashboard can’t refresh tokens
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d – Better security and usability
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
