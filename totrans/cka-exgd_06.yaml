- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will cover how Kubernetes authentication and authorization patterns
    work and dive into Kubernetes **role-based access control** (**RBAC**). We’ll
    also learn about managing the security of applications deployed on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Since most of the Kubernetes security-related content released prior to November
    2020 has gradually moved to the **Certified Kubernetes Security Specialist** (**CKS**)
    exam instead, this chapter will just cover the essentials to help you to learn
    about Kubernetes security. We’ll specifically focus on Kubernetes RBAC since it
    is close to 5% of the CKA exam content.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, a good understanding of the Kubernetes security fundamentals will
    be a great help for the CKA exam and prepare you for further development in the
    Kubernetes space.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Securing Kubernetes in layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes RBAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the security of Kubernetes applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, you will need to make sure that your local machine meets the
    technical requirements described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A compatible Linux host – we recommend a Debian-based Linux distribution such
    as Ubuntu 18.04 or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that your host machine has at least 2 GB of RAM, 2 CPU cores, and
    about 20 GB of free disk space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing Kubernetes in layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes security is a broad topic due to the sophistication of the platform.
    It includes secure Kubernetes nodes, networks, and Kubernetes objects such as
    Pods. The **Cloud Native Computing Foundation** (**CNCF**) defines Kubernetes
    security in layers, which they call the *four Cs* of cloud-native security, taking
    the topic of security beyond Kubernetes and its ecosystem. The four Cs stand for
    **Cloud**, **Cluster**, **Container**, and **Code**, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The different layers in Kubernetes ](img/Figure_6.1_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The different layers in Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding diagram, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Cloud** layer is based on the underlying infrastructure where the Kubernetes
    cluster is deployed – it is managed by the cloud provider when it is in the cloud
    or by the organization when it comes to a private data center.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Cluster** layer is more about securing the Kubernetes cluster components,
    ensuring each component is secured and conjured correctly. Looking back at [*Chapter
    1*](B18201_01.xhtml#_idTextAnchor015), *Kubernetes Overview*, will help you understand
    how those components work together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Container** layer includes container vulnerability scanning, hosted OS
    scaling, and container privileged users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Code** layer is focused on the application code. Different from traditional
    application security approaches, it now works with DevSecOps and vulnerability
    assessment tools. This layer is relevant but outside of the scope of Kubernetes
    security.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cloud-native security or, more specifically, Kubernetes security requires organizations
    to address each layer. In this chapter, we’ll focus on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes API security with an admission controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes authentication and authorization with RBAC, **Attribute-Based Access
    Control** (**ABAC**), and node authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the security of Kubernetes applications with security contexts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding topics are either part of cluster-layer or container-layer security,
    and they help us run our Kubernetes application securely. We’ll cover Kubernetes
    network security and dive deeper into network policies in [*Chapter 7*](B18201_07.xhtml#_idTextAnchor235),
    *Demystifying Kubernetes Networking*.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B18201_01.xhtml#_idTextAnchor015), *Kubernetes Overview*,
    we talked about a typical workflow of Kubernetes components collaborating with
    each other. In this workflow, when a request comes through the Kubernetes API
    server, it invokes an API call. This API request now needs to be authenticated
    and authorized by the API server before a request is made to a Kubernetes API
    resource. As a result, the request can either be *allowed* or *denied*. The authentication
    process can be depicted as in *Figure 6.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – API Kubernetes authentication  ](img/Figure_6.2_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – API Kubernetes authentication
  prefs: []
  type: TYPE_NORMAL
- en: 'You can refer to the following article to get an overview of how the Kubernetes
    authentication process works: [https://kubernetes.io/docs/reference/access-authn-authz/authentication/](https://kubernetes.io/docs/reference/access-authn-authz/authentication/).'
  prefs: []
  type: TYPE_NORMAL
- en: Before getting into authentication and authorization, let’s take a look at the
    user accounts and service accounts in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Service accounts versus user accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Kubernetes, we have a distinction between normal user accounts and service
    accounts managed by Kubernetes. An account represents an identity for a user or
    a service process. The main difference between a user account and a service account
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User accounts** are for normal human users. In Kubernetes, the RBAC subsystem
    is used to determine whether the user is authorized to perform a specific operation
    on a specific scope. We’ll look into this further in the *Kubernetes RBAC* section
    later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service accounts** are for services or processes running in a Pod in the
    Kubernetes cluster. The service accounts are users managed by the Kubernetes API.
    In Kubernetes, it is possible to use client certificates, bearer tokens, or even
    an authenticating proxy to authenticate API requests through an API server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll take a closer look at the following things from hereon:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes service accounts and how to work with them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to organize cluster access using `kubeconfig` as a Kubernetes user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to configure access to multiple clusters as a Kubernetes user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at the Kubernetes service account first.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes service accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in the previous chapter, we created a new Pod with `kubectl`, although
    there is a default service account in the `default` namespace, which the Pod was
    actually automatically assigned to. Now, let’s have a look at how to work with
    a service account in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Managing service accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the following command to get the current service account in the
    `default` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can simply use the shortcut command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will return the default service account in the `default` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The service account is a namespaced resource – you can use the following command
    to check out all the service accounts in the current cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the complete command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding commands will list the service account information
    by namespace, similar to the following in *Figure 6.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The service account information by namespace ](img/Figure_6.3_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – The service account information by namespace
  prefs: []
  type: TYPE_NORMAL
- en: This also means we can get the service account information by namespace using
    the `kubectl get sa` command and then by specifying the `-n` flag with `namespace
    name` to get the service account with that particular namespace. For example,
    using `kubectl get sa -n` with `kube-system` will only return the service account
    in the `kube-system` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The kubectl create sa command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `kubectl create` command to create a new service account, the
    following being an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output will show that the service account is created successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create the service account in a different namespace using the `kubectl
    create` command by specifying the `-n` flag. Additionally, we also need to make
    sure that the namespace exists prior to creating a service account in that namespace.
    The following is an example of using a `kubectl create` command to create a service
    account named `melonsa` in a namespace called `melon-ns`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output displays that you have created the service account successfully.
    You can also use the following command to check that the service account has just
    been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output lists the service account and how long it’s been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, if you want to check out the service account in another namespace,
    you can use the `kubectl get sa <service account name>` command and then add the
    `-n` flag, for example, `k get sa melonsa -n melon-ns`.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a service account to a Pod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The purpose of having a service account is to provide an identity to serve
    the process running in the Pod. To determine the service account that a Pod will
    use, you can specify a `serviceAccountName` field in the Pod YAML specification
    called `sa-pod.yaml`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Then, when we use the `kubectl apply -f sa-pod.yaml` command to deploy this
    YAML file, we’ll be able to see a Pod spinning up.
  prefs: []
  type: TYPE_NORMAL
- en: The kubectl delete sa command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can delete a service account using the `kubectl delete sa <account name
    >` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output comes back showing that the service account was deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, you now have a better idea of how to work with a Kubernetes service
    account using what you learned in this section. Now, let’s take a look at how
    to organize the cluster access using `kubeconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the cluster access using kubeconfig
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a Kubernetes user, when you deploy the Kubernetes cluster with `kubeadm`,
    you will find a file called `config` in the `$HOME/.kube` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In other cases, this `kubeconfig` file can be set up as a KUBECONFIG environment
    variable or a `--kubeconfig` flag. You can find detailed instructions in the official
    documentation: [https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/](https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/).'
  prefs: []
  type: TYPE_NORMAL
- en: The `kubeconfig` files help organize information clusters, users, and namespaces.
    From the `kubectl` utility point of view, it reads `kubeconfig` files to locate
    the information of the cluster and communicate with the API server of that Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a `kubeconfig` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see `config` by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The kubectl config view output ](img/Figure_6.4_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – The kubectl config view output
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `kubectl config` command to display `current-context`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned output will be the current context – in my case, it is `minikube`.
    You may notice that it is the same as `current-context` shown in the aforementioned
    `config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To know more about how to organize the cluster access using `kubeconfig`, refer
    to the official article to learn more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/)'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring access to multiple clusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a Kubernetes user, when it comes to multiple clusters, we can also use the
    `kubectl config` command to configure the current context to switch between different
    Kubernetes clusters. To find all the commands provided by `kubectl config`, use
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of how `kubeconfig` contains the access information
    of two different Kubernetes clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use the `kubectl config current-context` command to see the cluster
    that I am working on and it would be displayed as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output indicates that I am on a Kubernetes cluster called `gke-cluster`
    and that I am using the following command to switch my default context to another
    Kubernetes cluster called `akscluster`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use the `kubectl config current-context` command to check my current
    working Kubernetes cluster and it would be displayed as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Switching context is an important technique that you can apply during your actual
    CKA exam and it’s important to perform tasks in the targeting Kubernetes cluster
    so that you’ll be scored accurately. It also comes in handy in your real life
    working as a Kubernetes administrator, as often, you’ll be working on multiple
    Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To know more about how to configure access to multiple clusters, check the
    official article: [https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/](https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/)'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Kubernetes, a request must be authenticated before it can be authorized with
    permissions granted to access the Kubernetes cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four authorization modes in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RBAC authorization**: Kubernetes RBAC is more about regulating access to
    Kubernetes resources according to the roles with specific permissions to perform
    a specific task, such as reading, creating, or modifying through an API request.
    We’ll focus on Kubernetes RBAC in this section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubelets agent`. This is a special - purpose authorization mode not covered
    in the CKA exam. You can check out the official documentation about node authorization
    to find out more: [https://kubernetes.io/docs/reference/access-authn-authz/node/](https://kubernetes.io/docs/reference/access-authn-authz/node/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ABAC authorization**: ABAC is an access control granted to users by policies
    and attributes such as user attributes, resource attributes, and objects. This
    topic is not covered in the current CKA exam. If you want to learn more about
    using the ABAC mode, you can refer to the official article: [https://kubernetes.io/docs/reference/access-authn-authz/abac/](https://kubernetes.io/docs/reference/access-authn-authz/abac/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Webhook authorization**: Webhook authorization through WebHooks is an HTTP
    POST triggered by an event. An example of this is that the Webhook will react
    to a URL when triggered by certain actions. This topic is not covered in the current
    CKA exam. You can explore the following article if you want to know more about
    it: [https://kubernetes.io/docs/reference/access-authn-authz/webhook/](https://kubernetes.io/docs/reference/access-authn-authz/webhook/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at what the key areas covered in the CKA exam are, starting
    with Kubernetes RBAC.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes RBAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes RBAC aims to regulate access to Kubernetes resources according to
    the roles with specific permissions to perform a specific task.
  prefs: []
  type: TYPE_NORMAL
- en: Once specified, RBAC checks the `rbac.authorization.k8s.io` API group membership
    to see whether it is allowed through the Kubernetes API.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the different Roles and RoleBindings in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Roles versus ClusterRoles and their RoleBindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Kubernetes, we have Roles and ClusterRoles. A Kubernetes RBAC Role or ClusterRole
    represents a role with a set of permissions. In a nutshell, they differ by the
    scope of these permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Role** represents permissions within a particular namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **ClusterRole** represents permissions within the cluster – it could be cluster-wide,
    across multiple namespaces, or individual namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With Roles and ClusterRoles, we have the concept of **RoleBinding** and **ClusterRoleBinding**.
    The bindings bind the role to a list of subjects such as users, groups, or service
    accounts, as can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Kubernetes RBAC  ](img/Figure_6.5_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Kubernetes RBAC
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a new role called `dev-user` in a namespace called `dev`. We can
    use the following command to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command is the same as the following YAML definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use the `kubectl get role` command to check the role that we have
    just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to create the RoleBinding to bind this role to the subjects as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could also use the following YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s define a new ClusterRole called `secret-reader` – note that the ClusterRole
    is not namespaced. We could use the following YAML definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to create the RoleBinding to bind this role to the subjects,
    as shown in the following YAML definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the following command to get all the roles across all the namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the following command to get all the RoleBindings across all the
    namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Knowing the ways that Roles and RoleBindings work in Kubernetes, let’s now take
    a look at how to implement your own Kubernetes RBAC Roles and RoleBindings.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Kubernetes RBAC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To enable RBAC, set `apiserver –authorization-mode` to RBAC, which defaults
    to `AlwaysAllow`. The other possible values include `node`, `ABAC`, `Always deny,`
    and `webhook`. In the following command, we’re showing an example of setting it
    to use Kubernetes RBAC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To know more about how to set up authorization mode, visit the following link:
    [https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new deployment using our current context, which is
    `minikube`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, switch to the context for `dev-user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As our `dev-user` only has `list` and `get` permissions, let’s try to use this
    profile to delete the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have learned how to manage our own Kubernetes RBAC roles, let’s
    take a look at how to manage the security of Kubernetes applications.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the security of Kubernetes applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `securityContext` field defines the privilege and access control settings
    for a Pod in the Pod YAML specification. We need to configure the security context
    in case a Pod or container needs to interact with the security mechanisms of the
    underlying operating system unconventionally, and in this section, we’ll introduce
    how to configure a security context for a Pod or container.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a part of your prep work, you can create a new user and a new group as shown
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now log in to the worker node and create a new `.txt` file called `message.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, you’ll see the message that we input from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to adjust the permission to limit the permission for testing purposes,
    which is shown as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we could deploy a new Pod in our current Kubernetes cluster to test
    it out. The `securityContext` field is defined as part of a Pod’s YAML spec called
    `pod-permission.yaml`. With a section called `securityContext`, we can specify
    the security permissions information, as in the following YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding YAML definition file, the `runAsUser` field means that for
    any container in this Pod, all processes run with a user ID of `2000`. The `fsGroup`
    field is `2000`, which means that all the processes of the container are also
    part of the supplementary group, `ID 2000`. The owner for volume/message and any
    files created in that volume will be the `ID 2000` group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and deploy this YAML file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we’ll see the Pod is spinning up but will quickly encounter the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding example, we can see the Pod is `BackOff` due to the lack
    of permission. Now, let’s pull a similar example to see whether we can fix this.
    Let’s configure a YAML file with a similar configuration to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s deploy this using the following YAML example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see this example is now up and running in my local Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s get inside this running pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we’ll get into the interactive shell, input `id`, and we’ll get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: From the output, we can see that `uid` is `1000`, the same as the `runAsUser`
    field; the `gid` is `3000`, the same as the `runAsGroup` field; and the `fsGroup`
    is `2000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the security context, check out the official documentation
    here: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter gave an overview of Kubernetes security with a focus on three key
    topics about container security, RBAC, and the security context. You can use this
    chapter to assist you with laying the foundations for your CKS exam. With the
    addition of the next chapter, *Demystifying Kubernetes Networking*, you will get
    a complete view of working with Kubernetes networking security-related concepts
    and practice examples to help in your daily work as a Kubernetes administrator,
    and this will all cover 20% of the CKA exam content. Let’s stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: Mock CKA scenario-based practice test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have two virtual machines, `master-0` and `worker-0` – please complete the
    following mock scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new service account named `packt-sa` in a new namespace called `packt-ns`.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a Role named `packtrole` and bind it with the RoleBinding `packt-clusterbinding`.
    Map the `packt-sa` service account with `list` and `get` permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new pod named `packt-pod` with the `busybox:1.28` image in the `packt-ns`
    namespace. Expose port `80`. Then, assign the `packt-sa` service account to the
    Pod.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the scenario resolutions in [*Appendix*](B18201_Appendix_A.xhtml#_idTextAnchor386)
    *- Mock CKA scenario-based practice test resolutions* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: FAQs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Where can I find the latest updates about Kubernetes security while working
    with Kubernetes?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Kubernetes Security **Special Interest Group** (**SIG**) has a GitHub repository,
    which you can find here: [https://github.com/kubernetes/community/tree/master/sig-security](https://github.com/kubernetes/community/tree/master/sig-security).'
  prefs: []
  type: TYPE_NORMAL
- en: '*What is the recommended Kubernetes official article for configuring the ephemeral
    storage?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I recommend bookmarking the official documentation about Kubernetes RBAC, which
    you can find here: [https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/).'
  prefs: []
  type: TYPE_NORMAL
