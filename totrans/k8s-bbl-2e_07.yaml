- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuring Your Pods Using ConfigMaps and Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters introduced you to launching application containers using
    Kubernetes. You now know that whenever you need to launch a container on Kubernetes,
    you will need to do so using Pods. This was the key concept for you to understand
    and assimilate. Kubernetes is a complex system managed through a RESTful API.
    The core component handling this is the Kubernetes API server, which provides
    the primary interface to interact with the cluster. When users create Kubernetes
    objects, such as Pods, through this API, the system responds by provisioning the
    necessary resources on cluster nodes. Among these resources, a Pod stands out,
    as its creation on a Kubernetes node leads to the instantiation of application
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll learn about two new Kubernetes objects: **ConfigMaps**
    and **Secrets**. Kubernetes leverages ConfigMaps and Secrets to decouple application
    configuration from the code itself. These objects provide a mechanism to manage
    configuration values independently, enhancing application portability and security.
    ConfigMaps store non-sensitive data as key-value pairs, while Secrets handle sensitive
    information like passwords or API keys. Both can be injected into Pods as environment
    variables or mounted as volumes, allowing applications to dynamically access configuration
    without hardcoding values. By separating configuration from an application, you
    create more flexible, resilient, and secure deployments within the Kubernetes
    ecosystem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the main topics that we’re going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what ConfigMaps and Secrets are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring your Pods using ConfigMaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing sensitive configuration with the Secret object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Kubernetes cluster (local or cloud-based, although this is not important)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working `kubectl` CLI configured to communicate with the Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can get these two prerequisites by following *Chapter 2*, *Kubernetes Architecture
    – From Container Images to Running Pods*, and *Chapter 3*, *Installing Your First
    Kubernetes Cluster*, to get a working Kubernetes cluster and a properly configured
    `kubectl` client, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the latest code samples for this chapter from the official
    GitHub repository: [https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what ConfigMaps and Secrets are
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes environments are dynamic and constantly changing. This makes managing
    application configurations a complex challenge. Traditional methods often fall
    short in keeping up with the rapid pace of cloud-native development.
  prefs: []
  type: TYPE_NORMAL
- en: To address this, Kubernetes provides ConfigMaps and Secrets, specialized ways
    to handle different types of configuration data. By separating configuration from
    the application code, these resources significantly improve application portability,
    security, and manageability.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we’ll dive into the details of ConfigMaps and Secrets,
    exploring how they work and how to best utilize them in your Kubernetes deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling your application and your configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Containers are immutable by nature, meaning they cannot be changed once created.
    This presents a challenge when managing configuration. Embedding configuration
    within a container image requires rebuilding the entire image for every configuration
    change, a time-consuming and inefficient process. Relying solely on environment
    variables or command-line arguments for configuration can also be cumbersome,
    especially for complex setups, and doesn’t guarantee persistence across container
    restarts. These limitations highlight the need for a more effective configuration
    management strategy in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: When we use Kubernetes, we want our applications to be as portable as possible.
    A good way to achieve this is to decouple the application from its configuration.
    Back in the old days, configuration and application were the same thing; since
    the application code was designed to work only on one environment, configuration
    values were often bundled within the application code itself, so the configuration
    and application code were tightly coupled.
  prefs: []
  type: TYPE_NORMAL
- en: Having both application code and configuration values treated as the same thing
    reduces the portability of an application. Now, things have changed a lot, and
    we must be able to update the application configuration because we want to make
    our application as portable as possible, enabling us to deploy applications in
    multiple environments flawlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following problem:'
  prefs: []
  type: TYPE_NORMAL
- en: You deploy a Java application to the development environment for testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the tests, the app is ready for production, and you need to deploy it.
    However, the MySQL endpoint for production is different from the one in development.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two possibilities here:'
  prefs: []
  type: TYPE_NORMAL
- en: The configuration and application code are not decoupled, and the MySQL is hardcoded
    and bundled within the application code; you are stuck and need to rebuild the
    whole app after editing the application code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration and application code are decoupled. That’s good news for you,
    as you can simply override the MySQL endpoint as you deploy it to production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s the key to the concept of portability – the application code should be
    independent of the infrastructure it is running on. The best way to achieve this
    is to decouple the application code from its configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the following image, we have a common application container image and different
    configurations for the different environments.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Application configuration decoupled'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some typical examples of the types of configuration values you
    should decouple from an app:'
  prefs: []
  type: TYPE_NORMAL
- en: API keys to access an Amazon S3 bucket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The password of the MySQL server used by your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The endpoint of a Redis cluster used by your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pre-computed values such as JWT token private keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these values are likely to change from one environment to another, and
    the applications that are launched in your Pods should be able to load a different
    configuration, depending on the environment they are launched on. This is why
    we will seek to systematically maintain a barrier between our applications and
    the configurations they consume. Doing this allows us to treat them as two completely
    different entities in our Kubernetes cluster. The best way to achieve this is
    by considering our application and its configurations as two different entities.
  prefs: []
  type: TYPE_NORMAL
- en: This is why Kubernetes suggests using the ConfigMaps and Secrets objects, which
    are designed to carry your configuration data. Then, you will need to attach these
    ConfigMaps and Secrets when you create your Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Please avoid including your configuration values as part of your container images,
    such as Docker images. Your Dockerfile (or Containerfile for Podman) should build
    your application but not configure it. By including the container configuration
    at build time, you create a strong relationship between your application and how
    it’s configured, which reduces the portability of your container to different
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMaps are meant to hold non-sensitive configuration values, whereas Secrets
    are globally the same but are meant to hold sensitive configuration values, such
    as database passwords, API keys, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: So, you can imagine a ConfigMap and Secret for each environment and for each
    application, which will contain the parameters that the application needs to function
    in a specific context and environment. The key point is that ConfigMaps and Secrets
    serve as storage mechanisms for key/value pairs, for configuration data within
    a Kubernetes cluster. These key/value pairs can contain plain values called `literals`
    or full configuration files, such as `YAML`, `TOML`, and so on. Then, on Pod creation,
    you can pick the name of a ConfigMap or a Secret and link it to your Pod so that
    the configuration values are exposed to the containers running into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You always proceed in this order to guarantee that the configuration data is
    available when the Pod starts:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a ConfigMap or a Secret with the configuration values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Pod referencing the ConfigMap or Secret.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By adopting this approach, you enhance your application’s portability and maintainability,
    aligning with common DevOps best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explained why it is important to decouple application code and
    configuration values, it is time to explain why and how to achieve this in a Kubernetes-friendly
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how Pods consume ConfigMaps and Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the specifics of ConfigMaps and Secrets, let’s examine traditional
    methods of managing configuration in containerized environments. Outside of Kubernetes,
    modern containerized applications consume their configuration in multiple ways:'
  prefs: []
  type: TYPE_NORMAL
- en: As OS environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is because overriding an environment variable is super-easy with Docker
    or Podman, and all programming languages offer functions to easily read environment
    variables. Configuration files can easily be shared and mounted as volumes between
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: IMPORTANT
  prefs: []
  type: TYPE_NORMAL
- en: While ConfigMaps and Secrets are the primary methods for managing configuration
    in Kubernetes, there are alternative approaches. Command-line arguments can be
    used to pass configuration directly to containers, but this method is less flexible
    and secure than ConfigMaps and Secrets. Directly accessing the Kubernetes API
    to fetch configuration is generally discouraged, due to security risks and added
    complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the Kubernetes world, ConfigMaps and Secrets follow these two methods.
    Once created in your Kubernetes cluster, ConfigMaps can be consumed in one of
    two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Included as environment variables in the container running in your Pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounted as Kubernetes volumes, just like any other volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can choose to inject one value from a ConfigMap or a Secret as an environment
    variable, or inject all the values from a ConfigMap or a Secret as environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: IMPORTANT
  prefs: []
  type: TYPE_NORMAL
- en: Using environment variables to expose Secrets is strongly discouraged due to
    potential security risks and the possibility of value truncation. Consider using
    the volume approach with file-based Secrets to leverage kubelet caching for dynamic
    updates and improved security.
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMap and Secrets can also behave as volume mounts. When you mount a ConfigMap
    as a volume, you can inject all the values it contains in a directory into your
    container. If you store the full configuration files in your ConfigMap, using
    this feature to override a configuration directory becomes incredibly easy.
  prefs: []
  type: TYPE_NORMAL
- en: After this introduction to ConfigMap and Secrets, you should now understand
    why they are so important when it comes to configuring an application. Mastering
    them is crucial if you intend to work with Kubernetes cleanly and solidly. As
    we mentioned earlier in this chapter, ConfigMaps are used to store *unsecured*
    configuration values, whereas Secrets are used for more sensitive configuration
    data, such as hashes or database passwords.
  prefs: []
  type: TYPE_NORMAL
- en: The following table shows the high-level differences between ConfigMaps and
    Secrets in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **ConfigMaps** | **Secrets** |'
  prefs: []
  type: TYPE_TB
- en: '| Purpose | Store non-sensitive configuration data | Store sensitive information
    |'
  prefs: []
  type: TYPE_TB
- en: '| Data format | Plain text | Base64-encoded |'
  prefs: []
  type: TYPE_TB
- en: '| Security | Less secure | More secure |'
  prefs: []
  type: TYPE_TB
- en: '| Common use cases | Application configuration, environment variables, and
    command-line arguments | Passwords, API keys, SSH keys, and TLS certificates |'
  prefs: []
  type: TYPE_TB
- en: '| Handling sensitive data | Not recommended | Strongly recommended |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.1: Differences between ConfigMaps and Secrets'
  prefs: []
  type: TYPE_NORMAL
- en: Since the ConfigMaps and Secrets don’t behave the same, let’s look at them separately.
    First, we are going to discover how ConfigMaps work. We will discover Secrets
    after.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your Pods using ConfigMaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to list, create, delete, and read ConfigMaps.
    Also, we’ll learn how to attach them to our Pods so that their values are injected
    into the Pods, in the form of environment variables or volumes.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will learn how to list, create, and manage ConfigMaps
    in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Listing ConfigMaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Listing the ConfigMaps that were created in your cluster is fairly straightforward
    and can be accomplished using `kubectl`, just like any other object in Kubernetes.
    You can do this by using the full resource name, which is `configmaps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the shorter alias, which is `cm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Both of these commands have the same effect. When executed, `kubectl` might
    display a few default ConfigMaps or issue an error, stating that no ConfigMaps
    were found. This discrepancy arises because certain cloud services generate default
    ConfigMaps for internal processes, while others do not. The presence or absence
    of these default ConfigMaps depends on the environment in which your Kubernetes
    cluster is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding output, there are multiple ConfigMaps in the
    default namespace and Kubernetes-managed namespaces, which are created during
    the cluster deployment. Now, let’s learn how to create a new ConfigMap in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ConfigMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like other Kubernetes objects, ConfigMaps can be created imperatively or declaratively.
    You can decide to create an empty ConfigMap and then add values to it or create
    a ConfigMap directly with initial values. The following command will create an
    empty ConfigMap, called `my-first-configmap`, via the imperative method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this command has been executed, you can type the `kubectl get cm` command
    once again to see your new `configmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are going to create a new empty ConfigMap, but this time, we are going
    to create it with the declarative method. This way, we’ll have to create a YAML
    file and apply it through `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following content should be placed in a file called `~/my-second-configmap.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this file has been created, you can apply it to your Kubernetes cluster
    using the `kubectl apply -f` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can type the `kubectl get cm` command once more to see your new `configmap`
    added next to the one you created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the output of the `kubectl get cm` command also returns the
    number of keys that each ConfigMap contains in the `DATA` column. For now, it’s
    zero, but in the following examples, you’ll see that we can fill a `configmap`
    when it’s created, so `DATA` will reflect the number of keys we put in `configmap`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ConfigMap from literal values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having an empty ConfigMap is quite useless, so let’s learn how to create a
    ConfigMap with values inside it. Let’s do this imperatively: adding the `–from-literal`
    flag to the `kubectl create cm` command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are going to create a ConfigMap called `my-third-configmap`, with
    a key named `color` and its value set to `blue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, be aware that you can create a ConfigMap with multiple parameters; you
    just need to add as much configuration data as you want to `configmap` by chaining
    as many from-literals as you need in your command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a ConfigMap with three configuration values inside it. Now,
    you can list your ConfigMaps once more using this command. You should see the
    few additional ones you just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that the `DATA` column in the return of `kubectl get cm` now reflects
    the number of configuration values inside each `configmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can also see the details of the ConfigMap (or any other objects) by displaying
    a well-formatted output in the YAML or JSON format, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This approach also facilitates object backup in the YAML or JSON formats, aligning
    with **Configuration as Code** (**CaC**) and **Infrastructure as Code** (**IaC**)
    best practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is also possible to create the same ConfigMap declaratively. Here is
    the declarative YAML configuration file that is ready to be applied against the
    cluster. Please note the new data YAML key, which contains all the configuration
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have created the file, you can create the ConfigMap using the `kubectl
    apply` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A new ConfigMap object will be created based on the `my-fifth-configmap.yam`l
    file, which includes your data as per the YAML definition.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to store entire configuration files inside a ConfigMap
    in the next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Storing entire configuration files in a ConfigMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned earlier, it’s also possible to store complete files inside a
    ConfigMap – you are not restricted to literal values. The trick is to give the
    path of a file stored in your filesystem to the `kubectl` command line. The content
    of the file will then be taken by `kubectl` and used to populate a parameter in
    `configmap`.
  prefs: []
  type: TYPE_NORMAL
- en: Having the content of a configuration file stored in a ConfigMap is super-useful
    because you’ll be able to mount your ConfigMaps in your Pods, just like you can
    do with volumes.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that you can mix literal values and files inside a ConfigMap.
    Literal values are meant to be short strings, whereas files are just treated as
    longer strings; they are not two different data types.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen such a sample ConfigMap in *Chapter 5*, in the *Sidecar
    multi-container Pod – an example* section, where we stored the Fluentd configuration
    content inside a ConfigMap as file content.
  prefs: []
  type: TYPE_NORMAL
- en: Here, a sixth ConfigMap is created with a literal value, just like it was previously,
    but now, we are also going to store the content of a file in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a file called `configfile.txt` in the `$HOME/configfile.txt` location
    with arbitrary content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, that configuration file has the `.txt` extension, but it could be a `.yaml`,
    `.toml`, `.rb`, or any other configuration format that your application can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to import that file into a ConfigMap, so let’s create a brand-new
    ConfigMap to demonstrate this. You can do this using the `--from-file` flag, which
    can be used together with the `--from-literal` flag in the same command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run the `kubectl get cm` command once more to make sure that our sixth
    `configmap` is created. The command will show that it contains two configuration
    values – in our case, the one created from a literal and the other one created
    from the content of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `my-sixth-configmap` contains two pieces of data: the literal
    and the file.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s create a seventh ConfigMap. Just like the sixth one, it’s going to
    contain a literal and a file, but this time, we’re going to create it declaratively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The YAML format allows you to use multiple lines with the | symbol. We’re using
    this syntax as part of our declaration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s apply this YAML file to create our `configmap` with the `kubectl apply`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s list the ConfigMaps in our cluster using `kubectl get cm` to make sure
    our seventh `configmap` has been created and contains two values. So let’s run
    the `kubectl get cm` command once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s discover the last possible way to create a ConfigMap – that is, from
    an `env` file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ConfigMap from an env file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you might guess, you can create a ConfigMap from an `env` file imperatively
    using the `--from-env-file` flag.
  prefs: []
  type: TYPE_NORMAL
- en: An `env` file is a `key=value` format file where each key is separated by a
    line break. This is a configuration format that’s used by some applications, so
    Kubernetes introduced a way to generate a ConfigMap from an existing `env` file.
    This is especially useful if you have an already existing application that you
    want to migrate into Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical `env` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: By convention, `env` files are named `.env`, but it’s not mandatory. So long
    as the file is formatted correctly, Kubernetes will be able to generate a ConfigMap
    based on the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command to import the configuration in the `env`
    file as a ConfigMap into your Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let’s list the ConfigMaps in our cluster to check that our new ConfigMap
    was created with three configuration values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the new `configmap` is now available in the cluster, and it
    was created with the three parameters that were present in the `env` file. That’s
    a solid way to import your `env` files into Kubernetes ConfigMaps.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `ConfigMaps` are not meant to contain sensitive values. Data in
    ConfigMaps are not encoded, and that’s why you can view them with just a `kubectl
    describe cm` command. For anything that requires privacy, you’ll have to use the
    `Secret` object and not the `ConfigMap` one. It’s important to note that while
    `Secrets` themselves are not inherently encrypted by default, they are stored
    in the base64 format, offering a basic level of obfuscation. Additionally, with
    Kubernetes versions 1.27 and later, you can leverage Kubernetes **Key Management
    System** (**KMS**) plugin providers to encrypt data within both Secrets and ConfigMaps.
    This provides a more robust security layer for sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discover how to read the values inside a ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: Reading values inside a ConfigMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we’ve only listed the ConfigMaps to see the number of keys in them.
    Let’s take this a little bit further: you can read actual data inside a ConfigMap,
    not just count the number of ConfigMaps. This is useful if you want to debug a
    ConfigMap or if you’re not confident about what kind of data is stored in them.'
  prefs: []
  type: TYPE_NORMAL
- en: The data in a ConfigMap is not meant to be sensitive, so you can read and retrieve
    it easily from `kubectl`; it will be displayed in the terminal’s output.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read the value in a ConfigMap with the `kubectl describe` command.
    We will run this command against the `my-fourth-configmap` ConfigMap, since it’s
    the one that contains the most data. The output is quite big, but as you can see,
    the two pieces of configuration data are displayed clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `kubectl describe cm` command returns these kinds of results. Expect to
    receive results similar to this one and not results in a computer-friendly format,
    such as JSON or YAML.
  prefs: []
  type: TYPE_NORMAL
- en: As the data is displayed clearly in the terminal output, keep in mind that any
    user of the Kubernetes cluster (with access to this ConfigMap) will be able to
    retrieve this data directly by typing the `kubectl describe cm` command, so be
    careful to not store any sensitive value in a ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discover how we can inject ConfigMap data into running Pods as environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Linking ConfigMaps as environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’re going to bring our ConfigMaps to life by linking them
    to Pods. First, we will focus on injecting ConfigMaps as environment variables.
    Here, we want the environment variables of a container within a Pod to come from
    the values of a ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Injecting one or more given values in a given ConfigMap**: You can set the
    value of an environment variable based on the parameters contained in one or multiple
    ConfigMaps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Injecting all the values contained in a given ConfigMap**: You take one ConfigMap
    and inject all the values it contains into an environment at once. This way is
    good if you are creating one ConfigMap per Pod specification or application so
    that each app has a ConfigMap ready to be deployed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that it’s impossible to link a ConfigMap to a Pod with the `kubectl`
    `imperative` method. The reason is that it’s impossible to create a Pod referencing
    a ConfigMap directly from the `kubectl run` command. You will have to write declarative
    YAML files to use your ConfigMaps in your Pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we created a ConfigMap called `my-third-configmap`
    that contains a parameter called `color`, with a value of `blue`. In this example,
    we will create a Pod with the `quay.io/iamgini/my-flask-app:1.0` image, and we
    will link `my-third-configmap` to the Pod so that the flask application container
    is created with an environment variable called `COLOR`, with a value set to `blue`,
    according to what we have in the ConfigMap. Here is the YAML manifest to achieve
    that. Pay attention to the `env:` key in the `container` spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create this Pod using the `kubectl apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our application Pod has been created, let’s launch the `env` command
    inside the container to list all the environment variables that are available
    in the container. As you may have guessed, we will issue the `env` Linux command
    in this specific container by calling the `kubectl exec` command. Here is the
    command and the output to expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You should see the `COLOR` environment variable in the output if your ConfigMap
    has been linked to your Pod correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check the application deployed by exposing the Pod using a service,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Let’s test the application over a browser using the `kubectl port-forward` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start a `port-forward` to test the application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Using kubectl port-forward
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`kubectl port-forward` creates a secure tunnel between your local machine and
    a specific Pod within a Kubernetes cluster. This allows you to access and interact
    with applications running inside the Pod as if they were running locally. It’s
    a valuable tool for debugging, testing, and development, providing direct access
    to services without external exposure.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: While NodePort services are designed for external access, they can also be used
    in minikube environments. To access your application externally in this case,
    use the `minikube service` command to get the NodePort and corresponding IP address.
    For instance, the minikube service `--url flask-pod-with-configmap` might output
    `http://192.168.49.2:31997`, allowing you to access your Flask application at
    this URL.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can access the flask application over a web browser and can see the
    background with a BLUE color, as it was configured in the ConfigMap as `COLOR=blue`.
    You can change the value of `COLOR` in the ConfigMap and recreate the `flask-pod-with-configmap`
    Pod to see the changes.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about Kubernetes services and DNS in *Chapter 8*, *Exposing
    Your Pods with Services*.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the `kubectl port-forward` will continue serving the forward
    until you end the command (e.g., by pressing the *Ctrl + C* keys).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to discover the second way of injecting ConfigMaps as environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this demo, we will link another ConfigMap, the one called `my-fourth-configmap`.
    This time, we don’t want to retrieve a single value in this ConfigMap but all
    the values inside of it instead. Here is the updated YAML Pod manifest. This time,
    we don’t use individual `env` keys but an `envFrom` key in our `container` spec
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the manifest file is ready, you can recreate the NGINX Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s run the `env` command once more in the `nginx` container, using
    the `kubectl exec` command to list the environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that the three parameters `– color`, `version`, and `environment` – that
    were declared in the `my-fourth-configmap` have been set as environment variables
    in the container, but this time, you don’t have control over how the environment
    variables are named in the container. Their names are directly inherited from
    the parameter key names in the ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to learn how to mount a ConfigMap as a volume in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a ConfigMap as a volume mount
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, we created two ConfigMaps that store dummy configuration
    files. `kubectl` allows you to mount a ConfigMap inside a Pod as a volume. This
    is especially useful when the ConfigMap contains the content of a file that you
    want to inject into a container’s filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like when we inject environment variables, we need to do this imperatively
    using a YAML manifest file. Here, we are going to mount a ConfigMap called `my-sixth-configmap`
    as a volume mount to a new Pod, `flask-pod-with-configmap-volume`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have declared a volume named `configuration volume` at the same level
    as the containers, and we have told Kubernetes that this volume was built from
    a ConfigMap. The referenced ConfigMap (here, `my-sixth-configmap`) must be present
    in the cluster when we apply this file. Then, at the container level, we mounted
    the volume we declared earlier on `path /etc/conf:`. The parameter in the ConfigMap
    should be present at the specified location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s apply this file to create a new ConfigMap, with the volume attached to
    our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `ls` command in the container to make sure that the directory has been
    mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, the directory has been successfully mounted, and both parameters that
    were created in the ConfigMap are available in the directory as plain files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the `cat` command to make sure that both files hold the correct values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Good! Both files contain the values that were declared earlier when we created
    the ConfigMap! For example, you could store a virtual host NGINX configuration
    file and have it mounted to the proper directory, allowing NGINX to serve your
    website based on the configuration values hosted in a ConfigMap. That’s how you
    can override the default configuration and cleanly manage your app in Kubernetes.
    Now, you have a really strong and consistent interface to manage and configure
    the containers running in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to delete and update a ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a ConfigMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deleting a ConfigMap is very easy. However, be aware that you can delete a
    ConfigMap even if its values are used by a container. Once the Pod has been launched,
    it’s independent of the `configmap` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of whether the ConfigMap’s values are used by the container, it will
    be deleted as soon as this command is entered. Note that the ConfigMap cannot
    be recovered, so please think twice before removing a ConfigMap you have created
    imperatively, since you won’t be able to recreate it. Unlike declaratively created
    ConfigMaps, its content is not stored in any YAML file. But as we learned earlier,
    it is possible to collect the content of such resources in the YAML format by
    formatting the `kubectl get` commands – for example, `kubectl get cm <configmap-name>
    -o YAML > my-first-configmap.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we recommend that you are careful when removing your ConfigMaps, especially
    if you delete ConfigMaps that are used by running Pods. If your Pod were to crash,
    you wouldn’t be able to relaunch it without updating the manifest file; the Pods
    would look for the missing ConfigMap you deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test this scenario with the `my-sixth-configmap` ConfigMap; delete the
    ConfigMap resource as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try relaunching the `flask-pod-with-configmap-volume` Pod (or recreate
    the Pod) to see the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the Pod is in `ContainerCreating` and not in a `Running` state.
    Let’s check the details of the Pod as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Updating a ConfigMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two primary methods to update a ConfigMap in Kubernetes. The first
    involves using the `kubectl apply` command with a modified ConfigMap definition
    file. This approach is ideal for version control and collaborative environments.
    Simply make the necessary changes to your ConfigMap YAML file and apply the updates
    using `kubectl apply`.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can directly edit an existing ConfigMap using the `kubectl
    edit` command. This provides an interactive way to modify the ConfigMap’s contents.
    However, be cautious when using this method, as it doesn’t involve version control.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable ConfigMaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes offers a feature called Immutable ConfigMaps to prevent accidental
    or intentional modifications to ConfigMap data. By marking a ConfigMap as immutable,
    you ensure that its contents remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is particularly beneficial for clusters heavily reliant on ConfigMaps,
    as it safeguards against configuration errors causing application disruptions.
    Additionally, it enhances cluster performance by reducing the load on the `kube-apiserver`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an immutable ConfigMap, simply set the immutable field to `true`
    within the ConfigMap definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Once marked immutable, you cannot modify the ConfigMap’s data. If changes are
    necessary, you must delete the existing ConfigMap and create a new one. It’s essential
    to recreate any Pods referencing the deleted ConfigMap to maintain the correct
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section of this chapter, we will learn about Kubernetes Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Managing sensitive configuration with the Secret object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Secret object is a resource that allows you to configure applications running
    on Kubernetes. Secrets are extremely similar to ConfigMaps and they can be used
    together. The difference is that Secrets are encoded and intended to store sensitive
    data such as passwords, tokens, or private API keys, while ConfigMaps are intended
    to host non-sensitive configuration data. Other than that, Secrets and ConfigMaps
    mostly behave the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure the protection of sensitive information stored in Kubernetes Secrets,
    adhere to the following best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Limit access**: Utilize **Role-Based Access Control** (**RBAC**) to restrict
    access to Secrets based on user roles and permissions. Grant only necessary privileges
    to individuals or services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid hardcoding secrets**: Never embed Secrets directly within your application
    code or configuration files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rotate secrets regularly**: Implement a regular rotation schedule for Secrets
    to mitigate the risk of unauthorized access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consider external secret management**: For advanced security requirements,
    explore dedicated secret management solutions like HashiCorp Vault or AWS Secrets
    Manager.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leverage encryption**: Utilize KMS plugins to encrypt Secrets data at rest,
    providing an additional layer of protection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitor and audit**: Regularly review access logs and audit trails to detect
    suspicious activity and potential security breaches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Educate your team**: Foster a security-conscious culture by providing training
    on the best practices for handling and managing Secrets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While Secrets are used to store sensitive information and their data is encoded
    in base64, this encoding alone does not guarantee strong security. Base64 is a
    reversible encoding format, meaning that the original data can be recovered easily.
    For robust protection of sensitive information, consider additional security measures,
    such as encryption at rest using KMS plugins or external secret management solutions.
  prefs: []
  type: TYPE_NORMAL
- en: While Secrets are primarily used to store sensitive data, Kubernetes offers
    additional security measures. With the introduction of the **Key Management Service**
    (**KMS**) plugin providers, you can now encrypt data within both Secrets and ConfigMaps.
    This provides an extra layer of protection for sensitive information stored in
    ConfigMaps, making them more secure.
  prefs: []
  type: TYPE_NORMAL
- en: By utilizing KMS encryption for ConfigMaps, you can safeguard sensitive configuration
    data without resorting to Secrets. This approach simplifies configuration management
    while maintaining a high level of security.
  prefs: []
  type: TYPE_NORMAL
- en: Even with KMS encryption, it’s essential to carefully consider the sensitivity
    of the data stored in ConfigMaps. For highly confidential information, Secrets
    remain the recommended option.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the documentation ([https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/](https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/))
    to learn more about the KMS provider for data encryption.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by discovering how to list the Secrets that are available in your
    Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like any other Kubernetes resource, you can list secrets using the `kubectl
    get` command. The resource identifier is a Secret here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Just like with ConfigMaps, the `DATA` column tells you the number of sensitive
    parameters that have been hashed and saved in your `secret`. When executed, `kubectl`
    might display a few default Secrets or issue an error, stating that no resources
    were found. This discrepancy arises because certain cloud services generate default
    Secrets for internal processes, while others do not. The presence or absence of
    these default ConfigMaps depends on the environment in which your Kubernetes cluster
    is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Secret imperatively with --from-literal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create a Secret imperatively or declaratively – both methods are supported
    by Kubernetes. Let’s start by discovering how to create a Secret imperatively.
    Here, we want to store a database password, `my-db-password`, in a Secret object
    in our Kubernetes cluster. You can achieve that imperatively with `kubectl` by
    adding the `--from-literal` flag to the `kubectl create secret` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the `kubectl get secrets` command to retrieve the list of Secrets
    in your Kubernetes cluster. The new Secret should be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see the details of the Secret using the YAML output format, as shown
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see `data` with the `db_password: bXktZGItcGFzc3dvcmQ= line`, where
    the password is stored in an encoded format.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s figure out how to create a Secret declaratively.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Secret declaratively with a YAML file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Secrets can be created declaratively using YAML files. While it’s possible to
    manually encode secret values as base64 for the `data` field, Kubernetes provides
    a more convenient approach. The `stringData` field allows you to specify secret
    values as plain text strings. Kubernetes automatically encodes these values into
    the base64 format when creating the Secret. This method simplifies the process
    and helps prevent accidental exposure of sensitive data in plain text configuration
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: While base64 encoding offers basic obfuscation, it’s essential to remember
    that it’s not a strong encryption method. For heightened security, consider using
    KMS plugins or external secret management solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: When you use `--from-literal`, Kubernetes will encode your strings in base64
    itself, but when you create a Secret from a YAML manifest file, you will have
    to handle this step yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let’s start by converting the `my-db-password` string into `base64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`bXktZGItcGFzc3dvcmQ=` is the `base64` representation of the `my-db-password`
    string, and that’s what we will need to write in our YAML file. Here is the content
    of the YAML file to create the Secret object properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this file has been stored on your system, you can create the `secret`
    using the `kubectl apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make sure that the `secret` has been created properly by listing the
    secrets, with details, in our Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create the same Secret with `stringData` so that we do not need
    to encode it manually. Create a new YAML file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note the password in plain text instead of encoded text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the Secret from the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the secret content and compare it with the Secret `my-second-secret`
    to see the encoded content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that the `stringData` is already encoded and stored under the
    `data` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s discover another Kubernetes feature: the ability to create a Secret
    with values from a file.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Secret with content from a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create a Secret with values from a file, the same as we did with ConfigMaps.
    We start by creating a file that will contain our secret value. Let’s say that
    we have to store a password in a file and import it as a Secret object in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: After running this command, we have a file called `password.txt` that contains
    a string called `mypassword`, which is supposed to be our Secret value. The `-n`
    flag is used here to ensure that `password.txt` does not contain any extra blank
    lines at the end of the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run the `kubectl create secret` command by passing the location
    of `password.txt` to the `--from-file` flag. This will result in a new `secret`,
    containing a `base64` representation of the `mypassword` string being created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This new `secret` is now available in your Kubernetes cluster! Now, let’s learn
    how to read a Kubernetes Secret.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a Secret
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As observed, Secrets are supposed to host sensitive data, and, as such, the
    `kubectl` output won’t show you the secret decoded data to ensure confidentiality.
    You’ll simply have to decode it yourself to understand. Why is this confidentiality
    maintained? Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: To prevent the secret from being accidentally opened by someone who shouldn’t
    be able to open it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To prevent the secret from being displayed as part of a terminal output, which
    could result in it being logged somewhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While base64 encoding obfuscates secret data, it doesn’t provide strong encryption.
    Any user with API access to the Kubernetes cluster can retrieve and decode a Secret.
    To protect sensitive information, implement RBAC to restrict access to Secrets
    based on user roles and permissions. By carefully defining RBAC rules, you can
    limit who can view, modify, or delete Secrets, enhancing the overall security
    of your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Because of these securities, you simply won’t be able to retrieve the actual
    content of a secret, but you can still grab information about its size, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this using the `kubectl describe` command, just like we did earlier
    for ConfigMaps. As we mentioned previously, ConfigMaps and Secrets are very similar;
    they almost behave the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Do not get confused if your output is a little different than this one. If you
    receive something similar, it means that the new secret is available in your Kubernetes
    cluster and that you successfully retrieved its data!
  prefs: []
  type: TYPE_NORMAL
- en: 'However, also remember that the encoded data can be visible using the `kubectl`
    and YAML output format, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And anyone with access to this Secret can decode the data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: IMPORTANT
  prefs: []
  type: TYPE_NORMAL
- en: Base64 encoding is not encryption; it is simply a way to represent binary data
    in ASCII characters. While it makes the data look less readable, it’s not encryption.
    Anyone with the knowledge and tools can easily decode it back to plain text. To
    safeguard Secrets effectively, combine base64 encoding with additional security
    controls like RBAC and encryption, or consider using external secret management
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored the creation and management of Secrets, let’s delve
    into how to make this sensitive information accessible to our applications within
    Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming a Secret as an environment variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve seen how we can inject the values of a ConfigMap into a Pod in the form
    of environment variables, and we can do the same with Secrets. Returning to the
    example with our NGINX container, we are going to retrieve the `db_password` value
    of the `my-first-secret` Secret and inject it as an environment variable into
    the Pod. Here is the YAML manifest. Again, everything occurs under the `env:`
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can apply this file using the `kubectl apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the `env` command to list the environment variables in your container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `my-db-password` string is available as the environment
    variable `PASSWORD_ENV_VAR`.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to find out details about a Secret is by using the `envFrom` YAML
    key. When using this key, you’ll read all the values from a Secret and get them
    as environment variables in the Pod all at once. It works the same as for the
    ConfigMap object.
  prefs: []
  type: TYPE_NORMAL
- en: For a Pod to start successfully, the referenced Secret must exist unless explicitly
    marked as optional within the Pod definition. Ensure that the Secret is created
    before deploying Pods that depend on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Secret first by using the following YAML with the `envFrom` sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the preceding example of a Pod but updated with an `envFrom` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the Pod using the `kubectl apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this, all the keys in the Secret object will be used as environment variables
    within the Pod. Let us verify the environment variables inside the Pod to ensure
    that the variables from the Secret object are loaded properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note that if a key name cannot be used as an environment variable name, then
    it will be simply ignored!
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to consume a secret as a volume mount in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming a Secret as a volume mount
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can mount Secrets as a volume for your Pods, but you can only do so declaratively.
    So you’ll have to write YAML files to do this successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must start from a YAML manifest file that will create a Pod. Here is a
    YAML file that mounts a Secret called `mypassword` in the `/etc/passwords-mounted-path`
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have created this file on your filesystem, you can apply the YAML
    file using `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Please make sure that the `my-second-secret` exists before you attempt to create
    the Secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can run a command inside `flask-with-secret`, using the `kubectl
    exec` command, to check if the volume containing the Secret was set up correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `my-db-password` string is displayed correctly; the Secret
    was correctly mounted as a volume!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to create a Secret in Kubernetes and use it with
    a Pod in multiple methods, let’s learn how to delete and update Secrets in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a Secret
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deleting a secret is very simple and can be done via the `kubectl delete` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s learn how to update an existing secret in a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a Secret
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To update a Secret in Kubernetes, you can use the `kubectl apply` command with
    a modified Secret definition or by using the `kubectl edit` command.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Secrets provide a secure way to store and manage sensitive information
    like passwords, API keys, and certificates. Unlike ConfigMaps, Secrets are encoded
    to protect data confidentiality. This section explored how to create Secrets both
    imperatively and declaratively using YAML. You learned how to inject Secrets into
    Pods using environment variables and volume mounts, enabling applications to access
    sensitive data without exposing it in plain text.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter delved into the fundamental concepts of managing configuration
    within Kubernetes. We explored the critical distinction between ConfigMaps and
    Secrets, understanding their respective roles in handling non-sensitive and sensitive
    data. By effectively utilizing these Kubernetes resources, you can significantly
    enhance application portability and security.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to create and manage both ConfigMaps and Secrets, employing both
    imperative and declarative approaches. You discovered how to inject configuration
    data into Pods using environment variables and volume mounts, ensuring seamless
    access to application settings.
  prefs: []
  type: TYPE_NORMAL
- en: To protect sensitive information, we emphasized the importance of implementing
    robust security measures beyond base64 encoding. By combining RBAC, encryption,
    and external secret management solutions, you can significantly strengthen the
    security posture of your Kubernetes environment.
  prefs: []
  type: TYPE_NORMAL
- en: By mastering the concepts presented in this chapter, you’ll be well-equipped
    to build resilient and secure Kubernetes applications that are decoupled from
    their configuration, promoting flexibility and maintainability. In the next chapter,
    we will continue discovering Kubernetes by tackling another central concept of
    Kubernetes, which is Services. Services are Kubernetes objects that allow you
    to expose your Pods to not only each other but also the internet. This is a very
    important network concept for Kubernetes, and mastering it is essential to use
    the orchestrator correctly. Fortunately, mastering Services is not very complicated,
    and the next chapter will explain how to achieve this. You will learn how to associate
    the ports of a container with the ports of the worker node it is running on, and
    also how to associate a static IP with your Pods so that they can always be reached
    at the same address by other Pods in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ConfigMaps: [https://kubernetes.io/docs/concepts/configuration/configmap/](https://kubernetes.io/docs/concepts/configuration/configmap/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configure a Pod to Use a ConfigMap: [https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Managing Secrets using kubectl: [https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-kubectl/](https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-kubectl/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Managing Secrets using Configuration File: [https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-config-file/](https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-config-file/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using a KMS provider for data encryption: [https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/](https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The security aspect of Secrets as well as compliance and DevOps practices:
    Kubernetes Secrets Handbook: Design, implement, and maintain production-grade
    Kubernetes Secrets management solutions: [https://www.amazon.com/Kubernetes-Secrets-Handbook-production-grade-management/dp/180512322X/](https://www.amazon.com/Kubernetes-Secrets-Handbook-production-grade-management/dp/180512322X/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code119001106479081656.png)'
  prefs: []
  type: TYPE_IMG
