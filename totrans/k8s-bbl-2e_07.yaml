- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Configuring Your Pods Using ConfigMaps and Secrets
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ConfigMaps 和 Secrets 配置你的 Pods
- en: The previous chapters introduced you to launching application containers using
    Kubernetes. You now know that whenever you need to launch a container on Kubernetes,
    you will need to do so using Pods. This was the key concept for you to understand
    and assimilate. Kubernetes is a complex system managed through a RESTful API.
    The core component handling this is the Kubernetes API server, which provides
    the primary interface to interact with the cluster. When users create Kubernetes
    objects, such as Pods, through this API, the system responds by provisioning the
    necessary resources on cluster nodes. Among these resources, a Pod stands out,
    as its creation on a Kubernetes node leads to the instantiation of application
    containers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章介绍了如何使用 Kubernetes 启动应用容器。现在你知道，每当你需要在 Kubernetes 上启动容器时，必须通过 Pods 来实现。这是你需要理解和掌握的关键概念。Kubernetes
    是一个通过 RESTful API 管理的复杂系统。处理这一过程的核心组件是 Kubernetes API 服务器，它提供了与集群交互的主要接口。当用户通过这个
    API 创建 Kubernetes 对象，如 Pods 时，系统会在集群节点上分配必要的资源。在这些资源中，Pod 非常重要，因为它在 Kubernetes
    节点上创建时会启动应用容器。
- en: 'In this chapter, we’ll learn about two new Kubernetes objects: **ConfigMaps**
    and **Secrets**. Kubernetes leverages ConfigMaps and Secrets to decouple application
    configuration from the code itself. These objects provide a mechanism to manage
    configuration values independently, enhancing application portability and security.
    ConfigMaps store non-sensitive data as key-value pairs, while Secrets handle sensitive
    information like passwords or API keys. Both can be injected into Pods as environment
    variables or mounted as volumes, allowing applications to dynamically access configuration
    without hardcoding values. By separating configuration from an application, you
    create more flexible, resilient, and secure deployments within the Kubernetes
    ecosystem.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习两个新的 Kubernetes 对象：**ConfigMaps** 和 **Secrets**。Kubernetes 使用 ConfigMaps
    和 Secrets 来将应用配置与代码本身解耦。这些对象提供了一种独立管理配置值的机制，从而增强了应用的可移植性和安全性。ConfigMaps 将非敏感数据以键值对的形式存储，而
    Secrets 则处理诸如密码或 API 密钥等敏感信息。这两者都可以作为环境变量注入到 Pods 中，或者作为卷挂载，允许应用动态访问配置，而无需硬编码值。通过将配置与应用分离，你可以在
    Kubernetes 生态系统中创建更灵活、更具韧性和更安全的部署。
- en: 'The following are the main topics that we’re going to cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章我们将要覆盖的主要内容：
- en: Understanding what ConfigMaps and Secrets are
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 ConfigMaps 和 Secrets 的概念
- en: Configuring your Pods using ConfigMaps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ConfigMaps 配置你的 Pods
- en: Managing sensitive configuration with the Secret object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Secret 对象管理敏感配置
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你将需要以下内容：
- en: A working Kubernetes cluster (local or cloud-based, although this is not important)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正在运行的 Kubernetes 集群（本地或云端，虽然这并不重要）
- en: A working `kubectl` CLI configured to communicate with the Kubernetes cluster
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个已配置的 `kubectl` CLI，用于与 Kubernetes 集群通信
- en: You can get these two prerequisites by following *Chapter 2*, *Kubernetes Architecture
    – From Container Images to Running Pods*, and *Chapter 3*, *Installing Your First
    Kubernetes Cluster*, to get a working Kubernetes cluster and a properly configured
    `kubectl` client, respectively.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过阅读 *第 2 章*、*Kubernetes 架构 - 从容器镜像到运行的 Pod* 和 *第 3 章*、*安装你的第一个 Kubernetes
    集群*，分别获得一个工作中的 Kubernetes 集群和正确配置的 `kubectl` 客户端。
- en: 'You can download the latest code samples for this chapter from the official
    GitHub repository: [https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter07).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从官方 GitHub 仓库下载本章的最新代码示例：[https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter07)。
- en: Understanding what ConfigMaps and Secrets are
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 ConfigMaps 和 Secrets 的概念
- en: Kubernetes environments are dynamic and constantly changing. This makes managing
    application configurations a complex challenge. Traditional methods often fall
    short in keeping up with the rapid pace of cloud-native development.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 环境是动态的，并且不断变化。这使得应用配置的管理变得复杂。传统方法通常无法跟上云原生开发的快速步伐。
- en: To address this, Kubernetes provides ConfigMaps and Secrets, specialized ways
    to handle different types of configuration data. By separating configuration from
    the application code, these resources significantly improve application portability,
    security, and manageability.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Kubernetes 提供了 ConfigMaps 和 Secrets，这些是处理不同类型配置数据的专用方式。通过将配置与应用程序代码分离，这些资源显著提高了应用程序的可移植性、安全性和可管理性。
- en: In the following sections, we’ll dive into the details of ConfigMaps and Secrets,
    exploring how they work and how to best utilize them in your Kubernetes deployments.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将深入探讨 ConfigMaps 和 Secrets 的细节，了解它们是如何工作的，以及如何在 Kubernetes 部署中最好地利用它们。
- en: Decoupling your application and your configuration
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解耦应用程序和配置
- en: Containers are immutable by nature, meaning they cannot be changed once created.
    This presents a challenge when managing configuration. Embedding configuration
    within a container image requires rebuilding the entire image for every configuration
    change, a time-consuming and inefficient process. Relying solely on environment
    variables or command-line arguments for configuration can also be cumbersome,
    especially for complex setups, and doesn’t guarantee persistence across container
    restarts. These limitations highlight the need for a more effective configuration
    management strategy in Kubernetes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 容器天生是不可变的，这意味着一旦创建，就无法更改。这在配置管理时带来了挑战。将配置嵌入容器镜像中需要在每次配置更改时重建整个镜像，这个过程既费时又低效。仅依赖环境变量或命令行参数进行配置也会显得繁琐，尤其是对于复杂的设置，并且不能保证在容器重启时配置的持久性。这些限制突显了在
    Kubernetes 中需要更有效的配置管理策略。
- en: When we use Kubernetes, we want our applications to be as portable as possible.
    A good way to achieve this is to decouple the application from its configuration.
    Back in the old days, configuration and application were the same thing; since
    the application code was designed to work only on one environment, configuration
    values were often bundled within the application code itself, so the configuration
    and application code were tightly coupled.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Kubernetes 时，我们希望我们的应用程序尽可能具有可移植性。实现这一目标的一个好方法是将应用程序与其配置解耦。早些时候，配置和应用程序是同一个概念；由于应用程序代码只设计用于在单一环境中运行，配置值通常会被捆绑在应用程序代码中，因此配置和应用程序代码是紧密耦合的。
- en: Having both application code and configuration values treated as the same thing
    reduces the portability of an application. Now, things have changed a lot, and
    we must be able to update the application configuration because we want to make
    our application as portable as possible, enabling us to deploy applications in
    multiple environments flawlessly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序代码和配置值视为相同的内容会降低应用程序的可移植性。如今，情况发生了很大变化，我们必须能够更新应用程序配置，因为我们希望尽可能地使应用程序具有可移植性，使我们能够在多个环境中无缝部署应用程序。
- en: 'Consider the following problem:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下问题：
- en: You deploy a Java application to the development environment for testing.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将一个 Java 应用程序部署到开发环境进行测试。
- en: After the tests, the app is ready for production, and you need to deploy it.
    However, the MySQL endpoint for production is different from the one in development.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试完成后，应用程序准备好进入生产环境，并且需要进行部署。然而，生产环境的 MySQL 端点与开发环境中的不同。
- en: 'There are two possibilities here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两种可能性：
- en: The configuration and application code are not decoupled, and the MySQL is hardcoded
    and bundled within the application code; you are stuck and need to rebuild the
    whole app after editing the application code.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和应用程序代码没有解耦，MySQL 被硬编码并捆绑在应用程序代码中；你被困住了，在编辑应用程序代码后需要重新构建整个应用程序。
- en: The configuration and application code are decoupled. That’s good news for you,
    as you can simply override the MySQL endpoint as you deploy it to production.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和应用程序代码已解耦。这对你来说是好消息，因为你可以在部署到生产环境时，简单地覆盖 MySQL 端点。
- en: That’s the key to the concept of portability – the application code should be
    independent of the infrastructure it is running on. The best way to achieve this
    is to decouple the application code from its configuration.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是可移植性概念的关键——应用程序代码应独立于其运行的基础设施。实现这一目标的最佳方法是将应用程序代码与其配置解耦。
- en: In the following image, we have a common application container image and different
    configurations for the different environments.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们有一个常见的应用程序容器镜像，并且为不同环境配置了不同的配置。
- en: '![](img/B22019_07_01.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_07_01.png)'
- en: 'Figure 7.1: Application configuration decoupled'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：应用程序配置解耦
- en: 'Let’s look at some typical examples of the types of configuration values you
    should decouple from an app:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些典型的例子，看看您应该从应用程序中解耦的配置值类型：
- en: API keys to access an Amazon S3 bucket
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 Amazon S3 存储桶的 API 密钥
- en: The password of the MySQL server used by your application
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序使用的 MySQL 服务器的密码
- en: The endpoint of a Redis cluster used by your application
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序使用的 Redis 集群的端点
- en: Pre-computed values such as JWT token private keys
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预计算的值，如 JWT 令牌的私钥
- en: All of these values are likely to change from one environment to another, and
    the applications that are launched in your Pods should be able to load a different
    configuration, depending on the environment they are launched on. This is why
    we will seek to systematically maintain a barrier between our applications and
    the configurations they consume. Doing this allows us to treat them as two completely
    different entities in our Kubernetes cluster. The best way to achieve this is
    by considering our application and its configurations as two different entities.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值可能会在不同的环境之间发生变化，而在您的 Pod 中启动的应用程序应该能够加载不同的配置，具体取决于它们所启动的环境。这就是为什么我们要系统地维护应用程序与它们所消耗配置之间的隔离的原因。这样做可以让我们在
    Kubernetes 集群中将它们视为两个完全不同的实体。实现这一目标的最佳方法是将应用程序及其配置视为两个不同的实体。
- en: This is why Kubernetes suggests using the ConfigMaps and Secrets objects, which
    are designed to carry your configuration data. Then, you will need to attach these
    ConfigMaps and Secrets when you create your Pods.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Kubernetes 建议使用 ConfigMap 和 Secret 对象的原因，它们旨在承载您的配置数据。然后，您需要在创建 Pod 时附加这些
    ConfigMap 和 Secret。
- en: Please avoid including your configuration values as part of your container images,
    such as Docker images. Your Dockerfile (or Containerfile for Podman) should build
    your application but not configure it. By including the container configuration
    at build time, you create a strong relationship between your application and how
    it’s configured, which reduces the portability of your container to different
    environments.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请避免将您的配置值作为容器镜像的一部分，比如 Docker 镜像。您的 Dockerfile（或 Podman 的 Containerfile）应该构建您的应用程序，而不是配置它。在构建时包含容器配置，会在应用程序与其配置之间建立强关系，从而减少容器在不同环境中的可移植性。
- en: ConfigMaps are meant to hold non-sensitive configuration values, whereas Secrets
    are globally the same but are meant to hold sensitive configuration values, such
    as database passwords, API keys, and so on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 用于保存非敏感的配置值，而 Secret 通常是相同的，但用于保存敏感的配置值，如数据库密码、API 密钥等。
- en: So, you can imagine a ConfigMap and Secret for each environment and for each
    application, which will contain the parameters that the application needs to function
    in a specific context and environment. The key point is that ConfigMaps and Secrets
    serve as storage mechanisms for key/value pairs, for configuration data within
    a Kubernetes cluster. These key/value pairs can contain plain values called `literals`
    or full configuration files, such as `YAML`, `TOML`, and so on. Then, on Pod creation,
    you can pick the name of a ConfigMap or a Secret and link it to your Pod so that
    the configuration values are exposed to the containers running into it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以为每个环境和每个应用程序想象一个 ConfigMap 和 Secret，其中将包含应用程序在特定上下文和环境中运行所需的参数。关键点是，ConfigMap
    和 Secret 作为 Kubernetes 集群内配置数据的键值对存储机制。这些键值对可以包含称为 `literals` 的纯值或完整的配置文件，如 `YAML`、`TOML`
    等。然后，在创建 Pod 时，您可以选择 ConfigMap 或 Secret 的名称，并将其与 Pod 链接，以便将配置值暴露给运行在其中的容器。
- en: 'You always proceed in this order to guarantee that the configuration data is
    available when the Pod starts:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您始终按此顺序进行，以确保在 Pod 启动时配置数据可用：
- en: Create a ConfigMap or a Secret with the configuration values.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用配置值创建一个 ConfigMap 或 Secret。
- en: Create a Pod referencing the ConfigMap or Secret.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个引用 ConfigMap 或 Secret 的 Pod。
- en: By adopting this approach, you enhance your application’s portability and maintainability,
    aligning with common DevOps best practices.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用这种方法，您可以增强应用程序的可移植性和可维护性，符合常见的 DevOps 最佳实践。
- en: Now that we’ve explained why it is important to decouple application code and
    configuration values, it is time to explain why and how to achieve this in a Kubernetes-friendly
    way.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释了为何将应用程序代码与配置值解耦很重要，接下来是时候解释为什么以及如何以 Kubernetes 友好的方式实现这一目标。
- en: Understanding how Pods consume ConfigMaps and Secrets
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 Pods 如何使用 ConfigMap 和 Secret
- en: 'Before diving into the specifics of ConfigMaps and Secrets, let’s examine traditional
    methods of managing configuration in containerized environments. Outside of Kubernetes,
    modern containerized applications consume their configuration in multiple ways:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解 ConfigMap 和 Secrets 的具体细节之前，让我们先来看看在容器化环境中管理配置的传统方法。在 Kubernetes 之外，现代容器化应用程序通过多种方式使用它们的配置：
- en: As OS environment variables
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为操作系统环境变量
- en: As configuration files
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为配置文件
- en: Command-line arguments
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数
- en: API access
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 访问
- en: This is because overriding an environment variable is super-easy with Docker
    or Podman, and all programming languages offer functions to easily read environment
    variables. Configuration files can easily be shared and mounted as volumes between
    containers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在 Docker 或 Podman 中覆盖环境变量非常容易，而且所有编程语言都提供了轻松读取环境变量的功能。配置文件可以很容易地在容器之间共享并作为卷挂载。
- en: IMPORTANT
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: While ConfigMaps and Secrets are the primary methods for managing configuration
    in Kubernetes, there are alternative approaches. Command-line arguments can be
    used to pass configuration directly to containers, but this method is less flexible
    and secure than ConfigMaps and Secrets. Directly accessing the Kubernetes API
    to fetch configuration is generally discouraged, due to security risks and added
    complexity.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 ConfigMap 和 Secrets 是 Kubernetes 中管理配置的主要方法，但也有其他替代方法。命令行参数可以直接将配置传递给容器，但这种方法比
    ConfigMap 和 Secrets 更不灵活和安全。直接访问 Kubernetes API 获取配置通常不被推荐，因为它存在安全风险和增加的复杂性。
- en: 'Back in the Kubernetes world, ConfigMaps and Secrets follow these two methods.
    Once created in your Kubernetes cluster, ConfigMaps can be consumed in one of
    two ways:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 环境中，ConfigMap 和 Secrets 遵循这两种方法。一旦在 Kubernetes 集群中创建，ConfigMap
    可以通过以下两种方式使用：
- en: Included as environment variables in the container running in your Pods
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为容器中运行的 Pod 的环境变量
- en: Mounted as Kubernetes volumes, just like any other volume
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像其他任何卷一样，作为 Kubernetes 卷进行挂载
- en: You can choose to inject one value from a ConfigMap or a Secret as an environment
    variable, or inject all the values from a ConfigMap or a Secret as environment
    variables.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择将 ConfigMap 或 Secret 中的某个值注入为环境变量，或者将 ConfigMap 或 Secret 中的所有值注入为环境变量。
- en: IMPORTANT
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: Using environment variables to expose Secrets is strongly discouraged due to
    potential security risks and the possibility of value truncation. Consider using
    the volume approach with file-based Secrets to leverage kubelet caching for dynamic
    updates and improved security.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈不推荐使用环境变量来暴露 Secrets，因为这可能带来安全风险并导致值被截断。建议使用基于文件的 Secrets 卷挂载方法，利用 kubelet
    缓存实现动态更新和增强安全性。
- en: ConfigMap and Secrets can also behave as volume mounts. When you mount a ConfigMap
    as a volume, you can inject all the values it contains in a directory into your
    container. If you store the full configuration files in your ConfigMap, using
    this feature to override a configuration directory becomes incredibly easy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 和 Secrets 也可以作为卷挂载。当你将 ConfigMap 挂载为卷时，可以将它包含的所有值作为一个目录注入到容器中。如果你将完整的配置文件存储在
    ConfigMap 中，使用此功能覆盖配置目录变得异常简单。
- en: After this introduction to ConfigMap and Secrets, you should now understand
    why they are so important when it comes to configuring an application. Mastering
    them is crucial if you intend to work with Kubernetes cleanly and solidly. As
    we mentioned earlier in this chapter, ConfigMaps are used to store *unsecured*
    configuration values, whereas Secrets are used for more sensitive configuration
    data, such as hashes or database passwords.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这部分内容的介绍，你应该理解为什么在配置应用程序时，ConfigMap 和 Secrets 如此重要。如果你打算在 Kubernetes 中进行干净且扎实的工作，掌握它们至关重要。正如我们在本章前面提到的，ConfigMap
    用于存储*不安全*的配置值，而 Secrets 用于存储更为敏感的配置信息，如哈希值或数据库密码。
- en: The following table shows the high-level differences between ConfigMaps and
    Secrets in Kubernetes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了 Kubernetes 中 ConfigMap 和 Secrets 之间的高级差异。
- en: '| **Feature** | **ConfigMaps** | **Secrets** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **ConfigMaps** | **Secrets** |'
- en: '| Purpose | Store non-sensitive configuration data | Store sensitive information
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 目的 | 存储非敏感配置数据 | 存储敏感信息 |'
- en: '| Data format | Plain text | Base64-encoded |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 数据格式 | 明文文本 | Base64 编码 |'
- en: '| Security | Less secure | More secure |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 安全性 | 不太安全 | 更加安全 |'
- en: '| Common use cases | Application configuration, environment variables, and
    command-line arguments | Passwords, API keys, SSH keys, and TLS certificates |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 常见用途 | 应用程序配置、环境变量和命令行参数 | 密码、API 密钥、SSH 密钥和 TLS 证书 |'
- en: '| Handling sensitive data | Not recommended | Strongly recommended |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 处理敏感数据 | 不推荐 | 强烈推荐 |'
- en: 'Table 7.1: Differences between ConfigMaps and Secrets'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1：ConfigMap 和 Secrets 之间的区别
- en: Since the ConfigMaps and Secrets don’t behave the same, let’s look at them separately.
    First, we are going to discover how ConfigMaps work. We will discover Secrets
    after.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ConfigMap 和 Secrets 的行为不同，我们将分别探讨它们。首先，我们将了解 ConfigMap 的工作原理，之后再讨论 Secrets。
- en: Configuring your Pods using ConfigMaps
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ConfigMap 配置你的 Pods
- en: In this section, we will learn how to list, create, delete, and read ConfigMaps.
    Also, we’ll learn how to attach them to our Pods so that their values are injected
    into the Pods, in the form of environment variables or volumes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何列出、创建、删除和读取 ConfigMap。同时，我们还将学习如何将它们附加到 Pods 上，以便将其值作为环境变量或卷注入到
    Pods 中。
- en: In the following sections, we will learn how to list, create, and manage ConfigMaps
    in Kubernetes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将学习如何列出、创建和管理 Kubernetes 中的 ConfigMap。
- en: Listing ConfigMaps
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出 ConfigMap
- en: 'Listing the ConfigMaps that were created in your cluster is fairly straightforward
    and can be accomplished using `kubectl`, just like any other object in Kubernetes.
    You can do this by using the full resource name, which is `configmaps`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列出在集群中创建的 ConfigMap 非常简单，可以像使用 Kubernetes 中的其他对象一样使用 `kubectl` 完成。你可以通过使用完整的资源名称
    `configmaps` 来实现：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, you can use the shorter alias, which is `cm`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用较短的别名 `cm`：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both of these commands have the same effect. When executed, `kubectl` might
    display a few default ConfigMaps or issue an error, stating that no ConfigMaps
    were found. This discrepancy arises because certain cloud services generate default
    ConfigMaps for internal processes, while others do not. The presence or absence
    of these default ConfigMaps depends on the environment in which your Kubernetes
    cluster is deployed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令的效果相同。执行时，`kubectl` 可能会显示一些默认的 ConfigMap，或者出现错误，提示没有找到 ConfigMap。这种差异是因为某些云服务会为内部流程生成默认的
    ConfigMap，而有些则不会。这些默认 ConfigMap 的存在与否取决于 Kubernetes 集群的部署环境。
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see in the preceding output, there are multiple ConfigMaps in the
    default namespace and Kubernetes-managed namespaces, which are created during
    the cluster deployment. Now, let’s learn how to create a new ConfigMap in the
    next section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，默认命名空间和 Kubernetes 管理的命名空间中有多个 ConfigMap，这是在集群部署过程中创建的。现在，让我们学习如何在下一节中创建一个新的
    ConfigMap。
- en: Creating a ConfigMap
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 ConfigMap
- en: 'Like other Kubernetes objects, ConfigMaps can be created imperatively or declaratively.
    You can decide to create an empty ConfigMap and then add values to it or create
    a ConfigMap directly with initial values. The following command will create an
    empty ConfigMap, called `my-first-configmap`, via the imperative method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他 Kubernetes 对象一样，ConfigMap 可以通过命令式或声明式方法创建。你可以选择创建一个空的 ConfigMap 然后添加值，或者直接创建一个包含初始值的
    ConfigMap。以下命令将通过命令式方法创建一个名为 `my-first-configmap` 的空 ConfigMap：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once this command has been executed, you can type the `kubectl get cm` command
    once again to see your new `configmap`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完此命令后，你可以再次输入 `kubectl get cm` 命令，查看你新创建的 `configmap`：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we are going to create a new empty ConfigMap, but this time, we are going
    to create it with the declarative method. This way, we’ll have to create a YAML
    file and apply it through `kubectl`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个新的空 ConfigMap，但这次我们将采用声明式方法创建。这样，我们需要创建一个 YAML 文件，并通过 `kubectl` 来应用它。
- en: 'The following content should be placed in a file called `~/my-second-configmap.yaml`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容应该放置在名为 `~/my-second-configmap.yaml` 的文件中：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once this file has been created, you can apply it to your Kubernetes cluster
    using the `kubectl apply -f` command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个文件创建完成，你可以通过 `kubectl apply -f` 命令将其应用到 Kubernetes 集群中：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can type the `kubectl get cm` command once more to see your new `configmap`
    added next to the one you created earlier:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以再次输入 `kubectl get cm` 命令，以查看你新创建的 `configmap` 是否出现在你之前创建的 `configmap` 旁边：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Please note that the output of the `kubectl get cm` command also returns the
    number of keys that each ConfigMap contains in the `DATA` column. For now, it’s
    zero, but in the following examples, you’ll see that we can fill a `configmap`
    when it’s created, so `DATA` will reflect the number of keys we put in `configmap`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`kubectl get cm` 命令的输出还会在 `DATA` 列中返回每个 ConfigMap 所包含的键的数量。目前是零，但在接下来的示例中，你将看到我们可以在创建
    ConfigMap 时填写 `configmap`，因此 `DATA` 将反映我们在 `configmap` 中放入的键的数量。
- en: Creating a ConfigMap from literal values
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从字面值创建一个 ConfigMap
- en: 'Having an empty ConfigMap is quite useless, so let’s learn how to create a
    ConfigMap with values inside it. Let’s do this imperatively: adding the `–from-literal`
    flag to the `kubectl create cm` command.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个空的 ConfigMap 是相当无用的，所以让我们学习如何在 ConfigMap 中创建带有值的对象。我们通过命令式方式来实现：向 `kubectl
    create cm` 命令添加 `–from-literal` 标志。
- en: 'Here, we are going to create a ConfigMap called `my-third-configmap`, with
    a key named `color` and its value set to `blue`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个名为 `my-third-configmap` 的 ConfigMap，键名为 `color`，其值设置为 `blue`：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, be aware that you can create a ConfigMap with multiple parameters; you
    just need to add as much configuration data as you want to `configmap` by chaining
    as many from-literals as you need in your command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，请注意，您可以创建一个包含多个参数的 ConfigMap；您只需要通过在命令中链式添加所需数量的 `from-literals`，来将任意数量的配置数据添加到
    `configmap` 中：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we create a ConfigMap with three configuration values inside it. Now,
    you can list your ConfigMaps once more using this command. You should see the
    few additional ones you just created.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个包含三个配置值的 ConfigMap。现在，您可以再次使用此命令列出您的 ConfigMap。您应该能看到刚刚创建的几个额外的 ConfigMap。
- en: 'Please note that the `DATA` column in the return of `kubectl get cm` now reflects
    the number of configuration values inside each `configmap`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`kubectl get cm` 的返回结果中的 `DATA` 列现在反映了每个 `configmap` 内部的配置值数量：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can also see the details of the ConfigMap (or any other objects) by displaying
    a well-formatted output in the YAML or JSON format, as follows.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过以 YAML 或 JSON 格式显示良好格式化的输出，查看 ConfigMap（或其他任何对象）的详细信息，如下所示。
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This approach also facilitates object backup in the YAML or JSON formats, aligning
    with **Configuration as Code** (**CaC**) and **Infrastructure as Code** (**IaC**)
    best practices.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也有助于以 YAML 或 JSON 格式备份对象，符合 **配置即代码**（**CaC**）和 **基础设施即代码**（**IaC**）的最佳实践。
- en: 'Now, it is also possible to create the same ConfigMap declaratively. Here is
    the declarative YAML configuration file that is ready to be applied against the
    cluster. Please note the new data YAML key, which contains all the configuration
    values:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，也可以通过声明方式创建相同的 ConfigMap。下面是一个准备应用于集群的声明式 YAML 配置文件。请注意新的数据 YAML 键，它包含了所有的配置值：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once you have created the file, you can create the ConfigMap using the `kubectl
    apply` command, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了文件，您可以使用 `kubectl apply` 命令创建 ConfigMap，如下所示：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A new ConfigMap object will be created based on the `my-fifth-configmap.yam`l
    file, which includes your data as per the YAML definition.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 `my-fifth-configmap.yaml` 文件，创建一个新的 ConfigMap 对象，其中包括按 YAML 定义的数据。
- en: Now, let’s learn how to store entire configuration files inside a ConfigMap
    in the next section of this chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在本章的下一个部分学习如何将整个配置文件存储在 ConfigMap 中。
- en: Storing entire configuration files in a ConfigMap
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将整个配置文件存储在 ConfigMap 中
- en: As we mentioned earlier, it’s also possible to store complete files inside a
    ConfigMap – you are not restricted to literal values. The trick is to give the
    path of a file stored in your filesystem to the `kubectl` command line. The content
    of the file will then be taken by `kubectl` and used to populate a parameter in
    `configmap`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，也可以将完整的文件存储在 ConfigMap 中——您不局限于字面值。技巧是将文件在文件系统中的路径提供给 `kubectl` 命令行。然后，`kubectl`
    会获取文件的内容，并将其用于填充 `configmap` 中的参数。
- en: Having the content of a configuration file stored in a ConfigMap is super-useful
    because you’ll be able to mount your ConfigMaps in your Pods, just like you can
    do with volumes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将配置文件的内容存储在 ConfigMap 中非常有用，因为您可以像挂载卷一样，将 ConfigMap 挂载到您的 Pods 中。
- en: The good news is that you can mix literal values and files inside a ConfigMap.
    Literal values are meant to be short strings, whereas files are just treated as
    longer strings; they are not two different data types.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，您可以在 ConfigMap 中混合使用字面值和文件。字面值通常是短字符串，而文件则被视为较长的字符串；它们并不是两种不同的数据类型。
- en: We have already seen such a sample ConfigMap in *Chapter 5*, in the *Sidecar
    multi-container Pod – an example* section, where we stored the Fluentd configuration
    content inside a ConfigMap as file content.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第 5 章*的*Sidecar 多容器 Pod 示例*部分中已经看到过一个这样的示例 ConfigMap，我们将 Fluentd 配置内容作为文件内容存储在
    ConfigMap 中。
- en: Here, a sixth ConfigMap is created with a literal value, just like it was previously,
    but now, we are also going to store the content of a file in it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了第六个 ConfigMap，它与之前一样包含字面值，但现在我们也将存储一个文件的内容。
- en: 'Let’s create a file called `configfile.txt` in the `$HOME/configfile.txt` location
    with arbitrary content:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `$HOME/configfile.txt` 位置创建一个名为 `configfile.txt` 的文件，并填入任意内容：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, that configuration file has the `.txt` extension, but it could be a `.yaml`,
    `.toml`, `.rb`, or any other configuration format that your application can use.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的配置文件扩展名为 `.txt`，但它也可以是 `.yaml`、`.toml`、`.rb` 或任何其他您的应用程序可以使用的配置格式。
- en: 'Now, we need to import that file into a ConfigMap, so let’s create a brand-new
    ConfigMap to demonstrate this. You can do this using the `--from-file` flag, which
    can be used together with the `--from-literal` flag in the same command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将该文件导入到一个 ConfigMap 中，因此让我们创建一个全新的 ConfigMap 来演示这一点。您可以使用 `--from-file`
    标志来实现此操作，该标志可以与 `--from-literal` 标志一起使用：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s run the `kubectl get cm` command once more to make sure that our sixth
    `configmap` is created. The command will show that it contains two configuration
    values – in our case, the one created from a literal and the other one created
    from the content of a file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行 `kubectl get cm` 命令，以确保我们的第六个 `configmap` 已创建。该命令将显示它包含两个配置值——在我们的案例中，一个是从字面值创建的，另一个是从文件内容创建的：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, `my-sixth-configmap` contains two pieces of data: the literal
    and the file.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`my-sixth-configmap` 包含两条数据：字面值和文件。
- en: Now, let’s create a seventh ConfigMap. Just like the sixth one, it’s going to
    contain a literal and a file, but this time, we’re going to create it declaratively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建第七个 ConfigMap。就像第六个一样，它将包含一个字面值和一个文件，但这次我们将以声明方式创建它。
- en: 'The YAML format allows you to use multiple lines with the | symbol. We’re using
    this syntax as part of our declaration file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 格式允许您使用 `|` 符号来表示多行。我们在声明文件中使用了这种语法：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s apply this YAML file to create our `configmap` with the `kubectl apply`
    command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `kubectl apply` 命令应用这个 YAML 文件来创建我们的 `configmap`：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s list the ConfigMaps in our cluster using `kubectl get cm` to make sure
    our seventh `configmap` has been created and contains two values. So let’s run
    the `kubectl get cm` command once more:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `kubectl get cm` 列出集群中的 ConfigMap，确保我们的第七个 `configmap` 已创建并包含两个值。所以我们再运行一次
    `kubectl get cm` 命令：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, let’s discover the last possible way to create a ConfigMap – that is, from
    an `env` file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们发现创建 ConfigMap 的最后一种可能方式——那就是从 `env` 文件创建。
- en: Creating a ConfigMap from an env file
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 env 文件创建 ConfigMap
- en: As you might guess, you can create a ConfigMap from an `env` file imperatively
    using the `--from-env-file` flag.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所料，您可以通过使用 `--from-env-file` 标志，从 `env` 文件中命令式地创建 ConfigMap。
- en: An `env` file is a `key=value` format file where each key is separated by a
    line break. This is a configuration format that’s used by some applications, so
    Kubernetes introduced a way to generate a ConfigMap from an existing `env` file.
    This is especially useful if you have an already existing application that you
    want to migrate into Kubernetes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`env` 文件是一种 `key=value` 格式的文件，每个键由换行符分隔。这是某些应用程序使用的配置格式，因此 Kubernetes 引入了一种从现有
    `env` 文件生成 ConfigMap 的方式。如果您有已经存在的应用程序，并希望将其迁移到 Kubernetes 中，这非常有用。'
- en: 'Here is a typical `env` file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个典型的 `env` 文件：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By convention, `env` files are named `.env`, but it’s not mandatory. So long
    as the file is formatted correctly, Kubernetes will be able to generate a ConfigMap
    based on the parameters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，`env` 文件命名为 `.env`，但这不是强制要求。只要文件格式正确，Kubernetes 就能基于参数生成 ConfigMap。
- en: 'You can use the following command to import the configuration in the `env`
    file as a ConfigMap into your Kubernetes cluster:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令将 `env` 文件中的配置作为 ConfigMap 导入到 Kubernetes 集群中：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Lastly, let’s list the ConfigMaps in our cluster to check that our new ConfigMap
    was created with three configuration values:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们列出集群中的 ConfigMap，以检查我们的新 ConfigMap 是否已创建，并包含三个配置值：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the new `configmap` is now available in the cluster, and it
    was created with the three parameters that were present in the `env` file. That’s
    a solid way to import your `env` files into Kubernetes ConfigMaps.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，新创建的 `configmap` 现在已在集群中可用，并且它是根据 `env` 文件中的三个参数创建的。这是将您的 `env` 文件导入 Kubernetes
    ConfigMap 的一种可靠方法。
- en: Remember that `ConfigMaps` are not meant to contain sensitive values. Data in
    ConfigMaps are not encoded, and that’s why you can view them with just a `kubectl
    describe cm` command. For anything that requires privacy, you’ll have to use the
    `Secret` object and not the `ConfigMap` one. It’s important to note that while
    `Secrets` themselves are not inherently encrypted by default, they are stored
    in the base64 format, offering a basic level of obfuscation. Additionally, with
    Kubernetes versions 1.27 and later, you can leverage Kubernetes **Key Management
    System** (**KMS**) plugin providers to encrypt data within both Secrets and ConfigMaps.
    This provides a more robust security layer for sensitive information.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`ConfigMap` 并不适合存储敏感值。ConfigMap 中的数据没有加密，这也是为什么你只需通过 `kubectl describe cm`
    命令就能查看它们。对于任何需要隐私保护的内容，你必须使用 `Secret` 对象，而不是 `ConfigMap` 对象。需要注意的是，尽管 `Secrets`
    本身默认并不加密，但它们以 base64 格式存储，提供了基本的混淆保护。此外，在 Kubernetes 1.27 及之后的版本中，你可以利用 Kubernetes
    **密钥管理系统**（**KMS**）插件提供者来加密 Secrets 和 ConfigMap 中的数据，这为敏感信息提供了更强大的安全层。
- en: Now, let’s discover how to read the values inside a ConfigMap.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探索如何读取 ConfigMap 中的值。
- en: Reading values inside a ConfigMap
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取 ConfigMap 中的值
- en: 'So far, we’ve only listed the ConfigMaps to see the number of keys in them.
    Let’s take this a little bit further: you can read actual data inside a ConfigMap,
    not just count the number of ConfigMaps. This is useful if you want to debug a
    ConfigMap or if you’re not confident about what kind of data is stored in them.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只列出了 ConfigMap 以查看其中的键的数量。让我们再进一步：你可以读取 ConfigMap 中的实际数据，而不仅仅是计数 ConfigMap
    的数量。如果你想调试 ConfigMap 或者对其存储的数据类型不确定，这非常有用。
- en: The data in a ConfigMap is not meant to be sensitive, so you can read and retrieve
    it easily from `kubectl`; it will be displayed in the terminal’s output.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 中的数据并非敏感数据，因此你可以轻松地通过 `kubectl` 阅读并获取它；它将在终端的输出中显示。
- en: 'You can read the value in a ConfigMap with the `kubectl describe` command.
    We will run this command against the `my-fourth-configmap` ConfigMap, since it’s
    the one that contains the most data. The output is quite big, but as you can see,
    the two pieces of configuration data are displayed clearly:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `kubectl describe` 命令来读取 ConfigMap 中的值。我们将针对 `my-fourth-configmap` 这个
    ConfigMap 运行此命令，因为它包含的数据最多。输出内容相当多，但正如你所看到的，两项配置信息被清晰地显示了出来：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `kubectl describe cm` command returns these kinds of results. Expect to
    receive results similar to this one and not results in a computer-friendly format,
    such as JSON or YAML.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl describe cm` 命令返回这些结果。你可以预期会收到类似于此的结果，而不是计算机友好的格式（如 JSON 或 YAML）的结果。'
- en: As the data is displayed clearly in the terminal output, keep in mind that any
    user of the Kubernetes cluster (with access to this ConfigMap) will be able to
    retrieve this data directly by typing the `kubectl describe cm` command, so be
    careful to not store any sensitive value in a ConfigMap.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据在终端输出中清晰显示，请记住，任何 Kubernetes 集群的用户（只要有访问该 ConfigMap 的权限）都能够通过输入 `kubectl
    describe cm` 命令直接获取这些数据，因此请小心不要在 ConfigMap 中存储任何敏感数据。
- en: Now, let’s discover how we can inject ConfigMap data into running Pods as environment
    variables.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探索如何将 ConfigMap 数据注入到正在运行的 Pods 作为环境变量。
- en: Linking ConfigMaps as environment variables
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 ConfigMap 作为环境变量链接
- en: In this section, we’re going to bring our ConfigMaps to life by linking them
    to Pods. First, we will focus on injecting ConfigMaps as environment variables.
    Here, we want the environment variables of a container within a Pod to come from
    the values of a ConfigMap.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过将 ConfigMap 链接到 Pods 来“赋予”它们生命。首先，我们将重点讲解如何将 ConfigMap 注入为环境变量。在这里，我们希望
    Pod 中容器的环境变量来自一个 ConfigMap 的值。
- en: 'You can do this in two different ways:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种不同的方式来实现：
- en: '**Injecting one or more given values in a given ConfigMap**: You can set the
    value of an environment variable based on the parameters contained in one or multiple
    ConfigMaps.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在给定的 ConfigMap 中注入一个或多个指定值**：你可以根据一个或多个 ConfigMap 中的参数设置环境变量的值。'
- en: '**Injecting all the values contained in a given ConfigMap**: You take one ConfigMap
    and inject all the values it contains into an environment at once. This way is
    good if you are creating one ConfigMap per Pod specification or application so
    that each app has a ConfigMap ready to be deployed.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注入一个 ConfigMap 中的所有值**：你可以将一个 ConfigMap 中包含的所有值一次性注入到环境中。如果你为每个 Pod 规范或应用程序创建一个
    ConfigMap，那么这种方式非常适合，这样每个应用程序就有一个准备好部署的 ConfigMap。'
- en: Please note that it’s impossible to link a ConfigMap to a Pod with the `kubectl`
    `imperative` method. The reason is that it’s impossible to create a Pod referencing
    a ConfigMap directly from the `kubectl run` command. You will have to write declarative
    YAML files to use your ConfigMaps in your Pods.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无法通过`kubectl`的`命令式`方法将 ConfigMap 链接到 Pod。原因是无法通过`kubectl run`命令直接创建引用 ConfigMap
    的 Pod。你必须编写声明式的 YAML 文件来在 Pod 中使用你的 ConfigMap。
- en: 'Earlier in this chapter, we created a ConfigMap called `my-third-configmap`
    that contains a parameter called `color`, with a value of `blue`. In this example,
    we will create a Pod with the `quay.io/iamgini/my-flask-app:1.0` image, and we
    will link `my-third-configmap` to the Pod so that the flask application container
    is created with an environment variable called `COLOR`, with a value set to `blue`,
    according to what we have in the ConfigMap. Here is the YAML manifest to achieve
    that. Pay attention to the `env:` key in the `container` spec:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们创建了一个名为`my-third-configmap`的 ConfigMap，它包含一个名为`color`的参数，值为`blue`。在这个示例中，我们将创建一个使用`quay.io/iamgini/my-flask-app:1.0`镜像的
    Pod，并将`my-third-configmap`链接到 Pod，使得 Flask 应用程序容器创建时，环境变量`COLOR`的值设置为`blue`，与我们在
    ConfigMap 中的设置一致。以下是实现这一目标的 YAML 清单。请注意`env:`键在`container`规范中的位置：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we can create this Pod using the `kubectl apply` command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`kubectl apply`命令创建这个 Pod：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that our application Pod has been created, let’s launch the `env` command
    inside the container to list all the environment variables that are available
    in the container. As you may have guessed, we will issue the `env` Linux command
    in this specific container by calling the `kubectl exec` command. Here is the
    command and the output to expect:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序 Pod 已经创建完成，让我们在容器内部运行`env`命令，列出容器中所有可用的环境变量。正如你可能猜到的，我们将在这个特定容器内通过调用`kubectl
    exec`命令来执行`env` Linux 命令。以下是命令及预期输出：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You should see the `COLOR` environment variable in the output if your ConfigMap
    has been linked to your Pod correctly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 ConfigMap 已正确链接到 Pod，你应该在输出中看到`COLOR`环境变量。
- en: 'You can also check the application deployed by exposing the Pod using a service,
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过暴露 Pod 使用服务来检查部署的应用程序，如下所示：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let’s test the application over a browser using the `kubectl port-forward` method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过浏览器使用`kubectl port-forward`方法来测试应用程序。
- en: 'You can start a `port-forward` to test the application, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以启动一个`port-forward`来测试应用程序，如下所示：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using kubectl port-forward
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 kubectl port-forward
- en: '`kubectl port-forward` creates a secure tunnel between your local machine and
    a specific Pod within a Kubernetes cluster. This allows you to access and interact
    with applications running inside the Pod as if they were running locally. It’s
    a valuable tool for debugging, testing, and development, providing direct access
    to services without external exposure.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl port-forward`在本地机器和 Kubernetes 集群中的特定 Pod 之间创建一个安全的隧道。这使得你可以像访问本地应用程序一样访问和与运行在
    Pod 内的应用程序进行交互。它是一个有价值的调试、测试和开发工具，提供对服务的直接访问，而无需外部暴露。'
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: While NodePort services are designed for external access, they can also be used
    in minikube environments. To access your application externally in this case,
    use the `minikube service` command to get the NodePort and corresponding IP address.
    For instance, the minikube service `--url flask-pod-with-configmap` might output
    `http://192.168.49.2:31997`, allowing you to access your Flask application at
    this URL.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 NodePort 服务是为外部访问设计的，但它们也可以在 minikube 环境中使用。在这种情况下，要外部访问你的应用程序，使用`minikube
    service`命令获取 NodePort 和相应的 IP 地址。例如，minikube 服务`--url flask-pod-with-configmap`可能会输出`http://192.168.49.2:31997`，从而允许你通过这个
    URL 访问你的 Flask 应用程序。
- en: Now, you can access the flask application over a web browser and can see the
    background with a BLUE color, as it was configured in the ConfigMap as `COLOR=blue`.
    You can change the value of `COLOR` in the ConfigMap and recreate the `flask-pod-with-configmap`
    Pod to see the changes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过网页浏览器访问 flask 应用程序，并看到背景为蓝色，因为它在 ConfigMap 中被配置为`COLOR=blue`。你可以更改 ConfigMap
    中`COLOR`的值并重新创建`flask-pod-with-configmap` Pod 来查看更改。
- en: We will learn more about Kubernetes services and DNS in *Chapter 8*, *Exposing
    Your Pods with Services*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第 8 章*，*通过服务暴露你的 Pods*中学习更多关于 Kubernetes 服务和 DNS 的内容。
- en: Please note that the `kubectl port-forward` will continue serving the forward
    until you end the command (e.g., by pressing the *Ctrl + C* keys).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`kubectl port-forward`会继续转发，直到你结束命令（例如，按下*Ctrl + C*键）。
- en: Now, we are going to discover the second way of injecting ConfigMaps as environment
    variables.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探索将 ConfigMap 作为环境变量注入的第二种方式。
- en: 'In this demo, we will link another ConfigMap, the one called `my-fourth-configmap`.
    This time, we don’t want to retrieve a single value in this ConfigMap but all
    the values inside of it instead. Here is the updated YAML Pod manifest. This time,
    we don’t use individual `env` keys but an `envFrom` key in our `container` spec
    instead:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将链接另一个 ConfigMap，名为`my-fourth-configmap`。这次，我们不打算获取该 ConfigMap 中的单个值，而是获取它里面的所有值。以下是更新后的
    YAML Pod 清单。这次，我们不使用单独的`env`键，而是使用`envFrom`键来代替：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once the manifest file is ready, you can recreate the NGINX Pod:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦清单文件准备好，你可以重新创建 NGINX Pod：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let’s run the `env` command once more in the `nginx` container, using
    the `kubectl exec` command to list the environment variables:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`nginx`容器中再次运行`env`命令，使用`kubectl exec`命令列出环境变量：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that the three parameters `– color`, `version`, and `environment` – that
    were declared in the `my-fourth-configmap` have been set as environment variables
    in the container, but this time, you don’t have control over how the environment
    variables are named in the container. Their names are directly inherited from
    the parameter key names in the ConfigMap.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`my-fourth-configmap`中声明的三个参数`– color`、`version`和`environment`已经作为环境变量设置在容器中，但这次，你无法控制环境变量在容器中的命名方式。它们的名称直接继承自
    ConfigMap 中的参数键名称。
- en: Now, it’s time to learn how to mount a ConfigMap as a volume in a container.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候学习如何将 ConfigMap 作为卷挂载到容器中了。
- en: Mounting a ConfigMap as a volume mount
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 ConfigMap 挂载为卷挂载
- en: Earlier in this chapter, we created two ConfigMaps that store dummy configuration
    files. `kubectl` allows you to mount a ConfigMap inside a Pod as a volume. This
    is especially useful when the ConfigMap contains the content of a file that you
    want to inject into a container’s filesystem.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们创建了两个存储虚拟配置文件的 ConfigMap。`kubectl` 允许你将 ConfigMap 作为卷挂载到 Pod 内部。当 ConfigMap
    包含你希望注入到容器文件系统中的文件内容时，这尤其有用。
- en: 'Just like when we inject environment variables, we need to do this imperatively
    using a YAML manifest file. Here, we are going to mount a ConfigMap called `my-sixth-configmap`
    as a volume mount to a new Pod, `flask-pod-with-configmap-volume`, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们注入环境变量时一样，我们需要通过 YAML 清单文件以命令式方式进行操作。在这里，我们将把名为`my-sixth-configmap`的 ConfigMap
    挂载为卷挂载到新的 Pod `flask-pod-with-configmap-volume`，如下所示：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we have declared a volume named `configuration volume` at the same level
    as the containers, and we have told Kubernetes that this volume was built from
    a ConfigMap. The referenced ConfigMap (here, `my-sixth-configmap`) must be present
    in the cluster when we apply this file. Then, at the container level, we mounted
    the volume we declared earlier on `path /etc/conf:`. The parameter in the ConfigMap
    should be present at the specified location.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为`configuration volume`的卷，它与容器处于同一层级，并且我们告诉 Kubernetes 这个卷是从 ConfigMap
    构建的。所引用的 ConfigMap（此处为`my-sixth-configmap`）在我们应用此文件时必须存在于集群中。然后，在容器级别，我们将之前声明的卷挂载到`/etc/conf:`路径上。ConfigMap
    中的参数应当出现在指定的位置。
- en: 'Let’s apply this file to create a new ConfigMap, with the volume attached to
    our cluster:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用这个文件来创建一个新的 ConfigMap，并将卷附加到我们的集群：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the `ls` command in the container to make sure that the directory has been
    mounted:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中运行`ls`命令，确保目录已经成功挂载：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, the directory has been successfully mounted, and both parameters that
    were created in the ConfigMap are available in the directory as plain files.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，目录已成功挂载，且在目录中创建的两个参数作为普通文件可用。
- en: 'Let’s run the `cat` command to make sure that both files hold the correct values:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行`cat`命令，确保这两个文件包含正确的值：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Good! Both files contain the values that were declared earlier when we created
    the ConfigMap! For example, you could store a virtual host NGINX configuration
    file and have it mounted to the proper directory, allowing NGINX to serve your
    website based on the configuration values hosted in a ConfigMap. That’s how you
    can override the default configuration and cleanly manage your app in Kubernetes.
    Now, you have a really strong and consistent interface to manage and configure
    the containers running in Kubernetes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！这两个文件包含了我们创建 ConfigMap 时之前声明的值！例如，你可以存储一个虚拟主机 NGINX 配置文件，并将其挂载到正确的目录，从而使
    NGINX 根据存储在 ConfigMap 中的配置值提供你的网站。这就是如何覆盖默认配置并在 Kubernetes 中干净地管理你的应用程序。现在，你拥有了一个非常强大且一致的界面来管理和配置运行在
    Kubernetes 中的容器。
- en: Next, we will learn how to delete and update a ConfigMap.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何删除和更新 ConfigMap。
- en: Deleting a ConfigMap
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除 ConfigMap
- en: 'Deleting a ConfigMap is very easy. However, be aware that you can delete a
    ConfigMap even if its values are used by a container. Once the Pod has been launched,
    it’s independent of the `configmap` object:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 删除 ConfigMap 非常简单。但是，请注意，即使容器正在使用 ConfigMap 的值，你也可以删除 ConfigMap。一旦 Pod 启动，它就与
    `configmap` 对象独立：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Regardless of whether the ConfigMap’s values are used by the container, it will
    be deleted as soon as this command is entered. Note that the ConfigMap cannot
    be recovered, so please think twice before removing a ConfigMap you have created
    imperatively, since you won’t be able to recreate it. Unlike declaratively created
    ConfigMaps, its content is not stored in any YAML file. But as we learned earlier,
    it is possible to collect the content of such resources in the YAML format by
    formatting the `kubectl get` commands – for example, `kubectl get cm <configmap-name>
    -o YAML > my-first-configmap.yaml`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 无论 ConfigMap 的值是否被容器使用，一旦输入此命令，它将立即被删除。请注意，ConfigMap 无法恢复，因此在删除你直接创建的 ConfigMap
    时请三思，因为你将无法重新创建它。与声明式创建的 ConfigMap 不同，它的内容不会存储在任何 YAML 文件中。但正如我们之前学到的，通过格式化 `kubectl
    get` 命令，仍然可以以 YAML 格式收集这些资源的内容——例如，`kubectl get cm <configmap-name> -o YAML >
    my-first-configmap.yaml`。
- en: Also, we recommend that you are careful when removing your ConfigMaps, especially
    if you delete ConfigMaps that are used by running Pods. If your Pod were to crash,
    you wouldn’t be able to relaunch it without updating the manifest file; the Pods
    would look for the missing ConfigMap you deleted.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们建议在删除 ConfigMap 时要小心，特别是当你删除正在运行的 Pod 使用的 ConfigMap。如果 Pod 崩溃了，在没有更新清单文件的情况下，你将无法重新启动它；Pods
    会寻找你删除的缺失的 ConfigMap。
- en: 'Let’s test this scenario with the `my-sixth-configmap` ConfigMap; delete the
    ConfigMap resource as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 `my-sixth-configmap` ConfigMap 测试这个场景；按照以下步骤删除 ConfigMap 资源：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, try relaunching the `flask-pod-with-configmap-volume` Pod (or recreate
    the Pod) to see the problem:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试重新启动 `flask-pod-with-configmap-volume` Pod（或重新创建 Pod）以查看问题：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You will see the Pod is in `ContainerCreating` and not in a `Running` state.
    Let’s check the details of the Pod as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到 Pod 处于 `ContainerCreating` 状态，而不是 `Running` 状态。让我们查看 Pod 的详细信息，如下所示：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Updating a ConfigMap
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 ConfigMap
- en: There are two primary methods to update a ConfigMap in Kubernetes. The first
    involves using the `kubectl apply` command with a modified ConfigMap definition
    file. This approach is ideal for version control and collaborative environments.
    Simply make the necessary changes to your ConfigMap YAML file and apply the updates
    using `kubectl apply`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，有两种主要方法可以更新 ConfigMap。第一种方法是使用 `kubectl apply` 命令与修改后的 ConfigMap
    定义文件。这种方法适用于版本控制和协作环境。只需对 ConfigMap YAML 文件进行必要的更改，并使用 `kubectl apply` 应用更新。
- en: Alternatively, you can directly edit an existing ConfigMap using the `kubectl
    edit` command. This provides an interactive way to modify the ConfigMap’s contents.
    However, be cautious when using this method, as it doesn’t involve version control.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以直接使用 `kubectl edit` 命令编辑现有的 ConfigMap。这为你提供了一种交互式的方式来修改 ConfigMap 的内容。但是，在使用此方法时要小心，因为它不涉及版本控制。
- en: Immutable ConfigMaps
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变 ConfigMap
- en: Kubernetes offers a feature called Immutable ConfigMaps to prevent accidental
    or intentional modifications to ConfigMap data. By marking a ConfigMap as immutable,
    you ensure that its contents remain unchanged.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了一个名为 Immutable ConfigMaps 的功能，以防止 ConfigMap 数据被意外或故意修改。通过将 ConfigMap
    标记为不可变，你可以确保它的内容保持不变。
- en: This feature is particularly beneficial for clusters heavily reliant on ConfigMaps,
    as it safeguards against configuration errors causing application disruptions.
    Additionally, it enhances cluster performance by reducing the load on the `kube-apiserver`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能对于高度依赖 ConfigMap 的集群特别有益，因为它可以防止配置错误导致应用程序中断。此外，通过减少 `kube-apiserver` 的负载，它还能提高集群性能。
- en: 'To create an immutable ConfigMap, simply set the immutable field to `true`
    within the ConfigMap definition, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个不可变的 ConfigMap，只需在 ConfigMap 定义中将 immutable 字段设置为 `true`，如下所示：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Once marked immutable, you cannot modify the ConfigMap’s data. If changes are
    necessary, you must delete the existing ConfigMap and create a new one. It’s essential
    to recreate any Pods referencing the deleted ConfigMap to maintain the correct
    configuration.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦标记为不可变，您就无法修改 ConfigMap 的数据。如果需要进行更改，您必须删除现有的 ConfigMap 并创建一个新的。为了保持正确的配置，必须重新创建所有引用已删除
    ConfigMap 的 Pods。
- en: In the next section of this chapter, we will learn about Kubernetes Secrets.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一节中，我们将学习 Kubernetes Secrets。
- en: Managing sensitive configuration with the Secret object
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Secret 对象管理敏感配置
- en: The Secret object is a resource that allows you to configure applications running
    on Kubernetes. Secrets are extremely similar to ConfigMaps and they can be used
    together. The difference is that Secrets are encoded and intended to store sensitive
    data such as passwords, tokens, or private API keys, while ConfigMaps are intended
    to host non-sensitive configuration data. Other than that, Secrets and ConfigMaps
    mostly behave the same.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Secret 对象是一个允许您配置运行在 Kubernetes 上的应用程序的资源。Secrets 与 ConfigMap 极为相似，并且可以一起使用。不同之处在于，Secrets
    被编码，用于存储敏感数据，如密码、令牌或私有 API 密钥，而 ConfigMap 用于存储非敏感配置数据。除此之外，Secrets 和 ConfigMap
    在大多数情况下的行为相同。
- en: 'To ensure the protection of sensitive information stored in Kubernetes Secrets,
    adhere to the following best practices:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 Kubernetes Secrets 中存储的敏感信息得到保护，请遵循以下最佳实践：
- en: '**Limit access**: Utilize **Role-Based Access Control** (**RBAC**) to restrict
    access to Secrets based on user roles and permissions. Grant only necessary privileges
    to individuals or services.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制访问**：利用 **基于角色的访问控制**（**RBAC**）来根据用户角色和权限限制对 Secrets 的访问。仅授予个人或服务必要的权限。'
- en: '**Avoid hardcoding secrets**: Never embed Secrets directly within your application
    code or configuration files.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免硬编码密钥**：绝不将 Secrets 直接嵌入到应用程序代码或配置文件中。'
- en: '**Rotate secrets regularly**: Implement a regular rotation schedule for Secrets
    to mitigate the risk of unauthorized access.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定期轮换密钥**：为 Secrets 实施定期轮换计划，以降低未授权访问的风险。'
- en: '**Consider external secret management**: For advanced security requirements,
    explore dedicated secret management solutions like HashiCorp Vault or AWS Secrets
    Manager.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑外部秘密管理**：对于高级安全需求，探索像 HashiCorp Vault 或 AWS Secrets Manager 这样的专用秘密管理解决方案。'
- en: '**Leverage encryption**: Utilize KMS plugins to encrypt Secrets data at rest,
    providing an additional layer of protection.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用加密**：使用 KMS 插件对 Secrets 数据进行静态加密，提供额外的保护层。'
- en: '**Monitor and audit**: Regularly review access logs and audit trails to detect
    suspicious activity and potential security breaches.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和审计**：定期审查访问日志和审计轨迹，以检测可疑活动和潜在的安全漏洞。'
- en: '**Educate your team**: Foster a security-conscious culture by providing training
    on the best practices for handling and managing Secrets.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**教育您的团队**：通过提供有关处理和管理 Secrets 的最佳实践的培训，培养安全意识文化。'
- en: While Secrets are used to store sensitive information and their data is encoded
    in base64, this encoding alone does not guarantee strong security. Base64 is a
    reversible encoding format, meaning that the original data can be recovered easily.
    For robust protection of sensitive information, consider additional security measures,
    such as encryption at rest using KMS plugins or external secret management solutions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Secrets 用于存储敏感信息并且其数据是以 base64 编码的，但仅凭编码并不能保证强大的安全性。Base64 是一种可逆编码格式，这意味着原始数据可以轻易恢复。为了更好地保护敏感信息，请考虑采用额外的安全措施，如使用
    KMS 插件进行静态加密或外部的秘密管理解决方案。
- en: While Secrets are primarily used to store sensitive data, Kubernetes offers
    additional security measures. With the introduction of the **Key Management Service**
    (**KMS**) plugin providers, you can now encrypt data within both Secrets and ConfigMaps.
    This provides an extra layer of protection for sensitive information stored in
    ConfigMaps, making them more secure.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Secrets 主要用于存储敏感数据，但 Kubernetes 提供了额外的安全措施。通过引入**密钥管理服务**（**KMS**）插件提供者，现在你可以在
    Secrets 和 ConfigMaps 中加密数据。这为存储在 ConfigMaps 中的敏感信息提供了额外的保护层，使它们更加安全。
- en: By utilizing KMS encryption for ConfigMaps, you can safeguard sensitive configuration
    data without resorting to Secrets. This approach simplifies configuration management
    while maintaining a high level of security.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对 ConfigMaps 使用 KMS 加密，你可以在不依赖 Secrets 的情况下保护敏感的配置数据。这种方法简化了配置管理，同时保持了高水平的安全性。
- en: Even with KMS encryption, it’s essential to carefully consider the sensitivity
    of the data stored in ConfigMaps. For highly confidential information, Secrets
    remain the recommended option.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用了 KMS 加密，仍然需要仔细考虑存储在 ConfigMaps 中数据的敏感性。对于高度机密的信息，Secrets 依然是推荐的选项。
- en: Refer to the documentation ([https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/](https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/))
    to learn more about the KMS provider for data encryption.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅文档（[https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/](https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/)）了解有关数据加密的
    KMS 提供者的更多信息。
- en: Let’s start by discovering how to list the Secrets that are available in your
    Kubernetes cluster.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解如何列出 Kubernetes 集群中可用的 Secrets 开始。
- en: Listing Secrets
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出 Secrets
- en: 'Like any other Kubernetes resource, you can list secrets using the `kubectl
    get` command. The resource identifier is a Secret here:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他 Kubernetes 资源一样，你可以使用 `kubectl get` 命令来列出 Secrets。这里的资源标识符是 Secret：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Just like with ConfigMaps, the `DATA` column tells you the number of sensitive
    parameters that have been hashed and saved in your `secret`. When executed, `kubectl`
    might display a few default Secrets or issue an error, stating that no resources
    were found. This discrepancy arises because certain cloud services generate default
    Secrets for internal processes, while others do not. The presence or absence of
    these default ConfigMaps depends on the environment in which your Kubernetes cluster
    is deployed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ConfigMaps 一样，`DATA` 列告诉你已被哈希并保存到 `secret` 中的敏感参数数量。当执行时，`kubectl` 可能会显示一些默认的
    Secrets 或报错，表示没有找到资源。这种差异出现的原因是某些云服务为内部流程生成默认的 Secrets，而其他云服务则没有。这些默认 ConfigMaps
    的存在与否取决于 Kubernetes 集群的部署环境。
- en: Creating a Secret imperatively with --from-literal
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 --from-literal 创建一个 Secret（命令式方式）
- en: 'You can create a Secret imperatively or declaratively – both methods are supported
    by Kubernetes. Let’s start by discovering how to create a Secret imperatively.
    Here, we want to store a database password, `my-db-password`, in a Secret object
    in our Kubernetes cluster. You can achieve that imperatively with `kubectl` by
    adding the `--from-literal` flag to the `kubectl create secret` command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以命令式或声明式地创建一个 Secret —— 两种方式都被 Kubernetes 支持。让我们从了解如何命令式地创建一个 Secret 开始。在这里，我们想将数据库密码
    `my-db-password` 存储在 Kubernetes 集群中的一个 Secret 对象中。你可以通过将 `--from-literal` 标志添加到
    `kubectl create secret` 命令中来命令式地实现这一点：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, run the `kubectl get secrets` command to retrieve the list of Secrets
    in your Kubernetes cluster. The new Secret should be displayed:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行 `kubectl get secrets` 命令，获取 Kubernetes 集群中 Secrets 的列表。新创建的 Secret 应该会显示出来：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let’s see the details of the Secret using the YAML output format, as shown
    below:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 YAML 输出格式查看 Secret 的详细信息，如下所示：
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You will see `data` with the `db_password: bXktZGItcGFzc3dvcmQ= line`, where
    the password is stored in an encoded format.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '你将看到包含`db_password: bXktZGItcGFzc3dvcmQ=`行的`data`，其中密码以编码格式存储。'
- en: Now, let’s figure out how to create a Secret declaratively.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来了解如何声明式地创建一个 Secret。
- en: Creating a Secret declaratively with a YAML file
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 YAML 文件声明式地创建一个 Secret
- en: Secrets can be created declaratively using YAML files. While it’s possible to
    manually encode secret values as base64 for the `data` field, Kubernetes provides
    a more convenient approach. The `stringData` field allows you to specify secret
    values as plain text strings. Kubernetes automatically encodes these values into
    the base64 format when creating the Secret. This method simplifies the process
    and helps prevent accidental exposure of sensitive data in plain text configuration
    files.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 YAML 文件声明性地创建 Secrets。虽然可以手动将秘密值编码为 base64 并放入 `data` 字段，但 Kubernetes
    提供了更方便的方法。`stringData` 字段允许你将秘密值指定为明文字符串。Kubernetes 在创建 Secret 时会自动将这些值编码为 base64
    格式。这种方法简化了过程，并帮助防止敏感数据在明文配置文件中被意外暴露。
- en: 'Note: While base64 encoding offers basic obfuscation, it’s essential to remember
    that it’s not a strong encryption method. For heightened security, consider using
    KMS plugins or external secret management solutions.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：虽然 base64 编码提供了基本的混淆功能，但必须记住，它并不是一种强加密方法。为了提高安全性，考虑使用 KMS 插件或外部的秘密管理解决方案。
- en: When you use `--from-literal`, Kubernetes will encode your strings in base64
    itself, but when you create a Secret from a YAML manifest file, you will have
    to handle this step yourself.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `--from-literal` 时，Kubernetes 会自动将字符串编码为 base64，但如果你从 YAML 清单文件创建 Secret，你需要自己处理这一步。
- en: 'So let’s start by converting the `my-db-password` string into `base64`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们从将 `my-db-password` 字符串转换为 `base64` 开始：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`bXktZGItcGFzc3dvcmQ=` is the `base64` representation of the `my-db-password`
    string, and that’s what we will need to write in our YAML file. Here is the content
    of the YAML file to create the Secret object properly:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`bXktZGItcGFzc3dvcmQ=` 是 `my-db-password` 字符串的 `base64` 表示形式，这也是我们需要写入 YAML
    文件中的内容。以下是正确创建 Secret 对象的 YAML 文件内容：'
- en: '[PRE47]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once this file has been stored on your system, you can create the `secret`
    using the `kubectl apply` command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个文件存储在你的系统上，你可以使用 `kubectl apply` 命令创建 `secret`：
- en: '[PRE48]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can make sure that the `secret` has been created properly by listing the
    secrets, with details, in our Kubernetes cluster:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 Kubernetes 集群中列出所有 secrets 及其详细信息，来确保 `secret` 已正确创建：
- en: '[PRE49]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, let’s create the same Secret with `stringData` so that we do not need
    to encode it manually. Create a new YAML file as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用 `stringData` 来创建相同的 Secret，这样我们就不需要手动编码它。创建一个新的 YAML 文件，如下所示：
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note the password in plain text instead of encoded text.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意密码是以明文形式而不是编码后的文本形式出现。
- en: 'Create the Secret from the file as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，从文件中创建 Secret：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Verify the secret content and compare it with the Secret `my-second-secret`
    to see the encoded content:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 secret 内容并将其与 Secret `my-second-secret` 进行比较，以查看编码后的内容：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You will notice that the `stringData` is already encoded and stored under the
    `data` section.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，`stringData` 已经被编码并存储在 `data` 部分。
- en: 'Now, let’s discover another Kubernetes feature: the ability to create a Secret
    with values from a file.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们发现 Kubernetes 的另一个功能：从文件中创建 Secret 的能力。
- en: Creating a Secret with content from a file
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文件内容创建 Secret
- en: 'We can create a Secret with values from a file, the same as we did with ConfigMaps.
    We start by creating a file that will contain our secret value. Let’s say that
    we have to store a password in a file and import it as a Secret object in Kubernetes:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像使用 ConfigMaps 一样，通过文件中的值来创建一个 Secret。我们首先创建一个包含秘密值的文件。假设我们需要将密码存储在文件中，并将其作为
    Secret 对象导入 Kubernetes 中：
- en: '[PRE53]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: After running this command, we have a file called `password.txt` that contains
    a string called `mypassword`, which is supposed to be our Secret value. The `-n`
    flag is used here to ensure that `password.txt` does not contain any extra blank
    lines at the end of the text.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这个命令后，我们会得到一个名为 `password.txt` 的文件，里面包含一个名为 `mypassword` 的字符串，它应该是我们的 Secret
    值。`-n` 标志用于确保 `password.txt` 文件末尾没有额外的空白行。
- en: 'Now, let’s run the `kubectl create secret` command by passing the location
    of `password.txt` to the `--from-file` flag. This will result in a new `secret`,
    containing a `base64` representation of the `mypassword` string being created:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过传递 `password.txt` 的位置给 `--from-file` 标志来运行 `kubectl create secret` 命令。这样将创建一个新的
    `secret`，其中包含 `mypassword` 字符串的 `base64` 表示形式：
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This new `secret` is now available in your Kubernetes cluster! Now, let’s learn
    how to read a Kubernetes Secret.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的 `secret` 现在在你的 Kubernetes 集群中可用！接下来，我们来学习如何读取 Kubernetes Secret。
- en: Reading a Secret
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取一个 Secret
- en: 'As observed, Secrets are supposed to host sensitive data, and, as such, the
    `kubectl` output won’t show you the secret decoded data to ensure confidentiality.
    You’ll simply have to decode it yourself to understand. Why is this confidentiality
    maintained? Let’s take a look:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如观察到的，Secrets 应该托管敏感数据，因此，`kubectl` 输出不会显示密钥的解码数据，以确保机密性。你必须自己解码才能理解。为什么要保持这种机密性呢？我们来看一下：
- en: To prevent the secret from being accidentally opened by someone who shouldn’t
    be able to open it.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了防止密钥被不应有权限的人意外打开。
- en: To prevent the secret from being displayed as part of a terminal output, which
    could result in it being logged somewhere.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了防止密钥作为终端输出的一部分显示，这可能导致它被记录到某个地方。
- en: While base64 encoding obfuscates secret data, it doesn’t provide strong encryption.
    Any user with API access to the Kubernetes cluster can retrieve and decode a Secret.
    To protect sensitive information, implement RBAC to restrict access to Secrets
    based on user roles and permissions. By carefully defining RBAC rules, you can
    limit who can view, modify, or delete Secrets, enhancing the overall security
    of your cluster.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Base64 编码使密钥数据变得模糊，但它并不提供强加密。任何拥有 API 访问权限的用户都可以检索并解码 Secret。为了保护敏感信息，实施
    RBAC 来根据用户角色和权限限制对 Secrets 的访问。通过精确定义 RBAC 规则，你可以限制谁可以查看、修改或删除 Secrets，从而增强集群的整体安全性。
- en: Because of these securities, you simply won’t be able to retrieve the actual
    content of a secret, but you can still grab information about its size, and so
    on.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些安全性措施，你将无法检索到密钥的实际内容，但仍然可以获取有关其大小等信息。
- en: 'You can do this using the `kubectl describe` command, just like we did earlier
    for ConfigMaps. As we mentioned previously, ConfigMaps and Secrets are very similar;
    they almost behave the same:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像我们之前对 ConfigMaps 做的那样，使用 `kubectl describe` 命令来查看。正如我们之前提到的，ConfigMaps 和
    Secrets 非常相似；它们几乎表现得一样：
- en: '[PRE55]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Do not get confused if your output is a little different than this one. If you
    receive something similar, it means that the new secret is available in your Kubernetes
    cluster and that you successfully retrieved its data!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的输出与此稍有不同，请不要感到困惑。如果你收到类似的内容，说明新的密钥已经在你的 Kubernetes 集群中可用，并且你成功地检索到了它的数据！
- en: 'However, also remember that the encoded data can be visible using the `kubectl`
    and YAML output format, as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也要记住，编码后的数据可以通过 `kubectl` 和 YAML 输出格式显示，如下所示：
- en: '[PRE56]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And anyone with access to this Secret can decode the data, as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 任何有权限访问此 Secret 的人都可以解码数据，如下所示：
- en: '[PRE57]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: IMPORTANT
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Base64 encoding is not encryption; it is simply a way to represent binary data
    in ASCII characters. While it makes the data look less readable, it’s not encryption.
    Anyone with the knowledge and tools can easily decode it back to plain text. To
    safeguard Secrets effectively, combine base64 encoding with additional security
    controls like RBAC and encryption, or consider using external secret management
    solutions.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Base64 编码并不是加密；它仅仅是一种将二进制数据表示为 ASCII 字符的方式。虽然它使数据看起来不那么容易读取，但这并不是加密。任何具备相应知识和工具的人都可以轻松地将其解码回纯文本。为了有效保护
    Secrets，可以将 Base64 编码与额外的安全控制措施（如 RBAC 和加密）结合使用，或者考虑使用外部密钥管理解决方案。
- en: Now that we’ve explored the creation and management of Secrets, let’s delve
    into how to make this sensitive information accessible to our applications within
    Pods.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何创建和管理 Secrets，让我们深入了解如何使这些敏感信息在 Pods 中的应用程序可以访问。
- en: Consuming a Secret as an environment variable
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将密钥作为环境变量进行使用
- en: 'We’ve seen how we can inject the values of a ConfigMap into a Pod in the form
    of environment variables, and we can do the same with Secrets. Returning to the
    example with our NGINX container, we are going to retrieve the `db_password` value
    of the `my-first-secret` Secret and inject it as an environment variable into
    the Pod. Here is the YAML manifest. Again, everything occurs under the `env:`
    key:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何将 ConfigMap 的值作为环境变量注入到 Pod 中，我们也可以对 Secrets 做同样的操作。回到我们 NGINX 容器的例子中，我们将检索
    `my-first-secret` Secret 的 `db_password` 值，并将其作为环境变量注入到 Pod 中。以下是 YAML 清单。同样，所有操作都发生在
    `env:` 键下：
- en: '[PRE58]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, you can apply this file using the `kubectl apply` command:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 `kubectl apply` 命令来应用这个文件：
- en: '[PRE59]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, run the `env` command to list the environment variables in your container:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行 `env` 命令来列出容器中的环境变量：
- en: '[PRE60]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, the `my-db-password` string is available as the environment
    variable `PASSWORD_ENV_VAR`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`my-db-password` 字符串作为环境变量 `PASSWORD_ENV_VAR` 可用。
- en: Another way to find out details about a Secret is by using the `envFrom` YAML
    key. When using this key, you’ll read all the values from a Secret and get them
    as environment variables in the Pod all at once. It works the same as for the
    ConfigMap object.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 Secret 详细信息的另一种方法是使用 `envFrom` YAML 键。使用此键时，您将从 Secret 中读取所有值，并将它们作为环境变量一次性加载到
    Pod 中。其工作原理与 ConfigMap 对象相同。
- en: For a Pod to start successfully, the referenced Secret must exist unless explicitly
    marked as optional within the Pod definition. Ensure that the Secret is created
    before deploying Pods that depend on it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Pod 成功启动，引用的 Secret 必须存在，除非在 Pod 定义中明确标记为可选。请确保在部署依赖于该 Secret 的 Pod 之前先创建该
    Secret。
- en: 'Create a Secret first by using the following YAML with the `envFrom` sample:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 先通过使用以下 YAML 和 `envFrom` 示例创建一个 Secret：
- en: '[PRE61]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here is the preceding example of a Pod but updated with an `envFrom` key:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个之前的 Pod 示例，但已使用 `envFrom` 键进行了更新：
- en: '[PRE63]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create the Pod using the `kubectl apply` command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl apply` 命令创建 Pod：
- en: '[PRE64]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Using this, all the keys in the Secret object will be used as environment variables
    within the Pod. Let us verify the environment variables inside the Pod to ensure
    that the variables from the Secret object are loaded properly:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，Secret 对象中的所有键都将作为 Pod 中的环境变量使用。让我们验证 Pod 中的环境变量，以确保 Secret 对象中的变量已正确加载：
- en: '[PRE65]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that if a key name cannot be used as an environment variable name, then
    it will be simply ignored!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果某个键名不能作为环境变量名使用，它将被忽略！
- en: Now, let’s learn how to consume a secret as a volume mount in the next section.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一节学习如何将 Secret 作为卷挂载使用。
- en: Consuming a Secret as a volume mount
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Secret 作为卷挂载使用
- en: You can mount Secrets as a volume for your Pods, but you can only do so declaratively.
    So you’ll have to write YAML files to do this successfully.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 Secrets 作为卷挂载到 Pod 中，但只能以声明方式进行。因此，您必须编写 YAML 文件才能成功实现这一点。
- en: 'You must start from a YAML manifest file that will create a Pod. Here is a
    YAML file that mounts a Secret called `mypassword` in the `/etc/passwords-mounted-path`
    location:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须从一个 YAML 清单文件开始，该文件将创建一个 Pod。以下是一个挂载名为 `mypassword` 的 Secret 到 `/etc/passwords-mounted-path`
    路径的 YAML 文件：
- en: '[PRE66]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once you have created this file on your filesystem, you can apply the YAML
    file using `kubectl`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在文件系统中创建了此文件，可以使用 `kubectl` 应用 YAML 文件：
- en: '[PRE67]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Please make sure that the `my-second-secret` exists before you attempt to create
    the Secret.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试创建 Secret 之前，请确保`my-second-secret`已存在。
- en: 'Finally, you can run a command inside `flask-with-secret`, using the `kubectl
    exec` command, to check if the volume containing the Secret was set up correctly:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以在 `flask-with-secret` 中运行一个命令，使用 `kubectl exec` 命令，检查包含 Secret 的卷是否已正确设置：
- en: '[PRE68]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As you can see, the `my-db-password` string is displayed correctly; the Secret
    was correctly mounted as a volume!
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`my-db-password` 字符串已正确显示；Secret 已成功挂载为卷！
- en: Now that we have learned how to create a Secret in Kubernetes and use it with
    a Pod in multiple methods, let’s learn how to delete and update Secrets in the
    next section.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何在 Kubernetes 中创建 Secret，并通过多种方法将其与 Pod 配合使用，让我们在下一节学习如何删除和更新 Secrets。
- en: Deleting a Secret
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除一个 Secret
- en: 'Deleting a secret is very simple and can be done via the `kubectl delete` command:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个 Secret 非常简单，可以通过 `kubectl delete` 命令完成：
- en: '[PRE69]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, let’s learn how to update an existing secret in a Kubernetes cluster.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何在 Kubernetes 集群中更新一个现有的 Secret。
- en: Updating a Secret
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新一个 Secret
- en: To update a Secret in Kubernetes, you can use the `kubectl apply` command with
    a modified Secret definition or by using the `kubectl edit` command.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新 Kubernetes 中的 Secret，您可以使用 `kubectl apply` 命令并修改 Secret 定义，或使用 `kubectl
    edit` 命令。
- en: Kubernetes Secrets provide a secure way to store and manage sensitive information
    like passwords, API keys, and certificates. Unlike ConfigMaps, Secrets are encoded
    to protect data confidentiality. This section explored how to create Secrets both
    imperatively and declaratively using YAML. You learned how to inject Secrets into
    Pods using environment variables and volume mounts, enabling applications to access
    sensitive data without exposing it in plain text.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Secrets 提供了一种安全存储和管理敏感信息（如密码、API 密钥和证书）的方法。与 ConfigMaps 不同，Secrets
    是经过编码的，以保护数据的机密性。本节介绍了如何使用 YAML 命令和声明性方法创建 Secrets。您学习了如何通过环境变量和卷挂载将 Secrets 注入
    Pod，从而使应用程序能够访问敏感数据，而无需以明文形式暴露。
- en: Summary
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter delved into the fundamental concepts of managing configuration
    within Kubernetes. We explored the critical distinction between ConfigMaps and
    Secrets, understanding their respective roles in handling non-sensitive and sensitive
    data. By effectively utilizing these Kubernetes resources, you can significantly
    enhance application portability and security.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了 Kubernetes 配置管理的基本概念。我们研究了 ConfigMap 和 Secrets 之间的关键区别，了解了它们在处理非敏感数据和敏感数据方面的各自作用。通过有效利用这些
    Kubernetes 资源，您可以显著增强应用程序的可移植性和安全性。
- en: We learned how to create and manage both ConfigMaps and Secrets, employing both
    imperative and declarative approaches. You discovered how to inject configuration
    data into Pods using environment variables and volume mounts, ensuring seamless
    access to application settings.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何创建和管理 ConfigMap 和 Secrets，采用了命令式和声明式方法。您还了解了如何通过环境变量和卷挂载将配置信息注入到 Pods
    中，确保应用程序设置的无缝访问。
- en: To protect sensitive information, we emphasized the importance of implementing
    robust security measures beyond base64 encoding. By combining RBAC, encryption,
    and external secret management solutions, you can significantly strengthen the
    security posture of your Kubernetes environment.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护敏感信息，我们强调了实施强大安全措施的重要性，超越了仅使用 base64 编码。通过结合 RBAC、加密和外部机密管理解决方案，您可以显著增强
    Kubernetes 环境的安全性。
- en: By mastering the concepts presented in this chapter, you’ll be well-equipped
    to build resilient and secure Kubernetes applications that are decoupled from
    their configuration, promoting flexibility and maintainability. In the next chapter,
    we will continue discovering Kubernetes by tackling another central concept of
    Kubernetes, which is Services. Services are Kubernetes objects that allow you
    to expose your Pods to not only each other but also the internet. This is a very
    important network concept for Kubernetes, and mastering it is essential to use
    the orchestrator correctly. Fortunately, mastering Services is not very complicated,
    and the next chapter will explain how to achieve this. You will learn how to associate
    the ports of a container with the ports of the worker node it is running on, and
    also how to associate a static IP with your Pods so that they can always be reached
    at the same address by other Pods in the cluster.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握本章介绍的概念，您将能够构建具有弹性和安全性的 Kubernetes 应用程序，这些应用程序与配置解耦，从而促进灵活性和可维护性。在下一章中，我们将继续探索
    Kubernetes，介绍 Kubernetes 的另一个核心概念——服务。服务是 Kubernetes 对象，允许您将 Pods 暴露给彼此以及互联网。这是
    Kubernetes 中一个非常重要的网络概念，掌握它对于正确使用 Kubernetes 至关重要。幸运的是，掌握服务并不复杂，下一章将讲解如何实现这一点。您将学习如何将容器的端口与其运行的工作节点的端口关联，以及如何将静态
    IP 地址与 Pods 关联，以便其他集群中的 Pods 始终可以通过相同的地址访问它们。
- en: Further reading
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'ConfigMaps: [https://kubernetes.io/docs/concepts/configuration/configmap/](https://kubernetes.io/docs/concepts/configuration/configmap/)'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ConfigMap：[https://kubernetes.io/docs/concepts/configuration/configmap/](https://kubernetes.io/docs/concepts/configuration/configmap/)
- en: 'Configure a Pod to Use a ConfigMap: [https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/)'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Pod 使用 ConfigMap：[https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/)
- en: 'Managing Secrets using kubectl: [https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-kubectl/](https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-kubectl/)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 kubectl 管理机密：[https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-kubectl/](https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-kubectl/)
- en: 'Managing Secrets using Configuration File: [https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-config-file/](https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-config-file/)'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用配置文件管理机密：[https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-config-file/](https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-config-file/)
- en: 'Using a KMS provider for data encryption: [https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/](https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/)'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 KMS 提供程序进行数据加密：[https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/](https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/)
- en: 'The security aspect of Secrets as well as compliance and DevOps practices:
    Kubernetes Secrets Handbook: Design, implement, and maintain production-grade
    Kubernetes Secrets management solutions: [https://www.amazon.com/Kubernetes-Secrets-Handbook-production-grade-management/dp/180512322X/](https://www.amazon.com/Kubernetes-Secrets-Handbook-production-grade-management/dp/180512322X/)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Secrets的安全性，以及合规性和DevOps实践：Kubernetes Secrets 手册：设计、实现和维护生产级 Kubernetes Secrets
    管理解决方案：[https://www.amazon.com/Kubernetes-Secrets-Handbook-production-grade-management/dp/180512322X/](https://www.amazon.com/Kubernetes-Secrets-Handbook-production-grade-management/dp/180512322X/)
- en: Join our community on Discord
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们在 Discord 上的社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
- en: '![](img/QR_Code119001106479081656.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code119001106479081656.png)'
