<html><head></head><body>
		<div id="_idContainer103">
			<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/><em class="italic">Chapter 8</em>: Knowing the Trade-offs</h1>
			<p>In the previous few chapters, we learned a lot about Crossplane, from its basics to many advanced patterns. Also, we introduced the idea of a unified approach to both application and infrastructure automation. This chapter will step back to analyze and approach configuration management for unified automation holistically. The chapter is heavily influenced by the white paper <em class="italic">Declarative application management in Kubernetes</em> (<a href="https://goo.gl/T66ZcD">https://goo.gl/T66ZcD</a>) by Brian Grant, a Kubernetes Steering Committee emeritus. The white paper mainly covers<a id="_idIndexMarker448"/> the <strong class="bold">Kubernetes Resource Model</strong> (<strong class="bold">KRM</strong>). We will cover the topics in this chapter from the KRM <a id="_idIndexMarker449"/>and <strong class="bold">Crossplane Resource Model</strong> (<strong class="bold">XRM</strong>) perspectives. The chapter will define the scope of the unified automation approach. It will continue by looking into many more concepts, such as the tools available, common pitfalls along the way, and the trade-off in using different patterns. In a way, it’s a revisit of the API boundaries discussion from <a href="B17830_06_ePub.xhtml#_idTextAnchor092"><em class="italic">Chapter 6</em></a>, in more detail.</p>
			<p>The following are the topics covered in the chapter:</p>
			<ul>
				<li>Unified automation scope</li>
				<li>Complexity clock, requirements, and patterns</li>
				<li>Open Application Model</li>
				<li>Specialized and extendable abstraction </li>
				<li>Impact of change frequency</li>
			</ul>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/>Unified automation scope</h1>
			<p>Most of us will have <a id="_idIndexMarker450"/>different perceptions of what we mean by unified application and infrastructure automation. This section will help us understand the scope with a bit more clarity. Any application/product that we deploy is mostly a combination of custom-developed bespoke<a id="_idIndexMarker451"/> applications and <strong class="bold">common off-the-shelf</strong> (<strong class="bold">COTS</strong>) components. The term bespoke application means custom-written software for our requirements with a specific purpose. Bespoke applications are generally stateless, containerized workloads. From the perspective of Kubernetes, they are workloads that run on Pods, the basic unit of computing in Kubernetes. COTS components are generally stateful infrastructure components, such as databases, cache systems, storage systems, and messaging systems. In the <a id="_idIndexMarker452"/>cloud-native era, most COTS components are black-box, fully managed <strong class="bold">software as a service</strong> (<strong class="bold">SaaS</strong>) or <strong class="bold">platform as a service</strong> (<strong class="bold">PaaS</strong>). COTS <a id="_idIndexMarker453"/>vendors expose CRUD APIs to work with the resource with precise configuration knobs for security, scaling, monitoring, and updating concerns. These specific configuration knobs will support different use<a id="_idIndexMarker454"/> cases from consumers. When we talk about unified application and infrastructure automation, it’s an approach to use the same set of tools, processes, and patterns to configure both bespoke applications and COTS deployment. In other words, bespoke applications can follow KRM standards, and COTS dependencies can comply with XRM standards, an extension of KRM. There <a id="_idIndexMarker455"/>are many advantages to such unification:</p>
			<ul>
				<li>In the modern software engineering discipline, the product teams are vertically sliced to bring maximum delivery velocity. These vertically sliced teams own both bespoke applications and their dependent COTS components. Unified tooling, processes, and patterns will significantly reduce the cognitive load.</li>
				<li>It can bring down the need for specialized teams to manage COTS components, accelerating the delivery velocity further.</li>
				<li>The configuration data for policies in bespoke applications and their COTS dependencies can be quite simple. We can validate policies such as architecture fitness functions, security concerns, and compliance standards in a single place and format.</li>
				<li>All COTS vendors can offer KRM-compliant APIs (MRs) as a universal application dependency and integration standard. It is already happening with Crossplane providers for all primary cloud resources. The list is growing to cover other external resources, such as Git Lab, Argo CD, Rook, and Cloudflare, to cover end-to-end automation.</li>
			</ul>
			<p>The following section will cover a few requirements, patterns, and tools for approaching unified automation.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor132"/>Complexity clock, requirements, and patterns</h1>
			<p>The configuration complexity clock is a concept that explains how configuration management can become complex over time. It explores different stages in the evolution of configuration management, its use cases, and its pitfalls. It was initially discussed from the <a id="_idIndexMarker456"/>perspective of application configuration in the blog post found here: <a href="http://mikehadlow.blogspot.com/2012/05/configuration-complexity-clock.html">http://mikehadlow.blogspot.com/2012/05/configuration-complexity-clock.html</a>. We will look at the same concept from the Kubernetes configuration management perspective.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>The configuration complexity clock</h2>
			<p>Let’s say we are <a id="_idIndexMarker457"/>deploying our first application workload into Kubernetes. To start with, every Kubernetes artifact, such as Deployment, Service, and Ingress, can be managed as individual configuration artifacts. It may not be an issue when we operate on a tiny scale. But soon we will realize that there is an issue with consistently performing releases and rollbacks as the application configuration is spread over multiple Kubernetes resources. We will start thinking about packaging and release management tools such as Helm. Helm is a<a id="_idIndexMarker458"/> template-based configuration management tool. We will parameterize values with variables to enable configuration abstraction and expose only limited attributes. A typical example is setting the replica count for every deployment target (production and staging). Soon, the organization will realize the power of Kubernetes and decide to deploy further similar workloads in the Kubernetes ecosystem. As the configuration data for the new application looks identical to the initial Helm template, we will choose to parametrize more variables to support multiple applications with the same Helm template. It will be an excellent way to push the reuse agenda and minimize the configuration to maintain. A typical example of such new parameters would be a namespace, labels, and an application name.</p>
			<p>Again, the organization will realize more benefits from Kubernetes and decide to experiment with a few new workloads. These workloads may have similar configuration data to the initial Helm template with minor customization. We would decide to fork the main Helm template to do the required customization. Template-based abstractions are complex to reuse when customization is required. After a certain length of time of the configuration clock running, we will see too many forks that are difficult to keep in sync. On the other side, many individual templates would have introduced new parameters to support new local use cases. This is a leak in the abstraction we created with the Helm templates. We would have parameterized all values and completely eroded abstraction as the clock ticks further. Have a look <a id="_idIndexMarker459"/>at this WordPress chart as an example: <a href="https://github.com/helm/charts/tree/master/stable/wordpress">https://github.com/helm/charts/tree/master/stable/wordpress</a>. The number of parameters has increased slowly into multiple folds from the initial commit. Entirely eroded templates are complex to read, and end users will find it challenging to understand the usage of each parameter. Users will find it challenging to see parameters that are not their concern. For example, developers may not know how to define Ingress parameters in the preceding WordPress Helm chart.</p>
			<p>As the configuration clock<a id="_idIndexMarker460"/> ticks further, we must harden the configurations for security. Infrastructure operators will want to own the configuration as the application owners do not know how to configure the security parameter. The Helm post rendering feature can rescue us from the situation and help inject the security configuration as late binding. But it will still be challenging for the infrastructure operators to manage the post-rendering step in the deployment pipeline because of too many customization forks and unexpected rendering outputs. Some developers may decide to use a DSL such as Terraform to manage configuration as it is simple to read. DSLs inherit the same parameterization problem in input variables, and the post-rendering customization step is also challenging with DSL. Additionally, DSLs have the issue of a complex learning curve for developers and limited tooling support for concerns such as testing. Vulnerability or compliance scanning is another area where we may face tooling issues. The Crossplane configuration can also face similar problems as we scale over time. The idea of discussing these limitations is not to discourage any specific tool usage. Each tool has its use cases and trade-offs. For example, Helm packing works well when operating on a small scale and a few other use cases, such as release management. In a way, we will be looking at how we can use a combination of tools and patterns to overcome this limitation.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>Configuration management requirements</h2>
			<p>To manage <a id="_idIndexMarker461"/>configurations without being trapped by the issues discussed regarding the complexity clock, we should keep a few guiding principles in mind. These guiding principles will be the technical requirements to perform trade-off analysis when selecting tools and patterns for configuration management. Baking these guiding principles into our configuration management recipes <a id="_idIndexMarker462"/>would allow us to evolve and scale with ease:</p>
			<ul>
				<li>Keep the configuration data readable for humans and machines to mutate along the configuration pipeline. Requirements such as environment-specific patching, security configuration patches, and policy as the configuration are best implemented as an automated step in the pipeline. Avoid maintaining configuration as code as they are challenging to manipulate. Rendered output from code may not always be straightforward for the machines to read.</li>
				<li>Configuration scanning requirements, such as audit, compliance, and security, work well with clean configuration as data. Keeping the configuration as data throughout the pipeline as much as possible and separating code that manipulates the configuration is vital to meet the evolving requirements. Many tools evolved around the Kubernetes ecosystem because configuration data is kept separate (in etcd) from code (controller) and has a standard data format with KRM.</li>
				<li>Segregation of concerns is another critical aspect of configuration management. Not all configuration knobs required to automate are meant for a single persona to define. We should manage the configuration so that different people can collaborate with ease.</li>
				<li>Build specialized abstractions to support customization with the reuse of configuration. For example, Pod is a fundamental configuration abstract over which Deployment, ReplicationController, DaemonSet, and so on are built. Later in the chapter, we will see more solid examples from the Crossplane and complete application management perspective.</li>
				<li>Version control the source configuration and the final mutated configuration, representing the desired state. Avoid modification to the configuration post applying to the cluster. Tools such as mutating admission controllers should be avoided. Late configuration binding may fail in ways that are hard to predict (still, the admission controller is suitable for policy validation).</li>
				<li>Use composing to bind the application and its dependent resource into a single API while maintaining separation of concerns with nested sub-APIs. Facilitate release management concerns such as discovery, life cycle management, and dependency <a id="_idIndexMarker463"/>management for the entire application bundle.</li>
			</ul>
			<p>We will deep dive into all these guiding principles in the upcoming sections. The following section will examine different patterns available for configuration management and the trade-offs with each pattern.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/>Patterns and trade-off</h2>
			<p>Reusing the <a id="_idIndexMarker464"/>configuration as we scale is challenging. Most of the reuse patterns were discussed in the <em class="italic">The configuration complexity clock</em> section. The section will cover these patterns in more detail with their advantages and disadvantages. The following are the well-known approaches for configuration reuse:</p>
			<ul>
				<li><strong class="bold">Fork</strong>: This is one<a id="_idIndexMarker465"/> of the frequently used methods <a id="_idIndexMarker466"/>to reuse configuration, primarily because of the ease of customization. Rebase is the strategy used to sync the configuration as things evolve. The rebasing process cannot be automated as humans must address merge conflicts. The method offers a high level of flexibility and comfort of maintenance in the short term. As time passes by, a couple of challenges arise. The forks will diverge a lot with time, creating challenges with rebasing. With independent agile teams managing different forks, the advantages of reuse can be overlooked to keep up with the evolving speed. I had a similar experience a year back when I decided to fork a code repository for customized deployment requirements. Different agile teams owned both forks. As the clock ticked further, code merge activity was ignored entirely, yielding to the delivery pressure. Finally, we ended up in a state where the two forks could never sync with thousands of conflicts. The fork solution works best when you quickly try a proof of concept. I will not recommend using them beyond that.</li>
				<li><strong class="bold">Template parameterization</strong>: We<a id="_idIndexMarker467"/> discussed template-based parameterization in <a href="B17830_02_ePub.xhtml#_idTextAnchor025"><em class="italic">Chapter 2</em></a>, and earlier in this<a id="_idIndexMarker468"/> chapter. It works well on a small scale but suffers leaking abstraction and team collaboration issues as we scale. Additionally, it will also push us toward using the fork pattern by making customization complex. Tools such as Helm fall under this category. As a template-based parameterization tool, Helm is extremely popular because of its other capabilities, such as application discovery and release management.</li>
				<li><strong class="bold">Patch/overlay</strong>: This<a id="_idIndexMarker469"/> method would <a id="_idIndexMarker470"/>have the base configuration as pure data points and use the patch file to overlay <a id="_idIndexMarker471"/>the required variables for customization. We can<a id="_idIndexMarker472"/> replace values for an existing configuration knob or add a new configuration to the overall base. We can also use the technique as a post-rendering step in template-based abstraction tools such as Helm. The leaks are avoided as additional parameterization required for customization can be managed as a post-rendering patch. It’s a popular method that is being used quite a bit at the moment, especially since the Kustomize tool came into existence. These tools do not require human intervention and can be automated as a step in the deployment pipeline.</li>
				<li><strong class="bold">Composition</strong>: It <a id="_idIndexMarker473"/>is a technique where we compose the dependencies to build a higher-level API and multiple sub-APIs consumed by different persona. We have discussed this pattern well enough as Crossplane itself is a composing tool. Pull and push are two sub-patterns within the<a id="_idIndexMarker474"/> composition. In the pull model, the dependencies are directly referred to. Nested XR is a typical example from the Crossplane world. With the push model, the dependencies are referred across API indirectly through runtime binding. The push pattern is suitable for separating concerns and building extendable abstractions. Resource references between two independent XRs using labels is a push composition example. Composition and patch/overlay work well together to create customization. For instance, in Crossplane, we can use a patch to generate environment-specific composition (production/staging).</li>
			</ul>
			<p>Composition, patch/overlay, and template-based tools can complement each other and combining them can help you to build a robust deployment pipeline. We will look at a few such hands-on examples in the following two chapters. The next section of this chapter will look at the <strong class="bold">Open Application Model</strong> (<strong class="bold">OAM</strong>), an open source standard to define application and team-centric configuration management.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor136"/>Open Application Model</h1>
			<p>OAM is an open source <a id="_idIndexMarker475"/>standard developed by Microsoft and Alibaba to guide us in creating higher-level abstraction APIs for application deployment. In other words, it’s about creating a model for application configuration management using composition as a pattern. The standard focus on addressing the following three problems:</p>
			<ul>
				<li><strong class="bold">Developer focus</strong>: Exposing <a id="_idIndexMarker476"/>developers directly to Kubernetes configuration management to deploy the applications will make them spend time figuring out infrastructure details rather than application focus. Hence, OAM attempts to keep developers focused on the application.</li>
				<li><strong class="bold">Vendor dependency</strong>: Configuring <a id="_idIndexMarker477"/>applications usually tends to depend on the underlying infrastructure. Completely decoupling the application configuration from the underlying infrastructure can enable the portability of workloads. Kubernetes does this to an extent, but the area requires more work with cross-cutting concerns and COTS dependencies.</li>
				<li><strong class="bold">Extendibility</strong>: Configuration<a id="_idIndexMarker478"/> management at scale can have many problems, especially while balancing reuse and customization. OAM proposed a model for reuse and customization for scale.</li>
			</ul>
			<p>OAM proposes layered configuration management based on personas and composing abstractions accordingly to address the problems. OAM defines three personas to manage different application<a id="_idIndexMarker479"/> deployment concerns, as represented in the following figure:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B17830_08_01.jpg" alt="Figure 8.1 – OAM persona&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – OAM persona</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>KubeVela, the OAM implementation</h2>
			<p>The OAM community <a id="_idIndexMarker480"/>has developed KubeVela, a project that implements the specification. It is a CNCF sandbox project and a composing tool like Crossplane. KubeVela <a id="_idIndexMarker481"/>concentrates only on composing bespoke application configurations. But Crossplane composes both bespoke applications and COTS infrastructure/external dependencies. Both KubeVela and Crossplane can complement each other using the following two different patterns:</p>
			<ul>
				<li><strong class="bold">KubeVela composes Crossplane</strong>: We <a id="_idIndexMarker482"/>can use KubeVela to compose bespoke applications deployment abstractions, and it can rely on Crossplane as the COTS external dependency provider. This pattern requires the Crossplane control plane to be present in the application workload cluster.</li>
				<li><strong class="bold">Crossplane composes KubeVela</strong>: We<a id="_idIndexMarker483"/> can use Crossplane to compose abstractions for both bespoke applications and COTS infrastructure/external dependencies. For bespoke applications, it can use KubeVela through Crossplane Provider for Kubernetes. This pattern can work with a centralized Crossplane control plane or a distributed Crossplane control plane.</li>
			</ul>
			<p>The following figure represents the<a id="_idIndexMarker484"/> KubeVela composes Crossplane pattern where both the Crossplane control plane and application workload cluster are the same:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B17830_08_02.jpg" alt="Figure 8.2 – KubeVela composes Crossplane&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – KubeVela composes Crossplane</p>
			<p>The preceding figure <a id="_idIndexMarker485"/>represents a web service workload with an RDS database as a COTS dependency. The workload construct of KubeVela defines the application workload type. Traits define all workload characteristics, such as route and traffic. Components help define the COTS dependencies. First, we will compose RDS into an XR API using Crossplane. Later, we can compose the XR as a component inside KubeVela. The following figure represents the second pattern where Crossplane composes KubeVela:</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B17830_08_03.jpg" alt="Figure 8.3 – Crossplane composes KubeVela&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Crossplane composes KubeVela</p>
			<p>The figure <a id="_idIndexMarker486"/>represents application management <a id="_idIndexMarker487"/>both in the same cluster and in a remote cluster. Additionally, the figure represents the usage of the Helm provider to set up KubeVela and other cluster dependencies. We will cover a hands-on example of KubeVela in <a href="B17830_09_ePub.xhtml#_idTextAnchor144"><em class="italic">Chapter 9</em></a>.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">OAM and KubeVela are exciting<a id="_idIndexMarker488"/> topics to explore further. Visit <a href="https://oam.dev/">https://oam.dev/</a> for more information.</p>
			<p>The following section will cover two exciting patterns that can help platform teams to build extendable and reusable platform APIs.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>Specialized and extendable abstraction</h1>
			<p>As we scale the number of applications deployed in Kubernetes, there could be an exponential proliferation of configurations to manage. Managing a high volume of KRM/XRM configuration files is prone to human error, is challenging to keep in sync, and requires a highly skilled workforce. Reuse is the key to keeping the volume of configurations low. But customization requirements at the individual team level will not allow us to reuse unless we have an easy and quick way to do so. Also, agile and product engineering practices will add additional pressure from a minimal external dependency perspective. Specialized and extendable abstraction is vital to address these problems. Let’s start with specialized abstraction in the following section.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor139"/>Specialized abstraction</h2>
			<p>Specialized abstraction <a id="_idIndexMarker489"/>is a technique where we build a basic abstraction and reuse the base abstraction to make specialized abstractions that handle custom requirements. It is nothing but the inheritance pattern from object-oriented programming. Also, this is a well-known pattern in core Kubernetes. Think of the Pod resource type as an example. Deployment, DemonSet, and Job are specialized abstractions that use Pod as their base. Let’s look at some of the specialized abstractions we could build as a platform team:</p>
			<ul>
				<li><strong class="bold">Policy abstraction layer</strong>: We <a id="_idIndexMarker490"/>may have policies per cloud resource as an organization. These policies could be from diverse areas, such as security, architecture, and compliance. If this is how the cloud strategy works in your organization, consider creating an abstract layer above the Crossplane provider with an XR for each resource. The layer can act as a solid base for creating recipes.</li>
				<li><strong class="bold">Database recipes</strong>: Different product<a id="_idIndexMarker491"/> teams will have different database requirements. Some product teams will demand a geographically distributed database, and others may be happy with availability zone fault tolerance in a single region. A third team may require a PCI-DSS-compliant database to store payment transactions. We could create a base database XR and create a specialized XR above the base to fit each need.</li>
				<li><strong class="bold">Workload recipes</strong>: Not <a id="_idIndexMarker492"/>every workload is the same. Web applications, RESTful APIs, scheduled jobs, and data transformation are some examples of workloads, and each will have different dependency requirements. For example, a scheduled job workload does not require Ingress. We create a primary workload with all common cross-cutting concerns and develop a specialized abstraction over the primary workload. We can do this with Crossplane or KubeVela or a mix of both.</li>
			</ul>
			<p>These are just some general examples that may apply to your environment. Finding the correct abstractions that suit your environment will require a closer look at the organization structure, technical maturity, governance model, workloads, and so on. The base and specialized abstractions are typically developed by the platform team to be consumed by the application operator and developers. We may have a rare scenario where the application operator is building a specialized abstraction over the base developed by the platform team. We can look at extendable abstraction in the following section.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/>Extendable abstraction</h2>
			<p>Extendable abstraction<a id="_idIndexMarker493"/> is a technique where we build a partial abstraction and allow other teams to implement it fully. It is nothing but the polymorphism pattern from object-oriented programming. Also, this is a well-known pattern in core Kubernetes. Ingress is an example from core Kubernetes. Each managed Kubernetes provider will come up with its implementation for Ingress. Extendable abstraction is meant for both platform teams and application operators. Let’s look at some examples of the pattern’s usage:</p>
			<ul>
				<li><strong class="bold">Shared resources</strong>: Let’s <a id="_idIndexMarker494"/>consider VPC as an example of a shared resource. Multiple variants of the resources sometimes need to be created and used for different scenarios. We can have a standard label name/value strategy for such resources, and other XR recipes can choose one VPC with appropriate label references. This is polymorphic behavior and provides extendibility through dependency injection.</li>
				<li><strong class="bold">Nested XR</strong>: The<a id="_idIndexMarker495"/> platform teams can create an XR recipe with dependencies missed identified. The missing dependencies can be implemented separately. Both the pieces can be composed with a <a id="_idIndexMarker496"/>nested XR pattern. Choose this pattern when the requirement for that missed dependency changes with every product team. An application recipe that leaves the database choice open is an example of nested XR behaving in a polymorphic way. The application operator can complete the recipe based on the specific product team’s requirements.</li>
			</ul>
			<p>Again, these are indicative examples. This concludes the abstraction discussion. In the following section of the chapter, we will look at configuration change frequency in detail.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor141"/>Impact of change frequency</h1>
			<p>Looking at the configuration knobs from the perspective of frequency of change will help us categorize them between personas defined in the OAM. The<a id="_idIndexMarker497"/> change frequency detailing will bring in the discussion of ownership as these perspectives are linked. This<a id="_idIndexMarker498"/> section covers change frequency from the perspective of bespoke applications (KRM compliant) and COTS external dependencies (XRM compliant). We can classify configuration change frequency into the following three categories:</p>
			<ul>
				<li><strong class="bold">Change very often</strong>: Generally, application KRM configuration parameters, such as<a id="_idIndexMarker499"/> image tags, release version, environment variables, secrets reference, and application configuration, change very frequently. These configurations are application-centric and owned primarily by the application developers. If we use a template- or DSL-based abstraction, they are good candidates to be exposed as variables. Suppose a plain configuration YAML is used instead of a template- or DSL-based abstraction, developers can own a version-controlled patch/overlay file. When composing is used as the solution, these configurations should be exposed to the developer with a high-level API.</li>
				<li><strong class="bold">Less frequent change</strong>: Configurations <a id="_idIndexMarker500"/>such as application context-related information (namespaces, labels, references, and so on), resource constraints (memory, volume, and so on), and release-related knobs (replica count and rollout method) are examples of less frequently changing configurations. The preceding-mentioned configurations mainly vary per environment or change when there is a new operational<a id="_idIndexMarker501"/> requirement. For example, the number of replicas, namespace, or labels can change based on the deployment environment (production, staging, and so on). Irrespective of using template-based or DSL-based, or a plain YAML or composing, it’s best to use patching as a mechanism to manage less frequently changing configuration values and choose the patch file based on the target environment in the pipeline. Patching is a choice because application operators own these configurations independently. Exposing them to developers will increase the cognitive load.</li>
				<li><strong class="bold">Rarely changes</strong>: Rarely customized<a id="_idIndexMarker502"/> configurations are the basic structure of the core application. Platform developers should own these configurations. The basic structure is the core abstractions to minimize the cognitive load for application operators and developers. Also, it will summarize the policy requirements inside the recipe. Generally, we use overlay, specialized, and extendable abstractions to achieve multiple variants of core configurations required by the different product teams and workloads.</li>
			</ul>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/>XRM change frequency</h2>
			<p>The XRM-compliant COTS external<a id="_idIndexMarker503"/> infrastructure dependencies mostly do not change frequently. For example, changes to the external infrastructure, such<a id="_idIndexMarker504"/> as region scaling, autoscaling setup, tuning security configuration, upgrade, and migration, will happen at a low phase after the initial setup. Building these infrastructure abstractions with XRs should be owned by platform teams. The application operator could do a few XR composing exercises to make a new, specialized recipe. In other words, they could create workload-specific abstraction using the nested XR pattern. As discussed earlier, XRM goes beyond infrastructure dependencies to manage the external application using providers such as Helm and SQL. These configurations could change frequently. For example, every application release could change the SQL schema of the database. Hence, the<a id="_idIndexMarker505"/> application operator persona can extend the <a id="_idIndexMarker506"/>existing recipes to meet the product team requirement.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>Summary</h1>
			<p>This chapter discussed various aspects of unified configuration management of bespoke applications and COTS components at scale. We covered concepts such as different tools available for configuration management, common pitfalls along the way when we scale, and the trade-off in using different patterns. Also, we discussed how different combinations of tools and practices could complement each other under different circumstances.</p>
			<p>The following two chapters will look at hands-on examples to try out a few recipes discussed in this chapter. The recipes will include KRM and XRM configuration management as we move toward end-to-end automation of the whole application and its COTS dependencies.</p>
		</div>
	</body></html>