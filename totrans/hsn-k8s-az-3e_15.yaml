- en: 10\. Storing secrets in AKS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 在 AKS 中存储密钥
- en: All production applications require some sensitive information to function,
    such as passwords or connection strings. Kubernetes has a pluggable back end to
    manage these secrets. Kubernetes also provides multiple ways of using the secrets
    in your deployment. The ability to manage secrets and use them properly will make
    your applications more secure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 所有生产应用程序都需要一些敏感信息来正常运行，比如密码或连接字符串。Kubernetes 提供了一个可插拔的后端来管理这些密钥。Kubernetes 还提供了多种方法来在部署中使用这些密钥。能够管理密钥并正确使用它们将使你的应用程序更加安全。
- en: You have already used secrets previously in this book. You used them when connecting
    to the WordPress site to create blog posts in *Chapter 3, Application deployment
    on AKS*, and *Chapter 4, Building scalable applications*. You also used secrets
    in *Chapter 6, Securing your application with HTTPS*, when you were configuring
    the Application Gateway Ingress Controller with TLS.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在本书中之前使用过密钥。当你在 *第 3 章、在 AKS 上部署应用程序* 和 *第 4 章、构建可扩展应用程序* 中连接 WordPress 网站并创建博客文章时，你使用了密钥。你还在
    *第 6 章、使用 HTTPS 保护你的应用程序* 中使用了密钥，当时你正在配置带有 TLS 的应用程序网关入口控制器。
- en: Kubernetes has a built-in secret system that stores secrets in a semi-encrypted
    fashion in the default Kubernetes database. This system works well but isn't the
    most secure way to deal with secrets in Kubernetes. In AKS, you can make use of
    a project called **Azure Key Vault provider for Secrets Store CSI driver** (**CSI
    driver**), which is a more secure way of working with Secrets in Kubernetes. This
    project allows you to store and retrieve secrets in/from Azure Key Vault.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 拥有一个内置的密钥系统，它将密钥以半加密方式存储在默认的 Kubernetes 数据库中。这个系统运行良好，但并不是在 Kubernetes
    中处理密钥的最安全方法。在 AKS 中，你可以利用一个名为 **Azure 密钥保管库提供程序的密钥存储 CSI 驱动程序**（**CSI 驱动程序**）的项目，它是一种更安全的处理
    Kubernetes 密钥的方式。该项目允许你在 Azure 密钥保管库中存储和检索密钥。
- en: In this chapter, you will learn about the various built-in secret types in Kubernetes
    and the different ways in which you can create these Secrets. After that, you
    will install the CSI driver on your cluster, and use it to retrieve Secrets.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解 Kubernetes 中的各种内建密钥类型以及你可以创建这些密钥的不同方式。之后，你将安装 CSI 驱动程序到集群中，并使用它来检索密钥。
- en: 'Specifically, you will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Different types of secret in Kubernetes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 中不同类型的密钥
- en: Creating and using secrets in Kubernetes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中创建和使用密钥
- en: Installing the Azure Key Vault provider for secrets Store CSI driver
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Azure 密钥保管库提供程序的密钥存储 CSI 驱动程序
- en: Using the Azure Key Vault provider for secrets Store CSI driver
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure 密钥保管库提供程序进行密钥存储 CSI 驱动程序
- en: Let's start with exploring the different secret types in Kubernetes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索 Kubernetes 中的不同类型的密钥开始。
- en: Different secret types in Kubernetes
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 中不同类型的密钥
- en: As mentioned in the introduction to this chapter, Kubernetes comes with a default
    secrets implementation. This default implementation will store secrets in the
    etcd database that Kubernetes uses to store all object metadata. When Kubernetes
    stores secrets in etcd, it will store them in base64-encoded format. Base64 is
    a way to encode data in an obfuscated manner but is not a secure way of doing
    encryption. Anybody with access to base64-encoded data can easily decode it. AKS
    adds a layer of security on top of this by encrypting all data at rest within
    the Azure platform.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章介绍中所提到的，Kubernetes 自带默认的密钥实现。该默认实现将密钥存储在 Kubernetes 用来存储所有对象元数据的 etcd 数据库中。当
    Kubernetes 在 etcd 中存储密钥时，它会以 base64 编码格式存储它们。Base64 是一种以模糊方式编码数据的方式，但这并不是一种安全的加密方法。任何能够访问
    base64 编码数据的人都可以轻松地解码它。AKS 在此基础上增加了一层安全性，通过在 Azure 平台内对所有数据进行静态加密。
- en: 'The default secret implementation in Kubernetes allows you to store multiple
    types of Secrets:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的默认密钥实现允许你存储多种类型的密钥：
- en: '**Opaque secrets**: These can contain any arbitrary user-defined secret or
    data.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不透明密钥**：这些可以包含任何用户定义的任意密钥或数据。'
- en: '**Service account tokens**: These are used by Kubernetes pods for built-in
    cluster RBAC.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务帐户令牌**：这些由 Kubernetes pod 用于内置集群 RBAC。'
- en: '**Docker config secrets**: These are used to store Docker registry credentials
    for Docker command-line configuration.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 配置密钥**：这些用于存储 Docker 注册表凭据，以进行 Docker 命令行配置。'
- en: '**Basic authentication secrets**: These are used for storing authentication
    information in the form of a username and password.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本认证密钥**：这些用于存储以用户名和密码形式的认证信息。'
- en: '**SSH authentication secrets**: These are used to store SSH private keys.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSH 认证秘密**：用于存储 SSH 私钥。'
- en: '**TLS certificates**: These are used to store TLS/SSL certificates.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TLS 证书**：用于存储 TLS/SSL 证书。'
- en: '**Bootstrap token Secrets**: These are used to store bearer tokens that are
    used when creating new clusters or joining new nodes to an existing cluster.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引导令牌秘密**：用于存储在创建新集群或将新节点加入现有集群时使用的令牌。'
- en: As a user of Kubernetes, you most typically will work with opaque secrets and
    TLS certificates. You've already worked with TLS secrets in *Chapter 6, Securing
    your application with HTTPS*. In this chapter, you will focus on opaque secrets.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Kubernetes 的用户，你最常接触的通常是透明的秘密和 TLS 证书。你已经在 *第六章，用 HTTPS 保护你的应用程序* 中使用过 TLS
    秘密。在本章中，你将重点关注不透明的秘密。
- en: 'Kubernetes provides three ways of creating secrets, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了三种创建秘密的方法，具体如下：
- en: Creating secrets from files
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件创建秘密
- en: Creating secrets from YAML or JSON definitions
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 YAML 或 JSON 定义创建秘密
- en: Creating secrets from the command line
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行创建秘密
- en: Using any of the preceding methods, you can create any type of secret.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述任何方法，你都可以创建任何类型的秘密。
- en: 'Kubernetes gives you two ways of consuming secrets:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了两种使用秘密的方法：
- en: Using secrets as an environment variable
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将秘密作为环境变量使用
- en: Mounting secrets as a file in a pod
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 pod 中将秘密挂载为文件
- en: In the next section, you will create secrets using the three ways mentioned
    here, and you will later consume them using both the methods listed here.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将通过这里提到的三种方式创建秘密，之后你将使用这里列出的两种方法来使用这些秘密。
- en: Creating secrets in Kubernetes
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中创建秘密
- en: 'In Kubernetes, there are three different ways to create secrets: from files,
    from YAML or JSON definitions, or directly from the command line. Let''s start
    the exploration of how to create secrets by creating them from files.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，有三种不同的创建秘密的方法：通过文件、通过 YAML 或 JSON 定义，或直接通过命令行。让我们从通过文件创建秘密开始探索。
- en: Creating Secrets from files
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从文件创建秘密
- en: The first way to create secrets in Kubernetes is to create them from a file.
    In this way, the contents of the file will become the value of the secret, and
    the filename will be the identifier of each value within the secret.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中创建秘密的第一种方法是通过文件创建。在这种方法中，文件的内容将成为秘密的值，而文件名将是每个值在秘密中的标识符。
- en: 'Let''s say that you need to store a URL and a secure token for accessing an
    API. To achieve this, follow these steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要存储一个 URL 和一个用于访问 API 的安全令牌。要实现这一点，请按照以下步骤操作：
- en: 'Store the URL in `secreturl.txt`, as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 URL 存储在 `secreturl.txt` 中，如下所示：
- en: '[PRE0]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Store the token in another file, as follows:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将令牌存储在另一个文件中，如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let Kubernetes create the secret from the files, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 Kubernetes 从文件中创建秘密，如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Please note that you are creating a single secret object in Kubernetes, referring
    to both text files. In this command, you are creating an opaque secret by using
    the `generic` keyword.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，你正在 Kubernetes 中创建一个单一的秘密对象，引用了两个文本文件。在此命令中，你正在通过使用 `generic` 关键字创建一个不透明的秘密。
- en: 'The command should return an output similar to *Figure 10.1*:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令应返回类似 *图 10.1* 的输出：
- en: '![Creating a Secret using the contents of the secreturl.txt file](img/B17338_10_01.jpg)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用 secreturl.txt 文件内容创建秘密](img/B17338_10_01.jpg)'
- en: 'Figure 10.1: Creating an opaque secret'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.1：创建一个不透明的秘密
- en: 'You can check whether the secrets were created in the same way as any other
    Kubernetes resource by using the `get` command:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 `get` 命令检查秘密是否已经以与其他 Kubernetes 资源相同的方式创建：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command will return an output similar to *Figure 10.2*:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令将返回类似 *图 10.2* 的输出：
- en: '![Verifying the creation of your Secret using the kubectl get secrets command](img/B17338_10_02.jpg)'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用 kubectl get secrets 命令验证创建的秘密](img/B17338_10_02.jpg)'
- en: 'Figure 10.2: List of the created secrets'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.2：已创建的秘密列表
- en: Here, you will see the secret you just created, and any other secrets that are
    present in the `default` namespace. The secret is of the `Opaque` type, which
    means that, from Kubernetes' perspective, the schema of the contents is unknown.
    It is an arbitrary key-value pair with no constraints, as opposed to, for example,
    SSH auth or TLS secrets, which have a schema that will be verified as having the
    required details.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，你将看到你刚刚创建的秘密，以及 `default` 命名空间中存在的其他秘密。这个秘密是 `Opaque` 类型，这意味着从 Kubernetes
    的角度来看，内容的架构是未知的。它是一个任意的键值对，没有任何约束，与例如 SSH 认证或 TLS 秘密不同，后者有一个架构，并且会被验证是否包含所需的详细信息。
- en: 'For more details about the secret, you can also run the `describe` command:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要了解有关机密的更多信息，你还可以运行 `describe` 命令：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will get an output similar to *Figure 10.3*:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将获得类似 *图 10.3* 的输出：
- en: '![Fetching the detailed description of the Secret using the describe command](img/B17338_10_03.jpg)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用 describe 命令获取机密的详细描述](img/B17338_10_03.jpg)'
- en: 'Figure 10.3: Description of the created secret'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.3：已创建机密的描述
- en: As you can see, neither of the preceding commands displayed the actual secret values.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，前面的命令都没有显示实际的机密值。
- en: 'To see the secret''s value, you can run the following command:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看机密的值，你可以运行以下命令：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will get an output similar to *Figure 10.4*:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将获得类似 *图 10.4* 的输出：
- en: '![Using the -o yaml switch in kubectl get secret fetches the encoded value
    of the Secret](img/B17338_10_04.jpg)'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用 kubectl get secret 的 -o yaml 选项获取机密的编码值](img/B17338_10_04.jpg)'
- en: 'Figure 10.4: Using the -o yaml switch in kubectl get secret fetches the encoded
    value of the secret'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.4：使用 kubectl get secret 的 -o yaml 选项获取机密的编码值
- en: The data is stored as key-value pairs, with the filename as the key and the
    base64-encoded contents of the file as the value.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据以键值对的形式存储，文件名作为键，文件的 base64 编码内容作为值。
- en: 'The preceding values are base64-encoded. Base64 encoding isn''t secure. It
    obfuscates the secret so it isn''t easily readable by an operator, but any bad
    actor can easily decode a base64-encoded secret. To get the actual values, you
    can run the following command:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述值是 base64 编码的。Base64 编码并不安全。它模糊了机密信息，使其不容易被操作员读取，但任何恶意行为者都可以轻松解码 base64 编码的机密。要获取实际的值，你可以运行以下命令：
- en: '[PRE6]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will get the values of the secrets that were originally created:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将获得最初创建的机密的值：
- en: '![The Base64-encoded Secret is decoded using the base 64 -d command](img/B17338_10_05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![使用 base 64 -d 命令解码 base64 编码的秘密](img/B17338_10_05.jpg)'
- en: 'Figure 10.5: Base64-encoded secrets can easily be decoded'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5：Base64 编码的机密可以轻松解码
- en: This shows you that the secrets are not securely encrypted in the default Kubernetes
    secret store.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明机密在默认的 Kubernetes 秘密存储中并没有被安全加密。
- en: In this section, you were able to create a secret containing an example URL
    with a secure token using files as the source. You were also able to get the actual
    secret values back by decoding the base64-encoded secrets.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你能够创建一个包含示例 URL 和安全令牌的机密，文件作为源。你还能够通过解码 base64 编码的机密来获取实际的机密值。
- en: Let's move on and explore the second method of creating Kubernetes secrets,
    creating secrets from YAML definitions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探索创建 Kubernetes 秘密的第二种方法，即从 YAML 定义中创建秘密。
- en: Creating secrets manually using YAML files
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 YAML 文件手动创建机密
- en: 'In the previous section, you created a secret from a text file. In this section,
    you will create the same secret using YAML files by following these steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你是通过文本文件创建了机密。在本节中，你将通过以下步骤使用 YAML 文件创建相同的机密：
- en: 'First, you need to encode the secret to `base64`, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要将机密编码为 `base64`，如下所示：
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will get the following value:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将获得以下值：
- en: '[PRE8]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You might notice that this is the same value that was present when you got the
    `yaml` definition of the secret in the previous section.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会注意到，这是在上一节获取机密的 `yaml` 定义时出现的相同值。
- en: 'Similarly, for the `url` value, you can get the base64-encoded value, as shown
    in the following code block:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，对于 `url` 值，你可以获得 base64 编码的值，如下所示：
- en: '[PRE9]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will give you the base64-encoded URL:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将给你 base64 编码的 URL：
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can now create the secret definition manually; then, save the file. This
    file has been provided in the code bundle as `myfirstsecret.yaml`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以手动创建机密定义，然后保存文件。此文件已经在代码包中作为 `myfirstsecret.yaml` 提供：
- en: '[PRE11]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s investigate this file:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们查看这个文件：
- en: '`Opaque` secret, meaning that from Kubernetes'' perspective, values are unconstrained
    key-value pairs.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Opaque` 机密，意味着从 Kubernetes 的角度来看，值是无约束的键值对。'
- en: '**Lines 7-8**: These are the base64-encoded values of the secret.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 7-8 行**：这些是机密的 base64 编码值。'
- en: You might notice that this YAML is very similar to the return you got in the
    previous section. This is because the object you use to create the secret in Kubernetes
    is stored with a bit more metadata on the Kubernetes API.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会注意到，这个 YAML 文件与上一节中你得到的返回结果非常相似。这是因为你用来创建 Kubernetes 中机密的对象在 Kubernetes
    API 中存储时包含了更多的元数据。
- en: 'Now you can create the secret in the same way as any other Kubernetes resource
    by using the `create` command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以像使用任何其他 Kubernetes 资源一样，通过使用 `create` 命令来创建机密：
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will return an output similar to *Figure 10.6*:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回一个类似于*图10.6*的输出：
- en: '![Creating a Secret from a YAML file](img/B17338_10_06.jpg)'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![从YAML文件创建Secret](img/B17338_10_06.jpg)'
- en: 'Figure 10.6: The secret was successfully created from a YAML file'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.6：通过YAML文件成功创建的Secret
- en: 'You can verify whether the secret was successfully created using this:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过以下命令验证Secret是否成功创建：
- en: '[PRE13]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will show you an output similar to *Figure 10.7*:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示一个类似于*图10.7*的输出：
- en: '![Verifying the creation of your Secret using the kubectl get secrets command](img/B17338_10_07.jpg)'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用kubectl get secrets命令验证Secret的创建](img/B17338_10_07.jpg)'
- en: 'Figure 10.7: List of the created secrets'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.7：已创建秘密的列表
- en: You can double-check that the secrets are the same by using `kubectl get -o
    yaml secrets myapiurltoken-yaml` in the same way that was described in the previous
    section.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过在之前描述的相同方式使用`kubectl get -o yaml secrets myapiurltoken-yaml`来仔细检查秘密是否相同。
- en: This described a second way of creating secrets in Kubernetes. In the next section,
    you will learn the final way to create secrets, using literals in kubectl.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这描述了在Kubernetes中创建秘密的第二种方式。在下一节中，你将学习通过kubectl中的字面量创建秘密的最终方法。
- en: Creating generic secrets using literals in kubectl
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用字面量在kubectl中创建通用秘密
- en: 'The third method of creating secrets is by using the `literal` method, which
    means you pass the value in kubectl on the command line. As you have seen in the
    previous examples, a single secret in Kubernetes can contain multiple values.
    In the command to create a secret using the `literal` method, you use the syntax
    `--from-literal=<key>=<value>` to identify the different values in a secret:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建秘密的第三种方法是使用`literal`方法，这意味着你在命令行上通过kubectl传递值。正如你在前面的例子中看到的，Kubernetes中的单个秘密可以包含多个值。在创建使用`literal`方法的Secret的命令中，你使用语法`--from-literal=<key>=<value>`来标识秘密中的不同值：
- en: 'To create a secret using the `literal` method, run the following command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`literal`方法创建Secret，请运行以下命令：
- en: '[PRE14]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will return an output similar to *Figure 10.8*:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回一个类似于*图10.8*的输出：
- en: '![Creating a Secretusing a literal values](img/B17338_10_08.jpg)'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用字面量值创建Secret](img/B17338_10_08.jpg)'
- en: 'Figure 10.8: The secret was successfully created using a literal value in kubectl'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.8：通过kubectl中的字面量值成功创建的Secret
- en: 'You can verify that the secret was created by running the following command:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来验证Secret是否已创建：
- en: '[PRE15]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will give us a similar output to *Figure 10.9*:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将给我们一个类似于*图10.9*的输出：
- en: '![Verifying the creation of your Secret using the kubectl get secrets command](img/B17338_10_09.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![使用kubectl get secrets命令验证Secret的创建](img/B17338_10_09.jpg)'
- en: 'Figure 10.9: Verifying the secret created using the literal method'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：验证通过字面量方法创建的Secret
- en: Thus, you have created secrets using literal values in addition to the preceding
    two methods.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你已经通过字面量值创建了秘密，除了之前的两种方法。
- en: In this section, you've created Kubernetes secrets using three methods. In the
    next section, you'll explore two methods of using those secrets in your pods and
    applications.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你已经使用三种方法创建了Kubernetes的秘密。在下一节中，你将探索两种在Pod和应用中使用这些秘密的方法。
- en: Using your secrets
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用你的秘密
- en: 'Once secrets have been created, they need to be linked to the application.
    This means that Kubernetes needs to pass the value of the secret to the running
    pods in some way. Kubernetes offers two ways to link your secrets to your application:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了秘密，它们就需要与应用程序关联。这意味着Kubernetes需要以某种方式将秘密的值传递给正在运行的Pods。Kubernetes提供了两种将秘密链接到应用程序的方法：
- en: Using secrets as environment variables
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用秘密作为环境变量
- en: Mounting secrets as files
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将秘密挂载为文件
- en: Mounting secrets as files is the best way to consume secrets in your application.
    In this section, we will explain both methods, and also show why it's best to
    use the second method. Let's start by accessing secrets as environment variables.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将秘密挂载为文件是应用中使用秘密的最佳方式。在本节中，我们将解释这两种方法，并且展示为什么第二种方法是最好的。首先，从作为环境变量访问秘密开始。
- en: Secrets as environment variables
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将秘密作为环境变量
- en: 'You can use a secret in Kubernetes by referencing it as an environment variable.
    secrets can then be referenced in the pod definition under the `containers` and
    `env` sections. You will use the secrets that you previously created in a pod
    and learn how to use them in an application:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将秘密作为环境变量来使用它。然后可以在Pod定义中的`containers`和`env`部分引用这些秘密。你将使用之前创建的秘密，在Pod中学习如何在应用程序中使用它们：
- en: 'You can configure a pod with environment variable secrets like the definition
    provided in `pod-with-env-secrets.yaml`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以像在 `pod-with-env-secrets.yaml` 中提供的定义那样，配置带有环境变量机密的 pod：
- en: '[PRE16]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s inspect this file:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们检查这个文件：
- en: '`secreturl.txt` file in the `myapi-url-token` secret.'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secreturl.txt` 文件位于 `myapi-url-token` 秘密中。'
- en: '`secrettoken.txt` file in the `myapi-url-token` secret.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secrettoken.txt` 文件位于 `myapi-url-token` 秘密中。'
- en: When Kubernetes creates a pod on a node that needs to use a secret, it will
    store that secret on that host in `tmpfs`, a temporary file system that is not
    written to disk. When the last pod referencing that secret is no longer running
    on that node, the secret is deleted from the node's `tmpfs`. If a node is shut
    down or rebooted, `tmpfs` is always erased.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当 Kubernetes 在需要使用机密的节点上创建 pod 时，它会将机密存储在该主机的 `tmpfs` 中，这是一种临时文件系统，不会写入磁盘。当最后一个引用该机密的
    pod 在该节点上停止运行时，机密会从该节点的 `tmpfs` 中删除。如果节点关闭或重启，`tmpfs` 将被清除。
- en: 'Let''s now create the pod and see whether you can access the secrets:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建 pod 并查看是否可以访问这些机密：
- en: '[PRE17]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Check whether the environment variables are set correctly:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查环境变量是否设置正确：
- en: '[PRE18]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should show you a result similar to *Figure 10.10*:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该显示类似于*图 10.10*的结果：
- en: '![Accessing the Secret inside the pod](img/B17338_10_10.jpg)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![在 pod 内访问机密](img/B17338_10_10.jpg)'
- en: 'Figure 10.10: You can get the secrets inside the pod'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.10：您可以在 pod 内获取机密
- en: You can now exit out of the shell to the container using the `exit` command.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以使用 `exit` 命令退出容器的 shell。
- en: There are a couple of things to note in this example. First, note that when
    you access the environment variables, you get the actual value of the secret back,
    not the base64-encoded value. This is as expected, since the base64 encoding is
    only applied at the Kubernetes API level, not at the application level.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中有几点需要注意。首先，请注意，当您访问环境变量时，您会返回机密的实际值，而不是 base64 编码的值。这是预期的行为，因为 base64
    编码仅在 Kubernetes API 层应用，而不是在应用程序层。
- en: The second thing to note is that you were able to access the secret by opening
    a shell into that running container and echoing the secret. It is important to
    apply the right level of RBAC to pods in Kubernetes, so that not every cluster
    user is able to run the `exec` command and open a shell.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的第二点是，您能够通过进入正在运行的容器并回显机密来访问该机密。为 Kubernetes 中的 pod 应用适当级别的 RBAC（角色基础访问控制）非常重要，以确保不是每个集群用户都能运行
    `exec` 命令并打开 shell。
- en: Also note that both the application, in the form of the container image, and
    the pod definition had no hardcoded secrets. The secrets were provided by the
    dynamic configuration in Kubernetes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，无论是作为容器镜像的应用程序，还是 pod 定义中，都没有硬编码机密。机密是通过 Kubernetes 中的动态配置提供的。
- en: The final thing to note is that any application can use the secret values by
    referencing the appropriate `env` variables. There is no way to limit which processes
    in a container can access which environment variables.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要注意的一点是，任何应用程序都可以通过引用适当的 `env` 变量来使用机密值。没有办法限制容器中哪些进程可以访问哪些环境变量。
- en: An important thing to know about secrets that are used as environment variables
    is that the value of the environment variable will not be updated when the secret
    itself is updated. This might cause you to end up in a state where pods that are
    created after a secret is updated have a different environment variable value
    compared to the pods created before the secret was updated.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关于作为环境变量使用的机密，有一点很重要，那就是当机密本身更新时，环境变量的值不会被更新。这可能会导致您遇到这样一种情况：在机密更新后创建的 pod 与更新前创建的
    pod 在环境变量值上有所不同。
- en: In this section, you explored how to access secrets from within a running pod
    using environment variables. In the next section, you will explore how to achieve
    this using files.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您探讨了如何通过环境变量从正在运行的 pod 中访问机密。在下一节中，您将探讨如何通过文件来实现这一点。
- en: Secrets as files
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 机密作为文件
- en: 'Let''s take a look at how to mount the same secrets as files rather than environment
    variables:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将相同的机密作为文件而不是环境变量进行挂载：
- en: 'You will use the following pod definition to demonstrate how this can be done.
    It is provided in the `pod-with-vol-secrets.yaml` file:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将使用以下 pod 定义来演示如何完成此操作。它位于`pod-with-vol-secrets.yaml`文件中：
- en: '[PRE19]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s have a closer look at this file:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们更仔细地查看这个文件：
- en: '`/etc/secrets` directory as read-only.'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/secrets` 目录为只读。'
- en: '`env` definition, as you don''t have to define a name for each secret. However,
    applications need to have special code to read the contents of the file in order
    to load it properly.'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env` 定义，因为您不必为每个机密定义名称。然而，应用程序需要有特殊代码来读取文件的内容，以便正确加载它。'
- en: 'Let''s see whether the secrets made it through. Create the pod using the following
    command:'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们看看机密是否已经通过。使用以下命令创建 Pod：
- en: '[PRE20]'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Echo the contents of the files in the mounted volume:'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出挂载卷中文件的内容：
- en: '[PRE21]'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see in *Figure 10.11*, the secrets are present in the pod:'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如*图 10.11*所示，机密出现在 Pod 中：
- en: '![Echoing the contents of the files containing the secrets in the mounted volume
    ](img/B17338_10_11.jpg)'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![输出挂载卷中包含机密的文件内容](img/B17338_10_11.jpg)'
- en: 'Figure 10.11: The secrets are available as files in our pod'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.11：机密作为文件在我们的 Pod 中可用
- en: You can now exit out of the shell to the container using the `exit` command.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，您可以使用 `exit` 命令退出容器的 shell。
- en: There are a couple of things to note here as well. First, note that the secrets
    again are available in plain text and not in base64.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里也有几个要注意的地方。首先，请注意机密再次以明文显示，而不是以 base64 编码的形式。
- en: Second, since the secrets are mounted as a file, file system permissions apply
    to these secrets. This means that you can limit which processes can get access
    to the contents of these files.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，由于机密作为文件挂载，因此文件系统权限适用于这些机密。这意味着您可以限制哪些进程可以访问这些文件的内容。
- en: Finally, Secrets mounted as files will be dynamically updated as the secrets
    are updated.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为文件挂载的机密将在机密更新时动态更新。
- en: You have now learned two ways in which secrets can be passed to a running container.
    In the next section, it will be explained why it's best practice to use the file
    method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经学习了将机密传递给运行容器的两种方式。在下一部分中，将解释为什么将机密作为文件的方法是最佳实践。
- en: Why secrets as files is the best method
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么将机密作为文件是最好的方法
- en: 'Although it is a common practice to use secrets as environment variables, it
    is more secure to mount secrets as files. Kubernetes treats secrets as environment
    variables securely, but the container runtime doesn''t treat them securely. To
    verify this, you can run the following commands to see the secret in plain text
    in the Docker runtime:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将机密作为环境变量使用是常见做法，但将机密作为文件挂载更加安全。Kubernetes 将机密作为环境变量安全地处理，但容器运行时并不会安全地处理它们。为了验证这一点，您可以运行以下命令，在
    Docker 运行时以明文查看机密：
- en: 'Start by getting the node that the pod using environment variables from the
    earlier example is running on with the following command:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令获取使用环境变量的 Pod 所在节点：
- en: '[PRE22]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This should show you the instance ID, as seen in *Figure 10.12*:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该显示实例 ID，如*图 10.12*所示：
- en: '![Fetching the Instance ID of the node by describing the pod](img/B17338_10_12.jpg)'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![通过描述 Pod 获取节点的实例 ID](img/B17338_10_12.jpg)'
- en: 'Figure 10.12: Getting the instance ID'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.12：获取实例 ID
- en: 'Next, get the Docker ID of the running pod:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，获取正在运行的 Pod 的 Docker ID：
- en: '[PRE23]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This should give you the container ID:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会给您容器 ID：
- en: '![Fetching the Docker ID of the running pod](img/B17338_10_13.jpg)'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![获取正在运行的 Pod 的 Docker ID](img/B17338_10_13.jpg)'
- en: 'Figure 10.13: Getting the Docker ID'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.13：获取 Docker ID
- en: 'Finally, you will execute a command on the node running your container to show
    the secret that was passed as an environment variable. First, let''s set a couple
    of variables you''ll use later:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您将在运行容器的节点上执行一个命令，以显示作为环境变量传递的机密。首先，让我们设置几个您稍后会用到的变量：
- en: '[PRE24]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The previous command assumes you have a single AKS cluster with one node pool
    in your subscription. If this is not the case, please change the values of `VMSS`
    and `RGNAME` to the name of the value of the scale set and resource group running
    your cluster.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一个命令假设您在订阅中有一个单节点池的 AKS 集群。如果不是这种情况，请将 `VMSS` 和 `RGNAME` 的值更改为正在运行集群的规模集和资源组的名称。
- en: 'Depending on your node version, you will run either of the following commands.
    For clusters running on Kubernetes version 1.18.x or earlier, run the following
    command:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您的节点版本，您将运行以下命令之一。对于运行 Kubernetes 版本 1.18.x 或更早版本的集群，运行以下命令：
- en: '[PRE25]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This should return an output similar to *Figure 10.14*:'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该返回类似于*图 10.14*的输出：
- en: '![Output showing the decoded secret in the Docker runtime ](img/B17338_10_14.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![在 Docker 运行时显示解码后的机密输出](img/B17338_10_14.jpg)'
- en: 'Figure 10.14: The Secrets are decoded in the Docker runtime'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14：机密在 Docker 运行时被解码
- en: 'For clusters running version 1.19 or later, run the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行版本 1.19 或更高版本的集群，运行以下命令：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will show you an output similar to *Figure 10.15*:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示类似于 *图 10.15* 的输出：
- en: '![Output showing the decoded secret in the containerd runtime ](img/B17338_10_15.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![显示在 containerd 运行时解码的秘密的输出](img/B17338_10_15.jpg)'
- en: 'Figure 10.15: The secrets are decoded in the containerd runtime'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15：在 containerd 运行时解码的秘密
- en: This shows you both secrets in plain text in the container runtime, whether
    Docker (AKS version before 1.19) or containerd (AKS versions 1.19 and above).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了容器运行时中的明文秘密，无论是 Docker（1.19 之前的 AKS 版本）还是 containerd（1.19 及以上的 AKS 版本）。
- en: As you can see, the secrets are decoded in the container runtime command. This
    means that most logging systems will log these sensitive secrets. Hence, it's
    advised to use secrets as files, since they are not passed in plain text except
    to the pod and the application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，秘密是在容器运行时命令中解码的。这意味着大多数日志系统将记录这些敏感的秘密。因此，建议将秘密作为文件使用，因为它们除了传递给 Pod 和应用程序外，不会以明文形式传递。
- en: 'Let''s make sure to clean up the resources we created in this example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保清理在本示例中创建的资源：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now that you have explored secrets in Kubernetes using the default secrets mechanism,
    let's go ahead and use a more secure option, namely Azure Key Vault.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经使用 Kubernetes 的默认秘密机制探索了秘密，让我们继续使用更安全的选项，即 Azure Key Vault。
- en: Installing the Azure Key Vault provider for Secrets Store CSI driver
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Azure Key Vault 提供程序以使用 Secrets Store CSI 驱动程序
- en: In the previous section, you explored secrets that were stored natively in Kubernetes.
    This means they were base64-encoded on the Kubernetes API server. You saw in the
    previous section that base64-encoded secrets are not secure at all. For highly
    secure environments, you will want to use a better secret store.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你探索了存储在 Kubernetes 中的本地秘密。这意味着它们在 Kubernetes API 服务器上是 base64 编码的。你在上一节中看到，base64
    编码的秘密根本不安全。对于高度安全的环境，你将希望使用更好的秘密存储。
- en: Azure offers an industry-compliant key and secret storage solution called Azure
    Key Vault. It is a managed service that makes creating, storing, and retrieving
    keys and secrets easy, and offers auditing of access to your keys and secrets.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 提供了一个符合行业标准的密钥和秘密存储解决方案，称为 Azure Key Vault。它是一个托管服务，可以轻松创建、存储和检索密钥和秘密，并提供对密钥和秘密访问的审计。
- en: The Kubernetes community maintains a project called the Kubernetes Secrets Store
    CSI driver (https://github.com/kubernetes-sigs/secrets-store-csi-driver). This
    project allows you to integrate external secret stores with volumes in Kubernetes
    through the CSI driver. The Container Storage Interface is a standardized way
    in Kubernetes to interface with storage systems. There are multiple implementations
    of the Secret Store CSI driver. At the time of writing, the current implementations
    are Hashicorp Vault, Google Cloud Platform, and Azure Key Vault.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 社区维护一个名为 Kubernetes Secrets Store CSI 驱动程序的项目（[https://github.com/kubernetes-sigs/secrets-store-csi-driver](https://github.com/kubernetes-sigs/secrets-store-csi-driver)）。该项目允许你通过
    CSI 驱动程序将外部机密存储与 Kubernetes 中的卷进行集成。容器存储接口（CSI）是 Kubernetes 与存储系统交互的标准化方式。Secret
    Store CSI 驱动程序有多个实现。目前的实现包括 Hashicorp Vault、Google Cloud Platform 和 Azure Key
    Vault。
- en: Microsoft maintains the Key Vault implementation of the Secret Store CSI driver,
    named Azure Key Vault provider for Secrets Store CSI driver. This implementation
    allows you as a user to access Key Vault secrets from within Kubernetes. It is
    also integrated with pod identities to restrict access to secrets. Optionally,
    this implementation can also sync Key Vault secrets with Kubernetes secrets so
    you can use them as an environment variable if needed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 微软维护了 Secret Store CSI 驱动程序的 Key Vault 实现，名为 Azure Key Vault 提供程序。这个实现允许用户从
    Kubernetes 内部访问 Key Vault 秘密。它还与 Pod 身份集成，以限制对秘密的访问。可选地，此实现还可以将 Key Vault 秘密与
    Kubernetes 秘密同步，以便在需要时将其用作环境变量。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For brevity, we'll refer to Azure Key Vault provider for Secrets Store CSI driver
    as the CSI driver for Key Vault.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们将 Azure Key Vault 提供程序称为 Key Vault 的 CSI 驱动程序。
- en: At the time of writing, the CSI driver for Key Vault is only available as an
    open-source project that you can install on your cluster. It is worth noting that
    this solution might be introduced as a managed add-on to AKS in the future. For
    more up-to-date details, please refer to this issue on GitHub at https://github.com/Azure/AKS/issues/1876.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在写作时，Key Vault 的 CSI 驱动程序仅作为开源项目提供，你可以将其安装在集群中。值得注意的是，未来这个解决方案可能会作为 AKS 的托管附加组件引入。如需更详细的最新信息，请参阅
    GitHub 上的此问题：[https://github.com/Azure/AKS/issues/1876](https://github.com/Azure/AKS/issues/1876)。
- en: To work with the CSI driver for Key Vault, there are two things you need to
    do. First, you need to set up the driver itself on your cluster. That is the goal
    of this section. Secondly, you'll need to create an object in Kubernetes called
    a `SecretProviderClass` for each secret from Key Vault you need to access. You
    will learn more about this in the next section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Key Vault 的 CSI 驱动程序，您需要做两件事。首先，您需要在集群上设置驱动程序。这是本节的目标。其次，您需要为每个需要访问的 Key
    Vault 秘密，在 Kubernetes 中创建一个名为 `SecretProviderClass` 的对象。您将在下一节中了解更多内容。
- en: In this section, you will set up the CSI driver for Key Vault. First, you will
    create a new user-assigned managed identity. After that, you'll create a new key
    vault and give the user-assigned managed identity permissions to that key vault.
    Finally, you'll set up the CSI driver for Key Vault on your cluster.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将设置 Key Vault 的 CSI 驱动程序。首先，您将创建一个新的用户分配的托管身份。然后，您将创建一个新的密钥库，并授予该用户分配的托管身份对密钥库的访问权限。最后，您将为您的集群设置
    Key Vault 的 CSI 驱动程序。
- en: Let's start by creating a new managed identity.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建新的托管身份开始。
- en: Creating a managed identity
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建托管身份
- en: 'The CSI driver for Key Vault supports different ways of getting data out of
    Key Vault. It is recommended that you use a managed identity to link your Kubernetes
    cluster to Key Vault. For this, you can use the AAD pod-managed identity add-on
    that you set up in the previous chapter. In this section, you''ll create a new
    managed identity in Azure to later use with Key Vault:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Key Vault 的 CSI 驱动程序支持多种从 Key Vault 获取数据的方式。建议您使用托管身份将 Kubernetes 集群与 Key Vault
    连接。为此，您可以使用上一章中设置的 AAD pod 托管身份附加组件。在本节中，您将创建一个新的托管身份，以便稍后与 Key Vault 一起使用：
- en: Let's create a new managed identity. You will use the Azure portal to do this.
    To start, look for `managed identity` in the Azure search bar, as shown in *Figure 10.16*:![Searching
    for Managed Identity in the Azure search bar](img/B17338_10_16.jpg)
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的托管身份。您将使用 Azure 门户来完成这一步。首先，在 Azure 搜索框中查找 `managed identity`，如*图 10.16*所示：![在
    Azure 搜索框中查找托管身份](img/B17338_10_16.jpg)
- en: 'Figure 10.16: Looking for managed identity in the Azure search bar'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.16：在 Azure 搜索框中查找托管身份
- en: In the resulting pane, click the + New button at the top. To organize the resources
    for this chapter together, it's recommended to create a new resource group. In
    the resulting pane, click the Create new button to create a new resource group.
    Call it `csi-key-vault`, as shown in *Figure 10.17*:![Creating a new resource
    group for creating a new managed identity](img/B17338_10_17.jpg)
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的面板中，点击顶部的 + 新建按钮。为了将本章的资源组织在一起，建议创建一个新的资源组。在弹出的面板中，点击创建新建按钮来创建一个新的资源组。命名为
    `csi-key-vault`，如*图 10.17*所示：![为创建新的托管身份创建新的资源组](img/B17338_10_17.jpg)
- en: 'Figure 10.17: Creating a new resource group'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.17：创建新的资源组
- en: Now, select the region you created your cluster in as the region for your managed
    identity and give it a name, `csi-key-vault` if you follow the example, as shown
    in *Figure 10.18*. To finish, click the Review + create button and in the final
    window, click the Create button to create your managed identity:![Providing Instance
    details for the managed identity](img/B17338_10_18.jpg)
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择您创建集群的区域作为托管身份的区域，并为其命名，如果按照示例，可以命名为 `csi-key-vault`，如*图 10.18*所示。完成后，点击审核
    + 创建按钮，在最后的窗口中点击创建按钮来创建您的托管身份：![为托管身份提供实例详细信息](img/B17338_10_18.jpg)
- en: 'Figure 10.18: Providing Instance details'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.18：提供实例详细信息
- en: Once the managed identity has been created, hit the Go to resource button to
    go to the resource. Here, you will need to copy the resource ID that will be used
    later in the next step. You can find that in the Properties pane of the managed
    identity, as shown in *Figure 10.19*:![Fetching the resource ID from the Properties
    pane of the managed identity](img/B17338_10_19.jpg)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 托管身份创建完成后，点击转到资源按钮进入该资源。在这里，您需要复制将在下一步骤中使用的资源 ID。您可以在托管身份的属性面板中找到该 ID，如*图 10.19*所示：![从托管身份的属性面板中获取资源
    ID](img/B17338_10_19.jpg)
- en: 'Figure 10.19: Getting the Resource ID of the managed identity'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.19：获取托管身份的资源 ID
- en: 'Now you are ready to link the managed identity to your AKS cluster. To do this,
    you will run a command in cloud shell as you did in the previous chapter. Afterward,
    you will verify that the identity is available in your cluster. Let''s start with
    linking the identity:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您准备将托管身份链接到您的 AKS 集群。为此，您将像上一章一样，在云命令行中运行一个命令。之后，您将验证该身份是否在集群中可用。让我们从链接身份开始：
- en: '[PRE28]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can verify that your identity was successfully linked to your cluster by
    running the following command:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令验证您的身份是否成功链接到您的集群：
- en: '[PRE29]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This should produce an output similar to *Figure 10.20*:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会生成类似于 *图 10.20* 的输出：
- en: '![Verifying that your identity is successfully linked to your cluster](img/B17338_10_20.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![验证您的身份是否成功链接到您的集群](img/B17338_10_20.jpg)'
- en: 'Figure 10.20: Verifying the availability of the identity in the cluster'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20：验证集群中身份的可用性
- en: In this section, you created a new managed identity and linked that to your
    Kubernetes cluster using the AAD Pod-managed identity add-on. In the next section,
    you'll create a key vault and give the new identity you created access to the
    secrets. Finally, you'll create a secret in Key Vault that you try to access later
    from your cluster.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您创建了一个新的托管标识，并使用 AAD Pod 托管标识附加组件将其链接到了您的 Kubernetes 集群。在下一节中，您将创建一个密钥保管库，并授予您创建的新标识对密钥保管库中秘密的访问权限。最后，您将在
    Key Vault 中创建一个秘密，稍后从您的集群中尝试访问它。
- en: Creating a key vault
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建密钥保管库
- en: 'In the previous section, you set up the managed identity that the CSI driver
    for Key Vault will use. In this section, you''ll create the key vault that will
    be used:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，您设置了用于 Key Vault 的 CSI 驱动器的托管标识。在本节中，您将创建将使用的密钥保管库：
- en: To start the creation process, look for `Key vaults` in the Azure search bar:![Navigating
    to Key Vault services from the Azure portal](img/B17338_10_21.jpg)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始创建过程，请在 Azure 搜索栏中查找“Key vaults”：![从 Azure 门户导航到 Key Vault 服务](img/B17338_10_21.jpg)
- en: 'Figure 10.21: Navigating to Key vaults through the Azure portal'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.21：通过 Azure 门户导航到密钥保管库
- en: Click the + New button to start the creation process:![Creating a new key vault](img/B17338_10_22.jpg)
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“+ 新建”按钮开始创建过程：![创建新密钥保管库](img/B17338_10_22.jpg)
- en: 'Figure 10.22: Click the Add button to start creating a key vault'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.22：单击“添加”按钮开始创建密钥保管库
- en: Provide the details to create the key vault. Create the key vault in the resource
    group you created in the previous step. The key vault's name has to be globally
    unique, so consider adding your initials to the name. It is recommended that you
    create the key vault in the same region as your cluster:![Providing Subscription
    and Instance details to create the key vault](img/B17338_10_23.jpg)
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供创建密钥保管库的详细信息。在之前步骤创建的资源组中创建密钥保管库。密钥保管库的名称必须全局唯一，因此考虑在名称中添加您的缩写。建议您将密钥保管库创建在与您的集群相同的区域：![提供订阅和实例详细信息以创建密钥保管库](img/B17338_10_23.jpg)
- en: 'Figure 10.23: Providing the details to create the key vault'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.23：提供创建密钥保管库的详细信息
- en: 'After you have provided the details for your key vault, click the Next: Access
    policy > button to give the managed identity access to secrets. Click on the +
    Add Access Policy to give permission to your managed identity, as shown in *Figure
    10.24*:![Adding a new access policy](img/B17338_10_24.jpg)'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供密钥保管库详细信息后，单击“下一步：访问策略 >”按钮，为托管标识授予对秘密的访问权限。单击“+ 添加访问策略”为您的托管标识授予权限，如 *图 10.24*
    所示：![添加新的访问策略](img/B17338_10_24.jpg)
- en: 'Figure 10.24: Adding an Access policy'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.24：添加访问策略
- en: 'In the resulting pane, select the Secret Management template, click on the
    None Selected button underneath Select principal, and in the resulting pane look
    for the `csi-to-key-vault` you created earlier. Finally, click on Select at the
    bottom of the screen and then on Add, as shown in *Figure 10.25*:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在结果面板中，选择“秘密管理模板”，单击“选择主体”下的“未选择”按钮，在结果面板中查找您之前创建的“csi-to-key-vault”。最后，单击屏幕底部的“选择”，然后单击“添加”，如
    *图 10.25* 所示：
- en: '![Assigning the Secret Management template in the access policy to the csi-to-key-vault
    managed identity](img/B17338_10_25.jpg)'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![将访问策略中的秘密管理模板分配给 csi-to-key-vault 托管标识](img/B17338_10_25.jpg)'
- en: 'Figure 10.25: Assigning the Secret Management template to your managed identity'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.25：将秘密管理模板分配给您的托管标识
- en: Once you have provided permissions to this managed identity, hit the Review
    + create button to review and create your key vault. Hit the Create button to
    finish the creation process.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您为此托管标识提供了权限，请单击“审阅 + 创建”按钮审阅并创建您的密钥保管库。单击“创建”按钮完成创建过程。
- en: It will take a couple of seconds to create your key vault. Once the vault is
    created, click on the Go to resource button, go to Secrets, and hit the Generate/Import
    button to create a new secret as shown in *Figure 10.26*:![Creating a new Secret
    within the key vault](img/B17338_10_26.jpg)
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你的密钥库需要几秒钟时间。一旦密钥库创建完成，点击“转到资源”按钮，进入“Secrets”部分，点击“生成/导入”按钮以创建一个新密钥，如*图 10.26*所示：![在密钥库中创建新密钥](img/B17338_10_26.jpg)
- en: 'Figure 10.26: Creating a new secret'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.26：创建新密钥
- en: 'In the secret creation wizard, provide the details about your secret. To make
    this demonstration easier to follow, use the name `k8s-secret-demo`. Give the
    secret a memorable value, such as `secret-coming-from-key-vault`. Click the Create
    button at the bottom of the screen to create the secret:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在密钥创建向导中，提供密钥的详细信息。为了使这个演示更易于跟随，使用名称 `k8s-secret-demo`。给密钥一个容易记住的值，比如 `secret-coming-from-key-vault`。点击屏幕底部的“创建”按钮以创建密钥：
- en: '![Configuring the Secret](img/B17338_10_27.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![配置密钥](img/B17338_10_27.jpg)'
- en: 'Figure 10.27: Providing the details for your new secret'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.27：为新密钥提供详细信息
- en: Now that you have a secret in Key Vault, you can move ahead and install the
    actual CSI driver for Key Vault in your cluster.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你在 Key Vault 中有了一个密钥，你可以继续在集群中安装实际的 Key Vault CSI 驱动程序。
- en: Installing the CSI driver for Key Vault
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Key Vault CSI 驱动程序
- en: 'In this section, you will set up the CSI driver for Key Vault in your cluster.
    This will allow you, in the next section, to retrieve secrets from Key Vault.
    The installation is a short process, as you will see here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将在集群中设置 Key Vault CSI 驱动程序。这将允许你在下一节中从 Key Vault 中检索密钥。安装过程很简单，正如你将在这里看到的：
- en: 'The easiest way to install the CSI driver for Key Vault is to use Helm, as
    you''ve done before. Note that this feature may be available as an add-on after
    the release of this book. To do this, add the repo for the CSI driver for Key
    Vault:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Key Vault CSI 驱动程序最简单的方法是使用 Helm，正如你之前所做的那样。请注意，在本书发布后，此功能可能会作为附加组件提供。为此，添加
    Key Vault CSI 驱动程序的仓库：
- en: '[PRE30]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once the repo has been added, you can install the actual CSI driver for Key
    Vault using the following command:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦添加了仓库，你可以使用以下命令安装实际的 Key Vault CSI 驱动程序：
- en: '[PRE31]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To verify that the installation succeeded, you can verify that the SecretProviderClass
    CRD has been added to your cluster via the following command:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证安装是否成功，你可以通过以下命令验证 SecretProviderClass CRD 是否已被添加到你的集群中：
- en: '[PRE32]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This should show you an output that contains the SecretProviderClass CRD as
    shown in *Figure 10.28*:'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示包含 SecretProviderClass CRD 的输出，如*图 10.28*所示：
- en: '![Verifying that the SecretProviderClass CRD has been added to your cluster](img/B17338_10_28.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![验证 SecretProviderClass CRD 已被添加到集群中](img/B17338_10_28.jpg)'
- en: 'Figure 10.28: The SecretProviderClass CRD has been added to the cluster'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.28：SecretProviderClass CRD 已被添加到集群中
- en: This concludes the setup of the CSI driver for Key Vault. In this section, you
    first created a managed identity, then created a key vault with a secret in it,
    and then finally set up the CSI driver for Key Vault on your cluster.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着 Key Vault CSI 驱动程序的安装完成。在本节中，你首先创建了一个托管身份，然后创建了一个包含密钥的密钥库，最后在集群中设置了 Key
    Vault 的 CSI 驱动程序。
- en: You are now ready to use the CSI driver for Key Vault, which you'll do in the
    next section.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好使用 Key Vault 的 CSI 驱动程序，下一节中你将开始使用它。
- en: Using the Azure Key Vault provider for Secrets Store CSI driver
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Azure Key Vault 提供程序的 Secrets Store CSI 驱动程序
- en: Now that the CSI driver for Key Vault has been set up on your cluster, you are
    ready to start using it. In this section, you'll run through two examples of using
    the CSI driver for Key Vault. First, you will use it to mount a secret as a file
    in Kubernetes. Afterward, you will also use it to sync Key Vault secrets to Kubernetes
    secrets and use them as an environment variable.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Key Vault 的 CSI 驱动程序已经在你的集群中设置完成，你可以开始使用它了。在本节中，你将通过两个示例来演示如何使用 Key Vault
    的 CSI 驱动程序。首先，你将使用它将一个密钥作为文件挂载到 Kubernetes 中。接下来，你还将使用它将 Key Vault 中的密钥同步到 Kubernetes
    秘密，并将它们用作环境变量。
- en: Let's get started with the first example, how to mount Key Vault secrets as
    a file.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始第一个示例，如何将 Key Vault 密钥挂载为文件。
- en: Mounting a Key Vault secret as a file
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Key Vault 密钥挂载为文件
- en: 'In this first example, you will create a new SecretProviderClass in your cluster.
    This object will allow you to link a secret in Key Vault to a pod in Kubernetes.
    After that, you''ll create a pod that uses that SecretProviderClass and mounts
    the secrets in that pod. Let''s get started:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个示例中，你将在集群中创建一个新的 SecretProviderClass。这个对象将允许你将 Key Vault 中的密钥链接到 Kubernetes
    中的 Pod。之后，你将创建一个使用该 SecretProviderClass 的 Pod，并将密钥挂载到该 Pod 中。让我们开始吧：
- en: 'The SecretProviderClass requires you to know your Azure Active Directory tenant
    ID. To get this, run the following command:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SecretProviderClass 需要你知道 Azure Active Directory 租户 ID。要获取此信息，请运行以下命令：
- en: '[PRE33]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will show you an output similar to *Figure 10.29*. Copy-paste this value
    and store it in a file you can refer to later:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示一个类似于*图 10.29*的输出。复制并粘贴此值，并将其存储在以后可以引用的文件中：
- en: '![Fetching the tenant ID for creatingthe SecretProviderClass](img/B17338_10_29.jpg)'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![获取用于创建 SecretProviderClass 的租户 ID](img/B17338_10_29.jpg)'
- en: '[PRE34]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s investigate this file:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们研究一下这个文件：
- en: '`SecretProviderClass`.'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecretProviderClass`。'
- en: '`SecretProviderClass`.'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecretProviderClass`。'
- en: '**Line 15**: The AAD tenant ID of your AAD tenant.'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 15 行**：你的 AAD 租户的 AAD 租户 ID。'
- en: Make sure to edit this with the values for your environment.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保根据你的环境值进行编辑。
- en: 'You can create this `SecretProviderClass` using the following command:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用以下命令创建此 `SecretProviderClass`：
- en: '[PRE35]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once the SecretProviderClass has been created, you can go ahead and create
    a pod that references that SecretProviderClass. An example has been provided in
    the `pod-keyvault-file.yaml` file:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了 SecretProviderClass，你就可以继续创建一个引用该 SecretProviderClass 的 Pod。示例已提供在 `pod-keyvault-file.yaml`
    文件中：
- en: '[PRE36]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s have a look at the key parts of this file:'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们来看看这个文件的关键部分：
- en: '**Line 5-6**: This is where you link this pod to the managed identity you created
    earlier.'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 5-6 行**：在这里，你将 Pod 与之前创建的托管身份关联。'
- en: '**Line 11-14**: Here, you define where you want to mount the secrets.'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 11-14 行**：在这里，你定义了要挂载密钥的位置。'
- en: '**Line 15-21**: Here, you define the actual Volume and the link to Key Vault.
    On line 21, you refer to the SecretProviderClass you created earlier.'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 15-21 行**：在这里，你定义了实际的卷和与 Key Vault 的链接。在第 21 行，你引用了之前创建的 SecretProviderClass。'
- en: 'You can create this pod using the following command:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用以下命令创建这个 Pod：
- en: '[PRE37]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Monitor the Pod''s creation using the following command:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令监控 Pod 的创建：
- en: '[PRE38]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This should return an output similar to *Figure 10.30*:'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会返回一个类似于*图 10.30*的输出：
- en: '![Verifying that the status of thecsi-demo-file pod changes to Running](img/B17338_10_30.jpg)'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![验证 csi-demo-file Pod 的状态是否变更为 Running](img/B17338_10_30.jpg)'
- en: 'Figure 10.30: Status of the csi-demo-file pod changes to Running'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.30：csi-demo-file Pod 的状态变更为 Running
- en: 'Once the pod is created and running, you can open a shell in the pod using
    the `kubectl exec` command and verify that the secret is present:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 Pod 创建并运行，你可以使用 `kubectl exec` 命令在 Pod 中打开一个 Shell，并验证密钥是否存在：
- en: '[PRE39]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This should output the secret you created in Key Vault, as seen in *Figure
    10.31*:'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会输出你在 Key Vault 中创建的密钥，如*图 10.31*所示：
- en: '![Verifying that the Secret is mounted in the Pod](img/B17338_10_31.jpg)'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![验证密钥是否已挂载到 Pod 中](img/B17338_10_31.jpg)'
- en: 'Figure 10.31: The secret you configured in Key Vault is mounted in the pod
    as a file'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.31：你在 Key Vault 中配置的密钥作为文件挂载在 Pod 中
- en: And as expected, you are able to get the secret you configured in Key Vault
    to show up in Kubernetes.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如预期的那样，你能够将你在 Key Vault 中配置的密钥显示在 Kubernetes 中。
- en: You can now exit out of the shell to the container using the `exit` command.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以使用 `exit` 命令退出容器的 Shell。
- en: As you can see, you successfully used the CSI driver for Key Vault to get a
    secret from Key Vault to show up as a file in a pod.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你成功地使用了 CSI 驱动程序从 Key Vault 获取密钥，并将其作为文件显示在 Pod 中。
- en: It is also possible to sync secrets in Key Vault to secrets in Kubernetes and
    then use them as an environment variable in running pods. That's what you'll explore
    in the next and final section of this chapter.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 Key Vault 中的密钥同步到 Kubernetes 中的密钥，然后在运行中的 Pod 中将它们作为环境变量使用。接下来和本章的最后一部分将会探讨这一点。
- en: Using a Key Vault secret as an environment variable
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Key Vault 密钥作为环境变量
- en: In the previous section, you saw how to access Key Vault secrets as a file in
    a pod. As you learned earlier in this chapter, it is recommended that you use
    Kubernetes secrets as a file.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分中，你看到如何将 Key Vault 密钥作为文件在 Pod 中访问。如本章之前所学，建议你将 Kubernetes 密钥作为文件使用。
- en: However, there are situations where you cannot modify an application to use
    secrets as a file and you need to use them as environment variables. This can
    be done using the CSI driver for Key Vault, and you will configure the driver
    that way in this section. Please note that in order for the CSI driver to sync
    secrets in Key Vault to Secrets in Kubernetes, you need to mount the secret as
    a Volume in Kubernetes; you cannot only rely on the secret syncing.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下你不能修改应用程序以将秘密用作文件，而必须将其用作环境变量。你可以通过使用 Key Vault 的 CSI 驱动程序来完成这一点，在本节中你将配置该驱动程序。请注意，为了让
    CSI 驱动程序将 Key Vault 中的秘密同步到 Kubernetes 中的 Secrets，你需要将秘密作为卷挂载到 Kubernetes；不能仅依赖于秘密的同步。
- en: 'Let''s configure all of this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置所有这些内容：
- en: 'First, you''ll create the SecretProviderClass. An example has been provided
    in the code files for this chapter, in the `secretproviderclass-env.yaml` file:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你将创建 SecretProviderClass。示例代码已在本章的代码文件中提供，位于 `secretproviderclass-env.yaml`
    文件中：
- en: '[PRE40]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s investigate what''s different in this file versus the previous one you
    created:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们查看此文件与之前创建的文件有什么不同：
- en: '`secretName`: This refers to the name of the secret in Kubernetes that will
    be created.'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secretName`：这指的是将在 Kubernetes 中创建的秘密名称。'
- en: '`objectName`: This refers to the `objectName` on line 13, which is the name
    of the secret in Key Vault.'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objectName`：这指的是第 13 行的 `objectName`，即 Key Vault 中秘密的名称。'
- en: '`key`: This is the name of the key in the secret in Kubernetes. As was explained
    earlier in this chapter, a single secret in Kubernetes can contain multiple keys.'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key`：这是 Kubernetes 中秘密的键名称。如本章前面所解释的，Kubernetes 中的单个秘密可以包含多个键。'
- en: The remaining sections of this file are similar to the earlier SecretProviderClass
    you created.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件的其余部分与之前你创建的 SecretProviderClass 类似。
- en: 'You can create this SecretProviderClass using the following command:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用以下命令创建这个 SecretProviderClass：
- en: '[PRE41]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once the SecretProviderClass has been created, you can go ahead and create
    a pod that references that SecretProviderClass. You cannot rely solely on the
    syncing of the secrets, the SecretProviderClass has to be mounted in order for
    the CSI driver to sync the secrets. An example has been provided in the `pod-keyvault-env.yaml`
    file:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 SecretProviderClass 创建完成，你可以继续创建一个引用该 SecretProviderClass 的 pod。你不能仅依赖于秘密的同步，必须将
    SecretProviderClass 挂载才能使 CSI 驱动程序同步秘密。在 `pod-keyvault-env.yaml` 文件中提供了一个示例：
- en: '[PRE42]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The difference between this pod and the previous one you created is on *lines
    11 to 16*. This should seem familiar, as this is the typical way to use a secret
    as an environment variable.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 pod 和你之前创建的 pod 的区别在于*第 11 到第 16 行*。这应该很熟悉，因为这是使用秘密作为环境变量的典型方式。
- en: 'You can create this pod using the following command:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用以下命令创建这个 pod：
- en: '[PRE43]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Monitor the Pod''s creation using the following command:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令监控 Pod 的创建：
- en: '[PRE44]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This should return an output similar to *Figure 10.32*:'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该返回类似于*图 10.32*的输出：
- en: '![Monitoring the creation of the csi-demo-env Pod](img/B17338_10_32.jpg)'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![监控 csi-demo-env Pod 创建过程](img/B17338_10_32.jpg)'
- en: 'Figure 10.32: Waiting for the csi-demo-env pod to run'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.32：等待 csi-demo-env pod 启动
- en: 'Once the pod is created and running, you can open a shell in the pod using
    the `kubectl exec` command and verify that the secret is present:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 pod 创建并运行，你可以使用 `kubectl exec` 命令打开 pod 中的 shell，并验证秘密是否存在：
- en: '[PRE45]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This should output the secret you created in Key Vault, as seen in *Figure
    10.33*:'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该输出你在 Key Vault 中创建的秘密，如*图 10.33*所示：
- en: '![The Secret you configured in Key Vaultis used as an environment variable](img/B17338_10_33.jpg)'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![你在 Key Vault 中配置的秘密作为环境变量使用](img/B17338_10_33.jpg)'
- en: 'Figure 10.33: The secret you configured in Key Vault is used as an environment
    variable'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.33：你在 Key Vault 中配置的秘密作为环境变量使用
- en: You can now exit out of the shell to the container using the `exit` command.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以使用 `exit` 命令退出容器的 shell。
- en: 'Finally, you can also verify that the secret was created in Kubernetes by running
    the following command:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你还可以通过运行以下命令验证秘密是否在 Kubernetes 中创建：
- en: '[PRE46]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This should show you an output similar to *Figure 10.34*:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该显示类似于*图 10.34*的输出：
- en: '![The synced secret is available using the kubectl get secret command](img/B17338_10_34.jpg)'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![同步的秘密可以通过 kubectl get secret 命令访问](img/B17338_10_34.jpg)'
- en: 'Figure 10.34: The key-vault-secret secret in Kubernetes is synced with the
    Key Vault secret'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.34：Kubernetes 中的 key-vault-secret 秘密与 Key Vault 中的秘密同步
- en: 'This secret will disappear once no more pods that mount the secret are present.
    You can verify this with the following commands:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦没有挂载该 Secret 的 Pod 存在时，这个 Secret 就会消失。您可以通过以下命令验证这一点：
- en: '[PRE47]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This should show you an output similar to *Figure 10.35*:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会显示类似于*图 10.35*的输出：
- en: '![Deleting the pod will automatically delete the Secret as well](img/B17338_10_35.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![删除 Pod 会自动删除 Secret](img/B17338_10_35.jpg)'
- en: 'Figure 10.35: Deleting the pod automatically deletes the secret as well'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.35：删除 Pod 会自动删除 Secret
- en: This shows you that although you have a SecretProviderClass that tries to sync
    a Key Vault secret to a Kubernetes secret, that syncing only happens once a pod
    references that SecretProviderClass and mounts the secret.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了尽管您有一个 SecretProviderClass，尝试将 Key Vault 密钥同步到 Kubernetes 密钥，但该同步仅在 Pod
    引用该 SecretProviderClass 并挂载密钥时发生。
- en: In this section, you've been able to sync a secret in Key Vault to a secret
    in Kubernetes. You were able to access that secret's value in a pod using environment
    variables.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经能够将 Key Vault 中的一个密钥同步到 Kubernetes 中的密钥。您能够通过环境变量在 Pod 中访问该密钥的值。
- en: 'This also concludes this chapter on secrets in Kubernetes. Let''s make sure
    to clean up all the objects that we created:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 本章也就此结束，关于 Kubernetes 中的密钥。让我们确保清理所有我们创建的对象：
- en: '[PRE48]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Once the resources are deleted, you are ready to move on to the next chapter
    about network security in AKS.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦资源被删除，您就可以继续下一章关于 AKS 中网络安全的内容。
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about secrets in Kubernetes. You worked with both
    the default secret mechanism in Kubernetes as well as with the Azure Key Vault
    provider for Secrets Store CSI driver.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了 Kubernetes 中的密钥。您既使用了 Kubernetes 中的默认密钥机制，也使用了 Azure Key Vault 提供的
    Secrets Store CSI 驱动程序。
- en: This chapter started by explaining different secret types in Kubernetes. After
    that, you used different mechanisms in Kubernetes to create secrets. You then
    used two methods of accessing those secrets, using them as files or as environment
    variables.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时介绍了 Kubernetes 中的不同密钥类型。接下来，您使用 Kubernetes 中的不同机制创建了密钥。然后，您使用了两种访问密钥的方法：通过文件或通过环境变量。
- en: 'After that, you created a managed identity and a key vault to experiment with
    the CSI driver for Key Vault. You installed that on your cluster and used two
    mechanisms to access secrets in Key Vault: either using files or using environment
    variables.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您创建了一个托管身份和一个密钥库，以便实验 Key Vault 的 CSI 驱动程序。您将其安装在集群中，并使用两种机制访问 Key Vault
    中的密钥：通过文件或通过环境变量。
- en: In the next chapter, you'll learn more about network security in AKS.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，您将进一步了解 AKS 中的网络安全。
