- en: 10\. Storing secrets in AKS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All production applications require some sensitive information to function,
    such as passwords or connection strings. Kubernetes has a pluggable back end to
    manage these secrets. Kubernetes also provides multiple ways of using the secrets
    in your deployment. The ability to manage secrets and use them properly will make
    your applications more secure.
  prefs: []
  type: TYPE_NORMAL
- en: You have already used secrets previously in this book. You used them when connecting
    to the WordPress site to create blog posts in *Chapter 3, Application deployment
    on AKS*, and *Chapter 4, Building scalable applications*. You also used secrets
    in *Chapter 6, Securing your application with HTTPS*, when you were configuring
    the Application Gateway Ingress Controller with TLS.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes has a built-in secret system that stores secrets in a semi-encrypted
    fashion in the default Kubernetes database. This system works well but isn't the
    most secure way to deal with secrets in Kubernetes. In AKS, you can make use of
    a project called **Azure Key Vault provider for Secrets Store CSI driver** (**CSI
    driver**), which is a more secure way of working with Secrets in Kubernetes. This
    project allows you to store and retrieve secrets in/from Azure Key Vault.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the various built-in secret types in Kubernetes
    and the different ways in which you can create these Secrets. After that, you
    will install the CSI driver on your cluster, and use it to retrieve Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, you will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Different types of secret in Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using secrets in Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the Azure Key Vault provider for secrets Store CSI driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Azure Key Vault provider for secrets Store CSI driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with exploring the different secret types in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Different secret types in Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the introduction to this chapter, Kubernetes comes with a default
    secrets implementation. This default implementation will store secrets in the
    etcd database that Kubernetes uses to store all object metadata. When Kubernetes
    stores secrets in etcd, it will store them in base64-encoded format. Base64 is
    a way to encode data in an obfuscated manner but is not a secure way of doing
    encryption. Anybody with access to base64-encoded data can easily decode it. AKS
    adds a layer of security on top of this by encrypting all data at rest within
    the Azure platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default secret implementation in Kubernetes allows you to store multiple
    types of Secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Opaque secrets**: These can contain any arbitrary user-defined secret or
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service account tokens**: These are used by Kubernetes pods for built-in
    cluster RBAC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker config secrets**: These are used to store Docker registry credentials
    for Docker command-line configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Basic authentication secrets**: These are used for storing authentication
    information in the form of a username and password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSH authentication secrets**: These are used to store SSH private keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TLS certificates**: These are used to store TLS/SSL certificates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bootstrap token Secrets**: These are used to store bearer tokens that are
    used when creating new clusters or joining new nodes to an existing cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user of Kubernetes, you most typically will work with opaque secrets and
    TLS certificates. You've already worked with TLS secrets in *Chapter 6, Securing
    your application with HTTPS*. In this chapter, you will focus on opaque secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes provides three ways of creating secrets, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating secrets from files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating secrets from YAML or JSON definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating secrets from the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using any of the preceding methods, you can create any type of secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes gives you two ways of consuming secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: Using secrets as an environment variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting secrets as a file in a pod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, you will create secrets using the three ways mentioned
    here, and you will later consume them using both the methods listed here.
  prefs: []
  type: TYPE_NORMAL
- en: Creating secrets in Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Kubernetes, there are three different ways to create secrets: from files,
    from YAML or JSON definitions, or directly from the command line. Let''s start
    the exploration of how to create secrets by creating them from files.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Secrets from files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first way to create secrets in Kubernetes is to create them from a file.
    In this way, the contents of the file will become the value of the secret, and
    the filename will be the identifier of each value within the secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that you need to store a URL and a secure token for accessing an
    API. To achieve this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Store the URL in `secreturl.txt`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Store the token in another file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let Kubernetes create the secret from the files, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Please note that you are creating a single secret object in Kubernetes, referring
    to both text files. In this command, you are creating an opaque secret by using
    the `generic` keyword.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The command should return an output similar to *Figure 10.1*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Creating a Secret using the contents of the secreturl.txt file](img/B17338_10_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.1: Creating an opaque secret'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can check whether the secrets were created in the same way as any other
    Kubernetes resource by using the `get` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This command will return an output similar to *Figure 10.2*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Verifying the creation of your Secret using the kubectl get secrets command](img/B17338_10_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.2: List of the created secrets'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, you will see the secret you just created, and any other secrets that are
    present in the `default` namespace. The secret is of the `Opaque` type, which
    means that, from Kubernetes' perspective, the schema of the contents is unknown.
    It is an arbitrary key-value pair with no constraints, as opposed to, for example,
    SSH auth or TLS secrets, which have a schema that will be verified as having the
    required details.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For more details about the secret, you can also run the `describe` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get an output similar to *Figure 10.3*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Fetching the detailed description of the Secret using the describe command](img/B17338_10_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.3: Description of the created secret'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, neither of the preceding commands displayed the actual secret values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To see the secret''s value, you can run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get an output similar to *Figure 10.4*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Using the -o yaml switch in kubectl get secret fetches the encoded value
    of the Secret](img/B17338_10_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.4: Using the -o yaml switch in kubectl get secret fetches the encoded
    value of the secret'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The data is stored as key-value pairs, with the filename as the key and the
    base64-encoded contents of the file as the value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The preceding values are base64-encoded. Base64 encoding isn''t secure. It
    obfuscates the secret so it isn''t easily readable by an operator, but any bad
    actor can easily decode a base64-encoded secret. To get the actual values, you
    can run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get the values of the secrets that were originally created:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![The Base64-encoded Secret is decoded using the base 64 -d command](img/B17338_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Base64-encoded secrets can easily be decoded'
  prefs: []
  type: TYPE_NORMAL
- en: This shows you that the secrets are not securely encrypted in the default Kubernetes
    secret store.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you were able to create a secret containing an example URL
    with a secure token using files as the source. You were also able to get the actual
    secret values back by decoding the base64-encoded secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on and explore the second method of creating Kubernetes secrets,
    creating secrets from YAML definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating secrets manually using YAML files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, you created a secret from a text file. In this section,
    you will create the same secret using YAML files by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to encode the secret to `base64`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get the following value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You might notice that this is the same value that was present when you got the
    `yaml` definition of the secret in the previous section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, for the `url` value, you can get the base64-encoded value, as shown
    in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will give you the base64-encoded URL:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now create the secret definition manually; then, save the file. This
    file has been provided in the code bundle as `myfirstsecret.yaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s investigate this file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Opaque` secret, meaning that from Kubernetes'' perspective, values are unconstrained
    key-value pairs.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 7-8**: These are the base64-encoded values of the secret.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You might notice that this YAML is very similar to the return you got in the
    previous section. This is because the object you use to create the secret in Kubernetes
    is stored with a bit more metadata on the Kubernetes API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now you can create the secret in the same way as any other Kubernetes resource
    by using the `create` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return an output similar to *Figure 10.6*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Creating a Secret from a YAML file](img/B17338_10_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.6: The secret was successfully created from a YAML file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can verify whether the secret was successfully created using this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will show you an output similar to *Figure 10.7*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Verifying the creation of your Secret using the kubectl get secrets command](img/B17338_10_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.7: List of the created secrets'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can double-check that the secrets are the same by using `kubectl get -o
    yaml secrets myapiurltoken-yaml` in the same way that was described in the previous
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This described a second way of creating secrets in Kubernetes. In the next section,
    you will learn the final way to create secrets, using literals in kubectl.
  prefs: []
  type: TYPE_NORMAL
- en: Creating generic secrets using literals in kubectl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The third method of creating secrets is by using the `literal` method, which
    means you pass the value in kubectl on the command line. As you have seen in the
    previous examples, a single secret in Kubernetes can contain multiple values.
    In the command to create a secret using the `literal` method, you use the syntax
    `--from-literal=<key>=<value>` to identify the different values in a secret:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a secret using the `literal` method, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return an output similar to *Figure 10.8*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Creating a Secretusing a literal values](img/B17338_10_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.8: The secret was successfully created using a literal value in kubectl'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can verify that the secret was created by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will give us a similar output to *Figure 10.9*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Verifying the creation of your Secret using the kubectl get secrets command](img/B17338_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Verifying the secret created using the literal method'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, you have created secrets using literal values in addition to the preceding
    two methods.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you've created Kubernetes secrets using three methods. In the
    next section, you'll explore two methods of using those secrets in your pods and
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using your secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once secrets have been created, they need to be linked to the application.
    This means that Kubernetes needs to pass the value of the secret to the running
    pods in some way. Kubernetes offers two ways to link your secrets to your application:'
  prefs: []
  type: TYPE_NORMAL
- en: Using secrets as environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting secrets as files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting secrets as files is the best way to consume secrets in your application.
    In this section, we will explain both methods, and also show why it's best to
    use the second method. Let's start by accessing secrets as environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets as environment variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use a secret in Kubernetes by referencing it as an environment variable.
    secrets can then be referenced in the pod definition under the `containers` and
    `env` sections. You will use the secrets that you previously created in a pod
    and learn how to use them in an application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can configure a pod with environment variable secrets like the definition
    provided in `pod-with-env-secrets.yaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s inspect this file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`secreturl.txt` file in the `myapi-url-token` secret.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`secrettoken.txt` file in the `myapi-url-token` secret.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When Kubernetes creates a pod on a node that needs to use a secret, it will
    store that secret on that host in `tmpfs`, a temporary file system that is not
    written to disk. When the last pod referencing that secret is no longer running
    on that node, the secret is deleted from the node's `tmpfs`. If a node is shut
    down or rebooted, `tmpfs` is always erased.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now create the pod and see whether you can access the secrets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the environment variables are set correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should show you a result similar to *Figure 10.10*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Accessing the Secret inside the pod](img/B17338_10_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.10: You can get the secrets inside the pod'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can now exit out of the shell to the container using the `exit` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are a couple of things to note in this example. First, note that when
    you access the environment variables, you get the actual value of the secret back,
    not the base64-encoded value. This is as expected, since the base64 encoding is
    only applied at the Kubernetes API level, not at the application level.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to note is that you were able to access the secret by opening
    a shell into that running container and echoing the secret. It is important to
    apply the right level of RBAC to pods in Kubernetes, so that not every cluster
    user is able to run the `exec` command and open a shell.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that both the application, in the form of the container image, and
    the pod definition had no hardcoded secrets. The secrets were provided by the
    dynamic configuration in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: The final thing to note is that any application can use the secret values by
    referencing the appropriate `env` variables. There is no way to limit which processes
    in a container can access which environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to know about secrets that are used as environment variables
    is that the value of the environment variable will not be updated when the secret
    itself is updated. This might cause you to end up in a state where pods that are
    created after a secret is updated have a different environment variable value
    compared to the pods created before the secret was updated.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you explored how to access secrets from within a running pod
    using environment variables. In the next section, you will explore how to achieve
    this using files.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets as files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to mount the same secrets as files rather than environment
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will use the following pod definition to demonstrate how this can be done.
    It is provided in the `pod-with-vol-secrets.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s have a closer look at this file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`/etc/secrets` directory as read-only.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`env` definition, as you don''t have to define a name for each secret. However,
    applications need to have special code to read the contents of the file in order
    to load it properly.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see whether the secrets made it through. Create the pod using the following
    command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Echo the contents of the files in the mounted volume:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see in *Figure 10.11*, the secrets are present in the pod:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Echoing the contents of the files containing the secrets in the mounted volume
    ](img/B17338_10_11.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.11: The secrets are available as files in our pod'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You can now exit out of the shell to the container using the `exit` command.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a couple of things to note here as well. First, note that the secrets
    again are available in plain text and not in base64.
  prefs: []
  type: TYPE_NORMAL
- en: Second, since the secrets are mounted as a file, file system permissions apply
    to these secrets. This means that you can limit which processes can get access
    to the contents of these files.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Secrets mounted as files will be dynamically updated as the secrets
    are updated.
  prefs: []
  type: TYPE_NORMAL
- en: You have now learned two ways in which secrets can be passed to a running container.
    In the next section, it will be explained why it's best practice to use the file
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Why secrets as files is the best method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although it is a common practice to use secrets as environment variables, it
    is more secure to mount secrets as files. Kubernetes treats secrets as environment
    variables securely, but the container runtime doesn''t treat them securely. To
    verify this, you can run the following commands to see the secret in plain text
    in the Docker runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by getting the node that the pod using environment variables from the
    earlier example is running on with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should show you the instance ID, as seen in *Figure 10.12*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Fetching the Instance ID of the node by describing the pod](img/B17338_10_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.12: Getting the instance ID'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, get the Docker ID of the running pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give you the container ID:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Fetching the Docker ID of the running pod](img/B17338_10_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.13: Getting the Docker ID'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, you will execute a command on the node running your container to show
    the secret that was passed as an environment variable. First, let''s set a couple
    of variables you''ll use later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The previous command assumes you have a single AKS cluster with one node pool
    in your subscription. If this is not the case, please change the values of `VMSS`
    and `RGNAME` to the name of the value of the scale set and resource group running
    your cluster.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Depending on your node version, you will run either of the following commands.
    For clusters running on Kubernetes version 1.18.x or earlier, run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return an output similar to *Figure 10.14*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Output showing the decoded secret in the Docker runtime ](img/B17338_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.14: The Secrets are decoded in the Docker runtime'
  prefs: []
  type: TYPE_NORMAL
- en: 'For clusters running version 1.19 or later, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show you an output similar to *Figure 10.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output showing the decoded secret in the containerd runtime ](img/B17338_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.15: The secrets are decoded in the containerd runtime'
  prefs: []
  type: TYPE_NORMAL
- en: This shows you both secrets in plain text in the container runtime, whether
    Docker (AKS version before 1.19) or containerd (AKS versions 1.19 and above).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the secrets are decoded in the container runtime command. This
    means that most logging systems will log these sensitive secrets. Hence, it's
    advised to use secrets as files, since they are not passed in plain text except
    to the pod and the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make sure to clean up the resources we created in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have explored secrets in Kubernetes using the default secrets mechanism,
    let's go ahead and use a more secure option, namely Azure Key Vault.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Azure Key Vault provider for Secrets Store CSI driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you explored secrets that were stored natively in Kubernetes.
    This means they were base64-encoded on the Kubernetes API server. You saw in the
    previous section that base64-encoded secrets are not secure at all. For highly
    secure environments, you will want to use a better secret store.
  prefs: []
  type: TYPE_NORMAL
- en: Azure offers an industry-compliant key and secret storage solution called Azure
    Key Vault. It is a managed service that makes creating, storing, and retrieving
    keys and secrets easy, and offers auditing of access to your keys and secrets.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes community maintains a project called the Kubernetes Secrets Store
    CSI driver (https://github.com/kubernetes-sigs/secrets-store-csi-driver). This
    project allows you to integrate external secret stores with volumes in Kubernetes
    through the CSI driver. The Container Storage Interface is a standardized way
    in Kubernetes to interface with storage systems. There are multiple implementations
    of the Secret Store CSI driver. At the time of writing, the current implementations
    are Hashicorp Vault, Google Cloud Platform, and Azure Key Vault.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft maintains the Key Vault implementation of the Secret Store CSI driver,
    named Azure Key Vault provider for Secrets Store CSI driver. This implementation
    allows you as a user to access Key Vault secrets from within Kubernetes. It is
    also integrated with pod identities to restrict access to secrets. Optionally,
    this implementation can also sync Key Vault secrets with Kubernetes secrets so
    you can use them as an environment variable if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For brevity, we'll refer to Azure Key Vault provider for Secrets Store CSI driver
    as the CSI driver for Key Vault.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the CSI driver for Key Vault is only available as an
    open-source project that you can install on your cluster. It is worth noting that
    this solution might be introduced as a managed add-on to AKS in the future. For
    more up-to-date details, please refer to this issue on GitHub at https://github.com/Azure/AKS/issues/1876.
  prefs: []
  type: TYPE_NORMAL
- en: To work with the CSI driver for Key Vault, there are two things you need to
    do. First, you need to set up the driver itself on your cluster. That is the goal
    of this section. Secondly, you'll need to create an object in Kubernetes called
    a `SecretProviderClass` for each secret from Key Vault you need to access. You
    will learn more about this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will set up the CSI driver for Key Vault. First, you will
    create a new user-assigned managed identity. After that, you'll create a new key
    vault and give the user-assigned managed identity permissions to that key vault.
    Finally, you'll set up the CSI driver for Key Vault on your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a new managed identity.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a managed identity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The CSI driver for Key Vault supports different ways of getting data out of
    Key Vault. It is recommended that you use a managed identity to link your Kubernetes
    cluster to Key Vault. For this, you can use the AAD pod-managed identity add-on
    that you set up in the previous chapter. In this section, you''ll create a new
    managed identity in Azure to later use with Key Vault:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new managed identity. You will use the Azure portal to do this.
    To start, look for `managed identity` in the Azure search bar, as shown in *Figure 10.16*:![Searching
    for Managed Identity in the Azure search bar](img/B17338_10_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.16: Looking for managed identity in the Azure search bar'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the resulting pane, click the + New button at the top. To organize the resources
    for this chapter together, it's recommended to create a new resource group. In
    the resulting pane, click the Create new button to create a new resource group.
    Call it `csi-key-vault`, as shown in *Figure 10.17*:![Creating a new resource
    group for creating a new managed identity](img/B17338_10_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.17: Creating a new resource group'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, select the region you created your cluster in as the region for your managed
    identity and give it a name, `csi-key-vault` if you follow the example, as shown
    in *Figure 10.18*. To finish, click the Review + create button and in the final
    window, click the Create button to create your managed identity:![Providing Instance
    details for the managed identity](img/B17338_10_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.18: Providing Instance details'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the managed identity has been created, hit the Go to resource button to
    go to the resource. Here, you will need to copy the resource ID that will be used
    later in the next step. You can find that in the Properties pane of the managed
    identity, as shown in *Figure 10.19*:![Fetching the resource ID from the Properties
    pane of the managed identity](img/B17338_10_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.19: Getting the Resource ID of the managed identity'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now you are ready to link the managed identity to your AKS cluster. To do this,
    you will run a command in cloud shell as you did in the previous chapter. Afterward,
    you will verify that the identity is available in your cluster. Let''s start with
    linking the identity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can verify that your identity was successfully linked to your cluster by
    running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should produce an output similar to *Figure 10.20*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Verifying that your identity is successfully linked to your cluster](img/B17338_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.20: Verifying the availability of the identity in the cluster'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you created a new managed identity and linked that to your
    Kubernetes cluster using the AAD Pod-managed identity add-on. In the next section,
    you'll create a key vault and give the new identity you created access to the
    secrets. Finally, you'll create a secret in Key Vault that you try to access later
    from your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a key vault
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, you set up the managed identity that the CSI driver
    for Key Vault will use. In this section, you''ll create the key vault that will
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: To start the creation process, look for `Key vaults` in the Azure search bar:![Navigating
    to Key Vault services from the Azure portal](img/B17338_10_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.21: Navigating to Key vaults through the Azure portal'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the + New button to start the creation process:![Creating a new key vault](img/B17338_10_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.22: Click the Add button to start creating a key vault'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Provide the details to create the key vault. Create the key vault in the resource
    group you created in the previous step. The key vault's name has to be globally
    unique, so consider adding your initials to the name. It is recommended that you
    create the key vault in the same region as your cluster:![Providing Subscription
    and Instance details to create the key vault](img/B17338_10_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.23: Providing the details to create the key vault'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After you have provided the details for your key vault, click the Next: Access
    policy > button to give the managed identity access to secrets. Click on the +
    Add Access Policy to give permission to your managed identity, as shown in *Figure
    10.24*:![Adding a new access policy](img/B17338_10_24.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.24: Adding an Access policy'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the resulting pane, select the Secret Management template, click on the
    None Selected button underneath Select principal, and in the resulting pane look
    for the `csi-to-key-vault` you created earlier. Finally, click on Select at the
    bottom of the screen and then on Add, as shown in *Figure 10.25*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Assigning the Secret Management template in the access policy to the csi-to-key-vault
    managed identity](img/B17338_10_25.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.25: Assigning the Secret Management template to your managed identity'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you have provided permissions to this managed identity, hit the Review
    + create button to review and create your key vault. Hit the Create button to
    finish the creation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will take a couple of seconds to create your key vault. Once the vault is
    created, click on the Go to resource button, go to Secrets, and hit the Generate/Import
    button to create a new secret as shown in *Figure 10.26*:![Creating a new Secret
    within the key vault](img/B17338_10_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.26: Creating a new secret'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the secret creation wizard, provide the details about your secret. To make
    this demonstration easier to follow, use the name `k8s-secret-demo`. Give the
    secret a memorable value, such as `secret-coming-from-key-vault`. Click the Create
    button at the bottom of the screen to create the secret:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Configuring the Secret](img/B17338_10_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.27: Providing the details for your new secret'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a secret in Key Vault, you can move ahead and install the
    actual CSI driver for Key Vault in your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the CSI driver for Key Vault
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, you will set up the CSI driver for Key Vault in your cluster.
    This will allow you, in the next section, to retrieve secrets from Key Vault.
    The installation is a short process, as you will see here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to install the CSI driver for Key Vault is to use Helm, as
    you''ve done before. Note that this feature may be available as an add-on after
    the release of this book. To do this, add the repo for the CSI driver for Key
    Vault:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the repo has been added, you can install the actual CSI driver for Key
    Vault using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To verify that the installation succeeded, you can verify that the SecretProviderClass
    CRD has been added to your cluster via the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should show you an output that contains the SecretProviderClass CRD as
    shown in *Figure 10.28*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Verifying that the SecretProviderClass CRD has been added to your cluster](img/B17338_10_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.28: The SecretProviderClass CRD has been added to the cluster'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the setup of the CSI driver for Key Vault. In this section, you
    first created a managed identity, then created a key vault with a secret in it,
    and then finally set up the CSI driver for Key Vault on your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: You are now ready to use the CSI driver for Key Vault, which you'll do in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Azure Key Vault provider for Secrets Store CSI driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the CSI driver for Key Vault has been set up on your cluster, you are
    ready to start using it. In this section, you'll run through two examples of using
    the CSI driver for Key Vault. First, you will use it to mount a secret as a file
    in Kubernetes. Afterward, you will also use it to sync Key Vault secrets to Kubernetes
    secrets and use them as an environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with the first example, how to mount Key Vault secrets as
    a file.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a Key Vault secret as a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this first example, you will create a new SecretProviderClass in your cluster.
    This object will allow you to link a secret in Key Vault to a pod in Kubernetes.
    After that, you''ll create a pod that uses that SecretProviderClass and mounts
    the secrets in that pod. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SecretProviderClass requires you to know your Azure Active Directory tenant
    ID. To get this, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will show you an output similar to *Figure 10.29*. Copy-paste this value
    and store it in a file you can refer to later:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Fetching the tenant ID for creatingthe SecretProviderClass](img/B17338_10_29.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s investigate this file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SecretProviderClass`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SecretProviderClass`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 15**: The AAD tenant ID of your AAD tenant.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure to edit this with the values for your environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can create this `SecretProviderClass` using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the SecretProviderClass has been created, you can go ahead and create
    a pod that references that SecretProviderClass. An example has been provided in
    the `pod-keyvault-file.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s have a look at the key parts of this file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Line 5-6**: This is where you link this pod to the managed identity you created
    earlier.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 11-14**: Here, you define where you want to mount the secrets.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 15-21**: Here, you define the actual Volume and the link to Key Vault.
    On line 21, you refer to the SecretProviderClass you created earlier.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can create this pod using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Monitor the Pod''s creation using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return an output similar to *Figure 10.30*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Verifying that the status of thecsi-demo-file pod changes to Running](img/B17338_10_30.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.30: Status of the csi-demo-file pod changes to Running'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the pod is created and running, you can open a shell in the pod using
    the `kubectl exec` command and verify that the secret is present:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should output the secret you created in Key Vault, as seen in *Figure
    10.31*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Verifying that the Secret is mounted in the Pod](img/B17338_10_31.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.31: The secret you configured in Key Vault is mounted in the pod
    as a file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And as expected, you are able to get the secret you configured in Key Vault
    to show up in Kubernetes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can now exit out of the shell to the container using the `exit` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, you successfully used the CSI driver for Key Vault to get a
    secret from Key Vault to show up as a file in a pod.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to sync secrets in Key Vault to secrets in Kubernetes and
    then use them as an environment variable in running pods. That's what you'll explore
    in the next and final section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Key Vault secret as an environment variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, you saw how to access Key Vault secrets as a file in
    a pod. As you learned earlier in this chapter, it is recommended that you use
    Kubernetes secrets as a file.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are situations where you cannot modify an application to use
    secrets as a file and you need to use them as environment variables. This can
    be done using the CSI driver for Key Vault, and you will configure the driver
    that way in this section. Please note that in order for the CSI driver to sync
    secrets in Key Vault to Secrets in Kubernetes, you need to mount the secret as
    a Volume in Kubernetes; you cannot only rely on the secret syncing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s configure all of this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you''ll create the SecretProviderClass. An example has been provided
    in the code files for this chapter, in the `secretproviderclass-env.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s investigate what''s different in this file versus the previous one you
    created:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`secretName`: This refers to the name of the secret in Kubernetes that will
    be created.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`objectName`: This refers to the `objectName` on line 13, which is the name
    of the secret in Key Vault.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key`: This is the name of the key in the secret in Kubernetes. As was explained
    earlier in this chapter, a single secret in Kubernetes can contain multiple keys.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining sections of this file are similar to the earlier SecretProviderClass
    you created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can create this SecretProviderClass using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the SecretProviderClass has been created, you can go ahead and create
    a pod that references that SecretProviderClass. You cannot rely solely on the
    syncing of the secrets, the SecretProviderClass has to be mounted in order for
    the CSI driver to sync the secrets. An example has been provided in the `pod-keyvault-env.yaml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The difference between this pod and the previous one you created is on *lines
    11 to 16*. This should seem familiar, as this is the typical way to use a secret
    as an environment variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can create this pod using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Monitor the Pod''s creation using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return an output similar to *Figure 10.32*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Monitoring the creation of the csi-demo-env Pod](img/B17338_10_32.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.32: Waiting for the csi-demo-env pod to run'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the pod is created and running, you can open a shell in the pod using
    the `kubectl exec` command and verify that the secret is present:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should output the secret you created in Key Vault, as seen in *Figure
    10.33*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![The Secret you configured in Key Vaultis used as an environment variable](img/B17338_10_33.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.33: The secret you configured in Key Vault is used as an environment
    variable'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can now exit out of the shell to the container using the `exit` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, you can also verify that the secret was created in Kubernetes by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should show you an output similar to *Figure 10.34*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![The synced secret is available using the kubectl get secret command](img/B17338_10_34.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.34: The key-vault-secret secret in Kubernetes is synced with the
    Key Vault secret'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This secret will disappear once no more pods that mount the secret are present.
    You can verify this with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should show you an output similar to *Figure 10.35*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Deleting the pod will automatically delete the Secret as well](img/B17338_10_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.35: Deleting the pod automatically deletes the secret as well'
  prefs: []
  type: TYPE_NORMAL
- en: This shows you that although you have a SecretProviderClass that tries to sync
    a Key Vault secret to a Kubernetes secret, that syncing only happens once a pod
    references that SecretProviderClass and mounts the secret.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you've been able to sync a secret in Key Vault to a secret
    in Kubernetes. You were able to access that secret's value in a pod using environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also concludes this chapter on secrets in Kubernetes. Let''s make sure
    to clean up all the objects that we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Once the resources are deleted, you are ready to move on to the next chapter
    about network security in AKS.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about secrets in Kubernetes. You worked with both
    the default secret mechanism in Kubernetes as well as with the Azure Key Vault
    provider for Secrets Store CSI driver.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter started by explaining different secret types in Kubernetes. After
    that, you used different mechanisms in Kubernetes to create secrets. You then
    used two methods of accessing those secrets, using them as files or as environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you created a managed identity and a key vault to experiment with
    the CSI driver for Key Vault. You installed that on your cluster and used two
    mechanisms to access secrets in Key Vault: either using files or using environment
    variables.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn more about network security in AKS.
  prefs: []
  type: TYPE_NORMAL
