- en: Building Kubernetes on GCP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GCP上构建Kubernetes
- en: 'In this chapter, we will use **Google Cloud Platform** (**GCP**) in the following
    recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在以下配方中使用**Google Cloud Platform**（**GCP**）：
- en: Playing with GCP
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转GCP
- en: Setting up managed Kubernetes via **Google Kubernetes Engine** (**GKE**)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**Google Kubernetes Engine**（**GKE**）设置托管的Kubernetes
- en: Exploring Kubernetes CloudProvider on GKE
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GKE上探索Kubernetes CloudProvider
- en: Managing a Kubernetes cluster on GKE
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GKE上管理Kubernetes集群
- en: Playing with GCP
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转GCP
- en: GCP is getting popular in the public cloud industry. It has concepts similar
    to AWS, such as VPC, a compute engine, persistent disks, load balancing, and several
    managed services. The most interesting service is GKE, which is the managed Kubernetes
    cluster. We will explore how to use GCP and GKE.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: GCP在公有云行业越来越受欢迎。它有一些类似于AWS的概念，比如VPC、计算引擎、持久磁盘、负载均衡和多个托管服务。最有趣的服务是GKE，这是一个托管的Kubernetes集群。我们将探索如何使用GCP和GKE。
- en: Getting ready
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To use GCP, you need to have a Google account such as Gmail ([https://mail.google.com/mail/](https://mail.google.com/mail/))),
    which many people already have. Then sign up to GCP using your Google account
    by following these steps:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用GCP，你需要有一个Google账户，如Gmail（[https://mail.google.com/mail/](https://mail.google.com/mail/)），很多人已经拥有。然后，按照以下步骤使用你的Google账户注册GCP：
- en: Go to the [https://cloud.google.com](https://cloud.google.com) website then
    click the Try it free button
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://cloud.google.com](https://cloud.google.com)网站，然后点击“免费试用”按钮
- en: Log in to Google using your Google account
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的Google账户登录Google
- en: Register with GCP and enter your personal information and billing information
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GCP注册并输入你的个人信息和账单信息
- en: That's it!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！
- en: Once registration is complete, you'll see the GCP Web Console page. In the beginning,
    it may ask you to create one project; the default name could be My First Project.
    You can keep it, but we will create another project in this chapter, the better
    to help you understand.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注册完成后，你会看到GCP Web控制台页面。刚开始时，它可能会要求你创建一个项目；默认名称可能是“我的第一个项目”。你可以保留这个名称，但我们将在本章中创建另一个项目，更好地帮助你理解。
- en: The GCP Web Console is enough as a first step. But to keep using the Web Console
    is not recommended for DevOps, because human manual input always causes human
    errors and Google might change the Web Console design in the future.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: GCP Web控制台作为第一步已经足够。但不推荐DevOps持续使用Web控制台，因为人工输入总是会引发人为错误，而且Google未来可能会更改Web控制台的设计。
- en: Thus, we will use the CLI. GCP provides a CLI tool called Cloud SDK ([https://cloud.google.com/sdk/](https://cloud.google.com/sdk/)).
    So, let's create one new GCP project and then install Cloud SDK on your machine.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用CLI。GCP提供了一款名为Cloud SDK的CLI工具（[https://cloud.google.com/sdk/](https://cloud.google.com/sdk/)）。所以，让我们创建一个新的GCP项目，并在你的机器上安装Cloud
    SDK。
- en: Creating a GCP project
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个GCP项目
- en: 'We will create a new project from scratch by following steps. It will help
    you to understand how does GCP project works:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下步骤从零开始创建一个新项目。这将帮助你理解GCP项目是如何工作的：
- en: 'Go to the project page by clicking the My First Project link:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“我的第一个项目”链接，进入项目页面：
- en: '![](img/a34389e9-cb29-4c1b-8f1f-4df4957081e7.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a34389e9-cb29-4c1b-8f1f-4df4957081e7.png)'
- en: Navigating to the project link
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到项目链接
- en: 'You may see your own projects to choose from, but this time click the + button
    to create a new one:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会看到自己的项目供你选择，但这次点击+按钮创建一个新项目：
- en: '![](img/47198482-4866-4daa-9443-182e99c7c608.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47198482-4866-4daa-9443-182e99c7c608.png)'
- en: Creating a new project
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: Type the project name as `Kubernetes Cookbook`. Then GCP will generate and assign
    a project ID such as kubernetes-cookbook-12345\. Please remember this project
    ID.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入项目名称为`Kubernetes Cookbook`。然后，GCP会生成并分配一个项目ID，例如kubernetes-cookbook-12345。请记住这个项目ID。
- en: You may notice that your project ID is NOT kubernetes-cookbook, like kubernetes-cookbook-194302 in
    the screenshot as shown in the following screenshot. And even you click Edit to
    attempt to change it to kubernetes-cookbook, it doesn't allow it, because the
    project ID is a unique string for all GCP users. And we already took the kubernetes-cookbook project
    ID.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，你的项目ID并不是kubernetes-cookbook，就像下面截图中显示的kubernetes-cookbook-194302一样。即使你点击编辑尝试更改为kubernetes-cookbook，也不允许更改，因为项目ID是所有GCP用户唯一的字符串。我们已经使用了kubernetes-cookbook这个项目ID。
- en: '![](img/0fd87e3a-8715-4e46-a992-f368a6bf95e4.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fd87e3a-8715-4e46-a992-f368a6bf95e4.png)'
- en: Project name and Project ID
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 项目名称和项目ID
- en: 'After a few minutes, your project is ready to use. Go back to the project selection
    page on the top banner and then select your Kubernetes Cookbook project:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几分钟后，你的项目就准备好了。返回顶部横幅的项目选择页面，然后选择你的 Kubernetes Cookbook 项目：
- en: '![](img/93685e0e-2de7-4b92-bc57-d8240fcb7af6.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93685e0e-2de7-4b92-bc57-d8240fcb7af6.png)'
- en: Selecting a Kubernetes Cookbook project
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 Kubernetes Cookbook 项目
- en: Done! You can at any time switch to your project and the Kubernetes Cookbook
    project. That is is isolated environment; any VPC, VM, IAM users and even billing
    methods are independent.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！你可以随时切换到你的项目和 Kubernetes Cookbook 项目。这是一个隔离的环境；任何 VPC、VM、IAM 用户，甚至计费方式都是独立的。
- en: Installing Cloud SDK
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Cloud SDK
- en: Next, install Cloud SDK on your machine. It supports the Windows, Mac, and Linux
    platforms. All of these require a Python interpreter version 2.7, but most macOS
    and Linux installs use the defaults.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在你的机器上安装 Cloud SDK。它支持 Windows、Mac 和 Linux 平台。所有这些平台都需要 Python 解释器版本 2.7，但大多数
    macOS 和 Linux 安装使用默认值。
- en: On the other hand, Windows does't have the Python interpreter by default. However,
    in the Cloud SDK installer for Windows, it is possible to install Python. Let's
    install Cloud SDK on Windows and macOS step by step.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Windows 默认没有 Python 解释器。然而，在 Windows 的 Cloud SDK 安装程序中，可以安装 Python。让我们一步步在
    Windows 和 macOS 上安装 Cloud SDK。
- en: Installing Cloud SDK on Windows
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 Cloud SDK
- en: 'Cloud SDK provides an installer for Windows. It also include Python interpreter
    for Windows as well. Please follow the following steps to install on your Windows
    machine:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud SDK 提供了适用于 Windows 的安装程序。它还包括 Windows 上的 Python 解释器。请按照以下步骤在你的 Windows
    机器上安装：
- en: Download the Cloud SDK installer on Windows ([https://dl.google.com/dl/cloudsdk/channels/rapid/GoogleCloudSDKInstaller.exe](https://dl.google.com/dl/cloudsdk/channels/rapid/GoogleCloudSDKInstaller.exe)).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 上下载 Cloud SDK 安装程序（[https://dl.google.com/dl/cloudsdk/channels/rapid/GoogleCloudSDKInstaller.exe](https://dl.google.com/dl/cloudsdk/channels/rapid/GoogleCloudSDKInstaller.exe)）。
- en: Run the Cloud SDK installer.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Cloud SDK 安装程序。
- en: 'If you''ve never installed a Python interpreter on your Windows machine, you
    have to choose the Bundled Python option:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未在 Windows 机器上安装过 Python 解释器，你需要选择 Bundled Python 选项：
- en: '![](img/f28b2426-efed-4bf7-8cd6-5c7dd9758275.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f28b2426-efed-4bf7-8cd6-5c7dd9758275.png)'
- en: Cloud SDK installer for Windows
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 的 Cloud SDK 安装程序
- en: Other than that, proceed with the installation with the default options.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除此之外，继续使用默认选项完成安装。
- en: 'Once the installation is done, you can find Google Cloud SDK Shell in the Google
    Cloud SDK program group. Click it to launch a Google Cloud SDK Shell:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，你可以在 Google Cloud SDK 程序组中找到 Google Cloud SDK Shell。点击它启动 Google Cloud
    SDK Shell：
- en: '![](img/1232e920-4d5f-44d9-91c5-52a00344d03e.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1232e920-4d5f-44d9-91c5-52a00344d03e.png)'
- en: Google Cloud SDK Shell in the Google Cloud SDK program group
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud SDK 程序组中的 Google Cloud SDK Shell
- en: 'Type `gcloud info` to check whether you can see the Cloud SDK version:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `gcloud info` 来检查是否能看到 Cloud SDK 版本：
- en: '![](img/443c01fd-9b87-450e-a00e-1f2351558d22.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/443c01fd-9b87-450e-a00e-1f2351558d22.png)'
- en: Running the gcloud command on Windows
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上运行 gcloud 命令
- en: Installing Cloud SDK on Linux and macOS
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 和 macOS 上安装 Cloud SDK
- en: 'Installing Cloud SDK on both Linux and macOS follows the steps listed here.
    Let''s install Cloud SDK under your home directory:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 和 macOS 上安装 Cloud SDK 遵循此处列出的步骤。让我们在你的主目录下安装 Cloud SDK：
- en: Open the Terminal.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端。
- en: 'Type the following command to download and run the Cloud SDK installer:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以下载并运行 Cloud SDK 安装程序：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It asks for your desired installation directory. By default, it is under your
    home directory. So, type `return`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会询问你希望的安装目录。默认情况下，它会安装在你的主目录下。所以，输入 `return`：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It asks whether to send user usage data; it will send some information when
    it crashes. Based on your privacy policy, if don''t wish to send any data to Google,
    choose `n`. Otherwise choose `Y` to improve their quality:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会询问是否发送用户使用数据；当发生崩溃时，它会发送一些信息。根据你的隐私政策，如果你不希望将任何数据发送给 Google，选择 `n`。否则选择 `Y`
    来改善其质量：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It asks whether to update `.bash_profile` by adding the `gcloud` command to
    your command search path; type `y` to proceed:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会询问是否通过添加 `gcloud` 命令到你的命令搜索路径中来更新 `.bash_profile`；输入 `y` 继续：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open another Terminal or type `exec -l $SHELL` to refresh your command search
    path:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个终端，或者输入 `exec -l $SHELL` 来刷新你的命令搜索路径：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Type `gcloud info` to check whether you can see the Cloud SDK version:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `gcloud info` 来检查是否能看到 Cloud SDK 版本：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now you can start to configure Cloud SDK!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始配置 Cloud SDK 了！
- en: Configuring Cloud SDK
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Cloud SDK
- en: 'You can configure both Cloud SDK for Windows and for Linux/macOS, by using
    the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下步骤配置Windows和Linux/macOS版Cloud SDK：
- en: Launch Google Cloud SDK Shell (Windows) or open a Terminal (Linux/macOS).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Google Cloud SDK Shell（Windows）或打开终端（Linux/macOS）。
- en: 'Type `gcloud init`; it asks you to log on to your Google account. Type `y`
    and press return:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`gcloud init`；它会要求你登录到Google账户。输入`y`并按回车：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It will open a web browser to navigate to the Google logon page; proceed to
    log on using your Google Account with the GCP account.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将打开一个浏览器，导航到Google登录页面；请使用你的Google账户登录GCP账户。
- en: It asks you whether Cloud SDK can access your Google account information. Click
    the ALLOW button.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会询问Cloud SDK是否可以访问你的Google账户信息。点击`ALLOW`按钮。
- en: 'Back to the Terminal—it asks you which project you want to use. Let''s choose
    the Kubernetes Cookbook project you made:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到终端——它会询问你想使用哪个项目。我们选择你创建的Kubernetes Cookbook项目：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It asks you whether to configure `Compute Engine` or not. Let''s type `n` to
    skip it this time:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会询问你是否配置`Compute Engine`。这次我们输入`n`跳过此步骤：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now you can start to use Cloud SDK to control GCP. Let's create VPC, subnet,
    and firewall rules, then launch a VM instance to set up our own GCP infrastructure.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以开始使用Cloud SDK控制GCP了。我们将创建VPC、子网和防火墙规则，然后启动一个VM实例来设置我们的GCP基础设施。
- en: If you chose the wrong project or you want to try again, at any time you can
    reconfigure your setup by the `gcloud init` command.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了错误的项目，或者想重新尝试，随时可以通过`gcloud init`命令重新配置你的设置。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will go through GCP''s basic functionality to set up an infrastructure under
    the Kubernetes Cookbook project. By using the `gcloud` command, we will create
    these components:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过GCP的基本功能来设置Kubernetes Cookbook项目下的基础设施。通过使用`gcloud`命令，我们将创建以下组件：
- en: One new VPC
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的VPC
- en: Two subnets (`us-central1` and `us-east1`) in the VPC
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在VPC中有两个子网（`us-central1`和`us-east1`）
- en: Three firewall rules (`public-ssh`, `public-http`, and `private-ssh`)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个防火墙规则（`public-ssh`，`public-http`，和`private-ssh`）
- en: We will add your ssh public key to a project-wide metadata
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将把你的ssh公钥添加到项目范围的元数据中
- en: 'Overall, your infrastructure will resemble the following. Let''s configure
    the components one by one:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，你的基础设施将类似于以下内容。让我们逐一配置这些组件：
- en: '![](img/e360bc7c-6a8d-4dc1-83db-41c845ded19b.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e360bc7c-6a8d-4dc1-83db-41c845ded19b.png)'
- en: Target infrastructure
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目标基础设施
- en: Creating a VPC
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建VPC
- en: VPC in GCP is like AWS, but there's no need to bind a particular region, and
    also no need to set the CIDR address range. This means you can create a VPC that
    covers all regions. By default, your Kubernetes Cookbook project has a default
    VPC.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: GCP中的VPC与AWS类似，但无需绑定特定区域，也无需设置CIDR地址范围。这意味着你可以创建一个覆盖所有区域的VPC。默认情况下，你的Kubernetes
    Cookbook项目有一个默认的VPC。
- en: 'However, for a better understanding, let''s create a new VPC by following these
    steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了更好地理解，我们将按照以下步骤创建一个新的VPC：
- en: 'Run the `gcloud compute networks` command to create a new VPC. The name is
    `chap7 `and subnet-mode is `custom`, which means subnets are not created automatically.
    So we will add it manually in the next step:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`gcloud compute networks`命令创建一个新的VPC。名称为`chap7`，子网模式为`custom`，这意味着子网不会自动创建。所以下一步我们将手动添加子网：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Check the VPC list; you should have two VPCs, `default` VPC and `chap7` VPC:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查VPC列表；你应该有两个VPC，`default` VPC和`chap7` VPC：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating subnets
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建子网
- en: 'Let''s create two subnets under the `chap7` VPC (network) by following these
    steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下步骤，在`chap7` VPC（网络）下创建两个子网：
- en: 'In order to create a subnet, you have to choose the region. By typing `gcloud
    compute regions list` you will know which regions are available to you:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建一个子网，你必须选择区域。通过输入`gcloud compute regions list`，你可以查看哪些区域对你可用：
- en: '![](img/9a46d42e-477c-436b-9b2c-fbef497e1ab9.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a46d42e-477c-436b-9b2c-fbef497e1ab9.png)'
- en: Displaying a GCP region list
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 显示GCP区域列表
- en: 'Let''s choose `us-central1` and `us-east1` to create two subnets under the `chap7`
    VPC with the following configuration:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择`us-central1`和`us-east1`，在`chap7` VPC下创建两个子网，配置如下：
- en: '| **Subnet name** | **VPC** | **CIDR range** | **Region** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **子网名称** | **VPC** | **CIDR范围** | **区域** |'
- en: '| `chap7-us-central1` | `chap7` | `192.168.1.0/24` | `us-central1` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `chap7-us-central1` | `chap7` | `192.168.1.0/24` | `us-central1` |'
- en: '| `chap7-us-east1` | `chap7` | `192.168.2.0/24` | `us-east1` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `chap7-us-east1` | `chap7` | `192.168.2.0/24` | `us-east1` |'
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Check the following command to see whether subnets are configured properly
    or not:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看以下命令，以检查子网是否配置正确：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating firewall rules
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建防火墙规则
- en: Firewall rules are similar to an AWS Security Group in that you can define incoming
    and outgoing packet filters. They use a network tag, which is a label, to distinguish
    between firewall rules and VM instances. So, VM instances can specify zero or
    some network tags, then the firewall rule will apply to the VM which has the same
    Network Tag.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙规则类似于AWS的安全组，你可以定义入站和出站数据包过滤器。它们使用网络标签，作为标签，用来区分防火墙规则和VM实例。因此，VM实例可以指定零个或多个网络标签，防火墙规则将应用于具有相同网络标签的VM实例。
- en: 'Therefore, we need to set a target network tag while creating the firewall
    rule. Overall, we will create three firewall rules that have these configurations:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要在创建防火墙规则时设置目标网络标签。总体来说，我们将创建三条防火墙规则，具有以下配置：
- en: '| **Firewall rule name** | **Target VPC** | **Allow port** | **Allow from**
    | **Target network tag** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **防火墙规则名称** | **目标VPC** | **允许端口** | **允许来自** | **目标网络标签** |'
- en: '| `public-ssh` | `chap7` | `ssh` (22/tcp) | All (`0.0.0.0/0`) | public |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `public-ssh` | `chap7` | `ssh` (22/tcp) | All (`0.0.0.0/0`) | public |'
- en: '| `public-http` | `chap7` | `http` (80/tcp) | All (`0.0.0.0/0`) | public |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `public-http` | `chap7` | `http` (80/tcp) | All (`0.0.0.0/0`) | public |'
- en: '| `private-ssh` | `chap7` | `ssh` (22/tcp) | Host which has a public network
    tag | private |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `private-ssh` | `chap7` | `ssh` (22/tcp) | Host which has a public network
    tag | private |'
- en: 'Create a `public-ssh` rule:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`public-ssh`规则：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a `public-http` rule:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`public-http`规则：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a `private-ssh` rule:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`private-ssh`规则：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Check all firewall rules:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查所有防火墙规则：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adding your ssh public key to GCP
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将你的SSH公钥添加到GCP
- en: Before you launch VM instances, you need to upload your ssh public key in order
    to log on to the VM. If you don't have any ssh keys, you have to run the `ssh-keygen` command
    to generate a key pair (public key and private key). Let's assume you have a public
    key as `~/.ssh/id_rsa.pub` and a private key as `~/.ssh/id_rsa`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动VM实例之前，你需要上传你的SSH公钥，以便登录到VM。如果你没有任何SSH密钥，你需要运行`ssh-keygen`命令生成一对密钥（公钥和私钥）。假设你有一个公钥`~/.ssh/id_rsa.pub`和一个私钥`~/.ssh/id_rsa`
- en: 'Check your login user name by using the `whoami` command, then use `gcloud
    compute config-ssh` to upload your key via the following command:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`whoami`命令检查你的登录用户名，然后使用`gcloud compute config-ssh`通过以下命令上传你的密钥：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Check your ssh public key is registered as metadata:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查你的SSH公钥是否已作为元数据注册：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That's all. These are minimal configurations in order to launch a VM instance.
    So, let's launch some VM instances on this infrastructure.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。这些是启动VM实例所需的最小配置。那么，让我们在这个基础设施上启动一些VM实例。
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Now you have your own VPC, subnet, and firewall rules. This infrastructure
    will be used by the compute engine (VM instances), Kubernetes Engine, and some
    other GCP products. Let''s deploy two VM instances onto your VPC, as in the following
    diagram, to see how it works:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了自己的VPC、子网和防火墙规则。这些基础设施将被计算引擎（VM实例）、Kubernetes引擎和一些其他GCP产品使用。让我们将两个VM实例部署到你的VPC中，看看它是如何工作的，正如下面的图所示：
- en: '![](img/061df439-c2c1-48b2-9aeb-9645e75b1deb.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/061df439-c2c1-48b2-9aeb-9645e75b1deb.png)'
- en: Final state
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最终状态
- en: Launching VM instances
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动VM实例
- en: 'We will launch two VM instances on both `us-central1` and `us-east1` by using
    the following configuration:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下配置在`us-central1`和`us-east1`上启动两个VM实例：
- en: '| **VM Instance name** | **Target VPC** | **zone (see the following steps)**
    | **Target Subnet** | **Assign Network Tag** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **VM实例名称** | **目标VPC** | **区域（见下文步骤）** | **目标子网** | **分配网络标签** |'
- en: '| `chap7-public` | `chap7` | `us-central1-a` | `chap7-us-central1` | public
    |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `chap7-public` | `chap7` | `us-central1-a` | `chap7-us-central1` | public
    |'
- en: '| `chap7-private` | `chap7` | `us-east1-b` | `chap7-us-east1` | private |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `chap7-private` | `chap7` | `us-east1-b` | `chap7-us-east1` | private |'
- en: 'Check the available zones in `us-central1` and `us-east1` by using the following
    command:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查`us-central1`和`us-east1`中的可用区域：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, let''s choose `us-central1-a` for `chap7-public` and `us-east1-b` for `chap7-private`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们选择`us-central1-a`作为`chap7-public`的区域，`us-east1-b`作为`chap7-private`的区域：
- en: 'Type the following command to create two VM instances:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以创建两个VM实例：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Check the VM instance external IP address via the following command:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令检查VM实例的外部IP地址：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run `ssh-agent` to remember your ssh key:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ssh-agent`以记住你的SSH密钥：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'ssh from your machine to `chap7-public` using the `-A` option (forward authentication)
    and using an external IP address:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-A`选项（转发身份验证）和外部IP地址从你的机器SSH连接到`chap7-public`：
- en: '![](img/01c661b0-0fb2-4541-a527-1d97a51994cd.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01c661b0-0fb2-4541-a527-1d97a51994cd.png)'
- en: ssh to the public VM instance
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: SSH连接到公共VM实例
- en: 'ssh from `chap7-public` to `chap7-private` via the internal IP address:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `chap7-public` 通过内部 IP 地址 ssh 连接到 `chap7-private`：
- en: '![](img/0bdef6f5-f918-4d9f-ab06-2dfdf413ecc4.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0bdef6f5-f918-4d9f-ab06-2dfdf413ecc4.png)'
- en: ssh to private VM instance
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ssh 连接到私有 VM 实例
- en: 'Type the `exit` command to go back to the `chap7-public` host, then install
    `nginx` by using the `apt-get` command:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `exit` 命令返回到 `chap7-public` 主机，然后使用 `apt-get` 命令安装 `nginx`：
- en: '![](img/c932a618-0356-4c6b-aefc-c96873cd71b8.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c932a618-0356-4c6b-aefc-c96873cd71b8.png)'
- en: Installing nginx on a public VM instance
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共 VM 实例上安装 nginx
- en: 'Launch `nginx` by using the following command:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动 `nginx`：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Access `chap7-public` (via the external IP) using your web browser:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Web 浏览器通过外部 IP 访问 `chap7-public`：
- en: '![](img/e140b946-9757-4ec3-96a3-650eddc6f7ab.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e140b946-9757-4ec3-96a3-650eddc6f7ab.png)'
- en: Accessing a nginx web server on a public VM instance
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 访问公共 VM 实例上的 nginx Web 服务器
- en: Congratulations! You have finished setting up a GCP VPC, Subnet, and firewall
    rules, and launch VM instances! These are very basic and common usages of Google
    Compute Engine. You can login and install software in these machines, or even
    build a Kubernetes cluster from scratch. However, GCP also has a managed Kubernetes
    product called Kubernetes Engine. We will explore it in this chapter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了 GCP VPC、子网和防火墙规则的设置，并启动了 VM 实例！这些是 Google Compute Engine 的基本和常见用法。你可以登录并在这些机器上安装软件，甚至从零开始构建
    Kubernetes 集群。然而，GCP 还提供了一种托管的 Kubernetes 产品，叫做 Kubernetes Engine。我们将在本章中探讨它。
- en: Playing with Google Kubernetes Engine
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转 Google Kubernetes Engine
- en: Kubernetes was designed by google and widely used internally at Google for years.
    Google Cloud Platform offers the hosted GKE. With GKE, we don't need to build
    a cluster from scratch. Instead, clusters can be launched and turned down on demand.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是由 Google 设计的，并且在 Google 内部广泛使用多年。Google Cloud Platform 提供了托管的 GKE。使用
    GKE，我们无需从零构建集群，而是可以按需启动和关闭集群。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We can use the Kubernetes Engine dashboard in the GCP console or the gcloud
    CLI to launched and configure a cluster. Using the console is very straightforward
    and intuitive. However, using CLI is a more flexible way to make the operation
    repeatable or to integrate it with your existing pipeline. In this recipe, we'll
    walk through how to use gcloud to launch and set up a Kubernetes cluster, along
    with some importants concept in GCP.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 GCP 控制台中的 Kubernetes Engine 仪表盘或通过 gcloud CLI 启动并配置集群。使用控制台非常直接且直观。然而，使用
    CLI 是一种更灵活的方法，可以使操作可重复执行，或将其与现有管道集成。在本食谱中，我们将介绍如何使用 gcloud 启动并设置 Kubernetes 集群，以及
    GCP 中的一些重要概念。
- en: In GCP, everything is associated with a project. A GCP project is the basic
    unit for using GCP services, billing, and permission control. At first, we'll
    have to create a project from the GCP console [https://console.cloud.google.com](https://console.cloud.google.com).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GCP 中，一切都与项目相关联。GCP 项目是使用 GCP 服务、计费和权限控制的基本单位。一开始，我们需要从 GCP 控制台创建一个项目：[https://console.cloud.google.com](https://console.cloud.google.com)。
- en: 'The project ID is globally unique in GCP. After the project is properly created,
    we''ll see there is a unique project number assigned. In the home dashboard, we''ll
    have a clear view of how many resources we''ve used. We can set permissions, storage,
    network, billing, and other resources from here. Before we can move forward, we''ll
    need to install gcloud. gcloud is  part of Google Cloud SDK. Other than gcloud,
    which can do most common operations in GCP, Google Cloud SDK also includes other
    common GCP tools, such as gsutil (to manage Cloud Storage), bq (a command-line
    tool for BigQuery), and core (Cloud SDK libraries). The tools are available at
    the Google cloud SDK download page: [https://cloud.google.com/sdk/docs/#install_the_latest_cloud_tools_version_cloudsdk_current_version](https://cloud.google.com/sdk/docs/#install_the_latest_cloud_tools_version_cloudsdk_current_version).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 ID 在 GCP 中是全局唯一的。项目创建完成后，我们会看到分配了一个唯一的项目编号。在首页仪表盘中，我们可以清晰地看到已使用的资源数量。我们可以在这里设置权限、存储、网络、计费和其他资源。在继续之前，我们需要安装
    gcloud。gcloud 是 Google Cloud SDK 的一部分。除了 gcloud，它可以执行 GCP 中大多数常见操作，Google Cloud
    SDK 还包括其他常见的 GCP 工具，例如 gsutil（用于管理 Cloud Storage）、bq（BigQuery 的命令行工具）和 core（Cloud
    SDK 库）。这些工具可以在 Google Cloud SDK 下载页面获取：[https://cloud.google.com/sdk/docs/#install_the_latest_cloud_tools_version_cloudsdk_current_version](https://cloud.google.com/sdk/docs/#install_the_latest_cloud_tools_version_cloudsdk_current_version)。
- en: 'After gcloud is installed, run gcloud init to log in to set up your identity
    with gcloud and create a project named** k8s-cookbook-2e**. We can use gcloud
    to manipulate almost all the services in Google Cloud; the major command group
    is:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 gcloud 后，运行 `gcloud init` 进行登录，设置身份并创建一个名为 **k8s-cookbook-2e** 的项目。我们可以使用
    gcloud 来操作 Google Cloud 中几乎所有的服务；主要的命令组是：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The gcloud container command line set is used to manage our containers and
    clusters in Google Kuberentes Engine. For launching a cluster, the most important
    parameters are network settings. Let''s spend some time understanding network
    terminology in GCP here. Just like AWS, GCP has the VPC concept as well. It''s
    a private and safer way to isolate your compute, storage, and cloud resources
    with the public internet. It can be peered across projects, or established as
    a VPN with on-premise datacenters to create a hybrid cloud environment:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: gcloud 容器命令行集用于管理我们在 Google Kubernetes Engine 中的容器和集群。在启动集群时，最重要的参数是网络设置。让我们花一些时间来理解
    GCP 中的网络术语。和 AWS 一样，GCP 也有 VPC 概念。这是一种更私密和安全的方式，用来将计算、存储和云资源与公共互联网隔离。它可以跨项目建立对等连接，或与本地数据中心通过
    VPN 建立连接，创建混合云环境：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Instances on this network will not be reachable until firewall rules are created.
    As an example, you can allow all internal traffic between instances as well as
    SSH, RDP, and ICMP by running:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该网络上的实例在防火墙规则创建之前是无法访问的。举个例子，你可以通过运行以下命令允许所有内部流量在实例之间传递，同时允许 SSH、RDP 和 ICMP：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'By default, the VPC is created in auto mode, which will create a one subnet
    per region. We can observe that via the subcommand `describe`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，VPC 是以自动模式创建的，这将为每个区域创建一个子网。我们可以通过子命令 `describe` 来观察这一点：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In GCP, each subnet is across a zone. A zone is an isolated location in a region,
    which is a similar concept to availability zones in AWS.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GCP 中，每个子网跨越一个区域。区域是区域中的一个隔离位置，类似于 AWS 中的可用区概念。
- en: Alternatively, you could create a network in custom mode by adding the parameter
    `--subnet-mode=custom`, which allows you to define your desired IP range, region,
    and all the routing rules. For more details, please refer to the previous section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过添加参数 `--subnet-mode=custom` 来创建自定义模式的网络，这样可以定义你所需的 IP 范围、区域和所有路由规则。更多细节请参考上一节。
- en: 'Auto mode also helps you set up all default routing rules. A route serves to
    define the destination for certain IP ranges. For example, this route will direct
    the packet to virtual network `10.158.0.0/20`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 自动模式还可以帮助你设置所有默认的路由规则。路由用于定义特定 IP 范围的目的地。例如，此路由将数据包引导到虚拟网络 `10.158.0.0/20`：
- en: '![](img/7fe25562-f068-439c-9e86-1e0873de39b4.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fe25562-f068-439c-9e86-1e0873de39b4.png)'
- en: Default route example
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 默认路由示例
- en: 'There route which is used to direct the packet to the outside world. The next
    hop of this route is the default internet gateway, similar to the igw in AWS.
    In GCP, however, you don''t need to explicitly create an internet gateway:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 路由用于将数据包引导到外部世界。此路由的下一跳是默认的互联网网关，类似于 AWS 中的 igw。然而，在 GCP 中，你不需要显式地创建互联网网关：
- en: '![](img/532e9bd0-5148-40f5-a51d-a02176ae9ee1.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/532e9bd0-5148-40f5-a51d-a02176ae9ee1.png)'
- en: Default route for internet access
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 用于互联网访问的默认路由
- en: Another important concept in a GCP network is firewall rules, used to control
    the ingress and egress for your instance. In GCP, the association between firewall
    rules and VM instances is implemented by network tags.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: GCP 网络中的另一个重要概念是防火墙规则，用于控制实例的入站和出站流量。在 GCP 中，防火墙规则与虚拟机实例之间的关联通过网络标签实现。
- en: A firewall rule can also be assigned to all instances in the network or a group
    of instances with a specific service account (ingress only). The service account
    is the identity of a VM instance in GCP. One or more roles can be assigned to
    a service account, so it can have access to other GCP resources. This is similar
    to AWS instance profiles.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙规则也可以分配给网络中的所有实例或具有特定服务账户的实例组（仅限入站）。服务账户是 GCP 中虚拟机实例的身份。可以为服务账户分配一个或多个角色，以便它能够访问其他
    GCP 资源。这类似于 AWS 中的实例配置文件。
- en: 'One VM instance can have more than one network tags, which implies multiple
    network routes could be applied. This diagram shows how tags work. In the following
    diagram, the first firewall rule is applied to VM1 and VM2, and VM2 has two firewall
    rules associated with it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个虚拟机实例可以拥有多个网络标签，这意味着可以应用多个网络路由。此图显示了标签是如何工作的。在下图中，第一个防火墙规则应用于 VM1 和 VM2，VM2
    与两个防火墙规则相关联：
- en: '![](img/69c75148-13f4-4596-a4d4-dd6b32705650.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69c75148-13f4-4596-a4d4-dd6b32705650.png)'
- en: Illustration of AWS security groups and GCP firewall rules
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: AWS安全组和GCP防火墙规则示意图
- en: In **AWS**, one or more ingress/egress rules are defined in a **Security Group**,
    and one or more Security Groups can be assigned to a **EC2** instance. In **GCP**,
    on the other hand, one or more firewall rules are defined, which are associated
    with one or more tags. One or more tags can be assigned to an instance. By mapping
    network tags, firewall rules can control and limit  access in and out of your
    instances.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在**AWS**中，一个或多个入站/出站规则被定义在**安全组**中，且一个或多个安全组可以分配给一个**EC2**实例。而在**GCP**中，定义一个或多个防火墙规则，这些规则与一个或多个标签相关联。一个或多个标签可以分配给一个实例。通过映射网络标签，防火墙规则可以控制和限制进出实例的访问。
- en: How to do it…
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We''ve learned the basic network concept in GCP. Let''s launch our first GKE
    cluster:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了GCP中的基本网络概念。现在让我们启动我们的第一个GKE集群：
- en: '| **Parameter** | **Description** | **Value in example** |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** | **示例中的值** |'
- en: '| `--cluster-version` | Supported cluster version (Refer to [https://cloud.google.com/kubernetes-engine/release-notes](https://cloud.google.com/kubernetes-engine/release-notes))
    | `1.9.2-gke.1` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `--cluster-version` | 支持的集群版本（请参阅[https://cloud.google.com/kubernetes-engine/release-notes](https://cloud.google.com/kubernetes-engine/release-notes)）
    | `1.9.2-gke.1` |'
- en: '| `--machine-type` | Instance type of nodes (Refer to [https://cloud.google.com/compute/docs/machine-types](https://cloud.google.com/compute/docs/machine-types))
    | `f1-micro` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `--machine-type` | 节点的实例类型（请参阅[https://cloud.google.com/compute/docs/machine-types](https://cloud.google.com/compute/docs/machine-types)）
    | `f1-micro` |'
- en: '| `--num-nodes` | Number of nodes in the cluster | `3` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `--num-nodes` | 集群中的节点数量 | `3` |'
- en: '| `--network` | Target VPC network | `k8s-network` (the one we just created)
    |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `--network` | 目标VPC网络 | `k8s-network`（我们刚刚创建的网络） |'
- en: '| `--zone` | Target zone | `us-central1-a` (you''re free to use any zone) |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `--zone` | 目标区域 | `us-central1-a`（你可以自由选择任何区域） |'
- en: '| `--tags` | Network tags to be attached to the nodes | private |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `--tags` | 要附加到节点的网络标签 | private |'
- en: '| `--service-account &#124; --scopes` | Node identity (Refer to [https://cloud.google.com/sdk/gcloud/reference/container/clusters/create](https://cloud.google.com/sdk/gcloud/reference/container/clusters/create)
    for more scope value) | `storage-rw`,`compute-ro` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `--service-account &#124; --scopes` | 节点身份（有关更多范围值，请参见[https://cloud.google.com/sdk/gcloud/reference/container/clusters/create](https://cloud.google.com/sdk/gcloud/reference/container/clusters/create)）
    | `storage-rw`,`compute-ro` |'
- en: 'By referring preceding parameters, let''s launch a three nodes cluster by `gcloud`
    command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 参考前面的参数，我们通过`gcloud`命令启动一个三节点的集群：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After the cluster is up-and-running, we can start to connect to the cluster
    by configuring `kubectl`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 集群启动并运行后，我们可以通过配置`kubectl`开始连接到集群：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s see if the cluster is healthy:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看集群是否健康：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And we can check the nodes inside the cluster:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查集群中的节点：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also use `kubectl` to check cluster info:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`kubectl`检查集群信息：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works…
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Under the hood, gcloud creates a Kubernetes cluster with three nodes, along
    with a controller manager, scheduler, and etcd cluster with two members. We can
    also see that the master is launched with some services, including a default backend
    used by the controller, heapster (used for monitoring) KubeDNS for DNS services
    in the cluster, a dashboard for Kubernetes UI, and metrics-server for resource
    usage metrics.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，gcloud创建了一个包含三个节点的Kubernetes集群，以及一个控制器管理器、调度器和两个成员的etcd集群。我们还可以看到主节点启动了一些服务，包括控制器使用的默认后端、用于监控的heapster、集群中的KubeDNS用于DNS服务、用于Kubernetes
    UI的仪表盘，以及用于资源使用度量的metrics-server。
- en: 'We saw `Kubernetes-dashboard` has a URL; let''s try and access it:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`Kubernetes-dashboard`有一个URL；让我们尝试访问它：
- en: '![](img/4e58c86e-2d4e-4495-a79f-3bdc37c3da1b.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e58c86e-2d4e-4495-a79f-3bdc37c3da1b.png)'
- en: Forbidden to access Kubernetes dashboard
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 禁止访问Kubernetes仪表盘
- en: 'We got `HTTP 403 Forbidden`. Where do we get the access and credentials though?
    One way to do it is running a proxy via the `kubectl proxy` command. It will bind
    the master IP to local `127.0.0.1:8001`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了`HTTP 403 Forbidden`。那么我们从哪里获得访问权限和凭证呢？一种方法是通过`kubectl proxy`命令运行代理。它会将主节点IP绑定到本地`127.0.0.1:8001`：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After that, when we access `http://127.0.0.1:8001/ui`, it'll be redirected to
    `http://127.0.0.1:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当我们访问`http://127.0.0.1:8001/ui`时，它将被重定向到`http://127.0.0.1:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy`。
- en: 'Since Kubernetes 1.7, the dashboard has supported user authentication based
    on a bearer token or `Kubeconfig` file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 自Kubernetes 1.7起，仪表盘支持基于持有令牌或`Kubeconfig`文件的用户认证：
- en: '![](img/fd85ef71-b10b-40b8-af0e-31ba8d287dee.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd85ef71-b10b-40b8-af0e-31ba8d287dee.png)'
- en: Logging in to the Kubernetes dashboard
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到 Kubernetes 控制台
- en: 'You could create a user and bind it to the current context (please refer to
    the *Authentication and authorization* recipe in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*). Just for convenience, we can check if we have
    any existing users. Firstly, we need to know our current context name. Context
    combines of cluster information, users for authentication, and a namespace:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个用户并将其绑定到当前的上下文（请参考[第 8 章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)中的
    *身份验证与授权* 配方，*高级集群管理*）。为了方便起见，我们可以检查是否已有现有用户。首先，我们需要知道当前上下文的名称。上下文结合了集群信息、用于身份验证的用户和命名空间：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After we know the context name, we can describe it via the `kubectl` config
    view `$CONTEXT_NAME`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 知道了上下文名称后，我们可以通过 `kubectl` 配置视图 `$CONTEXT_NAME` 来描述它：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We may find there is a default user existing in our cluster; using its `$ACCESS_TOKEN`,
    you can glimpse the Kubernetes console.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会发现集群中存在一个默认用户；使用其`$ACCESS_TOKEN`，你可以查看 Kubernetes 控制台。
- en: '![](img/6825b49d-6934-41d2-83a8-cb3a098d2675.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6825b49d-6934-41d2-83a8-cb3a098d2675.png)'
- en: Kubernetes dashboard overview
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 控制台概览
- en: 'Our cluster in GKE is up-and-running! Let''s try and see if we can run a simple
    deployment on it:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 GKE 集群已经启动并运行！让我们尝试看看能否在其上运行一个简单的部署：
- en: '[PRE36]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s check our Kubernetes dashboard:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下 Kubernetes 控制台：
- en: '![](img/8a069c1f-b7cb-4441-8f32-90576dcdab69.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a069c1f-b7cb-4441-8f32-90576dcdab69.png)'
- en: Workloads in Kubernetes dashboard
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 控制台中的工作负载
- en: Hurray! The deployment is created and as a result two pods are scheduled and
    created.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 耶！部署已创建，结果有两个 Pod 被调度并创建。
- en: See also
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: '*Advanced settings in kubeconfig* in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 8 章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)中的 *kubeconfig 中的高级设置*，*高级集群管理*'
- en: '*Setting resources in nodes* in Chapter 8, *Advanced Cluster Administration*'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 8 章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)中的 *在节点中设置资源*，*高级集群管理*'
- en: '*Playing with the Web UI* in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 8 章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)中的 *玩转 Web UI*，*高级集群管理*'
- en: '*Setting up a DNS server in Kubernetes Cluster* in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 8 章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)中的 *在 Kubernetes 集群中设置 DNS
    服务器*，*高级集群管理*'
- en: '*Authentication and authorization* in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 8 章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)中的 *身份验证与授权*，*高级集群管理*'
- en: Exploring CloudProvider on GKE
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 GKE 上探索 CloudProvider
- en: GKE works as a native Kubernetes Cloud Provider, which integrates with resources
    in Kubernetes seamlessly and allows you to provision on demand, for example, VPC
    routes for the network, **Persistent Disk** (**PD**) for StorageClass, L4 load
    balancer for Service, and L4 load balancer for ingress.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: GKE 作为本地 Kubernetes 云提供商，与 Kubernetes 中的资源无缝集成，允许按需提供资源，例如网络的 VPC 路由、StorageClass
    的 **持久磁盘**（**PD**）、服务的 L4 负载均衡器以及入口的 L4 负载均衡器。
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: By default, when you create the network and launch a Kubernetes cluster in Google
    Cloud Platform with proper routes, containers can already talk to each other without
    an explicit network being set up.Beyond the resources listed previously, we don't
    need to set any settings explicitly in most cases. GKE will just work.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你在 Google Cloud Platform 中创建网络并启动 Kubernetes 集群并配置适当的路由时，容器之间就可以无需显式设置网络而相互通信。除了之前列出的资源外，在大多数情况下我们不需要显式设置任何配置。GKE
    将自动工作。
- en: How to do it…
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做……
- en: Let's see how convenient GKE offers about storage, network and more.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 GKE 在存储、网络等方面提供了多少便利。
- en: StorageClass
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StorageClass
- en: In [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking through
    Kubernetes Concepts*, we learned how to declare `PersistentVolume` and `PersistentVolumeClaim`.
    With dynamic provisioning, you can define a set of `StorageClass` with different
    physical storage backends and use them in `PersistentVolume` or `PersistentVolumeClaim`.
    Let's see how it works.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中，*Kubernetes 概念简介*，我们学习了如何声明
    `PersistentVolume` 和 `PersistentVolumeClaim`。通过动态供给，你可以定义一组不同物理存储后端的 `StorageClass`，并在
    `PersistentVolume` 或 `PersistentVolumeClaim` 中使用它们。让我们看看它是如何工作的。
- en: 'To check the current default `StorageClass`, use `kubectl get storageclasses`
    command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查当前的默认 `StorageClass`，可以使用 `kubectl get storageclasses` 命令：
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can see we have a default storage class named standard and its provisioner
    is GCE PD.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有一个名为 standard 的默认存储类，其提供者是 GCE PD。
- en: 'Let''s create a `PersistentVolumeClaim` request and use the standard `StorageClass`
    as the backend:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 `PersistentVolumeClaim` 请求，并使用标准的 `StorageClass` 作为后端：
- en: '[PRE38]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`storageClassName` is the place to put the name of the `StorageClass`. If you
    put in something that doesn''t exist, PVC will not be created, since there is
    no proper mapped `StorageClass` to use:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`storageClassName` 是指定 `StorageClass` 名称的地方。如果填写一个不存在的名称，PVC 将无法创建，因为没有适当的映射
    `StorageClass` 可以使用：'
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can see volume `pvc-1491b08e-1cfc-11e8-8589-42010a800360` has been created
    and bounded. If we list GCP disks, we''ll find there was a Persistent Disk created;
    the suffix of the disk name indicates the volume name in Kubernetes. That''s the
    magic of dynamic volume provisioning:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到卷 `pvc-1491b08e-1cfc-11e8-8589-42010a800360` 已经创建并绑定。如果列出 GCP 磁盘，我们会发现创建了一个持久磁盘；磁盘名称的后缀表示
    Kubernetes 中的卷名称。这就是动态卷提供的魔力：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Besides the default `StorageClass`, you can also create your own. Recap this
    in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking through Kubernetes
    Concepts*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认的 `StorageClass`，你还可以创建自己的存储类。回顾一下[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)，*Kubernetes
    概念详解*。
- en: Service (LoadBalancer)
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务（LoadBalancer）
- en: 'A `LoadBalancer` service type only works in the cloud environment that supports
    external load balancers. This allows outside traffic to be routed into target
    Pods. In GCP, a TCP load balancer will be created by a `LoadBalancer` service
    type:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadBalancer` 类型的服务只在支持外部负载均衡器的云环境中工作。这允许外部流量路由到目标 Pod。在 GCP 中，`LoadBalancer`
    类型的服务将创建一个 TCP 负载均衡器：'
- en: 'The firewall rules for allowing traffic between the load balancer and nodes
    will be created automatically:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于允许负载均衡器与节点之间流量的防火墙规则将自动创建：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s check the service. The `EXTERNAL-IP` will show `<pending>` if the load
    balancer is still provisioning. Wait a while and the load balancer IP will present
    itself eventually:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查服务。如果负载均衡器仍在配置中，`EXTERNAL-IP` 将显示 `<pending>`。稍等片刻，负载均衡器的 IP 会最终显示出来：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s curl `$EXTERNAL-IP:80`, to see if it works properly:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用 `curl` 测试 `$EXTERNAL-IP:80`，看看它是否正常工作：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we check the forwarding rules in GCP, we can find a rule that defines how
    the traffic goes from external IP to the target pool:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们检查 GCP 中的转发规则，我们可以找到一条规则，定义了流量如何从外部 IP 转发到目标池：
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'A target pool is a set of instances that receive the traffic from forwarding
    rules. We could inspect the target pool by using the gcloud command as well:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标池是一组实例，这些实例接收来自转发规则的流量。我们也可以使用 gcloud 命令检查目标池：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We can see there are three nodes inside the pool. Those are the same three nodes
    in our Kubernetes cluster. Load balancer will dispatch the traffic to a node based
    on a hash of the source/definition IP and port. A service with `LoadBalancer`
    type looks handy; however, it can't do path-based routing. It's time for ingress
    to come into play. Ingress supports virtual hosts, path-based routing, and TLS
    termination, which is a more flexible approach to your web services.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到目标池内有三个节点。这些节点与我们 Kubernetes 集群中的三个节点相同。负载均衡器将根据源/定义的 IP 和端口的哈希值将流量分发到某个节点。虽然
    `LoadBalancer` 类型的服务看起来很方便，但它无法执行基于路径的路由。此时，Ingress 就派上用场了。Ingress 支持虚拟主机、基于路径的路由和
    TLS 终止，这是对 Web 服务更灵活的处理方式。
- en: Ingress
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ingress（入口）
- en: In [Chapter 5](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml), *Building Continuous
    Delivery Pipelines*, we learned about the concept of ingress , and when and how
    to use it. Ingress  defines a set of rules allowing the inbound connection to
    access Kubernetes cluster services. It routes the traffic into cluster at L7,
    and the controller brings the traffic to the nodes. When GCP is the cloud provider,
    a L7 load balancer will be created if an ingress is created, as well as related
    firewall rules, health checks, backend services, forwarding rules, and a URL map.
    A URL map in GCP is a mechanism that contains a set of rules and forwards requests
    to the corresponding backend services.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml)，*构建持续交付管道*，我们学习了入口（Ingress）的概念，以及何时和如何使用它。Ingress
    定义了一组规则，允许入站连接访问 Kubernetes 集群服务。它在 L7 层路由流量到集群，控制器将流量带到节点。当 GCP 是云服务提供商时，如果创建了
    Ingress，还会创建 L7 负载均衡器，以及相关的防火墙规则、健康检查、后端服务、转发规则和 URL 映射。GCP 中的 URL 映射是一个包含一组规则的机制，将请求转发到相应的后端服务。
- en: 'In this recipe, we''ll reuse the examples from [Chapter 5](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml),
    *Building Continuous Delivery Pipelines*, `Nodeport-deployment.yaml` and `echoserver.yaml`.
    Next is an illustration of how these two services work from [Chapter 5](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml),
    *Building Continuous Delivery Pipelines*:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将重用来自 [第 5 章](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml)的示例，*构建持续交付流水线*，`Nodeport-deployment.yaml`
    和 `echoserver.yaml`。接下来是这两个服务在 [第 5 章](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml)，*构建持续交付流水线*
    中的工作原理图示：
- en: '![](img/9396e211-b955-4cd9-bb43-1154a5cc13ae.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9396e211-b955-4cd9-bb43-1154a5cc13ae.jpg)'
- en: Ingress illustration
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Ingress 图示
- en: We will create an ingress for nginx and echoserver, that routes to different
    services. When the traffic comes in, the pod ingress controller will decide with
    service to route to.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 nginx 和 echoserver 创建一个 ingress，路由到不同的服务。当流量到达时，pod ingress 控制器将决定路由到哪个服务。
- en: 'Here is an example for ingress . Please note that you might want to add the
    host name inside the rules section if you want the underlying services to always
    be visited from a certain host name:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 ingress 的示例。请注意，如果你希望底层服务始终从某个特定主机名访问，你可能需要在规则部分添加主机名：
- en: '[PRE46]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Please double-check that the underlying service is configured as a `NodePort`
    type. Otherwise you might encounter errors such as `googleapi: Error 400: Invalid
    value for field ''namedPorts[1].port'': ''0''. Must be greater than or equal to
    1, invalid error `from `loadbalancer-controller`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '请再次确认底层服务已配置为 `NodePort` 类型。否则，你可能会遇到如 `googleapi: Error 400: Invalid value
    for field ''namedPorts[1].port'': ''0''. Must be greater than or equal to 1, invalid
    error` 来自 `loadbalancer-controller` 的错误。'
- en: 'After a few minutes, the L7 load balancer will be created and you''ll be able
    to see it from the GCP console or by using the gcloud command. Let''s use `kubectl`
    to check if the backend service in INGRESS is healthy:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，L7 负载均衡器将被创建，你可以通过 GCP 控制台或使用 gcloud 命令查看它。让我们使用 `kubectl` 检查 INGRESS 中的后端服务是否健康：
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can see the three backends are healthy and the related forwarding rules,
    target proxy, and URL map have been all created. We can get a comprehensive view
    from the GCP console by visiting discovery and load balancing in GKE or the Load
    balancing tab in network services:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到三个后端是健康的，相关的转发规则、目标代理和 URL 映射都已创建。我们可以通过访问 GKE 中的发现和负载均衡，或通过网络服务中的负载均衡选项卡，从
    GCP 控制台获取全面的视图：
- en: '![](img/c1509f93-dc69-4e09-b6c6-0c80c63776cc.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1509f93-dc69-4e09-b6c6-0c80c63776cc.png)'
- en: Discovery and Load balancing
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 发现与负载均衡
- en: 'The backend is illustrated here:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 后端在这里进行说明：
- en: '![](img/69386610-e730-4510-94ff-cda84aa27e43.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69386610-e730-4510-94ff-cda84aa27e43.png)'
- en: Backend services
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 后端服务
- en: 'From time to time, your ingress resource might encounter updates. When you
    redeploy it, there is no guarantee that GCP will allocate the same IP address
    to your load balancer. This might introduce a problem when the IP address is associated
    with a DNS name. The target IP address will need to be updated every time the
    IP is changed. This could be resolved by a static external IP address plus `kubernetes.io/INGRESS.global-static-ip-name`
    annotation:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你的 ingress 资源可能会遇到更新。当你重新部署时，无法保证 GCP 会为你的负载均衡器分配相同的 IP 地址。这可能会在 IP 地址与 DNS
    名称关联时引发问题。每次 IP 地址更改时，都需要更新目标 IP 地址。可以通过静态外部 IP 地址加上 `kubernetes.io/INGRESS.global-static-ip-name`
    注解来解决这个问题：
- en: '[PRE48]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s describe `my-INGRESS` and see if it binds properly with the external
    IP we created :'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述 `my-INGRESS`，看看它是否与我们创建的外部 IP 正确绑定：
- en: '[PRE49]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We're all set. `Nginx` and `echoserver` can be visited via the external static
    IP `130.211.37.61`, and we're able to associate a DNS name with it by using the
    cloud DNS service in GCP.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了。`Nginx` 和 `echoserver` 可以通过外部静态 IP `130.211.37.61` 进行访问，我们可以通过 GCP
    的云 DNS 服务将其与 DNS 名称关联。
- en: There's more…
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: In Kubernetes v.1.9, the Kubernetes cloud controller manager was promoted to
    alpha. Cloud controller manager aims to make the cloud provider release feature
    support via its own release cycles, which could be independent from the Kubernetes
    release cycle. Then it could be independent with Kubernetes core release cycle.
    It provides common interfaces that each cloud provider can implement, which decoupling
    with Kubernetes Core logic. In the near future, we'll see more comprehensive support
    from different cloud providers!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes v.1.9中，Kubernetes云控制器管理器被提升为Alpha版本。云控制器管理器旨在通过其自身的发布周期，使云提供商发布功能支持，这些支持可以独立于Kubernetes发布周期。随后，它也可以与Kubernetes核心发布周期独立。它提供了每个云提供商可以实现的公共接口，从而与Kubernetes核心逻辑解耦。未来，我们将看到来自不同云提供商的更全面支持！
- en: See also
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: '*Working with services* in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中的*与服务协作*，*深入理解Kubernetes概念*'
- en: '*Working with volumes* in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中的*与卷协作*，*深入理解Kubernetes概念*'
- en: '*Forwarding container ports* in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)中的*转发容器端口*，*玩转容器*'
- en: Managing Kubernetes clusters on GKE
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GKE上管理Kubernetes集群
- en: Google Kubernetes Engines offers us the seamless experience of running Kubernetes;
    it also makes Kubernetes administration so easy. Depending on the expected peak
    time, we might want to scale the Kubernetes nodes out or in. Alternatively, we
    could use Autoscaler to do auto-scaling for the nodes. Kubernetes is an evolving
    platform. The release pace is fast. We might want to upgrade the cluster version
    from time to time, which is very easy to do. We could also use the Autoupgrade
    feature to upgrade the cluster by enabling automatically schedule feature in GKE.
    Let's see how to do it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Google Kubernetes Engine为我们提供了运行Kubernetes的无缝体验；它还使Kubernetes管理变得非常简单。根据预期的高峰时段，我们可能需要扩展或缩减Kubernetes节点。或者，我们可以使用Autoscaler为节点进行自动扩展。Kubernetes是一个不断发展的平台，发布速度很快。我们可能需要时不时地升级集群版本，这非常简单。我们还可以使用Autoupgrade功能，通过启用GKE中的自动调度功能来升级集群。让我们看看如何操作。
- en: Getting ready
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before setting up the administration features that GCP offers, we'll have to
    have a cluster up and running. We'll reuse the cluster we created in the Playing
    with the Google Kubernetes Engine recipe in this chapter.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置GCP提供的管理功能之前，我们必须先启动并运行集群。我们将重用本章中在《玩转Google Kubernetes Engine》一节中创建的集群。
- en: How to do it…
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In this recipe, we'll introduce how to manage the number of nodes based on usage
    and requirements. Also, we'll learn how to deal with cluster upgrades. Finally,
    we'll see how to provision a multi-zone cluster in GKE, in order to prevent a
    physical zone outage.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将介绍如何根据使用情况和需求管理节点数。同时，我们将学习如何处理集群升级。最后，我们将了解如何在GKE中配置一个多区集群，以防止物理区域故障。
- en: Node pool
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点池
- en: 'A node pool is a set of instances in GCP that share the same configuration.
    When we launch a cluster from the `gcloud` command, we pass `--num-node=3` and
    the rest of the arguments. Then three instances will be launched inside the same
    pool, sharing the same configuration, using the same method:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 节点池是GCP中一组共享相同配置的实例。当我们通过`gcloud`命令启动集群时，我们传递`--num-node=3`及其余参数。然后，三台实例将在同一池中启动，分享相同配置，使用相同的方法：
- en: '[PRE50]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Assume there is an expected heavy peak time for your service. As a Kubernetes
    administrator, you might want to resize your node pool inside the cluster.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的服务有一个预期的高峰时段。作为Kubernetes管理员，你可能希望调整集群中节点池的规模。
- en: '[PRE51]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The resize command can help you scale out and in. If the node count after resizing
    is less than before, the scheduler will migrate the pods to run on available nodes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: resize命令可以帮助你扩展和缩减。如果调整大小后节点数量少于调整前，调度程序将把Pod迁移到可用节点上运行。
- en: 'You can set the compute resource boundary for each container in the spec. You
    set requests and limits to a pod container. Assume we have a super nginx which
    requires 1024 MB memory:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在规格中为每个容器设置计算资源的边界。你为 Pod 容器设置请求和限制。假设我们有一个超级 nginx，它需要1024 MB内存：
- en: '[PRE52]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The node size we created is `f1-miro`, which only has 0.6 GM memory per node.
    It means the scheduler will never find a node with sufficient memory to run `super-nginx`.
    In this case, we can add more nodes with higher memory to the cluster by creating
    another node pool. We''ll use `g1-small` as an example, which contains 1.7 GB
    memory:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的节点大小是 `f1-micro`，每个节点只有 0.6 GB 内存。这意味着调度器永远找不到具有足够内存来运行 `super-nginx` 的节点。在这种情况下，我们可以通过创建另一个节点池，向集群中添加更多内存更大的节点。我们以
    `g1-small` 为例，它包含 1.7 GB 内存：
- en: '[PRE53]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Looks like we have two more powerful nodes. Let''s see the status of our super
    nginx:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们有了两个更强大的节点。让我们看看我们的超级 nginx 状态：
- en: '[PRE54]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It''s running! Kubernetes scheduler will always try to find sufficient resources
    to schedule pods. In this case, there are two new nodes added to the cluster that
    can fulfill the resource requirement, so the pod is scheduled and run:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 运行了！Kubernetes 调度器将始终尝试找到足够的资源来调度 Pod。在这种情况下，集群中添加了两个新节点，可以满足资源需求，因此 Pod 被调度并运行：
- en: '[PRE55]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: From the events of the pod, we know what path it ran through. Originally, it
    couldn't find any nodes with sufficient resources and eventually it's scheduled
    to the new node named `gke-my-k8s-cluster-larger-mem-pool-a51c8da3-scw1`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Pod 的事件中，我们可以知道它的运行路径。最初，它无法找到任何具有足够资源的节点，最终被调度到一个名为 `gke-my-k8s-cluster-larger-mem-pool-a51c8da3-scw1`
    的新节点上。
- en: 'For making the user preference on scheduling pods on certain nodes, `nodeSelector`
    was introduced. You could either use built-in node labels, such as `beta.kubernetes.io/instance-type:
    n1-standard-1` in pod spec, or use customized labels to achieve it. For more information,
    please refer to [https://kubernetes.io/docs/concepts/configuration/assign-pod-node](https://kubernetes.io/docs/concepts/configuration/assign-pod-node).'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '为了让用户在调度 Pod 到特定节点时具有偏好，`nodeSelector` 被引入。你可以在 Pod 规范中使用内置节点标签，比如 `beta.kubernetes.io/instance-type:
    n1-standard-1`，或者使用自定义标签来实现。更多信息请参阅 [https://kubernetes.io/docs/concepts/configuration/assign-pod-node](https://kubernetes.io/docs/concepts/configuration/assign-pod-node)。'
- en: 'Kubernetes also supports **cluster autoscaler**, which automatically resizes
    your cluster based on capacity if all nodes have insufficient resources to run
    the requested pods. To do that, we add `–enable-autoscaling` and specify the maximum
    and minimum node count when we create the new node pool:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 还支持**集群自动扩展器**，它可以根据容量自动调整集群大小，如果所有节点的资源不足以运行请求的 Pod。为了实现这一点，我们在创建新节点池时添加
    `–enable-autoscaling`，并指定最大和最小节点数：
- en: '[PRE56]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After a few minutes, we can see there is a new node inside our cluster:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，我们可以看到集群中有了一个新节点：
- en: '[PRE57]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, let''s change the replica of our super-nginx from 1 to 4 by using `kubectl`
    edit or creating a new deployment:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过 `kubectl` 编辑或创建新部署，将我们的超级 nginx 的副本从 1 改为 4：
- en: '[PRE58]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We find there are two pods with a pending status:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现有两个 Pod 状态为待定：
- en: '[PRE59]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After a few minutes, we see that there are new members in our larger mem pool,
    and all our pods get to run:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，我们看到在更大的内存池中有了新成员，所有的 Pod 都开始运行：
- en: '[PRE60]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Cluster autoscaler comes in handy and is cost-effective. When the nodes are
    over-provisioned, the additional node in the node pool will be terminated automatically.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 集群自动扩展器非常有用且具有成本效益。当节点过度配置时，节点池中的额外节点将被自动终止。
- en: Multi-zone and regional clusters
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多区域和区域性集群
- en: Our `my-k8s-cluster` is currently deployed in the `us-central1-a` zone. While
    a zone is a physically isolated location in a region, it may suffer an outage.
    Google Kubernetes Engine supports multi-zone and regional deployment. Multi-zone
    clusters create a single master in a zone and provision nodes in multiple zones;
    on the other hand, a regional cluster creates multiple masters across three zones
    and provisions nodes in multiple zones.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `my-k8s-cluster` 当前部署在 `us-central1-a` 区域。虽然区域是一个物理隔离的位置，但它可能会发生故障。Google
    Kubernetes Engine 支持多区域和区域性部署。多区域集群在一个区域创建一个主节点，并在多个区域配置节点；而区域性集群则在三个区域创建多个主节点，并在多个区域配置节点。
- en: Multi-zone clusters
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多区域集群
- en: To enable multi-zone cluster, add -`-additional-zones $zone2, $zone3, …` into
    the command when you create the cluster.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用多区域集群，在创建集群时在命令中添加 `--additional-zones $zone2, $zone3, …`。
- en: Just like AWS, GCP has service quota limits as well. You could use `gcloud compute
    project-info describe –project $PROJECT_NAME` to check the quota and request an
    increase from the GCP console if needed.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 AWS 一样，GCP 也有服务配额限制。你可以使用 `gcloud compute project-info describe –project
    $PROJECT_NAME` 来检查配额，并在需要时通过 GCP 控制台请求增加配额。
- en: 'Let''s launch a two-nodes cluster per zone first:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 先让我们每个区域启动一个两节点的集群：
- en: '[PRE61]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We find we have six nodes now:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现现在有六个节点：
- en: '[PRE62]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s check if the nodes are spread across the three zones we specified:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查节点是否分布在我们指定的三个区域：
- en: '[PRE63]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Regional clusters
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区域集群
- en: 'Regional clusters are still in the beta phase. To use these, we''ll have to
    enable the gcloud beta command. We can enable it via this command:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 区域集群仍处于 Beta 阶段。要使用这些功能，我们必须启用 gcloud beta 命令。可以通过以下命令启用：
- en: '[PRE64]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then we should be able to use the `gcloud v1beta` command to launch the regional
    cluster:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们应该能够使用`gcloud v1beta`命令来启动区域集群：
- en: '[PRE65]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The command is quite similar to the one that creates a cluster, just with two
    differences: a beta flag is added before the group name container which indicates
    it''s a `v1beta` command. The second difference is changing `--zone` to `--region`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令与创建集群的命令非常相似，只是有两个不同之处：在组名容器之前添加了一个 beta 标志，表示这是一个`v1beta`命令。第二个不同之处是将`--zone`更改为`--region`：
- en: '[PRE66]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Cluster upgrades
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群升级
- en: 'Kubernetes is a fast-release project. GKE also keeps supporting new versions.
    It''s not uncommon to have multiple minor version updates within a month. check
    the GKE console:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个快速发布的项目。GKE 也在不断支持新版本。每个月出现多个小版本更新并不罕见。请查看 GKE 控制台：
- en: '![](img/7474190c-b187-407f-aac8-f92c7e3c9ec3.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7474190c-b187-407f-aac8-f92c7e3c9ec3.png)'
- en: Upgrade available information in the GCP console
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GCP 控制台中查看升级信息
- en: 'We see that an upgrade is available. 1.9.3-gke.1 in the screenshot has just
    been released and our cluster is able to upgrade:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到升级已可用。截图中的 1.9.3-gke.1 刚刚发布，我们的集群可以进行升级：
- en: '![](img/bd70a627-254a-4882-b45a-7f1c15f9b782.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd70a627-254a-4882-b45a-7f1c15f9b782.png)'
- en: Upgrade available to 1.9.3-gke.0
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 升级可用至 1.9.3-gke.0
- en: We can upgrade the cluster via the GKE console, or using gcloud command. We'll
    use the single zone (`us-central1-a`) cluster to demonstrate how to upgrade in
    the next example. When upgrading the cluster, the master is always the first citizen
    to do the upgrade. The desired node version cannot be greater than the current
    master version.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 GKE 控制台或使用 gcloud 命令来升级集群。在下一个示例中，我们将使用单区（`us-central1-a`）集群来演示如何升级。升级集群时，主节点始终是第一个进行升级的节点。所需的节点版本不能高于当前主节点的版本。
- en: '[PRE67]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s check the master''s version:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查主节点的版本：
- en: '[PRE68]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Looks good. The master has been upgraded to `v1.9.3-gke.0`, but our nodes didn''t
    get upgrade yet:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。主节点已升级到`v1.9.3-gke.0`，但我们的节点还没有升级：
- en: '[PRE69]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'For the node upgrade, instead of upgrading them all at once, GKE performs rolling
    upgrade. It will first drain and deregister a node from the node pool, delete
    an old instance, and provision a new instance with the desired version, then add
    it back to the cluster:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于节点升级，GKE 不是一次性地升级所有节点，而是执行滚动升级。它首先会将一个节点从节点池中排空并注销，删除旧实例，并以所需的版本提供新实例，然后将其添加回集群：
- en: '[PRE70]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The node pool can be configured to auto-upgrade via the `--enable-autoupgrade`
    flag during cluster creation, or using the gcloud container `node-pools` update
    command to update existing node pools. For more information, please refer to [https://cloud.google.com/kubernetes-engine/docs/concepts/node-auto-upgrades](https://cloud.google.com/kubernetes-engine/docs/concepts/node-auto-upgrades).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 节点池可以通过在集群创建时使用`--enable-autoupgrade`标志来配置为自动升级，或者使用 gcloud 容器的`node-pools`更新命令来更新现有节点池。有关更多信息，请参阅[https://cloud.google.com/kubernetes-engine/docs/concepts/node-auto-upgrades](https://cloud.google.com/kubernetes-engine/docs/concepts/node-auto-upgrades)。
- en: It will take more than 10 minutes. After that, all the nodes in the cluster
    are upgraded to `1.9.3-gke.0`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要超过 10 分钟。之后，集群中的所有节点将升级到`1.9.3-gke.0`。
- en: See also
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: '*Advanced settings in kubeconfig* in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)的*在 kubeconfig 中的高级设置*，*高级集群管理*
- en: '*Setting resources in nodes* in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)的*设置节点资源*中，*高级集群管理*
