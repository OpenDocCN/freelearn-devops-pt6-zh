- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining and Managing Business APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Application programming interfaces** (**APIs**) are as old as digital computing
    itself but more relevant than ever as we continue to interconnect every aspect
    of modern life. They make up the backbone of most enterprise applications and
    help run the modern world. It is this very proliferation of APIs that makes them
    a big source of waste, redundancy, and bad practice in enterprises.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces two products aimed squarely at this problem space:
    **Spring Cloud Gateway for Kubernetes** and **API Portal for VMware Tanzu**. As
    is the case with every product in the Tanzu portfolio, these products address
    a specific acute business need: in this case, developing, operating, publishing,
    securing, monitoring, documenting, searching for, and consuming APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Gateway for Kubernetes and API Portal for VMware Tanzu – overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Spring Cloud Gateway for Kubernetes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why API Portal for VMware Tanzu?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud Gateway for Kubernetes – getting started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Portal for VMware Tanzu – getting started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud Gateway for Kubernetes and API Portal for VMware Tanzu – real-world
    use case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud Gateway for Kubernetes and API Portal for VMware Tanzu – day-2
    operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud Gateway for Kubernetes and API Portal for VMware Tanzu – overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before jumping into the product installation, let’s revisit why we’re here.
    I like to think of the API space in terms of three personas. There’s the **API
    Developer**, the **API Consumer**, and the **API Operator**. Each has its own
    set of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I develop APIs, there are some recurring problems that I must solve with
    every single project:'
  prefs: []
  type: TYPE_NORMAL
- en: Exposing my API to my customers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminating *TLS*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling *CORS* and browser restrictions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making my API discoverable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing my API endpoints so that only certain groups can execute certain functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting against misuse by rate-limiting requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewriting request paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewriting request and response headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API terminology
  prefs: []
  type: TYPE_NORMAL
- en: '**Transport Layer Security** (**TLS**) is the cryptographic technology behind
    the reassuring lock next to your bank’s website’s URL in your web browser. It
    is especially important in the realm of APIs as most of the sensitive financial
    data, personal messages, and sensitive health information are delivered via an
    API. It’s especially difficult to implement correctly, and something best handled
    centrally by an API gateway rather than having each API developer implement it
    themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-Origin Resource Sharing** (**CORS**) is an especially important topic
    for engineers in the API space. CORS is the mechanism by which your browser allows
    one website to make calls in the background (often called AJAX calls) to another
    website. There are legitimate reasons to do this, but this technique is often
    used by bad actors to try to steal credentials or sensitive information. Configuring
    a website and its supporting APIs such that only trusted AJAX calls are allowed
    is complex and easy to get wrong. This is one more reason why it’s best to centralize
    this logic in an API gateway.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s say that I need to consume APIs. I have an entirely different set
    of problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Does the API I need exist?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where can I find the APIs I need?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do I access those APIs once I’ve found them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do those APIs require authentication? If so, what scopes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do I test out an API before writing a bunch of code to consume it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, if I’m a platform operator hosting APIs, I may need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide developers self-service access to an API gateway that they can configure
    themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor and alert on metrics around the APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide an API gateway with extremely high throughput so as not to become a
    bottleneck
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provide a uniform implementation of common features such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSO** (**Single Sign-On**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limiting
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Header manipulation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Header/content enrichment
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Where necessary, let developers build custom filters and plug them into an API
    gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage the life cycle and upgrades of developers’ API gateways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where possible, auto-generate API documentation based on what is deployed to
    the gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a single searchable location where developers can discover and try out
    all the APIs I manage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud Gateway for Kubernetes** and **API Portal for VMware Tanzu**
    exist specifically to provide a simple, straightforward, enterprise-wide solution
    for all three personas’ concerns.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a high-level overview of the topics being covered, let’s break
    it down into the “whys” of both products. We’ll start with *Spring Cloud Gateway*
    *for Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: Why Spring Cloud Gateway for Kubernetes?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spring Cloud Gateway for Kubernetes** is based on the open source *Spring
    Cloud Gateway* project: [https://spring.io/projects/spring-cloud-gateway](https://spring.io/projects/spring-cloud-gateway).
    Spring Cloud Gateway is a library for building high-performance APIs. You deploy
    it like a normal Spring app and configure it like you would configure a Spring
    app. Unfortunately, the open source project doesn’t do much to address many of
    the problems mentioned previously – problems commonly encountered in the enterprise.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to their business logic, developers must also package, configure,
    and deploy a Spring Cloud Gateway app, or bundle it into their existing app as
    a library. Either way, it’s a significant amount of added complexity. Unless they’re
    using some advanced features of the Spring Framework, any changes to their API’s
    routes will involve rebuilding and redeploying the app.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the open source Spring Cloud Gateway leaves some of the operator’s
    problems unsolved. If every development team is doing its custom deployment of
    Spring Cloud Gateway, the operator can’t reason about how each gateway’s routes
    will be exposed, or how it will emit metrics. In addition, there’s no easy way
    for multiple teams to share a gateway as they all need to configure and deploy
    it on their schedule.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where Spring Cloud Gateway for Kubernetes enters the picture. Spring
    Cloud Gateway for Kubernetes is a commercial Tanzu product with a superset of
    the open source’s features. It is geared specifically toward the enterprise and
    managing software at scale. It uses a Kubernetes Operator to manage three main
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Instances of Spring Cloud Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API routes – instructions to the gateway on how to filter incoming requests
    and where to send them on to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mappings of API routes to Spring Cloud Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By exposing these three entities as Kubernetes **Custom Resources**, Spring
    Cloud Gateway for Kubernetes can abstract away the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Packaging and deploying Spring Cloud Gateway instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the Spring code to configure those instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically updating that configuration without redeploying them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Life cycle-managing all the gateway instances across all Kubernetes clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reasoning about the gateway instances in bulk:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They all emit metrics the same way, so I can easily aggregate all their metrics
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They all expose their API configuration the same way, so I can aggregate that
    config and report on it or, as we will see shortly, use it to drive other useful
    tools such as API Portal for VMware Tanzu
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To summarize then, Spring Cloud Gateway for Kubernetes uses a Kubernetes Operator
    and some very strategic **Custom Resource Definitions** to make the already formidable
    open source Spring Cloud Gateway a first-class Kubernetes citizen and a truly
    enterprise-grade product focused on enterprise-grade problems. This is summed
    up in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Spring Cloud Gateway for Kubernetes at a glance](img/B18145_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Spring Cloud Gateway for Kubernetes at a glance
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered how to deploy APIs, let’s move on to how best to consume
    them. Let’s have a look at **API Portal for** **VMware Tanzu**.
  prefs: []
  type: TYPE_NORMAL
- en: Why API Portal for VMware Tanzu?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as **Spring Cloud Gateway for Kubernetes** is a self-service tool allowing
    developers and operators to uniformly deploy, manage, and secure their APIs, **API
    Portal for VMware Tanzu** is a self-service tool that allows developers and consumers
    to publish, document, search for, discover, and try out those APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Just as Spring Cloud Gateway for Kubernetes makes it easy to deploy multiple
    gateways for multiple use cases or environments, API Portal for Vmware Tanzu makes
    it easy to deploy multiple searchable catalogs across those very same use cases
    or environments.
  prefs: []
  type: TYPE_NORMAL
- en: This distributed, Kubernetes-native approach to API catalogs can scale across
    multiple large teams and enables self-service, which, in turn, gives you greater
    developer productivity and satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, it’s a simple, straightforward operation to integrate API portals
    with enterprise SSO so that the right people can find the right APIs for their
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know *why* we’re learning about these products, let’s get started
    with installing them and trying them out. Let’s go over some technical requirements;
    then, we can start with **Spring Cloud Gateway** **for Kubernetes**.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**API Portal for VMware Tanzu** is a subcomponent of another product covered
    in this book, **Tanzu Application Platform (TAP)**. To get started with API Portal
    for VMware Tanzu, we’ll first need to install a Kubernetes cluster and then install
    TAP on that cluster. You’re free to use whichever Kubernetes distribution you
    prefer. If you’d like some guidance around standing up a cluster, you can go to
    the appendix at the end of the book where we describe several options for getting
    Kubernetes up and running.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a running Kubernetes cluster, you’ll need to jump briefly to [*Chapter
    8*](B18145_08.xhtml#_idTextAnchor150), *Enhancing Developer Productivity with
    Tanzu Application Platform*, and install *Tanzu Application Platform*. That chapter
    walks through a more complex end-to-end use case, while this chapter focuses solely
    on the *API* *Portal* component.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll need an account on a container registry that presents a TLS certificate
    trusted by your Kubernetes cluster. The easiest thing to do is sign up for a free
    developer account at Docker Hub. Simply visit [https://hub.docker.com](https://hub.docker.com)
    and sign up.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to deploy the real-world use case, you’ll need an OIDC provider
    for SSO. If you don’t already have something available, I’d recommend setting
    up a free developer account at Okta: [https://developer.okta.com/signup/](https://developer.okta.com/signup/).
    Later in this chapter, there will be some detailed instructions for setting up
    your account to work with our real-world example application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the **Spring Cloud Gateway for Kubernetes** installation
    requires the *helm* CLI, which you can find here: [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll need the *kustomize* CLI, which can be found here: [https://kustomize.io](https://kustomize.io).
    If you just want to download the binary, you can also go here: [https://kubectl.docs.kubernetes.io/installation/kustomize/binaries](https://kubectl.docs.kubernetes.io/installation/kustomize/binaries).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Kubernetes running *Tanzu Application Platform*, we can install
    **Spring Cloud Gateway for Kubernetes** and **API Portal for** **VMware Tanzu**.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s double-check that we have all our prerequisites in place:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need an up-to-date version of the `kapp` controller – at least 0.29.0:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also need the `secretgen` controller:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s make sure we have up-to-date versions of `helm` and `kustomize` installed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, we should test that we have a writable Docker repository and a
    working Docker CLI. The following is a simple way to test that everything has
    been set up properly. I’ll use `dockerhub` as the registry, but you can plug in
    whichever solution you’ve chosen to use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If everything worked without errors, congratulations! You should have all the
    technical requirements in place to proceed to the next section, where you will
    install **Spring Cloud Gateway for Kubernetes** and **API Portal for** **VMware
    Tanzu**!
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Gateway for Kubernetes – getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start by installing **Spring Cloud Gateway for Kubernetes**. There are
    two distinct parts to this product: the Kubernetes Operator and the deployed gateways.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Kubernetes Operator* works with the Kubernetes API to handle three *Custom*
    *Resource Definitions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SpringCloudGateway** (abbr: *scg*): This is an (optionally) HA instance of
    Spring Cloud Gateway – centrally packaged, deployed, and life cycle-managed for
    the developer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SpringCloudGatewayRouteConfig** (abbr: *scgrc*): This is a set of instructions
    for a Spring Cloud Gateway instance around what host/path to accept requests on,
    how to filter that request, and which backend Kubernetes service to eventually
    proxy it onto.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SpringCloudGatewayMapping** (abbr: *scgm*): This tells the Kubernetes operator
    which *SpringCloudGatewayRouteConfigs* are associated with which *SpringCloudGateways*.
    The operator automatically reconfigures *SpringCloudGateways* with the necessary
    Spring configuration properties to match the contents of *SpringCloudGatewayRouteConfig*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployed instances of Spring Cloud Gateway are the other half of the product.
    The Kubernetes operator stands up multiples of these gateways, which can accept
    incoming traffic via a Kubernetes service or ingress. It then looks for *SpringCloudGatewayRouteConfigs*
    that are mapped to a particular Spring Cloud Gateway instance and dynamically
    configures those routes.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Cloud Gateway deployed instances are what handle API traffic for
    developers’ APIs. The Kubernetes Operator is how developers can self-service provision
    Spring Cloud Gateway instances and (human, not Kubernetes) operators can monitor
    and manage those instances automatically, and at scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation process is as simple as running a couple of scripts to relocate
    the necessary container images to your container registry and then deploying the
    necessary Kubernetes artifacts to your cluster using *Helm*. The official installation
    instructions can be found here: [https://docs.vmware.com/en/VMware-Spring-Cloud-Gateway-for-Kubernetes/1.0/scg-k8s/GUID-installation.html](https://docs.vmware.com/en/VMware-Spring-Cloud-Gateway-for-Kubernetes/1.0/scg-k8s/GUID-installation.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To paraphrase the installation, here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the binary from this link: [https://network.tanzu.vmware.com/products/spring-cloud-gateway-for-kubernetes](https://network.tanzu.vmware.com/products/spring-cloud-gateway-for-kubernetes).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the script to take the local `.tgz` image layers and push them to your container
    repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the script to deploy everything to your Kubernetes cluster via *helm*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, let’s relocate our images. The Kubernetes operator and the deployed
    Spring Cloud Gateway instances need to exist in an external image repository that
    is reachable from the Kubernetes cluster. At this time, Spring Cloud Gateway for
    Kubernetes is delivered via download and all the image bits are contained in the
    downloaded file. To get those bits somewhere Kubernetes can access them, we’ll
    need to load them into our local Docker environment and push them to the remote
    repository. The straightforward Docker commands are in the `scripts/relocate-images.sh`
    file if you’re interested. Otherwise, simply navigate to the `scripts` directory
    and call the script. I’ll share the abbreviated output from my run. `docker.io/rhardt`
    is my repository. If you set up a Docker Hub account, yours will be `docker.io/<your-username>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So, now, we have our container images somewhere that Kubernetes can find them.
    The other thing that the `relocate-images.sh` script does is create a file called
    `scg-image-values.yaml` that Helm will use when deploying to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second script we will run is `install-spring-cloud-gateway.sh`, also in
    the `scripts` directory. I encourage you to peruse this script as well as it’s
    an excellent example of a comprehensive helm deployment, complete with updating
    an existing installation, specific instructions on timeout, error diagnostics
    in the event of failure, and checking to see that the deployment succeeded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve installed Spring Cloud Gateway for Kubernetes, let’s move on
    to API Portal for VMware Tanzu.
  prefs: []
  type: TYPE_NORMAL
- en: API Portal for VMware Tanzu – getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike *Spring Cloud Gateway for Kubernetes*, API Portal for VMware Tanzu comes
    as a part of *Tanzu Application Platform*, which you installed in the *Technical
    requirements* section previously. You can verify that API Portal is installed
    and running by navigating to your Tanzu Application GUI, either at a local port
    forward address such as `http://localhost:8081` or at your ingress domain such
    as `http://tap-gui.example.com`. This depends on your choice of Kubernetes cluster
    and how you installed TAP. Once you access your Tanzu Application Platform GUI,
    click the **APIs** menu item on the left-hand side; you should see a screen like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – API Portal](img/B18145_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – API Portal
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Gateway for Kubernetes and API Portal for VMware Tanzu – real-world
    use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we’re going to implement a real-world use case using **API Portal for VMware
    Tanzu** and **Spring Cloud Gateway for Kubernetes**. This will show how these
    products naturally work together and how, in combination, you can realize significant
    value as a developer, consumer, or operator of APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of our next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We will download an API-driven application called *Animal Rescue* while approximating
    a real-world animal adoption site, complete with SSO.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will set up our Okta environment so that our application can use Okta for
    SSO. Then, we will take the Okta parameters and plug them into the Animal Rescue
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will deploy the Animal Rescue application to our Kubernetes cluster, which
    will create the necessary Spring Cloud Gateway artifacts. By doing so, we will
    be able to browse and interact with the Animal Rescue web app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will modify our API Portal installation so that it connects to the Spring
    Cloud Gateway Kubernetes Operator, which now knows all the API routes for the
    Animal Rescue app and exposes them as OpenAPIv3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will port-forward to our API Portal to explore and try out the Animal Rescue
    APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you know what we’re trying to accomplish, here are the steps.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – cloning this book’s Git repository and navigating to the Animal Rescue
    application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the Git CLI to clone the book code repository and then navigate to the
    *animal-rescue* application as seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Step 2 – configuring your Okta developer account to provide SSO for Animal Rescue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These steps are a bit involved, so I recommend following the instructions directly
    from the VMware documentation here: [https://docs.vmware.com/en/VMware-Spring-Cloud-Gateway-for-Kubernetes/1.0/scg-k8s/GUID-sso-setup-guide.html](https://docs.vmware.com/en/VMware-Spring-Cloud-Gateway-for-Kubernetes/1.0/scg-k8s/GUID-sso-setup-guide.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After completing the setup, we’ll need to complete one additional step for
    this example to work. We need to add two additional sign-in redirect URIs for
    the “gateway” application. This screenshot shows my Okta setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Screenshot of the Okta sign-in redirect URIs](img/B18145_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Screenshot of the Okta sign-in redirect URIs
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be port-forwarding the Animal Rescue app to `http://localhost:8084` and
    the API gateway to `http://localhost:8085`; we’d like both to be able to authenticate
    via Okta.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this exercise, you’ll need three pieces of information from your
    Okta environment: `issuer-id`, `client-id`, and `client-secret`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The VMware documentation instructs you on how to configure the Animal Rescue
    app with that information. I’ll include it here as well. These steps are relative
    to the `animal-rescue` app that we cloned from GitHub in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `backend/secrets/sso-credentials.txt` with the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `gateway/sso-secret-for-gateway/secrets/test-sso-credentials.txt` with
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Some of the additional steps mentioned in the documentation, such as editing
    `roles-attribute-name` or configuring route security have already been done for
    you in the version of the app you downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – deploying the Animal Rescue application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the `animal-rescue` directory – that is, the home directory of the app
    you cloned (`DevSecOps-in-Practice-with-VMware-Tanzu/chapter-05/animal-rescue`)
    – run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you can watch to see when all the pods in the `animal-rescue`
    namespace have come up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Once the pods are up, we can port forward to `localhost:8084`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, I highly recommend an *incognito* browser window to prevent the
    application from getting confused regarding your Okta developer account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your browser to `http://localhost:8084`; you should see the Animal Rescue
    web application replete with cute animals to adopt and an SSO login button in
    the top-right corner. If you configured everything correctly, clicking that button
    will take you to an Okta login and then back to the running application once you’ve
    logged in. This is what it looks like in my browser. Notice the text in the top
    right with my Okta username:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Animal Rescue screenshot](img/B18145_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Animal Rescue screenshot
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good! Now, let’s take things to the next level and integrate this
    API with **API Portal for** **VMware Tanzu**.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – (optional) viewing the Animal Rescue API’s OpenAPI 3.0 specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is, in my opinion, one of the most compelling features of this pair of
    products.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, developers are responsible for manually keeping their API specification
    in some sort of documentation format, usually OpenAPI 3.x or Swagger. This is
    tedious for the developer, and in the heat of battle, that API specification will
    be the first thing to stop being maintained. This means that new consumers will
    be basing their clients on incorrect, out-of-date API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Once you deploy the *Animal Rescue* application, the Spring Cloud Gateway Kubernetes
    Operator manages all the routes – that is, the Kubernetes Operator manages the
    configuration of Spring Cloud Gateway instances so that every API call gets properly
    routed to the right backend service, along with any filters, security, and metadata.
    This is sufficient information to auto-generate the API’s OpenAPI 3.0 specification.
  prefs: []
  type: TYPE_NORMAL
- en: It’s hard to understate what a breakthrough this is. The actual Kubernetes objects
    that control the API’s runtime configuration are used to auto-generate always-accurate,
    always-up-to-date OpenAPI 3.0 documentation. This removes the burden of documentation
    creation and maintenance from the API developer, and the burden of working around
    out-of-date documentation from the API consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a quick look at our Animal Rescue API auto-generated documentation.
    The OpenAPI 3.0 documentation for every deployed API across all gateways is available
    via a web endpoint on the Spring Cloud Gateway Operator. That web endpoint is
    exposed via a ClusterIP service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In production, you may want to put a TLS-secured ingress in front of that service,
    but for the sake of demonstration, let’s just set up a quick port forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we determined that the `spring-cloud-gateway` service was running on
    port `80`, so we port-forwarded our local workstation’s port `8083` to that service
    on port `80`. Now, we can point a web browser to `http://localhost:8083`, and
    voila! You will see the OpenAPI 3.0.1 representation of the `Animal Rescue` API,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Animal Rescue auto-generated OpenAPI 3.0.1 specification](img/B18145_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Animal Rescue auto-generated OpenAPI 3.0.1 specification
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a 100% valid and accurate OpenAPI 3.0, so any tools that can generate
    clients or server stubs from that format will work with it. Furthermore, the Kubernetes
    `SpringCloudGatewayRouteConfig` objects contain fields for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Human-readable descriptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the possible response codes and their meanings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any sort of authentication required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, the real-world Kubernetes objects driving the real-world runtime
    behavior are also driving the documentation, so it’s always accurate and up to
    date.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – (optional) connecting API Portal for VMware Tanzu with the Spring Cloud
    Gateway for Kubernetes OpenAPI endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we demonstrated earlier, **API Portal for VMware Tanzu** is driven entirely
    by OpenAPI 3 or Swagger documents. It’s only logical, then, that we’d set up the
    API Portal to consume the OpenAPI 3 documents generated by **Spring Cloud Gateway
    for Kubernetes**. If you set up a port forward in the previous step, you can exit
    from it. Since the API Portal and Spring Cloud Gateway are on the same Kubernetes
    cluster, they can communicate via ClusterIP services.
  prefs: []
  type: TYPE_NORMAL
- en: We previously installed `tanzu package` command. Now, let’s throw together a
    simple configuration file that overrides where API Portal will look for OpenAPI
    3 docs, and update the package installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a file called `api-portal-values.yaml` with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we’re appending the ClusterIP service of the Spring Cloud Gateway
    Operator to the list of places where the API Portal will search for API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use the `tanzu package` command to update the installation. Behind
    the scenes, the API Portal will be redeployed with the new configuration. This
    method of deploying software removes configuration drift as any manual configuration
    changes to the deployment will be overwritten by the `kapp` controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s re-instate our port forward to our API Portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And upon opening a web browser to `http://localhost:8085`, we should see our
    `Animal Rescue` API in the list, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – API Portal with the Animal Rescue API](img/B18145_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – API Portal with the Animal Rescue API
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Animal Rescue` tile, click **VIEW APIS**. Then, on the resulting screen,
    click **/api/animals**, then **Try it Out**, then **Execute**. If everything has
    been configured correctly, you should see some animal data in JSON format in the
    **Server response** section, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Trying out APIs from the browser](img/B18145_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Trying out APIs from the browser
  prefs: []
  type: TYPE_NORMAL
- en: Just to be clear, you’re able to *try out* APIs directly from the API Portal
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: After the exhilarating experience of installing these two products, wiring them
    together, and implementing a complex real-world application, we must face the
    inevitable. Long after the fun of deploying a working piece of software has faded,
    the ongoing task of maintenance and support will remain. We’ll cover that next.
  prefs: []
  type: TYPE_NORMAL
- en: Common day-2 operations with Tanzu Application Accelerator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! If you’ve made it this far, you have set up an API publishing
    and consumption model that can unlock incredible value in your enterprise software
    development operation.
  prefs: []
  type: TYPE_NORMAL
- en: As is usually the case in the enterprise, the hard problem is not getting something
    installed and configured, it’s operating it over time. Let’s look at some of these
    day-2 operations.
  prefs: []
  type: TYPE_NORMAL
- en: Updating an API’s route definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say we identify a typo in an API route’s description. We’d like to be
    able to update that route in real time and have it propagate to the API Portal
    without any additional configuration. Let’s do that. Navigate to the `animal-rescue`
    app that you cloned from GitHub and open the `./backend/k8s/animal-rescue-backend-route-config.yaml`
    file in an editor. At line 17, you’ll see a description starting with *Retrieve
    all the anmals*. Fix it so that it reads *Retrieve all the animals*. If you want
    to be doubly sure, insert some additional text if you’d like. Here’s what it looked
    like in my editor. I wanted to be *especially* sure that I was seeing my changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Editing the description of an API route](img/B18145_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Editing the description of an API route
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must simply update the Spring Cloud Gateway Route Config in Kubernetes,
    and the documentation should auto-update. Don’t forget the namespace, which in
    the original install was added by *kustomize*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you still have the port-forward to `api-portal` running, you can navigate
    to `http://localhost:8085`, click through to the Animal Rescue `/api/animals`
    route, and see your update in real time!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Viewing real-time updates to our API specification](img/B18145_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Viewing real-time updates to our API specification
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’ve gone in-depth into numerous *day-0* and *day-1* tasks,
    such as deploying and consuming APIs. But anyone who has spent any time at all
    in the enterprise software space knows that the vast majority of our time and
    effort is spent on the *day-2* tasks: updating, monitoring, measuring, and improving
    our software. Let’s briefly cover some of these day-2 topics.'
  prefs: []
  type: TYPE_NORMAL
- en: Updating the API Portal package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `tanzu package` commands in conjunction with the kapp controller give you
    incredible power to life cycle-manage your deployed software. In the case of API
    Portal, you can grab the currently deployed version and see which versions are
    currently available. Then, to update it, you simply execute `tanzu package installed
    update -n tap-install api-portal -v <``new version>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We currently have 1.0.8 installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It appears that version 1.0.9 became available recently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: And with a simple command, our `api-portal` package auto-updates to the latest
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: APIs are everywhere. With OpenAPI 3 and REST becoming the well-accepted standard
    among developers, a significant portion of an enterprise developer’s job consists
    of creating, publishing, discovering, and consuming APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an environment with a significant number of developers on disparate teams,
    this inevitably leads to waste: a significant waste of time, effort, and money.'
  prefs: []
  type: TYPE_NORMAL
- en: Developers waste energy reverse-engineering inadequately documented APIs. They
    waste time identifying the right API. They burn unnecessary cycles figuring out
    how to make their API widely available.
  prefs: []
  type: TYPE_NORMAL
- en: Once they have an API deployed, there’s a waste of time and energy making sure
    the API is adequately secured and that it’s shared across a large organization,
    not to mention making sure those APIs are maintained and kept up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Architects may spend undue time building out a central clearing house for discovering
    APIs and a central gateway for deploying them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, operators are tasked with monitoring and measuring many polyglot APIs
    across different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: With the tools that you’ve now become familiar with in this chapter, I hope
    you can take a big bite out of that API waste, making your team, your development
    org, and your company wildly successful, efficient, and API-driven.
  prefs: []
  type: TYPE_NORMAL
- en: With our next chapter, we will move our focus from *building* software to *running*
    it. We’ll kick off our new area of focus with a deep dive into hosting and maintaining
    OCI container images and Helm Charts with the **VMware** **Harbor Registry**.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 – Running Cloud-Native Applications on Tanzu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part of the book focuses on the tools and techniques that help run modern
    cloud-native applications on Kubernetes with multi-cloud and multi-cluster deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of the book comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18145_06.xhtml#_idTextAnchor112), *Managing Container Images
    with Harbor*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18145_07.xhtml#_idTextAnchor131), *Orchestrating Containers
    across Clouds with Tanzu Kubernetes Grid*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18145_08.xhtml#_idTextAnchor150), *Enhancing Developer Productivity
    with Tanzu Application Platform*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
