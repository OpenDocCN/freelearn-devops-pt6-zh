- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Application Performance with Grafana Pyroscope and k6
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Grafana Pyroscope 和 k6 进行应用性能分析
- en: This chapter will explore two tools, **Pyroscope** and **k6**. Pyroscope is
    a **continuous profiling** tool that allows users to collect very detailed information
    about the usage of system resources such as CPU and memory. k6 is a **load testing**
    tool that can be used to interact with an application via endpoints, or via a
    browser session in a scripted way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨两个工具，**Pyroscope** 和 **k6**。Pyroscope 是一个 **持续性能分析** 工具，允许用户收集关于系统资源使用的非常详细的信息，比如
    CPU 和内存。k6 是一个 **负载测试** 工具，可以通过端点与应用程序交互，或通过脚本方式在浏览器会话中使用。
- en: With Pyroscope, we will see how to search data, which will give you a good understanding
    of how to make use of the data available. We will then show how to add instrumentation
    to collect this data using both an installed client and by adding a native language
    SDK to the application code. Finally, we will see how the new version of the Pyroscope
    architecture leverages Grafana’s knowledge of highly scalable storage platforms,
    using inexpensive block storage to set Pyroscope on a path toward offering truly
    continuous profiling for developers. This functionality will allow those of you
    who need visibility of code execution to improve operational cost or end user
    performance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pyroscope 中，我们将学习如何搜索数据，这将帮助您更好地理解如何利用可用数据。接着，我们将展示如何通过安装客户端或向应用代码中添加原生语言
    SDK 来加入插桩以收集这些数据。最后，我们将看到 Pyroscope 新版本的架构如何利用 Grafana 在高可扩展存储平台方面的知识，使用廉价的块存储将
    Pyroscope 带入为开发者提供真正持续性能分析的路径。这项功能将帮助那些需要查看代码执行情况的人，改善运营成本或最终用户性能。
- en: k6 will move a little away from observability into the very closely related
    field of load or performance testing. We will discuss the general principles of
    load testing and look at the different categories of load tests that you may need.
    Then, you will be introduced to the scripting language used by k6 to easily write
    tests that validate the application is performing as expected. We will see how
    k6 uses **virtual users** (**VUs**) to scale tests and create a significant load
    on an application, so you can use it to prove your applications are running as
    expected. Finally, we’ll see how k6 can be installed, and how it is versatile
    enough to even run as part of a CI pipeline, ensuring your applications are continuously
    load tested.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: k6 将稍微偏离可观察性，进入与之紧密相关的负载或性能测试领域。我们将讨论负载测试的一般原则，并查看您可能需要的不同类别的负载测试。接着，您将学习 k6
    使用的脚本语言，方便编写测试来验证应用程序是否按预期运行。我们将了解 k6 如何使用 **虚拟用户**（**VUs**）来扩展测试并为应用程序创造显著负载，您可以利用它证明您的应用程序按预期运行。最后，我们将看到如何安装
    k6，以及它如何足够灵活，甚至可以作为 CI 流水线的一部分运行，确保您的应用程序持续接受负载测试。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: Using Pyroscope for continuous profiling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pyroscope 进行持续性能分析
- en: Using k6 for load testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 k6 进行负载测试
- en: Using Pyroscope for continuous profiling
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pyroscope 进行持续性能分析
- en: 'First, let’s address the question of what **continuous profiling** is. As we
    outlined at the start of this book, a system is observable when the internal state
    of the system can be inferred from its external outputs. We have seen three types
    of output telemetry: logs, metrics, and traces. Profiling data is another form
    of telemetry. Profiling data is very low-level data that relates to a workload’s
    use of resources, such as the use of CPU or memory. As profiling tools analyze
    very low-level system data, they capture information such as the running time
    or the number of objects in memory of a specific application function. This is
    very powerful for domain experts to inspect how an application behaves, and this
    power can lead to significant performance and cost improvements. Profiling has
    been around for a long time, as anyone who has produced a stack trace will know.
    Pyroscope offers the ability to capture this profiling data continuously, with
    a default interval of 15 seconds. The ability to collect this telemetry continuously
    over the lifetime of an application can give insight into how an application runs
    over time, which can link the inner workings of the code base to specific user
    actions seen in logs, metrics, and traces.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们解决一个问题，那就是**连续剖析**是什么。如同本书开头所提到的，当系统的内部状态可以从其外部输出中推测出来时，系统是可观察的。我们已经看到了三种输出遥测：日志、指标和追踪。剖析数据是另一种遥测形式。剖析数据是与工作负载资源使用相关的低级数据，如
    CPU 或内存的使用情况。由于剖析工具分析的是非常底层的系统数据，它们捕获的信息包括特定应用函数的运行时间或内存中的对象数量。这对于领域专家检查应用程序行为非常有力，这种能力能够带来显著的性能和成本改进。剖析技术已经存在很长时间了，任何生成过堆栈跟踪的人都会知道这一点。Pyroscope
    提供了连续捕获这种剖析数据的能力，默认间隔为 15 秒。能够在应用程序的生命周期内持续收集这些遥测数据，可以深入了解应用程序随时间的运行情况，这能够将代码库的内部工作与日志、指标和追踪中看到的特定用户行为联系起来。
- en: In this section, we will briefly introduce Pyroscope. You will be shown how
    to search the data collected by Pyroscope. We will talk about configuring the
    client to collect profiles, and we will look at the architecture of the Pyroscope
    server.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍 Pyroscope。你将学习如何搜索 Pyroscope 收集的数据。我们将讨论如何配置客户端以收集剖析数据，并将研究 Pyroscope
    服务器的架构。
- en: A brief overview of Pyroscope
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pyroscope 简介
- en: 'Pyroscope, also known as Grafana Cloud Profiles, was founded in 2020 and acquired
    by Grafana Labs in 2023\. The Pyroscope team joined the team from a Grafana Labs
    experimental product called Phlare, and the product is now a standard offering
    from Grafana Cloud. Some of the key features of Pyroscope are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Pyroscope，也被称为 Grafana Cloud Profiles，成立于2020年，并在2023年被 Grafana Labs 收购。Pyroscope
    团队从 Grafana Labs 的一个实验性产品 Phlare 中加入，该产品现在成为了 Grafana Cloud 的标准产品之一。Pyroscope
    的一些关键特性如下：
- en: Great horizontal scalability using the same architecture as Loki, Mimir, and
    Tempo
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与 Loki、Mimir 和 Tempo 相同架构的优秀水平扩展性
- en: Cheap storage for profile data
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剖析数据的廉价存储
- en: Can store data locally or using Grafana Cloud
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将数据存储在本地或使用 Grafana Cloud
- en: High frequency of sampling, which produces very granular data
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高频率采样，产生非常细粒度的数据
- en: Now, let’s explore how we can examine the data collected by Pyroscope.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨如何检查 Pyroscope 收集的数据。
- en: Searching Pyroscope data
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索 Pyroscope 数据
- en: 'Profile telemetry can be viewed using the **Explore** view in the Grafana UI
    by selecting a Pyroscope source. While the view is similar to Loki, Mimir, and
    Tempo, the query language is limited by the nature of the telemetry type; effectively,
    only selection functionality is available to select a signal from an application
    or group of applications by tag. This is the view you will see to select data
    from a Pyroscope source:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在 Grafana UI 中选择 Pyroscope 数据源，使用**Explore**视图查看剖析遥测数据。虽然该视图与 Loki、Mimir
    和 Tempo 类似，但查询语言受到遥测类型的限制；实际上，只能使用选择功能，通过标签选择来自应用程序或应用程序组的信号。你将在此视图中看到用于选择 Pyroscope
    数据源数据的界面：
- en: '![Figure 13.1 – Pyroscope query pane](img/B18277_13_1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – Pyroscope 查询面板](img/B18277_13_1.jpg)'
- en: Figure 13.1 – Pyroscope query pane
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – Pyroscope 查询面板
- en: 'The first view to look at is the `top` command, this view will be familiar.
    The view lists every function and the amount of time that has been spent on the
    function. The **Self** column shows the time spent on that function. The **Total**
    column shows the total time each function takes to run. This allows users to see
    functions that have a long running time. Long runtimes could indicate an inefficient
    function, but it could also indicate a function that is central to the application.
    Domain expertise is needed to understand where improvements could be made. This
    screenshot shows the **Top** **Table** view:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个需要查看的视图是`top`命令，这个视图应该是熟悉的。该视图列出了每个函数及其所花费的时间。**Self**列显示该函数所花费的时间。**Total**列显示每个函数运行的总时间。这可以帮助用户查看运行时间较长的函数。较长的运行时间可能表明一个低效的函数，但也可能意味着这个函数对应用程序至关重要。需要领域知识才能理解在哪些地方可以进行改进。以下截图显示了**Top**
    **Table**视图：
- en: '![Figure 13.2 – Pyroscope Top Table view](img/B18277_13_2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – Pyroscope 顶部表格视图](img/B18277_13_2.jpg)'
- en: Figure 13.2 – Pyroscope Top Table view
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – Pyroscope 顶部表格视图
- en: 'The second view is the **Flame Graph** view. This chart is specifically designed
    to visualize profile data. **Flame graphs** were invented to be able to visualize
    stack trace output from applications to make debugging easier. Before we look
    at the view in Pyroscope, let’s take a look at a sample application stack trace:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个视图是**火焰图**视图。这个图表专门设计用来可视化分析数据。**火焰图**的发明是为了能够可视化应用程序的堆栈跟踪输出，从而简化调试工作。在我们查看
    Pyroscope 中的视图之前，先来看一个示例应用程序的堆栈跟踪：
- en: '![Figure 13.3 – Example application stack trace](img/B18277_13_3.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – 示例应用程序堆栈跟踪](img/B18277_13_3.jpg)'
- en: Figure 13.3 – Example application stack trace
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – 示例应用程序堆栈跟踪
- en: 'We can see there is a `main()` function, which is started when the application
    is run. This function calls the child functions, `foo()` and `bar()`, in order,
    and `bar()` also calls the `baz()` and `qux()` functions. A flame graph captures
    the hierarchical nature of these stack calls by grouping child functions under
    their parent. This allows us to see how deep the call stack is by looking at the
    *y* axis. The total population of functions is shown in the *x* axis; importantly,
    this does not represent the time but rather each function that was seen on the
    call stack during the sampling period. The visualization of duration is shown
    in a flame graph by the width of the box for each function, which shows the total
    time spent on a function during the sampling period. Let’s have a look at how
    this looks in practice:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有一个`main()`函数，它在应用程序启动时被调用。这个函数依次调用子函数`foo()`和`bar()`，而`bar()`也会调用`baz()`和`qux()`函数。火焰图通过将子函数分组在其父函数下，捕捉了这些堆栈调用的层次结构。这让我们能够通过查看*y*轴来了解调用堆栈的深度。函数的总数量显示在*x*轴上；重要的是，这不代表时间，而是每个在采样期间出现在调用堆栈中的函数。火焰图中每个函数的框宽度表示该函数在采样期间花费的总时间，进而可视化了每个函数的持续时间。我们来看看这个实际的例子：
- en: '![Figure 13.4 – Example flame graph from the stack trace](img/B18277_13_4.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 – 来自堆栈跟踪的示例火焰图](img/B18277_13_4.jpg)'
- en: Figure 13.4 – Example flame graph from the stack trace
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – 来自堆栈跟踪的示例火焰图
- en: In this example flame graph, we can see that the `baz()` function takes up a
    significant portion of the operating time. In some applications, this may be completely
    expected behavior; in other applications, this may indicate a function that needs
    to be optimized.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例火焰图中，我们可以看到`baz()`函数占用了大量的操作时间。在某些应用程序中，这是完全预期的行为；而在其他应用程序中，这可能表明需要优化的函数。
- en: 'Very few applications are as simple as this example. Let’s look at a real flame
    graph from the OpenTelemetry Demo application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有应用程序像这个示例一样简单。接下来，我们看看 OpenTelemetry 演示应用程序中的真实火焰图：
- en: '![Figure 13.5 – A real flame graph](img/B18277_13_5.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5 – 一个真实的火焰图](img/B18277_13_5.jpg)'
- en: Figure 13.5 – A real flame graph
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 一个真实的火焰图
- en: We’ve seen how continuous profiling tools such as Pyroscope can be valuable
    in creating efficient code and debugging issues. Let’s now look at how to collect
    profile data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到像 Pyroscope 这样的连续分析工具在编写高效代码和调试问题中非常有价值。接下来，我们来看看如何收集分析数据。
- en: Continuous profiling client configuration
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连续分析客户端配置
- en: 'There are currently three separate ways to collect data for Pyroscope, although
    we expect this to evolve as Pyroscope is quite a new piece of technology. We would
    recommend the Grafana Labs blog for those of you who want to keep up to date with
    the latest developments from this exciting technology (https://grafana.com/blog/).
    Let’s explore how to set up each one:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有三种独立的方式收集Pyroscope的数据，尽管我们预期随着Pyroscope技术的不断发展，这些方式将会演变。对于那些希望了解此项激动人心技术最新进展的朋友，我们建议参考Grafana
    Labs的博客（https://grafana.com/blog/）。接下来，让我们探讨如何设置每一种方法：
- en: '**Extended Berkeley Packet Filter (eBPF) client**: The first way to collect
    profile data for Pyroscope is to make use of a Linux kernel-level tool called
    eBPF. This tool allows the profiling client to view the trace information for
    all applications running on the server or node. The eBPF client combines this
    data with metadata on the data source (for example, a Kubernetes Pod or namespace)
    and then sends this profile information to a Pyroscope backend. The following
    diagram shows a simplified view of how eBPF stores data for the Pyroscope client
    to collect:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展伯克利数据包过滤器（eBPF）客户端**：收集Pyroscope配置数据的第一种方法是利用Linux内核级工具eBPF。这个工具允许配置客户端查看服务器或节点上运行的所有应用程序的跟踪信息。eBPF客户端将这些数据与数据源的元数据（例如Kubernetes
    Pod或命名空间）结合，然后将这些配置信息发送到Pyroscope后端。下图显示了eBPF如何为Pyroscope客户端收集数据的简化视图：'
- en: '![Figure 13.6 – eBPF client process](img/B18277_13_6.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6 – eBPF客户端进程](img/B18277_13_6.jpg)'
- en: Figure 13.6 – eBPF client process
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – eBPF客户端进程
- en: With eBPF, the kernel collects profile data, as well as several other types
    of data, and stores it in eBPF maps. Pyroscope links into the eBPF maps, packages
    the data, and then sends it for storage in the configured backend.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用eBPF时，内核收集配置数据以及其他几种类型的数据，并将其存储在eBPF映射中。Pyroscope将数据链接到eBPF映射中，打包数据，然后将其发送到配置的后端进行存储。
- en: '**Native language instrumentation**: The second way to collect profile data
    is to use a language-specific Pyroscope SDK to add instrumentation to your application.
    SDKs are currently provided for Go, Java, .NET, Python, Ruby, Rust, and Node.js.
    Apart from the Go SDK, all these libraries only support a *push* mode of operation.
    Go supports both a *push* and a *pull* mode of operation; the pull mode allows
    the Grafana agent to collect profile data from a scraping endpoint published by
    the application. In push mode, it is currently necessary to add the Pyroscope
    server address, basic authenticated username, and password at the application
    level, although as this tool matures, we’re sure this will become easier to manage
    in an operational environment.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地语言仪器**：收集配置数据的第二种方法是使用特定语言的Pyroscope SDK向应用程序添加仪器。目前，Go、Java、.NET、Python、Ruby、Rust和Node.js都提供SDK。除了Go
    SDK之外，所有这些库仅支持*推送*模式操作。Go支持*推送*和*拉取*模式操作；拉取模式允许Grafana代理从应用程序发布的抓取端点收集配置数据。在推送模式下，目前需要在应用程序级别添加Pyroscope服务器地址、基本身份验证用户名和密码，尽管随着该工具的成熟，我们相信这将在操作环境中变得更易于管理。'
- en: '**Instrumenting Lambda functions**: Pyroscope also provides tooling for AWS
    Lambda functions. This consists of a Lambda extension that is loaded as a layer
    when the function is triggered. This allows the profiling tooling to collect the
    required profile telemetry asynchronously without impacting the operation of your
    Lambda function. Like the native language instrumentation, environment variables
    must be provided with the remote address for the Pyroscope backend and the relevant
    authentication tokens.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪器化Lambda函数**：Pyroscope还为AWS Lambda函数提供工具。这包括一个Lambda扩展，当函数被触发时，作为一个层加载。这样，配置工具可以异步收集所需的配置遥测数据，而不影响Lambda函数的操作。与本地语言仪器一样，必须提供环境变量，其中包括Pyroscope后端的远程地址和相关的身份验证令牌。'
- en: For teams running serverless functions, this adds the capability to look inside
    the Lambda function black box and allows teams to answer questions such as, *Why
    is my Lambda costing so much?*, *Why do I have such high latency?*, and *Why is
    my function failing* *so often?*
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于运行无服务器函数的团队，这为查看Lambda函数的“黑匣子”提供了能力，并允许团队回答以下问题：*为什么我的Lambda费用这么高？*，*为什么我的延迟这么高？*，以及*为什么我的函数*
    *这么频繁失败？*
- en: 'There are benefits and drawbacks to the eBPF client, the SDK, and the Lambda
    approaches: their usage is dependent on the use case. Here are some benefits and
    drawbacks for each method:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF客户端、SDK和Lambda方法各有利弊：它们的使用取决于使用场景。以下是每种方法的一些优缺点：
- en: '| **Instrumentation method** | **Benefits** | **Drawbacks** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **工具化方法** | **优点** | **缺点** |'
- en: '| eBPF | System-wide whole system profiles are easy to collect.Infrastructure
    metadata is easy to add (for example, Kubernetes Pod or namespace).Easy to manage
    a multi-language or large system.Can combine with native language instrumentation.
    | Linux kernel constraints.Limited ability to tag user-level code.Some profile
    types are not performant to collect (for example, memory use).More complex for
    local development environments. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| eBPF | 可以轻松收集全系统的系统级配置文件。基础设施元数据易于添加（例如，Kubernetes Pod 或命名空间）。易于管理多语言或大型系统。可以与本地语言工具化结合使用。
    | Linux 内核限制。标记用户级代码的能力有限。一些配置文件类型的收集性能差（例如，内存使用）。本地开发环境更为复杂。 |'
- en: '| Native language | Flexible tagging of code.Detailed profiling of specific
    parts of code.Ability to profile other types of data (for example, memory use).Simple
    to use in local development environments. | Managing a multi-language or large
    system is difficult.Difficult to auto-tag infrastructure metadata (for example,
    Kubernetes Pod or namespace). |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 本地语言 | 灵活标记代码。对代码特定部分进行详细分析。能够分析其他类型的数据（例如，内存使用）。在本地开发环境中使用简单。 | 管理多语言或大型系统比较困难。难以自动标记基础设施元数据（例如，Kubernetes
    Pod 或命名空间）。 |'
- en: '| Lambda functions | Allows for collection of trace data from serverless functions.Links
    with the native language support to instrument the function. | Currently only
    available for AWS Lambda. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| Lambda 函数 | 允许从无服务器函数收集追踪数据。与本地语言支持相连接以对函数进行工具化。 | 当前仅适用于 AWS Lambda。 |'
- en: Table 13.1 – Advantages and drawbacks of Pyroscope instrumentation methods
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.1 – Pyroscope 工具化方法的优缺点
- en: We’ve looked at the different ways to set up applications and clients to collect
    profile data. Now, let’s consider the storage and search architecture of Pyroscope.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了不同的应用程序和客户端设置方式来收集配置数据。接下来，让我们考虑 Pyroscope 的存储和查询架构。
- en: Understanding the Pyroscope architecture
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Pyroscope 架构
- en: Pyroscope 1.0 has introduced a major change to the architecture of Pyroscope.
    This leverages the Grafana knowledge of Cortex architectures to make the architecture
    horizontally scalable. This is a breaking change from previous versions so we
    will only be considering the architecture from this change onward.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Pyroscope 1.0 引入了对 Pyroscope 架构的重大变化。该变化利用了 Grafana 对 Cortex 架构的知识，使架构具备水平扩展能力。这是与之前版本的断裂性变化，因此我们将仅考虑从这个变化开始的架构。
- en: 'Similar to Loki, Mimir, and Tempo, Pyroscope uses low-cost, highly available
    block storage such as Amazon S3, Google Cloud Storage, or Microsoft Azure Storage
    to provide massive scalability. Here’s a diagram of the Pyroscope architecture:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Loki、Mimir 和 Tempo，Pyroscope 使用低成本、高可用的块存储，如 Amazon S3、Google Cloud Storage
    或 Microsoft Azure Storage，以提供大规模扩展能力。以下是 Pyroscope 架构的示意图：
- en: '![Figure 13.7 – Pyroscope architecture](img/B18277_13_7.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – Pyroscope 架构](img/B18277_13_7.jpg)'
- en: Figure 13.7 – Pyroscope architecture
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – Pyroscope 架构
- en: When data is written, it is sent to the **Ingester**, which persists the data
    to **Object Storage**. On the **Reads** side, queries are split and sharded to
    instances of the **Querier**, which grabs the necessary data from the **Ingester**
    and/or the long-term storage.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据被写入时，它会被发送到 **Ingester**，该组件将数据持久化到 **对象存储**。在 **读取** 方面，查询被拆分并分片到 **Querier**
    实例，后者从 **Ingester** 和/或长期存储中获取所需的数据。
- en: There are several alternatives to Pyroscope on the market that may be of interest
    to you. The open source tools include OpenTelemetry eBPF, Parca, and profefe,
    and several observability vendors include similar profiling tools. These tools
    can be found at [https://github.com/open-telemetry/opentelemetry-ebpf](https://github.com/open-telemetry/opentelemetry-ebpf),
    [https://www.parca.dev/](https://www.parca.dev/), and https://github.com/profefe/profefe.
    We’ve now seen how Pyroscope functions. Another tool that is helpful for developers
    and testers is k6 load testing. Let’s take a look at this next.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有几个替代 Pyroscope 的工具可能会引起你的兴趣。开源工具包括 OpenTelemetry eBPF、Parca 和 profefe，还有几个观察性供应商也提供类似的分析工具。这些工具可以在
    [https://github.com/open-telemetry/opentelemetry-ebpf](https://github.com/open-telemetry/opentelemetry-ebpf)、[https://www.parca.dev/](https://www.parca.dev/)
    和 https://github.com/profefe/profefe 找到。我们现在已经看过了 Pyroscope 的功能。另一个对开发人员和测试人员有帮助的工具是
    k6 负载测试。接下来让我们看一下这个工具。
- en: Using k6 for load testing
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 k6 进行负载测试
- en: Load testing is the practice of applying a known, artificial load to an application
    to see how it behaves. The term is often used interchangeably with performance
    testing, and we will follow the k6 documentation in using *average load* to differentiate
    a specific type of test.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试是将已知的人工负载施加到应用程序上，以观察其行为的实践。这个术语通常与性能测试交替使用，我们将遵循 k6 文档，使用*平均负载*来区分特定类型的测试。
- en: 'Several different types of load tests can be applied; they differ on two axes
    – the load throughput and the duration. They may also differ in the content of
    the tests that are performed. Some common types of tests are shown in the following
    table:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用几种不同类型的负载测试；它们在两个维度上有所不同——负载吞吐量和持续时间。它们在执行的测试内容上也可能不同。下表展示了一些常见的测试类型：
- en: '| **Test** | **Description** | **Purpose** | **Runtime** **and volume** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **测试** | **描述** | **目的** | **运行时长** **与流量** |'
- en: '| **Smoke tests** | These are designed to validate that the system works. They
    can also be known as sanity or confidence tests. They are called smoke tests after
    testing a device by powering it on and checking for smoke. | These are designed
    to quickly say that things look as expected or that something is wrong | These
    should run quickly, in minutes not hours.They should be low volume. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **冒烟测试** | 这些测试旨在验证系统是否正常工作。它们也可以称为健全性测试或信心测试。冒烟测试这个名称源自测试设备时，通过开启设备并检查是否冒烟。
    | 这些测试旨在快速验证系统是否符合预期，或者是否存在问题。 | 这些测试应该快速进行，通常是几分钟而非几小时。它们应为低流量。 |'
- en: '| **Average** **load tests** | These tests show how the system is used in most
    conditions. | These are designed to simulate the most frequent level of load on
    the system. | These should run relatively quickly, but slower than smoke tests.They
    should simulate average volumes of traffic. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **平均** **负载测试** | 这些测试展示了系统在大多数条件下的使用情况。 | 这些测试旨在模拟系统上最常见的负载水平。 | 这些测试应该相对快速地进行，但比冒烟测试慢。它们应模拟平均流量。
    |'
- en: '| **Stress tests** | These tests stress the system with higher-than-average
    peak traffic. | These are designed to simulate what would happen if peak traffic
    were experienced for an extended duration. | These should run in less than a day.They
    should simulate high volumes of traffic. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **压力测试** | 这些测试通过高于平均水平的峰值流量来测试系统。 | 这些测试旨在模拟如果在较长时间内经历峰值流量时系统会发生什么。 | 这些测试应该在一天之内完成。它们应模拟大量流量。
    |'
- en: '| **Spike tests** | These tests should show how the system behaves with a sudden,
    short, massive increase in traffic, as might be seen during a **denial of service**
    (**DoS**) attack. | These are designed to test how the system would handle a sudden
    overwhelming spike in traffic, such as a DoS attack. | These should run quickly.They
    should simulate unrealistic amounts of traffic. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **峰值测试** | 这些测试应该展示系统在短时间内经历突如其来的、大量的流量激增时的表现，就像在**拒绝服务**（**DoS**）攻击中看到的那样。
    | 这些测试旨在测试系统如何应对突如其来的、极大的流量激增，如 DoS 攻击。 | 这些测试应该快速进行。它们应模拟不现实的大量流量。 |'
- en: '| **Breakpoint tests** | These tests gradually increase traffic until the system
    breaks down. | These are designed to understand when the system will fail with
    added load. | These can run for extended periods.They should simulate steadily
    increasing rates of traffic. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **突破点测试** | 这些测试逐渐增加流量，直到系统崩溃。 | 这些测试旨在了解在负载增加时系统何时会失败。 | 这些测试可以运行较长时间。它们应模拟稳定增长的流量速率。
    |'
- en: '| **Soak tests** | These tests assess the performance of the system over extended
    periods. They are like an average load test over a significantly longer period.
    | These are designed to demonstrate how the system will function during real operations
    for extended periods. They are good for identifying issues such as memory leaks.
    | These will run over extended periods such as 48 hours.They should simulate average
    volumes of traffic. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **浸泡测试** | 这些测试评估系统在长时间运行下的性能。它们类似于在显著更长时间内进行的平均负载测试。 | 这些测试旨在展示系统在实际操作中长时间运行时的表现。它们适用于发现诸如内存泄漏等问题。
    | 这些测试将运行较长时间，如 48 小时。它们应模拟平均流量。 |'
- en: Table 13.2 – Types of load tests
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.2 – 负载测试类型
- en: 'The following graph shows the different tests for reference:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了不同的测试，供参考：
- en: '![Figure 13.8 – Visual representation of the different load test types](img/B18277_13_8.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8 – 不同负载测试类型的视觉表示](img/B18277_13_8.jpg)'
- en: Figure 13.8 – Visual representation of the different load test types
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – 不同负载测试类型的视觉表示
- en: In the preceding figure, we can see the different types of tests graphed by
    the test throughput and the test duration. Try correlating what you can see in
    the graph with what you’ve just learned about these tests in *Table 13.2*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到通过测试吞吐量和测试持续时间来绘制的不同类型的测试。尝试将你在图表中看到的内容与在*表 13.2*中学到的这些测试相对应。
- en: You can see that load testing and observability are very closely linked. The
    data collected from a live system will show what average and unrealistic loads
    look like. The data injected by a smoke test can show a system is working as expected,
    for example, after a new version is deployed. The data collected from the load
    testing environment can give critical insights into the operation of the system
    under load.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，负载测试和可观察性紧密相关。从实时系统收集的数据将展示出什么是平均负载和不现实的负载。通过冒烟测试注入的数据可以显示系统是否按预期工作，例如在新版本部署后。负载测试环境中收集的数据可以提供关于系统在负载下运行的关键见解。
- en: It is good practice to separate the observability data collected from load testing
    from other data. Due to the nature of the tests that are being tried, very large
    volumes of data can be generated, which can be a very costly thing to collect.
    One huge advantage of open source systems such as Grafana is the ability to run
    the data storage system as part of the load testing environment while using the
    same visualization as in production.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将从负载测试中收集到的可观察性数据与其他数据分开是一个良好的实践。由于所尝试的测试的性质，可能会生成大量数据，这可能会是一个非常昂贵的收集过程。像 Grafana
    这样的开源系统的一个巨大优势是能够将数据存储系统作为负载测试环境的一部分运行，并使用与生产环境中相同的可视化方式。
- en: There are several load testing tools on the market, both open source and commercial.
    The open source offerings include JMeter, k6, Gatling, Locust, Artillery, Tsung,
    Vegeta, Hey, and Siege. As this book focuses on Grafana tools, we will only discuss
    k6 here. Let’s have a look at some of the features of k6.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有几种负载测试工具，既有开源的也有商业的。开源工具包括 JMeter、k6、Gatling、Locust、Artillery、Tsung、Vegeta、Hey
    和 Siege。由于本书关注 Grafana 工具，我们这里只讨论 k6。让我们来看看 k6 的一些特点。
- en: A brief overview of k6
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: k6 简介
- en: 'k6 is the load testing tool developed by Grafana Labs after they acquired LoadImpact.
    k6 offers several key features:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: k6 是由 Grafana Labs 在收购 LoadImpact 后开发的负载测试工具。k6 提供了几个关键特性：
- en: A **command-line interface** (**CLI**) that allows tests to be run, paused,
    resumed, or scaled.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**命令行接口**（**CLI**），可以用于运行、暂停、恢复或扩展测试。
- en: The ability to start tests locally, from a Kubernetes cluster, or in the cloud
    with the CLI. k6 supports distributed running via a Kubernetes operator.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在本地、Kubernetes 集群或通过 CLI 在云端启动测试。k6 支持通过 Kubernetes 操作员进行分布式运行。
- en: Scripting support using JavaScript.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JavaScript 的脚本支持。
- en: The ability to load additional modules into scripts, although this does not
    include support for Node.js modules.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将额外的模块加载到脚本中的能力，尽管这不包括对 Node.js 模块的支持。
- en: A browser module that adds browser-level APIs for full frontend testing.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个浏览器模块，添加浏览器级别的 API，用于完整的前端测试。
- en: Support for goal-oriented load testing using checks and thresholds.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持使用检查和阈值进行目标导向的负载测试。
- en: 'Great supporting tools, such as the following:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很好的支持工具，如下所示：
- en: Reference projects
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考项目
- en: Tools to convert scripts from other tools to k6
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其他工具的脚本转换为 k6 的工具
- en: Tools to convert k6 output to other common formats
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 k6 输出转换为其他常见格式的工具
- en: A GUI for test building
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个图形界面用于测试构建
- en: Let’s now look at the process of writing a simple test.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下编写简单测试的过程。
- en: Important note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As k6 requires a test file to run, we have included the installation and usage
    instructions after these instructions on writing a test.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 k6 需要测试文件才能运行，我们在这些编写测试的说明后面加入了安装和使用说明。
- en: Writing a test using checks
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用检查编写测试
- en: 'Tests are written in k6 using JavaScript. A very simple test to submit a `GET`
    request to the `acme` website would look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是使用 JavaScript 在 k6 中编写的。一个非常简单的测试示例，向 `acme` 网站提交一个 `GET` 请求，可能是这样的：
- en: '[PRE0]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This script would just submit a request to the web page, but it would not validate
    that the request was successful. The `check` functionality would be used to confirm
    that this is the case, like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本仅仅会向网页提交请求，但不会验证请求是否成功。`check` 功能用于确认请求是否成功，如下所示：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `check()` function takes a value, an object containing the checks that will
    be run against the value, and an object containing any tags. If all the checks
    pass, then the function returns `true`; otherwise, it will return `false`. The
    `check` functionality makes it very simple to check for simple conditions in a
    script. It is common to want to check that an endpoint is meeting specific expectations,
    and k6 offers thresholds for this goal.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Writing a test using thresholds
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thresholds are checked against all requests made in the script, and it is good
    practice to use the **service-level objectives** (**SLOs**) set by the team as
    a starting point for testing. Here is an example of a threshold test:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This test would make a call to the `acme` website and check that the built-in
    `http_req_failed` and `http_req_duration` HTTP metrics meet the threshold expression
    specified. These metrics are collected from all the requests made in the script;
    in this case, there is only a single request made. If needed, it is possible to
    use **groups** and **tags** to evaluate HTTP requests independently.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to write basic scripted tests, let’s look at how we can
    use `options` to scale.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Adding scenarios to a test to run at scale
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we mentioned that the test would only make a single
    HTTP request. By using `options`, it is easy to manage the behavior of the default
    function in complex ways. Let’s consider a simple example in which we create 100
    VUs, and each VU will execute the default function repeatedly for 30 minutes:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You might notice that we are using the same `options` constant as we used when
    we created the test thresholds in the previous section. The `options` configuration
    option offers a lot of flexibility for defining the behavior of a test. It is
    a common requirement to share data with each of the VUs that will run the tests.
    Let’s have a look at how the test life cycle can manage these requirements.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Test life cycle
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four stages to the k6 test life cycle. These stages are explicitly
    set in the ordering of a test file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization code**: This is any code that appears at the top of the test
    script, before the setup code. It is run once per VU and is used to load files,
    import modules, configure the options used in the test, and for similar operations.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`export function setup() { }`'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`export default function (data) { }`'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`export function teardown (data) { }`'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have a good understanding of using k6 to run tests, we need to consider
    the different ways we can install and run k6.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Installing and running k6
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'k6 is available in several package formats:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Linux (`.rpm` and `.deb`)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerized image
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standalone binary for all platforms
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation is very simple on all platforms, and full instructions can be found
    on the k6 website at [https://k6.io/docs/get-started/installation/](https://k6.io/docs/get-started/installation/).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Running k6 is also very easy as all processes are triggered from the CLI. This
    is very well documented via the `--``help` flag:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 k6 也非常简单，因为所有过程都可以通过 CLI 启动。这一点通过 `--help` 标志得到了很好的文档说明：
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `k6 run` and `k6 cloud` operations are used to run tests locally or via
    the k6 cloud, respectively. Here are some example commands using a test file called
    `test.js`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`k6 run` 和 `k6 cloud` 操作分别用于本地运行测试或通过 k6 云运行测试。以下是使用名为 `test.js` 的测试文件的一些示例命令：'
- en: 'Run a single VU once:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行单个虚拟用户一次：
- en: '`k6` `run test.js`'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`k6` `run test.js`'
- en: 'Run 10 VUs with 20 iterations of the test being run across these VUs:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 10 个虚拟用户，并在这些虚拟用户中运行 20 次测试：
- en: '`k6 run -u 10 -i` `20 test.js`'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`k6 run -u 10 -i` `20 test.js`'
- en: 'Ramp VUs from `0` to `50` over 20 secs, maintain the `50` VU count for 60 secs,
    then ramp down to `0` over 10 secs:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 20 秒内将虚拟用户数（VU）从 `0` 增加到 `50`，保持 `50` VU 数量持续 60 秒，然后在 10 秒内将虚拟用户数降回 `0`：
- en: '`k6 run -u 0 -s 20s:50 -s 60s:50 -s` `10s:0 test.js`'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`k6 run -u 0 -s 20s:50 -s 60s:50 -s` `10s:0 test.js`'
- en: These commands could all have `k6 run` replaced with `k6 cloud` to use a k6
    cloud runner instead of running the tests from the local machine.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令中的 `k6 run` 都可以用 `k6 cloud` 替换，以使用 k6 云运行器，而不是从本地机器运行测试。
- en: Now that we’ve seen how to use k6 to perform load testing, let’s wrap up.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用 k6 执行负载测试，让我们总结一下。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have explored two of the tools that Grafana offers as part
    of its observability platform: Pyroscope and k6\. We learned how to search the
    profile data collected by Pyroscope and how to configure the client to collect
    that profile data. We also learned how to instrument applications, both using
    a native language SDK and using Lambda layers for serverless applications. Finally,
    we explored the new Pyroscope architecture and saw how it is very similar to Loki,
    Mimir, and Tempo. This new scalability should give Pyroscope the space to grow
    into a vital fourth telemetry type, making systems more observable.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Grafana 作为其可观察性平台的一部分提供的两个工具：Pyroscope 和 k6。我们学习了如何搜索 Pyroscope 收集的配置文件数据，以及如何配置客户端以收集这些配置文件数据。我们还学习了如何使用原生语言
    SDK 和 Lambda 层为无服务器应用程序对应用程序进行监控。最后，我们探索了新的 Pyroscope 架构，并看到它与 Loki、Mimir 和 Tempo
    非常相似。这种新的可扩展性应该为 Pyroscope 提供空间，发展成一个重要的第四种遥测类型，使系统更具可观察性。
- en: With k6, we learned about various types of load or performance tests. We saw
    how we can easily write tests using the JavaScript language, using checks and
    thresholds to articulate vital measures for an application. We saw how to use
    `options` to manage how k6 runs its tests, and how to add the correct data and
    functions to our scripts to best make use of the test life cycle. Finally, we
    saw the process for installing and running k6, and how the simple operation even
    allows us to run the tool as part of a CI/CD pipeline to continuously load test
    applications to validate that their performance is meeting SLOs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 k6，我们了解了各种类型的负载或性能测试。我们看到如何使用 JavaScript 语言编写测试，使用检查和阈值来表达应用程序的重要度量。我们了解了如何使用
    `options` 来管理 k6 运行测试的方式，以及如何在脚本中添加正确的数据和功能，以最好地利用测试生命周期。最后，我们了解了安装和运行 k6 的过程，以及简单的操作如何使我们能够将该工具作为
    CI/CD 流水线的一部分来连续进行负载测试，验证应用程序的性能是否符合 SLO。
- en: In the next chapter, we will bring together all of the tools, APIs, and knowledge
    to understand how to best support DevOps principles using Grafana.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将汇集所有工具、API 和知识，理解如何使用 Grafana 最好地支持 DevOps 原则。
