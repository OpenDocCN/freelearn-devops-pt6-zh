<html><head></head><body>
		<div id="_idContainer046">
			<h1 class="chapter-number" id="_idParaDest-52"><a id="_idTextAnchor051"/>3</h1>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Version Control and Integration with Git and GitHub</h1>
			<p>So far, our exploration has shed light on the foundational concepts of GitOps and its critical role in managing cloud-native operations. This journey has involved unpacking the principles, benefits, and transformative nature of GitOps in infrastructure management, as well as its capacity to enhance and streamline <span class="No-Break">cloud-native processes.</span></p>
			<p>This chapter will further expand on these concepts. It will delve into the significance of Git in <strong class="bold">version control</strong>, an essential component of modern software development. The chapter will also explore GitHub’s contribution to collaborative development and how it can be maximized for team efficiency. Additionally, it will discuss the integration of GitOps practices with Git and GitHub, highlighting automated <span class="No-Break">integration processes.</span></p>
			<p>The chapter outlines the best practices for utilizing Git and GitHub within a GitOps framework, aiming to enhance workflow efficiency and promote a strong <span class="No-Break">DevOps culture.</span></p>
			<p>In this chapter, we’ll focus on these <span class="No-Break">key areas:</span></p>
			<ul>
				<li>Version <span class="No-Break">control systems</span></li>
				<li><span class="No-Break">Why Git?</span></li>
				<li><span class="No-Break">Exploring GitHub</span></li>
				<li>Integrating GitOps <span class="No-Break">and GitHub</span></li>
			</ul>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Technical requirements</h1>
			<p>To fully engage with the concepts and practices presented in this chapter, there are a few technical requirements. You should have a basic understanding of software development processes and a familiarity with command-line tools. Access to a computer with internet connectivity is necessary to follow along with examples involving Git and GitHub. This hands-on approach will enable you to apply the theories and practices of GitOps in <span class="No-Break">real-world scenarios.</span></p>
			<p>The code for this chapter is available in the <strong class="source-inline">Chapter03</strong> folder of our GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes"><span class="No-Break">https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>Exploring version control systems – local, centralized, and distributed</h1>
			<p><strong class="bold">Version control systems</strong> (<strong class="bold">VCSs</strong>) are essential tools in modern software development, as they are responsible for enabling efficient management of changes to files, especially code. Git, a widely used VCS, exemplifies this by tracking modifications, allowing users to view and<a id="_idIndexMarker180"/> revert to specific versions of files as needed. This functionality is crucial for collaborative projects, where it provides a comprehensive record of who made changes, when, and why, enhancing accountability <span class="No-Break">and clarity.</span></p>
			<p>At its core, version control is about recording changes over time. This makes it easier to recover previous states of a project, whether for fixing bugs, testing, or undoing changes. It’s not limited to software code; version control can be applied to any file type, making it an asset for professionals such as graphic or web designers who might need to manage different versions of their work. The use of a VCS minimizes risks associated with file loss or errors, as it provides a safety net for easily reverting to earlier states and understanding the evolution of a project. This leads to increased efficiency and a more structured workflow with <span class="No-Break">minimal overhead.</span></p>
			<p>By integrating version control into their workflow, teams and individuals gain a powerful tool to navigate the complexities of project development, ensuring a smoother, more controlled process of continuous improvement <span class="No-Break">and collaboration.</span></p>
			<p>VCS can be categorized into three main types: local, centralized, <span class="No-Break">and distributed:</span></p>
			<ul>
				<li><strong class="bold">Local VCSs</strong> (<strong class="bold">LVCSs</strong>): These are the simplest <a id="_idIndexMarker181"/>forms. They involve keeping track of changes in files on a local computer, typically using<a id="_idIndexMarker182"/> a database that stores all the changes to files under revision control. This system is straightforward but has limitations, especially in the contexts of collaboration and data backup. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em> shows an example of LVCS on the <span class="No-Break">left side.</span></li>
				<li><strong class="bold">Centralized VCSs</strong> (<strong class="bold">CVCSs</strong>): These systems, such <a id="_idIndexMarker183"/>as <strong class="bold">Subversion</strong> (<strong class="bold">SVN</strong>), have a single server that contains all <a id="_idIndexMarker184"/>versioned files. Various clients check out files from this central place. This <a id="_idIndexMarker185"/>setup significantly enhances collaboration compared to LVCS, as everyone knows what everyone else is working on. However, the central server is also a single point of failure; if it goes down, no one can collaborate or save <span class="No-Break">versioned changes.</span></li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer032">
					<img alt="Figure 3.1 – An example of LCVS and CVCS" src="image/B22100_03_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – An example of LCVS and CVCS</p>
			<p class="callout-heading">Concurrent version systems and SVN</p>
			<p class="callout">The <strong class="bold">Concurrent Versions System</strong> (<strong class="bold">CVS</strong>) was an early version control system that enabled collaborative software development by allowing <a id="_idIndexMarker186"/>teams to work simultaneously on a project using a centralized repository. However, it had limitations, especially in handling binary files. It also lacked advanced features. SVN was developed as a modern alternative to CVS, addressing these shortcomings. SVN, also a centralized system, improved collaboration by allowing multiple users to work efficiently on a project with a centralized source for file changes, enhancing the tracking and management of changes made by different <span class="No-Break">team members.</span></p>
			<ul>
				<li><strong class="bold">Distributed VCSs</strong> (<strong class="bold">DVCSs</strong>): Systems such as Git fall into this category. Instead of a single central <a id="_idIndexMarker187"/>repository, each user has a <a id="_idIndexMarker188"/>complete copy of the entire repository. This approach allows for more complex workflows, increases redundancy and backup options, and enables offline work. It also allows for various forms of <strong class="bold">merging</strong> and <strong class="bold">branching</strong>, offering a more flexible approach to version control, especially for large-scale projects with <span class="No-Break">many contributors.</span></li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer033">
					<img alt="Figure 3.2 – An example of DVCS" src="image/B22100_03_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – An example of DVCS</p>
			<p>Having explored the landscape of VCSs—including LVCSs, CVCSs, and DVCSs, each offering distinct benefits and suited to specific project needs—it’s clear why Git stands out among DVCSs. Let’s delve deeper into the unique advantages and capabilities that make Git an essential tool in modern software development in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Why Git?</h1>
			<p>The story of Git begins with the developmental challenges of the Linux kernel project in the early 2000s. This period<a id="_idIndexMarker189"/> saw Linus Torvalds, the creator of Linux, facing a dilemma with the existing version control tools. The limitations and restrictions of the proprietary DVCS, BitKeeper, used by the Linux community at that time, led to the need for a new system. This spurred the creation of Git in 2005, marking a significant turn in the version control <span class="No-Break">system landscape.</span></p>
			<p>Git was designed with specific goals in mind, drawing from the lessons learned during the use of BitKeeper. Key among these were speed, simple design, and robust support for non-linear development. The system was tailored to handle large projects such as the Linux kernel efficiently both in terms of speed and data size. This focus on efficiency and flexibility was crucial given the scale and complexity of <span class="No-Break">such projects.</span></p>
			<p>The structure of Git is unique and effective. It is a distributed version control system, meaning that every user has the complete history of the project stored locally. This design not only enhances speed but also enables a more flexible and secure approach to version control. <strong class="bold">Repositories</strong> in Git are<a id="_idIndexMarker190"/> comprehensive, containing <strong class="bold">commits</strong>, which are essentially snapshots of the project at various stages, as well as references to these commits (known<a id="_idIndexMarker191"/> as <strong class="bold">heads</strong>). Over the years, Git has evolved and matured, retaining its initial qualities while becoming more user-friendly. Its integration with platforms such as GitHub (we will delve into more details about GitHub in the <em class="italic">Exploring GitHub</em> section of this chapter), <strong class="bold">Bitbucket</strong>, and <strong class="bold">GitLab</strong> has further amplified its capabilities, providing centralized hubs for collaboration, code sharing, and <span class="No-Break">project management.</span></p>
			<p>To illustrate the widespread adoption of Git, it’s worth noting that the GitHub community announced having surpassed 100 million developers on <span class="No-Break">their platform:</span></p>
			<p><a href="https://github.blog/2023-01-25-100-million-developers-and-counting/"><span class="No-Break">https://github.blog/2023-01-25-100-million-developers-and-counting/</span></a></p>
			<p>The adoption of Git in GitOps practices underscores its reliability and efficiency, making it a cornerstone in modern software development and <span class="No-Break">version control.</span></p>
			<p>Having understood the importance of Git from various perspectives, we will now shift our focus to a more practical approach. In the upcoming sections, we’ll begin with the basics of Git commands and examples to offer a <span class="No-Break">hands-on experience.</span></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Git setup</h2>
			<p>This chapter doesn’t cover the<a id="_idIndexMarker192"/> details of Git installation in depth, but you can find a thorough, step-by-step guide in the official Git documentation (refer to [1] in the <em class="italic">Further reading</em> section at the end of this chapter). For the purposes of our discussions, we’ll assume that Git is already<a id="_idIndexMarker193"/> installed on a <strong class="bold">Windows Subsystem for Linux</strong> (<strong class="bold">WSL</strong>) Ubuntu 22.04 distribution. It is important to underline that Git can be natively installed on Windows (without WSL), macOS, <span class="No-Break">and Linux.</span></p>
			<p>For additional information on setting up WSL, please refer to <a href="B22100_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, particularly the <em class="italic">Setup of WSL</em> section, which provides relevant guidance <span class="No-Break">and insights.</span></p>
			<p>To verify your Git installation, you can enter a specific command in your command prompt. This command will help you confirm that Git is properly installed and functioning on <span class="No-Break">your system:</span></p>
			<pre class="console">
$ git version</pre>			<p>The expected response should resemble <span class="No-Break">the following:</span></p>
			<pre class="source-code">
git version 2.45.1</pre>			<p>Great job! In the following sections, we will delve into the basics of Git, explore its commands, and examine the most interesting features that are essential <span class="No-Break">for GitOps.</span></p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Creating and cloning a Git repository</h2>
			<p>A Git repository is a cornerstone in the Git version control system, encompassing all project files and their <a id="_idIndexMarker194"/>revision histories. It’s marked by the <strong class="source-inline">.git</strong> directory containing necessary change-tracking data. Repositories exist either as local entities on a user’s<a id="_idIndexMarker195"/> computer or as remote versions on servers such as GitHub, enabling both individual work and collaborative efforts. They play a crucial role in project version management and evolution, storing files and histories as commits in a structured, linked-list format. This setup supports varied interactions such as <strong class="bold">cloning</strong> (creating a <a id="_idIndexMarker196"/>local copy of a repository from a remote server), <strong class="bold">branching</strong> (diverging from the <a id="_idIndexMarker197"/>main code base to create separate versions for development or testing without affecting the original code), and <strong class="bold">code version comparisons</strong> (examining <a id="_idIndexMarker198"/>the differences between various versions of code files to track changes or <span class="No-Break">merge updates).</span></p>
			<p>A Git repository can be started using <span class="No-Break">two commands:</span></p>
			<ul>
				<li><strong class="source-inline">git init</strong>: This <a id="_idIndexMarker199"/>command is used to initialize a new Git repository in a directory that is not currently under version control. Executing this command creates a hidden subfolder named <strong class="source-inline">.git</strong> in the directory, setting up the necessary structure for repository management and <span class="No-Break">version control.</span></li>
				<li><strong class="source-inline">git clone</strong>: This <a id="_idIndexMarker200"/>command is used to create a local copy of an existing Git repository, typically one that’s <a id="_idIndexMarker201"/>hosted remotely such as on GitHub. When you clone a repository, it <a id="_idIndexMarker202"/>downloads not only the project’s files but also its complete history and all branches into your local repository. This process ensures that you have the entire development history of the project at <span class="No-Break">your disposal.</span></li>
			</ul>
			<p>Open the command <a id="_idIndexMarker203"/>prompt and activate a WSL instance, as detailed in <a href="B22100_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, in the <em class="italic">Setup WSL</em> section, then follow <a id="_idIndexMarker204"/>the ensuing numbered steps to create and clone a <span class="No-Break">Git repository:</span></p>
			<ol>
				<li>Create a new directory <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">Chapter_3</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">$ mkdir Chapter_3</strong></pre></li>				<li>To set up <strong class="source-inline">Chapter_3</strong> as the current working directory, type <strong class="source-inline">cd Chapter_3</strong> into the <span class="No-Break">command prompt.</span></li>
				<li>Once in the <strong class="source-inline">Chapter_3</strong> directory, you are ready to initialize a new Git repository using the <strong class="source-inline">git init</strong> command. This step is crucial for starting version control in your new <span class="No-Break">project directory:</span><pre class="source-code">
<strong class="bold">$ git init</strong></pre><p class="list-inset">The output from the command should look something <span class="No-Break">like this:</span></p><pre class="source-code">hint: Using 'master' as the name for the initial branch. This default branch name
hint: is subject to change. To configure the initial branch name to use in all
…
hint:   git branch -m &lt;name&gt;
Initialized empty Git repository in /home/pietro/Chapter_3/.git/</pre></li>				<li>By listing the contents of the <a id="_idIndexMarker205"/>working directory using the <strong class="source-inline">ls -a</strong> command, you should be able to see<a id="_idIndexMarker206"/> the newly created <strong class="source-inline">.git</strong> hidden directory. This directory is an indication that the Git repository has been <span class="No-Break">successfully initialized:</span><pre class="source-code">
<strong class="bold">$ ls -a</strong></pre><p class="list-inset">The response to this command should resemble the <span class="No-Break">following output:</span></p><pre class="source-code">.  ..  .git</pre></li>				<li>To list the contents and subfolder structure of the <strong class="source-inline">.git</strong> directory, you can use the <strong class="source-inline">ls -a ./.git</strong> command. This will display all the files and subdirectories within the <strong class="source-inline">.git</strong> directory, providing insight into the structure of the initialized <span class="No-Break">Git repository:</span><pre class="source-code">
<strong class="bold">$ ls -a ./git</strong></pre><p class="list-inset">The output should look like <span class="No-Break">the following:</span></p><pre class="source-code">.  ..  HEAD  branches  config  description  hooks  info  objects  refs</pre></li>				<li>To initialize a repository by cloning it, you should first navigate to a different directory. Once there, execute the clone command with the appropriate URL to create a copy of an existing Git repository in that new location. This process will replicate the repository, including its history and branches, into your <span class="No-Break">specified directory:</span><pre class="source-code">
<strong class="bold">$ git clone https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes</strong></pre><p class="list-inset">The output from the command should look something <span class="No-Break">like this:</span></p><pre class="source-code">Cloning into 'Implementing-GitOps-with-Kubernetes'...
remote: Enumerating objects: 151, done.
remote: Compressing objects: 100% (94/94), done.
...
Resolving deltas: 100% (32/32), done.</pre></li>			</ol>
			<p>We have now learned how to <a id="_idIndexMarker207"/>create a new repository from scratch or by cloning an <a id="_idIndexMarker208"/>existing one. Next, we’ll focus on understanding and using basic Git commands to start recording changes in our repository. This step is crucial for managing and tracking the evolution of your <span class="No-Break">project files.</span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>The basics of Git</h2>
			<p>Understanding the basics <a id="_idIndexMarker209"/>of Git involves familiarizing yourself with a set of fundamental commands that facilitate version control in software development. These commands enable you to track and manage changes to your project’s files, offering control over every aspect of its evolution. From staging and committing changes to managing branches and updating your project with the latest developments, mastering these commands is essential for the effective use of Git. This introductory overview will guide you through key commands such as <strong class="source-inline">git status</strong>, <strong class="source-inline">git add</strong>, <strong class="source-inline">git commit</strong>, <strong class="source-inline">git branch</strong>, <strong class="source-inline">git merge</strong>, <strong class="source-inline">git pull</strong>, and <strong class="source-inline">git push</strong>, each playing a critical role in the <span class="No-Break">Git workflow:</span></p>
			<ul>
				<li><strong class="source-inline">git status</strong>: This<a id="_idIndexMarker210"/> command shows the status of changes, indicating whether they are untracked, modified, <span class="No-Break">or staged.</span></li>
				<li><strong class="source-inline">git add</strong>: This <a id="_idIndexMarker211"/>command stages changes for inclusion in your project’s history. It prepares the changes for the next step, allowing you to control what becomes part of the <span class="No-Break">project’s history.</span></li>
				<li><strong class="source-inline">git commit</strong>: This<a id="_idIndexMarker212"/> command saves the staged changes to the project’s history, functioning like capturing a snapshot. It finalizes what you have staged with <span class="No-Break"><strong class="source-inline">git add</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">git branch</strong>: Use <a id="_idIndexMarker213"/>this to view the branches being worked on locally, giving insight into the various lines <span class="No-Break">of development.</span></li>
				<li><strong class="source-inline">git merge</strong>: This merges <a id="_idIndexMarker214"/>different lines of development and is commonly used to integrate changes from one branch into another (e.g., merging a <strong class="source-inline">feature</strong> branch into the <span class="No-Break"><strong class="source-inline">master</strong></span><span class="No-Break"> branch).</span></li>
				<li><strong class="source-inline">git fetch</strong>: This<a id="_idIndexMarker215"/> command updates your local database of changes from a remote repository, which is useful for reviewing updates before integrating them into your <span class="No-Break">local branch.</span></li>
				<li><strong class="source-inline">git pull</strong>: This<a id="_idIndexMarker216"/> updates your local development line with changes from its remote counterpart. It is useful when you need to reflect changes made by others in your <span class="No-Break">local </span><span class="No-Break"><a id="_idIndexMarker217"/></span><span class="No-Break">environment.</span></li>
				<li><strong class="source-inline">git push</strong>: This<a id="_idIndexMarker218"/> updates the remote repository with commits made locally, ensuring that the remote repository reflects your <span class="No-Break">recent changes.</span></li>
			</ul>
			<h3>A basic Git commit-status-push loop example</h3>
			<p>Let’s start with a practical example of how to use Git locally using the commands listed in the <em class="italic">The basics of Git</em> section. You are<a id="_idIndexMarker219"/> free to use the repository initialized in the <em class="italic">Creating and cloning a Git repository</em> section of this chapter or to start with a <span class="No-Break">new one:</span></p>
			<ol>
				<li>Set up a <span class="No-Break">GIT identity:</span><pre class="source-code">
<strong class="bold">$ git config --global user.email "you@example.com"</strong>
<strong class="bold">$ git config --global user.name "Your Name"</strong></pre></li>				<li>Use the <strong class="source-inline">git status</strong> command to see the current state of your files, whether they are untracked, modified, or ready to <span class="No-Break">be committed:</span><pre class="source-code">
<strong class="bold">$ git status</strong></pre><p class="list-inset">The response to this command should look something <span class="No-Break">like this:</span></p><pre class="source-code">On branch master
No commits yet
nothing to commit (create/copy files and use "git add" to track)</pre><p class="list-inset">This indicates that your working directory is clean, meaning that no tracked files have been modified and no untracked files are present. Additionally, it confirms that you’re on a specific branch (<strong class="source-inline">master</strong>) that hasn’t diverged from its <span class="No-Break">remote counterpart.</span></p></li>				<li>Create a new non-empty file in the <span class="No-Break">working directory:</span><pre class="source-code">
<strong class="bold">$ echo 'The content of this file will be committed.' &gt; README</strong></pre><p class="list-inset">The preceding command will create a new non-empty <strong class="source-inline">README</strong> file in the current <span class="No-Break">working directory.</span></p></li>				<li>Execute the <strong class="source-inline">git status</strong> <span class="No-Break">command again:</span><pre class="source-code">
<strong class="bold">On branch master</strong>
<strong class="bold">No commits yet</strong>
<strong class="bold">Untracked files:</strong>
<strong class="bold">   (use "git add &lt;file&gt;..." to include in what will be committed)</strong>
<strong class="bold">       README</strong>
<strong class="bold">nothing added to commit but untracked files present (use "git add" to track)</strong></pre><p class="list-inset">The <strong class="source-inline">README</strong> file<a id="_idIndexMarker220"/> appears with the <strong class="source-inline">untracked</strong> status because Git recognizes it as a file that is not present in the last commit and that hasn’t been prepared for inclusion in future commits. The <strong class="source-inline">untracked</strong> status prevents Git from automatically adding files that might not be intended for version control, such as binary files. To include the <strong class="source-inline">README</strong> file in your project’s version history, you need to explicitly track it with Git, ensuring it’s considered for subsequent <span class="No-Break">commit snapshots.</span></p></li>				<li>To track modifications, to add the new file, use the <strong class="source-inline">git </strong><span class="No-Break"><strong class="source-inline">add</strong></span><span class="No-Break"> command:</span><pre class="source-code">
<strong class="bold">$ git add README</strong></pre></li>				<li>Execute the <strong class="source-inline">git status</strong> <span class="No-Break">command again:</span><pre class="source-code">
<strong class="bold">On branch master</strong>
<strong class="bold">No commits yet</strong>
<strong class="bold">Changes to be committed:</strong>
<strong class="bold">(use "git rm --cached &lt;file&gt;..." to unstage)</strong>
<strong class="bold">        new file:   README</strong></pre><p class="list-inset"><strong class="source-inline">README</strong> is now marked as <strong class="source-inline">staged</strong> because it appears under the <strong class="source-inline">Changes to be committed</strong> section, indicating that it’s ready for the <span class="No-Break">next commit.</span></p></li>				<li>With our staging area<a id="_idIndexMarker221"/> prepared as desired, it’s now time to record our changes in the repository’s history using <strong class="source-inline">git commit -m "Add the README file"</strong>, whereby we specify the modifications that <span class="No-Break">we’ve implemented:</span><pre class="source-code">
<strong class="bold">$ git commit -m "Add the README file."</strong></pre><p class="list-inset">The output from the <strong class="source-inline">git commit</strong> command should be like <span class="No-Break">the following:</span></p><pre class="source-code">[master (root-commit) f933b54] Add the README file.
 1 file changed, 1 insertion(+)
 create mode 100644 README</pre><p class="list-inset">Whenever you add, modify, or delete one or more files (or non-empty folders), you’ll need to repeat <em class="italic">steps 5</em> and <em class="italic">7</em> to ensure that those changes are properly staged <span class="No-Break">and committed.</span></p></li>			</ol>
			<h3>Git workflows</h3>
			<p>The basic Git workflow involves a <a id="_idIndexMarker222"/>strategic approach to branching that facilitates efficient development and release processes. This strategy includes different types <span class="No-Break">of branches:</span></p>
			<ul>
				<li><strong class="source-inline">Main (or Master)</strong>: The foundational branch where production-ready code is maintained throughout the project’s <span class="No-Break">life cycle</span></li>
				<li><strong class="source-inline">Develop</strong>: Initiated alongside the main branch, it houses pre-production code and features <span class="No-Break">under testing</span></li>
				<li><strong class="source-inline">Feature</strong>: Employed for developing new features, these branches merge back into the <strong class="source-inline">develop</strong> branch <span class="No-Break">upon completion</span></li>
				<li><strong class="source-inline">Release</strong>: Dedicated to preparing code for <span class="No-Break">production release</span></li>
				<li><strong class="source-inline">Hotfix</strong>: Addresses urgent fixes directly in the <span class="No-Break">main branch</span></li>
			</ul>
			<p>In this workflow, changes are tracked as commits. They document the history of file modifications, including what changed, who changed it, and when. This structure not only organizes work effectively but also accelerates the release cycle by clearly defining the purpose of each branch and streamlining the integration of new features, bug fixes, and releases. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.3</em> illustrates an example of a <span class="No-Break">Git workflow.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer034">
					<img alt="Figure 3.3 – An example of a Git workflow" src="image/B22100_03_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – An example of a Git workflow</p>
			<p>Initially, the content of a repository resides in a default branch. For making modifications or additions, it’s recommended to create and work within your own branch. This practice ensures that the main code base remains stable while you develop features or fixes. Delving <a id="_idIndexMarker223"/>deeply into the intricacies of Git, including branching, merging, and remote strategies, exceeds the scope of this book. However, for those seeking an in-depth exploration, Mastering Git by PACKT, <em class="italic">[3]</em> in the <em class="italic">Further reading</em> section, offers comprehensive insights into advanced Git concepts. It’s an excellent resource for expanding your Git knowledge beyond <span class="No-Break">the basics.</span></p>
			<p>This section concludes our brief exploration of Git, marking the beginning of our journey into GitHub. The upcoming section will introduce and delve into GitHub, presenting its significance and utility in the world <span class="No-Break">of GitOps.</span></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Exploring GitHub</h1>
			<p>GitHub is a vital platform in the world of software development, serving as a hub for collaborative projects using Git. It extends the functionality of Git by providing a web-based graphical interface. GitHub facilitates the hosting of both public and private repositories, making it easier for<a id="_idIndexMarker224"/> individuals and teams to collaborate on projects regardless of their geographical location. Its importance lies not just in code storage but also in fostering a community where developers can share, contribute to, and build upon each other’s work, enhancing the open source <span class="No-Break">development culture.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Creating a GitHub account is essential for storing source code on this widely used platform. This book will guide you through using GitHub to manage code in public and private repositories. Detailed instructions for account creation are available on GitHub’s website, where you can find all the information needed to get <span class="No-Break">started (</span><a href="https://github.com/"><span class="No-Break">https://github.com/</span></a><span class="No-Break"><span class="P---URL">)</span></span><span class="No-Break">.</span></p>
			<p class="callout">SSH access offers a secure way to interact with Git repositories, bypassing the need for entering a username and password with each command. It’s particularly useful for cloning public projects without an account. For forking or pushing changes, however, an account is necessary. For detailed setup instructions, refer to GitHub’s official SSH access <span class="No-Break">guide (</span><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh"><span class="No-Break">https://docs.github.com/en/authentication/connecting-to-github-with-ssh</span></a><span class="No-Break">).</span></p>
			<p>GitHub significantly enhances collaborative software development by enabling remote teamwork and streamlining processes such as bug tracking and continuous integration. Its pull request system bolsters collaboration, facilitating code review and merging. Moreover, GitHub serves as a comprehensive code hosting platform, supporting both public and private repositories, thus bolstering both open source and private projects. This accessibility and integration with development tools makes GitHub indispensable for <span class="No-Break">developers worldwide.</span></p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>GitHub’s ecosystem</h2>
			<p>The GitHub ecosystem is a comprehensive and dynamic environment that extends beyond simple code hosting. It encompasses a wide range of tools, integrations, community features, and<a id="_idIndexMarker225"/> services that support the entire software development life cycle. This includes project management tools, issue tracking, continuous integration and deployment services, and code review facilities. Additionally, GitHub offers a vast community and network of developers contributing to open source projects, sharing insights, and collaborating on various initiatives. This ecosystem has become an integral part of the software development world, fostering innovation and collaboration among <span class="No-Break">developers globally:</span></p>
			<ul>
				<li><strong class="bold">Version control</strong>: At its core, GitHub offers Git-based version control for managing and tracking <span class="No-Break">code changes</span></li>
				<li><strong class="bold">Issue tracking</strong>: It includes tools for reporting and tracking bugs, feature requests, and tasks <span class="No-Break">within projects</span></li>
				<li><strong class="bold">Collaboration features</strong>: Features such as pull requests and code reviews facilitate collaborative coding and <span class="No-Break">team interaction</span></li>
				<li><strong class="bold">GitHub actions</strong>: For automation of <a id="_idIndexMarker226"/>workflows, such as <strong class="bold">Continuous Integration and Continuous </strong><span class="No-Break"><strong class="bold">Deployment </strong></span><span class="No-Break">(</span><span class="No-Break"><strong class="bold">CI/CD</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Project management</strong>: Tools for organizing and prioritizing work, such as Projects and <span class="No-Break">Kanban boards</span></li>
				<li><strong class="bold">Community and networking</strong>: A platform for developers to contribute to open source projects, network, <span class="No-Break">and collaborate</span></li>
				<li><strong class="bold">Marketplace</strong>: Offers third-party apps and integrations to extend <span class="No-Break">GitHub functionality</span></li>
				<li><strong class="bold">GitHub Pages</strong>: Provides hosting for static websites and documentation directly from a <span class="No-Break">GitHub repository</span></li>
				<li><strong class="bold">Security Features</strong>: Includes features for vulnerability scanning and managing <span class="No-Break">access controls</span></li>
			</ul>
			<p>Having gained an understanding of what GitHub is and how to access it, it’s time to shift our focus toward <span class="No-Break">practical applications.</span></p>
			<p>GitHub enhances the software development process by integrating tools for better code quality, such as command line operations, issue discussions, pull requests, and code reviews, alongside a vast array of apps available in the <span class="No-Break">GitHub Marketplace.</span></p>
			<p>It fosters collaboration<a id="_idIndexMarker227"/> through the GitHub flow, enabling developers to efficiently manage work within repositories, outline project directions, and seamlessly merge updates after thorough discussion and agreement. It thereby transforms the conventional methodologies of <span class="No-Break">software construction.</span></p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>GitHub flow</h2>
			<p>The GitHub flow is a<a id="_idIndexMarker228"/> branch-based workflow integrating Git commands for global teams. It involves creating branches for parallel development, adding commits for reversible project points, and using pull requests to foster transparency (see the <em class="italic">Git workflow</em> section in this chapter). Code review is central, thereby promoting an open culture. Merging incorporates changes seamlessly, while deployment ensures robust code. This workflow adapts to various collaboration scales, from small teams to global contributions, emphasizing pull requests for discussion and integration. GitHub’s tools replace traditional email reviews, streamlining the development process. We can summarize the GitHub Flow in the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Create a repository. The first thing to do is to create a repository in our GitHub space. In the upper corner of any page of each GitHub space, click on <strong class="bold">+</strong> and then on <strong class="bold">New Repository</strong>, as shown in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer035">
					<img alt="Figure 3.4 – Creating a new GitHub repository" src="image/B22100_03_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Creating a new GitHub repository</p>
			<p class="list-inset">For the repository name, you could choose something such as <strong class="source-inline">gitops-for-k8s-gitops-integration</strong>. <strong class="bold">Description</strong> is optional. Decide between a private or public repository based on your preference for open access or restricted visibility. Ensure that you check the <strong class="bold">Add a README file</strong> checkbox and then proceed by<a id="_idIndexMarker229"/> clicking the <strong class="bold">Create repository</strong> button, as illustrated in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer036">
					<img alt="Figure 3.5 – The form for creating a new repository on GitHub" src="image/B22100_03_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – The form for creating a new repository on GitHub</p>
			<ol>
				<li value="2">Create a branch. By default, the created repository has one branch named <strong class="source-inline">main</strong> that is considered the one containing production-ready code. Best practices suggest using a different <strong class="source-inline">feature</strong> branch for each feature that we want to implement. To create a new branch in GitHub, click the <strong class="bold">Code</strong> tab of the repository that you created in the preceding step, then click the dropdown menu containing the <strong class="source-inline">main</strong> item, as shown in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.6</em>. To create the new branch, click on <strong class="bold">Create branch features/docker-file-and-ci</strong>, as highlighted in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer037">
					<img alt="Figure 3.6 – Creating a new features/docker-file-and-ci feature branch" src="image/B22100_03_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Creating a new features/docker-file-and-ci feature branch</p>
			<ol>
				<li value="3">Add commits. It’s time to<a id="_idIndexMarker230"/> add some useful files to our repository. For this exercise, we will use the same Docker file seen in the <em class="italic">Dockerfile</em> section of <a href="B22100_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic">Chapter 2</em></span></a> of this book. To add a Docker file, click the <strong class="bold">Add file</strong> button (see <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.7</em>). If you opt for <strong class="bold">Create new file</strong>, an editor will open where you can paste the Docker file contents and commit. Alternatively, selecting <strong class="bold">Upload files</strong> allows you to directly upload the Docker file from <span class="No-Break">your computer.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer038">
					<img alt="Figure 3.7 – Menu for adding a new file or uploading an existing one" src="image/B22100_03_07.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Menu for adding a new file or uploading an existing one</p>
			<ol>
				<li value="4">Copy the content of the Docker file and call the file <strong class="source-inline">dockerfile</strong>, as illustrated in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.8</em>. Click on <strong class="bold">Commit changes</strong> and accept the suggested commit message and options. Repeat the operations for the <strong class="source-inline">requirements.txt</strong> file used in the <em class="italic">Dockerfile</em> section of <a href="B22100_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer039">
					<img alt="Figure 3.8 – The GitHub editor interface for editing a repository file" src="image/B22100_03_08.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – The GitHub editor interface for editing a repository file</p>
			<ol>
				<li value="5">Adopt best practices for commit messages by specifying the action taken, such as <strong class="bold">Add file</strong> or <strong class="bold">Remove API</strong>. Use <strong class="source-inline">Create dockerfile</strong> as a suggested description and commit your changes. On the main page, select the <strong class="bold">Edit File</strong> icon for the <strong class="source-inline">README</strong> file and <a id="_idIndexMarker231"/>add the following line at the beginning, then commit the changes with the <span class="No-Break">default description:</span><pre class="source-code">
## This repository will be used to show GitOps and GitHub capabilities</pre><p class="list-inset">See <em class="italic">[2]</em> in the <em class="italic">Further reading</em> section for a useful list of commit <span class="No-Break">best practices.</span></p></li>				<li>Open a pull request. After making changes in a branch off the <strong class="source-inline">main</strong> branch, you can initiate a pull request, which is a core element for collaboration in GitHub. This feature allows you to suggest changes, seek a review to merge your contributions into another branch, and highlight differences in color. You can start a discussion with a pull request immediately after committing, even if the code isn’t final. Practicing this with a pull request in your repository by merging it yourself is an excellent way to familiarize yourself with GitHub’s collaborative flow before moving on to <span class="No-Break">bigger projects.</span></li>
				<li>From the repository’s tab, click on the <strong class="bold">Pull requests</strong> tab of our repository and click on <strong class="bold">New Pull request</strong>. In the <strong class="bold">Example Comparison</strong> box, select the <strong class="bold">features/dockerfile-and-ci </strong>branch to compare with the <strong class="bold">main</strong> branch as illustrated in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.9</em>, then click on the <strong class="bold">Create pull </strong><span class="No-Break"><strong class="bold">request</strong></span><span class="No-Break"> button.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer040">
					<img alt="Figure 3.9 – Creating a pull request and select which branches to compare" src="image/B22100_03_09.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Creating a pull request and select which branches to compare</p>
			<ol>
				<li value="8">Review the changes in the comparison view at the bottom of the page. If they accurately reflect your intended modifications, proceed to create a pull request. Assign a title to your pull request and include a concise description of your changes, such as detailing the addition of a Docker file and the automation of Docker image builds with <a id="_idIndexMarker232"/>GitHub Actions. Feel free to enhance your description with emojis, images, or GIFs, and then finalize it by creating the <span class="No-Break">pull request.</span></li>
				<li>Discuss and review the code. Starting collaboration involves seeking reviews from your peers on pull requests. This step enables collaborators to offer feedback or suggest edits before finalizing changes to the <strong class="source-inline">main</strong> branch, ensuring a consensus-driven approach to <span class="No-Break">code integration.</span></li>
				<li>In the final step, merge your <strong class="source-inline">features/dockerfile-and-ci</strong> branch into the <strong class="source-inline">main</strong> branch to add your updates. Should any conflicts between your pull request and the <strong class="source-inline">main</strong> branch emerge, GitHub will prompt you to resolve them prior to merging. Assuming that there are no conflicts, the merge should be straightforward. To complete the process, select <strong class="bold">Merge pull request</strong> at the bottom of the pull request page. Confirm the merge. A notification that mentions a successful merge and request closure will appear. Lastly, delete the branch for cleanup and return to the repository’s <strong class="bold">Code</strong> tab to view your changes in the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> branch.</span></li>
			</ol>
			<p>We’ve introduced the fundamentals of GitHub and GitFlow alongside a hands-on example. We encourage you to practice using Git command line tools for cloning repositories, as outlined in the <em class="italic">Git repository</em> section of this chapter. Armed with this essential knowledge, we’re <a id="_idIndexMarker233"/>poised to delve into integrating GitOps with GitHub, specifically for automating Docker deployments <span class="No-Break">with commits.</span></p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Integrating GitOps and GitHub</h1>
			<p>GitHub Actions offers a<a id="_idIndexMarker234"/> powerful automation tool within the GitHub ecosystem, enabling developers to streamline their software development workflows. Specifically, a GitHub Action can significantly enhance a GitOps workflow by automating the<a id="_idIndexMarker235"/> building and pushing of Docker images for services, followed by the deployment of new versions to Kubernetes clusters. This capability simplifies the CI/CD processes, making it easier for teams to maintain and update their applications efficiently in a <span class="No-Break">cloud-native environment.</span></p>
			<p>Best practices suggest that when you want to use this GitHub Action, your GitHub repository should have a <strong class="source-inline">dev</strong> and a <strong class="source-inline">master</strong> or <strong class="source-inline">main</strong> branch, and that it should use tags for releases. In the following example, for brevity, we will work directly in the <strong class="source-inline">main</strong> branch. Best practices suggest working in <span class="No-Break">separate branches.</span></p>
			<p>Here are the steps to automate Docker image creation with <span class="No-Break">GitHub Actions:</span></p>
			<ol>
				<li>Click on <strong class="bold">Actions</strong> in the repository’s tab, as shown in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer041">
					<img alt="Figure 3.10 – The tab menu with the Actions button circled" src="image/B22100_03_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – The tab menu with the Actions button circled</p>
			<ol>
				<li value="2">On the new page, click on <strong class="bold">set up a workflow yourself</strong>, as shown in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer042">
					<img alt="Figure 3.11 – Manually defining a workflow in GitHub" src="image/B22100_03_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Manually defining a workflow in GitHub</p>
			<ol>
				<li value="3">In the editor, add<a id="_idIndexMarker236"/> the <span class="No-Break">following content:</span><pre class="source-code">
name: Create Docker Image CI
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4.1.1
    - name: Build the Docker image
      run: docker build . --file dockerfile --tag my-image-name:$(date +%s)</pre><p class="list-inset">The <strong class="source-inline">name</strong> field serves as the identifier for our action. In the <strong class="source-inline">on</strong> section, we specify the events that will trigger this action, primarily focusing on specific branches. This is usually <a id="_idIndexMarker237"/>set to <strong class="source-inline">main</strong>. If you happen to create a new branch and want to trigger this action, you’ll need to modify this <span class="No-Break">section accordingly.</span></p><p class="list-inset">Within the <strong class="source-inline">jobs</strong> | <strong class="source-inline">build</strong> section, you’ll find the <strong class="source-inline">runs-on</strong> field, which specifies the type of GitHub servers that our job will run on. This is distinct from the version of our Docker image, which is determined by <strong class="source-inline">Dockerfile</strong>. In this case, our Docker image will be based on Ubuntu 20.04. The Docker image build will take place on GitHub servers <span class="No-Break">running </span><span class="No-Break"><strong class="bold">ubuntu-latest</strong></span><span class="No-Break">.</span></p><p class="list-inset">Now, let’s move on to the <a id="_idIndexMarker238"/>action steps. The <strong class="source-inline">uses</strong> field instructs the workflow to perform a checkout<a id="_idIndexMarker239"/> of our repository. The <strong class="source-inline">name</strong> field provides a label for the step. Finally, the <strong class="source-inline">run</strong> field specifies the command to execute. With this configuration, we are prepared for our first build on the Ubuntu 20.04-based <span class="No-Break">Docker image.</span></p></li>				<li>To initiate a new build, we need to introduce a modification to our <strong class="source-inline">main</strong> branch. You can easily accomplish this by making a simple comment change to the Docker file within the integrated editor on GitHub or editing the <strong class="source-inline">README</strong> file. In <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.12</em>, the build is triggered from an update <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">README</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer043">
					<img alt="Figure 3.12 – A list of workflows triggered by commits on the Actions page" src="image/B22100_03_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – A list of workflows triggered by commits on the Actions page</p>
			<p class="list-inset">Once you’ve made the change in your repository, GitHub will automatically detect it and initiate a new build. You’ll notice an indicator signaling that the build has <span class="No-Break">been triggered.</span></p>
			<ol>
				<li value="5">To access the build logs, simply click on <strong class="bold">build</strong>, as illustrated in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.13</em>. This will lead you to the dedicated page for that build. Once on this page, you can delve into the individual steps of the build process and review the logs associated with each step, as illustrated in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.14</em>. GitHub also provides email notifications in case of <a id="_idIndexMarker240"/>build failures, and you can conveniently configure your alerting preferences <a id="_idIndexMarker241"/>within the <span class="No-Break">GitHub platform.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer044">
					<img alt="Figure 3.13 – A summary of a successful build" src="image/B22100_03_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – A summary of a successful build</p>
			<div>
				<div class="IMG---Figure" id="_idContainer045">
					<img alt="Figure 3.14 – Detailed steps of the build process with logs for each step" src="image/B22100_03_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Detailed steps of the build process with logs for each step</p>
			<p>At this stage, you should have a <a id="_idIndexMarker242"/>comprehensive understanding of Git, GitFlow, GitHub, and how to develop a <a id="_idIndexMarker243"/>CI process that builds a Docker image for <span class="No-Break">each commit.</span></p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>Summary</h1>
			<p>This chapter delved into the essential role of Git for version control and GitHub for collaborative software development within the GitOps framework. It outlined the significance of these tools in enhancing team efficiency, automating deployment processes, and fostering a robust DevOps culture. Key areas covered include the technical requirements for engaging with Git and GitHub, the benefits of VCSs, the functionalities of Git and GitHub, and the integration of GitOps practices. The chapter concluded with some best practices for utilizing Git and GitHub to streamline <span class="No-Break">workflow efficiency.</span></p>
			<p>In the upcoming chapters, we will explore additional tools such as Argo CD and Flux CD, along with their integration into GitOps, enabling us to complete our pipeline with the <span class="No-Break">deployment segment.</span></p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Further reading</h1>
			<ul>
				<li>[<span class="No-Break">1] </span><a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git"><span class="No-Break">https://git-scm.com/book/en/v2/Getting-Started-Installing-Git</span></a></li>
				<li>[<span class="No-Break">2] </span><a href="https://gist.github.com/luismts/495d982e8c5b1a0ced4a57cf3d93cf60"><span class="No-Break">https://gist.github.com/luismts/495d982e8c5b1a0ced4a57cf3d93cf60</span></a></li>
				<li>[<span class="No-Break">3] </span><a href="https://www.packtpub.com/product/mastering-git/9781783553754"><span class="No-Break">https://www.packtpub.com/product/mastering-git/9781783553754</span></a></li>
			</ul>
		</div>
	</body></html>