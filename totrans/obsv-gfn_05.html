<html><head></head><body>
		<div id="_idContainer079">
			<h1 id="_idParaDest-104" class="chapter-number"><a id="_idTextAnchor106"/>5</h1>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor107"/>Monitoring with Metrics Using Grafana Mimir and Prometheus</h1>
			<p>This chapter will introduce the <strong class="bold">Prometheus query language</strong> (<strong class="bold">PromQL</strong>). Like<a id="_idIndexMarker434"/> LogQL, PromQL<a id="_idIndexMarker435"/> can be used to select and filter metrics streams and process numeric data with operators and functions, enabling you to build quick and efficient queries that will support establishing an observable system. We will also explore and compare the various protocols that can be used to output metrics from systems. Finally, we will explore the architecture<a id="_idIndexMarker436"/> of <strong class="bold">Prometheus</strong> and <strong class="bold">Mimir</strong> to understand how Mimir fills the <a id="_idIndexMarker437"/>need for a highly <span class="No-Break">scalable system.</span></p>
			<p>We will cover the following main topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Updating the OpenTelemetry collector <span class="No-Break">for metrics</span></li>
				<li><span class="No-Break">Introducing PromQL</span></li>
				<li>Exploring data collection and <span class="No-Break">metric protocols</span></li>
				<li>Understanding data <span class="No-Break">storage architectures</span></li>
				<li>Using exemplars <span class="No-Break">in Grafana</span></li>
			</ul>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor108"/>Technical requirements</h1>
			<p>In this chapter, you will need <span class="No-Break">the following:</span></p>
			<ul>
				<li>The OpenTelemetry demo application set up in <a href="B18277_03.xhtml#_idTextAnchor063"><span class="No-Break"><em class="italic">Chapter 3</em></span></a></li>
				<li>The Grafana Cloud instance set up in <a href="B18277_03.xhtml#_idTextAnchor063"><span class="No-Break"><em class="italic">Chapter 3</em></span></a></li>
				<li>Docker <span class="No-Break">and Kubernetes</span></li>
			</ul>
			<p>You'll find the code for this chapter in the GitHub repository at <a href="https://github.com/PacktPublishing/Observability-with-Grafana/tree/main/chapter5">https://github.com/PacktPublishing/Observability-with-Grafana/tree/main/chapter5</a>. You'll find the <em class="italic">Code in Action</em> videos for this chapter at <a href="https://packt.link/A2g91">https://packt.link/A2g91</a>.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor109"/>Updating the OpenTelemetry demo application</h1>
			<p>For <a id="_idIndexMarker438"/>this chapter, we have prepared an updated version of <strong class="source-inline">OTEL-Collector.yaml</strong>, which will add additional labels to metrics for you to explore. Full details on this process are available from the Git repository in the <strong class="source-inline">README.md</strong> file. This process will apply the new version of the collector configuration to your <span class="No-Break">demo application:</span></p>
			<ol>
				<li>Using Helm, we will apply the updated configuration file to our <span class="No-Break">Kubernetes cluster:</span><pre class="source-code">
<strong class="bold">$ helm upgrade --version '0.73.1' --values chapter5/OTEL-Collector.yaml --values OTEL-Creds.yaml owg open-telemetry/opentelemetry-collector</strong>
<strong class="bold">NAME: owg-otel-collector</strong>
<strong class="bold">LAST DEPLOYED: Sun Mon 19 12:42:36 2023</strong>
<strong class="bold">NAMESPACE: default</strong>
<strong class="bold">STATUS: deployed</strong>
<strong class="bold">REVISION: 2</strong>
<strong class="bold">…</strong></pre></li>				<li>Validate upgrade <span class="No-Break">was successful:</span><pre class="source-code">
<strong class="bold">$ kubectl get pods --selector=component=standalone-collector</strong>
<strong class="bold">NAME  READY   STATUS    RESTARTS   AGE</strong>
<strong class="bold">owg-otel-collector-594fddd656-tfstk   1/1     Terminating   1 (70s ago)   2m8s</strong>
<strong class="bold">owg-otel-collector-7b7fb876bd-vxgwg   1/1     Running       0             3s</strong></pre></li>			</ol>
			<p>This new<a id="_idIndexMarker439"/> configuration adds the collection of metrics from the Kubernetes cluster and the OpenTelemetry collector. The configuration also does some <span class="No-Break">necessary relabeling.</span></p>
			<p>Now that we are collecting more data from our local demo application, let’s introduce the language used to query <span class="No-Break">that data.</span></p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor110"/>Introducing PromQL</h1>
			<p><strong class="bold">Prometheus</strong> was <a id="_idIndexMarker440"/>initially developed by SoundCloud in 2012; the project was accepted by the <em class="italic">Cloud Native Computing Foundation</em> in 2016 as the second incubated project (after Kubernetes), and version 1.0 was released shortly after. PromQL<a id="_idIndexMarker441"/> is an integral part of Prometheus, which is used to query stored data and produce dashboards <span class="No-Break">and alerts.</span></p>
			<p>Before we delve into the details of the language, let’s briefly look at the following ways in which Prometheus-compatible systems <a id="_idIndexMarker442"/>interact with <span class="No-Break">metrics data:</span></p>
			<ul>
				<li><strong class="bold">Ingesting metrics</strong>: Prometheus-compatible systems accept a timestamp, key-value labels, and a sample value. As the details of the <strong class="bold">Prometheus Time Series Database</strong> (<strong class="bold">TSDB</strong>) are <a id="_idIndexMarker443"/>quite complicated, the following diagram shows a simplified example of how an individual sample for a metric is stored once it has <span class="No-Break">been ingested:</span></li>
			</ul>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B18277_05_1.jpg" alt="Figure 5.1 – A simplified view of metric data stored in the TSDB"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – A simplified view of metric data stored in the TSDB</p>
			<ul>
				<li><strong class="bold">The labels or dimensions of a metric</strong>: Prometheus labels provide metadata to identify data of interest. These labels create metrics, time series, <span class="No-Break">and samples:</span><ul><li>Each unique <strong class="source-inline">__name__</strong> value creates<a id="_idIndexMarker444"/> a <strong class="bold">metric</strong>. In the preceding figure, the metric <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">app_frontend_requests</strong></span><span class="No-Break">.</span></li><li>Each unique set of labels creates <a id="_idIndexMarker445"/>a <strong class="bold">time series</strong>. In the preceding figure, the set of all labels is the <span class="No-Break">time series.</span></li><li>A time series will contain <a id="_idIndexMarker446"/>multiple <strong class="bold">samples</strong>, each with a unique timestamp. The preceding figure shows a single sample, but over time, multiple samples will be collected for each <span class="No-Break">time series.</span></li><li>The number of unique values for a metric label is referred to as the <strong class="bold">cardinality</strong> of the <a id="_idIndexMarker447"/>label. Highly cardinal labels should be avoided, as they<a id="_idIndexMarker448"/> significantly increase the storage costs of <span class="No-Break">the metric.</span></li></ul><p class="list-inset">The following diagram shows a single metric containing two time series and <span class="No-Break">five samples:</span></p></li>
			</ul>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B18277_05_2.jpg" alt="Figure 5.2 – An example of samples from multiple time series"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – An example of samples from multiple time series</p>
			<p>In Grafana, we can see a representation of the time series and samples from a metric. To do this, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>In your Grafana instance, select <strong class="bold">Explore</strong> in <span class="No-Break">the menu.</span></li>
				<li>Choose your Prometheus data source, which will be labeled as <span class="No-Break"><strong class="source-inline">grafanacloud-&lt;team&gt;-prom (default)</strong></span><span class="No-Break">.</span></li>
				<li>In the <strong class="bold">Metric</strong> dropdown, choose <strong class="bold">app_frontend_requests_total</strong>, and under <strong class="bold">Options</strong>, set <strong class="bold">Format</strong> to <strong class="bold">Table</strong>, and then click on <strong class="bold">Run query</strong>. This will show you all the samples and time series in the metric over the selected time range. You should see data <span class="No-Break">like this:</span></li>
			</ol>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B18277_05_3.jpg" alt="Figure 5.3 – Visualizing the samples and time series that make up a metric"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Visualizing the samples and time series that make up a metric</p>
			<p>Now that we understand the data structure, let’s <span class="No-Break">explore PromQL.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor111"/>An overview of PromQL features</h2>
			<p>In this section, we will take you through the features that PromQL has. We will start with an explanation of the data types, and then we will look at how to select data, how to work on multiple datasets, and how to use functions. As PromQL is a query language, it’s important to know how to manipulate data to produce alerts <span class="No-Break">and dashboards.</span></p>
			<h3>Data types</h3>
			<p>PromQL offers three data types, which are<a id="_idIndexMarker449"/> important, as the functions and operators in PromQL will work differently depending on the data <span class="No-Break">types presented:</span></p>
			<ul>
				<li><strong class="bold">Instant vectors</strong> are a <a id="_idIndexMarker450"/>data type that stores a set of time series<a id="_idIndexMarker451"/> containing a single sample, all sharing the same timestamp – that is, it presents values at a specific instant <span class="No-Break">in time:</span></li>
			</ul>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B18277_05_4.jpg" alt="Figure 5.4 – An instant vector"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – An instant vector</p>
			<ul>
				<li><strong class="bold">Range vectors</strong> store a set of <a id="_idIndexMarker452"/>time series, each containing a range<a id="_idIndexMarker453"/> of <a id="_idIndexMarker454"/>samples with <span class="No-Break">different timestamps:</span></li>
			</ul>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B18277_05_5.jpg" alt="Figure 5.5 – Range vectors"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Range vectors</p>
			<ul>
				<li><strong class="bold">Scalars</strong> are<a id="_idIndexMarker455"/> simple <a id="_idIndexMarker456"/>numeric values, with no labels or <span class="No-Break">timestamps </span><span class="No-Break"><a id="_idIndexMarker457"/></span><span class="No-Break">involved.</span></li>
			</ul>
			<h3>Selecting data</h3>
			<p>PromQL <a id="_idIndexMarker458"/>offers several tools for you to select data to show in a dashboard or <a id="_idIndexMarker459"/>alert, or just to understand a system’s state. Some of these are described in the <span class="No-Break">following table:</span></p>
			<table id="table001-4" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Syntax</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Operators</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Scope</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Metric selector</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">metric_name</strong></span></p>
						</td>
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Selects <span class="No-Break">a metric</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Range selector</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">[</strong><span class="No-Break"><strong class="source-inline">5m]</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">ms</strong>, <strong class="source-inline">s</strong>, <strong class="source-inline">m</strong>, <strong class="source-inline">h</strong>, <strong class="source-inline">d</strong>, <strong class="source-inline">w</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">y</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Selects samples</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Label selector</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">{</strong><span class="No-Break"><strong class="source-inline">label="value", foo!="bar"}</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">=</strong>, <strong class="source-inline">!=</strong>, <strong class="source-inline">=~</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">!~</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Selects and filters time series <span class="No-Break">using labels</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Offset modifier</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">offset 5m</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">ms</strong>, <strong class="source-inline">s</strong>, <strong class="source-inline">m</strong>, <strong class="source-inline">h</strong>, <strong class="source-inline">d</strong>, <strong class="source-inline">w</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">y</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Offsets the evaluation time from the current point in time by the <span class="No-Break">specified amount</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">@</strong> <span class="No-Break">modifier</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">@ </strong><span class="No-Break"><strong class="source-inline">1686561123</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">@</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Sets the evaluation time to a specific time for instant or range vectors. This modifier uses <span class="No-Break">epoch timestamps</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.1 – The selection operators available in PromQL</p>
			<p>In addition to <a id="_idIndexMarker460"/>the operators that allow us to select data, PromQL offers <a id="_idIndexMarker461"/>a selection of operators to compare multiple sets <span class="No-Break">of data.</span></p>
			<h3>Operators between two datasets</h3>
			<p>Some data is easily <a id="_idIndexMarker462"/>provided by a single metric, while other useful information<a id="_idIndexMarker463"/> needs to be created from multiple metrics. The following operators allow you to <span class="No-Break">combine datasets.</span></p>
			<table id="table002-3" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Syntax</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Operators</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Scope</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Arithmetic operators</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">a + b</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">+</strong>, <strong class="source-inline">-</strong>, <strong class="source-inline">*</strong>, <strong class="source-inline">/</strong>, <strong class="source-inline">%</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">^</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Arithmetic operations on instant vectors and scalars; scope depends on the data type of <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>. It’s important to note that vectors are matched on <span class="No-Break"><em class="italic">all</em></span><span class="No-Break"> labels.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Comparison operators</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">a == b</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">==</strong>, <strong class="source-inline">!=</strong>, <strong class="source-inline">&gt;</strong>, <strong class="source-inline">&lt;</strong>, <strong class="source-inline">&gt;=</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">&lt;=</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Filters instant vectors and scalars based on the comparison; scope depends on the data type of <strong class="source-inline">a</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">b</strong></span><span class="No-Break">.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Aggregation operators</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">sum by (</strong><span class="No-Break"><strong class="source-inline">label) (a)</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">sum()</strong>, <strong class="source-inline">min()</strong>, <strong class="source-inline">max()</strong>, <strong class="source-inline">avg()</strong>, <strong class="source-inline">group()</strong>, <strong class="source-inline">stddev()</strong>, <strong class="source-inline">stdvar()</strong>, <strong class="source-inline">count()</strong>, <strong class="source-inline">count_values()</strong>, <strong class="source-inline">bottomk()</strong>, <strong class="source-inline">topk()</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">quantile()</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Aggregation operations on a single <span class="No-Break">instant vector.</span></p>
							<p>These operators offer the <strong class="source-inline">without</strong> and <strong class="source-inline">by</strong> clauses to modify how results are grouped <span class="No-Break">by label.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>One-to-one <span class="No-Break">vector matching</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">a + </strong><span class="No-Break"><strong class="source-inline">on b</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">on()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">ignoring()</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Modifies vector matching to specific labels (<strong class="source-inline">on</strong>) or ignoring a <span class="No-Break">label (ignoring)</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>One-to-many/many-to-one vector matching using <span class="No-Break">group modifiers</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">a + </strong><span class="No-Break"><strong class="source-inline">group_left b</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">group_left()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">group_right()</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Modifies the vector matching in cases of many-to-one or <span class="No-Break">one-to-many matching.</span></p>
							<p>Grouping can use a label list to include a label in <span class="No-Break">the results.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Many-to-many vector matching using <span class="No-Break">logical operators</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">a </strong><span class="No-Break"><strong class="source-inline">and b</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">and</strong>, <strong class="source-inline">or</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">unless</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Modifies<a id="_idIndexMarker464"/> vector<a id="_idIndexMarker465"/> matching in cases of many-to-many matching, based on logical operations between labels and the values of <strong class="source-inline">a</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">b</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.2 – The comparison operators available in PromQL</p>
			<p>Vector matching is an initially confusing topic; to clarify it, let’s consider examples for the three cases of vector matching – <em class="italic">one-to-one</em>, <em class="italic">one-to-many</em>/<em class="italic">many-to-one</em>, <span class="No-Break">and </span><span class="No-Break"><em class="italic">many-to-many</em></span><span class="No-Break">.</span></p>
			<p>By default, when<a id="_idIndexMarker466"/> combining vectors, all label names and values are <a id="_idIndexMarker467"/>matched. This means that for each element of the vector, the operator will try to find a single matching element from the second vector. Let’s consider a <span class="No-Break">simple example:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Vector A</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break"><strong class="source-inline">10{color=blue,smell=ocean}</strong></span></li><li><span class="No-Break"><strong class="source-inline">31{color=red,smell=cinnamon}</strong></span></li><li><span class="No-Break"><strong class="source-inline">27{color=green,smell=grass}</strong></span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Vector B</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break"><strong class="source-inline">19{color=blue,smell=ocean}</strong></span></li><li><span class="No-Break"><strong class="source-inline">8{color=red,smell=cinnamon}</strong></span></li><li><span class="No-Break"><strong class="source-inline">14{color=green,smell=jungle}</strong></span></li></ul></li>
				<li><strong class="bold">A{} + </strong><span class="No-Break"><strong class="bold">B{}</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break"><strong class="source-inline">29{color=blue,smell=ocean}</strong></span></li><li><span class="No-Break"><strong class="source-inline">39 {color=red,smell=cinnamon}</strong></span></li></ul></li>
				<li><strong class="bold">A{} + on (color) B{}</strong> <em class="italic">or</em> <strong class="bold">A{} + ignoring (</strong><span class="No-Break"><strong class="bold">smell) B{}</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break"><strong class="source-inline">29{color=blue}</strong></span></li><li><span class="No-Break"><strong class="source-inline">39{color=red}</strong></span></li><li><span class="No-Break"><strong class="source-inline">41{color=green}</strong></span></li></ul></li>
			</ul>
			<p>When <strong class="source-inline">color=blue</strong> and <strong class="source-inline">smell=ocean</strong>, <strong class="source-inline">A{} + B{}</strong> gives <strong class="source-inline">10 + 19 = 29</strong>, and when <strong class="source-inline">color=red</strong> and <strong class="source-inline">smell=cinnamon</strong>, <strong class="source-inline">A{} + B{}</strong> gives <strong class="source-inline">31 + 8 = 29</strong>. The other elements do not match the two vectors so <span class="No-Break">are ignored.</span></p>
			<p>When we sum the vectors using <strong class="source-inline">on (color)</strong>, we will only match on the <strong class="source-inline">color</strong> label; so now, the two green elements match and <span class="No-Break">are summed.</span></p>
			<p>This example <a id="_idIndexMarker468"/>works when there is a <em class="italic">one-to-one</em> relationship of labels<a id="_idIndexMarker469"/> between vector <strong class="bold">A</strong> and vector <strong class="bold">B</strong>. However, sometimes there may be a <em class="italic">many-to-one</em> or <em class="italic">one-to-many</em> relationship – that is, vector A or vector B may have more than one element that matches the other vector. In these cases, Prometheus will give an error, and grouping syntax must be used. Let’s look at another example to <span class="No-Break">illustrate this:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Vector A</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break"><strong class="source-inline">7{color=blue,smell=ocean}</strong></span></li><li><span class="No-Break"><strong class="source-inline">5{color=red,smell=cinamon}</strong></span></li><li><span class="No-Break"><strong class="source-inline">2{color=blue,smell=powder}</strong></span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Vector B</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break"><strong class="source-inline">20{color=blue,smell=ocean}</strong></span></li><li><span class="No-Break"><strong class="source-inline">8{color=red,smell=cinamon}</strong></span></li><li><span class="No-Break"><strong class="source-inline">14{color=green,smell=jungle}</strong></span></li></ul></li>
				<li><strong class="bold">A{} + on (color) </strong><span class="No-Break"><strong class="bold">group_left B{}</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break"><strong class="source-inline">27{color=blue,smell=ocean}</strong></span></li><li><span class="No-Break"><strong class="source-inline">13{color=red,smell=cinamon}</strong></span></li><li><span class="No-Break"><strong class="source-inline">22{color=blue,smell=powder}</strong></span></li></ul></li>
			</ul>
			<p>Now, we have two different elements in vector <strong class="bold">A</strong> with <strong class="source-inline">color=blue</strong>. The <strong class="source-inline">group_left</strong> command will use the labels from vector <strong class="bold">A</strong> but only match on color. This leads to the third element of the combined vector having a value of <strong class="source-inline">22</strong>, when the item matching in vector <strong class="bold">B</strong> has a different smell. The <strong class="source-inline">group_right</strong> operator will behave in the <span class="No-Break">opposite direction.</span></p>
			<p>The final option is a <em class="italic">many-to-many</em> vector match. These matches use the logical operators <strong class="source-inline">and</strong>, <strong class="source-inline">unless</strong>, and <strong class="source-inline">or</strong> to combine parts of vectors <strong class="bold">A</strong> and <strong class="bold">B</strong>. Let’s see <span class="No-Break">some examples:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Vector A</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break"><strong class="source-inline">10{color=blue,smell=ocean}</strong></span></li><li><span class="No-Break"><strong class="source-inline">31{color=red,smell=cinamon}</strong></span></li><li><span class="No-Break"><strong class="source-inline">27{color=green,smell=grass}</strong></span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Vector B</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break"><strong class="source-inline">19{color=blue,smell=ocean}</strong></span></li><li><span class="No-Break"><strong class="source-inline">8{color=red,smell=cinamon}</strong></span></li><li><span class="No-Break"><strong class="source-inline">14{color=green,smell=jungle}</strong></span></li></ul></li>
				<li><strong class="bold">A{} </strong><span class="No-Break"><strong class="bold">and B{}</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break"><strong class="source-inline">10{color=blue,smell=ocean}</strong></span></li><li><span class="No-Break"><strong class="source-inline">31{color=red,smell=cinamon}</strong></span></li></ul></li>
				<li><strong class="bold">A{} </strong><span class="No-Break"><strong class="bold">unless B{}</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break"><strong class="source-inline">27{color=green,smell=grass}</strong></span></li></ul></li>
				<li><strong class="bold">A{} </strong><span class="No-Break"><strong class="bold">or B{}</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break"><strong class="source-inline">10{color=blue,smell=ocean}</strong></span></li><li><span class="No-Break"><strong class="source-inline">31{color=red,smell=cinamon}</strong></span></li><li><span class="No-Break"><strong class="source-inline">27{color=green,smell=grass}</strong></span></li><li><span class="No-Break"><strong class="source-inline">14{color=green,smell=jungle}</strong></span></li></ul></li>
			</ul>
			<p>Unlike the <a id="_idIndexMarker470"/>previous examples, mathematical operators are not<a id="_idIndexMarker471"/> being used here, so the values of the elements are the values from vector <strong class="bold">A</strong>, but only the elements of <strong class="bold">A</strong> that match the logical condition in <strong class="bold">B</strong> <span class="No-Break">are returned.</span></p>
			<p>Now that we understand the operators, let’s quickly introduce PromQL functions before we look at a practical example of writing PromQL. We will explore a practical example of their use in the <em class="italic">Writing </em><span class="No-Break"><em class="italic">PromQL</em></span><span class="No-Break"> section.</span></p>
			<h3>Functions</h3>
			<p>PromQL offers about<a id="_idIndexMarker472"/> 60 different functions. The full list of functions can be found on the <a id="_idIndexMarker473"/>Prometheus <span class="No-Break">w</span><a href="https://prometheus.io/docs/prometheus/latest/querying/functions"><span class="No-Break">ebsite: </span><span class="No-Break">https://prometheus.io/docs/prometheus/latest/querying/f</span></a><span class="No-Break">unctions</span><span class="No-Break">.</span></p>
			<p>Now that we’ve looked at the functions available in PromQL, let’s explore writing a <span class="No-Break">PromQL query.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor112"/>Writing PromQL</h2>
			<p>While<a id="_idIndexMarker474"/> technical descriptions of a language are useful for reference, this section will follow the process of building a query so that the language can be seen in context. Having your Grafana instance open in <strong class="bold">Explorer</strong> will help you follow along. In the following sections, we’ll write practical examples using the selectors, operators, and modifiers we introduced in the <span class="No-Break">previous section.</span></p>
			<h3>Metric selection</h3>
			<p>When we looked at<a id="_idIndexMarker475"/> metric labels, we saw how you can select metrics in PromQL with the <strong class="source-inline">metric_name{}</strong> syntax. This can be typed directly into a query using the <strong class="bold">Code</strong> button in the top-right corner of the query panel, or as we did earlier in the <em class="italic">Introducing PromQL</em> section, you can use <strong class="bold">Builder</strong>. In <strong class="bold">Builder</strong>, you will see the PromQL in the query panel below your selection, it should currently say <strong class="source-inline">app_frontend_requests_total</strong>. If it does not, use the <strong class="bold">Metric</strong> dropdown to select this metric. You should see results like in <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.3</em>. This method of selection returns an instant vector, as described in <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">.</span></p>
			<p>The syntax is similar for returning a range vector, as described in <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.5</em>. We just need to add the range we are interested in – <strong class="source-inline">metric_name[range]</strong>. The range must include the time units, which can range from millisec<a id="_idTextAnchor113"/>onds (ms) to years (y). It’s important to note that queries using range vectors need to be run with a query type of <strong class="bold">Instant</strong>. If a query type of <strong class="bold">Range</strong> or <strong class="bold">Both</strong> (the default) is selected, then you will receive an error. Here is an example of the error you <span class="No-Break">will see:</span></p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B18277_05_6.jpg" alt="Figure 5.6 – An error when using a range vector in a range query"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – An error when using a range vector in a range query</p>
			<h3>Time series selection and operators</h3>
			<p>As time<a id="_idIndexMarker476"/> series are made up of a unique set of labels, we can expand our query to only look at specific data – for example, only requests that target the cart API of the OpenTelemetry demo application. The following steps will filter our query to show only the requests that target the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">api/cart</strong></span><span class="No-Break"> endpoint:</span></p>
			<ol>
				<li>Switch to the <strong class="bold">Table</strong> view at the top right of the <span class="No-Break"><strong class="bold">Results</strong></span><span class="No-Break"> panel:</span></li>
			</ol>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B18277_05_7.jpg" alt="Figure 5.7 – Using the Table view in the PromQL results"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Using the Table view in the PromQL results</p>
			<ol>
				<li value="2">Hover your mouse over a value for the target; you should see <span class="No-Break">this icon:</span></li>
			</ol>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B18277_05_8.jpg" alt="Figure 5.8 – Filter for value"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Filter for value</p>
			<ol>
				<li value="3">Click on<a id="_idIndexMarker477"/> the plus icon, and you will see that we have a new label filter and our PromQL now says the <span class="No-Break">following: </span><span class="No-Break"><strong class="source-inline">app_frontend_requests_total{targ<a id="_idTextAnchor114"/>et="/api/cart"}</strong></span><span class="No-Break">.</span></li>
				<li>Let’s only show the <strong class="source-inline">GET</strong> method requests as well; you can do this by using the <strong class="bold">filters</strong> selector in the query panel, or the table in the <strong class="bold">Results</strong> panel. Like LogQL, we have different operators available to filter labels. The operators we can use are <span class="No-Break">as follows:</span><ul><li><strong class="source-inline">=</strong>: Checks for an exact match of a string. For example, <strong class="source-inline">target="/api/cart"</strong> will match only when the <strong class="source-inline">target</strong> label <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">/ap<a id="_idTextAnchor115"/>i/cart/</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">!=</strong>: Checks for anything other than an exact match. <strong class="source-inline">target!="/api/cart"</strong> will match everything except when the <strong class="source-inline">target</strong> label <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">/api/cart/</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">=~</strong>: Checks for a regex match. For example,<strong class="source-inline"> target=~"/api/.*"</strong> will match when the <strong class="source-inline">target</strong> label starts with <strong class="source-inline">/api/</strong>. This includes <strong class="source-inline">/api/cart/</strong>, <strong class="source-inline">/api/horse/</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">/api/cart/f<a id="_idTextAnchor116"/>oo/bar/</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">!~</strong>: Checks for anything other than a regex match. <strong class="source-inline">target!~"/api/.+"</strong> will match when the <strong class="source-inline">target</strong> label is <strong class="source-inline">/api/</strong> or <strong class="source-inline">/checkout/</strong> but will not match <strong class="source-inline">/api/cart/</strong>, <strong class="source-inline">/api/horse/</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">/api/cart/foo/bar/</strong></span><span class="No-Break">.</span></li></ul></li>
			</ol>
			<p>While we’re looking at the table, you should also see a column titled <strong class="bold">__name__</strong>; this is a special label that can be used as an alternative during search, for instance, <strong class="source-inline">metric_name{}</strong> is equivalent <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">{__name__="metric_name"}</strong></span><span class="No-Break">.</span></p>
			<p>We’ve now selected data and filtered it to the endpoint we’re interested in, but a raw count of the requests that were made is difficult to interpret. Let’s look at how to transform this count into something more useful, using <span class="No-Break">a function.</span></p>
			<h3>Functions, aggregation, and operators</h3>
			<p>PromQL is a<a id="_idIndexMarker478"/> nested language, so to apply a function to a selected set of data, you <a id="_idIndexMarker479"/>simply enclose the data selection with the function. Our query so <a id="_idIndexMarker480"/>far looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
app_frontend_requests_total{target="/api/cart",method="GET"}</pre>			<p>This query returns the count of requests at each sample point. For most purposes, we are more interested in the rate of requests that hit that endpoint. This will allow us to answer questions such as what the peak rate is, or whether the rate is higher now or lower than at another point in time. The function to get this information is the <strong class="source-inline">rate()</strong> function. We can plug our current query into the function <span class="No-Break">like this:</span></p>
			<pre class="source-code">
rate(app_frontend_requests_total{target="/api/cart",method="GET"}[$__rate_interval])</pre>			<p>The rate function takes an input of a range vector, so we have added the special <strong class="source-inline">[$__rate_interval]</strong> time variable. This is a Grafana feature that instructs Grafana to pick an appropriate interval, based on the scrape interval of the data source we have selected. This feature simplifies the technicalities of selecting the correct rate interval. A similar process is used for aggregation and <span class="No-Break">other operators.</span></p>
			<p>Now that we know how to get the rate of requests to the <strong class="source-inline">/api/cart</strong> endpoint, let’s have a look at another <span class="No-Break">example query.</span></p>
			<h3>HTTP success rate</h3>
			<p>A common <strong class="bold">Service Level Indicator</strong> (<strong class="bold">SLI</strong>) for<a id="_idIndexMarker481"/> a web application is the <strong class="bold">success rate</strong> of HTTP requests. In plain language, this is the number of <a id="_idIndexMarker482"/>successful HTTP requests/total HTTP requests. We will discuss the process of choosing good SLIs in <a href="B18277_09.xhtml#_idTextAnchor183"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">.</span></p>
			<p>A PromQL query like the following will produce the success rate SLI for the <span class="No-Break"><strong class="source-inline">app_frontend_requests_total</strong></span><span class="No-Break"> metric:</span></p>
			<pre class="source-code">
sum b<a id="_idTextAnchor117"/>y (instance) (rate(
   app_frontend_requests_total{status=~"2[0-9]{2}"}[5m]))
/
sum by (instance) (rate(app_frontend_requests[5m]))</pre>			<p>We can break this <a id="_idIndexMarker483"/>code down <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Using <strong class="source-inline">app_frontend_requests_total{status=~"2[0-9]{2}"}[5m]</strong>, we select samples of the <strong class="source-inline">app_frontend_requests</strong> metric that have the <strong class="source-inline">status</strong> label, with a value between <strong class="source-inline">200</strong> and <strong class="source-inline">299</strong>. This uses regex to select the label range, and it is a range vector over a five-minute range. For those of you familiar with regex, Grafana requires the escaping <span class="No-Break">of ba<a id="_idTextAnchor118"/>ckslashes.</span></li>
				<li>The <strong class="source-inline">rate()</strong> function calculates the per-second average rate of successful requests. This function returns an <span class="No-Break">instant vector.</span></li>
				<li>The previous functions have left all data grouped into the initial time series from it. However, for this query, we are not interested in the method, target, or any other labels. Instead, we are interested in knowing whether a particular instance of the application is failing, as a failing instance could be masked by many good instances. To achieve this, we use the <strong class="source-inline">sum by (instance) ()</strong> <span class="No-Break">aggregation.</span></li>
				<li>The last line of the query mirrors the first line but removes the label selector, so we get the <span class="No-Break"><em class="italic">total</em></span><span class="No-Break"> requests.</span></li>
				<li>Finally, we use the arithmetic operator (<strong class="source-inline">/</strong>) to divide the successful requests by the total requests. The output of this query gives us a number that will be close to 1 when most requests are successful; as we see failures, this will trend downward to 0 when every <span class="No-Break">request fails.</span></li>
			</ul>
			<p>Another common item to measure is the <strong class="bold">duration</strong> of requests made to the service. Durations are frequently represented as histogram data, and PromQL offers us many statistical tools we can use to understand our user’s experience. Let’s look at the <span class="No-Break">following query:</span></p>
			<pre class="source-code">
histogram_quant<a id="_idTextAnchor119"/>ile(
    0.95<a id="_idTextAnchor120"/>, sum(
        rate(
            http_server_duration_milliseconds_bucket{}[$__rate_interv<a id="_idTextAnchor121"/>al])
        ) by (le)
    )</pre>			<p>The <strong class="source-inline">http_server_duration_milliseconds_bucket</strong> metric is a histogram, which is indicated by the naming convention of <strong class="source-inline">_bucket</strong>. The <strong class="source-inline">histogram_quantile()</strong> function takes this histogram data and gives us the 95th percentile duration. This is calculated using the <strong class="source-inline">le</strong> (less than or equal to) label in the histogram data. While it might be tempting to use averages for this kind of calculation, percentiles offer us a more nuanced understanding of the data. The 95th percentile means that 95% of samples have a duration less than or equal to the <span class="No-Break">value returned.</span></p>
			<p>Grafana offers several helpful functions to understand <span class="No-Break">a query:</span></p>
			<ul>
				<li>Above the query component is a slider titled <strong class="bold">Explain</strong>.<a id="_idTextAnchor122"/> Toggling this on will present a step-by-step breakdown of what a query <span class="No-Break">is doing.</span></li>
				<li>Also, above the query component is a button titled <strong class="bold">Kick start your query</strong>. Clicking this will give a number of <span class="No-Break">starter queries.</span></li>
				<li>Below the <strong class="bold">Options</strong> section<a id="_idIndexMarker484"/> is the query <strong class="bold">Inspector</strong>. This will give detailed information about the query, such as its total request time and the <span class="No-Break">data returned.</span></li>
			</ul>
			<p>Here is a screenshot showing the location of <span class="No-Break">these options:</span></p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B18277_05_9.jpg" alt="Figure 5.9 – Helpful functions for queries"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – Helpful functions for queries</p>
			<p>Hopefully, you have a good grasp of the fundamentals of PromQL now and know what resources you have available to learn more. Whilst querying data is a major part of the day-to-day work in Grafana, it is good to have an understanding of how metrics data <span class="No-Break">is collected.</span></p>
			<p>The OpenTelemetry demo that has been set up also produces metrics from the single-node Kubernetes cluster, the kubelet instance on the node, and the underlying host. We encourage you to explore these metrics and see what you <span class="No-Break">can find.</span></p>
			<p>We’ve seen how to query the data stored in Prometheus-compatible systems. Now, let’s see how to collect data from <span class="No-Break">your services.</span></p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor123"/>Exploring data collection and metric protocols</h1>
			<p>In <a href="B18277_02.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we <a id="_idIndexMarker485"/>introduced<a id="_idIndexMarker486"/> four common protocols in use to<a id="_idIndexMarker487"/> collect data from today’s software – <strong class="bold">StatsD</strong> and <strong class="bold">DogStatsD</strong>, <strong class="bold">OpenTelemetry Protocol</strong> (<strong class="bold">OTLP</strong>), and <strong class="bold">Prometheus</strong>. We also<a id="_idIndexMarker488"/> introduced <strong class="bold">Simple Network Management Protocol</strong> (<strong class="bold">SNMP</strong>), which <a id="_idIndexMarker489"/>is used in the networking and compute spaces. In this section, we’ll explore some of the features of <span class="No-Break">these protocols.</span></p>
			<p>There are two methods that metrics can be collected, push and pull. In a <strong class="bold">push protocol</strong>, the <a id="_idIndexMarker490"/>application or infrastructure must be configured with a destination to send metrics. In a <strong class="bold">pull protocol</strong>, the<a id="_idIndexMarker491"/> application or infrastructure is configured to expose metrics for another service to request. Both methods have advantages and disadvantages, it is also important to be aware of the potential security implications. In the following subsections, let’s delve into <span class="No-Break">each protocol.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor124"/>StatsD and DogStatsD</h2>
			<p>We have grouped<a id="_idIndexMarker492"/> StatsD and DogStatsD together, as they are <a id="_idIndexMarker493"/>identical for the purposes of what we are discussing in <span class="No-Break">this chapter.</span></p>
			<p><strong class="bold">StatsD</strong> is<a id="_idIndexMarker494"/> a <em class="italic">push protocol</em>, so each application producing metrics needs to be aware of the destination for these metrics. StatsD <a id="_idIndexMarker495"/>uses <strong class="bold">User Datagram Protocol</strong> (<strong class="bold">UDP</strong>) over port <strong class="source-inline">8125</strong> in its default settings. These are things to consider when <span class="No-Break">using StatsD:</span></p>
			<ul>
				<li>StatsD uses UDP for transmission. This favors the speed of transmission over the guarantee <span class="No-Break">of delivery.</span></li>
				<li>The protocol offers no support for authentication between the application and the receiving service. Depending on the environment, this could be a <span class="No-Break">security concern.</span></li>
			</ul>
			<p>It’s worth noting that common practice, especially in Kubernetes, is to expose the StatsD receiver on <strong class="source-inline">localhost:8125</strong>, thus limiting exposure and offering a standard for applications <span class="No-Break">to use.</span></p>
			<p>StatsD has quite wide support in data collection agents, usually via contributed receivers. The OpenTelemetry collector, FluentBit, Vector, Beats, Telegraf, and the StatsD daemon all support the protocol. Prometheus offers an exporter that takes StatsD format metrics and exposes them as a Prometheus scrape endpoint; this is recommended as an intermediate step to a full <span class="No-Break">Prometheus migration.</span></p>
			<p><strong class="bold">DogStatsD</strong> is <a id="_idIndexMarker496"/>less well <a id="_idIndexMarker497"/>supported than the StatsD format it is derived from; it provides an expanded set of metrics to StatsD. The data collection agents that natively support DogStatsD are <strong class="bold">Vector</strong> and <a id="_idIndexMarker498"/>Datadog’s own agent. The OpenTelemetry collector currently has no support, but there are discussions in progress on adding this, and Datadog is an active participant in the OpenTelemetry project, so this is likely <span class="No-Break">to change.</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor125"/>OTLP</h2>
			<p>OTLP is also<a id="_idIndexMarker499"/> a <em class="italic">push protocol</em>, so <a id="_idIndexMarker500"/>destination knowledge is necessary. Like StatsD, OTLP is often implemented using the<a id="_idIndexMarker501"/> standard receiving endpoint of <strong class="source-inline">localhost:4317</strong> (<strong class="bold">Google Remote Procedure Call</strong> (<strong class="bold">gRPC</strong>)) or <strong class="source-inline">localhost:4318</strong> (HTTP). OTLP supports both gRPC and HTTP and offers support for the authentication and <a id="_idIndexMarker502"/>acknowledgment between the client and server. OTLP also offers several quality-of-life items, such<a id="_idIndexMarker503"/> as <strong class="bold">server-controlled throttling</strong> and <span class="No-Break"><strong class="bold">GZIP compression</strong></span><span class="No-Break">.</span></p>
			<p>OpenTelemetry is in very active development, so this information is liable to change. As the project is a collaboration between several major vendors, agents from those vendors are increasingly supporting OTLP metrics. While other collection tools do not support OTLP input, the OpenTelemetry collector supports input from many sources. This means the OTEL collector is ideal for supporting a mixed estate. The vector collection agent also offers this versatility, and most things said about the OTEL collector can be applied to it <span class="No-Break">as well.</span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor126"/>Prometheus</h2>
			<p>Unlike StatsD and OTLP, Prometheus<a id="_idIndexMarker504"/> is a <em class="italic">pull protocol</em>. A client application needs to be configured to<a id="_idIndexMarker505"/> serve metrics on an endpoint, and then a Prometheus-compatible scraper is configured to collect those metrics at specific intervals. These metrics are commonly exposed on the <strong class="source-inline">/metrics</strong> endpoint, although some frameworks implement this differently (e.g., <strong class="source-inline">/actuator/Prometheus</strong> for <span class="No-Break">Spring Boot).</span></p>
			<p>It may seem that using a pull configuration increases the configuration steps required. However, using a pull method does reduce the information needed by the application of its running environment. For example, the application configuration would remain the same if 0 or 10 clients read its metrics. This pull pattern also matches very closely with the pattern of liveness and readiness endpoints for applications <span class="No-Break">in Kubernetes.</span></p>
			<p>To assist in the server configuration, Prometheus offers a wide range of service discovery options, across many different platforms, including Kubernetes, DNS, and Consul. These discovery options include matching a specific name and collecting data if a label is present, and this range of options allows for quite complex architectures <span class="No-Break">where needed.</span></p>
			<p>The <a id="_idIndexMarker506"/>Prometheus format has good collector support; Prometheus, the<a id="_idIndexMarker507"/> OTEL Collector, Grafana Agent, Vector, Beats, and Telegraf all support the collection of <span class="No-Break">these metrics.</span></p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor127"/>SNMP</h2>
			<p>SNMP is <a id="_idIndexMarker508"/>more complex than the other protocols discussed<a id="_idIndexMarker509"/> here, as it includes a lot of functionality for the management and monitoring of network-connected devices, such as switches and physical servers. The <em class="italic">monitoring</em> aspect of SNMP is a <em class="italic">pull protocol</em>, where a manager instance connects to agent software on devices and pulls data. There is additional functionality<a id="_idIndexMarker510"/> in <strong class="bold">SNMP traps</strong>, which allow a device to inform the manager about items as a data push. These traps are often of interest to track metrics from. It is worth noting that security can be a concern using SNMP, depending on how it is configured. SNMP offers a significant attack surface if <span class="No-Break">configured incorrectly.</span></p>
			<p>SNMP is very well supported, as the protocol has been active since 1988 and has good support from <span class="No-Break">hardware vendors.</span></p>
			<p>We’ve now covered querying data using PromQL, and how data is produced and collected, so let’s now explore how Grafana stores <span class="No-Break">metric data.</span></p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor128"/>Understanding data storage architectures</h1>
			<p><strong class="bold">Time Series Databases</strong> (<strong class="bold">TSDBs</strong>) are<a id="_idIndexMarker511"/> ideally <a id="_idIndexMarker512"/>suited to handle metric data, as metrics need to record data at specific points in time, and TSDBs are structured to make this data easy to record and query. There are several TSDBs available, but as this book is focused on Grafana, we will only <a id="_idIndexMarker513"/>discuss <strong class="bold">Graphite</strong>, <strong class="bold">Prometheus</strong>, and <strong class="bold">Mimir</strong> in this section. This is aimed at giving you an<a id="_idIndexMarker514"/> understanding of the structure of data as it is stored, as well as an <a id="_idIndexMarker515"/>overview of how Mimir allows organizations to scale their data beyond the capabilities of Graphite <span class="No-Break">and Prometheus.</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor129"/>Graphite architecture</h2>
			<p>Graphite has several <a id="_idIndexMarker516"/>components; we will discuss the storage <a id="_idIndexMarker517"/>component <strong class="bold">Whisper</strong> here. The Whisper TSDB uses a flat file structure, where each unique time series is a fixed-size file. This size is determined by the configuration of resolution<a id="_idIndexMarker518"/> and retention configured in Whisper. Gathering this data for a search requires each of these files to be read, which quickly becomes expensive in disk I/O. As there are no inbuilt items that manage data redundancy, Graphite is also unable to guarantee that data written to it will be protected from loss <span class="No-Break">or corruption.</span></p>
			<p>However, the protocols introduced by Graphite to write data are still relevant although aging, so Grafana Cloud offers a Graphite ingest endpoint and query endpoint for teams that are already using <span class="No-Break">this technology.</span></p>
			<p>Graphite was an early example of metrics, introduced in 2008; the limitations of query speed and data integrity outlined previously led to the creation of Prometheus, which we will <span class="No-Break">discuss next.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor130"/>Prometheus architecture</h2>
			<p>Prometheus<a id="_idIndexMarker519"/> stores data in an immutable <strong class="source-inline">block</strong>, which <a id="_idIndexMarker520"/>covers a fixed time range (by default, two hours). Inside a block are several <strong class="source-inline">chunks</strong>, which are capped at 512 MB; these files contain the sampled value. Alongside these <strong class="source-inline">chunks</strong> are metadata files – <strong class="source-inline">index</strong> and <strong class="source-inline">meta.json</strong>. The <strong class="source-inline">index</strong> file contains a table that records the labels contained in the block and a reference to the position of all samples, with these labels in the associated chunks. Highly cardinal metric labels cause a huge increase in the size of the <strong class="source-inline">index</strong> file and degrade read performance. The <strong class="source-inline">meta.json</strong> file contains metadata such as the min and max timestamp contained in the <strong class="source-inline">block</strong> and stats on the samples, series, and chunks contained and the <span class="No-Break">version used.</span></p>
			<p>To process data as it’s received, Prometheus also uses a <strong class="source-inline">head block</strong>, which is similar to the <strong class="source-inline">block</strong> used for storage, but it allows writes. This allows for the collection of a full two-hour block of data, ready for the index and metadata to be created when the block is finished. This process includes functionality to persist data on disk to prevent data loss. The <strong class="source-inline">head block</strong> consists of a <strong class="bold">Write-Ahead Log</strong> (<strong class="bold">WAL</strong>) that contains the raw data as it is received and a <strong class="source-inline">meta.json</strong> file that records what<a id="_idIndexMarker521"/> has been received. When the end of the two-hour time block is reached, a new <strong class="source-inline">head block</strong> is created, and the old <strong class="source-inline">head block</strong> is transformed into a standard <strong class="source-inline">block</strong>, with the creation of an <strong class="source-inline">index</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">chunks</strong></span><span class="No-Break">.</span></p>
			<p>The following<a id="_idIndexMarker522"/> figure shows the structure of a fictional Prometheus TSDB, with<a id="_idIndexMarker523"/> the <strong class="source-inline">blocks</strong>, <strong class="source-inline">chunks</strong>, <strong class="source-inline">index</strong>, and metadata files and the <span class="No-Break">WAL highlighted:</span></p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B18277_05_10.jpg" alt="Figure 5.10 – The Prometheus TSDB"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – The Prometheus TSDB</p>
			<p>The<a id="_idIndexMarker524"/> implementation of the Prometheus TSDB in Prometheus itself is limited, as it uses local storage, which is not clustered or replicated natively. While it is<a id="_idIndexMarker525"/> possible to improve the aspects of this, there is a fundamental limitation of only a single node carrying out reads and writes. These limitations are perfectly acceptable in the correct circumstances. However, when scaling the TSDB to accept many active time series, changes are needed. Handling these situations is what Mimir was designed <span class="No-Break">to do.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor131"/>Mimir architecture</h2>
			<p>Mimir uses <a id="_idIndexMarker526"/>the <a id="_idIndexMarker527"/>same fundamental TSDB storage structures. However, unlike Prometheus, Mimir natively supports object stores for block files. The supported stores include Amazon S3, Google Cloud Storage, Microsoft Azure Storage, and <span class="No-Break">OpenStack Swift.</span></p>
			<p>By leveraging <strong class="bold">object storage</strong>, which is<a id="_idIndexMarker528"/> massively scalable, Mimir can handle the scaling problem experienced with Prometheus by adding new instances of the data-ingesting service. Mimir separates the incoming streams of data to a specific per-tenant TSDB, and each of these is assigned to an instance of the ingesting service. Like Prometheus, data is written to memory and the WAL by the ingester, and when the block is complete, it is written to object storage. To provide resilience Mimir will write each of these streams to multiple ingesters, and a compactor service will handle the process of merging the redundant blocks in object storage and removing <span class="No-Break">duplicate samples.</span></p>
			<p>Like the horizontal scalability of the write pathway, Mimir also scales the read pathway. It does this by splitting an incoming query into shorter time ranges. Then, it distributes these smaller units of the query to multiple querier instances. By doing this, Mimir again leverages the benefits of the underlying object storage for a quick return <span class="No-Break">of data.</span></p>
			<p>The following diagram shows the read and write pathways <span class="No-Break">for Mimir:</span></p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B18277_05_11.jpg" alt="Figure 5.11 – Mimir architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11 – Mimir architecture</p>
			<p>Metrics show us<a id="_idIndexMarker529"/> aggregated data, such as the total count of requests. It is helpful when exploring an <em class="italic">odd</em> metric value to be able to look at an example. In applications that are instrumented with traces and metrics, exemplars allow us to record a sample trace in our <a id="_idIndexMarker530"/>metric data. Let’s see this capability <span class="No-Break">in action.</span></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor132"/>Using exemplars in Grafana</h1>
			<p><strong class="bold">Exemplars</strong> are<a id="_idIndexMarker531"/> functions in Grafana that allow us to pivot from an aggregated view of the system, given by metrics, to a detailed view of a single request, given by traces. Exemplars <a id="_idIndexMarker532"/>need to be configured at the <em class="italic">collection layer</em> and then <a id="_idIndexMarker533"/>sent to the <span class="No-Break"><em class="italic">storage layer</em></span><span class="No-Break">.</span></p>
			<p>When they are available, you can view exemplars by doing <span class="No-Break">the following:</span></p>
			<ol>
				<li>Open <strong class="bold">Options</strong> under the query, and toggle the <span class="No-Break"><strong class="bold">Exemplars</strong></span><span class="No-Break"> slider:</span></li>
			</ol>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B18277_05_12.jpg" alt="Figure 5.12 – The Exemplars toggle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12 – The Exemplars toggle</p>
			<ol>
				<li value="2">Exemplars <a id="_idIndexMarker534"/>will appear as stars on the <span class="No-Break">metrics </span><span class="No-Break"><a id="_idIndexMarker535"/></span><span class="No-Break">chart:</span></li>
			</ol>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B18277_05_13.jpg" alt="Figure 5.13 – An exemplar in metrics"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.13 – An exemplar in metrics</p>
			<p class="list-inset">Hovering over an individual exemplar will expand on the metrics data by showing information from the exemplar trace in the metrics view. We will explain these fields in more detail in <a href="B18277_06.xhtml#_idTextAnchor134"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, but some notable fields are the name and version of the process runtime and <strong class="source-inline">span_id</strong>, which would not usually be available in a purely <span class="No-Break">metric view:</span></p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B18277_05_14.jpg" alt="Figure 5.14 – Exemplar information"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.14 – Exemplar information</p>
			<ol>
				<li value="3">From an<a id="_idIndexMarker536"/> exemplar, you can also pivot from viewing metric<a id="_idIndexMarker537"/> data to looking at the trace in question by clicking on the <strong class="bold">Query with Tempo (</strong><span class="No-Break"><strong class="bold">Tempo)</strong></span><span class="No-Break"> button:</span></li>
			</ol>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B18277_05_15.jpg" alt="Figure 5.15 – Opening an exemplar in Tempo"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.15 – Opening an exemplar in Tempo</p>
			<p>We’ll discuss the details of tracing in more detail in <a href="B18277_06.xhtml#_idTextAnchor134"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, but this should give you a good introduction to using this kind of data in <span class="No-Break">your metrics.</span></p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor133"/>Summary</h1>
			<p>In this chapter, we explored metrics in detail. We saw all the operators available in PromQL and wrote two queries using the language. With that foundation of querying knowledge, we looked at the tools available to collect data and the various protocols with which applications can share data. We then looked at the architecture for Prometheu, and saw how Mimir takes the concepts of Prometheus and turns them into a highly scalable data processing tool, able to meet the needs of organizations of any size. Our final exploration was of Exemplars, giving us a concrete data example to add context to the aggregated data seen <span class="No-Break">in metrics.</span></p>
			<p>The next chapter will explore how traces work in Grafana Tempo, which will show you how powerful the use of exemplars and logging trace and span information can be to create a truly observable system for your <span class="No-Break">organization’s customers.</span></p>
		</div>
	</body></html>