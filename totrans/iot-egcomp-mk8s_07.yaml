- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up MetalLB and Ingress for Load Balancing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we have looked at how Kubernetes network model works and
    learned how to use Calico, Cilium, and Flannel CNI plugins to network the cluster.
    We've also gone through some of the most important factors to consider when choosing
    a CNI provider.
  prefs: []
  type: TYPE_NORMAL
- en: We should revisit the Kubernetes Service abstraction mechanism from the first
    chapter before diving into **MetalLB** load-balancer and Ingress concepts for
    load balancing. Kubernetes **Services**, in simple terms, connect a group of Pods
    to an abstracted Service name and IP address. Discovery and routing between Pods
    are provided by the Services. Services, for example, connect an application's
    frontend to its backend, which are both deployed in different cluster deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common types of Services are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ClusterIP**: This is the default type, which exposes the Service via the
    cluster''s internal IP address. These Services are only accessible within the
    cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NordPort` service, a `ClusterIP` Service is automatically created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadBalancer` type of service will create a load balancer and expose the Service
    externally. It will also automatically create `ClusterIP` and `NodePort` Services
    and route traffic accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`externalName ex.sampleapp.test.com` field by returning a value for the **Canonical
    Name** (**CNAME**) record.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most common types of Services are depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Common types of Services ](img/Figure_7.01_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Common types of Services
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get into the intricacies of MetalLB and Ingress configuration now that
    we''ve covered the basics. In this chapter, we''re going to cover the following
    main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of MetalLB and Ingress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring MetalLB to load balance across the cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Ingress to expose Services outside the cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guidelines on choosing the right load balancer for your applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of MetalLB and Ingress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite its widespread adoption, Kubernetes does not offer a load balancer implementation.
    If your Kubernetes cluster is running on a cloud platform such as Azure, `Pending`
    status indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: The `NodePort` and `externalIPs` Services are the only options for bringing
    user traffic into bare-metal clusters. Both strategies have considerable drawbacks
    when it comes to output. MetalLB solves this problem by providing an implementation
    of a network load balancer that connects with conventional network equipment,
    allowing external Services on bare-metal clusters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, MetalLB enables you to establish `LoadBalancer` Kubernetes Services
    in clusters that aren''t hosted on a cloud provider. Address allocation and external
    announcement are two characteristics that work together to deliver this Service.
    We will now see these in more detail, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address allocation**: MetalLB cannot generate IP addresses on its own; instead,
    we must provide it with IP address pools from which it can draw. As Services come
    and go, MetalLB will take care of assigning and unassigning individual addresses,
    but it will only ever distribute IPs that are part of its preset pools. Setting
    up IP address pools is based on the environment we have; for example, if you''re
    running a bare-metal cluster in a colocation facility, your hosting provider may
    provide IP addresses for lease, or if you''re running on a private **local area
    network** (**LAN**), you could choose a range of IPs from one of the private addresses
    spaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External announcement**: After assigning an external IP address to a Service,
    MetalLB must notify the network outside the cluster that the IP address is residing
    in the cluster. MetalLB accomplishes this using conventional routing protocols
    such as **Address Resolution Protocol** (**ARP**), **Neighbor Discovery Protocol**
    (**NDP**), or **Border Gateway Protocol** (**BGP**). In a **Layer 2** (**L2**)
    mode such as ARP/NDP, one node in the cluster takes ownership of the Service and
    makes those IPs visible on the local network using standard address discovery
    protocols (ARP for IPv4; NDP for IPv6); whereas in the BGP mode, all nodes in
    the cluster create BGP peering sessions with adjacent routers that you control
    in BGP mode and inform those routers how to forward traffic to the Service IPs.
    BGP''s policy mechanisms enable genuine load balancing across several nodes as
    well as fine-grained traffic control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another option is to utilize **Ingress** (Kubernetes object) to expose your
    Service. Although it acts as the cluster's entrance point, Ingress is not a Service
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The workings of Ingress are depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Workings of Ingress ](img/Figure_7.02_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Workings of Ingress
  prefs: []
  type: TYPE_NORMAL
- en: The Ingress controller aids in the consolidation of various applications' routing
    rules into a single entity. With the help of `NodePort` or `LoadBalancer`, the
    Ingress controller is exposed to the outside world. It's more suited for internal
    load balancing of `nginx` or `HAProxy`. For `LoadBalancer` kind of service, and
    MetalLB comes to our rescue in such situations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll go over how to set up MetalLB as a load balancer
    for your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring MetalLB to load balance across the cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are clear on MetalLB concepts, we will dive into the steps of configuring
    MetalLB to load balance across the cluster. The following diagram depicts our
    Raspberry Pi cluster setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – MicroK8s Raspberry Pi cluster ](img/Figure_7.03_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – MicroK8s Raspberry Pi cluster
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what we want to do, let's look at the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you begin, here are the prerequisites that are needed for building a
    Raspberry Pi Kubernetes cluster and for the configuration of a MetalLB load balancer:'
  prefs: []
  type: TYPE_NORMAL
- en: A microSD card (4 **gigabytes** (**GB**) minimum; 8 GB recommended)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A computer with a microSD card drive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Raspberry Pi 2, 3, or 4 (one or more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A micro-USB power cable (USB-C for the Pi 4)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Wi-Fi network or an Ethernet cable with an internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optional) A monitor with a **High-Definition Multimedia Interface** (**HDMI**)
    interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optional) An HDMI cable for the Pi 2 and 3 and a micro-HDMI cable for the Pi
    4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optional) A **Universal Serial Bus** (**USB**) keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've established what the requirements are, we'll go on to the step-by-step
    instructions on how to complete the process.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – Creating a MicroK8s Raspberry Pi cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please follow the steps that we covered in [*Chapter 5*](B18115_05.xhtml#_idTextAnchor070),
    *Creating and Implementing Updates on Multi-Node Raspberry Pi Kubernetes Clusters*,
    to create a MicroK8s Raspberry Pi cluster. Here''s a quick refresher:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing the **operating system** (**OS**) image to a **Secure Digital**
    (**SD**) card:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring Wi-Fi access settings
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring remote access settings
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring control group settings
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring hostname
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing and configuring MicroK8s
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a worker node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A fully functional multi-node Kubernetes cluster should look like the one shown
    in the following screenshot. To summarize, we have installed MicroK8s on the Raspberry
    Pi boards and joined multiple deployments to form a cluster. We have also added
    nodes to the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Fully functional MicroK8s Raspberry Pi cluster ](img/Figure_5.22_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Fully functional MicroK8s Raspberry Pi cluster
  prefs: []
  type: TYPE_NORMAL
- en: We can now go to the next step of enabling the MetalLB add-on, as we have a
    fully functional cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Enabling the MetalLB add-on
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MicroK8s supports a variety of add ons ([https://microk8s.io/docs/addons](https://microk8s.io/docs/addons))
    which are pre-packaged components that provide additional capabilities for your
    Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are easy to set up with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to enable the MetalLB load balancer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output indicates the MetalLB add-on has been
    enabled successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Enabling MetalLB add-on ](img/Figure_7.05_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Enabling MetalLB add-on
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve instructed MetalLB to give out addresses in the `192.168.1.10` - `192.168.1.15`
    range with this command. To check a list of available and installed add-ons, use
    the `status` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use `192.168.2.1/24` subnet, and I opted to give MetalLB
    half of the IPs. IP numbers `192.168.2.1` to `192.168.2.126` make up the first
    part of the subnet. A /25 subnet can be used to represent this range: `192.168.2.1`/`25`.'
  prefs: []
  type: TYPE_NORMAL
- en: A /25 subnet can also be used to represent the second half of the network—for
    example, `192.168.2.128`/`25`. Each half has 126 IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you choose subnets that are appropriate for your network and that
    your router and MetalLB are configured correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command execution output indicates (refer to the highlighted
    portions) that the MetalLB add-on has been enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – MicroK8s status ](img/Figure_7.06_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – MicroK8s status
  prefs: []
  type: TYPE_NORMAL
- en: 'For its components, MetalLB uses the `metallb-system` namespace. To verify
    all components are running, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output indicates that all components are in
    a `Running` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 7.7 – Components of MetalLB and their status ](img/Figure_7.07_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Components of MetalLB and their status
  prefs: []
  type: TYPE_NORMAL
- en: 'The components that you can see in the preceding command execution output of
    MetalLB are outlined in more detail here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`metallb-system/controller` (deployment): This is the IP address assignment
    controller for the entire cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metallb-system/speaker` (DaemonSet): This component communicates with Services
    using the protocol(s) of your choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've activated the MetalLB add-on, the next step is to launch an example
    application and see whether it can load balance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add-ons that have been enabled can be disabled at any time by utilizing the
    `disable` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you have a fully functional multi-node Kubernetes cluster with
    the MetalLB add-on enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Between nodes, port `7946` (TCP and UDP) must be permitted. Additionally, ensure
    that no other software is running on port `7946` on the nodes before installing
    MetalLB.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – Deploying a sample containerized application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this step, we will be deploying the following Apache web server deployment
    on our multi-node MicroJ8s cluster setup, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we deploy the web server, let''s verify the cluster nodes are ready
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output shows that all the nodes are in a `Ready`
    state. We are now ready to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Checking whether nodes are in a Ready state ](img/Figure_7.08_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Checking whether nodes are in a Ready state
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will deploy the web server application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output indicates that there is no error in
    the deployment, and in the next steps, we can verify the same using the `get deployments`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Deploying the web server ](img/Figure_7.09_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Deploying the web server
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the status of the deployment to verify the application has been deployed
    and is running by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output confirms that the deployment is `Ready`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Confirming that the deployment is ready ](img/Figure_7.10_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Confirming that the deployment is ready
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the sample web server application ready, we can test the load-balancing
    mechanism in the next part.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – Verifying the load balancer mechanism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To summarize, we've deployed a sample web server application. We'll now test
    the load-balancer mechanism in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to see whether your load balancer has been allocated
    an external IP and port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output (refer to the highlighted portions)
    shows that an external IP and port have been allocated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Checking whether external IP and port have been allocated ](img/Figure_7.11_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Checking whether external IP and port have been allocated
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that an external IP has been allocated, we can access the application using
    the external IP address from any of the nodes or from the external network, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have followed the preceding steps, you should be able to see the `<html><body><h1>It
    works!</h1></body></html>` Apache web server output, as in the following command
    execution output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Apache web server output ](img/Figure_7.12_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Apache web server output
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s scale the deployment to see whether our load balancer is still working
    properly. To do so, run the `kubectl scale` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output confirms that there is no error in the
    deployment, and in the next steps, we can verify that the deployment has five
    Pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Scaling the deployment ](img/Figure_7.13_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Scaling the deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to check the status of the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command output shows that the command was successfully run, and
    the deployment has been updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Checking deployment state ](img/Figure_7.14_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Checking deployment state
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the deployment has been updated, let''s check how the Pods are distributed
    across the nodes, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output indicates that three Pods are running
    on the `master` node, and two of them are running on `worker1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – How Pods are distributed across the nodes ](img/Figure_7.15_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – How Pods are distributed across the nodes
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check whether there is any change in the external IP and ports using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output shows that there is no change in the
    allocated external IP and port:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17 – Apache web server output ](img/Figure_7.16_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – Rechecking for any change in external IP and port
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the same `curl` command to access the application and verify it''s
    working, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_7.17_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17 – Apache web server output
  prefs: []
  type: TYPE_NORMAL
- en: The command execution output confirms that the load balancer is working properly.
    Even though the Pods are spread throughout the nodes, our web server application
    is able to effectively serve user requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the MetalLB load-balancing functionality. MetalLB
    implements the `LoadBalancer` Kubernetes Service. When a `LoadBalancer` Service
    is requested externally, MetalLB assigns an IP address from the preset range to
    the client and informs the network that the IP is residing in the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18 – MetalLB load-balancing functionality ](img/Figure_7.18_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.18 – MetalLB load-balancing functionality
  prefs: []
  type: TYPE_NORMAL
- en: 'MetalLB is configured in L2 mode by default in MicroK8s. The following command
    can be used to confirm this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output confirms that MetalLB is in L2 mode,
    and we can see the IP range as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19 – MetalLB ConfigMap ](img/Figure_7.19_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19 – MetalLB ConfigMap
  prefs: []
  type: TYPE_NORMAL
- en: To set the MetalLB in BGP mode, `ConfigMap config` needs to be reconfigured
    to set the operation mode as `BGP` and the external IP address range.
  prefs: []
  type: TYPE_NORMAL
- en: The speakers in BGP mode create a BGP peering with routers outside of the cluster
    and instruct those routers on how to redirect traffic to the Service IPs. BGP's
    policy mechanisms enable genuine load balancing across several nodes, as well
    as fine-grained traffic control.
  prefs: []
  type: TYPE_NORMAL
- en: You can utilize ordinary router hardware with BGP as a load-balancing method.
    It does, however, have some drawbacks. More information regarding these limits,
    as well as ways to overcome them, may be found on the MetalLB BGP documentation
    page ([https://metallb.universe.tf/configuration/#bgp-configuration](https://metallb.universe.tf/configuration/#bgp-configuration)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, MetalLB enables you to establish Kubernetes `LoadBalancer` Services
    without requiring your cluster to be deployed on a cloud platform. MetalLB provides
    two modes of operation: a basic L2 mode that requires no external hardware or
    configuration, and a BGP mode that is more robust and production-ready but necessitates
    more network setup tasks. In the next section, we will look at how to use the
    `Ingress` method for load-balancing configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Ingress to expose Services outside the cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in the *Overview of MetalLB and Ingress* section, Ingress offers
    HTTP and HTTPS routes to Services within the cluster from outside the cluster.
    Rules defined on Ingress control traffic routing. NGINX Ingress Controller is
    a common Kubernetes Ingress and the default Ingress controller for MicroK8s as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is employing a load balancer such as MetalLB that can be deployed
    in the same Kubernetes cluster, and the Services can then be exposed to an external
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'A diagrammatic illustration of both approaches is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20 – Ingress load-balancing functionality ](img/Figure_7.20_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 – Ingress load-balancing functionality
  prefs: []
  type: TYPE_NORMAL
- en: Both options are discussed in more depth in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Option 1 – Using the Ingress NodePort method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this option and the next, we'll use the same MicroK8s Raspberry Pi cluster
    that we built for the MetalLB setup.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – Enabling the Ingress add-on
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Ingress add-on can be enabled using the same command that we used to enable
    MetalLB, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output indicates the Ingress add-on has been
    enabled successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21 – Enabling Ingress add-on ](img/Figure_7.21_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.21 – Enabling Ingress add-on
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Ingress add-on has been enabled, the next step is to deploy a sample
    application to test the load-balancing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Deploying a sample containerized application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll apply the following `whoami` deployment on our multi-node MicroK8s cluster,
    which is a Tiny Go web server that prints OS information and HTTP requests to
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will deploy the `whoami` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output indicates that there is no error in
    the deployment, and in the next steps, we can verify this by using the `get deployments`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22 – Deploying the whoami application ](img/Figure_7.22_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.22 – Deploying the whoami application
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the status of the deployment to verify the application has been deployed
    and is running by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output indicates that the deployment is `Ready`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23 – Checking the deployment status ](img/Figure_7.23_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.23 – Checking the deployment status
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to check whether an Ingress object has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command indicates that an Ingress object with the
    name `whoami-ingress` has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24 – Checking the Ingress object that we created ](img/Figure_7.24_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.24 – Checking the Ingress object that we created
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `describe` command to view detailed information about the Ingress object
    we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.25 – Ingress describe command to check details on Ingress object
    created ](img/Figure_7.25_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.25 – Ingress describe command to check details on Ingress object created
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command execution output, here is what each field represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Host`: Because no host is mentioned in the previous output, the rule applies
    to all inbound HTTP traffic via the provided IP address. The rules apply to that
    site if a host (for example, `foo.com`) is supplied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Path`: List of routes (for example, `/whoami`) with a backend described by
    a `service.name` and a `service.port.name` or `service.port.number`. Before the
    load balancer distributes traffic to the specified Service, the host and path
    must match the content of an incoming request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Backends`: The Service describes a backend as a combination of Service and
    port names. The mentioned backend receives HTTP (and HTTPS) requests to the Ingress
    object that matches the rule''s host and path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information on Ingress, please refer to the Ingress Kubernetes documentation
    at the following link: [https://kubernetes.io/docs/concepts/services-networking/ingress/](https://kubernetes.io/docs/concepts/services-networking/ingress/).'
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – Verifying the load balancer mechanism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the `curl` command to check whether you can access the application, as
    illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26 – Accessing the deployed application ](img/Figure_7.26_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.26 – Accessing the deployed application
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s scale the deployment to see whether our load balancer is working properly.
    To do so, run the `kubectl scale` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output confirms that there is no error in the
    deployment, and in the next steps, let''s check how the Pods are distributed across
    the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.27 – Scaling the deployment ](img/Figure_7.27_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.27 – Scaling the deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command execution output indicates that two Pods are running
    on the `master` node, and three of them are running on `worker1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.28 – Checking how the Pods are distributed across nodes ](img/Figure_7.28_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.28 – Checking how the Pods are distributed across nodes
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the same `curl` command to access the application and verify it''s
    working, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.29 – Rechecking whether the load balancer is working properly ](img/Figure_7.29_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.29 – Rechecking whether the load balancer is working properly
  prefs: []
  type: TYPE_NORMAL
- en: The command execution output confirms that the load balancer is working properly.
    Even though the Pods are spread throughout the nodes, our `whoami` application
    is able to effectively serve user requests.
  prefs: []
  type: TYPE_NORMAL
- en: Option 2 – Using Ingress and a load balancer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this method, we must have a load balancer for the Kubernetes cluster in order
    to proceed. Since we already have an installed MetalLB load balancer configured,
    we will be reusing it. However, we will have to define a simple load balancer
    Service for our sample `whoami` application to make sure it's acquiring the external
    IP and port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the simple load balancer Service deployment of the `whoami`
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will deploy the preceding application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command output shows that the command was successfully run and
    a load balancer has been created. We will confirm the same in the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.30 – Created load-balancer Service ](img/Figure_7.30_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.30 – Created load-balancer Service
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to check whether a load balancer Service has been
    created and an external IP and port have been allocated. You won''t acquire an
    IP address for `EXTERNAL-IP` if a load balancer isn''t available. Instead, it''s
    marked as `<pending>`. In this situation, check the availability of your load
    balancer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command output shows that an external IP and port have been allocated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.31 – Load balancer has allocated external IP and port ](img/Figure_7.31_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.31 – Load balancer has allocated external IP and port
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that an external IP has been allocated, we can access the application from
    any of the nodes or from an external network, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command output shows that the command was successfully run and
    the load balancer is working properly. Though the application is spread throughout
    the nodes, our `whoami` application is able to effectively serve user requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.32 – Checking whether the load balancer is working properly ](img/Figure_7.32_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.32 – Checking whether the load balancer is working properly
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, Kubernetes provides several ways to expose Services to the outside
    world. `LoadBalancer` and Ingress controllers are the most common choices. We
    have explored both options with examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines on how to choose the right load balancer for your applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've gone over choices, it would be useful to have a cheat sheet to
    rapidly compare some crucial features to assist us in deciding which one to utilize.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following table, we will cover some of the important parameters in choosing
    the right option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 7.1 – How to choose the right load balancer ](img/B18115_07_Table_7.1a.jpg)![Table
    7.1 – How to choose the right load balancer ](img/B18115_07_Table_7.1b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 7.1 – How to choose the right load balancer
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, it all boils down to a few choices. When using `LoadBalancer`,
    especially on bare metal, it works great because the Service can choose which
    port it wishes to use. The disadvantage is that it can be costly, as each Service
    will have its own load balancer and external IP address, both of which cost money
    in the cloud environment. Ingress is becoming the most popular Service when connected
    with a MetalLB load balancer because it reduces the number of IPs used while still
    allowing each service to have its own name and/or **Uniform Resource Identifier**
    (**URI**) routing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at techniques for exposing Services outside the cluster
    and we've seen how load balancers can expose applications to the outside network.
    Incoming requests are routed to your application using a load balancer's single
    IP address. MetalLB implements the `LoadBalancer` Kubernetes service. When a `LoadBalancer`
    Service is requested, MetalLB assigns an IP address from a preset range to the
    client and informs the network that the IP resides in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen the NGINX Ingress Controller option, which is a common Kubernetes
    Ingress option. MetalLB, which can be deployed in the same Kubernetes cluster
    along with Ingress, can also be used as a load balancer. `NodePort` is another
    way to expose the Ingress controller to the outside world. Both options were discussed
    in this chapter, along with different examples.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be covering how to monitor the health of infrastructure
    and applications using tools such as Prometheus, Grafana, Elastic, Fluentd, Kibana,
    and Jaeger. You will also learn how to configure and access the various dashboards/metrics.
  prefs: []
  type: TYPE_NORMAL
