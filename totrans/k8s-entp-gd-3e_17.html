<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer291">
<h1 class="chapterNumber">17</h1>
<h1 class="chapterTitle" id="_idParaDest-564">Building and Deploying Applications on Istio</h1>
<p class="normal">In the previous chapter, we deployed Istio and Kiali into our cluster. We also deployed an example application to see how the pieces fit together. In this chapter, we’re going to look at what it takes to build applications that will run on Istio. We’ll start by examining the differences between microservices and monolithic applications. Then, we’ll deploy a monolithic application on Istio and move on to building microservices that will run on Istio. This chapter will cover the following main topics:</p>
<ul>
<li class="bulletList">Comparing microservices and monoliths</li>
<li class="bulletList">Deploying a monolith</li>
<li class="bulletList">Building a microservice</li>
<li class="bulletList">Do I need an API gateway?</li>
</ul>
<p class="normal">Once you have completed this chapter, you’ll have a practical understanding of the difference between a monolith and a microservice, along with the information you’ll need to determine which one is best for you, and you will also have deployed a secured microservice in Istio.</p>
<h1 class="heading-1" id="_idParaDest-565">Technical requirements</h1>
<p class="normal">To run the examples in this chapter, you’ll need:</p>
<ul>
<li class="bulletList">A running cluster with Istio deployed, as outlined in <em class="chapterRef">Chapter 16</em>, <em class="italic">An Introduction to Istio</em>.</li>
<li class="bulletList">Scripts from this book’s GitHub repository.</li>
</ul>
<p class="normal">You can access the code for this chapter by going to this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter17"><span class="url">https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter17</span></a>.</p>
<h1 class="heading-1" id="_idParaDest-566">Comparing microservices and monoliths</h1>
<p class="normal">Before we dive too deeply into code, we should spend some time discussing the differences between microservices and monolithic architecture. The microservices versus monolithic architecture debate is as old as computing itself (and the theory is probably even older). Understanding how these two approaches relate to each other and your problem set will help you decide which one to use.</p>
<h2 class="heading-2" id="_idParaDest-567">My history with microservices versus monolithic architecture</h2>
<p class="normal">Before<a id="_idIndexMarker1604"/> we get into the microservices versus monoliths discussion, I wanted to share my own history. I doubt it’s unique, but it does frame my outlook on the discussion and adds some context to the recommendations in this chapter.</p>
<p class="normal">My introduction to this discussion was when I was a computer science student in college and had started using Linux and open source. One of my favorite books, <em class="italic">Open Sources: Voices from the Open Source Revolution</em>, had an appendix on the debate between Andrew Tanenbaum and Linus Torvalds on microkernels versus monolithic kernels. Tanenbaum was the inventor of Minix, and a proponent of a minimalist kernel, with most of the functionality in user space. Linux, instead, uses a monolithic kernel design, where much more is done in the kernel. If you’ve ever run <code class="inlineCode">modprobe</code> to load a driver, you’re interacting with the kernel! The entire thread is available at <a href="https://www.oreilly.com/openbook/opensources/book/appa.xhtml"><span class="url">https://www.oreilly.com/openbook/opensources/book/appa.xhtml</span></a>.</p>
<p class="normal">Linus’ core argument was that a well-managed monolith was much easier to maintain than a microkernel.</p>
<p class="normal">Tanenbaum instead pointed to the idea that microkernels were easier to port and that most “modern” kernels were microkernels. Windows (at the time, Windows NT) is probably the most prevalent microkernel today. As a software developer, I’m constantly trying to find the smallest unit I can build. The microkernel architecture really appealed to that aspect of my talents.</p>
<p class="normal">At the same time, I was starting my career in IT, primarily as a Windows developer in the data management and analysis space. I spent most of my time working with <strong class="keyWord">ASP</strong> (<strong class="keyWord">Active Server Pages</strong>, Microsoft’s version of PHP), Visual Basic, and SQL Server. I tried to convince my bosses that we should move off of a <a id="_idIndexMarker1605"/>monolithic application design to <a id="_idIndexMarker1606"/>use <strong class="keyWord">MTS</strong> (<strong class="keyWord">Microsoft Transaction Server</strong>). MTS was my first exposure to what we would call today a distributed application. My bosses and mentors all pointed out that our costs, and so our customers’ costs, would go through the roof if we injected the additional infrastructure for no benefit other than a cleaner code base. There was nothing we were working on that <a id="_idIndexMarker1607"/>couldn’t be accomplished with our tightly bound trio of ASP, Visual Basic, and SQL Server at a much lower cost.</p>
<p class="normal">I later moved from data management to identity management. I also switched from Microsoft to Java. One of my first projects was to deploy an identity management vendor’s product that was built using a distributed architecture. At the time, I thought it was great, until I started trying to debug issues and trace down problems across dozens of log files. I quickly started using another vendor’s product that was built as a monolith. Deployments were slow, as they required a full recompile, but otherwise, management was much easier, and it scaled every bit as well. We found that a distributed architecture didn’t help because identity management was done by such a centralized team that having a monolith didn’t impact productivity or management. The benefits of distributing implementation just didn’t outweigh the additional complexity.</p>
<p class="normal">Fast forward to the founding of Tremolo Security. This was in 2010, so it was before Kubernetes and Istio came along. At the time, virtual appliances were all the rage! We decided OpenUnison would take the monolithic approach because we wanted to make it easier to deploy and upgrade. In <em class="chapterRef">Chapter 6</em>, <em class="italic">Integrating Authentication into Your Cluster</em>, we deployed OpenUnison with some Helm charts to layer on different configurations. How much harder would it have been had there been an authentication service to install, a directory service, a just-in-time provisioning service, etc.? It made for a much simpler deployment having one system.</p>
<p class="normal">With all that said, it’s not that I’m anti-microservice—I’m not! When used correctly, it’s an incredibly powerful architecture used by many of the world’s largest companies. I’ve learned through the years that if it’s not the right architecture for your system, it will considerably impact your ability to deliver. Now that I’ve filled you in on my own journey through architectures, let’s take a deeper look at the differences between microservices and monoliths.</p>
<h2 class="heading-2" id="_idParaDest-568">Comparing architectures in an application</h2>
<p class="normal">First, let’s talk about what these two architecture approaches each do in a common example application, a storefront.</p>
<h3 class="heading-3" id="_idParaDest-569">Monolithic application design</h3>
<p class="normal">Let’s say <a id="_idIndexMarker1608"/>you have an online store. Your store will likely need a product lookup service, a shopping cart, a payment system, and a shipping system. This is a vast oversimplification of a storefront application, but the point of the discussion is how to break up development and not how to build a storefront. There are two ways you could approach building this application. The first is you could build a monolithic application where all the code for each service is stored and managed in the same tree. Your application infrastructure would probably look something like this:</p>
<figure class="mediaobject"><img alt="A diagram of a storefront application  Description automatically generated" height="351" src="../Images/B21165_17_01.png" width="673"/></figure>
<p class="packt_figref">Figure 17.1: Monolithic application architecture</p>
<p class="normal">In our application, we have a single system with multiple modules. Depending on your programming language of choice, these could be classes, structs, or other forms of code module. A central application manages the user’s interaction with this code. This would likely be a web frontend with the modules being server-side code, written up as web services or a post/response-style app.</p>
<p class="normal">Yes, web <a id="_idIndexMarker1609"/>services can be used in a monolith! These modules likely need to store data, usually in some kind of a database. Whether it’s a relational database, a document database, or a series of databases isn’t really important.</p>
<p class="normal">The biggest advantage to this monolithic architecture is it’s relatively simple to manage and have the systems interact with each other. If the user wants to do a product search, the storefront will likely just execute some code like the following:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">list_of_products</span> <span class="hljs-string">=</span> <span class="hljs-string">products.search(search_criteria);</span>
<span class="hljs-string">display(list_of_products);</span>
</code></pre>
<p class="normal">The application code only needs to know the interface of the services it’s going to call. There’s no need to “authenticate” that call from the application controller to the product directory module. There’s no concern with creating rate-limiting systems or trying to work out which version of the service to use. Everything is tightly bound. If you make an update to any system, you know pretty quickly if you broke an interface, since you’re likely using a development tool that will tell you when module interfaces break. Finally, deployment is usually pretty simple. You upload your code to a deployment service (or create a container… this is a Kubernetes book!).</p>
<p class="normal">What happens if you need to have one developer update your ordering system while another developer updates your payment system? They each have their own copies of the code that need to be merged. After merging, the changes from both branches need to be reconciled before deployment. This may be fine for a small system, but as your storefront grows, this can become cumbersome to the point of being unmanageable.</p>
<p class="normal">Another potential issue is, what if there’s a better language or system to build one of these services in than the overall application? I’ve been on multiple projects over the years where Java was a great choice for certain components, but C# had better APIs for others. Maybe one service team was built around Python and another on Ruby. Standardization is all well and good, but you wouldn’t use the butt end of a screwdriver to drive in a nail for the sake of standardization, would you?</p>
<p class="normal">This argument doesn’t pertain to frontend versus backend. An application with a JavaScript frontend and a Golang backend can still be a monolithic application. Both the Kubernetes Dashboard and Kiali are examples of monolithic applications built on service APIs across different languages. Both have HTML and JavaScript frontends, while their backend APIs are written in Golang.</p>
<h3 class="heading-3" id="_idParaDest-570">Microservices design</h3>
<p class="normal">What if we<a id="_idIndexMarker1610"/> broke these modules up into services? Instead of having one single source tree, we would break our application up into individual services like the following:</p>
<figure class="mediaobject"><img alt="A diagram of a storefront application  Description automatically generated" height="382" src="../Images/B21165_17_02.png" width="756"/></figure>
<p class="packt_figref">Figure 17.2: Simple microservices architecture</p>
<p class="normal">This doesn’t look that much more complex. Instead of a big box, there’s a bunch of lines. Let’s zoom in on the call from our frontend to our product lookup service:</p>
<figure class="mediaobject"><img alt="A picture containing text, screenshot, diagram, design  Description automatically generated" height="598" src="../Images/B21165_17_03.png" width="513"/></figure>
<p class="packt_figref">Figure 17.3: Service call architecture</p>
<p class="normal">It’s no longer a simple <a id="_idIndexMarker1611"/>function or method call. Now, our storefront controller needs to determine where to send the service call, and this will likely change in each environment. It also needs to inject some kind of authentication token, since you wouldn’t want just anyone calling your services. Since the remote service no longer has a local code representation, you’ll either need to build the call manually or use a schema language to describe your product listing service, combining it with a client binding. Once the call is made, the service needs to validate the call’s schema and apply security rules for authentication and authorization. Once the response is packaged and sent back to our storefront controller, the controller needs to validate the schema of the response. If there’s a failure, it needs to decide if it’s going to retry or not.</p>
<p class="normal">Combine all this additional complexity with version management. Which version of the product lookup service should our storefront use? Are other services tightly coupled together? There are several benefits to the microservices approach, as we discussed earlier, in terms of version and deployment management. These advantages come with the cost of additional complexity.</p>
<h3 class="heading-3" id="_idParaDest-571">Choosing between monoliths and microservices</h3>
<p class="normal">Which of these two approaches is right for you? That really depends. What does your team look like? What are your management needs? Do you need the flexibility that comes from microservices or will a monolith’s simpler design make for an easier-to-manage system?</p>
<p class="normal">One of the major<a id="_idIndexMarker1612"/> benefits of a microservice architecture is that you can have multiple teams working on their own code without having to share the same source repository. Before assuming that breaking the services into their own source repositories will benefit your team, how closely tied are the services? If there are numerous interdependencies, then your microservices are really just a distributed monolith, and you may not get the benefits of different repositories. It may be easier to manage branches and merge them.</p>
<p class="normal">Also, will your services need to be called by other systems? Look at the cluster we built in the last chapter. Kiali has its own services, but they’re not likely to be used by other applications. Jaeger and Prometheus, however, do have services that are used by Kiali, even if those systems have their own frontends too. In addition to these services, Kiali uses the Kubernetes API. All these components are deployed separately and are managed separately. They need to be upgraded on their own, monitored, and so on. This can be a management headache because each system is independently managed and maintained. That said, it wouldn’t make any sense for the Kiali team to re-implement Prometheus and Jaeger in their own project. It also wouldn’t make sense to just import the entire source tree for these projects and be forced to keep them up to date.</p>
<h3 class="heading-3" id="_idParaDest-572">Using Istio to help manage microservices</h3>
<p class="normal">We’ve spent <a id="_idIndexMarker1613"/>quite a bit of time talking about microservices and monoliths without talking about Istio. Earlier in this chapter, <em class="italic">Figure 17.3 </em>pointed out decisions that were needed by our microservice before we could get to calling our code.</p>
<p class="normal">These should look familiar because we covered objects from Istio that service most of these needs in the last chapter! Istio can remove our need to write code to authenticate and authorize clients, discover where services are running, and manage traffic routing. Throughout the rest of this chapter, we’re going to walk through building a small application off<a id="_idIndexMarker1614"/> of a microservice, using Istio to leverage these common services without having to build them into our code.</p>
<p class="normal">So far, we’ve looked at the differences between monoliths and microservices, and how those differences interact with Istio at a conceptual level. Next, we’ll see how a monolith is deployed into Istio.</p>
<h1 class="heading-1" id="_idParaDest-573">Deploying a monolith</h1>
<p class="normal">This chapter is <a id="_idIndexMarker1615"/>about microservices, so why are we starting with deploying monoliths in Istio? The first answer is, because we can! There’s no reason to not get the benefits of Istio’s built-in capabilities when working with monoliths in your cluster. Even though it’s not a “microservice,” it’s still good to be able to trace through application requests, manage deployments, and so on. The second answer is, because we need to. Our microservice will need to know which user in our enterprise is calling it. To do that, Istio will need a JWT to validate. We’ll use OpenUnison to generate JWTs first so that we can call our service manually, and then so we can authenticate users from a frontend and allow it to call our service securely.</p>
<p class="normal">Starting with your cluster from <em class="chapterRef">Chapter 16</em>, we’re now going to deploy OpenUnison. Go to the <code class="inlineCode">chapter17/openunison-istio</code> directory and run <code class="inlineCode">deploy_openunison_istio.sh</code>:</p>
<pre class="programlisting con"><code class="hljs-con">cd chapter17/openunison-istio
./deploy_openunison_istio.sh
</code></pre>
<p class="normal">This is going to take a while to run. This script does a few things:</p>
<ol>
<li class="numberedList" value="1">Deploys <code class="inlineCode">cert-manager</code> with our enterprise CA.</li>
<li class="numberedList">Deploys all of the OpenUnison components (including our testing Active Directory) for impersonation, so we don’t need to worry about updating the API server for SSO to work.</li>
<li class="numberedList">Labels the <code class="inlineCode">openunison</code> namespace with <code class="inlineCode">istio-injection: enabled</code>. This tells Istio to enable sidecar injection for all pods. You can do this manually by running <code class="inlineCode">kubectl label ns openunison istio-injection=enabled</code>.</li>
<li class="numberedList">Creates all of our Istio objects for us (we’ll go into the details of these next).</li>
<li class="numberedList">Creates an <code class="inlineCode">ou-tls-certificate</code> Certificate in the the <code class="inlineCode">istio-system</code> namespace. Again, we’ll dive into the details as to why in the next section.</li>
</ol>
<p class="normal">Once the script is run, we’re able to now log in to our monolith! Just like in <em class="chapterRef">Chapter 6</em>, <em class="italic">Integrating Authentication into Your Cluster</em>, go to <code class="inlineCode">https://k8sou.apps.XX-XX-XX-XX.nip.io/</code> to log in, where <code class="inlineCode">XX-XX-XX-XX</code> is your host’s IP address.</p>
<p class="normal">For instance, my <a id="_idIndexMarker1616"/>host runs on <code class="inlineCode">192.168.2.114</code>, so my URL is <code class="inlineCode">https://k8sou.apps.192-168-2-114.nip.io/</code>. Again, as in <em class="chapterRef">Chapter 6</em>, the username is <code class="inlineCode">mmosley</code> and the password is <code class="inlineCode">start123</code>.</p>
<p class="normal">Now that our monolith is deployed, let’s walk through the Istio-specific configuration as it relates to our deployment.</p>
<h2 class="heading-2" id="_idParaDest-574">Exposing our monolith outside our cluster</h2>
<p class="normal">Our OpenUnison is<a id="_idIndexMarker1617"/> running, so let’s look at the objects that expose it to our network. There are two main objects that do this work: <code class="inlineCode">Gateway</code> and <code class="inlineCode">VirtualService</code>. These objects were created when we installed OpenUnison. How these objects are configured was described in <em class="chapterRef">Chapter 16</em>, <em class="italic">An Introduction to Istio</em>. Then, we’ll look at running instances to show how they grant access. First, let’s look at the important parts of our gateways. There are two. The first one, <code class="inlineCode">openunison-gateway-orchestra</code>, handles access to the OpenUnison portal and the Kubernetes Dashboard:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Gateway</span>
<span class="hljs-attr">metadata:</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">istio:</span> <span class="hljs-string">ingressgateway</span>
  <span class="hljs-attr">servers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">k8sou.apps.192-168-2-114.nip.io</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">k8sdb.apps.192-168-2-114.nip.io</span>
    <span class="hljs-attr">port:</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>
      <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTP</span>
    <span class="hljs-attr">tls:</span>
      <span class="hljs-attr">httpsRedirect:</span> <span class="hljs-literal">true</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">k8sou.apps.192-168-2-114.nip.io</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">k8sdb.apps.192-168-2-114.nip.io</span>
    <span class="hljs-attr">port:</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">https-443</span>
      <span class="hljs-attr">number:</span> <span class="hljs-number">443</span>
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTPS</span>
    <span class="hljs-attr">tls:</span>
      <span class="hljs-attr">credentialName:</span> <span class="hljs-string">ou-tls-certificate</span>
      <span class="hljs-attr">mode:</span> <span class="hljs-string">SIMPLE</span>
</code></pre>
<p class="normal">The <code class="inlineCode">selector</code> tells Istio which <code class="inlineCode">ingress-ingressgateway</code> pod to work with. The default gateway deployed to <code class="inlineCode">istio-system</code> has the label <code class="inlineCode">istio: ingressgateway</code>, which will match this one. You could run multiple gateways, using this section to determine which one you want to expose your service to. This is useful if you have multiple networks with different traffic or if you want to separate traffic between applications on a cluster.</p>
<p class="normal">The first<a id="_idIndexMarker1618"/> entry in the <code class="inlineCode">servers</code> list tells Istio that if a request comes on HTTP to port <code class="inlineCode">80</code> for either of our hosts, then we want Istio to send a redirect to the HTTPS port. This is a good security practice, so folks, don’t try to bypass HTTPS. The second entry in <code class="inlineCode">servers</code> tells Istio to accept HTTPS connections on port <code class="inlineCode">443</code>, using the certificate in the <code class="inlineCode">Secret</code> named <code class="inlineCode">ou-tls-certificate</code>. This <code class="inlineCode">Secret</code> must be a TLS <code class="inlineCode">Secret</code> and be in the same namespace as the pod running the ingress gateway. For our cluster, this means that <code class="inlineCode">ou-tls-certificate</code> <em class="italic">MUST</em> be in the <code class="inlineCode">istio-system</code> namespace. That’s why our deployment script created the wild card certificate in the <code class="inlineCode">istio-system</code> namespace. This is different from using an <code class="inlineCode">Ingress</code> object with NGINX, where you keep the TLS <code class="inlineCode">Secret</code> in the same namespace as your <code class="inlineCode">Ingress</code> object.</p>
<p class="normal">If you don’t include your <code class="inlineCode">Secret</code> in the correct namespace, it can be difficult to debug. The first thing you’ll notice is that when you try to connect to your host, your browser will report that the connection has been reset. This is because Istio doesn’t have a certificate to serve. Kiali won’t tell you there’s a configuration issue, but looking at the <code class="inlineCode">istiod</code> pod in <code class="inlineCode">istio-system</code>'s logs, you’ll find <code class="inlineCode">failed to fetch key and certificate for kubernetes://secret-name</code>, where <code class="inlineCode">secret-name</code> is the name of your <code class="inlineCode">Secret</code>. Once you copy your <code class="inlineCode">Secret</code> into the correct namespace, your app will start working on HTTPS.</p>
<p class="normal">The second Gateway, <code class="inlineCode">openunison-api-gateway-orchestra</code>, is used to expose OpenUnison directly via HTTPS for the API server host. This bypasses most of Istio’s built-in functionality, so it’s not something we’ll want to do unless needed. The important difference in this Gateway versus our other Gateway is how we configure TLS:</p>
<pre class="programlisting code"><code class="hljs-code">  <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">k8sapi.192-168-2-114.nip.io</span>
    <span class="hljs-attr">port:</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">https-443</span>
      <span class="hljs-attr">number:</span> <span class="hljs-number">443</span>
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTPS</span>
    <span class="hljs-attr">tls:</span>
<span class="code-highlight"><strong class="hljs-slc">      </strong><strong class="hljs-attr-slc">mode:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">PASSTHROUGH</strong></span>
</code></pre>
<p class="normal">We <a id="_idIndexMarker1619"/>use <code class="inlineCode">PASSTHROUGH</code> as the <code class="inlineCode">mode</code> instead of <code class="inlineCode">SIMPLE</code>. This tells Istio to not bother trying to decrypt the HTTPS request and, instead, send it downstream. We have to do this for the Kubernetes API calls because Envoy doesn’t support the SPDY protocol used by kubectl for <code class="inlineCode">exec</code>, <code class="inlineCode">cp</code>, and <code class="inlineCode">port-forward</code>, so we need to bypass it. This, of course, means that we lose much of Istio’s capabilities, so it’s not something we want to do if we can avoid it.</p>
<p class="normal">While the <code class="inlineCode">Gateway</code> objects tell Istio how to listen for connections, the <code class="inlineCode">VirtualService</code> objects tell Istio where to send the traffic to. Just like with the <code class="inlineCode">Gateway</code> objects, there are two <code class="inlineCode">VirtualService</code> objects. The first object handles traffic for both the OpenUnison portal and the Kubernetes Dashboard. Here are the important parts:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">gateways:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">openunison-gateway-orchestra</span>
  <span class="hljs-attr">hosts:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">k8sou.apps.192-168-2-114.nip.io</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">k8sdb.apps.192-168-2-114.nip.io</span>
  <span class="hljs-attr">http:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">match:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span>
        <span class="hljs-attr">prefix:</span> <span class="hljs-string">/</span>
    <span class="hljs-attr">route:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span>
        <span class="hljs-attr">host:</span> <span class="hljs-string">openunison-orchestra</span>
        <span class="hljs-attr">port:</span>
          <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>
</code></pre>
<p class="normal">The <code class="inlineCode">gateways</code> section tells Istio which <code class="inlineCode">Gateway</code> objects to link this to. You could, in theory, have multiple Gateways as sources for traffic. The <code class="inlineCode">hosts</code> section tells Istio which hostnames to apply this configuration to, with the <code class="inlineCode">match</code> section telling Istio what conditions to match requests on. This section can provide quite a bit of power for routing microservices, but for monoliths, just <code class="inlineCode">/</code> is usually good enough.</p>
<p class="normal">Finally, the <code class="inlineCode">route</code> section tells Istio where to send the traffic. <code class="inlineCode">destination.host</code> is the name of the <code class="inlineCode">Service</code> you want to send the traffic to. We’re sending all traffic to port <code class="inlineCode">80</code> (sort of).</p>
<p class="normal">The NGINX <code class="inlineCode">Ingress</code> version <a id="_idIndexMarker1620"/>of this configuration sent all traffic to OpenUnison’s HTTPS port (<code class="inlineCode">8443</code>). This meant that all data was encrypted over the wire from the user’s browser, all the way to the OpenUnison pod. We’re not doing that here because we’re going to rely on mTLS from Istio’s sidecar.</p>
<p class="normal">Even though we’re sending traffic to port <code class="inlineCode">80</code> using HTTP, the traffic will be encrypted from when it leaves the <code class="inlineCode">ingressgateway</code> pod until it arrives at the sidecar on our OpenUnison pod that intercepts all of OpenUnison’s inbound network connections. There’s no need to configure TLS explicitly!</p>
<p class="normal">Now that we’re routing traffic from our network to OpenUnison, let’s tackle a common requirement of monolithic applications: sticky sessions.</p>
<h2 class="heading-2" id="_idParaDest-575">Configuring sticky sessions</h2>
<p class="normal">Most<a id="_idIndexMarker1621"/> monolithic applications require sticky sessions. Enabling sticky sessions means that every request in a session is sent to the same pod. This is generally not needed in microservices because each API call is distinct. Web applications that users interact with generally need to manage state, usually via cookies. However, those cookies don’t generally store all of the session’s state because they would get too big and would likely have sensitive information. Instead, most web applications use a cookie that points to a session that’s saved on the server, usually in memory. While there are ways to make sure that this session is available to any instance of the application in a highly available way, it’s not very common to do so. These systems are expensive to maintain and are generally not worth the work.</p>
<p class="normal">OpenUnison is no different than most other web applications and needs to make sure that sessions are sticky to the pod they originated from. To tell Istio how we want sessions to be managed, we use <code class="inlineCode">DestinationRule</code>. The <code class="inlineCode">DestinationRule</code> objects tell Istio what to do about traffic routed to a host by a <code class="inlineCode">VirtualService</code>. Here are the important parts of ours:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">host:</span> <span class="hljs-string">openunison-orchestra</span>
  <span class="hljs-attr">trafficPolicy:</span>
    <span class="hljs-attr">loadBalancer:</span>
      <span class="hljs-attr">consistentHash:</span>
        <span class="hljs-attr">httpCookie:</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">openunison-orchestra</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/</span>
          <span class="hljs-attr">ttl:</span> <span class="hljs-string">0s</span>
    <span class="hljs-attr">tls:</span>
      <span class="hljs-attr">mode:</span> <span class="hljs-string">ISTIO_MUTUAL</span>
</code></pre>
<p class="normal">The <code class="inlineCode">host</code> in<a id="_idIndexMarker1622"/> the rule refers to the target (<code class="inlineCode">Service</code>) of the traffic, not the hostname in the original URL. <code class="inlineCode">spec.trafficPolicy.loadBalancer.consistentHash</code> tells Istio how we want to manage stickiness. Most monolithic applications will want to use cookies. <code class="inlineCode">ttl</code> is set to <code class="inlineCode">0s</code>, so the cookie is considered a “session cookie.” This means that when the browser is closed, the cookie disappears from its cookie jar.</p>
<p class="normal">You should avoid cookies with specific times to live. These cookies are persisted by the browser and can be treated as a security risk by your enterprise.</p>
<p class="normal">With OpenUnison up and running and understanding how Istio is integrated, let’s take a look at what Kiali will tell us about our monolith.</p>
<h2 class="heading-2" id="_idParaDest-576">Integrating Kiali and OpenUnison</h2>
<p class="normal">First, let’s integrate OpenUnison <a id="_idIndexMarker1623"/>and Kiali. Kiali, like any other cluster management system, should be configured to<a id="_idIndexMarker1624"/> require access. Kiali, just like the Kubernetes <a id="_idIndexMarker1625"/>Dashboard, can integrate with Impersonation so that Kiali will interact with the API server, using the user’s own permissions. Doing this is pretty straight forward. We created a script in the <code class="inlineCode">chapter17/kiali</code> folder called <code class="inlineCode">integrate-kiali-openunison.sh</code> that:</p>
<ol>
<li class="numberedList" value="1">Deletes the old Gateways and VirtualServices for Kiali, Prometheus, Jaeger, and Grafana.</li>
<li class="numberedList">Updates Grafana to accept a header for SSO from OpenUnison.</li>
<li class="numberedList">Updates the Kiali Helm chart to use <code class="inlineCode">header</code> for <code class="inlineCode">auth.strategy</code> and restarts Kiali to pick up the changes.</li>
<li class="numberedList">Redeploys OpenUnison with Kiali, Prometheus, Jaeger, and Grafana integrated for SSO.</li>
</ol>
<p class="normal">The integration works the same way as the dashboard, but if you’re interested in the details, you can read about them at <a href="https://openunison.github.io/applications/kiali/"><span class="url">https://openunison.github.io/applications/kiali/</span></a>.</p>
<p class="normal">With the<a id="_idIndexMarker1626"/> integration completed, let’s <a id="_idIndexMarker1627"/>see what Kiali can tell us about our <a id="_idIndexMarker1628"/>monolith. First, log in to OpenUnison. You’ll see new badges on the portal screen:</p>
<figure class="mediaobject"><img alt="Graphical user interface, application, logo, company name  Description automatically generated" height="530" src="../Images/B21165_17_04.png" width="878"/></figure>
<p class="packt_figref">Figure 17.4: OpenUnison portal with the Kiali, Prometheus, Grafana, and Jaeger badges</p>
<p class="normal">Next, click on the <strong class="screenText">Kiali</strong> badge to open Kiali, then click on <strong class="screenText">Graphs</strong>, and choose the <strong class="screenText">openunison</strong> namespace. You’ll see a graph similar to the following:</p>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated with medium confidence" height="308" src="../Images/B21165_17_05.png" width="873"/></figure>
<p class="packt_figref">Figure 17.5: OpenUnison graph in Kiali</p>
<p class="normal">You can <a id="_idIndexMarker1629"/>now view the connections<a id="_idIndexMarker1630"/> between OpenUnison, <code class="inlineCode">apacheds</code>, and other <a id="_idIndexMarker1631"/>containers the same way you would with a microservice! Speaking of which, now that we’ve learned how to integrate a monolith into Istio, let’s build a microservice and learn how it integrates with Istio.</p>
<h1 class="heading-1" id="_idParaDest-577">Building a microservice</h1>
<p class="normal">We <a id="_idIndexMarker1632"/>spent quite a bit of time talking about monoliths. First, we discussed which is the best approach for you, then we spent some time showing how to deploy a monolith into Istio to get from it many of the benefits that microservices do. Now, let’s dive into building and deploying a microservice. Our microservice will be pretty simple. The goal is to show how a microservice is built and integrated into an application, rather than how to build a full-fledged application based on microservices. Our book is focused on enterprise, so we’re going to focus on a service that:</p>
<ul>
<li class="bulletList">Requires authentication from a specific user</li>
<li class="bulletList">Requires authorization for a specific user based on a group membership or attribute</li>
<li class="bulletList">Does something very <em class="italic">important</em></li>
<li class="bulletList">Generates some log data about what happened</li>
</ul>
<p class="normal">This is common in enterprise applications and the services they’re built on. Most enterprises need to be able to associate actions, or decisions, with a particular person in an organization. If <a id="_idIndexMarker1633"/>an order is placed, who placed it? If a case is closed, who closed it? If a check is cut, who cut it? There are of course many instances where a user isn’t responsible for an action. Sometimes, it’s another service that is automated. A batch service that pulls in data to create a warehouse isn’t associated with a particular person. That is<a id="_idIndexMarker1634"/> an <strong class="keyWord">interactive</strong> service, meaning that an end user is expected to interact with it, so we’re going to assume that the user is a person in the enterprise.</p>
<p class="normal">Once you know who is going to use the service, you’ll then need to know if the user is authorized to do so. In the previous paragraph, we identified that you need to know “who cut the check.” Another important question is, “Are they allowed to cut the check?” You really don’t want just anybody in your organization sending out checks, do you? Identifying who is authorized to perform an action could be the subject of multiple books, so to keep things simple, we’ll make our authorization decisions based on group membership, at least at a high level.</p>
<p class="normal">Having identified the user and authorized them, the next step is to do something <em class="italic">important</em>. It’s an enterprise, filled with important things that need doing! Since writing a check is something that we can all relate to and represents many of the challenges enterprise services face, we’re going to stick with this as our example. We’re going to write a check service that will let us send out checks.</p>
<p class="normal">Finally, having done something <em class="italic">important</em>, we need to make a record of it. We need to track who called our service, and once the service does the important parts, we need to make sure we record it somewhere. This can be recorded in a database or another service, or even sent to standard-out so that it can be collected by a log aggregator, like the OpenSearch we deployed in <em class="chapterRef">Chapter 15</em>.</p>
<p class="normal">Having identified all the things that our service will do, the next step is to identify which part of our infrastructure will be responsible for each decision and action. For our service:</p>
<table class="table-container" id="table001-10">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Action</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Component</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">User Authentication</p>
</td>
<td class="table-cell">
<p class="normal">OpenUnison</p>
</td>
<td class="table-cell">
<p class="normal">Our OpenUnison instance will authenticate users to our “Active Directory”</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Service Routing</p>
</td>
<td class="table-cell">
<p class="normal">Istio</p>
</td>
<td class="table-cell">
<p class="normal">How we will expose our service to the world</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Service Authentication</p>
</td>
<td class="table-cell">
<p class="normal">Istio</p>
</td>
<td class="table-cell">
<p class="normal">The <code class="inlineCode">RequestAuthentication</code> object will describe how to validate the user for our service</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Service Coarse Grained Authorization</p>
</td>
<td class="table-cell">
<p class="normal">Istio</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">AuthorizationPolicy</code> will make sure users are members of a specific group to call our service</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Fine-Grained Authorization, or Entitlements</p>
</td>
<td class="table-cell">
<p class="normal">Service</p>
</td>
<td class="table-cell">
<p class="normal">Our service will determine which payees you’re able to write checks for</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Writing a Check</p>
</td>
<td class="table-cell">
<p class="normal">Service</p>
</td>
<td class="table-cell">
<p class="normal">The point of writing this service!</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Log who Wrote the Check and to whom it was Sent</p>
</td>
<td class="table-cell">
<p class="normal">Service</p>
</td>
<td class="table-cell">
<p class="normal">Write this data to standard-out</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Log Aggregation</p>
</td>
<td class="table-cell">
<p class="normal">Kubernetes</p>
</td>
<td class="table-cell">
<p class="normal">In production – a tool like OpenSearch</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 17.1: Service responsibilities</p>
<p class="normal">We’ll build each<a id="_idIndexMarker1635"/> of these components, layer by layer, in the following sections. Before we get into the service itself, we need to say hello to the world.</p>
<h2 class="heading-2" id="_idParaDest-578">Deploying Hello World</h2>
<p class="normal">Our first <a id="_idIndexMarker1636"/>service will be a simple Hello World service that will serve as the starting point for our check-writing service. Our service is built on Python using Flask. We’re using this because it’s pretty simple to use and deploy. Go to <code class="inlineCode">chapter17/hello-world</code> and run the <code class="inlineCode">deploy_helloworld.sh</code> script. This will create our <code class="inlineCode">Namespace</code>, <code class="inlineCode">Deployment</code>, <code class="inlineCode">Service</code>, and <code class="inlineCode">Istio</code> objects. Look at the code in the <code class="inlineCode">service-source ConfigMap</code>. This is the main body of our code and the framework on which we will build our check service. The code itself doesn’t do much:</p>
<pre class="programlisting code"><code class="hljs-code">@app.<span class="hljs-title">route</span>(<span class="hljs-string">'/'</span>)
def <span class="hljs-title">hello</span>():
    retVal = {
        <span class="hljs-string">"msg"</span>:<span class="hljs-string">"hello world!"</span>,
        <span class="hljs-string">"host"</span>:<span class="hljs-string">"%s"</span> % socket.<span class="hljs-title">gethostname</span>()
    }
    <span class="hljs-keyword">return</span> json.<span class="hljs-title">dumps</span>(retVal)
</code></pre>
<p class="normal">This code <a id="_idIndexMarker1637"/>accepts all requests to <code class="inlineCode">/</code> and runs our function called <code class="inlineCode">hello()</code>, which sends a simple response. We’re embedding our code as a <code class="inlineCode">ConfigMap</code> for the sake of simplicity.</p>
<p class="normal">If you’ve read all the previous chapters, you’ll notice that we’re violating some cardinal rules with this container from a security standpoint. It’s a Docker Hub container running as root. That’s OK for now. We didn’t want to get bogged down in the build processes for this chapter. In <em class="chapterRef">Chapter 19</em><em class="italic">, Building a Developer Portal</em>, we’ll walk through using GitLab workflows to build out a more secure version of the container for this service.</p>
<p class="normal">Once our service is deployed, we can test it out by using <code class="inlineCode">curl</code>:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>curl http://service.192-168-2-114.nip.io/
{"msg": "hello world!", "host": "run-service-785775bf98-fln49"}%
</code></pre>
<p class="normal">This code isn’t terribly exciting, but next, we’ll add some security to our service.</p>
<h2 class="heading-2" id="_idParaDest-579">Integrating authentication into our service</h2>
<p class="normal">In <em class="chapterRef">Chapter 16</em>, <em class="italic">An Introduction to Istio</em>, we introduced the <code class="inlineCode">RequestAuthentication</code> object. Now, we<a id="_idIndexMarker1638"/> will use this object to enforce authentication. We want to make sure that in order to access our service, you must have a valid JWT. In the previous example, we just called our service directly. Now, we want to only get a response if a valid JWT is embedded in the request. We need to make sure to pair our <code class="inlineCode">RequestAuthentication</code> with an <code class="inlineCode">AuthorizationPolicy</code> that forces Istio to require a JWT; otherwise, Istio will only reject JWTs that don’t conform to our <code class="inlineCode">RequestAuthentication</code> but allow requests that have no JWT at all.</p>
<p class="normal">Even before we configure our objects, we need to get a JWT from somewhere. We’re going to use OpenUnison. To work with our API, let’s deploy the pipeline token generation chart we deployed in <em class="chapterRef">Chapter 6</em><em class="italic">, Integrating Authentication into Your Cluster</em>. Go to the <code class="inlineCode">chapter6/pipelines</code> directory and run the Helm chart:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>helm install orchestra-token-api token-login -n openunison -f /tmp/openunison-values.yaml
NAME: orchestra-token-api
LAST DEPLOYED: Tue Aug 31 19:41:30 2021
NAMESPACE: openunison
STATUS: deployed
REVISION: 1
TEST SUITE: None
</code></pre>
<p class="normal">This will give<a id="_idIndexMarker1639"/> us a way to easily generate a JWT from our internal Active Directory. Next, we’ll deploy the actual policy objects. Go into the <code class="inlineCode">chapter17/authentication</code> directory and run <code class="inlineCode">deploy-auth.sh</code>. It will look like this:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>./deploy-auth.sh
secret/cacerts configured
pod "istiod-75d8d56b68-tm6b7" deleted
requestauthentication.security.istio.io/hello-world-auth created
authorizationpolicy.security.istio.io/simple-hellow-world created
</code></pre>
<p class="normal">First, we created a <code class="inlineCode">Secret</code> called <code class="inlineCode">cacerts</code> to store our enterprise CA certificate and restart <code class="inlineCode">istiod</code>. This will allow <code class="inlineCode">istiod</code> to communicate with OpenUnison to pull <code class="inlineCode">jwks</code> signature verification keys. Next, two objects are created. The first is the <code class="inlineCode">RequestAuthentication</code> object and then a simple <code class="inlineCode">AuthorizationPolicy</code>. First, we will walk through <code class="inlineCode">RequestAuthentication</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">security.istio.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">RequestAuthentication</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-auth</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">istio-hello-world</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">jwtRules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">audiences:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">kubernetes</span>
    <span class="hljs-attr">issuer:</span> <span class="hljs-string">https://k8sou.192-168-2-119.nip.io/auth/idp/k8sIdp</span>
    <span class="hljs-attr">jwksUri:</span> <span class="hljs-string">https://k8sou.192-168-2-119.nip.io/auth/idp/k8sIdp/certs</span>
    <span class="hljs-attr">outputPayloadToHeader:</span> <span class="hljs-string">User-Info</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">run-service</span>
</code></pre>
<p class="normal">This object first specifies how the JWT needs to be formatted in order to be accepted. We’re cheating here a bit by just leveraging our Kubernetes JWT. Let’s compare this object to our JWT:</p>
<pre class="programlisting code"><code class="hljs-code">{
  <span class="hljs-attr">"iss":</span> <span class="hljs-string">"https://k8sou.192-168-2-119.nip.io/auth/idp/k8sIdp"</span>,
  <span class="hljs-attr">"aud":</span> <span class="hljs-string">"kubernetes"</span>,
  <span class="hljs-attr">"exp":</span> <span class="hljs-number">1630421193</span>,
  <span class="hljs-attr">"jti":</span> <span class="hljs-string">"JGnXlj0I5obI3Vcmb1MCXA"</span>,
  <span class="hljs-attr">"iat":</span> <span class="hljs-number">1630421133</span>,
  <span class="hljs-attr">"nbf":</span> <span class="hljs-number">1630421013</span>,
  <span class="hljs-attr">"sub":</span> <span class="hljs-string">"mmosley"</span>,
  <span class="hljs-attr">"name":</span> <span class="hljs-string">" Mosley"</span>,
  <span class="hljs-attr">"groups":</span> [
    <span class="hljs-string">"cn=group2,ou=Groups,DC=domain,DC=com"</span>,
    <span class="hljs-string">"cn=k8s-cluster-admins,ou=Groups,DC=domain,DC=com"</span>
  ],
  <span class="hljs-attr">"</span><span class="hljs-attr">preferred_username":</span> <span class="hljs-string">"mmosley"</span>,
  <span class="hljs-attr">"email":</span> <span class="hljs-string">"mmosley@tremolo.dev"</span>
}
</code></pre>
<p class="normal">The <code class="inlineCode">aud</code> claim<a id="_idIndexMarker1640"/> in our JWT lines up with the audiences in our <code class="inlineCode">RequestAuthentication</code>. The <code class="inlineCode">iss</code> claim lines up with <code class="inlineCode">issuer</code> in our <code class="inlineCode">RequestAuthentication</code>. If either of these claims doesn’t match, then Istio will return a <code class="inlineCode">401</code> HTTP error code to tell you that the request is unauthorized.</p>
<p class="normal">We also specify <code class="inlineCode">outputPayloadToHeader: User-Info</code> to tell Istio to pass the user info to the downstream service as a base64-encoded JSON header, with the name <code class="inlineCode">User-Info</code>. This header can be used by our service to identify who called it. We’ll get into the details of this when we get into entitlement authorization.</p>
<p class="normal">Additionally, the <code class="inlineCode">jwksUri</code> section specifies the URL that contains the RSA public keys used to verify the JWT. This can be obtained by first going to the issuer’s OIDC discovery URL and getting the URL from the <code class="inlineCode">jwks</code> claim.</p>
<p class="normal">It’s important to note that the <code class="inlineCode">RequestAuthentication</code> object will tell Istio what form the JWT needs to take, but not what data about the user needs to be present. We’ll cover that next, in the authorization section.</p>
<p class="normal">Speaking of authorization, we want to make sure to enforce the requirement for a JWT, so we will create this very simple <code class="inlineCode">AuthorizationPolicy</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">security.istio.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">AuthorizationPolicy</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">simple-hellow-world</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">istio-hello-world</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">action:</span> <span class="hljs-string">ALLOW</span>
  <span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">from:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">source:</span>
        <span class="hljs-attr">requestPrincipals:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">'*'</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">run-service</span>
</code></pre>
<p class="normal">The <code class="inlineCode">from</code> section says that there must be a <code class="inlineCode">requestPrincipal</code>. This tells Istio there must be a user (and in this case, anonymous is not a user). <code class="inlineCode">requestPrincipal</code> comes from JWTs and<a id="_idIndexMarker1641"/> represents users. There is also a <code class="inlineCode">principal</code> configuration, but this represents the service calling our URL, which in this case would be <code class="inlineCode">ingressgateway</code>. This tells Istio that a user must be authenticated via a JWT.</p>
<p class="normal">With our policy in place, we can now test it. First, with no user:</p>
<pre class="programlisting con"><code class="hljs-con">curl -v http://service.192-168-2-119.nip.io/
*   Trying 192.168.2.119:80...
* TCP_NODELAY set
* Connected to service.192-168-2-119.nip.io (192.168.2.119) port 80 (#0)
<span class="hljs-con-meta">&gt; </span>GET / HTTP/1.1
<span class="hljs-con-meta">&gt; </span>Host: service.192-168-2-119.nip.io
<span class="hljs-con-meta">&gt; </span>User-Agent: curl/7.68.0
<span class="hljs-con-meta">&gt; </span>Accept: */*
<span class="hljs-con-meta">&gt;</span>
* Mark bundle as not supporting multiuse
&lt; HTTP/1.1 403 Forbidden
&lt; content-length: 19
&lt; content-type: text/plain
&lt; date: Tue, 31 Aug 2021 20:23:14 GMT
&lt; server: istio-envoy
&lt; x-envoy-upstream-service-time: 2
&lt;
* Connection #0 to host service.192-168-2-119.nip.io left intact
</code></pre>
<p class="normal">We can see that the request was denied with a <code class="inlineCode">403</code> HTTP code. We received <code class="inlineCode">403</code> because Istio was expecting a JWT but there wasn’t one. Next, let’s generate a valid token the same way we did in <em class="chapterRef">Chapter 6</em><em class="italic">, Integrating Authentication into Your Cluster</em>:</p>
<pre class="programlisting con"><code class="hljs-con">curl -H "Authorization: Bearer $(curl --insecure -u 'mmosley:start123' https://k8sou.apps.192-168-2-119.nip.io/k8s-api-token/token/user 2&gt;/dev/null| jq -r '.token.id_token')" http://service.192-168-2-119.nip.io/ 
{"msg": "hello world!", "host": "run-service-785775bf98-6bbwt"}
</code></pre>
<p class="normal">Now, we have<a id="_idIndexMarker1642"/> success! Our hello world service now requires proper authentication. Next, we’ll update our authorization to require a specific group from Active Directory.</p>
<h2 class="heading-2" id="_idParaDest-580">Authorizing access to our service</h2>
<p class="normal">So far, we’ve<a id="_idIndexMarker1643"/> built a service and made sure users have a valid JWT from our identity provider before they can access it.</p>
<p class="normal">Now, we want to apply what’s often referred to as “coarse-grained” authorization. This is application- or service-level access. It says, “You are generally able to use this service,” but it doesn’t say you’re able to perform the action you wish to take. For our check-writing service, you may be authorized to write a check, but there are likely more controls that limit who you can write a check for. If you’re responsible for the <strong class="keyWord">Enterprise Resource Planning</strong> (<strong class="keyWord">ERP</strong>) system in <a id="_idIndexMarker1644"/>your enterprise, you probably shouldn’t be able to write checks for the facility vendors. We’ll get into how your service can manage these business-level decisions in the next section, but for now, we’ll focus on the service-level authorization.</p>
<p class="normal">It turns out we have everything we need. Earlier, we looked at our <code class="inlineCode">mmosley</code> user’s JWT, which had multiple claims. One such claim was the <code class="inlineCode">groups</code> claim. We used this claim in <em class="chapterRef">Chapter 6</em>, <em class="italic">Integrating Authentication into Your Cluster</em>, and <em class="chapterRef">Chapter 7</em>, <em class="italic">RBAC Policies and Auditing</em>, to manage access to our cluster. In a similar fashion, we’ll manage who can access our service based on our membership of a particular group. First, we’ll delete our existing policy:</p>
<pre class="programlisting con"><code class="hljs-con">kubectl delete authorizationpolicy simple-hellow-world -n istio-hello-world
authorizationpolicy.security.istio.io "simple-hellow-world" deleted
</code></pre>
<p class="normal">With the policy disabled, you can now access your service without a JWT. Next, we’ll create a policy that requires you to be a member of the group <code class="inlineCode">cn=group2,ou=Groups,DC=domain,DC=com</code> in our Active Directory.</p>
<p class="normal">Deploy the below policy (in <code class="inlineCode">chapter17/coursed-grained-authorization/coursed-grained-az.yaml</code>):</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">---</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">security.istio.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">AuthorizationPolicy</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">service-level-az</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">istio-hello-world</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">action:</span> <span class="hljs-string">ALLOW</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">run-service</span>
  <span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">when:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">request.auth.claims[groups]</span>
      <span class="hljs-attr">values:</span> [<span class="hljs-string">"cn=group2,ou=Groups,DC=domain,DC=com"</span>]
</code></pre>
<p class="normal">This policy<a id="_idIndexMarker1645"/> tells Istio that only users with a claim called <code class="inlineCode">groups</code> that have the value <code class="inlineCode">cn=group2,ou=Groups,DC=domain,DC=com</code> are able to access this service. With this policy deployed, you’ll see that you can still access the service as <code class="inlineCode">mmosley</code>, and trying to access the service anonymously still fails. Next, try accessing the service as <code class="inlineCode">jjackson</code>, with the same password:</p>
<pre class="programlisting con"><code class="hljs-con">curl -H "Authorization: Bearer $(curl --insecure -u 'jjackson:start123' https://k8sou.192-168-2-119.nip.io/k8s-api-token/token/user 2&gt;/dev/null| jq -r '.token.id_token')" http://service.192-168-2-119.nip.io/
RBAC: access denied
</code></pre>
<p class="normal">We’re not able to access this service as <code class="inlineCode">jjackson</code>. If we look at <code class="inlineCode">jjackson</code>'s <code class="inlineCode">id_token</code>, we can see why:</p>
<pre class="programlisting code"><code class="hljs-code">{
  <span class="hljs-attr">"iss":</span> <span class="hljs-string">"https://k8sou.192-168-2-119.nip.io/auth/idp/k8sIdp"</span>,
  <span class="hljs-attr">"aud":</span> <span class="hljs-string">"kubernetes"</span>,
  <span class="hljs-attr">"exp":</span> <span class="hljs-number">1630455027</span>,
  <span class="hljs-attr">"jti":</span> <span class="hljs-string">"Ae4Nv22HHYCnUNJx780l0A"</span>,
  <span class="hljs-attr">"iat":</span> <span class="hljs-number">1630454967</span>,
  <span class="hljs-attr">"nbf":</span> <span class="hljs-number">1630454847</span>,
  <span class="hljs-attr">"sub":</span> <span class="hljs-string">"jjackson"</span>,
  <span class="hljs-attr">"name":</span> <span class="hljs-string">" Jackson"</span>,
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-attr-slc">"groups":</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">"cn=k8s-create-ns,ou=Groups,DC=domain,DC=com"</strong><strong class="hljs-slc">,</strong></span>
  <span class="hljs-attr">"preferred_username":</span> <span class="hljs-string">"jjackson"</span>,
  <span class="hljs-attr">"email":</span> <span class="hljs-string">"jjackson@tremolo.dev"</span>
}
</code></pre>
<p class="normal">Looking at the claims, <code class="inlineCode">jjackson</code> isn’t a member of the group <code class="inlineCode">cn=group2,ou=Groups,DC=domain,DC=com</code>.</p>
<p class="normal">Now that we’re <a id="_idIndexMarker1646"/>able to tell Istio how to limit access to our service to valid users, the next step is to tell our service who the user is. We’ll then use this information to look up authorization data, log actions, and act on the user’s behalf.</p>
<h2 class="heading-2" id="_idParaDest-581">Telling your service who’s using it</h2>
<p class="normal">When<a id="_idIndexMarker1647"/> writing a service that does anything involving a user, the first thing you need to determine is, “Who is trying to use my service?” So far, we have told Istio how to determine who the user is, but how do we propagate that information down to our service? Our <code class="inlineCode">RequestAuthentication</code> included the configuration option <code class="inlineCode">outputPayloadToHeader: User-Info</code>, which injects the claims from our user’s authentication token as base64-encoded JSON into the HTTP request’s headers. This information can be pulled from that header and used by your service to look up additional authorization data.</p>
<p class="normal">We can view this header with a service we built, called <code class="inlineCode">/headers</code>. This service will just give us back all the headers that are passed to our service. Let’s take a look:</p>
<pre class="programlisting con"><code class="hljs-con">curl  -H "Authorization: Bearer $(curl --insecure -u 'mmosley:start123' https://k8sou.192-168-2-119.nip.io/k8s-api-token/token/user 2&gt;/dev/null| jq -r '.token.id_token')" http://service.192-168-2-119.nip.io/headers 2&gt;/dev/null | jq -r '.headers'
Host: service.192-168-2-119.nip.io
User-Agent: curl/7.75.0
Accept: */*
X-Forwarded-For: 192.168.2.112
X-Forwarded-Proto: http
X-Request-Id: 6397d068-537e-94b7-bf6b-a7c649db5b3d
X-Envoy-Attempt-Count: 1
X-Envoy-Internal: true
X-Forwarded-Client-Cert: By=spiffe://cluster.local/ns/istio-hello-world/sa/default;Hash=1a58a7d0abf62d32811c084a84f0a0f42b28616ffde7b6b840c595149d99b2eb;Subject="";URI=spiffe://cluster.local/ns/istio-system/sa/istio-ingressgateway-service-account
User-Info: eyJpc3MiOiJodHRwczovL2s4c291LjE5Mi0xNjgtMi0xMTkubmlwLmlvL2F1dGgvaWRwL2
s4c0lkcCIsImF1ZCI6Imt1YmVybmV0ZXMiLCJleHAiOjE2MzA1MTY4MjQsImp0aSI6InY0e
kpCNzdfRktpOXJoQU5jWDVwS1EiLCJpYXQiOjE2MzA1MTY3NjQsIm5iZiI6MTYzMDUxNj
Y0NCwic3ViIjoibW1vc2xleSIsIm5hbWUiOiIgTW9zbGV5IiwiZ3JvdXBzIjpbImNuPWdy
b3VwMixvdT1Hcm91cHMsREM9ZG9tYWluLERDPWNvbSIsImNuPWs4cy1jbHVzdGVyLWFkbW
lucyxvdT1Hcm91cHMsREM9ZG9tYWluLERDPWNvbSJdLCJwcmVmZXJyZWRfdXNlcm5hbWUi
OiJtbW9zbGV5IiwiZW1haWwiOiJtbW9zbGV5QHRyZW1vbG8uZGV2In0=
X-B3-Traceid: 28fb185aa113ad089cfac2d6884ce9ac
X-B3-Spanid: d40f1784a6685886
X-B3-Parentspanid: 9cfac2d6884ce9ac
X-B3-Sampled: 1
</code></pre>
<p class="normal">There <a id="_idIndexMarker1648"/>are several headers here. The one we care about is <code class="inlineCode">User-Info</code>. This is the name of the header we specified in our <code class="inlineCode">RequestAuthentication</code> object. If we decode from base64, we’ll get some JSON:</p>
<pre class="programlisting code"><code class="hljs-code">{
  <span class="hljs-string">"iss"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"https://k8sou.192-168-2-119.nip.io/auth/idp/k8sIdp"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"aud"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"kubernetes"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"exp"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1630508679</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"jti"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"5VoEAAgv1rkpf1vOJ9uo-g"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"iat"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1630508619</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"nbf"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1630508499</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"sub"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"mmosley"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">" Mosley"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"groups"</span><span class="hljs-punctuation">:</span> [
    <span class="hljs-string">"cn=group2,ou=Groups,DC=domain,DC=com"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">"cn=k8s-cluster-admins,ou=Groups,DC=domain,DC=com"</span>
  ]<span class="hljs-punctuation">,</span>
  <span class="hljs-string">"preferred_username"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"mmosley"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"email"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"mmosley@tremolo.dev"</span>
}
</code></pre>
<p class="normal">We have all the same claims as if we had decoded the token ourselves. What we don’t have is the JWT. This is important from a security standpoint. Our service can’t leak a token it doesn’t possess.</p>
<p class="normal">Now that we know how to determine who the user is, let’s integrate that into a simple <code class="inlineCode">who-am-i</code> service that just tells us who the user is. First, let’s look at our code:</p>
<pre class="programlisting code"><code class="hljs-code">@app.<span class="hljs-title">route</span>(<span class="hljs-string">'</span><span class="hljs-string">/who-am-i'</span>)
    def <span class="hljs-title">who_am_i</span>():
      user_info = request.<span class="hljs-property">headers</span>[<span class="hljs-string">"User-Info"</span>]
      user_info_json = base64.<span class="hljs-title">b64decode</span>(user_info).<span class="hljs-title">decode</span>(<span class="hljs-string">"utf8"</span>)
      user_info_obj = json.<span class="hljs-title">loads</span>(user_info_json)
      ret_val = {
        <span class="hljs-string">"name"</span>: user_info_obj[<span class="hljs-string">"sub"</span>],
        <span class="hljs-string">"</span><span class="hljs-string">groups"</span>: user_info_obj[<span class="hljs-string">"groups"</span>]
      }
      <span class="hljs-keyword">return</span> json.<span class="hljs-title">dumps</span>(ret_val)
</code></pre>
<p class="normal">This is<a id="_idIndexMarker1649"/> pretty basic. We’re getting the header from our request. Next, we decode it from base64, and finally, we get the JSON and add it to a return. If this were a more complex service, this is where we might query a database to determine what entitlements our user has.</p>
<p class="normal">In addition to not requiring that our code knows how to verify the JWT, this also makes it easier for us to develop our code in isolation from Istio. Open a shell in your <code class="inlineCode">run-service</code> pod and try accessing this service directly with any user:</p>
<pre class="programlisting con"><code class="hljs-con">kubectl exec -ti run-service-785775bf98-g86gl -n istio-hello-world – bash
<span class="hljs-con-meta"># </span><span class="hljs-con-built_in">export</span> USERINFO=$(<span class="hljs-con-built_in">echo</span> -n <span class="hljs-con-string">'{"sub":"marc","groups":["group1","group2"]}'</span> | <span class="hljs-con-built_in">base64</span> -w 0)
<span class="hljs-con-meta"># </span>curl -H <span class="hljs-con-string">"User-Info: </span><span class="hljs-con-variable">$USERINFO</span><span class="hljs-con-string">"</span> http://localhost:8080/who-am-i
{"name": "marc", "groups": ["group1", "group2"]}
</code></pre>
<p class="normal">We were able to call our service without having to know anything about Istio, JWTs, or cryptography! Everything was offloaded to Istio so that we could focus on our service. While this does make for easier development, what are the impacts on security if there’s a way to inject any information we want into our service?</p>
<p class="normal">Let’s try this directly from a namespace that doesn’t have the Istio sidecar:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl run -i --<span class="hljs-con-built_in">tty</span> curl --image=alpine --<span class="hljs-con-built_in">rm</span>=<span class="hljs-con-literal">true</span> – sh
/ # apk update add curl
/ # curl -H "User-Info $(echo -n '{"sub":"marc","groups":["group1","group2"]}' | base64 -w 0)" http://run-service.istio-hello-world.svc/who-am-i
RBAC: access denied
</code></pre>
<p class="normal">Our <code class="inlineCode">RequestAuthentication</code> and <code class="inlineCode">AuthorizationPolicy</code> stop the request. While we’re not running the sidecar, our service is, and it redirects all traffic to Istio where our policies will be enforced. What about if we try to inject our own <code class="inlineCode">User-Info</code> header from a valid request?</p>
<pre class="programlisting con"><code class="hljs-con">export USERINFO=$(echo -n '{"sub":"marc","groups":["group1","group2"]}' | base64 -w 0)
curl  -H "Authorization: Bearer $(curl --insecure -u 'mmosley:start123' https://k8sou.192-168-2-119.nip.io/k8s-api-token/token/user 2&gt;/dev/null| jq -r '.token.id_token')" -H "User-Info: $USERINFO" http://service.192-168-2-119.nip.io/who-am-i
{"name": "mmosley", "groups": ["cn=group2,ou=Groups,DC=domain,DC=com", "cn=k8s-cluster-admins,ou=Groups,DC=domain,DC=com"]}
</code></pre>
<p class="normal">Once again, our<a id="_idIndexMarker1650"/> attempt to override who the user is outside of a valid JWT has been foiled by Istio. We’ve shown how Istio injects a user’s identity into our service; now, we need to know how to authorize a user’s entitlements.</p>
<h2 class="heading-2" id="_idParaDest-582">Authorizing user entitlements</h2>
<p class="normal">So far, we’ve<a id="_idIndexMarker1651"/> managed to add quite a bit of functionality to our service without having to write any code. We added token-based authentication and coarse-grained authorization. We know who the user is and have<a id="_idIndexMarker1652"/> determined that, at the service level, they are authorized to call our service. Next, we need to decide if the user is allowed to do the specific action they’re trying to do. This is often called fine-grained authorization or entitlements. In this section, we’ll walk through multiple approaches you can take, discussing how you should choose an approach.</p>
<h3 class="heading-3" id="_idParaDest-583">Authorizing in service</h3>
<p class="normal">Unlike <a id="_idIndexMarker1653"/>coarse-grained authorizations and authentication, entitlements are generally not managed at the service mesh layer. That’s not to say it’s impossible. We’ll talk about ways you can do this in the service mesh, but in general, it’s not the best approach. Authorizations are generally tied to business data that’s usually locked up in a database. Sometimes, that database is a generic relational database, like MySQL or SQL Server, but it could really be anything. Since the data used to make the authorization decision is often owned by the service owner, not the cluster owner, it’s generally easier and more secure to make entitlement decisions directly in our code.</p>
<p class="normal">Earlier, we discussed in our check-writing service that we don’t want someone responsible for the ERP to cut checks to the facilities vendor. Where is the data that determines that? Well, it’s probably in your enterprise’s ERP system. Depending on how big you are, this could be a homegrown application or a SAP or Oracle. Let’s say you wanted Istio to make the authorization decision for our check-writing service. How would it get that data? Do you think the people responsible for the ERP want you, as a cluster owner, to <a id="_idIndexMarker1654"/>talk to their database directly? Do you, as a cluster owner, want that responsibility? What happens when something goes wrong with the ERP and someone points the finger at you for the problem? Do you have the resources to prove that you, and your team, were not responsible?</p>
<p class="normal">It turns out that the silos in enterprises that benefit from the management aspects of microservice design also work against centralized authorization. In our example of determining who can write the check for a specific vendor, it’s probably just easiest to make this decision inside our service. This way, if there’s a problem, it’s not the Kubernetes team’s responsibility to determine the issue, and the people who are responsible are in control of their own destiny.</p>
<p class="normal">That’s not to say there isn’t an advantage to a more centralized approach to authorization. Having teams implement their own authorization code will lead to different standards being used and different approaches. Without careful controls, it can lead to a compliance nightmare. Let’s look at how Istio could provide a more robust framework for authorization.</p>
<h3 class="heading-3" id="_idParaDest-584">Using OPA with Istio</h3>
<p class="normal">Using the Envoy<a id="_idIndexMarker1655"/> filters feature discussed in <em class="chapterRef">Chapter 16</em>, <em class="italic">An Introduction to Istio</em>, you can integrate the <strong class="keyWord">Open Policy Agent</strong> (<strong class="keyWord">OPA</strong>) into <a id="_idIndexMarker1656"/>your service mesh to make authorization decisions. We discussed OPA in <em class="chapterRef">Chapter 11</em>, <em class="italic">Extending Security Using Open Policy Agent</em>. There are a few key points about OPA we need to review:</p>
<ul>
<li class="bulletList">OPA does not (typically) reach out to external data stores to make authorization decisions. Much of the benefit of OPA requires that it uses its own internal database.</li>
<li class="bulletList">OPA’s database is not persistent. When an OPA instance dies, it must be repopulated with data.</li>
<li class="bulletList">OPA’s databases are not clustered. If you have multiple OPA instances, each database must be updated independently.</li>
</ul>
<p class="normal">To use OPA to<a id="_idIndexMarker1657"/> validate whether our user can write a check for a specific vendor, OPA would either need to be able to pull that data directly from the JWT or have the ERP data replicated in its own database. The former is unlikely to happen for multiple reasons. First, the issues with your cluster talking to your ERP will still exist when your identity provider tries to talk to your ERP. Second, the team that runs your identity provider would need to know to include the correct data, which is a difficult task and is unlikely something they’re interested in doing. Finally, there could be numerous folks, from security to the ERP team, who are not comfortable with this data being stored in a token that gets passed around. The latter option, syncing data into OPA, is more likely to be successful.</p>
<p class="normal">There are two ways you could sync your authorization data from your ERP into your OPA databases. The first is by pushing the data. A “bot” could push updates to each OPA instance. This way, the ERP owner is responsible for pushing the data, with your cluster just being a consumer. However, there’s no simple way to do this, and security would be a concern to make sure someone doesn’t push false data. The alternative is to write a pull “bot” that runs as a sidecar to your OPA pods. This is how GateKeeper works. The advantage here is that you have the responsibility of keeping your data synced without having to build a security framework to push data.</p>
<p class="normal">In either scenario, you’ll need to understand whether there are any compliance issues with the data you are storing. Now that you have the data, what’s the impact of losing it in a breach? Is that a responsibility you want?</p>
<p class="normal">Centralized authorization services have been discussed for entitlements long before Kubernetes or even RESTful APIs existed. They even predate SOAP and XML! For enterprise applications, it’s never really worked because of the additional costs in data management, ownership, and bridging silos. If you own all of the data, this is a great approach. When one of the main goals of microservices is to allow silos to better manage their own development, forcing a centralized entitlements engine is not likely to succeed.</p>
<p class="normal">With all that said, there has been a move towards centralizing authorization services. This movement has spawned several commercial companies and projects outside of OPA:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Cedar</strong>: An <a id="_idIndexMarker1658"/>open source project from Amazon Web Services that creates a new policy language. Amazon has also created a service built on this language: <a href="https://github.com/cedar-policy"><span class="url">https://github.com/cedar-policy</span></a>.</li>
<li class="bulletList"><strong class="keyWord">Topaz</strong>: Built on <a id="_idIndexMarker1659"/>OPA and Zanzibar, Topaz provides the OPA authorization engine with relationship-based authorizations from Zanzibar. There’s also a commercial offering: <a href="https://github.com/aserto-dev/topaz"><span class="url">https://github.com/aserto-dev/topaz</span></a>.</li>
<li class="bulletList"><strong class="keyWord">OpenFGA</strong>: Another<a id="_idIndexMarker1660"/> engine built on Zanzibar’s relationship-based authorization system, built by Auth0/Okta: <a href="https://github.com/openfga"><span class="url">https://github.com/openfga</span></a>.</li>
</ul>
<p class="normal">We’re not going <a id="_idIndexMarker1661"/>to dive into any of these solutions in detail; the point is that there has been a clear movement toward building authorization solutions, similar to how externalized authentication has been a product and project category for multiple decades.</p>
<p class="normal">Now that we know some of the issues involved in creating a centralized authorization, let’s build out an authorization rule with OPA for Istio.</p>
<h3 class="heading-3" id="_idParaDest-585">Creating an OPA Authorization Rule</h3>
<p class="normal">Earlier in <a id="_idIndexMarker1662"/>this<a id="_idIndexMarker1663"/> section, we discussed writing checks. A common rule for writing checks is that the person who writes the check is now also allowed to sign the check. This rule is called a “separation of duties.” It’s designed to build checkpoints for potentially harmful and costly processes. For instance, if an employee were allowed to both write the check and sign it, there’s no chance for someone to ask if the check is being written for a valid reason.</p>
<p class="normal">We’ve already implemented an AuthorizationPolicy that validates group membership, but for separation of duties, what we want is to implement a rule that validates that a user is a member of one group while NOT a member of another group. This sort of complex decision isn’t possible with a generic AuthorizationPolicy, so we’re going to need to build our own. We can use OPA as our authorization engine while instructing Istio to use our policy.</p>
<p class="normal">Before we deploy our policy, let’s review it. The full policy is in <code class="inlineCode">chapter17/opa/rego</code> and includes test cases:</p>
<pre class="programlisting code"><code class="hljs-code">package istio.<span class="hljs-property">authz</span>
<span class="hljs-keyword">import</span> input.<span class="hljs-property">attributes</span>.<span class="hljs-property">request</span>.<span class="hljs-property">http</span> <span class="hljs-keyword">as</span> http_request
<span class="hljs-keyword">import</span> input.<span class="hljs-property">parsed_path</span>
<span class="hljs-keyword">default</span> allow = <span class="hljs-literal">false</span>
<span class="hljs-title">contains_element</span>(arr, elem) = <span class="hljs-literal">true</span> {
    arr[_] = elem
} <span class="hljs-keyword">else</span> = <span class="hljs-literal">false</span> { <span class="hljs-literal">true</span> }
<span class="hljs-title">verify_headers</span>() = payload {
    <span class="hljs-title">startswith</span>(http_request.<span class="hljs-property">headers</span>[<span class="hljs-string">"authorization"</span>], <span class="hljs-string">"Bearer "</span>)
    [header, payload, signature] := io.<span class="hljs-property">jwt</span>.<span class="hljs-title">decode</span>(<span class="hljs-title">trim_prefix</span>(http_request.<span class="hljs-property">headers</span>[<span class="hljs-string">"authorization"</span>], <span class="hljs-string">"Bearer "</span>))
} <span class="hljs-keyword">else</span> = <span class="hljs-literal">false</span> {<span class="hljs-literal">true</span>}
allow {
    payload := <span class="hljs-title">verify_headers</span>()   
    payload.<span class="hljs-property">groups</span>
    <span class="hljs-title">contains_element</span>(payload.<span class="hljs-property">groups</span>,<span class="hljs-string">"cn=k8s-cluster-admins,ou=Groups,DC=domain,DC=com"</span>)
    not <span class="hljs-title">contains_element</span>(payload.<span class="hljs-property">groups</span>,<span class="hljs-string">"cn=group2,ou=Groups,DC=domain,DC=com"</span>)
}
allow {
    payload := <span class="hljs-title">verify_headers</span>()   
    payload.<span class="hljs-property">groups</span>
    payload.<span class="hljs-property">groups</span> == <span class="hljs-string">"cn=k8s-cluster-admins,ou=Groups,DC=domain,DC=com"</span>
}
</code></pre>
<p class="normal">We removed <a id="_idIndexMarker1664"/>the <a id="_idIndexMarker1665"/>comments to make the code more compact. The basics of this policy are that we:</p>
<ol>
<li class="numberedList" value="1">Verify that there’s an <code class="inlineCode">authorization</code> header.</li>
<li class="numberedList">Verify that the <code class="inlineCode">authorization</code> header is a <code class="inlineCode">Bearer</code> token.</li>
<li class="numberedList">Verify that the bearer token is a JWT.</li>
<li class="numberedList">Parse the JWT and verify that there is a <code class="inlineCode">groups</code> claim.</li>
<li class="numberedList">If the <code class="inlineCode">groups</code> claim is a list, make sure that it contains the <code class="inlineCode">k8s-cluster-admins</code> group, but NOT the <code class="inlineCode">group2</code> group.</li>
<li class="numberedList">If the <code class="inlineCode">groups</code> claim is not a list, only validate that it’s the <code class="inlineCode">k8s-cluster-admins</code> group.</li>
</ol>
<p class="normal">We are validating that the authorization header is present and properly formatted because Istio does not require a token to be present to pass authentication. This was done by our previous <code class="inlineCode">AuthorizationPolicy</code>, either explicitly by requiring that a principal be present or implicitly by requiring that a specific claim has a specific value.</p>
<p class="normal">Once we <a id="_idIndexMarker1666"/>have validated that the authorization header is properly formatted, we parse it for a payload. We’re not validating the JWT based on its public key, validity, or issuer because our <code class="inlineCode">RequestAuthentication</code> object is doing that for us. We just need to make sure that the token is there.</p>
<p class="normal">Finally, we <a id="_idIndexMarker1667"/>have two potential <code class="inlineCode">allow</code> policies. The first is if the <code class="inlineCode">groups</code> claim is a list, so we need to apply array logic to see if the correct group is present and that the forbidden group is not present. The second <code class="inlineCode">allow</code> policy will trigger if the <code class="inlineCode">groups</code> claim is not a list but only a single value. In this case, we only care that the group’s value is our admin group.</p>
<p class="normal">To deploy this policy, go to the <code class="inlineCode">chapter17/opa</code> directory and run <code class="inlineCode">deploy_opa_istio.sh</code>. The script will enable authorization and deploy our policy:</p>
<ol>
<li class="numberedList" value="1"><strong class="keyWord">Configure istiod</strong>: Updates the <code class="inlineCode">istio</code> <code class="inlineCode">ConfigMap</code> that stores the mesh configuration to enable the <code class="inlineCode">envoyExtAuthzGrpc</code> extension provider.</li>
<li class="numberedList"><strong class="keyWord">Deploy an OPA mutating admission controller</strong>: A mutating admission controller is deployed to automate the creation of an OPA instance on pods that runs alongside your services.</li>
<li class="numberedList"><strong class="keyWord">Deploys our policy</strong>: The policy we created earlier is created as a <code class="inlineCode">ConfigMap</code>.</li>
<li class="numberedList"><strong class="keyWord">Redeploy our service</strong>: Deletes the pod so that it is recreated with our authorization policy.</li>
<li class="numberedList">Once everything is deployed, we can now verify that our policy is being enforced using a <code class="inlineCode">curl</code> command. If we try to call our headers service now with our <code class="inlineCode">mmosley</code> user, it will fail because <code class="inlineCode">mmosley</code> is a member of both the <code class="inlineCode">k8s-cluster-admin</code> group and the <code class="inlineCode">group2</code> group:</li>
</ol>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>curl -v -H <span class="hljs-con-string">"Authorization: Bearer </span><span class="hljs-con-subst">$(curl --insecure -u 'mmosley:start123' https://k8sou.apps.192-168-2-96.nip.io/k8s-api-token/token/user 2&gt;/dev/null| jq -r '.token.id_token')</span><span class="hljs-con-string">"</span> http://service.192-168-2-96.nip.io/headers
*   Trying 192.168.2.96:80...
* Connected to service.192-168-2-96.nip.io (192.168.2.96) port 80
<span class="hljs-con-meta">&gt; </span>GET /headers HTTP/1.1
<span class="hljs-con-meta">&gt; </span>Host: service.192-168-2-96.nip.io
<span class="hljs-con-meta">&gt; </span>User-Agent: curl/8.4.0
<span class="hljs-con-meta">&gt; </span>Accept: */*
<span class="hljs-con-meta">&gt; </span>Authorization: Bearer …
<span class="hljs-con-meta">&gt; </span>
&lt; HTTP/1.1 403 Forbidden
&lt; date: Tue, 27 Feb 2024 19:49:49 GMT
&lt; server: istio-envoy
&lt; content-length: 0
&lt; x-envoy-upstream-service-time: 8
&lt; 
* Connection #0 to host service.192-168-2-96.nip.io left intact
</code></pre>
<p class="normal">However, if <a id="_idIndexMarker1668"/>we use <a id="_idIndexMarker1669"/>our <code class="inlineCode">pipeline_svc_account</code> user, it succeeds because this user is only a member of the <code class="inlineCode">k8s-cluster-admin</code> group:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>curl -H <span class="hljs-con-string">"Authorization: Bearer </span><span class="hljs-con-subst">$(curl --insecure -u 'pipeline_svc_account:start123' https://k8sou.apps.192-168-2-96.nip.io/k8s-api-token/token/user 2&gt;/dev/null| jq -r '.token.id_token')</span><span class="hljs-con-string">"</span> http://service.192-168-2-96.nip.io/headers 
{"headers": "Host: service.192-168-2-96.nip.io\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nX-Forwarded-For: 192.168.3.6\r\nX-Forwar…
</code></pre>
<p class="normal">Now, we can build more complex policies than what’s possible with Istio’s <code class="inlineCode">AuthorizationPolicy</code>'s built-in authorization capabilities.</p>
<p class="normal">Having determined how to integrate entitlements into our services, the next question we need to answer is, how do we securely call other services?</p>
<h2 class="heading-2" id="_idParaDest-586">Calling other services</h2>
<p class="normal">We’ve written<a id="_idIndexMarker1670"/> services that do simple things, but what about when your service needs to talk to another service? Just like with almost every other set of choices in your cluster rollout, you have multiple options to authenticate to other services. Which choice you make will depend on your needs. We’ll first cover the OAuth2 standard way of getting new tokens for service calls and how Istio works with it. We’ll then cover some alternatives that should be considered anti-patterns but that you may choose to use anyway.</p>
<h3 class="heading-3" id="_idParaDest-587">Using OAuth2 Token Exchange</h3>
<p class="normal">Your service knows<a id="_idIndexMarker1671"/> who your user is but needs to call another service. How do you identify yourself to the second service? The OAuth2 specification, which OpenID Connect is built on, has RFC 8693 – OAuth2 Token Exchange for this purpose. The basic idea is that your service will get a fresh token from your identity provider for the service call, based on the existing user. By getting a fresh token for your own call to a remote service, you’re making it easier to lock down where tokens can be used and who can use them, allowing yourself to more easily track a call’s authentication and authorization flow. The following diagram gives a high-level overview.</p>
<figure class="mediaobject"><img alt="A picture containing text, screenshot, line, diagram  Description automatically generated" height="373" src="../Images/B21165_17_06.png" width="877"/></figure>
<p class="packt_figref">Figure 17.6: OAuth2 Token Exchange sequence</p>
<p class="normal">There are some details we’ll walk through that depend on your use case:</p>
<ol>
<li class="numberedList" value="1">The user requests an <code class="inlineCode">id_token</code> from the identity provider. How the user gets their token doesn’t really matter for this part of the sequence. We’ll use a utility in OpenUnison for our lab.</li>
<li class="numberedList">Assuming you’re authenticated and authorized, your identity provider will give you an <code class="inlineCode">id_token</code> with an <code class="inlineCode">aud</code> claim that will be accepted by Service-X.</li>
<li class="numberedList">The user uses the <code class="inlineCode">id_token</code> as a bearer token to call Service-X. It goes without saying that Istio will validate this token.</li>
<li class="numberedList">Service-X requests a token for Service-Y from the identity provider on behalf of the user. There are two potential methods to do this. One is impersonation; the other is delegation. We’ll cover both in detail later in this section. You’ll send your identity<a id="_idIndexMarker1672"/> provider your original <code class="inlineCode">id_token</code> and something to identify the service to the identity provider.</li>
<li class="numberedList">Assuming Service-X is authorized, the identity provider sends a new <code class="inlineCode">id_token</code> to Service-X with the original user’s attributes and an <code class="inlineCode">aud</code> scoped to Service-Y.</li>
<li class="numberedList">Service-X uses the new <code class="inlineCode">id_token</code> as the <code class="inlineCode">Authorization</code> header when calling Service-Y. Again, Istio validates the <code class="inlineCode">id_token</code>.</li>
</ol>
<p class="normal">Steps 7 and 8 in the previous diagram aren’t really important here.</p>
<p class="normal">If you think this seems like quite a bit of work to make a service call, you’re right. There are several authorization steps going on here:</p>
<ol>
<li class="numberedList" value="1">The identity provider authorizes the user to generate a token scoped to Service-X.</li>
<li class="numberedList">Istio validates the token and that it’s properly scoped to Service-X.</li>
<li class="numberedList">The identity provider authorizes Service-X to get a token for Service-Y and to do so for our user.</li>
<li class="numberedList">Istio validates that the token used by Service-X for Service-Y is properly scoped.</li>
</ol>
<p class="normal">These authorization points provide a chance for an improper token to be stopped, allowing you to create very short-lived tokens that are harder to abuse and are more narrowly scoped. For instance, if the token used to call Service-X was leaked, it couldn’t be used to call Service-Y on its own. You’d still need Service-X’s own token before you could get a token for Service-Y. That’s an additional step an attacker would need to take in order to get control of Service-Y. It also means breaching more than one service, providing multiple layers of security. This lines up with our discussion of defense in depth from <em class="chapterRef">Chapter 11</em>, <em class="italic">Extending Security Using Open Policy Agent</em>. With a high-level understanding of how OAuth2 Token Exchange works, the next question we need to answer is, how will your services authenticate themselves to your identity provider?</p>
<h4 class="heading-4">Authenticating your service</h4>
<p class="normal">In order<a id="_idIndexMarker1673"/> for the token exchange to work, your identity provider needs to know who the original user is and which service wants to exchange the token on behalf of the user. In the check-writing service example we’ve discussed, you wouldn’t want the service that provides today’s lunch menu to be able to generate a token for issuing a check! You accomplish this by making sure your identity provider knows the difference between your check-writing services and your lunch menu service by authenticating each service individually.</p>
<p class="normal">There are three ways a service running in Kubernetes can authenticate itself to the identity provider:</p>
<ol>
<li class="numberedList" value="1">Use the Pod’s <code class="inlineCode">ServiceAccount</code> token</li>
<li class="numberedList">Use Istio’s mTLS capabilities</li>
<li class="numberedList">Use a pre-shared “client secret”</li>
</ol>
<p class="normal">Throughout the <a id="_idIndexMarker1674"/>rest of this section, we’re going to focus on option #1, using the Pod’s built-in <code class="inlineCode">ServiceAccount</code> token. This token is provided by default for each running pod. This token can be validated by either submitting it to the API server’s <code class="inlineCode">TokenReview</code> service or by treating it as a JWT, validating it against the public key published by the API server.</p>
<p class="normal">In our examples, we’re going to use the <code class="inlineCode">TokenReview</code> API to test the passed-in <code class="inlineCode">ServiceAccount</code> token against the API server. This is the most backward-compatible approach and supports any kind of token integrated into your cluster. For instance, if you’re deployed in a managed cloud with its own IAM system that mounts tokens, you could use that as well. This could generate a considerable amount of load on your API server, since every time a token needs to be validated, it gets sent to the API server.</p>
<p class="normal">The <code class="inlineCode">TokenRequest</code> API discussed in <em class="chapterRef">Chapter 6</em>, <em class="italic">Integrating Authentication into Your Cluster</em>, can be used to cut down on this additional load. Instead of using the <code class="inlineCode">TokenReview</code> API, we can call the API server’s issuer endpoint to get the appropriate token verification public key and use that key to validate the token’s JWT. While this is convenient and scales better, it does have some drawbacks:</p>
<ol>
<li class="numberedList" value="1">Starting in 1.21, <code class="inlineCode">ServiceAccount</code> tokens are mounted using the <code class="inlineCode">TokenRequest</code> API but with lifespans of a year or more. You can manually change this to be as short as 10 minutes.</li>
<li class="numberedList">Validating the JWT directly against a public key won’t tell you if the pod is still running. The <code class="inlineCode">TokenReview</code> API will fail if a <code class="inlineCode">ServiceAcount</code> token is associated with a deleted pod, adding an additional layer of security.</li>
<li class="numberedList">Enabling this feature requires enabling anonymous authentication in your cluster, which can be leveraged to elevate privileges with misconfigured RBAC or potential bugs.</li>
</ol>
<p class="normal">We’re not going to use Istio’s mTLS capabilities because it’s not as flexible as tokens. It’s primarily meant for intra-cluster communications, so if our identity provider were outside of the cluster, it would be much harder to use. Also, since mTLS requires a point-to-point connection, any TLS termination points would break its use. Since it’s rare for an enterprise <a id="_idIndexMarker1675"/>system to host its own certificate, even outside of Kubernetes, it would be very difficult to implement mTLS between your cluster’s services and your identity provider.</p>
<p class="normal">Finally, we’re not going to use a shared secret between our services and our identity provider because we don’t need to. Shared secrets are only needed when you have no other way to give a workload an identity. Since Kubernetes gives every pod its own identity, there’s no need to use a client secret to identify our service.</p>
<p class="normal">Now that we know how our services will identify themselves to our identity provider, let’s walk through an example of using OAuth2 Token Exchange to securely call one service from another.</p>
<h4 class="heading-4">Deploying and running the check-writing service</h4>
<p class="normal">Having <a id="_idIndexMarker1676"/>walked through much of the theory of using a token exchange to securely call services, let’s deploy an example check-writing service. When<a id="_idIndexMarker1677"/> we call this service, it will call two other services. The first service, <code class="inlineCode">check-funds</code>, will use the impersonation profile of OAuth2 Token Exchange, while the second service, <code class="inlineCode">pull-funds</code>, will use delegation. We’ll walk through each of these individually. First, use Helm to deploy an identity provider. Go into the <code class="inlineCode">chapter17</code> directory and run:</p>
<pre class="programlisting con"><code class="hljs-con">helm install openunison-service-auth openunison-service-auth -n openunison
NAME: openunison-service-auth
LAST DEPLOYED: Mon Sep 13 01:08:09 2021
NAMESPACE: openunison
STATUS: deployed
REVISION: 1
TEST SUITE: None
</code></pre>
<p class="normal">We’re not going to go into the details of OpenUnison’s configuration. Suffice it to say, this will set up an identity provider for our services and a way to get an initial token. Next, deploy the <code class="inlineCode">write-checks</code> service:</p>
<pre class="programlisting con"><code class="hljs-con">cd write-checks/
./deploy_write_checks.sh
getting oidc config
getting jwks
namespace/write-checks created
configmap/service-source created
deployment.apps/write-checks created
service/write-checks created
gateway.networking.istio.io/service-gateway created
virtualservice.networking.istio.io/service-vs created
requestauthentication.security.istio.io/write-checks-auth created
authorizationpolicy.security.istio.io/service-level-az created
</code></pre>
<p class="normal">This<a id="_idIndexMarker1678"/> should<a id="_idIndexMarker1679"/> look pretty familiar after the first set of examples in this chapter. We deployed our service as Python in a <code class="inlineCode">ConfigMap</code> and the same Istio objects we created in the previous service. The only major difference is in our <code class="inlineCode">RequestAuthentication</code> object:</p>
<pre class="programlisting code"><code class="hljs-code">apiVersion<span class="hljs-punctuation">:</span> security.istio.io/v1beta1
kind<span class="hljs-punctuation">:</span> RequestAuthentication
metadata<span class="hljs-punctuation">:</span>
  name<span class="hljs-punctuation">:</span> write<span class="hljs-punctuation">-</span>checks<span class="hljs-punctuation">-</span>auth
  namespace<span class="hljs-punctuation">:</span> write<span class="hljs-punctuation">-</span>checks
spec<span class="hljs-punctuation">:</span>
  jwtRules<span class="hljs-punctuation">:</span>
  <span class="hljs-punctuation">-</span> audiences<span class="hljs-punctuation">:</span>
    <span class="hljs-punctuation">-</span> users
    <span class="hljs-punctuation">-</span> checkfunds
    <span class="hljs-punctuation">-</span> pullfunds
    forwardOriginalToken<span class="hljs-punctuation">:</span> true
    issuer<span class="hljs-punctuation">:</span> https<span class="hljs-punctuation">:</span><span class="hljs-comment">//k8sou.apps.192-168-2-119.nip.io/auth/idp/service-idp</span>
    jwksUri<span class="hljs-punctuation">:</span> https<span class="hljs-punctuation">:</span><span class="hljs-comment">//k8sou.apps.192-168-2-119.nip.io/auth/idp/service-idp/certs</span>
    outputPayloadToHeader<span class="hljs-punctuation">:</span> User<span class="hljs-punctuation">-</span>Info
  selector<span class="hljs-punctuation">:</span>
    matchLabels<span class="hljs-punctuation">:</span>
      app<span class="hljs-punctuation">:</span> write<span class="hljs-punctuation">-</span>checks
</code></pre>
<p class="normal">There’s an additional setting, <code class="inlineCode">forwardOriginalToken</code>, that tells Istio to send the service the original JWT used to authenticate the call. We’ll need this token in order to prove to the identity provider that we should even attempt to perform a token exchange. You can’t ask for a new token if you can’t provide the original. This keeps someone with access to your service’s pod from requesting a token on your behalf with just the service’s <code class="inlineCode">ServiceAccount</code>.</p>
<p class="normal">Earlier in the chapter, we said we couldn’t leak a token we didn’t have, so we shouldn’t have access to the original token. This would be true if we didn’t need it to get a token for another <a id="_idIndexMarker1680"/>service. Following the<a id="_idIndexMarker1681"/> concept of least privilege, we shouldn’t forward the token if we don’t need to. In this case, we need it for a token exchange, so it’s worth the increased risk to have more secure service-to-service calls.</p>
<p class="normal">With our example check-writing service deployed, let’s run it and work backward. Just like with our earlier examples, we’ll use <code class="inlineCode">curl</code> to get the token and call our service. In <code class="inlineCode">chapter17/write-checks</code>, run <code class="inlineCode">call_service.sh</code>:</p>
<pre class="programlisting con"><code class="hljs-con">./call_service.sh
{
  "msg": "hello world!",
  "host": "write-checks-84cdbfff74-tgmzh",
  "user_jwt": "...",
  "pod_jwt": "...",
  "impersonated_jwt": "...",
  "call_funds_status_code": 200,
  "call_funds_text": "{\"funds_available\": true, \"user\": \"mmosley\"}",
  "actor_token": "...",
  "delegation_token": "...",
  "pull_funds_text": "{\"funds_pulled\": true, \"user\": \"mmosley\", \"actor\": \"system:serviceaccount:write-checks:default\"}"
}
</code></pre>
<p class="normal">The output you see is the result of the calls to <code class="inlineCode">/write-check</code>, which then calls <code class="inlineCode">/check-funds</code> and <code class="inlineCode">/pull-funds</code>. Let’s walk through each call, the tokens that are generated, and the code that generates them.</p>
<h4 class="heading-4">Using Impersonation</h4>
<p class="normal">We’re not<a id="_idIndexMarker1682"/> talking about the same Impersonation you used in <em class="chapterRef">Chapter 6</em>, <em class="italic">Integrating Authentication into Your Cluster</em>. It’s a similar concept, but this is specific to token exchange. When <code class="inlineCode">/write-check</code> needs to get a token to call <code class="inlineCode">/check-funds</code>, it asks OpenUnison for a token on behalf of our user, <code class="inlineCode">mmosley</code>. The important aspect of Impersonation is that there’s no reference to the requesting client in the generated token. The <code class="inlineCode">/check-funds</code> service does not know that the token it’s received wasn’t retrieved by the user themselves. Working backward, the <code class="inlineCode">impersonated_jwt</code> in the response to our service call is what <code class="inlineCode">/write-check</code> uses to call <code class="inlineCode">/check-funds</code>. Here’s the payload after dropping the result into <code class="inlineCode">jwt.io</code>:</p>
<pre class="programlisting code"><code class="hljs-code">{
  <span class="hljs-string">"iss"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"https://k8sou.192-168-2-119.nip.io/auth/idp/service-idp"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"aud"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"</span><span class="hljs-string">checkfunds"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"exp"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1631497059</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"jti"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"C8Qh8iY9FJdFzEO3pLRQzw"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"iat"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1631496999</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"nbf"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1631496879</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"nonce"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"bec42c16-5570-4bd8-9038-be30fd216016"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"sub"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"mmosley"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">" Mosley"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"groups"</span><span class="hljs-punctuation">:</span> [
    <span class="hljs-string">"cn=group2,ou=Groups,DC=domain,DC=com"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">"cn=k8s-cluster-admins,ou=Groups,DC=domain,DC=com"</span>
  ]<span class="hljs-punctuation">,</span>
  <span class="hljs-string">"preferred_username"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"mmosley"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"email"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"mmosley@tremolo.dev"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"amr"</span><span class="hljs-punctuation">:</span> [
    <span class="hljs-string">"pwd"</span>
  ]
}
</code></pre>
<p class="normal">The two<a id="_idIndexMarker1683"/> important fields here are <code class="inlineCode">sub</code> and <code class="inlineCode">aud</code>. The <code class="inlineCode">sub</code> field tells <code class="inlineCode">/check-funds</code> who the user is and the <code class="inlineCode">aud</code> field tells Istio which services can consume this token. Compare this to the payload from the original token in the <code class="inlineCode">user_jwt</code> response:</p>
<pre class="programlisting code"><code class="hljs-code">{
  <span class="hljs-string">"iss"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"https://k8sou.192-168-2-119.nip.io/auth/idp/service-idp"</span><span class="hljs-punctuation">,</span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-string-slc">"aud"</strong><strong class="hljs-punctuation-slc">:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">"users"</strong><strong class="hljs-punctuation-slc">,</strong></span>
  <span class="hljs-string">"exp"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1631497059</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"jti"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"C8Qh8iY9FJdFzEO3pLRQzw"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"iat"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1631496999</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"nbf"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1631496879</span><span class="hljs-punctuation">,</span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-string-slc">"sub"</strong><strong class="hljs-punctuation-slc">:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">"mmosley"</strong><strong class="hljs-punctuation-slc">,</strong></span>
  <span class="hljs-string">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">" Mosley"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"groups"</span><span class="hljs-punctuation">:</span> [
    <span class="hljs-string">"cn=group2,ou=Groups,DC=domain,DC=com"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">"</span><span class="hljs-string">cn=k8s-cluster-admins,ou=Groups,DC=domain,DC=com"</span>
  ]<span class="hljs-punctuation">,</span>
  <span class="hljs-string">"preferred_username"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"mmosley"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"email"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"mmosley@tremolo.dev"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"amr"</span><span class="hljs-punctuation">:</span> [
    <span class="hljs-string">"pwd"</span>
  ]
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker1684"/>original <code class="inlineCode">sub</code> is the same, but the <code class="inlineCode">aud</code> is different. The original <code class="inlineCode">aud</code> is for users, while the impersonated <code class="inlineCode">aud</code> is for <code class="inlineCode">checkfunds</code>. This is what differentiates the impersonated token from the original one. While our Istio deployment is configured to accept both audiences for the same service, that’s not a guarantee in most production clusters. When we call <code class="inlineCode">/check-funds</code>, you’ll see that, in the output, we echo the user of our token, <code class="inlineCode">mmosley</code>.</p>
<p class="normal">Now that we’ve seen the end product, let’s see how we get it. First, we get the original JWT that was used to call <code class="inlineCode">/write-check</code>:</p>
<pre class="programlisting code"><code class="hljs-code"># <span class="hljs-keyword">let</span><span class="hljs-string">'</span><span class="hljs-string">s first get the original JWT. We'</span>ll
# use <span class="hljs-variable">this</span> <span class="hljs-keyword">as</span> an input <span class="hljs-keyword">for</span> impersonation
az_header = request.<span class="hljs-property">headers</span>[<span class="hljs-string">"Authorization"</span>]
user_jwt = az_header[<span class="hljs-number">7</span>:]
</code></pre>
<p class="normal">Once we have the original JWT, we need the Pod’s <code class="inlineCode">ServiceAccount</code> token:</p>
<pre class="programlisting code"><code class="hljs-code"># next, get the pod<span class="hljs-string">'s ServiceAccount token</span>
<span class="hljs-string"># so we can identify the pod to the IdP for</span>
<span class="hljs-string"># an impersonation token</span>
<span class="hljs-string">pod_jwt = Path('</span>/<span class="hljs-keyword">var</span>/run/secrets/kubernetes.<span class="hljs-property">io</span>/serviceaccount/token<span class="hljs-string">').read_text()</span>
</code></pre>
<p class="normal">We now have everything we need to get an impersonation token. We’ll create a POST body and an <code class="inlineCode">Authorization</code> header to authenticate us to OpenUnison to get our token:</p>
<pre class="programlisting code"><code class="hljs-code"># <span class="hljs-keyword">with</span> the <span class="hljs-title">subject</span> (user) jwt and the pod
# jwt we can now request an impersonated
# token <span class="hljs-keyword">for</span> our user <span class="hljs-keyword">from</span> openunison
impersonation_request = {
  <span class="hljs-string">"grant_type"</span>:<span class="hljs-string">"urn:ietf:params:oauth:grant-type:token-exchange"</span>,
  <span class="hljs-string">"audience"</span>:<span class="hljs-string">"checkfunds"</span>,
  <span class="hljs-string">"subject_token"</span>:user_jwt,
  <span class="hljs-string">"subject_token_type"</span>:<span class="hljs-string">"urn:ietf:params:oauth:token-type:id_token"</span>,
  <span class="hljs-string">"client_id"</span>:<span class="hljs-string">"sts-impersonation"</span>
}
impersonation_headers = {
  <span class="hljs-string">"Authorization"</span>: <span class="hljs-string">"Bearer %s"</span> % pod_jwt
}
</code></pre>
<p class="normal">The first<a id="_idIndexMarker1685"/> data structure we created is the body of an HTTP POST that will tell OpenUnison to generate an impersonation token for the <code class="inlineCode">clientfunds aud</code>, using our existing user (<code class="inlineCode">user_jwt</code>). OpenUnison will authenticate our service by verifying the JWT sent in the <code class="inlineCode">Authorization</code> header as a <code class="inlineCode">Bearer</code> token, using the <code class="inlineCode">TokenReview</code> API.</p>
<p class="normal">OpenUnison will then apply its internal policy to verify that our service is able to generate a token for <code class="inlineCode">mmosley</code> for the <code class="inlineCode">clientfunds</code> audience, and then generate an <code class="inlineCode">access_token</code>, <code class="inlineCode">id_token</code>, and <code class="inlineCode">refresh_token</code>. We’ll use the <code class="inlineCode">id_token</code> to call <code class="inlineCode">/check-funds</code>:</p>
<pre class="programlisting code"><code class="hljs-code">resp = requests.<span class="hljs-title">post</span>(<span class="hljs-string">"https://k8sou.apps.IPADDR.nip.io/auth/idp/service-idp/token"</span>,verify=<span class="hljs-title">False</span>,data=impersonation_request,headers=impersonation_headers)
response_payload = json.<span class="hljs-title">loads</span>(resp.<span class="hljs-property">text</span>)
impersonated_id_token = response_payload[<span class="hljs-string">"id_token"</span>]
# <span class="hljs-keyword">with</span> the impersonated user<span class="hljs-string">'s id_token, call another</span>
<span class="hljs-string"># service as that user</span>
<span class="hljs-string">call_funds_headers = {</span>
<span class="hljs-string">  "Authorization": "Bearer %s" % impersonated_id_token</span>
<span class="hljs-string">}</span>
<span class="hljs-string">resp = requests.get("http://write-checks.IPADDR.nip.io/check-funds",verify=False,headers=call_funds_headers)</span>
</code></pre>
<p class="normal">Since the final JWT makes no mention of the impersonation, how do we track a request back to our service? Hopefully, you’re piping your logs into a centralized logging system. If we look at the <code class="inlineCode">jti</code> claim of our impersonation token, we can find the impersonation call in the OpenUnison logs:</p>
<pre class="programlisting con"><code class="hljs-con">INFO  AccessLog - [AzSuccess] - service-idp - https://k8sou.apps.192-168-2-119.nip.io/auth/idp/service-idp/token - username=system:serviceaccount:write-checks:default,ou=oauth2,o=Tremolo - client 'sts-impersonation' impersonating 'mmosley', jti : 'C8Qh8iY9FJdFzEO3pLRQzw'
</code></pre>
<p class="normal">So, we at least have a way of tying them together. We can see that our Pod’s service account was authorized to create the impersonation token for <code class="inlineCode">mmosley</code>.</p>
<p class="normal">Having worked through an example of impersonation, let’s cover token delegation next.</p>
<h4 class="heading-4">Using delegation</h4>
<p class="normal">In the<a id="_idIndexMarker1686"/> last example, we used impersonation to generate a new token on behalf of our user, but our downstream service had no knowledge that the impersonation happened. Delegation is different in that the token carries information about both the original user and the service, or actor, that requested it.</p>
<p class="normal">This means that the service being called knows both the originator of the call and the service that makes the call. We can see this in the <code class="inlineCode">pull_funds_text</code> value from the response of our <code class="inlineCode">call_service.sh</code> run. It contains both our original user, <code class="inlineCode">mmosley</code>, and the <code class="inlineCode">ServiceAccount</code> for the service that made the call, <code class="inlineCode">system:serviceaccount:write-checks:default</code>. Just as with impersonation, let’s look at the generated token:</p>
<pre class="programlisting code"><code class="hljs-code">{
  <span class="hljs-string">"</span><span class="hljs-string">iss"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"https://k8sou.apps.192-168-2-119.nip.io/auth/idp/service-idp"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"aud"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"pullfunds"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"exp"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1631497059</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"jti"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"xkaQhMgKgRvGBqAsOWDlXA"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"iat"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1631496999</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"nbf"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1631496879</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"nonce"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"272f1900-f9d9-4161-a31c-6c6dde80fcb9"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"sub"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"mmosley"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"amr"</span><span class="hljs-punctuation">:</span> [
    <span class="hljs-string">"pwd"</span>
  ]<span class="hljs-punctuation">,</span>
  <span class="hljs-string">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">" Mosley"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"groups"</span><span class="hljs-punctuation">:</span> [
    <span class="hljs-string">"cn=group2,ou=Groups,DC=domain,DC=com"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">"cn=k8s-cluster-admins,ou=Groups,DC=domain,DC=com"</span>
  ]<span class="hljs-punctuation">,</span>
  <span class="hljs-string">"preferred_username"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"mmosley"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-string">"email"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"</span><span class="hljs-string">mmosley@tremolo.dev"</span><span class="hljs-punctuation">,</span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-string-slc">"act"</strong><strong class="hljs-punctuation-slc">:</strong><strong class="hljs-slc"> {</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-string-slc">"sub"</strong><strong class="hljs-punctuation-slc">:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">"system:serviceaccount:write-checks:default"</strong><strong class="hljs-punctuation-slc">,</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-string-slc">"amr"</strong><strong class="hljs-punctuation-slc">:</strong><strong class="hljs-slc"> [</strong></span>
<span class="code-highlight"><strong class="hljs-slc">      </strong><strong class="hljs-string-slc">"k8s-sa"</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    ]</strong><strong class="hljs-punctuation-slc">,</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    .</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    .</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    .</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  }</strong></span>
}
</code></pre>
<p class="normal">In addition to the claims that identify the user as <code class="inlineCode">mmosley</code>, there’s an <code class="inlineCode">act</code> claim that identifies the <code class="inlineCode">ServiceAccount</code> that’s used by <code class="inlineCode">/write-checks</code>. Our service can make additional <a id="_idIndexMarker1687"/>authorization decisions based on this claim or simply log it, noting that the token it received was delegated to a different service. In order to generate this token, we start by getting the original subject’s JWT and the Pod’s <code class="inlineCode">ServiceAccount</code> token.</p>
<p class="normal">Instead of calling OpenUnison for a delegated token, our client first has to get an actor token by using the <code class="inlineCode">client_credentials</code> grant. This will get us the token that will eventually go into the <code class="inlineCode">act</code> claim:</p>
<pre class="programlisting code"><code class="hljs-code">client_credentials_grant_request = {
  <span class="hljs-string">"grant_type"</span>: <span class="hljs-string">"client_credentials"</span>,
  <span class="hljs-string">"client_id"</span> : <span class="hljs-string">"</span><span class="hljs-string">sts-delegation"</span>
}
delegation_headers = {
  <span class="hljs-string">"Authorization"</span>: <span class="hljs-string">"Bearer %s"</span> % pod_jwt
}
resp = requests.<span class="hljs-title">post</span>(<span class="hljs-string">"https://k8sou.IPADDR.nip.io/auth/idp/service-idp/token"</span>,verify=<span class="hljs-title">False</span>,data=client_credentials_grant_request,headers=delegation_headers)
response_payload = json.<span class="hljs-title">loads</span>(resp.<span class="hljs-property">text</span>)
actor_token = response_payload[<span class="hljs-string">"id_token"</span>]
</code></pre>
<p class="normal">We authenticate to OpenUnison using our Pod’s native identity. OpenUnison returns an <code class="inlineCode">access_token</code> and an <code class="inlineCode">id_token</code>, but we only need the <code class="inlineCode">id_token</code>. With our actor token in hand, we can now get our delegation token:</p>
<pre class="programlisting code"><code class="hljs-code">delegation_request = {
  <span class="hljs-string">"grant_type"</span>:<span class="hljs-string">"urn:ietf:params:oauth:grant-type:token-exchange"</span>,
  <span class="hljs-string">"audience"</span>:<span class="hljs-string">"pullfunds"</span>,
  <span class="hljs-string">"subject_token"</span>:user_jwt,
  <span class="hljs-string">"subject_token_type"</span>:<span class="hljs-string">"urn:ietf:params:oauth:token-type:id_token"</span>,
  <span class="hljs-string">"</span><span class="hljs-string">client_id"</span>:<span class="hljs-string">"sts-delegation"</span>,
  <span class="hljs-string">"actor_token"</span>: actor_token,
  <span class="hljs-string">"actor_token_type"</span>: <span class="hljs-string">"urn:ietf:params:oauth:token-type:id_token"</span>
}
resp = requests.<span class="hljs-title">post</span>(<span class="hljs-string">"https://k8sou.IPADDR.nip.io/auth/idp/service-idp/token"</span>,verify=<span class="hljs-title">False</span>,data=delegation_request)
response_payload = json.<span class="hljs-title">loads</span>(resp.<span class="hljs-property">text</span>)
delegation_token = response_payload[<span class="hljs-string">"</span><span class="hljs-string">id_token"</span>]
</code></pre>
<p class="normal">Similarly to impersonation, in this call, we not only send the original user’s token (<code class="inlineCode">user_jwt</code>) but also the <code class="inlineCode">actor_token</code> we just received from OpenUnison. We also don’t send an Authorization<a id="_idIndexMarker1688"/> header. The <code class="inlineCode">actor_token</code> authenticates us already. Finally, we’re able to use our returned token to call <code class="inlineCode">/pull-funds</code>.</p>
<p class="normal">Now that we’ve looked at the most correct way to call services, using both impersonation and delegation, let’s take a look at some anti-patterns and why you shouldn’t use them.</p>
<h3 class="heading-3" id="_idParaDest-588">Passing tokens between services</h3>
<p class="normal">Whereas,<a id="_idIndexMarker1689"/> in the previous section, we used an identity provider to generate either impersonation or delegation tokens, this method skips that and just passes the original token from service to service. This is a simple approach that’s easy to implement. It also creates a larger blast radius. If the token gets leaked (and given that it’s now being passed to multiple services, the likelihood of it leaking goes up quite a bit), you’ve now not only exposed one service; you’ve also exposed all the services that trust that token.</p>
<p class="normal">While using OAuth2 Token Exchange does require more work, it will limit your blast radius should a token be leaked. Next, we’ll look at how you can simply tell a downstream service who’s calling it.</p>
<h3 class="heading-3" id="_idParaDest-589">Using simple impersonation</h3>
<p class="normal">Where the previous <a id="_idIndexMarker1690"/>examples of service-to-service calls rely on a third party to generate a token for a user, direct impersonation is where your service’s code uses a service account (in the generic sense, not the Kubernetes version) to call the second service and just tells the service who the user is as an input to the call. For instance, instead of calling OpenUnison to get a new token, <code class="inlineCode">/write-check</code> could have just used the Pod’s <code class="inlineCode">ServiceAccount</code> token to call <code class="inlineCode">/check-funds</code>, with a parameter containing the user’s ID. Something like the following would work:</p>
<pre class="programlisting code"><code class="hljs-code">call_headers = {
  <span class="hljs-string">"Authorization"</span>: <span class="hljs-string">"Bearer %s"</span> % pod_jwt
}
resp = requests.<span class="hljs-title">post</span>(<span class="hljs-string">"https://write-checks.IPADDR.nip.io/check-funds?user=mmosley"</span>,verify=<span class="hljs-title">False</span>,data=impersonation_request,headers=call_headers)
</code></pre>
<p class="normal">This is, again, very simple. You can tell Istio to authenticate a Kubernetes <code class="inlineCode">ServiceAccount</code>. This takes two lines of code to do something that took 15 to 20 lines using a token service. Just like with passing tokens between services, this approach leaves you exposed in multiple ways. First, if anyone gets the <code class="inlineCode">ServiceAccount</code> used by our service, they <a id="_idIndexMarker1691"/>can impersonate anyone they want without checks. Using the token service ensures that a compromised service account doesn’t lead to it being used to impersonate anyone.</p>
<p class="normal">You might find this method very similar to the impersonation we used in <em class="chapterRef">Chapter 6</em>, <em class="italic">Integrating Authentication into Your Cluster</em>. You’re correct. While this uses the same mechanism, a <code class="inlineCode">ServiceAccount</code> and some parameters to specify who the user is, the type of impersonation Kubernetes uses for the API server is often referred to as a <strong class="keyWord">protocol transition</strong>. This<a id="_idIndexMarker1692"/> is used when you are moving from one protocol (OpenID Connect) to another (a Kubernetes service account). As we discussed in <em class="chapterRef">Chapter 5</em>, there are several controls you can put in place with Kubernetes impersonation, including using <code class="inlineCode">NetworkPolicies</code>, <code class="inlineCode">RBAC</code>, and the <code class="inlineCode">TokenRequest</code> API. It’s also a much more isolated use case than a generic service.</p>
<p class="normal">We’ve walked through multiple ways for services to call and authenticate each other. While it may not be the simplest way to secure access between services, it will limit the impact of a leaked token. Now that we know how our services will talk to each other, the last topic we need to cover is the relationship between Istio and API gateways.</p>
<h1 class="heading-1" id="_idParaDest-590">Do I need an API gateway?</h1>
<p class="normal">If you’re using Istio, do you <a id="_idIndexMarker1693"/>still need an API gateway? In the past, Istio was primarily concerned with routing traffic for services. It got traffic into the cluster and figured out where to route it to. API gateways have typically focused more on application-level functionality such as authentication, authorization, input validation, and logging.</p>
<p class="normal">For example, earlier in this chapter, we identified schema input validation as a process that needs to be repeated for each call and shouldn’t need to be done manually. This is important to protect against attacks that can leverage unexpected input, and it also makes for a better developer experience, providing feedback to developers sooner in the integration process. This is a common function for API gateways but is not available in Istio.</p>
<p class="normal">Another example<a id="_idIndexMarker1694"/> of a function that is not built into Istio but is common for API gateways is logging authentication and authorization decisions and information. Throughout this chapter, we leveraged Istio’s built-in authentication and authorization to validate service access, but Istio makes no record of that decision, other than that a decision was made. It doesn’t record who accessed a particular URL, only where it was accessed from. Logging who accessed a service, from an identity standpoint, is left to each individual service. This is a common function for API gateways.</p>
<p class="normal">Finally, API gateways are able to handle more complex transformations. Gateways will typically provide functionality for mapping inputs and outputs, or even integrating with legacy systems.</p>
<p class="normal">These functions could all be integrated into Istio, either directly or via Envoy filters. We saw an example of this when we looked at using OPA to make more complex authorization decisions than what the <code class="inlineCode">AuthorizationPolicy</code> object provides. However, over the last few releases, Istio has moved further into the realm of traditional API gateways, and API gateways have begun taking on more service mesh capabilities. I suspect there will be considerable overlap between these systems in the future, but at the time of writing, Istio isn’t yet capable of fulfilling all the functions of an API gateway.</p>
<p class="normal">We’ve had quite the journey building out the services for our Istio service mesh. You should now have the tools you need to begin building services in your own cluster.</p>
<h1 class="heading-1" id="_idParaDest-591">Summary</h1>
<p class="normal">In this chapter, we learned how both monoliths and microservices run in Istio. We explored why and when to use each approach. We deployed a monolith, taking care to ensure our monolith’s session management worked. We then moved into deploying microservices, authenticating requests, authorizing requests, and finally, how services can securely communicate. To wrap things up, we discussed whether an API gateway is still necessary when using Istio.</p>
<p class="normal">Istio can be complex, but when used properly, it can provide considerable power. What we didn’t cover in this chapter is how to build containers and manage the deployment of our services. We’re going to tackle that next, in <em class="chapterRef">Chapter 18</em>, <em class="italic">Provisioning a Multitenant Platform</em>.</p>
<h1 class="heading-1" id="_idParaDest-592">Questions</h1>
<ol>
<li class="numberedList" value="1">True or false: Istio is an API Gateway.<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">True</li>
<li class="alphabeticList level-2">False</li>
</ol>
</li>
</ol>
<p class="normal-one">Answer: b – False. Istio is a service mesh, and while it has many of the functions of a gateway, it doesn’t have all of them (such as schema checking).</p>
<ol>
<li class="numberedList" value="2">Should I always build applications as microservices?<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">Obviously – this is the right way.</li>
<li class="alphabeticList level-2">Only if a microservices architecture aligns with your organization’s structure and needs.</li>
<li class="alphabeticList level-2">No. Microservices are more trouble than they’re worth.</li>
<li class="alphabeticList level-2">What’s a microservice?</li>
</ol>
</li>
</ol>
<p class="normal-one">Answer: b – Microservices are great when you have a team that is able to make use of the granularity they provide.</p>
<ol>
<li class="numberedList" value="3">What is a monolith?<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">A large object that appears to be made from a single piece by an unknown maker</li>
<li class="alphabeticList level-2">An application that is self-contained</li>
<li class="alphabeticList level-2">A system that won’t run on Kubernetes</li>
<li class="alphabeticList level-2">A product from a new start-up</li>
</ol>
</li>
</ol>
<p class="normal-one">Answer: b – A monolith is a self-contained application that can run quite well on Kubernetes.</p>
<ol>
<li class="numberedList" value="4">How should you authorize access to your services in Istio?<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">You can write a rule that limits access in Istio by a claim in the token.</li>
<li class="alphabeticList level-2">You can integrate OPA with Istio for more complex authorization decisions.</li>
<li class="alphabeticList level-2">You can embed complex authorization decisions in your code.</li>
<li class="alphabeticList level-2">All of the above.</li>
</ol>
</li>
</ol>
<p class="normal-one">Answer: d – These are all valid strategies from a technical standpoint. Each situation is different, so look at each one to determine which one is best for you!</p>
<ol>
<li class="numberedList" value="5">True or false: Calling services on behalf of a user without token exchange is a secure approach.<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">True</li>
<li class="alphabeticList level-2">False</li>
</ol>
</li>
</ol>
<p class="normal-one">Answer: b. False – Without using token exchange to get a new token for when the user uses the next service, you leave yourself open to various attacks because you can’t limit calls or track them.</p>
<ol>
<li class="numberedList" value="6">True or false: Istio supports sticky sessions.<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">True</li>
<li class="alphabeticList level-2">False</li>
</ol>
</li>
</ol>
<p class="normal-one">Answer: a. True – They are not a default, but they are supported.</p>
<h1 class="heading-1" id="_idParaDest-593">Join our book’s Discord space</h1>
<p class="normal">Join the book’s Discord workspace for a monthly <em class="italic">Ask Me Anything</em> session with the authors:</p>
<p class="normal"><a href="https://packt.link/K8EntGuide"><span class="url">https://packt.link/K8EntGuide</span></a></p>
<p class="normal"><img alt="" height="176" src="../Images/QR_Code965214276169525265.png" width="176"/></p>
</div>
</div></body></html>