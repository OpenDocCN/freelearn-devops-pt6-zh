- en: Walking through Kubernetes Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解Kubernetes概念
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下操作：
- en: Linking Pods and containers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接Pods和容器
- en: Managing Pods with ReplicaSets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ReplicaSets管理Pods
- en: Deployment API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署API
- en: Working with Services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务（Services）
- en: Working with Volumes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用卷（Volumes）
- en: Working with Secrets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Secrets
- en: Working with names
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用名称
- en: Working with Namespaces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名空间（Namespaces）
- en: Working with labels and selectors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签和选择器
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will start by creating different kinds of resources on the
    Kubernetes system. In order to realize your application in a microservices structure,
    reading the recipes in this chapter will be a good start towards understanding
    the concepts of the Kubernetes resources and consolidating them. After you deploy
    applications in Kubernetes, you can work on its scalable and efficient container
    management, and also fulfill the DevOps delivering procedure of microservices.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从在Kubernetes系统上创建不同类型的资源开始。为了实现你的微服务结构应用，阅读本章的操作将是理解Kubernetes资源概念并加深理解的一个好开始。部署应用到Kubernetes后，你可以继续进行可扩展且高效的容器管理，同时也能完成微服务的DevOps交付流程。
- en: An overview of Kubernetes
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes概述
- en: Working with Kubernetes is quite easy, using either a **Command Line Interface**
    (**CLI**) or API (RESTful). This section will describe Kubernetes control by CLI.
    The CLI we use in this chapter is version 1.10.2.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes非常简单，可以通过**命令行接口**（**CLI**）或API（RESTful）进行操作。本节将介绍如何通过CLI控制Kubernetes。本章节使用的CLI版本是1.10.2。
- en: 'After you install Kubernetes master, you can run a `kubectl` command as follows.
    It shows the kubectl and Kubernetes master versions (both the API Server and CLI
    are v1.10.2):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Kubernetes master后，你可以运行如下的`kubectl`命令。它显示了kubectl和Kubernetes master的版本（API服务器和CLI版本都是v1.10.2）：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`kubectl` connects the Kubernetes API server using the RESTful API. By default,
    it attempts to access the localhost if `.kube/config` is not configured, otherwise
    you need to specify the API server address using the `--server` parameter. Therefore,
    it is recommended to use `kubectl` on the API server machine for practice.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`通过RESTful API连接Kubernetes API服务器。默认情况下，如果`.kube/config`没有配置，它会尝试访问本地主机，否则你需要使用`--server`参数指定API服务器地址。因此，建议在API服务器机器上使用`kubectl`进行实践。'
- en: If you use kubectl over the network, you need to consider authentication and
    authorization for the API server. See [Chapter 7](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Building Kubernetes on GCP*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过网络使用kubectl，你需要考虑API服务器的身份验证和授权。请参阅[第7章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)，*在GCP上构建Kubernetes*。
- en: '`kubectl` is the only command for Kubernetes clusters, and it controls the
    Kubernetes cluster manager. Find more information at [http://kubernetes.io/docs/user-guide/kubectl-overview/](http://kubernetes.io/docs/user-guide/kubectl-overview/).
    Any container, or Kubernetes cluster operation, can be performed by a `kubectl`
    command.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`是Kubernetes集群的唯一命令，它控制Kubernetes集群管理器。更多信息请访问[http://kubernetes.io/docs/user-guide/kubectl-overview/](http://kubernetes.io/docs/user-guide/kubectl-overview/)。任何容器或Kubernetes集群操作都可以通过`kubectl`命令执行。'
- en: In addition, kubectl allows the inputting of information via either the command
    line's optional arguments or a file (use the `-f` option); it is highly recommended
    to use a file, because you can maintain Kubernetes configuration as code. This
    will be described in detail in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，kubectl允许通过命令行的可选参数或文件（使用`-f`选项）输入信息；强烈建议使用文件，因为你可以将Kubernetes配置作为代码进行维护。本章将详细介绍这一点。
- en: 'Here is a typical `kubectl` command-line argument:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的`kubectl`命令行参数：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The attributes of the preceding command are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令的属性如下：
- en: '`command`: Specifies the operation that you want to perform on one or more
    resources.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command`：指定你希望对一个或多个资源执行的操作。'
- en: '`TYPE`: Specifies the resource type. Resource types are case-sensitive and
    you can specify the singular, plural, or abbreviated forms.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TYPE`：指定资源类型。资源类型区分大小写，你可以指定单数、复数或缩写形式。'
- en: '`NAME`: Specifies the name of the resource. Names are case-sensitive. If the
    name is omitted, details for all resources are displayed.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NAME`：指定资源的名称。名称区分大小写。如果省略名称，则会显示所有资源的详细信息。'
- en: '`flags`: Specifies optional flags.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`：指定可选的标志。'
- en: 'For example, if you want to launch `nginx`, you can use either the `kubectl
    run` command or the `kubectl create -f` command with the YAML file as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想启动 `nginx`，可以使用 `kubectl run` 命令或使用带有 YAML 文件的 `kubectl create -f` 命令，如下所示：
- en: 'Use the `run` command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `run` 命令：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Use the `create -f` command with the YAML file:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有 YAML 文件的 `create -f` 命令：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you want to see the status of the Deployment, type the `kubectl get` command
    as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想查看 Deployment 的状态，请输入 `kubectl get` 命令，如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you also want the support abbreviation, type the following:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还希望支持缩写，请输入以下内容：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you want to delete these resources, type the `kubectl delete` command as
    follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想删除这些资源，请输入 `kubectl delete` 命令，如下所示：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `kubectl` command supports many kinds of sub-commands; use the `-h` option
    to see the details, for example:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl` 命令支持多种子命令；使用 `-h` 选项查看详细信息，例如：'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This section describes how to use the `kubectl` command to control the Kubernetes
    cluster. The following recipes describe how to set up Kubernetes components:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了如何使用 `kubectl` 命令来控制 Kubernetes 集群。以下食谱描述了如何设置 Kubernetes 组件：
- en: '*Setting up a Kubernetes cluster on macOS using minikube* and *Set up a Kubernetes
    cluster on Windows** using minikube* in [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml),
    *Building Your Own Kubernetes Cluster*'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 minikube 在 macOS 上设置 Kubernetes 集群* 和 *使用 minikube 在 Windows 上设置 Kubernetes
    集群*，参见[第 1 章](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml)，*构建你自己的 Kubernetes 集群*'
- en: '*Setting up a Kubernetes cluster on Linux using kubeadm* in [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml),
    *Building Your Own Kubernetes Cluster*'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 kubeadm 在 Linux 上设置 Kubernetes 集群*，参见[第 1 章](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml)，*构建你自己的
    Kubernetes 集群*'
- en: '*Setting up a Kubernetes cluster on Linux using kubespray (Ansible) *in [Chapter
    1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml), *Building Your Own Kubernetes Cluster*'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 kubespray（Ansible）在 Linux 上设置 Kubernetes 集群*，参见[第 1 章](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml)，*构建你自己的
    Kubernetes 集群*'
- en: Linking Pods and containers
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接 Pods 和容器
- en: 'The Pod is a group of one or more containers and the smallest deployable unit
    in Kubernetes. Pods are always co-located and co-scheduled, and run in a shared
    context. Each Pod is isolated by the following Linux namespaces:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 是一个或多个容器的集合，是 Kubernetes 中最小的可部署单元。Pod 总是被共同定位和共同调度，并在共享上下文中运行。每个 Pod 都由以下
    Linux 命名空间进行隔离：
- en: The **process ID** (**PID**) namespace
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程 ID**（**PID**）命名空间'
- en: The network namespace
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络命名空间
- en: The **interprocess communication** (**IPC**) namespace
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程间通信**（**IPC**）命名空间'
- en: The **unix time sharing** (**UTS**) namespace
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unix 时间共享**（**UTS**）命名空间'
- en: In a pre-container world, they would have been executed on the same physical
    or virtual machine.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器化之前，它们会在同一台物理机或虚拟机上执行。
- en: It is useful to construct your own application stack Pod (for example, web server
    and database) that are mixed by different Docker images.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 构建你自己的应用栈 Pod（例如，Web 服务器和数据库），它们由不同的 Docker 镜像混合而成是很有用的。
- en: Getting ready
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You must have a Kubernetes cluster and make sure that the Kubernetes node has
    accessibility to the Docker Hub ([https://hub.docker.com](https://hub.docker.com))
    in order to download Docker images.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须拥有一个 Kubernetes 集群，并确保 Kubernetes 节点能够访问 Docker Hub（[https://hub.docker.com](https://hub.docker.com)）以便下载
    Docker 镜像。
- en: If you are running minikube, use `minikube ssh` to log on to the minikube VM
    first, then run the `docker pull` command.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行 minikube，首先使用 `minikube ssh` 登录到 minikube 虚拟机，然后运行 `docker pull` 命令。
- en: 'You can simulate downloading a Docker image by using the `docker pull` command
    as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式使用 `docker pull` 命令模拟下载 Docker 镜像：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following are the steps to create a Pod has 2 containers:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建包含 2 个容器的 Pod 的步骤：
- en: Log on to the Kubernetes machine (no need to log on if using minikube) and prepare
    the following YAML file. It defines the launch `nginx` container and the CentOS
    container.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 Kubernetes 机器（如果使用 minikube，则无需登录），并准备以下 YAML 文件。它定义了启动 `nginx` 容器和 CentOS
    容器。
- en: 'The `nginx` container opens the HTTP port (TCP/`80`). On the other hand, the
    CentOS container attempts to access the `localhost:80` every three seconds using
    the `curl` command:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nginx` 容器打开 HTTP 端口（TCP/`80`）。另一方面，CentOS 容器每三秒钟尝试使用 `curl` 命令访问 `localhost:80`：'
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, execute the `kubectl create` command to launch `my-first-pod` as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，执行 `kubectl create` 命令以启动 `my-first-pod`，如下所示：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It takes between a few seconds and a few minutes, depending on the network bandwidth
    of the Docker Hub and Kubernetes node's spec.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要几秒钟到几分钟的时间，具体取决于 Docker Hub 的网络带宽和 Kubernetes 节点的规格。
- en: 'You can check `kubectl get pods` to see the status, as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过 `kubectl get pods` 查看 Pod 的状态，如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now both the nginx container (`my-nginx`) and the CentOS container (`my-centos`)
    are ready.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`nginx` 容器（`my-nginx`）和 CentOS 容器（`my-centos`）都已经准备好。
- en: 'Let''s check whether the CentOS container can access `nginx` or not. You can
    run the `kubectl exec` command to run bash on the CentOS container, then run the `curl`
    command to access the `nginx`, as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查一下 CentOS 容器是否能访问 `nginx`。你可以运行 `kubectl exec` 命令在 CentOS 容器上运行 bash，然后使用
    `curl` 命令访问 `nginx`，如下所示：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the Pod links two different containers, `nginx` and `CentOS`,
    into the same Linux network namespace.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Pod 将两个不同的容器，`nginx` 和 `CentOS`，连接到同一个 Linux 网络命名空间中。
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When launching a Pod, the Kubernetes scheduler dispatches to the kubelet process
    to handle all the operations to launch both `nginx` and `CentOS` containers on
    one Kubernetes node.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Pod 时，Kubernetes 调度器会将任务分配给 kubelet 进程，处理在一个 Kubernetes 节点上启动 `nginx` 和 `CentOS`
    容器的所有操作。
- en: 'The following diagram illustrates these two containers and the Pod; these two
    containers can communicate via the localhost network, because within the Pod containers,
    it share the network interface:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了这两个容器和 Pod；这两个容器可以通过 localhost 网络进行通信，因为在 Pod 内的容器共享网络接口：
- en: '![](img/17157006-2419-4268-9291-481e14d19121.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17157006-2419-4268-9291-481e14d19121.png)'
- en: A Pod has two containers, which can communicate via localhost
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Pod 有两个容器，它们可以通过 localhost 进行通信。
- en: 'If you have two or more nodes, you can check the `-o wide` option to find a
    node which runs a Pod:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有两个或更多节点，可以检查 `-o wide` 选项以找到运行某个 Pod 的节点：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Log in to that node, then you can check the `docker ps | grep my-first-pod` command
    to see the running containers as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到该节点，然后可以使用 `docker ps | grep my-first-pod` 命令查看正在运行的容器，如下所示：
- en: '![](img/73ca0964-dd98-4df3-b84b-868116a59e25.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73ca0964-dd98-4df3-b84b-868116a59e25.png)'
- en: List of containers that belong to my-first-pod
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 属于 my-first-pod 的容器列表
- en: You may notice that `my-first-pod` contains three containers; `centos`, `nginx`,
    and `pause` are running instead of two. Because each Pod we need to keep belongs
    to a particular Linux namespace, if both the CentOS and nginx containers die,
    the namespace will also destroyed. Therefore, the pause container just remains
    in the Pod to maintain Linux namespaces.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到 `my-first-pod` 包含三个容器；`centos`、`nginx` 和 `pause` 容器都在运行，而不是两个。因为每个 Pod
    都属于一个特定的 Linux 命名空间，如果 CentOS 和 nginx 容器都死掉了，命名空间也会被销毁。因此，`pause` 容器会保留在 Pod 中，以维持
    Linux 命名空间。
- en: 'Let''s launch a second Pod, rename it as `my-second-pod`, and run the `kubectl`
    create command as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动第二个 Pod，将其重命名为 `my-second-pod`，并运行 `kubectl create` 命令，如下所示：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now you have two Pods; each Pod has two containers, `centos` and `nginx`. So
    a total of four containers are running on your Kubernetes cluster as in the following
    diagram:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有两个 Pod；每个 Pod 有两个容器，`centos` 和 `nginx`。因此，在 Kubernetes 集群中总共有四个容器，如下图所示：
- en: '![](img/75affb40-1877-4289-b830-42e63715dad9.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75affb40-1877-4289-b830-42e63715dad9.png)'
- en: Duplicate Pod from my-first-pod to my-second-pod
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从 my-first-pod 复制 Pod 到 my-second-pod
- en: If you would like to deploy more of the same Pod, consider using a Deployment
    (ReplicaSet) instead.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想部署更多相同的 Pod，可以考虑使用 Deployment（ReplicaSet）。
- en: 'After your testing, you can run the `kubectl` delete command to delete your
    Pod from the Kubernetes cluster:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，你可以运行 `kubectl delete` 命令从 Kubernetes 集群中删除 Pod：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See also
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'This recipe from this chapter described how to control Pods. They are the basic
    components of Kubernetes operation. The following recipes will describe the advanced
    operation of Pods using Deployments, Services, and so on:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的这一配方描述了如何控制 Pods。它们是 Kubernetes 操作的基本组成部分。接下来的配方将描述如何使用 Deployments、Services
    等进行高级 Pod 操作：
- en: '*Managing Pods with ReplicaSets*'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 ReplicaSets 管理 Pods*'
- en: '*Deployment API*'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Deployment API*'
- en: '*Working with Services *'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与服务一起工作*'
- en: '*Working with labels and selectors*'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用标签和选择器*'
- en: Managing Pods with ReplicaSets
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ReplicaSets 管理 Pods
- en: 'A ReplicaSet is a term for API objects in Kubernetes that refer to Pod replicas.
    The idea is to be able to control a set of Pods'' behaviors. The ReplicaSet ensures
    that the Pods, in the amount of a user-specified number, are running all the time.
    If some Pods in the ReplicaSet crash and terminate, the system will recreate Pods
    with the original configurations on healthy nodes automatically, and keep a certain
    number of processes continuously running. While changing the size of set, users
    can scale the application out or down easily. According to this feature, no matter
    whether you need replicas of Pods or not, you can always rely on ReplicaSet for
    auto-recovery and scalability. In this recipe, you''re going to learn how to manage
    your Pods with ReplicaSet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet 是 Kubernetes 中指代 Pod 副本的 API 对象的术语。其目的是能够控制一组 Pod 的行为。ReplicaSet
    确保用户指定数量的 Pod 始终在运行。如果 ReplicaSet 中的某些 Pod 崩溃并终止，系统将自动在健康节点上重新创建具有原始配置的 Pod，并保持一定数量的进程持续运行。在更改副本集大小时，用户可以轻松地扩展或缩减应用程序。根据这一特性，无论是否需要
    Pod 的副本，你都可以依赖 ReplicaSet 进行自动恢复和可扩展性管理。在这个教程中，你将学习如何使用 ReplicaSet 管理 Pod：
- en: '![](img/940902c6-7d59-4f0e-81c8-b2cebfc002be.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/940902c6-7d59-4f0e-81c8-b2cebfc002be.png)'
- en: ReplicaSet and their Pods on two nodes
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet 和它们的 Pod 在两个节点上
- en: 'The ReplicaSet usually handles a tier of applications. As you can see in the
    preceding diagram, we launch a ReplicaSet with three Pod replicas. Some mechanism
    details are listed as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet 通常处理一个应用层。正如在前面的图示中所看到的，我们启动了一个包含三个 Pod 副本的 ReplicaSet。以下是一些机制细节：
- en: The **kube-controller-manager** daemon helps to maintain the resource running
    in its desired state. For example, the desired state of ReplicaSet in the diagram
    is three Pod replicas.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-controller-manager** 守护进程帮助维持资源处于其期望的状态。例如，图示中 ReplicaSet 的期望状态是三个 Pod
    副本。'
- en: The **kube-scheduler** daemon on master, the scheduler of Kubernetes, takes
    charge of assigning tasks to healthy nodes.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-scheduler** 守护进程（Kubernetes 的调度器）负责将任务分配给健康的节点。'
- en: The selector of the ReplicaSet is used for deciding which Pods it covers. If
    the key-value pairs in the Pod's label include all items in the selector of the
    ReplicaSet, this Pod belongs to this ReplicaSet. As you will see, the diagram
    shows three Pods are under the charge of the ReplicaSet. Even though Pod 2 has
    a different label of `env`, it is selected since the other two labels, `role`
    and `project`, match the ReplicaSet's selector.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReplicaSet 的选择器用于决定它覆盖哪些 Pod。如果 Pod 标签中的键值对包含 ReplicaSet 选择器中的所有项，则该 Pod 属于该
    ReplicaSet。如你所见，图示显示三个 Pod 由 ReplicaSet 管理。尽管 Pod 2 的 `env` 标签不同，但由于其他两个标签 `role`
    和 `project` 与 ReplicaSet 的选择器匹配，它仍然被选中。
- en: '**ReplicationController? ReplicaSet?** For experienced Kubernetes players,
    you may notice ReplicaSet looks quite similar to the ReplicationController. Since
    version 1.2 of Kubernetes, in order to concentrate on different features, the
    ReplicationController''s functionality has been covered by ReplicaSet and Deployment.
    ReplicaSet focuses on the Pod replica, keeping certain Pods running in healthy
    states. On the other hand, Deployment is a higher-level API, which can manage
    the ReplicaSet, perform application rolling updates, and expose the services.
    In Kubernetes v1.8.3, users can still create replication controllers. However,
    using Deployment with ReplicaSet is more recommended because these are up to date
    and have finer granularity of configuration.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**ReplicationController？ReplicaSet？** 对于经验丰富的 Kubernetes 用户，你可能会注意到 ReplicaSet
    看起来与 ReplicationController 非常相似。自 Kubernetes 1.2 版本以来，为了集中关注不同的功能，ReplicationController
    的功能已被 ReplicaSet 和 Deployment 覆盖。ReplicaSet 关注 Pod 副本，确保特定的 Pod 始终保持在健康状态。另一方面，Deployment
    是一个更高级的 API，可以管理 ReplicaSet，执行应用程序的滚动更新并公开服务。在 Kubernetes v1.8.3 中，用户仍然可以创建复制控制器。然而，建议使用与
    ReplicaSet 一起使用的 Deployment，因为这些是最新的，并且具有更细粒度的配置。'
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Creating a ReplicaSet is the same as creating any Kubernetes resource; we fire
    the `kubectl` command on the Kubernetes master. Therefore, we ensure your Kubernetes
    environment is ready to accept your order. More than that, the Kubernetes node
    should be able to access the Docker Hub. For the demonstration in the following
    few pages, we would take official `nginx` docker image for example, which stores
    in public docker registry as well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 ReplicaSet 与创建任何 Kubernetes 资源相同；我们在 Kubernetes 主节点上执行 `kubectl` 命令。因此，我们需要确保你的
    Kubernetes 环境已准备好接受命令。此外，Kubernetes 节点应能够访问 Docker Hub。接下来的几页演示中，我们将以官方的 `nginx`
    Docker 镜像为例，该镜像也存储在公共 Docker 注册表中。
- en: '**The evaluation of a prepared Kubernetes system** You can verify whether your
    Kuberenetes master is a practical one through checking the items here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**评估已准备好的Kubernetes系统**：你可以通过检查这里的项目来验证你的Kubernetes主节点是否是一个可用的系统：'
- en: '**Check whether the daemons are running or no**t: There should be three working
    daemon processes on the master node: `apiserver`, `scheduler`, and `controller-manager`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查守护进程是否正在运行**：主节点上应该有三个正在运行的守护进程：`apiserver`、`scheduler`和`controller-manager`。'
- en: '**Check whether the command kubectl exists and is workable**: Try the command
    `kubectl get cs` to cover this bullet point and the first one. You can verify
    not only the status of components but also the feasibility of `kubectl`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查命令kubectl是否存在且可用**：尝试使用命令`kubectl get cs`来检查此项目和第一个项目。你不仅可以验证组件的状态，还可以验证`kubectl`的可用性。'
- en: '**Check whether the nodes are ready to work**: You can check them by using
    the command `kubectl get nodes` to get their status.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查节点是否准备好工作**：你可以通过使用命令`kubectl get nodes`来检查它们的状态。'
- en: In the case that some items listed here are invalid, please refer to [Chapter
    1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml), *Building Your Own Kubernetes
    Cluster,* for proper guidelines based on the installation you chose.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这里列出的某些项目无效，请参考[第1章](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml)，*构建你自己的Kubernetes集群*，根据你选择的安装方式获取正确的指导。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this section, we will demonstrate the life cycle of a ReplicaSet from creation
    to destruction.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示ReplicaSet从创建到销毁的生命周期。
- en: Creating a ReplicaSet
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ReplicaSet
- en: 'When trying to use the command line to launch a Kubernetes Service immediately,
    we usually fire `kubectl run`. However, it would creates a Deployment by default,
    and not only taking care of the Pod replica but also providing a container-updating
    mechanism. To simply create a standalone ReplicaSet, we can exploit a configuration
    YAML file and run it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试使用命令行立即启动Kubernetes服务时，我们通常会使用`kubectl run`。但是，它默认会创建一个Deployment，不仅处理Pod副本，还提供容器更新机制。为了简单地创建一个独立的ReplicaSet，我们可以利用一个配置YAML文件并执行它：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding file is the YAML for our first ReplicaSet. It defines a ReplicaSet
    named `my-first-replicaset`, which has three replicas for its Pods. Labels and
    the selector are the most characteristic settings of ReplicaSet. There are two
    sets of labels: one for ReplicaSet, the other for Pods. The first label for ReplicaSet
    is under the metadata of this resource, right beneath the name, which is simply
    used for description. However, the other label value under the template''s metadata,
    the one for Pods, is also used for identification. ReplicaSet takes charge of
    the Pods which have the labels covered by its selector.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件是我们第一个ReplicaSet的YAML配置文件。它定义了一个名为`my-first-replicaset`的ReplicaSet，具有三个Pod副本。标签和选择器是ReplicaSet最具特色的设置。这里有两组标签：一组用于ReplicaSet，另一组用于Pods。ReplicaSet的第一个标签位于该资源的metadata下，在名称下方，主要用于描述。而位于模板metadata下的另一个标签值，用于Pods，也是用于标识。ReplicaSet管理其选择器所包含标签的Pods。
- en: 'In our example configuration file, the selector of ReplicaSet looks for Pods
    with `project: My-Happy-Web` and `role: frontend` tags. Since we initiate Pods
    under control of this ReplicaSet, the Pods'' labels should definitely include
    what selector cares. You may get following error message while creating a ReplicaSet
    with incorrectly labeled Pods: `` `selector` does not match template `labels`
    ``.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的示例配置文件中，ReplicaSet的选择器会查找带有`project: My-Happy-Web`和`role: frontend`标签的Pods。由于我们在此ReplicaSet的控制下启动Pods，因此Pods的标签应该必定包含选择器所关注的标签。你在创建带有错误标签的ReplicaSet时可能会遇到以下错误信息：``
    `selector` does not match template `labels` ``。'
- en: 'Now, let''s create ReplicaSet through this file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过这个文件来创建ReplicaSet：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**The API version of ReplicaSet in Kubernetes v1.9**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes v1.9中ReplicaSet的API版本**'
- en: While this book is under construction, Kubernetes v1.9 is released. The API
    version of ReplicaSet turns to a stable version `apps/v1` instead of `apps/v1beta2`.
    If you have an older version Kubernetes, please change the value of `apiVersion` to
    `apps/v1beta2`, or you can just update your Kubernetes system.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当本书编写时，Kubernetes v1.9已发布。ReplicaSet的API版本变更为稳定版本`apps/v1`，不再是`apps/v1beta2`。如果你使用的是旧版Kubernetes，请将`apiVersion`的值更改为`apps/v1beta2`，或者直接更新你的Kubernetes系统。
- en: Getting the details of a ReplicaSet
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取ReplicaSet的详细信息
- en: 'After we create the ReplicaSet, the subcommands `get` and `describe` can help
    us to capture its information and the status of Pods. In the CLI of Kubernetes,
    we are able to use the abbreviation rs for resource type, instead of the full
    name ReplicaSet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 ReplicaSet 后，子命令 `get` 和 `describe` 可以帮助我们获取其信息以及 Pod 的状态。在 Kubernetes 的
    CLI 中，我们可以使用 `rs` 来代替完整的资源类型名称 ReplicaSet：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This result shows roughly that the Pod replicas of `my-first-replicaset` are
    all running successfully; currently running Pods are of the desired number and
    all of them are ready for serving requests.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该结果大致显示 `my-first-replicaset` 的 Pod 副本都已成功运行；当前运行的 Pod 数量与期望的一致，并且它们都已准备好接受请求。
- en: 'For detailed information, check by using the subcommand `describe`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详细信息，请使用子命令 `describe` 查看：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can see that the output lists ReplicaSet''s particulars of the configuration,
    just like what we requested in the YAML file. Furthermore, the logs for the creation
    of Pods are shown as part of ReplicaSet, which confirms that the Pod replicas
    are successfully created and designated with unique names. You can also check
    Pods by name:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到输出列出了 ReplicaSet 配置的详细信息，就像我们在 YAML 文件中请求的那样。此外，Pod 创建的日志作为 ReplicaSet
    的一部分显示出来，这确认了 Pod 副本已成功创建，并且被指定了唯一名称。你也可以通过名称检查 Pod：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Changing the configuration of a ReplicaSet
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改 ReplicaSet 的配置
- en: The subcommands known as `edit`, `patch`, and `replace` can help to update live
    Kubernetes resources. All these functionalities change the settings by way of
    modifying a configuration file. Here we just take `edit`, for example.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为 `edit`、`patch` 和 `replace` 的子命令可以帮助更新 Kubernetes 中的实时资源。所有这些功能通过修改配置文件的方式来更改设置。在这里我们以
    `edit` 为例。
- en: 'The subcommand edit lets users modify resource configuration through the editor.
    Try to update your ReplicaSet through the command `kubectl edit rs $REPLICASET_NAME`;
    you will access this resource via the default editor with a YAML configuration
    file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 子命令 `edit` 允许用户通过编辑器修改资源配置。尝试通过命令 `kubectl edit rs $REPLICASET_NAME` 更新你的 ReplicaSet；你将通过默认编辑器访问这个资源，编辑一个
    YAML 配置文件：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the demonstration, we succeed to add one Pod in the set, yet this is not
    the best practice for auto-scaling the Pod. Take a look at the *Working with configuration
    files* recipe in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml), *Playing
    with Containers*,for Reference, and try to change the other values.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示中，我们成功地向该集合中添加了一个 Pod，但这不是自动扩缩容 Pod 的最佳实践。请查看[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)中*处理配置文件*的示例，参考其中的*容器操作*部分，并尝试修改其他值。
- en: Deleting a ReplicaSet
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除 ReplicaSet
- en: 'In order to remove the ReplicaSet from the Kubernetes system, you can rely
    on the subcommand `delete`. When we fire `delete` to remove the resource, it removes
    the target objects forcefully:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 Kubernetes 系统中删除 ReplicaSet，你可以依赖子命令 `delete`。当我们执行 `delete` 来删除资源时，它会强制删除目标对象：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We find that the response time is quite short and the effect is also instantaneous.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现响应时间非常短，效果也立即体现。
- en: '**Removing the Pod under ReplicaSet** As we mentioned previously, it is impossible
    to scale down the ReplicaSet by deleting the Pod, because while a Pod is removed,
    the ReplicaSet is out of stable status: if the desired number of Pods is not met,
    and the controller manager will ask ReplicaSet to create another one. The concept
    is shown in the following commands:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除 ReplicaSet 下的 Pod** 如前所述，无法通过删除 Pod 来缩减 ReplicaSet 的规模，因为在删除 Pod 时，ReplicaSet
    会处于不稳定状态：如果期望的 Pod 数量未达到，控制器管理器会要求 ReplicaSet 创建另一个 Pod。这个概念可以通过以下命令展示：'
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You will find that although the `my-first-replicaset-bxf45` Pod is removed,
    the `my-first-replicaset-dvbpg` Pod is created automatically and attached to this
    ReplicaSet.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，尽管 `my-first-replicaset-bxf45` Pod 被删除，但 `my-first-replicaset-dvbpg` Pod
    会自动创建并附加到该 ReplicaSet 中。
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The ReplicaSet defines a set of Pods by using a Pod template and labels. As
    in the ideas from previous sections, the ReplicaSet only manages the Pods via
    their labels. It is possible that the Pod template and the configuration of the
    Pod are different. This also means that standalone Pods can be added into a set
    by using label modification.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet 通过使用 Pod 模板和标签来定义一组 Pod。如前面章节中的思路，ReplicaSet 仅通过标签管理 Pod。这也意味着 Pod
    模板和 Pod 配置可能不同。这也意味着，可以通过修改标签将独立的 Pod 添加到集合中。
- en: 'Let''s evaluate this concept of selectors and labels by creating a ReplicaSet
    similar to the diagram at the beginning of this recipe:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个与本配方开头的图示类似的 ReplicaSet，来评估选择器和标签的概念：
- en: '![](img/dd292c2f-714e-431e-a7f0-c134076653fe.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd292c2f-714e-431e-a7f0-c134076653fe.png)'
- en: The ReplicaSet would cover Pods which have the same labels describing in its
    selector
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet 会管理具有相同标签的 Pods，这些标签在其选择器中有所描述。
- en: 'First, we are going to create a CentOS Pod with the labels project: `My-Happy-Web`,
    `role: frontend`, and `env: test`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们将创建一个 CentOS Pod，并为其指定标签 `project: My-Happy-Web`、`role: frontend` 和 `env:
    test`：'
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After adding this command, a standalone Pod runs with the labels we specified.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此命令后，带有我们指定标签的 standalone Pod 会运行。
- en: 'Next, go create your first ReplicaSet example by using the YAML file again:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 YAML 文件再次创建你的第一个 ReplicaSet 示例：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As in the preceding result, only two Pods are created. It is because the Pod
    `standalone-pod` is considered one of the sets taken by `my-first-replicaset`.
    Remember that `my-first-replicaset` takes care of the Pods labeled with project: `My-Happy-Web`
    and `role:frontend` (ignore the `env `tag). Go check the standalone Pod; you will
    find it belongs to a member of the ReplicaSet as well:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '如前述结果所示，只有两个 Pod 被创建。这是因为 Pod `standalone-pod` 被认为是 `my-first-replicaset` 所管理的一部分。请记住，`my-first-replicaset`
    会管理带有标签 `project: My-Happy-Web` 和 `role:frontend` 的 Pod（忽略 `env` 标签）。去检查 standalone
    Pod，你会发现它也是 ReplicaSet 的一部分：'
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Similarly, once we delete the set, the standalone Pod will be removed with
    the group:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，一旦我们删除该 ReplicaSet，独立的 Pod 也将与其一起被移除：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There's more...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'There are multiple Kubernetes resources for Pod management. Users are encouraged
    to leverage various types of resources to meet different purposes. Let''s comparing
    the resource types listed below with ReplicaSet:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了多种 Pod 管理资源。鼓励用户利用不同类型的资源以满足不同的需求。让我们将以下列出的资源类型与 ReplicaSet 进行比较：
- en: '**Deployment**: In general cases, Kubernetes Deployments are used together
    with ReplicaSet for complete Pod management: container rolling updates, load balancing,
    and service exposing.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deployment**：在一般情况下，Kubernetes Deployment 与 ReplicaSet 一起使用，以实现完整的 Pod 管理：容器滚动更新、负载均衡和服务暴露。'
- en: '**Job**: Sometimes, we want the Pods run as a job instead of a service. A Kubernetes
    job is suitable for this situation. You can consider it a ReplicaSet with the
    constraint of termination.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Job**：有时，我们希望 Pod 作为作业而不是服务运行。Kubernetes 的 Job 适用于这种情况。可以把它看作是一个带有终止约束的 ReplicaSet。'
- en: '**DaemonSet**: More than ReplicaSet, the Kubernetes DaemonSet guarantees that
    the specified set is running on every node in the cluster. That said, a subset
    of ReplicaSet on every node.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DaemonSet**：与 ReplicaSet 不同，Kubernetes DaemonSet 保证在集群中的每个节点上都运行指定的 Pod。换句话说，它是在每个节点上部署
    ReplicaSet 的一个子集。'
- en: To get more idea and instruction, you can check the recipe *Ensuring flexible
    usage of your containers* in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 想要获得更多的想法和指导，可以查看 [第 3 章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)中的配方 *确保容器的灵活使用*，《**玩转容器**》。
- en: See also
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'Now you understand the idea of ReplicaSet. Continue to look up the following
    recipes in this chapter for more Kubernetes resources, which will allow you to
    explore the magical effects of ReplicaSet:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了 ReplicaSet 的概念。继续查阅本章中的其他配方，探索更多 Kubernetes 资源，进一步体验 ReplicaSet 的神奇效果：
- en: '*Deployment API*'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署 API*'
- en: '*Working with Services*'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用服务*'
- en: '*Working with labels an selectors*'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用标签和选择器*'
- en: 'Moreover, since you have built a simple ReplicaSet by using a configuration
    file, refer to more details about creating your own configuration files for Kubernetes
    resources:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于你已经使用配置文件创建了一个简单的 ReplicaSet，请参考有关为 Kubernetes 资源创建自定义配置文件的更多详细信息：
- en: '*Working with configuration files* section in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    **Playing with Containers**'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置文件操作* 部分在 [第 3 章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)，《**玩转容器**》'
- en: Deployment API
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署 API
- en: The Deployment API was introduced in Kubernetes version 1.2\. It is replacing
    the replication controller. The functionalities of rolling-update and rollback
    by replication controller, it was achieved with client side (`kubectl` command
    and `REST API`), that `kubectl` need to keep connect while updating a replication
    controller. On the other hand, Deployments takes care of the process of rolling-update
    and rollback at the server side. Once that request is accepted, the client can
    disconnect immediately.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment API是在Kubernetes 1.2版本中引入的。它取代了复制控制器。复制控制器的滚动更新和回滚功能是通过客户端（`kubectl`命令和`REST
    API`）来实现的，`kubectl`需要在更新复制控制器时保持连接。另一方面，Deployments在服务器端处理滚动更新和回滚的过程。一旦请求被接受，客户端可以立即断开连接。
- en: Therefore, the Deployments API is designed as a higher-level API to manage ReplicaSet
    objects. This section will explore how to use the Deployments API to manage ReplicaSets.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Deployments API被设计为一个更高层次的API来管理ReplicaSet对象。本节将探讨如何使用Deployments API来管理ReplicaSets。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to create Deployment objects, as usual, use the `kubectl run` command
    or prepare the YAML/JSON file that describe Deployment configuration. This example
    is using the `kubectl run` command to create a `my-nginx` Deployment object:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建Deployment对象，通常使用`kubectl run`命令，或者准备描述Deployment配置的YAML/JSON文件。这个示例使用`kubectl
    run`命令来创建`my-nginx` Deployment对象：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, a Deployment object `my-nginx` creates one `ReplicaSet`, which
    has an identifier: `<Deployment name>-<hex decimal hash>`. And then ReplicaSet
    creates three Pods which have an identifier: `<ReplicaSet id>-<random id>`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Deployment对象`my-nginx`创建了一个`ReplicaSet`，它有一个标识符：`<Deployment name>-<hex
    decimal hash>`。然后ReplicaSet创建了三个Pod，它们的标识符为：`<ReplicaSet id>-<random id>`。
- en: Until Kubernetes version 1.8, `<Deployment name>-<pod-template-hash value (number)>`
    was used as a ReplicaSet identifier instead of a hex decimal hash.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes v1.8版本之前，`<Deployment name>-<pod-template-hash value (number)>`
    被用作ReplicaSet的标识符，而不是十六进制哈希值。
- en: For more details, look at pull request: [https://github.com/kubernetes/kubernetes/pull/51538](https://github.com/kubernetes/kubernetes/pull/51538).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 更多细节，请查看拉取请求：[https://github.com/kubernetes/kubernetes/pull/51538](https://github.com/kubernetes/kubernetes/pull/51538)。
- en: 'This diagram illustrates the **Deployment**, **ReplicaSet**, and **Pod** relationship:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了**Deployment**、**ReplicaSet**和**Pod**之间的关系：
- en: '![](img/48a785dd-5ce1-4a9b-8145-9d8aacdfd6e9.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48a785dd-5ce1-4a9b-8145-9d8aacdfd6e9.png)'
- en: Relationship diagram for Deployments, ReplicaSets, and Pods
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment、ReplicaSet和Pod的关系图
- en: 'Because of this relationship, if you perform `delete` on a `my-nginx` Deployment
    object, it will also attempt to delete ReplicaSet and Pods respectively:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种关系，如果你对`my-nginx` Deployment对象执行`delete`操作，它也会尝试删除相应的ReplicaSet和Pods：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This example is just a simple `create` and `delete`, that easy to understand
    Deployment object and ReplicaSet object 1:1 relationship at this moment. However,
    a Deployment object can manage many ReplicaSets to preserve as a history. So the
    actual relationship is 1:N, as in the following diagram:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例只是一个简单的`create`和`delete`，此时可以轻松理解Deployment对象和ReplicaSet对象之间1:1的关系。然而，Deployment对象可以管理多个ReplicaSets来保存历史记录。所以，实际的关系是1:N，如下图所示：
- en: '![](img/48c720e2-16f1-473d-aa22-aad05204a347.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48c720e2-16f1-473d-aa22-aad05204a347.png)'
- en: Deployments maintain ReplicaSet history
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Deployments维护ReplicaSet的历史记录
- en: To understand the 1:N relationship, let's recreate this Deployment object again
    and perform to make some changes to see how Deployment manages ReplicaSet history.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解1:N关系，让我们重新创建这个Deployment对象，并进行一些操作，看看Deployment如何管理ReplicaSet的历史记录。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: You may run the `kubectl run` command to recreate `my-nginx`, or write a Deployments
    configuration file that produces the same result. This is a great opportunity
    to learn about the Deployment configuration file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行`kubectl run`命令来重新创建`my-nginx`，或者编写一个Deployment配置文件来实现相同的结果。这是一个很好的机会来学习Deployment配置文件。
- en: 'This example is an equivalent of `kubectl run my-nginx --image=nginx:1.11.0
    --port=80 --replicas=3`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例等同于 `kubectl run my-nginx --image=nginx:1.11.0 --port=80 --replicas=3`：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These parameters, sorted by key and value, are described here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数按键值对排序，具体描述如下：
- en: '| **Key** | **Value** | **Description** |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| **Key** | **Value** | **Description** |'
- en: '| `apiVersion` | `apps/v1` | Until Kubernetes v1.8, it had been used apps/v1Beta1,
    v1.8 used apps/v1Beta2, then v1.9 or later use apps/v1 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `apiVersion` | `apps/v1` | 在Kubernetes v1.8之前，使用的是apps/v1Beta1，v1.8使用的是apps/v1Beta2，之后v1.9及更高版本使用apps/v1
    |'
- en: '| `kind` | `deployment` | Indicates that this is a set of Deployment configurations
    |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `kind` | `deployment` | 表示这是一个Deployment配置集 |'
- en: '| `metadata.name` | `my-nginx` | Name of Deployment |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `metadata.name` | `my-nginx` | Deployment的名称 |'
- en: '| `spec.replicas` | `3` | Desire to have three Pods |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `spec.replicas` | `3` | 希望有三个Pod |'
- en: '| `spec.selector.matchLabels` | `run:my-nginx` | Control ReplicaSet/Pods which
    have this label |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `spec.selector.matchLabels` | `run:my-nginx` | 控制具有此标签的ReplicaSet/Pods |'
- en: '| `spec.template.metadata.labels` | `run:my-nginx` | Assigns this label when
    creating a ReplicaSet/Pod; it must match `spec.selector.matchLabels` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `spec.template.metadata.labels` | `run:my-nginx` | 创建ReplicaSet/Pod时分配此标签；必须与`spec.selector.matchLabels`匹配
    |'
- en: '| `spec.template.spec.containers` | name: `my-nginx`image: `nginx:1.11.0`port:`-
    containerPort:80` | ReplicaSet creates and manages Pods which have:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '| `spec.template.spec.containers` | name: `my-nginx`image: `nginx:1.11.0`port:`-
    containerPort:80` | ReplicaSet创建和管理包含以下内容的Pods：'
- en: name as `my-nginx`
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称为`my-nginx`
- en: Container image as nginx version 1.11.0
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像为nginx版本1.11.0
- en: Publish port number `80`
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布端口号`80`
- en: '|'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If you use this YAML file to create a Deployment, use the `kubectl create` command
    instead of `kubectl run`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这个YAML文件来创建Deployment，应该使用`kubectl create`命令，而不是`kubectl run`。
- en: 'Note that, this time, you should also specify `--save-config`, which allows
    you to update the resource using the `kubectl apply` command in the future. In
    addition, specify `--record` which can store the command line history. Those two
    options are not mandatory to manage ReplicaSet history but help you to preserve
    better information:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此时，你还应指定`--save-config`，这将允许你以后使用`kubectl apply`命令更新资源。此外，指定`--record`可以存储命令行历史记录。这两个选项并非管理ReplicaSet历史记录的必需，但有助于你更好地保存信息：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can see a property `OldReplicaSets` and  `NewReplicaSet` in the preceding
    code, which are some association between Deployment and ReplicaSet.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的代码中看到`OldReplicaSets`和`NewReplicaSet`属性，它们表示Deployment和ReplicaSet之间的某些关联。
- en: Whenever you update a definition of a container template, for example, changing
    the nginx image version from 1.11.0 to 1.12.0, then Deployment `my-nginx` will
    create a new ReplicaSet. Then the property `NewReplicaSet` will point to the new
    ReplicaSet which has nginx version 1.12.0.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你更新容器模板的定义时，例如，将nginx镜像版本从1.11.0更改为1.12.0，Deployment `my-nginx`将创建一个新的ReplicaSet。然后，`NewReplicaSet`属性将指向使用nginx版本1.12.0的新ReplicaSet。
- en: On the other hand, the `OldReplicaSets` property points to an old ReplicaSet
    which has nginx version 1.11.0 until new ReplicaSet is complete to setup new Pod.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`OldReplicaSets`属性指向一个旧的ReplicaSet，该ReplicaSet使用的是nginx版本1.11.0，直到新的ReplicaSet完成并设置新的Pod。
- en: These old/new ReplicaSet associations between Deployment, Kubernetes administrator
    can easy to achieve rollback operation in case new ReplicaSet has any issues.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些旧的/新的ReplicaSet与Deployment之间的关联，Kubernetes管理员可以轻松地进行回滚操作，以防新的ReplicaSet出现问题。
- en: In addition, Deployment can keep preserves the history of ReplicaSet which were
    associated with it before. Therefore, Deployment can anytime to change back (rollback)
    to any point of older ReplicaSet.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Deployment可以保留与其之前关联的ReplicaSet的历史记录。因此，Deployment可以随时回滚到任何旧的ReplicaSet。
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As mentioned earlier, let''s bump the nginx image version from 1.11.0 to 1.12.0\.
    There are two ways to change the container image: use the `kubectl set` command,
    or update YAML then use the `kubectl apply` command.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，假设我们将nginx镜像版本从1.11.0升级到1.12.0。有两种方法可以更改容器镜像：使用`kubectl set`命令，或更新YAML文件然后使用`kubectl
    apply`命令。
- en: Using the `kubectl set` command is quicker and there is better visibility when
    using the `--record` option.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl set`命令更快捷，并且当使用`--record`选项时可提供更好的可视化效果。
- en: On the other hand, updating YAML and using the `kubectl apply` command is better
    to preserve the entire Deployment YAML configuration file, which is better when
    using a version control system such as `git`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，更新YAML并使用`kubectl apply`命令更适合保留整个Deployment YAML配置文件，在使用版本控制系统（如`git`）时更为有利。
- en: Using kubectl set to update the container image
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用kubectl set更新容器镜像
- en: 'Use the `kubectl set` command allows us to overwrite the `spec.template.spec.containers[].image`
    property that is similar to using the `kubectl run` command to specify the image
    file. The following example specifies `my-nginx` deployment to set the container
    `my-nginx` to change the image to nginx version 1.12.0:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl set`命令允许我们覆盖`spec.template.spec.containers[].image`属性，这类似于使用`kubectl
    run`命令指定镜像文件。以下示例指定`my-nginx` Deployment，将容器`my-nginx`的镜像更改为nginx版本1.12.0：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, `OldReplicaSets` becomes the previous `ReplicaSet` (`my-nginx-54bb7bbcf9`)
    and `NewReplicaSet` becomes `my-nginx-77769b7666`. Note that you can see the `OldReplicaSets`
    property until `NewReplicaSet` is ready, so once the new `ReplicaSet` is successfully
    launched, `OldReplicaSet` becomes `<none>`, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`OldReplicaSets`变为之前的`ReplicaSet`（`my-nginx-54bb7bbcf9`），而`NewReplicaSet`变为`my-nginx-77769b7666`。请注意，您可以看到`OldReplicaSets`属性，直到`NewReplicaSet`准备就绪，所以一旦新的`ReplicaSet`成功启动，`OldReplicaSet`将变为`<none>`，如下所示：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you can see the `ReplicaSet` list by `kubectl get rs`, you can see two ReplicaSet,
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以通过`kubectl get rs`看到`ReplicaSet`列表，则可以看到两个`ReplicaSet`，如下所示：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, in the old `ReplicaSet` (`my-nginx-54bb7bbcf9`), the numbers
    of `DESIRED/CURRENT/READY` pods are all zero.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在旧的`ReplicaSet`（`my-nginx-54bb7bbcf9`）中，`DESIRED/CURRENT/READY`的Pod数都是零。
- en: 'In addition, because the preceding example uses the `--record` option, you
    can see the history of the Deployment `my-nginx` rollout with the `kubectl rollout
    history` command, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于前面的示例使用了`--record`选项，您可以使用`kubectl rollout history`命令查看Deployment `my-nginx`的部署历史，如下所示：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Updating the YAML and using kubectl apply
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新YAML并使用kubectl apply
- en: 'For demo purposes, copy `deploy.yaml` to `deploy_1.12.2.yaml` and change the
    `nginx` version to `1.12.2`, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 出于演示目的，将`deploy.yaml`复制到`deploy_1.12.2.yaml`并将`nginx`版本更改为`1.12.2`，如下所示：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then run the `kubectl apply` command with the `--record` option:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行带有`--record`选项的`kubectl apply`命令：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will perform the same thing as the `kubectl set` image command, so you
    can see that the nginx image version has been bumped up to `1.12.2`; also, the
    `OldReplicaSets`/`NewReplicaSet` combination has been changed as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行与`kubectl set`镜像命令相同的操作，因此您可以看到nginx镜像版本已升级到`1.12.2`；此外，`OldReplicaSets`/`NewReplicaSet`的组合已更改如下：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After a few moments, `NewReplicaSet` will be ready. Then there will be a total
    of three `ReplicaSets` existing on your system:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，`NewReplicaSet`将准备就绪。然后系统中将总共有三个`ReplicaSets`：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can also see the rollout history:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以查看部署历史：
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Whenever you want to revert to a previous `ReplicaSet`, which means rolling
    back to the previous nginx version, you can use `kubectl rollout undo` with the
    `--to-revision` option. For example, if you want to roll back to revision 2 in
    your history (`kubectl set image deployment/my-nginx my-nginx=nginx:1.12.0 --record=true`),
    specify `--to-revision=2`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您想要回滚到之前的`ReplicaSet`，即回到之前的nginx版本时，可以使用带有`--to-revision`选项的`kubectl rollout
    undo`。例如，如果您想回滚到历史记录中的修订版2（`kubectl set image deployment/my-nginx my-nginx=nginx:1.12.0
    --record=true`），可以指定`--to-revision=2`：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'A few moments later, Deployment will deactivate the current `ReplicaSet`, which
    uses the Pod template with `nginx` version `1.12.2`, and will then activate the `ReplicaSet`
    which uses `nginx` version `1.12`, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，Deployment将停用当前使用`nginx`版本`1.12.2`的Pod模板的`ReplicaSet`，然后激活使用`nginx`版本`1.12`的`ReplicaSet`，如下所示：
- en: '[PRE42]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: See also
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'In this section, you learned about the concept of Deployment. It is an important
    core feature in Kubernetes ReplicaSet life cycle management. It allows us to achieve
    rollout and rollback functionalities, and can integrate to CI/CD. In the following
    chapter you will see detailed operations of rollout and rollback:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了Deployment的概念。它是Kubernetes ReplicaSet生命周期管理中的一个重要核心功能。它允许我们实现部署和回滚功能，并能集成到CI/CD中。在接下来的章节中，您将看到部署和回滚的详细操作：
- en: '*Updating live containers* section in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)中，*更新实时容器*部分，*与容器互动*
- en: '*Setting up a continuous delivery pipeline *section in [Chapter 5](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml),
    *Building Continuous Delivery Pipelines*'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml)中，*设置持续交付流水线*部分，*构建持续交付流水线*
- en: Working with Services
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与服务合作
- en: 'The network service is an application that receives requests and provides a
    solution. Clients access the service by a network connection. They don''t have
    to know the architecture of the service or how it runs. The only thing that clients
    have to verify is whether the endpoint of the service can be accessed, and then
    follow its usage policy to get the response of the server. The Kubernetes Service
    has similar ideas. It is not necessary to understand every Pod before reaching
    their functionalities. For components outside the Kubernetes system, they just
    access the Kubernetes Service with an exposed network port to communicate with
    running Pods. It is not necessary to be aware of the containers'' IPs and ports.
    Behind Kubernetes Services, we can fulfill a zero-downtime update for our container
    programs without struggling:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务是一个接收请求并提供解决方案的应用程序。客户端通过网络连接访问服务。它们不需要了解服务的架构或其运行方式。客户端唯一需要验证的是服务的端点是否可访问，然后根据其使用策略获取服务器的响应。Kubernetes
    服务具有类似的理念。并不需要在使用服务功能之前了解每个 Pod。对于 Kubernetes 系统之外的组件，它们只需通过暴露的网络端口访问 Kubernetes
    服务，与运行中的 Pod 进行通信。无需了解容器的 IP 地址和端口。在 Kubernetes 服务的支持下，我们可以实现零停机时间更新容器程序，而无需费力：
- en: '![](img/feaa67cf-b59c-43b1-87f2-5e0647c966ed.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/feaa67cf-b59c-43b1-87f2-5e0647c966ed.png)'
- en: Kubernetes Service-covered Pods by labels of Pods and their selectors
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 服务通过 Pod 的标签及其选择器覆盖 Pod
- en: 'The preceding diagram shows the basic structure of the **Service** and realizes
    the following concepts:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 上图展示了**服务**的基本结构，并实现了以下概念：
- en: As with the **D****eployment**, the **Service** directs requests to Pods that
    have labels containing the Service's selector. In other words, the Pods selected
    by the **Service** are based on their labels.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 **Deployment** 一样，**服务**将请求引导到具有包含服务选择器的标签的 Pod。换句话说，**服务**选择的 Pod 是基于其标签的。
- en: The load of requests sent to the Services will distribute to three Pods.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到服务的请求负载将分配给三个 Pod。
- en: The **Deployment**, along with ReplicaSet, ensures that the number of running
    Pods meets its desired state. It monitors the Pods for the **Service**, making
    sure they will be healthy for taking over duties from the **Service**.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deployment** 和 ReplicaSet 确保运行中的 Pod 数量符合期望状态。它监控为**服务**提供服务的 Pod，确保它们在接管服务职责时健康可用。'
- en: '**Service** is an abstraction layer for grouping Pods, which allows for Pods
    scaling across nodes.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**是一个抽象层，用于对 Pod 进行分组，允许 Pod 在不同节点之间进行扩展。'
- en: In this recipe, you will learn how to create Services in front of your Pods
    for the requests.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您将学习如何为 Pod 前端创建服务以处理请求。
- en: Getting ready
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Prior to applying Kubernetes Services, it is important to verify whether all
    nodes in the system are running `kube-proxy`. The daemon `kube-proxy` works as
    a network proxy in a node. It helps to reflect Service settings, such as IPs or
    ports on each node, and to do network forwarding. To check if `kube-proxy` is
    running or not, we take a look at network connections:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用 Kubernetes 服务之前，重要的是验证系统中所有节点是否都在运行 `kube-proxy`。守护进程 `kube-proxy` 作为节点中的网络代理工作。它帮助反映服务设置，例如
    IP 或端口，并执行网络转发。要检查 `kube-proxy` 是否正在运行，可以查看网络连接：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once you see the output, the process ID `2326`, `kube-proxy`, listening on port
    `10249` on localhost, the node is ready for Kubernetes Services. Go ahead and
    verify whether all of your nodes in the Kubernetes cluster having `kube-proxy`
    running on them.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦看到输出，进程 ID 为 `2326` 的 `kube-proxy` 正在本地主机的端口 `10249` 上监听，那么节点就已经准备好支持 Kubernetes
    服务。继续验证 Kubernetes 集群中所有节点是否都在运行 `kube-proxy`。
- en: How to do it...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'As mentioned in the previous section, the Kubernetes Service exposes Pods by
    selecting them through corresponding labels. However, there is another configuration
    we have to take care of: the network port. As the following diagram indicates,
    the Service and Pod have their own key-value pair labels and ports:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Kubernetes 服务通过选择对应的标签来暴露 Pod。然而，还有一个配置需要我们关注：网络端口。如以下图所示，服务和 Pod 有各自的键值对标签和端口：
- en: '![](img/28ed7767-9dc7-4b82-9de3-3a6f99d969d0.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28ed7767-9dc7-4b82-9de3-3a6f99d969d0.png)'
- en: Network port mapping between Service and Pod
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 服务和 Pod 之间的网络端口映射
- en: Therefore, setting the selector of Service and binding the service exposed port
    to the container port are required to be carried out while creating Services.
    If either of them fail to be set properly, clients won't get responses or will
    get connection-refused errors.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在创建 Service 时，必须设置 Service 的选择器，并将 Service 的暴露端口绑定到容器端口。如果其中任何一项设置不当，客户端将无法获得响应，或者会收到连接拒绝的错误。
- en: We can define and create a new Kubernetes Service through the CLI or a configuration
    file. Here, we are going to explain how to deploy the Services by command. The
    subcommands `expose` and `describe` are utilized in the following commands for
    various scenarios. For file-format creation, it is recommended to read the *Working
    with configuration files* recipe in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*, for a detailed discussion.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 CLI 或配置文件定义并创建新的 Kubernetes Service。这里，我们将解释如何通过命令部署这些 Services。以下命令使用了子命令
    `expose` 和 `describe` 来处理不同的场景。对于文件格式的创建，建议阅读[第 3 章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)
    *操作配置文件*，该章节会详细讨论相关内容。
- en: Creating a Service for different resources
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为不同资源创建 Service
- en: 'You can attach a Service to a Pod, a Deployment, an endpoint outside the Kubernetes
    system, or even another Service. We will show you these, one by one, in this section.
    The creation of the Kubernetes Service looks similar to these command formats:
    `kubectl expose $RESOURCE_TYPE $RESOURCE_NAME [OTHER TAGS]` or `kubectl expose
    -f $CONFIG_FILE`. The resource types (Pod, Deployment, and Service) are supported
    by the subcommand `expose`. So is the configuration file, which follows the limitation type.
    Accordingly, for a later demonstration we will attach the newly created Service
    to the endpoint by the configuration file.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将一个 Service 附加到 Pod、Deployment、Kubernetes 系统外部的一个端点，甚至另一个 Service。在本节中，我们将依次展示这些操作。Kubernetes
    Service 的创建类似于以下命令格式：`kubectl expose $RESOURCE_TYPE $RESOURCE_NAME [OTHER TAGS]`
    或 `kubectl expose -f $CONFIG_FILE`。子命令 `expose` 支持资源类型（Pod、Deployment 和 Service）。配置文件也被支持，并且符合类型限制。因此，在后续的演示中，我们将通过配置文件将新创建的
    Service 附加到端点。
- en: Creating a Service for a Pod
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Pod 创建 Service
- en: 'Kubernetes Pods covered by Service require labels, so that Service can recognize
    who is the one it should take charge of. In the following commands, we create
    a Pod with labels first, and attach a Service on it:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Pods 需要标签才能被 Service 识别，以便 Service 知道应该管理哪个 Pod。在以下命令中，我们首先创建一个带标签的
    Pod，并将一个 Service 附加到该 Pod 上：
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You may find that, based on the preceding command, we did not assign any selector
    to this Service. Nonetheless, since Service `nginx-service` takes the port forwarding
    task of Pod `nginx-pod`, it will take the labels of the Pod as its selector. Go ahead
    and check the details of the Service with the subcommand `describe`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现，根据之前的命令，我们并没有为这个 Service 指定任何选择器。然而，由于 Service `nginx-service` 承担了 Pod
    `nginx-pod` 的端口转发任务，它会将 Pod 的标签作为自己的选择器。请继续使用子命令 `describe` 查看 Service 的详细信息：
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now you can see that, for guaranteeing the responsibility, this successfully
    exposed Service just copied the labels of the Pod as its selector. The value list
    after `Endpoints` was the IP of the Pod and its exposed port `80`. Furthermore,
    the Service took the Pod's labels as its own. According to this example, the Pod
    can be accessed through Service by surfing `10.96.107.213:8080`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到，为了保证职责明确，成功暴露的 Service 将 Pod 的标签复制为自己的选择器。`Endpoints` 后面的值列表是 Pod 的
    IP 地址和它暴露的端口 `80`。此外，Service 将 Pod 的标签作为自己的标签。根据这个例子，Pod 可以通过 Service 访问，URL 为
    `10.96.107.213:8080`。
- en: 'Except for the selector of Service, some parameters can be automatically configured
    if they are bypassed by users. One parameter is the labels of the Pod; another
    is the name of the Service; and the other is the exposed port of the Service.
    Let''s take a look at how this simple set of Pod and Service can be managed:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Service 的选择器外，如果用户跳过某些参数，它们可以自动配置。一个参数是 Pod 的标签；另一个是 Service 的名称；还有一个是 Service
    的暴露端口。我们来看一下如何管理这组简单的 Pod 和 Service：
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here, we can see that the Service inherited the name, label, and port from
    the Pod. The selector was assigned the dummy label with the key named `run` and
    the value named as Pod''s name, which is just the same dummy one of Pod `nginx-no-label`.
    Users should access the Service through port `80`, as well. For such simple settings,
    you can alternatively try the following command to create the Pods and Service
    at the same time:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 Service 从 Pod 继承了名称、标签和端口。选择器被分配了一个虚拟标签，键名为 `run`，值为 Pod 的名称，这里是
    Pod `nginx-no-label` 的虚拟名称。用户也应通过端口 `80` 访问该 Service。对于如此简单的设置，您还可以尝试以下命令，同时创建
    Pod 和 Service：
- en: '[PRE47]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Creating a Service for a Deployment with an external IP
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Deployment 创建带有外部 IP 的 Service
- en: 'Kubernetes Deployment is the ideal resource type for a Service. For Pods supervised
    by the ReplicaSet and Deployment, the Kubernetes system has a controller manager
    to look over the their life cycles. It is also helpful for updating the version
    or state of the program by binding the existing Services to another Deployment.
    For the following commands, we create a Deployment first, and attach a Service
    with an external IP:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Deployment 是 Service 的理想资源类型。对于由 ReplicaSet 和 Deployment 监控的 Pods，Kubernetes
    系统有一个控制器管理器来管理它们的生命周期。它也有助于通过将现有的 Services 绑定到另一个 Deployment 来更新程序的版本或状态。对于以下命令，我们首先创建一个
    Deployment，然后附加一个具有外部 IP 的 Service：
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s go ahead and check the details of the newly created Service, `another-nginx-service`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续查看新创建的 Service `another-nginx-service` 的详细信息：
- en: '[PRE49]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Apart from the Service IP (in the case of the preceding command, `10.100.109.230`),
    which can be accessed within the Kubernetes system, the Service can now be connected
    through an external one (`192.168.122.102`, for example) beyond the Kubernetes
    system. While the Kubernetes master is able to communicate with every node, in
    this case, we can fire a request to the Service such as the following command:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Service IP（在前面的命令中是 `10.100.109.230`），它可以在 Kubernetes 系统内访问之外，Service 现在还可以通过
    Kubernetes 系统外的外部 IP 连接（例如 `192.168.122.102`）。虽然 Kubernetes 主节点能够与每个节点通信，但在这种情况下，我们可以向
    Service 发起如下命令请求：
- en: '[PRE50]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Creating a Service for an Endpoint without a selector
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为没有选择器的 Endpoint 创建 Service
- en: 'First, we are going to create an Endpoint directing the external service. A
    Kubernetes Endpoint is an abstraction, making components beyond Kubernetes (for
    instance, a database in other system) become a part of Kubernetes resources. It
    provides a feasible use case for a hybrid environment. To create an endpoint,
    an IP address, along with a port, is required. Please take a look at the following
    template:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个指向外部服务的 Endpoint。Kubernetes Endpoint 是一种抽象，将 Kubernetes 以外的组件（例如，其他系统中的数据库）纳入
    Kubernetes 资源的一部分。它为混合环境提供了可行的使用案例。要创建一个 Endpoint，需要提供 IP 地址和端口。请查看以下模板：
- en: '[PRE51]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The template defines an Endpoint named `k8s-ep`, which points to the IP of
    the host of the official Kubernetes website ([https://kubernetes.io](https://kubernetes.io)).
    Never mind that this Endpoint forwards to a plain HTML; we just take this Endpoint
    as an example. As mentioned, Endpoint is not a resource supported by the Kubernetes
    API for exposing:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 模板定义了一个名为 `k8s-ep` 的 Endpoint，它指向官方 Kubernetes 网站主机的 IP（[https://kubernetes.io](https://kubernetes.io)）。无需在意这个
    Endpoint 转发到的是普通的 HTML 页面；我们只是把这个 Endpoint 作为示例。如前所述，Endpoint 不是 Kubernetes API
    支持的暴露资源：
- en: '[PRE52]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In Kubernetes, an Endpoint not only represents an external service; an internal
    Kubernetes Service is also a Kubernetes Endpoint. You can check Endpoint resources
    with the command `kubectl get endpoints`. You will find that there is not a single
    endpoint `k8s-ep` (which you just created), but many endpoints named the same
    as the Services in previous pages. When a Service is created with a selector and
    exposes certain resources (such as a Pod, Deployment, or other Service), a corresponding
    Endpoint with the same name is created at the same time.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，Endpoint 不仅代表外部服务；内部的 Kubernetes Service 也是一个 Kubernetes Endpoint。您可以通过命令
    `kubectl get endpoints` 检查 Endpoint 资源。您会发现，除了刚刚创建的名为 `k8s-ep` 的 Endpoint 外，还有许多与前面页面中
    Service 同名的 Endpoint。当 Service 使用选择器并暴露某些资源（如 Pod、Deployment 或其他 Service）时，会同时创建一个同名的
    Endpoint。
- en: 'Therefore, we still can create a Service associated with the Endpoint using
    an identical name, as in the following template:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们仍然可以使用相同名称创建与 Endpoint 关联的 Service，如以下模板所示：
- en: '[PRE53]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The relationship between the Endpoints and the Service is built up with the
    resource name. For the Service `k8s-ep`, we didn''t indicate the selector, since
    it did not actually take any Pod in responsibility:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 端点（Endpoints）与服务（Service）之间的关系是通过资源名称建立的。对于服务`k8s-ep`，我们没有指定选择器，因为它实际上并没有负责任何
    Pod：
- en: '[PRE54]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now you can see that the endpoint of the Service is just the one defined in
    `k8s-endpoint.yaml`. It is good for us to access the outside world through the
    Kubernetes Service! In the case earlier, we can verify the result with the following
    command:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到，服务的端点就是在`k8s-endpoint.yaml`中定义的那个。通过 Kubernetes 服务访问外部世界对我们来说是很方便的！在之前的例子中，我们可以通过以下命令验证结果：
- en: '[PRE55]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Creating a Service for another Service with session affinity
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为另一个具有会话亲和性的服务创建服务
- en: 'While building a Service over another, we may think of multiple layers for
    port forwarding. In spite of redirecting traffic from one port to another, the
    action of exposing a Service is actually copying the setting of one Service to
    another. This scenario could be utilized as updating the Service setting, without
    causing headaches to current clients and servers:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建一个服务时，我们可能会考虑多层端口转发。尽管是将流量从一个端口重定向到另一个端口，但暴露一个服务的操作实际上是在将一个服务的设置复制到另一个服务中。这个场景可以用作更新服务设置，而不会给当前客户端和服务器带来麻烦：
- en: '[PRE56]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here we are! We successfully exposed another Service with similar settings
    to the Service `another-nginx-service`. The commands and output can be summarized
    as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是！我们成功地暴露了另一个具有类似设置的服务，名为`another-nginx-service`。命令和输出可以总结如下：
- en: '**A new Service name is required**: Although we can copy the configurations
    from another Service, the name of the resource type should always be unique. When
    exposing a Service without the tag `--name`, you will get the error message: `Error
    from server (AlreadyExists): services "another-nginx-service" already exists`.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要新的服务名称**：虽然我们可以从另一个服务复制配置，但资源类型的名称应该始终是唯一的。当暴露一个没有 `--name` 标签的服务时，你会收到错误消息：`Error
    from server (AlreadyExists): services "another-nginx-service" already exists`。'
- en: '**Adding or updating the configuration is workable**: We are able to add a
    new configuration, like adding session affinity; or we can update the port of
    the Service, like here, where we change to open port `8081` instead of `8080`.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加或更新配置是可行的**：我们可以添加新的配置，比如添加会话亲和性；或者我们可以更新服务的端口，例如这里，我们将端口从`8080`更改为`8081`。'
- en: '**Avoid changing target port**: Because the target port is along with the IP
    of the Pods, once the Service exposing changes the target port, the newly copied
    Service cannot forward traffic to the same endpoints. In the preceding example,
    since the new target port is defined, we should point out the container port again.
    It prevented the new Service from using the target port as the container port
    and turned out a misleading transaction.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免更改目标端口**：因为目标端口是与 Pods 的 IP 一起使用的，一旦暴露的服务更改了目标端口，新复制的服务将无法将流量转发到相同的端点。在前面的示例中，由于定义了新的目标端口，我们应该再次指出容器端口。这避免了新服务使用目标端口作为容器端口，避免了产生误导性的交易。'
- en: 'With session affinity, the list of description tags session affinity as `ClientIP`.
    For the current Kubernetes version, the client IP is the only option for session
    affinity. It takes the action as a hash function: with the same IP address, the
    request will always send to the identical Pod. However, this could be a problem
    if there is a load balancer or ingress controller in front of the Kubernetes Service:
    the requests would be considered to come from the same source, and the traffic
    forwarded to a single Pod. Users have to handle this issue on their own, for example,
    by building an HA proxy server instead of using the Kubernetes Service.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用会话亲和性时，描述标签列表中的会话亲和性为`ClientIP`。对于当前的 Kubernetes 版本，客户端 IP 是唯一支持的会话亲和性选项。它的行为像哈希函数一样：使用相同的
    IP 地址，请求将始终发送到相同的 Pod。然而，如果 Kubernetes 服务前面有负载均衡器或入口控制器，这可能会成为问题：请求会被视为来自相同的源，流量会被转发到单一的
    Pod。用户必须自己处理这个问题，例如，通过建立一个 HA 代理服务器，而不是使用 Kubernetes 服务。
- en: Deleting a Service
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除服务
- en: 'If you go through every command in this section, there are definitely some
    demonstrated Kubernetes Services (we counted six of them) that should be removed.
    To delete a Service, the same as with any other Kubernetes resource, you can remove
    the Service with the name or the configuration file through the subcommand `delete`.
    When you try to remove the Service and the Endpoint at the same time, the following
    situation will happen:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您浏览本节中的每个命令，肯定会看到应该删除的一些演示的Kubernetes服务（我们统计了六个）。要删除服务，与任何其他Kubernetes资源一样，可以通过子命令`delete`删除带有名称或配置文件的服务。当您尝试同时删除服务和端点时，将发生以下情况：
- en: '[PRE57]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is because a Service is also a Kubernetes Endpoint. That's why, although
    we created the Service and the endpoint separately, once they are considered to
    work as a unit, the Endpoint is going to be removed when the Service is removed.
    Thus, the error message expresses that there is no endpoint called `k8s-ep`, since
    it was already removed with the Service deletion.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Service也是Kubernetes的Endpoint。这就是为什么，尽管我们分别创建了Service和端点，但一旦它们被视为作为一个单元工作，删除Service时会删除Endpoint。因此，错误消息表明没有名为`k8s-ep`的端点，因为它已随Service删除。
- en: How it works...
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: On the network protocol stack, the Kubernetes Service relies on the transport
    layer, working together with the **overlay network** and `kube-proxy`. The overlay
    network of Kubernetes builds up a cluster network by allocating a subnet lease
    out of a pre-configured address space and storing the network configuration in
    `etcd`; on the other hand, `kube-proxy` helps to forward traffic from the endpoints
    of Services to the Pods through `iptables` settings.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络协议栈上，Kubernetes服务依赖于传输层，与**覆盖网络**和`kube-proxy`一起工作。Kubernetes的覆盖网络通过分配子网租约从预配置的地址空间中建立集群网络，并将网络配置存储在`etcd`中；另一方面，`kube-proxy`通过`iptables`设置帮助将来自服务端点的流量转发到Pod。
- en: '**Proxy-mode and Service **`kube-proxy`  currently has three modes with different
    implementation methods: `userspace`, `iptables`, and `ipvs`. The modes affect
    how the requests of clients reach to certain Pods through the Kubernete Service:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**代理模式和Service** `kube-proxy` 目前有三种具有不同实现方法的模式：`userspace`、`iptables`和`ipvs`。这些模式影响客户端请求如何通过Kubernetes服务到达特定的Pod：'
- en: '`userspace`: `kube-proxy` opens a random port, called a proxy port, for each
    Service on the local node, then updates the `iptables` rules, which capture any
    request sent to the Service and forward it to the proxy port. In the end, any
    message sent to the proxy port will be passed to the Pods covered by the Service.
    It is less efficient, since the traffic is required to go to `kube-proxy` for
    routing to the Pod.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userspace`：`kube-proxy`为每个本地节点上的Service打开一个随机端口，称为代理端口，然后更新`iptables`规则，捕获发送到Service的任何请求并转发到代理端口。最终，发送到代理端口的任何消息都将传递给Service覆盖的Pod。由于流量需要经过`kube-proxy`路由到Pod，效率较低。'
- en: '`iptables`: As with the `userspace` mode, there are also required `iptables`
    rules for redirecting the client traffic. But there is no proxy port as mediator.
    Faster but need to take care the liveness of Pod. By default, there is no way
    for a request to retry another Pod if the target one fails. To avoid accessing
    the unhealthy Pod, health-checking Pods and updating `iptables` in time is necessary.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iptables`：与`userspace`模式一样，重定向客户端流量也需要`iptables`规则。但是没有代理端口作为中介。更快但需要注意Pod的存活性。默认情况下，如果目标Pod失败，请求无法重试到另一个Pod。为了避免访问不健康的Pod，必须对Pod进行健康检查并及时更新`iptables`。'
- en: '`ipvs`: `ipvs` is the beta feature in Kubernetes v1.9\. In this mode, `kube-proxy`
    builds up the interface called netlink between the Service and its backend set.
    The `ipvs` mode takes care of the downside in both `userspace` and `iptables`;
    it is even faster, since the routing rules stored a hash table structure in the
    kernel space, and even reliable that `kube-proxy` keeps checking the consistency
    of `netlinks`. `ipvs` even provides multiple load balancing options.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipvs`：`ipvs`是Kubernetes v1.9版本中的Beta功能。在这种模式下，`kube-proxy`在Service和其后端集之间建立名为netlink的接口。`ipvs`模式处理了`userspace`和`iptables`的缺点；它甚至更快，因为路由规则存储在内核空间的哈希表结构中，`kube-proxy`持续检查`netlinks`的一致性。`ipvs`甚至提供多种负载平衡选项。'
- en: The system picks the optimal and stable one as the default setting for `kube-proxy`.
    Currently, it is the mode `iptables`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 系统选择最佳和稳定的作为`kube-proxy`的默认设置。目前，默认设置是`iptables`模式。
- en: 'When a Pod tries to communicate with a Service, it can find the Service through
    environment variables or a DNS host lookup. Let''s give it a try in the following
    scenario of accessing a service in a Pod:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个Pod尝试与服务进行通信时，它可以通过环境变量或DNS主机查找来找到服务。让我们在下面的示例中尝试访问Pod中的服务：
- en: '[PRE58]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You will find that the Pod `my-2nd-centos` comes out with additional variables
    showing information for the Service `my-nginx-service`, as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现Pod `my-2nd-centos`显示了附加的变量，显示了服务`my-nginx-service`的相关信息，如下所示：
- en: '[PRE59]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This is because the system failed to do a real-time update for Services; only
    the Pods created subsequently can be applied to accessing the Service through
    environment variables. With this ordering-dependent constraint, pay attention
    to running your Kubernetes resources in a proper sequence if they have to interact
    with each other in this way. The keys of the environment variables representing
    the Service host are formed as `<SERVICE NAME>_SERVICE_HOST`, and the Service
    port is like `<SERVICE NAME>_SERVICE_PORT`. In the preceding example, the dash
    in the name is also transferred to the underscore:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为系统未能实时更新服务；只有之后创建的Pod才能通过环境变量访问服务。在这种依赖顺序的约束下，如果你的Kubernetes资源必须以这种方式相互交互，请注意按正确的顺序运行它们。表示服务主机的环境变量键将形成`<SERVICE
    NAME>_SERVICE_HOST`，而服务端口则类似`<SERVICE NAME>_SERVICE_PORT`。在前面的示例中，名称中的破折号也被转换为下划线：
- en: '[PRE60]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Nevertheless, if the `kube-dns` add-on is installed, which is a DNS server
    in the Kubernetes system, any Pod in the same Namespace can access the Service,
    no matter when the Service was created. The hostname of the Service would be formed
    as `<SERVICE NAME>.<NAMESPACE>.svc.cluster.local`. `cluster.local` is the default
    cluster domain defined in booting `kube-dns`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果已安装`kube-dns`插件，作为Kubernetes系统中的DNS服务器，任何在相同命名空间中的Pod都可以访问服务，无论该服务何时创建。服务的主机名将形成`<SERVICE
    NAME>.<NAMESPACE>.svc.cluster.local`的形式。`cluster.local`是启动`kube-dns`时定义的默认集群域：
- en: '[PRE61]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: There's more...
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'The Kubernetes Service has four types: `ClusterIP`, `NodePort`, `LoadBalancer`,
    and `ExternalName`. In the *How to do it...* section in this recipe, we only demonstrate
    the default type, `ClusterIP`. The type `ClusterIP` indicates that the Kubernetes
    Service is assigned a unique virtual IP in the overlay network, which also means
    the identity in this Kubernetes cluster. `ClusterIP` guarantees that the Service
    is accessible internally.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 服务有四种类型：`ClusterIP`、`NodePort`、`LoadBalancer`和`ExternalName`。在本食谱的*如何操作...*部分，我们仅展示默认类型`ClusterIP`。`ClusterIP`类型表示Kubernetes服务在覆盖网络中被分配了一个唯一的虚拟IP，这也意味着该服务在此Kubernetes集群中的身份。`ClusterIP`保证该服务在内部是可访问的。
- en: 'The following diagram expresses the availability coverage of the types, and
    their entry points:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表表达了各类型的可用性覆盖范围及其入口点：
- en: '![](img/516627fc-54d3-4283-ba0f-70d54d0d7978.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](img/516627fc-54d3-4283-ba0f-70d54d0d7978.png)'
- en: Four Service types and their entry points
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 四种服务类型及其入口点
- en: For the `NodePort` type, it covers the `ClusterIP`'s features, has a peer-accessible
    virtual IP, and also allows the user to expose Services on each node with the
    same port. The type `LoadBalancer` is on the top of the other two types. The `LoadBalancer`
    Service would be exposed internally and on the node. More than that, if your cloud
    provider supports external load balancing servers, you can bind the load balancer
    IP to the Service, and this will become another exposing point. On the other hand,
    the type `ExternalName` is used for the endpoint out of your Kubernetes system.
    It is similar to the Endpoint we created with the configuration file in a previous
    section; moreover, a single `ExternalName` Service can provide this feature.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`NodePort`类型，它包含了`ClusterIP`的所有特性，具有一个对等访问的虚拟IP，并且允许用户在每个节点上通过相同的端口暴露服务。`LoadBalancer`类型位于其他两种类型之上。`LoadBalancer`服务会在内部和节点上都暴露。更重要的是，如果你的云服务商支持外部负载均衡服务器，你可以将负载均衡器IP绑定到服务上，这将成为另一个暴露点。另一方面，`ExternalName`类型用于指向Kubernetes系统外部的端点。它类似于我们在前一部分使用配置文件创建的端点；此外，单个`ExternalName`服务可以提供此功能。
- en: 'We can use the subcommand `create` to create Services in different types:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用子命令`create`来创建不同类型的服务：
- en: '[PRE62]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In this example of the `NodePort` Service, you can see that it still has the
    virtual IP (`10.105.106.134`) in the cluster, and can be accessed through port
    `31336` of any Kubernetes node:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在此`NodePort`类型服务的示例中，你可以看到它仍然具有虚拟IP（`10.105.106.134`），并且可以通过任何Kubernetes节点的`31336`端口进行访问：
- en: '[PRE63]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the case here, we demonstrate creating an `ExternalName` Service which exposes
    the `CNAME kubernetes.io`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们演示了如何创建一个`ExternalName`服务，该服务暴露了`CNAME kubernetes.io`：
- en: '[PRE64]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Yet, we cannot build an `ExternalName` Service in CLI with the subcommand `expose`,
    because `expose` works on exposing the Kubernetes resources, while the `ExternalName` Service
    is for the resources in the outside world. Then, it is also reasonable that the
    `ExternalName` Service doesn't need to be defined with the selector.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们无法通过子命令`expose`在 CLI 中创建`ExternalName`服务，因为`expose`是用来暴露 Kubernetes 资源的，而`ExternalName`服务是用于外部世界的资源。因此，`ExternalName`服务无需定义选择器也是合理的。
- en: '**Using the subcommand "create" to create Services** While using the subcommand
    `create` on Service creation, the command line would look like this: `kubectl
    create service <SERVICE TYPE> <SERVICE NAME> [OPTIONS]`. And we can put the Service
    types at `<SERVICE TYPE>`, such as `clusterip`, `nodeport`, `loadbalancer`, and
    `externalname`. With this method, we cannot specify the selector of the Service.
    As with the `NodePort` Service we created in that section, only a default selector, `app:
    my-nginx`, is created, and we have to assign this label to a later created Deployment
    `test-nodeport`. Except for the type `ExternalName`, Service types can be created
    with the subcommand `expose` with the tag `type`. Try to create the `NodePort` service
    with `kubectl expose` for existing resources!'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用子命令“create”创建服务** 在使用子命令`create`创建服务时，命令行将是这样的：`kubectl create service
    <SERVICE TYPE> <SERVICE NAME> [OPTIONS]`。我们可以在`<SERVICE TYPE>`中指定服务类型，例如`clusterip`、`nodeport`、`loadbalancer`和`externalname`。使用这种方法时，我们不能指定服务的选择器。正如我们在这一部分中创建的`NodePort`服务一样，它只会创建一个默认选择器`app:
    my-nginx`，我们必须将此标签分配给后续创建的部署`test-nodeport`。除了`ExternalName`类型，其他服务类型可以使用子命令`expose`并通过`type`标签创建。尝试使用`kubectl
    expose`为现有资源创建`NodePort`服务！'
- en: See also
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'To get the best practices of Kubernetes Services, the following recipes in
    [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking though Kubernetes
    Concepts*, are suggested reading:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得 Kubernetes 服务的最佳实践，建议阅读[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中的以下食谱，*深入了解
    Kubernetes 概念*：
- en: '*Deployment API*'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署 API*'
- en: '*Working with Secrets*'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Secrets*'
- en: '*Working with labels and selectors*'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用标签和选择器*'
- en: 'There is more advanced knowledge to make your service more functional and flexible.
    Stay tuned:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多高级知识可以使你的服务更具功能性和灵活性，敬请关注：
- en: '*Forwarding container ports* section in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)中 *转发容器端口* 部分，*玩转容器*'
- en: '*Ensuring flexible usage of your containers* section in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)中 *确保容器灵活使用* 部分，*玩转容器*'
- en: Working with volumes
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用卷
- en: 'Files in a container are ephemeral. When the container is terminated, the files
    are gone. Docker has introduced data volumes to help us persist data ([https://docs.docker.com/engine/admin/volumes/volumes](https://docs.docker.com/engine/admin/volumes/volumes)).
    However, when it comes to multiple hosts, as a container cluster, it is hard to
    manage volumes across all the containers and hosts for file sharing or provisioning
    volume dynamically. Kubernetes introduces volume, which lives with a Pod across
    a container life cycle. It supports various types of volumes, including popular
    network disk solutions and storage services in different public clouds. Here are
    a few:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 容器中的文件是短暂的。当容器被终止时，文件也会消失。Docker 引入了数据卷来帮助我们持久化数据（[https://docs.docker.com/engine/admin/volumes/volumes](https://docs.docker.com/engine/admin/volumes/volumes)）。然而，当涉及到多个主机时，作为容器集群，要管理所有容器和主机之间的卷以实现文件共享或动态提供卷就变得很困难。Kubernetes
    引入了卷，它随着 Pod 的生命周期而存在。它支持多种类型的卷，包括流行的网络磁盘解决方案和不同公共云中的存储服务。以下是一些：
- en: '| **Volume type** | **Storage provider** |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| **卷类型** | **存储提供商** |'
- en: '| `emptyDir` | Localhost |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `emptyDir` | 本地主机 |'
- en: '| `hostPath` | Localhost |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `hostPath` | 本地主机 |'
- en: '| `glusterfs` | GlusterFS cluster |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `glusterfs` | GlusterFS 集群 |'
- en: '| `downwardAPI` | Kubernetes Pod information |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `downwardAPI` | Kubernetes Pod 信息 |'
- en: '| `nfs` | NFS server |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `nfs` | NFS 服务器 |'
- en: '| `awsElasticBlockStore` | Amazon Web Service Amazon Elastic Block Store |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `awsElasticBlockStore` | 亚马逊 Web 服务 Amazon Elastic Block Store |'
- en: '| `gcePersistentDisk` | Google Compute Engine persistent disk |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `gcePersistentDisk` | Google Compute Engine 持久磁盘 |'
- en: '| `azureDisk` | Azure disk storage |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `azureDisk` | Azure 磁盘存储 |'
- en: '| `projected` | Kubernetes resources; currently supports `secret`, `downwardAPI`,
    and `configMap` |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `projected` | Kubernetes资源；当前支持`secret`、`downwardAPI`和`configMap` |'
- en: '| `secret` | Kubernetes Secret resource |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `secret` | Kubernetes Secret资源 |'
- en: '| `vSphereVolume` | vSphere VMDK volume |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `vSphereVolume` | vSphere VMDK卷 |'
- en: '| `gitRepo` | Git repository |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `gitRepo` | Git仓库 |'
- en: Getting ready
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Storage providers are required when you start to use volume in Kubernetes, except
    for `emptyDir`, which will be erased when the Pod is removed. For other storage
    providers, folders, servers, or clusters have to be built before using them in
    the Pod definition. Dynamic provisioning was promoted to stable in Kubernetes
    version 1.6, which allows you to provision storage based on the supported cloud
    provider.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Kubernetes中的卷时，需要存储提供程序，除了`emptyDir`，当Pod被删除时，它将被清除。对于其他存储提供程序，在Pod定义之前必须建立文件夹、服务器或集群。动态配置在Kubernetes版本1.6中提升为稳定版，允许根据支持的云提供商来配置存储。
- en: In this section, we'll walk through the details of `emptyDir`, `hostPath`, `nfs`,
    `glusterfs`, `downwardAPI`, and `gitRepo`. `Secret`, which is used to store credentials,
    will be introduced in the next section. `Projected`, on the other hand, is a way
    one could group other volume resources under one single mount point. As it only
    supports `secret`, `downwardAPI`, and `configMap`, we'll be introducing this in
    the Secret section, as well. The rest of the volume types have similar Kubernetes
    syntax, just with different backend volume implementations.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将详细介绍`emptyDir`、`hostPath`、`nfs`、`glusterfs`、`downwardAPI`和`gitRepo`的细节。下一节将介绍用于存储凭据的`Secret`。另一方面，`Projected`是一种将其他卷资源分组到单个挂载点下的方法。由于它仅支持`secret`、`downwardAPI`和`configMap`，我们将在`Secret`部分介绍它。其余的卷类型具有类似的Kubernetes语法，只是具有不同的后端卷实现。
- en: How to do it...
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Volumes are defined in the volumes section of the pod definition with unique
    names. Each type of volume has a different configuration to be set. Once you define
    the volumes, you can mount them in the `volumeMounts` section in the container
    specs. `volumeMounts.name` and `volumeMounts.mountPath` are required, which indicate
    the name of the volumes you defined and the mount path inside the container, respectively.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 卷在Pod定义的卷部分中使用唯一名称进行定义。每种类型的卷都有不同的配置需要设置。一旦定义了卷，可以在容器规范的`volumeMounts`部分中挂载它们。需要`volumeMounts.name`和`volumeMounts.mountPath`，分别表示您定义的卷的名称和容器内部的挂载路径。
- en: We'll use the Kubernetes configuration file with the YAML format to create a
    Pod with volumes in the following examples.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用YAML格式的Kubernetes配置文件来创建带有卷的Pod，如下例所示。
- en: emptyDir
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: emptyDir
- en: '`emptyDir` is the simplest volume type, which will create an empty volume for
    containers in the same Pod to share. When the Pod is removed, the files in `emptyDir`
    will be erased, as well. `emptyDir` is created when a Pod is created. In the following
    configuration file, we''ll create a Pod running Ubuntu with commands to sleep
    for `3600` seconds. As you can see, one volume is defined in the volumes section
    with name data, and the volumes will be mounted under the `/data-mount` path in
    the Ubuntu container:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`emptyDir`是最简单的卷类型，它将为同一Pod中的容器创建一个空卷。当删除Pod时，`emptyDir`中的文件也将被删除。`emptyDir`在创建Pod时创建。在以下配置文件中，我们将创建一个运行Ubuntu的Pod，并使用命令休眠`3600`秒。如您所见，在卷部分定义了一个名为data的卷，并且卷将在Ubuntu容器中的`/data-mount`路径下挂载：'
- en: '[PRE65]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '**Check which node the Pod is running on** By using the `kubectl describe pod
    <Pod name> | grep Node` command, you can check which node the Pod is running on.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查Pod运行在哪个节点上** 使用`kubectl describe pod <Pod name> | grep Node`命令，您可以检查Pod运行在哪个节点上。'
- en: 'After the Pod is running, you can use `docker inspect <container ID>` on the
    target node and you can see the detailed mount points inside your container:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Pod运行后，您可以在目标节点上使用`docker inspect <container ID>`，您可以看到容器内部的详细挂载点：
- en: '[PRE66]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Kubernetes mounts `/var/lib/kubelet/pods/<id>/volumes/kubernetes.io~empty-dir/<volumeMount
    name>` to `/data-mount` for the Pod to use. If you create a Pod with more than
    one container, all of them will mount the same destination `/data-mount` with
    the same source. The default mount propagation is `rprivate`, which means any
    mount points on the host are invisible in the container, and vice versa.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes将`/var/lib/kubelet/pods/<id>/volumes/kubernetes.io~empty-dir/<volumeMount
    name>`挂载到Pod使用的`/data-mount`。如果创建一个具有多个容器的Pod，它们都将以相同的源挂载到相同的目标`/data-mount`。默认的挂载传播方式是`rprivate`，这意味着主机上的任何挂载点在容器中是不可见的，反之亦然。
- en: '`emptyDir` could be mounted as `tmpfs` by setting `emptyDir.medium` as `Memory`.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`emptyDir` 可以通过将 `emptyDir.medium` 设置为 `Memory` 来挂载为 `tmpfs`。'
- en: 'Taking the previous configuration file `2-6-1_emptyDir_mem.yaml` as an example,
    it would be as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 以之前的配置文件 `2-6-1_emptyDir_mem.yaml` 为例，内容如下：
- en: '[PRE67]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We could verify whether it''s successfully mounted with the `kubectl exec <pod_name>
    <commands>` command. We''ll run the `df` command in this container:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `kubectl exec <pod_name> <commands>` 命令来验证是否成功挂载。在容器中运行 `df` 命令：
- en: '[PRE68]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that `tmpfs` is stored in memory instead of in the filesystem. No file
    will be created, and it'll be flushed in every reboot. In addition, it is constrained
    by memory limits in Kubernetes. For more information about container resource
    constraint, refer to *Working with Namespace* in this chapter.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`tmpfs` 存储在内存中，而不是文件系统中。不会创建文件，并且在每次重启时会被清空。此外，它受 Kubernetes 中内存限制的约束。有关容器资源限制的更多信息，请参见本章中的
    *Working with Namespace*。
- en: If you have more than one container inside a Pod, the `Kubectl exec` command
    will be `kubectl exec <pod_name> <container_name> <commands>`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Pod 内有多个容器，则 `Kubectl exec` 命令为 `kubectl exec <pod_name> <container_name>
    <commands>`。
- en: hostPath
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: hostPath
- en: '`hostPath` acts as data volume in Docker. The local folder on a node listed
    in `hostPath` will be mounted into the Pod. Since the Pod can run on any nodes,
    read/write functions happening in the volume could explicitly exist in the node
    on which the Pod is running. In Kubernetes, however, the Pod should not be node-aware.
    Please note that the configuration and files might be different on different nodes
    when using `hostPath`. Therefore, the same Pod, created by the same command or
    configuration file, might act differently on different nodes.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`hostPath` 在 Docker 中充当数据卷。列在 `hostPath` 中的节点本地文件夹将被挂载到 Pod 中。由于 Pod 可以在任何节点上运行，因此在卷中发生的读写操作显式存在于
    Pod 所运行的节点上。然而，在 Kubernetes 中，Pod 不应意识到节点的存在。请注意，使用 `hostPath` 时，配置和文件在不同节点上可能会有所不同。因此，通过相同的命令或配置文件创建的相同
    Pod 在不同节点上可能会表现得不同。'
- en: 'By using `hostPath`, you''re able to read and write the files between containers
    and localhost disks of nodes. What we need for volume definition is for `hostPath.path`
    to specify the target mounted folder on the node:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `hostPath`，您可以在容器和节点本地磁盘之间读取和写入文件。我们在定义卷时需要通过 `hostPath.path` 来指定节点上目标挂载文件夹：
- en: '[PRE69]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Using `docker inspect` to check the volume details, you will see the volume
    on the host is mounted in the `/data-mount` destination:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker inspect` 查看卷的详细信息，您将看到主机上的卷被挂载到 `/data-mount` 目录：
- en: '[PRE70]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If we run `kubectl exec ubuntu touch /data-mount/sample`, we should be able
    to see one empty file, named `sample under /tmp/data`, on the host.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行 `kubectl exec ubuntu touch /data-mount/sample`，我们应该能在主机的 `/tmp/data`
    目录下看到一个名为 `sample` 的空文件。
- en: NFS
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NFS
- en: You can mount an **network filesystem** (**NFS**) to your Pod as `nfs volume`.
    Multiple Pods can mount and share the files in the same `nfs volume`. The data
    stored into `nfs volume` will be persistent across the Pod lifetime. You have
    to create your own NFS server before using `nfs volume`, and make sure the `nfs-utils`
    package is installed on Kubernetes minions.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 **网络文件系统** (**NFS**) 挂载到 Pod 上，作为 `nfs volume`。多个 Pod 可以挂载并共享同一个 `nfs volume`
    中的文件。存储到 `nfs volume` 中的数据将在 Pod 生命周期中持久存在。在使用 `nfs volume` 之前，您需要创建自己的 NFS 服务器，并确保
    Kubernetes 节点上安装了 `nfs-utils` 包。
- en: Check whether your NFS server works before you go. You should check out the `/etc/exports`
    file with a proper sharing parameter and directory, and use the `mount -t nfs
    <nfs server>:<share name> <local mounted point>` command to check whether it could
    be mounted locally.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开之前，请检查您的 NFS 服务器是否正常工作。您应该检查 `/etc/exports` 文件，并确保正确的共享参数和目录设置，使用 `mount
    -t nfs <nfs server>:<share name> <local mounted point>` 命令检查是否可以在本地挂载。
- en: 'The configuration file of the volume type with NFS is similar to others, but
    `nfs.server` and `nfs.path` are required in the volume definition to specify NFS
    server information and the path mounted from. `nfs.readOnly` is an optional field
    for specifying whether the volume is read-only or not (the default is `false`):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 NFS 的卷类型配置文件与其他配置类似，但在卷定义中需要指定 `nfs.server` 和 `nfs.path`，以指定 NFS 服务器信息和挂载路径。`nfs.readOnly`
    是一个可选字段，用于指定卷是否为只读（默认为 `false`）：
- en: '[PRE71]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'After you run `kubectl create –f 2-6-3_nfs.yaml`, you can describe your Pod
    with `kubectl describe <pod name>` to check the mounting status. If it''s mounted
    successfully, it should show conditions. Ready as true and the target `nfs` you
    mount:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If we inspect the container with the `docker` command, we can see the volume
    information in the `Mounts` section:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Actually, Kubernetes just mounts your `<nfs server>:<share name>` into `/var/lib/kubelet/pods/<id>/volumes/kubernetes.io~nfs/nfs`,
    and then mounts it into the container as the destination in `/data-mount`. You
    could also use `kubectl exec` to touch the file, to test whether it's perfectly
    mounted.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: glusterfs
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GlusterFS ([https://www.gluster.org](https://www.gluster.org)) is a scalable,
    network-attached storage filesystem. The `glusterfs` volume type allows you to
    mount GlusterFS volume into your Pod. Just like NFS volume, the data in `glusterfs`
    volume is persistent across the Pod lifetime. If the Pod is terminated, the data
    is still accessible in `glusterfs` volume. You should build the GlusterFS system
    before using `glusterfs` volume.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Check whether `glusterfs` works before you go. By using `glusterfs` volume information
    on GlusterFS servers, you can see currently available volumes. By using `mount
    -t glusterfs <glusterfs server>:/<volume name> <local mounted point>` on local,
    you can check whether the GlusterFS system can be successfully mounted.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Since the volume replica in GlusterFS must be greater than `1`, let's assume
    we have two replicas in the servers `gfs1` and `gfs2`, and the volume name is
    `gvol`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create an endpoint acting as a bridge for `gfs1` and `gfs2`:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, we can use `kubectl get endpoints` to check the endpoint was created
    properly:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'After that, we should be able to create the Pod with `glusterfs` volume by
    `glusterfs.yaml`. The parameters of the `glusterfs` volume definition are `glusterfs.endpoints`,
    which specify the endpoint name we just created, and `glusterfs.path`, which is
    the volume name `gvol`. `glusterfs.readOnly` is used to set whether the volume
    is mounted in read-only mode:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let''s check the volume setting with `kubectl describle`:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Using `docker inspect`, you should be able to see that the mounted source is
    `/var/lib/kubelet/pods/<id>/volumes/kubernetes.io~glusterfs/data` to the destination
    `/data-mount`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: downwardAPI
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`downwardAPI` volume is used to expose Pod information into a container. The
    definition of `downwardAPI` is a list of items. An item contains a path and `fieldRef`.
    Kubernetes will dump the specified metadata listed in `fieldRef` to a file named
    `path` under `mountPath` and mount the `<volume name>` into the destination you
    specified. Currently supported metadata for `downwardAPI` volume includes:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field path** | **Scope** | **Definition** |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
- en: '| `spec.nodeName` | Pod | The node that the Pod is running on |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
- en: '| `spec.serviceAccountName` | Pod | The service account associating with the
    current Pod |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
- en: '| `metadata.name` | Pod | The name of the Pod |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
- en: '| `metadata.namespace` | Pod | The Namespace that the Pod belongs to |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
- en: '| `metadata.annotations` | Pod | The annotations of the Pod |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
- en: '| `metadata.labels` | Pod | The labels of the Pod |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
- en: '| `status.podIP` | Pod | The ip of the Pod |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
- en: '| `limits.cpu` | Container | The CPU limits of the container |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
- en: '| `requests.cpu` | Container | The CPU requests of the container |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
- en: '| `limits.memory` | Container | The memory limits of the container |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
- en: '| `requests.memory` | Container | The memory requests of the container |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
- en: '| `limits.ephemeral-storage` | Container | The ephemeral storage limits of
    the container |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
- en: '| `requests.ephemeral-storage` | Container | The ephemeral storage requests
    of the container |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
- en: 'We use `fieldRef.fieldPath` if the scope is with a Pod; `resourceFieldRef`
    is used when the scope is with a container. For example, the following configuration
    file could expose `metadata.labels` in `/data-mount` volume in an Ubuntu container:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'By describing the `pod`, we could check that the volume is mounted successfully
    to `/data-mount`, and `metadata.labels` is pointed to the `metadata` file:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We could check the file inside the container with `kubectl exec downwardapi
    cat /data-mount/metadata`, and you should be able to see `env="example" presents`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'If it''s in the container scope, we''ll have to specify the container name:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We could use the `docker inspect <container_name>` command inside a node to
    check the implementation:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Kubernetes exposes `pod` information in source volume, and mounts it to `/data-mount`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'For the IP of the Pod, using environment variable to propagate in Pod spec
    would be must easier:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The sample folder in the Kubernetes GitHub ([https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information](https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information))
    contains more examples for both environment variables and `downwardAPI` volume.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: gitRepo
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`gitRepo` is a convenient volume type that clones your existing Git repository
    into a container:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In the preceding example, the volume plugin mounts an empty directory and runs
    the git clone `<gitRepo.repolist>` to clone the repository into it. Then the Ubuntu
    container will be able to access it.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous cases, the user needs to know the details of the storage provider.
    Kubernetes provides `PersistentVolumes` and `PersistentVolumeClaim` to abstract
    the details of the storage provider and storage consumer.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: PersistentVolumes
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An illustration of `PersistentVolume` is shown in the following graph. First,
    the administrator provisions the specification of a `PersistentVolume`. Then the
    consumer requests for storage with `PersistentVolumeClaim`. Finally, the Pod mounts
    the volume with the reference of `PersistentVolumeClaim`:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f65303f4-59e5-4814-a38b-d6a38bd7977b.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
- en: PersistentVolumeClaims is an abstract layer to decouple volumes for a Pod and
    physical volume resource
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example using `NFS`. The administrator needs to provision and allocate
    `PersistentVolume` first:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We can see that there are three parameters here: `capacity`, `accessModes`,
    and `persistentVolumeReclaimPolicy`. `capacity` is the size of this `PersistentVolume`.
    Now, `accessModes` is based on the capability of the storage provider and can
    be set to a specific mode during provision. For example, NFS supports multiple
    readers and writers simultaneously—then we can specify the `accessModes` as one
    of `ReadWriteOnce`, `ReadOnlyMany`, or `ReadWriteMany`. Now, `persistentVolumeReclaimPolicy`
    is used to define the behavior when `PersistentVolume` is released. The currently
    supported policy is retain and recycle for `nfs` and `hostPath`. You have to clean
    the volume by yourself in retain mode; on the other hand, Kubernetes will scrub
    the volume in recycle mode.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'PV is a resource like a node. We could use `kubectl get pv` to see current
    provisioned PVs:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Next, we will need to bind `PersistentVolume` with `PersistentVolumeClaim`
    in order to mount it as volume into the `pod`:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The constraints of `accessModes` and storage can be set in `PersistentVolumeClaim`.
    If the claim is bound successfully, its status will turn to `Bound`; on the other
    hand, if the status is `Unbound`, it means there is no PV currently matching the
    requests.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we are able to mount the PV as volume with the reference of `PersistentVolumeClaim`:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'It will be similar syntax to other volume types. Just add the `claimName` of
    `persistentVolumeClaim` in the volume definition. We are all set! Let''s check
    the details to see whether we mounted it successfully:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We can see we have a volume mounted in the Pod `nginx` with the type `pv pvclaim01`.
    Use `docker inspect` to see how it is mounted:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Kubernetes mounts `/var/lib/kubelet/pods/<id>/volumes/kubernetes.io~nfs/< persistentvolume
    name>` into the destination in the Pod.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Using storage classes
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the cloud world, people provision storage or data volume dynamically. While
    `PersistentVolumeClaim` is based on existing static `PersistentVolume` that is
    provisioned by administrators, it might be really beneficial if the cloud volume
    could be requested dynamically when it needs to be. Storage classes are designed
    to resolve this problem. To make storage classes available in your cluster, three
    conditions need to be met. First, the `DefaultStorageClass` admission controller
    has to be enabled (refer to [Chapter 7](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Building Kubernetes on GCP*). Then `PersistentVolumeClaim` needs to request a
    storage class. The last condition is trivial; administrators have to configure
    a storage class in order to make dynamic provisioning work:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23a069b1-0d06-4c86-8762-e3fe472a7a87.png)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
- en: StorageClass dynamically allocates a PV and associates it with a PVC
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: The default storage classes are various, basically based on your underlying
    cloud provider. Storage classes are the abstract way to define underlying storage
    providers. They have different syntax based on different types of providers. Default
    storage classes can be changed, but cannot be deleted. The default storage class
    has an annotation `storageclass.beta.kubernetes.io/is-default-class=true` on.
    Removing that annotation can disable the dynamic provisioning. Moving the annotation
    to another storage class can switch the default storage class. If no storage classes
    have that annotation, dynamic provisioning will not be triggered when there is
    a new `PersistentVolumeClaim`.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: gcePersistentDisk
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`gcePersistentDisk` volume mounts a **Google Compute Engine** (**GCE**) **Persistent
    Disk** (**PD**) into a Pod. If you provision it statically, you''ll have to create
    it first with the `gcloud` command or in the GCE console. The following is an
    example:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Alternatively, and more cost-effectively, we could use dynamic provisioning.
    Then we don''t need to provision PD beforehand. For enabling dynamic provisioning,
    the `DefaultStorageClass` admission controller has to be enabled on the API server.
    In some Kubernetes environments, it has been enabled by default, such as in GCE.
    We could explicitly disable it by setting the `storageClassName: "" in Pod/Deployment/ReplicaSet`
    configuration file.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll introduce how to create a non-default `StorageClass`:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We can see we have a default storage class named `standard`. If that''s the
    desired provider, then you don''t need to create your own storage classes. In
    the following example, we''ll create a new storage class named `example`:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'For the type, you can specify any storage type that GCE supports, such as `pd-ssd`.
    You can specify zones by changing zone parameters, too. Next, we''ll add a `PersistentVolumeClaim`
    for using this storage class:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This configuration file will create a PVC by specifying the storage class named
    `example`. A PV will be created by the claim. When a PVC is in `Bound` status,
    Kubernetes will always bind that PV to the matching PVC. Then, let''s have a Pod
    using this PVC:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We can see that `gce-pd` is mounted under `/mount-path`. Let's see if the volume
    has been provisioned dynamically.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you could use `gcloud compute disks list. gcloud` in a command-line
    tool in GCE.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: awsElasticBlockStore
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`awsElasticBlockStore` volume mounts an **Amazon Web Service Elastic Block
    Store** (**AWS EBS**) volume. It''s a service that provides persistent block storage
    for Amazon EC2\. Just like the GCE persistent disk, we can provision it statically
    or dynamically.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'To provision it statically, administrators have to create an EBS volume by
    the AWS console or AWS CLI beforehand. The following is an example of how to mount
    an existing EBS volume to the containers in a Deployment:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'To provision it dynamically, on the other hand, just like how we demonstrated
    in the GCE persistent disk, we first create a non-default storage class; you''re
    free to use a default storage class as well. Here, our environment is provisioned
    by kops ([https://github.com/kubernetes/kops](https://github.com/kubernetes/kops);
    for more information, please refer to [Chapter 6](b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml),
    *Building Kubernetes on AWS*). The environment has been bound with the required
    IAM policies, such as `ec2:AttachVolume`, `ec2:CreateVolume`, `ec2:DetachVolume`,
    and `ec2:DeleteVolume`. If you provision it from scratch, be sure that you have
    required policies attaching to the masters:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Next, we create a PVC with the storage class name we just created:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'When Kubernetes receives the request of `PersistentVolumeClaim`, it''ll try
    to allocate a new `PersistentVolume`, or bind to an existing PV, if possible:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We can check the corresponding PV in the AWS console, as well.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, we create a Deployment with this volume by specifying `persistentVolumeClaim`
    in the spec:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'By specifying `claimName` as `aws-example`, it''ll then use the EBS volume
    we just create by PVC, which is requested to AWS dynamically. If we take a look
    at the Pod description with `kubectl describe pod <pod_name>`, we can see the
    details of the volumes:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: EBS volume `vol-0fccc3b0af8c17727` is mounted under `/mount-path` inside the
    container.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: If the volume was dynamically provisioned, the default reclaim policy is set
    to `delete`. Set it to `retain` if you want to keep them, even if a PVC is deleted.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '**The StorageObjectInUseProtection admission controller**'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: A PVC might be deleted accidentally by user even if it's used by a Pod. In Kubernetes
    v1.10, a new admission controller is added to prevent this from happening.` kubernetes.io/pv-protection`
    or `kubernetes.io/pvc-protection` finalizer will be added into PV or PVC by `StorageObjectInUseProtection`
    admission controller. Then when object deletion request is sent, admission controller
    will do pre-delete check and see if there is any Pod are using it. This will prevent
    data loss.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Volumes can be mounted on the Pods by declaring in Pods or ReplicaSet spec.
    Check out the following recipes to jog your memory:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '*Working with Pods* section in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking
    through Kubernetes Concepts*'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with replica sets* section in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking
    through Kubernetes Concepts*'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with Secrets* section in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking
    through Kubernetes Concepts*'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting resource in nodes* section in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml), *Advanced
    Cluster Administration*'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Authentication and authorization* section in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml), *Advanced
    Cluster Administration*'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Secrets
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes Secrets manage information in key-value formats with the value encoded.
    It can be a password, access key, or token. With Secrets, users don't have to
    expose sensitive data in the configuration file. Secrets can reduce the risk of
    credential leaks and make our resource configurations more organized.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, there are three types of Secrets:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: 'Generic/Opaque: [https://en.wikipedia.org/wiki/Opaque_data_type](https://en.wikipedia.org/wiki/Opaque_data_type)'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker registry
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TLS
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic/Opaque is the default type that we're using in our application. Docker
    registry is used to store the credential of a private Docker registry. TLS Secret
    is used to store the CA certificate bundle for cluster administration.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes creates built-in Secrets for the credentials that using to access
    API server.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before using Secrets, we have to keep in mind that Secret should be always created
    before dependent Pods, so dependent Pods can reference it properly. In addition,
    Secrets have a 1 MB size limitation. It works properly for defining a bunch of
    information in a single Secret. However, Secret is not designed for storing large
    amounts of data. For configuration data, consider using `ConfigMaps`. For large
    amounts of non-sensitive data, consider using volumes instead.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following example, we'll walk through how to create a Generic/Opaque
    Secret and use it in your Pods by assuming that we have an access token that needs
    to be used inside a Pod.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Secret
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two ways to create a Secret. The first one is with `kubectl create
    secret` in the command line, and the other one is with direct resource creation
    in the configuration file.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Working with kubectl create command line
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By using `kubectl create secret` command line, you can create a Secret from
    a file, directory, or literal value. With this method, you don''t need to encode
    the Secret by yourself. Kubernetes will do that for you:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: From a file
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a file is the source of Secret, we''ll have to create a text file which
    contains our sensitive data first:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Next, we could use `kubectl create secret` in the command line to create the
    Secret. The syntax is:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In our case, we use generic Secret type, since the access token is neither
    the Docker registry image pull Secrets nor TLS information:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'You can check the detailed Secret information with the `kubectl get secret`
    command:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'You can use the `base64` command ([https://linux.die.net/man/1/base64](https://linux.die.net/man/1/base64))
    in Linux to decode the encoded Secret:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: From a directory
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a Secret from a directory is similar to creating from a file, using
    the same command, but with `directory`. Kubernetes will iterate all the files
    inside that directory and create a Secret for you:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: You can check the Secret with the `kubectl get secret access-token -o yaml`
    command again and see if they're identical to the ones from the file.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: From a literal value
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes supports creating a Secret with a single command line, as well:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Then we can use the `get secret` command to check if they''re identical to
    the previous method:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Via configuration file
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Secret can also be created directly through the configuration file; however,
    you''ll have to encode the Secret manually. Just use the kind of Secret:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Using Secrets in Pods
  id: totrans-550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use Secrets inside Pods, we can choose to expose them in environment variables
    or mount the Secrets as volumes.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: By environment variables
  id: totrans-552
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In terms of accessing Secrets inside a Pod, add `env section` inside the container
    spec as follows:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'In the preceding example, we expose `2-7-1_access-token` key in access-token
    Secret as `ACCESS_TOKEN` environment variable, and print it out through a while
    infinite loop. Check the `stdout via kubectl` log command:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Note that the environment variable was exposed during Pod creation. If a new
    value of Secret is pushed, you'll have to re-launch/rolling-update a Pod or Deployment
    to reflect that.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: 'If we describe the `secret-example-env` Pod, we can see that an environment
    variable was set to a Secret:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: By volumes
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Secret can be also mounted as volume by using the Secret type of the volume.
    The following is an example of how to use it:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The preceding example will mount `secret-volume` into the `/secret mount` point
    inside the Pod. `/secret` will contain a file with the name token, which contains
    our access token. If we check the Pod details, it''ll show that we mounted a read-only
    Secret volume:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'If we check the `stdout`, it''ll show the Pod can properly retrieve the expected
    value:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The same as with the environment variable, the files in the mounted volume are
    created upon Pod creation time. It won't change dynamically when the Secret value
    is updated after the Pod creation time.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a Secret
  id: totrans-568
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To delete a Secret, simply use the `kubectl delete secret` command:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'If a Secret is deleted when a Secret volume is attached, it''ll show an error
    message whenever the volume reference disappears:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: How it works...
  id: totrans-573
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to reduce the risk of leaking the Secrets' content, Secret is not landed
    to the disk. Instead, kubelet creates a `tmpfs` filesystem on the node to store
    the Secret. The Kubernetes API server pushes the Secret to the node on which the
    demanded container is running. The data will be flashed when the container is
    destroyed.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-575
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secrets hold small amounts of sensitive data. For application configuration,
    consider using `ConfigMaps` to hold non-sensitive information.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: Using ConfigMaps
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example of using `ConfigMaps`:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Similar to Secret, `ConfigMaps` can be retrieved with environment variables
    or volumes:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Alternatively, you can use `ConfigMaps` volume to retrieve the configuration
    information:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Mounting Secrets and ConfigMap in the same volume
  id: totrans-584
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Projected volume is a way to group multiple volume sources into the same mount
    point. Currently, it supports Secrets, `ConfigMap`, and `downwardAPI`.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of how we group the examples of Secrets and `ConfigMaps` that
    we used in this chapter:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Let''s check `stdout` to see if it works properly:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: See also
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Working with Volumes* section in [*Chapter 2*](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)*, Walking
    through Kubernetes Concepts*'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with configuration files * section in *[Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    Playing with Containers*
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Moving monolithic to microservices* and *Working with the private Docker
    registry * sections in *[Chapter 5](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml),
    Building Continuous Delivery Pipeline*'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Advanced settings in kubeconfig * section in *[Chapter 7](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    Building Kubernetes on GCP*
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with names
  id: totrans-595
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create any Kubernetes object, such as a Pod, Deployment, and Service,
    you can assign a name to it. The names in Kubernetes are spatially unique, which
    means you cannot assign the same name in the Pods.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-597
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes allows us to assign a name with the following restrictions:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: Up to 253 characters
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lowercase of alphabet and numeric characters
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May contain special characters in the middle, but only dashs (-) and dots (.)
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-602
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For assigning a name to the Pod, follow the following steps:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is the Pod YAML configuration that assigns the Pod name
    as `my-pod` to the container name as `my-container`; you can successfully create
    it as follows:'
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'You can use the `kubectl describe` command to see the container named `my-container`
    as follows:'
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'On the other hand, the following example contains two containers, but assigns
    the same name, `my-container`; therefore, the `kubectl create` command returns
    an error and can''t create the Pod:'
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: You can add the `--validate` flag.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: For example, the command `kubectl create -f duplicate.yaml --validate` uses
    a schema to validate the input before sending it.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: 'In another example, the YAML contains a ReplicationController and Service,
    both of which are using the same name, `my-nginx`, but it is successfully created
    because the Deployment and Service are different objects:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: How it works...
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A name is just a unique identifier, and all naming conventions are good; however,
    it is recommended to look up and identify the container image. For example:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '`memcached-pod1`'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`haproxy.us-west`'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my-project1.mysql`'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, the following examples do not work because of Kubernetes
    restrictions:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '`Memcache-pod1` (contains uppercase)'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`haproxy.us_west` (contains underscore)'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my-project1.mysql.` (dot in the last)'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that Kubernetes supports a label that allows assigning a `key=value` style
    identifier. It also allows duplication. Therefore, if you want to assign something
    like the following information, use a label instead:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: 'Environment (for example: staging, production)'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Version (for example: v1.2)'
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Application role (for example: frontend, worker)'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, Kubernetes also supports names that have different Namespaces.
    This means that you can use the same name in different Namespaces (for example:
    `nginx`). Therefore, if you want to assign just an application name, use Namespaces
    instead.'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-628
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section from the chapter described how to assign and find the name of
    objects. This is just a basic methodology, but Kubernetes has more powerful naming
    tools, such as Namespace and selectors, to manage clusters:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '*Working with Pods*'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deployment API*'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with Services*'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with Namespaces*'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with labels and selectors*'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Namespaces
  id: totrans-635
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a Kubernetes cluster, the name of a resource is a unique identifier within
    a Namespace. Using a Kubernetes Namespace could separate user spaces for different
    environments in the same cluster. It gives you the flexibility of creating an
    isolated environment and partitioning resources to different projects and teams.
    You may consider Namespace as a virtual cluster. Pods, Services, and Deployments
    are contained in a certain Namespace. Some low-level resources, such as nodes
    and `persistentVolumes`, do not belong to any Namespace.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dig into the resource Namespace, let''s understand `kubeconfig` and
    some keywords first:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1dc5384-97c8-4a7b-af9b-ddbdc62e60c0.png)'
  id: totrans-638
  prefs: []
  type: TYPE_IMG
- en: The relationship of kubeconfig components
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '`kubeconfig` is used to call the file which configures the access permission
    of Kubernetes clusters. As the original configuration of the system, Kubernetes
    takes `$HOME/.kube/config` as a `kubeconfig` file. Some concepts that are illustrated
    by the preceding diagram are as follows:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '**kubeconfig defines user, cluster, and context**: `kubeconfig` lists multiple
    users for defining authentication, and multiple clusters for indicating the Kubernetes
    API server. Also, the context in `kubeconfig` is the combination of a user and
    a cluster: accessing a certain Kubernetes cluster with what kind of authentication.'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Users and clusters are sharable between contexts**: In the previous diagram,
    both **Context 1** and **Context 3** take **User** **1** as their user content.
    However, each context can only have a single user and single cluster definition.'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Namespace can be attached to context**: Every context can be assigned to
    an existing Namespace. If there are none, like **Context 3**, it is along with
    the default Namespace, named `default`, as well.'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The current context is the default environment for client**: We may have
    several contexts in `kubeconfig`, but only one for the current context. The current
    context and the Namespace attached on it will construct the default computing
    environment for users.'
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now you will get the idea that, as Namespace works with `kubeconfig`, users
    can easily switch default resources for usage by switching the current context
    in `kubeconfig`. Nevertheless, users can still start any resource in a different
    Namespace with a specified one. In this recipe, you will learn how to create your
    own Namespace and how to work with it.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-646
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, Kubernetes has created a Namespace named `default`. All the objects
    created without specifying Namespaces will be put into the `default` Namespace.
    Kubernetes will also create another initial Namespace called `kube-system` for
    locating Kubernetes system objects, such as an add-on or overlay network. Try
    to list all the Namespaces:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: You may find an additional Namespace, `kube-public`, listed at the initial stage.
    It is designed for presenting some public configurations for even users without
    permission to access the Kubernetes system. Both of the provisioning tools, minikube
    and kubeadm, will create it while booting the system up.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of a Namespace must be a DNS label and follow the following rules:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: At most, 63 characters
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching regex [a-z0-9]([-a-z0-9]*[a-z0-9])
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-653
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will demonstrate how to create a Namespace, change the default
    Namespace, and delete the Namespace.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Namespace
  id: totrans-655
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For creating a Namespace, following are the steps:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: 'After deciding on our desired name for Namespace, let''s create it with a configuration
    file:'
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'You can now see that we have an additional namespace called `my-namespace`.
    Next, let''s run a Kubernetes Deployment in this new Namespace:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'While trying to check the newly created resource, we cannot easily find them
    as usual:'
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Instead, the Deployment is shown with a flag related to the Namespace:'
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Now you can find the resource that was just created.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: Changing the default Namespace
  id: totrans-666
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in the previous introduction, we can change the default Namespace by switching
    the current context in `kubeconfig` to another one:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we may check the current context with the subcommand `config`:'
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: You may feel unfamiliar with the output when checking the current context. The
    value of the preceding current context is defined and created by `kubeadm`. You
    could get `minikube` shown on screen if you leveraged `minikube` as your Kubernetes
    system management tool.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter what you got from checking the current context in `kubeconfig`, use
    the subcommand `config set-context` to create a new context:'
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The preceding command is based on `kubeadm` managed Kubernetes; you may fire
    a similar one for `minikube`, with the names of the default cluster and user in
    `kubeconfig`:'
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Next, check `kubeconfig` to verify the changes:'
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: When checking the configuration of `kubeconfig`, in the section of contexts,
    you can find a context named exactly as what we defined and which also takes our
    newly created Namespace.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: 'Fire the following command to switch to using the new context:'
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Now the current context is our customized one, which is along with the Namespace
    `my-namespace`.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the default Namespace is changed to `my-namespace`, it is possible that
    we can get the Deployment without specifying the Namespace:'
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Deleting a Namespace
  id: totrans-683
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you followed the previous pages for the Kubernetes resource, you may have
    gotten the idea that the subcommand `delete` is used to remove resources. It is
    workable in the case of removing a Namespace. At the same time, if we try to delete
    a Namespace, the resources under it will be removed, as well:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'To solve this issue, you may attach another Namespace to the current context,
    or just change your current context to the previous one:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: How it works…
  id: totrans-688
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we discussed the Namespaces and context of `kubeconfig` together, they
    are independent objects in the Kubernetes system. The context of `kubeconfig`
    is a client concept which can only be controlled by certain users, and it makes
    it easier to work with Namespaces and clusters. On the other hand, Namespace is
    the concept of the server side, working for resource isolation in clusters, and
    it is able to be shared between clients.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-690
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We not only leverage Namespace to separate our resources, but also to realize
    finer computing resource provisioning. By restricting the usage amount of the
    computing power of a Namespace, the system manager can avoid the client creating
    too many resources and making servers overload.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: Creating a LimitRange
  id: totrans-692
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set the resource limitation of each Namespace, the admission controller `LimitRanger`
    should be added in the Kubernetes API server. Do not worry about this setting
    if you have `minikube` or `kubeadm` as your system manager.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '**The admission controller in the Kubernetes API server** Admission controller
    is a setting in the Kubernetes API server which defines more advanced functionality
    in the API server. There are several functions that can be set in the admission
    controller. Users can add the functions when starting the API server through the
    configuration file or using CLI with the flag `--admission-control`. Relying on
    `minikube` or `kubeadm` for system management, they have their own initial settings
    in the admission controller:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '**Default admission controller in** **kubeadm**: `Initializers`, `NamespaceLifecycle`,
    `LimitRanger`, `ServiceAccount`, `PersistentVolumeLabel`, `DefaultStorageClass`,
    `DefaultTolerationSeconds`, `NodeRestriction`, `ResourceQuota`'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default admission controller in minikube**: `NamespaceLifecycle`, `LimitRanger`,
    `ServiceAccount`, `DefaultStorageClass, ResourceQuota`'
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the version of your API server, there is a recommended list in an official
    document at [https://kubernetes.io/docs/admin/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use](https://kubernetes.io/docs/admin/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use).
    Check for more ideas!
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: 'A plain new Namespace has no limitation on the resource quota. At the beginning,
    we start a Namespace and take a look at its initial settings:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'After that, we create a resource called `LimitRange` for specifying the resource
    limitation of a Namespace. The following is a good example of creating a limit
    in a Namespace:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: We will then limit the resources in a Pod with the values of `2` as `max` and
    `200m` as a `min` for CPU, and `1Gi` as max and `6Mi` as a min for memory. For
    the container, the CPU is limited between `100m - 2` and the memory is between
    `3Mi` - `1Gi`. If the max is set, then you have to specify the limit in the Pod/container
    spec during the resource creation; if the min is set, then the request has to
    be specified during the Pod/container creation. The `default` and `defaultRequest`
    section in LimitRange is used to specify the default limit and request in the
    container spec.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '**The value of CPU limitation in LimitRange** What do the values of `2` and
    `200m` mean in the Pod limitation in the file `my-first-limitrange.yaml`? The
    integer value means the number of CPU; the "m" in the value means millicpu, so
    `200m` means 0.2 CPU (200 * 0.001). Similarly, the default CPU limitation of the
    container is 0.2 to 0.3, and the real limitation is 0.1 to 2.'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterwards, we create the LimitRange in our plain Namespace and check what
    will happen:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'When you query the detail description of `my-namespace`, you will see the constraint
    attached to the Namespace directly. There is not any requirement to add the LimitRange.
    Now, all the Pods and containers created in this Namespace have to follow the
    resource limits listed here. If the definitions violate the rule, a validation
    error will be thrown accordingly:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Deleting a LimitRange
  id: totrans-708
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can delete the LimitRange resource with the subcommand `delete`. Like creating
    the `LimitRange`, deleting a `LimitRange` in a Namespace would remove the constraints
    in the Namespace automatically:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: See also
  id: totrans-711
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many Kubernetes resources are able to run under a Namespace. To achieve good
    resource management, check out the following recipes:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '*Working with Pods*'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deployment API*'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with names*'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting resources in nodes* section in *[Chapter 7](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    Building Kubernetes on GCP*'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with labels and selectors
  id: totrans-717
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Labels** are a set of key/value pairs, which are attached to object metadata.
    We could use labels to select, organize, and group objects, such as Pods, ReplicaSets,
    and Services. Labels are not necessarily unique. Objects could carry the same
    set of labels.'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: 'Label selectors are used to query objects with labels of the following types:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: 'Equality-based:'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use equal (`=` or `==`) or not-equal (`!=`) operators
  id: totrans-721
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set-based:'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `in` or `notin` operators
  id: totrans-723
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-724
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you get to setting labels in the objects, you should consider the valid
    naming convention of key and value.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: 'A valid key should follow these rules:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: A name with an optional prefix, separated by a slash.
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A prefix must be a DNS subdomain, separated by dots, no longer than 253 characters.
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A name must be less than 63 characters with the combination of [a-z0-9A-Z] and
    dashes, underscores, and dots. Note that symbols are illegal if put at the beginning
    and the end.
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A valid value should follow the following rules:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: A name must be less than 63 characters with the combination of [a-z0-9A-Z] and
    dashes, underscores, and dots. Note that symbols are illegal if put at the beginning
    and the end.
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should also consider the purpose, too. For example, there are two projects, `pilot`
    and `poc`. Also, those projects are under different environments, such as `develop`
    and `production`. In addition, some contain multiple tiers, such as `frontend`,
    `cache`, and `backend`. We can make our labels key and value pair combination
    like follows:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: How to do it...
  id: totrans-734
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to create several Pods with the previous labels to distinguish different
    projects, environments, and tiers, as follows:'
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **YAML Filename** | **Pod Image** | **Project** | **Environment** | **Tier**
    |'
  id: totrans-736
  prefs: []
  type: TYPE_TB
- en: '| `pilot-dev.yaml` | `nginx` | pilot | develop | `frontend` |'
  id: totrans-737
  prefs: []
  type: TYPE_TB
- en: '| `pilot-dev.yaml` | `memcached` | `cache` |'
  id: totrans-738
  prefs: []
  type: TYPE_TB
- en: '| `pilot-prod.yaml` | `nginx` | production | `frontend` |'
  id: totrans-739
  prefs: []
  type: TYPE_TB
- en: '| `pilot-prod.yaml` | `memcached` | `cache` |'
  id: totrans-740
  prefs: []
  type: TYPE_TB
- en: '| `poc-dev.yaml` | `httpd` | poc | develop | `frontend` |'
  id: totrans-741
  prefs: []
  type: TYPE_TB
- en: '| `poc-dev.yaml` | `memcached` | `cache` |'
  id: totrans-742
  prefs: []
  type: TYPE_TB
- en: 'For convenience, we will prepare three YAML files that contain two Pods each,
    with a `YAML separator ---` between Pods:'
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pilot-dev.yaml`:'
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '`pilot-prod.yaml`:'
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '`poc-dev.yaml`:'
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Create those six Pods with the `kubectl create` command, as follows, to see
    how labels are defined:'
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Run `kubectl describe <Pod name>` to check labels, as follows. It looks good,
    so let''s use the label selector to query these Pods by different criteria:'
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: How it works...
  id: totrans-754
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier in this section, there are two types of label selectors:
    either equality-based or set-based. Those types have different operators to specify
    criteria.'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: Equality-based label selector
  id: totrans-756
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The equality-based selector can specify equal or not equal, and also uses commas
    to add more criteria. Use the `-l` or `--selector` option to specify these criteria
    to filter the name of the object; for example:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: 'Query Pods which belong to the pilot project:'
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Query Pods which belong to the frontend tier:'
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Query Pods which belong to the frontend tier AND the under develop environment:'
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Query Pods which belong to the frontend tier and NOT the under develop environment:'
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Set-based label selector
  id: totrans-766
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the set-based selector, you can use either the `in` or `notin` operator,
    which is similar to the `SQL IN` clause that can specify multiple keywords, as
    in the following examples:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: 'Query `Pods` which belong to the `pilot` project:'
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Query `Pods` which belong to the pilot project and `frontend` tier:'
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Query `Pods` which belong to the pilot project and either the `frontend` or
    `cache` tier:'
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Query `Pods` which belong to the pilot project and not the `frontend` or `backend`
    tier (note, we didn''t create the `backend` tier object):'
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'As you can see in the preceding examples for both the equality-based and set-based
    label selector, equality-based is simpler and set-based is more expressive. Note
    that you can mix both operator as follows:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: 'Query Pods which do not belong to the pilot project and develop environment:'
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: So, you can use the most efficient way to filter out the Kubernetes objects.
    In addition, you can also use either or both types of selectors to configure the
    Kubernetes Service, Deployments, and so on. However, some objects support the
    equality-based selector and some objects support both. So, let's take a look at
    how to define it.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-780
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Label selectors are useful to not only list an object, but also to specify the
    Kubernetes Service and Deployment to bind objects.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: Linking Service to Pods or ReplicaSets using label selectors
  id: totrans-782
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of Kubernetes version 1.9, Service only supports the equality-based selector
    to bind to Pods or ReplicaSet.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create one Service that binds to `nginx`, which belongs to the production
    environment and the pilot project. Remember that `nginx` also belongs to the frontend
    tier:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Here is the equivalent, where you can use the `kubectl expose` command to specify
    the label selector:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Based on your Kubernetes environment, if you are using minikube, it is easier
    to check your Service with `minikube service <Service name>`, as in the following
    screenshot. If you are not using minikube, access to any Kubernetes node and assigned
    Service port number. For the following screenshot, it would be `<node ip>:31981
    or <node ip>:31820`:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0be9472-e1c0-4b61-9224-5af359c3be14.png)'
  id: totrans-789
  prefs: []
  type: TYPE_IMG
- en: Access to Service which is running on minikube
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: Linking Deployment to ReplicaSet using the set-based selector
  id: totrans-791
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deployment supports not only the equality-based selector, but also the set-based
    selector, to specify `ReplicaSet`. To do that, you can write `spec.selector.matchExpressions[]`
    to specify the key and `in`/`notin` operator. For example, if you want to specify `project
    in (poc), environment in (staging), tier notn (backend,cache)`, then `matchExpressions`
    would be as follows:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: As you can see, the YAML array is represented as `*-*`, and the map object as
    `{}`, to specify the key, operator, and values. Note that values would also be
    an array, so use the square bracket `[]` to specify one or more values.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing you need to aware of is one label, called the `pod-template-hash`
    label, which is created by Deployment. When you create a Deployment, it will also
    create a `ReplicaSet` object. At this time, Deployment will also assign the `pod-template-hash`
    label to the `ReplicaSet`. Let''s see how it works:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: As you can see, the `ReplicaSet` `my-nginx2-764d7cfff` has an equality-based
    selector, as `pod-template-hash=320837999` is appended to the Selector and Pod
    template. It will be used to generate a `ReplicaSet` and Pod name with a particular
    hash function (for example, `my-nginx2-764d7cfff`).
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-798
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you learned how flexible it is to assign a label to your Kubernetes
    object. In addition, equality-based and set-based selectors allow us to filter
    out an object by label. Selector is important that loosely couple an object such
    as Service and ReplicaSet/Pod as well as Deployment and ReplicaSet.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sections will also use labels and the concept of selectors to
    utilize container management:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: '*Updating live containers* section in *[Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    Playing with Containers*'
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Managing the Kubernetes* *cluster on GKE* section in *[Chapter 7](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml),
    Building Kubernetes on GCP*'
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
