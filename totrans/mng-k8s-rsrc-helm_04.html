<html><head></head><body>
		<div id="_idContainer062">
			<h1 id="_idParaDest-92" class="chapter-number"><a id="_idTextAnchor139"/>4</h1>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor140"/>Scaffolding a New Helm Chart</h1>
			<p>In the previous chapter, you learned how to use Helm from an end user perspective, leveraging it as a package manager to install applications to Kubernetes. Leveraging Helm in this fashion required you to understand how to use the Helm life cycle commands (<strong class="source-inline">install</strong>, <strong class="source-inline">upgrade</strong>, <strong class="source-inline">rollback</strong>, and <strong class="source-inline">uninstall</strong>), but it did not require you to understand how the Helm chart itself was built. While an understanding of the Helm CLI commands is necessary to install and manage applications installed by Helm, that level of knowledge alone will not allow you to package your own applications into Helm charts.</p>
			<p>In the second part of this book, starting with this chapter, we will switch gears away from being a Helm chart end user and transition into becoming a Helm chart developer. We will accomplish this by building a Helm chart from scratch over the next few chapters that deploys an instance of the Guestbook application, a commonly used sample application within the Kubernetes community. By the end of the second part, you will have an understanding of the concepts and experience required to write robust Helm charts.</p>
			<p>In this chapter, we will begin to explore Helm chart development by discussing the following topics:</p>
			<ul>
				<li>Understanding the Guestbook application</li>
				<li>Understanding the YAML format</li>
				<li>Using <strong class="source-inline">helm create</strong> to scaffold a new Helm chart</li>
				<li>Deploying the scaffolded Guestbook chart</li>
				<li>Exploring the <strong class="source-inline">Chart.yaml</strong> file</li>
				<li>Updating the <strong class="source-inline">Chart.yaml</strong> file</li>
			</ul>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor141"/>Technical requirements</h1>
			<p>This section requires the <strong class="source-inline">minikube</strong> and <strong class="source-inline">helm</strong> binaries to be installed on your local machine. The installation and configuration of these tools are covered in <a href="B17979_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Preparing a Kubernetes and Helm Environment</em>.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor142"/>Understanding the Guestbook application</h1>
			<p>Since the<a id="_idIndexMarker250"/> second part of this book will be centered around developing a Helm chart to deploy the Guestbook application, let’s first understand what this application does and what its architecture looks like.</p>
			<p>The Guestbook application is a <a id="_idIndexMarker251"/>simple <strong class="bold">PHP: Hypertext Preprocessor</strong> (<strong class="bold">PHP</strong>) frontend designed to persist messages to a Redis backend. The frontend consists of a dialog box and a <strong class="bold">Submit</strong> button, as illustrated in the following screenshot:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_4.1_B17979.jpg" alt="Figure 4.1 – The Guestbook PHP frontend&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The Guestbook PHP frontend</p>
			<p>To interact with this application, users can follow these steps:</p>
			<ol>
				<li>Type a message in the <strong class="bold">Messages</strong> dialog box.</li>
				<li>Click the <strong class="bold">Submit</strong> button.</li>
				<li>When the <strong class="bold">Submit</strong> button is clicked, the message will be saved to the Redis database and displayed at the bottom of the page, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_4.2_B17979.jpg" alt="Figure 4.2 – The Guestbook frontend after a new message has been submitted&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The Guestbook frontend after a new message has been submitted</p>
			<p>Redis is an<a id="_idIndexMarker252"/> in-memory, key-value data store that, for our Helm chart, will be clustered to provide data replication. The cluster will consist of one leader node that the Guestbook frontend writes to. Once data is persisted, the leader will replicate across each of the follower nodes, from which Guestbook replicas will read, to retrieve and display the list of previously submitted messages.</p>
			<p>The following <a id="_idIndexMarker253"/>diagram describes how the frontend interacts with Redis:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Figure_4.3_B17979.jpg" alt="Figure 4.3 – Guestbook frontend and Redis interaction&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Guestbook frontend and Redis interaction</p>
			<p>With an understanding of how this application works, let’s focus on starting our Guestbook Helm chart. We’ll begin with a primer on the YAML format, since this format is ubiquitous among the files you will interact with as a Helm chart developer.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor143"/>Understanding the YAML format</h1>
			<p><strong class="bold">YAML Ain’t Markup Language</strong> (<strong class="bold">YAML</strong>) is a <a id="_idIndexMarker254"/>file format used to create human-readable configuration. It is the file format most used to configure Kubernetes resources and is also the format used for many of the files in Helm charts.</p>
			<p>YAML files follow a <strong class="bold">key-value</strong> format to declare configuration. Let’s explore the YAML key-value construct.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor144"/>Defining key-value pairs</h2>
			<p>One of the <a id="_idIndexMarker255"/>most<a id="_idIndexMarker256"/> basic examples of a YAML key-value pair is shown here:</p>
			<pre class="source-code">
name: LearnHelm</pre>
			<p>In the preceding example, the <strong class="source-inline">name</strong> key is given a <strong class="source-inline">LearnHelm</strong> value. In YAML, keys and values are separated by a colon (<strong class="source-inline">:</strong>). Characters written to the left of the colon represent the key, while characters written to the right of the colon represent the value. </p>
			<p>Spacing matters in YAML format. The following line does not constitute a valid key-value pair:</p>
			<pre class="source-code">
name:LearnHelm</pre>
			<p>Note that a space is missing between the colon and the <strong class="source-inline">LearnHelm</strong> string. This would result in a parsing error. A space must exist between the colon and the value.</p>
			<p>While the preceding example represents a simple key-value pair, YAML allows users to configure more complex pairings with nested <a id="_idIndexMarker257"/>elements, called maps. An example is shown here:</p>
			<pre class="source-code">
resources:
  limits:
    cpu: 100m
    memory: 512Mi</pre>
			<p>The preceding example demonstrates a <strong class="source-inline">resources</strong> object containing a map of two key-value pairs:</p>
			<table id="table001-4" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">Key</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">Value</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">resources.limits.cpu</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">100m</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">resources.limits.memory</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">512Mi</strong></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>Keys are determined by following the indentation under a YAML block. Each indentation adds a dot (<strong class="source-inline">.</strong>) separator to the name of the key. The value of the key has been reached when there are no longer any indentations remaining in the YAML block. By common practice, indentations in YAML should use two spaces, but users can provide as many spaces as they desire as long as the spacing is consistent throughout the document.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout"><strong class="bold">Tabs</strong> are not supported by YAML, and their use will result in a parsing error.</p>
			<p>With an<a id="_idIndexMarker258"/> understanding of YAML key-value pairs, let’s now explore some of the common types that values can be defined as.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor145"/>Value types</h2>
			<p>Values in a <a id="_idIndexMarker259"/>YAML file can be of different types. The most common type is a string, which is a text value. Strings can be declared by wrapping a value in quotation marks, but this is not always required. If a value contains at least one alphabetical letter or special character, the value is considered a string, with or without quotation marks. Multiline strings can be set by using the pipe (<strong class="source-inline">|</strong>) symbol, as shown:</p>
			<pre class="source-code">
configuration: |
  server.port=8443
  logging.file.path=/var/log</pre>
			<p>Values can also be integers. A value is an integer when it is a numeric character that is not wrapped in quotations. The following YAML declares an integer value:</p>
			<pre class="source-code">
replicas: 1</pre>
			<p>Compare this to the following YAML, which assigns <strong class="source-inline">replicas</strong> to a string value:</p>
			<pre class="source-code">
replicas: "1"</pre>
			<p>Boolean values are often used as well, which can be declared with either <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>:</p>
			<pre class="source-code">
ingress:
  enable: true</pre>
			<p>This YAML sets <strong class="source-inline">ingress.enable</strong> to the <strong class="source-inline">true</strong> Boolean value. Other acceptable Boolean values are <strong class="source-inline">yes</strong>, <strong class="source-inline">no</strong>, <strong class="source-inline">on</strong>, <strong class="source-inline">off</strong>, <strong class="source-inline">y</strong>, <strong class="source-inline">n</strong>, <strong class="source-inline">Y</strong>, and <strong class="source-inline">N</strong>.</p>
			<p>Values can also be set to more complex types, such as lists. Items in a list in YAML are identified by the dash (<strong class="source-inline">-</strong>) symbol. </p>
			<p>The following demonstrates a YAML list:</p>
			<pre class="source-code">
servicePorts:
  - 8080
  - 8443</pre>
			<p>This YAML<a id="_idIndexMarker260"/> sets <strong class="source-inline">servicePorts</strong> to a list of integers (such as <strong class="source-inline">8080</strong> and <strong class="source-inline">8443</strong>). This syntax can also be used to describe a list of objects:</p>
			<pre class="source-code">
deployment:
  env:
    - name: MY_VAR
      value: MY_VALUE
    - name: SERVICE_NAME
      value: MY_SERVICE</pre>
			<p>In this case, <strong class="source-inline">env</strong> is set to a list of objects containing the <strong class="source-inline">name</strong> and <strong class="source-inline">value</strong> fields. Lists are often used in both Kubernetes and Helm configuration, and understanding them is valuable to using Helm to its fullest potential.</p>
			<p>While YAML is more commonly used in the worlds of Kubernetes and Helm for its ease of readability, the <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) format can be used as well. Let’s <a id="_idIndexMarker261"/>briefly describe this format.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor146"/>The JSON format</h2>
			<p>YAML is a<a id="_idIndexMarker262"/> superset of another widely used format—JSON. This is a<a id="_idIndexMarker263"/> string of key-value pairs, similar to YAML. The key difference is that while YAML relies on spacing and indentation to properly configure key-value pairs, JSON relies on braces and brackets.</p>
			<p>The following example converts the previous YAML example into the JSON format:</p>
			<pre class="source-code">
{
  "deployment": {
    "env": [
      {
        "name": "MY_VAR",
        "value": "MY_VALUE"
      },
      {
        "name": "SERVICE_NAME",
        "value": "MY_SERVICE"
      }
    ]
  }</pre>
			<p>All the keys in JSON are wrapped in quotation marks and positioned before a colon:</p>
			<ul>
				<li>Curly braces (<strong class="source-inline">{</strong>) denote a block in a similar way to how indentations denote a block in YAML. </li>
				<li>Square brackets (<strong class="source-inline">[</strong>) denote a list in a similar way to how dashes denote a list in YAML.</li>
			</ul>
			<p>There are many more constructs to the YAML and JSON formats, but this introduction provides more<a id="_idIndexMarker264"/> than enough information to understand<a id="_idIndexMarker265"/> how they can be used in Helm charts. </p>
			<p>In the next section, we will begin to develop our Guestbook Helm chart by first learning how to scaffold Helm charts.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor147"/>Scaffolding the Guestbook Helm chart</h1>
			<p>When developing<a id="_idIndexMarker266"/> a new Helm chart from scratch, it is often useful to start by running the <strong class="source-inline">helm create</strong> command, which has the following syntax:</p>
			<pre class="source-code">
<strong class="bold">helm create NAME [flags]</strong></pre>
			<p>The <strong class="source-inline">helm create</strong> command <a id="_idIndexMarker267"/>provides a new project folder for your Helm chart. Inside, the folder contains a basic Helm chart scaffolding that you can use to begin developing your chart.</p>
			<p>Let’s run the <strong class="source-inline">helm create</strong> command <a id="_idIndexMarker268"/>to scaffold our Guestbook Helm chart:</p>
			<ol>
				<li value="1">In your terminal, within a directory where you would like to store Helm charts, run the <strong class="source-inline">helm create</strong> command:<p class="source-code"><strong class="bold">$ helm create guestbook</strong></p><p class="source-code"><strong class="bold">Creating guestbook</strong></p></li>
				<li>Review the list of files that have been created:<p class="source-code"><strong class="bold">$ ls –al guestbook</strong></p><p class="source-code"><strong class="bold">.</strong></p><p class="source-code"><strong class="bold">..</strong></p><p class="source-code"><strong class="bold">charts/</strong></p><p class="source-code"><strong class="bold">Chart.yaml</strong></p><p class="source-code"><strong class="bold">.helmignore</strong></p><p class="source-code"><strong class="bold">templates/</strong></p><p class="source-code"><strong class="bold">values.yaml</strong></p><p class="source-code"><strong class="bold">$ ls –l guestbook/templates/</strong></p><p class="source-code"><strong class="bold">deployment.yaml</strong></p><p class="source-code"><strong class="bold">_helpers.tpl</strong></p><p class="source-code"><strong class="bold">hpa.yaml</strong></p><p class="source-code"><strong class="bold">ingress.yaml</strong></p><p class="source-code"><strong class="bold">NOTES.txt</strong></p><p class="source-code"><strong class="bold">serviceaccount.yaml</strong></p><p class="source-code"><strong class="bold">service.yaml</strong></p><p class="source-code"><strong class="bold">tests/</strong></p></li>
			</ol>
			<p>As you can see, the <strong class="source-inline">helm create</strong> command generated a new folder for you called <strong class="source-inline">guestbook</strong>, which<a id="_idIndexMarker269"/> represents the name of the Helm chart. It is not necessarily required to call this folder <strong class="source-inline">guestbook</strong>, but since this is the name of the Helm chart we are creating, it is a good idea to make sure the folder name matches.</p>
			<p>Under the <strong class="source-inline">guestbook</strong> folder, there are <a id="_idIndexMarker270"/>several different files and folders that make up your Helm chart. This may appear overwhelming at first, but we will dive deeper into each component as we develop the Guestbook chart over the next few chapters. By the end of the second part, each of these files will become clearer, and you will be able to jump into your next Helm chart with ease!</p>
			<p>For now, let’s take<a id="_idIndexMarker271"/> a high-level look at each of the files that <strong class="source-inline">helm create</strong> generated for us. As you’ll see in the following table, some of the files are not strictly required for a new Helm chart, but <strong class="source-inline">helm create</strong> provided them for us as a best practice:</p>
			<table id="table002-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">File/Directory</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Definition</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Required?</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">charts/</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A directory that contains dependencies or Helm charts that the parent chart depends on.</p>
						</td>
						<td class="No-Table-Style">
							<p>No</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">Chart.yaml</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A file that contains metadata about the Helm chart.</p>
						</td>
						<td class="No-Table-Style">
							<p>Yes</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.helmignore</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A file that contains a list of files and directories that should be omitted from the Helm chart’s packaging.</p>
						</td>
						<td class="No-Table-Style">
							<p>No</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">templates/</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A directory that contains Golang templates, which are primarily used for generating Kubernetes resources.</p>
						</td>
						<td class="No-Table-Style">
							<p>Yes, unless the chart contains dependencies</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">templates/*.yaml</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A template file used to generate a Kubernetes resource.</p>
						</td>
						<td class="No-Table-Style">
							<p>Yes, unless the chart contains dependencies</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">templates/_*.tpl</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A file that contains boilerplate helper templates.</p>
						</td>
						<td class="No-Table-Style">
							<p>No</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">templates/NOTES.txt</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A template file that is used to generate usage instructions after chart installation.</p>
						</td>
						<td class="No-Table-Style">
							<p>No</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">templates/tests/ (or more generically, templates/*/)</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A folder used for grouping different templates. This is strictly for aesthetics and has no effect on how the Helm chart operates – for example, <strong class="source-inline">templates/tests</strong> is used to group templates that are used for testing.</p>
						</td>
						<td class="No-Table-Style">
							<p>No</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">values.yaml</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A file that contains the chart’s default values.</p>
						</td>
						<td class="No-Table-Style">
							<p>No, but every chart should contain this file as a best practice</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.2 – Files created with the “helm create” command</p>
			<p>In addition to the files listed in the preceding table, there are a few other files that a Helm chart can contain that <strong class="source-inline">helm create</strong> did not include for us. Let’s take a high-level look at <a id="_idIndexMarker272"/>these files in the following table:</p>
			<table id="table003" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">File/Directory</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Definition</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Required?</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">Chart.lock</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A file used to save, or <em class="italic">lock in</em>, the previously applied dependency versions.</p>
						</td>
						<td class="No-Table-Style">
							<p>No</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">crds/</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A directory that contains <strong class="bold">Custom Resource Definition</strong><strong class="bold"> </strong>(<strong class="bold">CRD</strong>) YAML resources. These CRD resources will be installed before those under <strong class="source-inline">templates/</strong>.</p>
						</td>
						<td class="No-Table-Style">
							<p>No</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">README.md</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A file that contains installation and usage information about the Helm chart.</p>
						</td>
						<td class="No-Table-Style">
							<p>No, but every Helm chart should contain this file as a best practice</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">LICENSE</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A file that contains the chart’s license, which provides information about usage and redistribution rights.</p>
						</td>
						<td class="No-Table-Style">
							<p>No</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">values.schema.json</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A file that contains the chart’s values schema in the JSON format. Used to provide input validation.</p>
						</td>
						<td class="No-Table-Style">
							<p>No</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.3– Additional Helm chart files</p>
			<p>Again, we will explore each of these files in greater detail when they become relevant to the topics we will discuss later in this chapter and over the next few chapters.</p>
			<p>For now, let’s focus on the content in the <strong class="source-inline">guestbook</strong> directory that <strong class="source-inline">helm create</strong> generated for us. You may be surprised to know that, upon running <strong class="source-inline">helm create</strong>, you already have a fully functional Helm chart contained within your <strong class="source-inline">guestbook</strong> folder! Let’s install the Guestbook chart in its current state to see what gets deployed.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor148"/>Deploying the scaffolded Guestbook chart</h1>
			<p>Before we<a id="_idIndexMarker273"/> install the chart, let’s set up your Kubernetes environment by following these steps:</p>
			<ol>
				<li value="1">Start Minikube by running the <strong class="source-inline">minikube start</strong> command:<p class="source-code"><strong class="bold">$ minikube start</strong></p></li>
				<li>Create a new namespace called <strong class="source-inline">chapter4</strong>:<p class="source-code"><strong class="bold">$ kubectl create namespace chapter4</strong></p></li>
			</ol>
			<p>Now, let’s proceed by installing your scaffolded chart and reviewing the deployed resources. In <a href="B17979_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>, <em class="italic">Installing Your First App With Helm</em>, we installed a Helm chart from a remote repository by providing the name <strong class="source-inline">bitnami/wordpress</strong>, which references the name of the remote repository and the chart contained within this repository. Alternatively, you can also install a chart by providing the local path to a valid Helm chart project folder. This makes it easy to test your Helm charts and see your progress without needing to publish the chart to a repository first.</p>
			<ol>
				<li value="3">Let’s install your chart by running the following command, where <strong class="source-inline">./guestbook</strong> represents the folder generated by <strong class="source-inline">helm create</strong>:<p class="source-code"><strong class="bold">$ helm install guestbook ./guestbook -n chapter4</strong></p><p class="source-code"><strong class="bold">NAME: guestbook</strong></p><p class="source-code"><strong class="bold">LAST DEPLOYED: Sun Sep 19 10:39:40 2021</strong></p><p class="source-code"><strong class="bold">NAMESPACE: default</strong></p><p class="source-code"><strong class="bold">STATUS: deployed</strong></p><p class="source-code"><strong class="bold">REVISION: 1</strong></p><p class="source-code"><strong class="bold">NOTES:</strong></p><p class="source-code"><strong class="bold">1. Get the application URL by running these commands:</strong></p><p class="source-code"><strong class="bold">  export POD_NAME=$(kubectl get pods --namespace default -l "app.kubernetes.io/name=guestbook,app.kubernetes.io/instance=guestbook" -o jsonpath="{.items[0].metadata.name}")</strong></p><p class="source-code"><strong class="bold">  export CONTAINER_PORT=$(kubectl get pod --namespace default $POD_NAME -o jsonpath="{.spec.containers[0].ports[0].containerPort}")</strong></p><p class="source-code"><strong class="bold">  echo "Visit http://127.0.0.1:8080 to use your application"</strong></p><p class="source-code"><strong class="bold">  kubectl --namespace default port-forward $POD_NAME 8080:$CONTAINER_PORT</strong></p></li>
				<li>Run <strong class="source-inline">helm get manifest</strong> to <a id="_idIndexMarker274"/>review the resources that were deployed:<p class="source-code"><strong class="bold">$ helm get manifest guestbook –n chapter4</strong></p></li>
			</ol>
			<p>As denoted in the output, your scaffolded Guestbook chart (with the default values applied) contains one service account, one service, and one deployment. If you look carefully at the deployment, you’ll find something interesting about the image that was deployed:</p>
			<p class="source-code">image: "nginx:1.16.0"</p>
			<p>Sure enough, a new Helm chart that was scaffolded using <strong class="source-inline">helm create</strong> begins as a basic NGINX chart. <strong class="bold">NGINX</strong> is <a id="_idIndexMarker275"/>a popular open source web server and reverse proxy. Because its installation requires many of the same resources as many other Kubernetes applications, it serves as a great starting point when writing new Helm charts.</p>
			<p>Let’s continue by accessing the NGINX application to verify it was installed properly.</p>
			<ol>
				<li value="5">Since the Helm chart created a <strong class="source-inline">ClusterIP</strong> service, let’s run <strong class="source-inline">kubectl port-forward</strong> so that we can access the NGINX pod. Keep in mind that, although our Guestbook chart has installed NGINX, the deployed resources are still called <strong class="source-inline">guestbook</strong>, since that is the name of our chart:<p class="source-code"><strong class="bold">$ kubectl -n chapter4 port-forward svc/guestbook 8080:80</strong></p></li>
				<li>In a new terminal window (since the current one will block while the <strong class="source-inline">kubectl port-forward</strong> command <a id="_idIndexMarker276"/>is active), use the <strong class="source-inline">curl</strong> command to reach NGINX: <p class="source-code"><strong class="bold">$ curl localhost:8080</strong></p><p class="source-code"><strong class="bold">&lt;!DOCTYPE html&gt;</strong></p><p class="source-code"><strong class="bold">&lt;html&gt;</strong></p><p class="source-code"><strong class="bold">&lt;head&gt;</strong></p><p class="source-code"><strong class="bold">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</strong></p><p class="source-code"><strong class="bold">&lt;style&gt;</strong></p><p class="source-code"><strong class="bold">    body {</strong></p><p class="source-code"><strong class="bold">        width: 35em;</strong></p><p class="source-code"><strong class="bold">        margin: 0 auto;</strong></p><p class="source-code"><strong class="bold">        font-family: Tahoma, Verdana, Arial, sans-serif;</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">&lt;/style&gt;</strong></p><p class="source-code"><strong class="bold">&lt;/head&gt;</strong></p><p class="source-code"><strong class="bold">&lt;body&gt;</strong></p><p class="source-code"><strong class="bold">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</strong></p></li>
			</ol>
			<p>As you can see, we are able to reach NGINX successfully. Now, let’s continue by cleaning up this Helm release. </p>
			<ol>
				<li value="7">Press <em class="italic">Ctrl</em> + <em class="italic">c</em> in the terminal window running the <strong class="source-inline">kubectl port-forward</strong> command. Alternatively, you can close the window.</li>
				<li>Uninstall the <strong class="source-inline">guestbook</strong> Helm release:<p class="source-code"><strong class="bold">$ helm uninstall guestbook –n chapter4</strong></p><p class="source-code"><strong class="bold">release "guestbook" uninstalled</strong></p></li>
				<li>Next, you can delete the <strong class="source-inline">chapter4</strong> namespace, since we won’t need it for the remainder of the chapter:<p class="source-code"><strong class="bold">$ kubectl delete namespace chapter4</strong></p><p class="source-code"><strong class="bold">namespace "chapter4" deleted</strong></p></li>
				<li>Finally, you can shut down your <strong class="source-inline">minikube</strong> cluster:<p class="source-code"><strong class="bold">$ minikube stop</strong></p></li>
			</ol>
			<p>You may realize<a id="_idIndexMarker277"/> after this exercise that our Guestbook chart doesn’t resemble the architecture we presented at the beginning of this chapter very much. However, by providing a scaffold that we will use as a starting point, we have already made great progress toward creating a Helm chart for deploying the desired architecture. We will continue making progress on our Guestbook chart in the next chapter when we learn about dependencies. At that time, we will declare a dependency to install Redis and the backend of our Guestbook architecture.</p>
			<p>In the next section, we’ll take a deeper dive into one of the most important Helm chart files, <strong class="source-inline">Chart.yaml</strong>. Then, at the end of the chapter, we will update this file to provide new settings that align with our Guestbook chart.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor149"/>Understanding the Chart.yaml file</h1>
			<p>The <strong class="source-inline">Chart.yaml</strong> file, also <a id="_idIndexMarker278"/>referred to as the <strong class="bold">chart definition</strong>, is used<a id="_idIndexMarker279"/> for storing different pieces of metadata about a Helm chart. This file is required, and if it is not included within a chart, you’ll receive the following error:</p>
			<pre class="source-code">
Error: Chart.yaml file is missing</pre>
			<p>A <strong class="source-inline">Chart.yaml</strong> file was created for you earlier when you ran <strong class="source-inline">helm create</strong>. Let’s review this file by running the following command:</p>
			<pre class="source-code">
<strong class="bold">$ cat guestbook/Chart.yaml</strong></pre>
			<p>An output like the following will be displayed:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/Figure_4.4_B17979.jpg" alt="Figure 4.4 – The Guestbook Chart.yaml file&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – The Guestbook Chart.yaml file</p>
			<p>A <strong class="source-inline">Chart.yaml</strong> file<a id="_idIndexMarker280"/> can contain many different fields, some of which are required, while most other fields are optional. Let’s take a closer look at each of the fields provided in our Guestbook chart’s <strong class="source-inline">Chart.yaml</strong> file.</p>
			<table id="table004" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Field</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Required?</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">apiVersion</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">The chart API version</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Yes</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">The name of the Helm chart</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Yes</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">description</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">A brief description of the Helm chart</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">No</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">type</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">The type of Helm chart (either </span><strong class="source-inline">Application</strong><span lang="en-US" xml:lang="en-US"> or </span><strong class="source-inline">Library</strong><span lang="en-US" xml:lang="en-US">)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">No</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">version</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">The version of the Helm chart, in SemVer format.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Yes</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">appVersion</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">The version of the application that the Helm chart deploys. This does not need to be in the SemVer format.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">No</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.4 – Fields from the generated Chart.yaml file</p>
			<p>As you can see<a id="_idIndexMarker281"/> from Guestbook’s chart definition, the <strong class="source-inline">apiVersion</strong> value for our chart is set to <strong class="source-inline">v2</strong>. Charts with an <strong class="source-inline">apiVersion</strong> value of <strong class="source-inline">v2</strong> are only compatible with Helm 3. The other possible <strong class="source-inline">apiVersion</strong> value is <strong class="source-inline">v1</strong>, but this is a legacy version that was geared towards Helm 2. Charts with an <strong class="source-inline">apiVersion</strong> value of <strong class="source-inline">v1</strong> handled dependencies differently and did not support library charts (topics that we will discuss in greater detail later in this book). Helm 3 is in fact backward-compatible with <strong class="source-inline">apiVersion v1</strong>, but in order to leverage Helm’s latest features and to avoid deprecations, new Helm charts should be created using <strong class="source-inline">apiVersion v2</strong>.</p>
			<p>The type of Helm chart we have scaffolded, according to the <strong class="source-inline">Chart.yaml</strong> file, is an <strong class="source-inline">application</strong> chart. A Helm chart can be either an <strong class="source-inline">application</strong> chart or a <strong class="source-inline">library</strong> chart. An application chart is used to deploy an application to Kubernetes, while a library chart is used to provide reusable helper templates. We will discuss library charts in greater detail in <a href="B17979_06.xhtml#_idTextAnchor167"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding Helm Templates </em>. The <strong class="source-inline">type</strong> field in the <strong class="source-inline">Chart.yaml</strong> file is optional and defaults to <strong class="source-inline">application</strong>.</p>
			<p>The other fields in our chart definition, <strong class="source-inline">name</strong>, <strong class="source-inline">description</strong>, <strong class="source-inline">version</strong>, and <strong class="source-inline">appVersion</strong>, are used to provide metadata that identifies our chart. As an example, think back to <a href="B17979_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>, <em class="italic">Installing Your First App with Helm, w</em>hen we searched Artifact Hub from the command line for WordPress charts. We ran the <strong class="source-inline">helm search hub wordpress</strong> command and saw an output like the following:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_4.5_B17979.jpg" alt="Figure 4.5 – An example of name, version, appVersion, and description&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – An example of name, version, appVersion, and description</p>
			<p>These fields are acquired from their corresponding fields in <strong class="source-inline">Chart.yaml</strong>. Note that you can also see this information on any chart’s Artifact Hub page.</p>
			<p>In addition to the fields included in our scaffolded <strong class="source-inline">Chart.yaml</strong> file, there are many other fields used to<a id="_idIndexMarker282"/> describe your chart, as shown in the following table:</p>
			<table id="table005" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Field</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Required?</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">kubeVersion</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">A range of compatible Kubernetes versions in the SemVer format.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">No</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">keywords</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">A list of keywords used to describe the Helm chart. Keywords are also used to provide search terms for the </span><strong class="source-inline">helm search</strong><span lang="en-US" xml:lang="en-US"> command.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">No</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">home</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">The URL to the Helm chart’s home page.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">No</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">sources</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">A list of URLs that link to source code used by the Helm chart.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">No</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">dependencies</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">A list of charts that your Helm chart is reliant on.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">No</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">maintainers</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">A list of Helm chart maintainers.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">No</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">icon</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">An icon in SVG or PNG format used to represent the Helm chart. Displayed on the chart’s Artifact Hub page.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">No</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">deprecated</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Indicates whether the Helm chart has been deprecated.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">No</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">annotations</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">A list of annotations used to provide custom metadata.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">No</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.5 – Additional Chart.yaml fields</p>
			<p>The <strong class="source-inline">kubeVersion</strong> field is <a id="_idIndexMarker283"/>used to provide validation against the target Kubernetes cluster version. This is useful if your Helm chart uses resources that are only compatible with certain versions of Kubernetes. You could set <strong class="source-inline">kubeVersion</strong> to a string such as <strong class="source-inline">&gt;= 1.18.0 &lt; 1.20.0</strong>, and Helm will ensure that the chart is installed only if Kubernetes is greater than or equal to version <strong class="source-inline">1.18.0</strong> and less than (exclusive) <strong class="source-inline">1.20.0</strong>. You can also use the <strong class="source-inline">OR</strong> (<strong class="source-inline">||</strong>) operator, as in <strong class="source-inline">&gt;= 1.15.0 &lt;= 1.17.0 || &gt;= 1.18.0 &lt; 1.20.0</strong>.</p>
			<p>The <strong class="source-inline">dependencies</strong> field is the most functional of these optional fields. Charts added under the <strong class="source-inline">dependencies</strong> field will be installed alongside your Helm chart’s resources. We will explore dependencies more in the next chapter.</p>
			<p>As shown earlier with the <strong class="source-inline">name</strong>, <strong class="source-inline">version</strong>, <strong class="source-inline">appVersion</strong>, and <strong class="source-inline">description</strong> fields, each of the other <strong class="source-inline">Chart.yaml</strong> properties also have an impact on how a Helm chart is displayed in Artifact Hub. Look at the following screenshot, taken from Bitnami’s WordPress page in Artifact Hub:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_4.6_B17979.jpg" alt="Figure 4.6 – Chart.yaml metadata displayed on Artifact Hub&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Chart.yaml metadata displayed on Artifact Hub</p>
			<p>Let’s compare<a id="_idIndexMarker284"/> this to WordPress’s <strong class="source-inline">Chart.yaml</strong> file, retrieved by running <strong class="source-inline">helm show values bitnami/wordpress</strong>:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/Figure_4.7_B17979.jpg" alt="Figure 4.7 – The Bitnami/WordPress Chart.yaml file&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – The Bitnami/WordPress Chart.yaml file</p>
			<p>Note how <strong class="source-inline">home</strong>, <strong class="source-inline">sources</strong>, <strong class="source-inline">maintainers</strong>, <strong class="source-inline">dependencies</strong>, and <strong class="source-inline">keywords</strong> from <strong class="source-inline">Chart.yaml</strong> are also displayed in Artifact Hub.</p>
			<p>It is not required to<a id="_idIndexMarker285"/> provide all the <strong class="source-inline">Chart.yaml</strong> fields in full, but it is a good thing to do if you are publishing your charts to Artifact Hub or another repository that can display chart metadata. Otherwise, feel free to use your discretion and provide the fields that you find relevant and necessary. Besides <strong class="source-inline">apiVersion</strong>, <strong class="source-inline">name</strong>, and <strong class="source-inline">version</strong>, we recommend providing at least <strong class="source-inline">appVersion</strong> and <strong class="source-inline">description</strong>, since these fields provide a good high-level glance at the application your Helm chart is packaging. If you are writing a Helm chart for public use, you should consider also adding <strong class="source-inline">maintainers</strong>, <strong class="source-inline">home</strong>, and <strong class="source-inline">sources</strong>, and if you are publishing to Artifact Hub, you should also include <strong class="source-inline">keywords</strong> so that the chart can be easily discovered.</p>
			<p>With an understanding of the <strong class="source-inline">Chart.yaml</strong> fields, let’s finish this chapter by updating our scaffolded chart definition to better suit our Guestbook application.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor150"/>Updating the Guestbook Chart.yaml file</h1>
			<p>The <a id="_idIndexMarker286"/>scaffolded <strong class="source-inline">Chart.yaml</strong> file that <strong class="source-inline">helm create</strong> generated is catered around NGINX and not Guestbook as we would desire. Let’s make a couple of quick changes to improve the content:</p>
			<ol>
				<li value="1">First, let’s update the chart description to better describe the application our chart will deploy. Update the <strong class="source-inline">description</strong> field of <strong class="source-inline">Chart.yaml</strong> to the following (or feel free to provide your own):<p class="source-code">description: An application used for keeping a running record of guests</p></li>
				<li>Next, let’s provide a more appropriate <strong class="source-inline">appVersion</strong> setting that better suits the version of Guestbook that our chart will deploy. The latest version of Guestbook is <strong class="source-inline">v5</strong>, so let’s use this as our <strong class="source-inline">appVersion</strong>:<p class="source-code">appVersion: v5</p></li>
			</ol>
			<p>Our <strong class="source-inline">Chart.yaml</strong> file should now look like this (with the comments removed):</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/Figure_4.8_B17979.jpg" alt="Figure 4.8 – The updated Chart.yaml file for Guestbook&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – The updated Chart.yaml file for Guestbook</p>
			<p>Feel free to add any of the other <strong class="source-inline">Chart.yaml</strong> fields as well, but these changes, at a minimum, will put us in a good state where the <strong class="source-inline">Chart.yaml</strong> metadata accurately reflects the application that we will deploy.</p>
			<p>We will revisit the <strong class="source-inline">Chart.yaml</strong> field in the next chapter when we add a chart dependency for<a id="_idIndexMarker287"/> deploying Redis.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor151"/>Summary</h1>
			<p>In this chapter, we began to peek into the world of Helm chart development by introducing the Helm chart and chart definition structure. A Helm chart consists of a chart definition (a <strong class="source-inline">Chart.yaml</strong> file) and template files used for generating Kubernetes resources. A chart definition is used to provide an identity around the chart, including metadata such as the chart name, version, description, and the application version that the chart deploys.</p>
			<p>We also introduced an application called Guestbook, and we began writing a Helm chart that will be used to deploy this application. We ran the <strong class="source-inline">helm create</strong> command to scaffold a new Helm chart, and we updated the <strong class="source-inline">Chart.yaml</strong> file to better reflect the application that our chart will deploy. In the next chapter, we will return to the <strong class="source-inline">Chart.yaml</strong> file when we add a dependency for installing Redis, the backend service that our Guestbook frontend relies on.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor152"/>Further reading</h1>
			<p>To learn more about Helm chart structure and <strong class="source-inline">Chart.yaml</strong> files, visit the Helm documentation at <a href="https://helm.sh/docs/topics/charts/">https://helm.sh/docs/topics/charts/</a>. For more information on the Guestbook application, visit <a href="https://kubernetes.io/docs/tutorials/stateless-application/guestbook/">https://kubernetes.io/docs/tutorials/stateless-application/guestbook/</a>.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor153"/>Questions</h1>
			<ol>
				<li value="1">What is the file format most used in Kubernetes and Helm?</li>
				<li>What is the command used to scaffold a new Helm chart?</li>
				<li>Where is the Helm chart name and version defined?</li>
				<li>What are the three required fields in the <strong class="source-inline">Chart.yaml</strong> file?</li>
				<li>Helm charts can be made up of many different files. Which files are required?</li>
				<li>Which folder of a Helm chart is used to contain Kubernetes resource templates?</li>
				<li>Which <strong class="source-inline">Chart.yaml</strong> field is used to describe the application version that a Helm chart deploys?</li>
			</ol>
		</div>
		<div>
			<div id="_idContainer063">
			</div>
		</div>
	</body></html>