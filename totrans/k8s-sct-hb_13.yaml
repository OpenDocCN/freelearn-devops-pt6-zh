- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Case Studies and Real-World Examples
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究与实际应用示例
- en: 'In this chapter, we will see real-world examples of how Kubernetes Secrets
    are used in production environments. The chapter will cover case studies of production
    Secrets management in Kubernetes and lessons learned from real-world deployments.
    Additionally, you will learn about managing Secrets in CI/CD pipelines and integrating
    Secrets management into the CI/CD process. The chapter will also cover how to
    manage Secrets in pipelines using Kubernetes tools and the best practices to secure
    CI/CD Secrets management. We will expand on the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示 Kubernetes Secrets 在生产环境中的实际应用案例。本章将涵盖 Kubernetes 生产环境中 Secrets 管理的案例研究，并分享从实际部署中获得的经验教训。此外，您还将学习如何在
    CI/CD 流水线中管理 Secrets，并将 Secrets 管理集成到 CI/CD 过程中。本章还将讲解如何使用 Kubernetes 工具管理流水线中的
    Secrets，并介绍确保 CI/CD Secrets 管理安全的最佳实践。我们将扩展以下主题：
- en: Real-world examples of how Kubernetes Secrets are used in production environments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes Secrets 在生产环境中的实际应用示例
- en: Secrets management from a CI/CD perspective
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 CI/CD 角度的密钥管理
- en: Lessons learned from real-world deployments
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从实际部署中学到的经验
- en: Managing the Secrets’ lifecycle end to end in the Kubernetes production system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 生产系统中管理 Secrets 的生命周期
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To link theory with practice, we are leveraging a series of tools and platforms
    commonly used to interact with the Google Cloud API and Kubernetes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将理论与实践结合起来，我们利用了一系列常用工具和平台，这些工具和平台通常用于与 Google Cloud API 和 Kubernetes 交互：
- en: '**gcloud CLI**: This is a set of tools used to create and manage Google Cloud
    resources ([https://cloud.google.com/sdk/gcloud#download_and_install_the](https://cloud.google.com/sdk/gcloud#download_and_install_the))'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gcloud CLI**：这是用于创建和管理 Google Cloud 资源的一套工具（[https://cloud.google.com/sdk/gcloud#download_and_install_the](https://cloud.google.com/sdk/gcloud#download_and_install_the)）'
- en: '**kubectl**: This is the command-line tool used for communicating with a Kubernetes
    cluster through the Kubernetes API ([https://kubernetes.io/docs/reference/kubectl/](https://kubernetes.io/docs/reference/kubectl/))'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubectl**：这是用于通过 Kubernetes API 与 Kubernetes 集群通信的命令行工具（[https://kubernetes.io/docs/reference/kubectl/](https://kubernetes.io/docs/reference/kubectl/)）'
- en: '**minikube**: This is a local Kubernetes distribution used for Kubernetes learning
    and development. To install minikube on your system, you can follow the instructions
    from the official documentation ([https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/))'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**minikube**：这是一个本地 Kubernetes 发行版，用于 Kubernetes 学习和开发。要在系统上安装 minikube，可以按照官方文档中的指示操作（[https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)）'
- en: '`sealed-secrets` installation on Kubernetes ([https://github.com/bitnami-labs/sealed-secrets#kubeseal](https://github.com/bitnami-labs/sealed-secrets#kubeseal))'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sealed-secrets` 在 Kubernetes 上的安装（[https://github.com/bitnami-labs/sealed-secrets#kubeseal](https://github.com/bitnami-labs/sealed-secrets#kubeseal)）'
- en: '**argocd**: This is a command-line utility that simplifies interactions with
    Argo CD ([https://argo-cd.readthedocs.io/en/stable/cli_installation/](https://argo-cd.readthedocs.io/en/stable/cli_installation/))'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**argocd**：这是一个命令行工具，用于简化与 Argo CD 的交互（[https://argo-cd.readthedocs.io/en/stable/cli_installation/](https://argo-cd.readthedocs.io/en/stable/cli_installation/)）'
- en: Real-world examples of how Kubernetes Secrets are used in production environments
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes Secrets 在生产环境中的实际应用示例
- en: So far, we have seen some different approaches to managing Kubernetes Secrets.
    We will proceed and see examples of how Secrets are managed in a production environment.
    We will compare some different approaches, identifying their differences and looking
    at the pros and cons.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一些不同的 Kubernetes Secrets 管理方法。接下来，我们将查看一些在生产环境中如何管理 Secrets 的示例。我们将比较一些不同的方法，识别它们的差异，并分析它们的优缺点。
- en: Qualities of Secrets management in production
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生产环境中密钥管理的特性
- en: 'When it comes to Kubernetes Secrets management in production, regardless of
    the approach taken, certain qualities need to be satisfied. These qualities make
    our production deployment robust and secure. The qualities are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中管理 Kubernetes Secrets 时，无论采取何种方式，都需要满足某些特性。这些特性使我们的生产部署更加可靠和安全。以下是这些特性：
- en: High availability
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高可用性
- en: Disaster recovery
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灾难恢复
- en: Encryption
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密
- en: Auditing
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计
- en: Let us deep dive into each one of them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨每一个方法。
- en: High availability
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高可用性
- en: Kubernetes is highly available; we saw how in [*Chapter 1*](B20970_01.xhtml#_idTextAnchor015),
    *Understanding Kubernetes Secrets Management*. A secret stored in Kubernetes will
    be stored on etcd, and etcd nodes are part of the Kubernetes cluster. If one etcd
    node goes down, the Secrets will still be present on the other etcd nodes. This
    ensures that Kubernetes will continue to operate with all the Secrets functioning.
    Eventually, once the missing etcd node is up, it will resume operations along
    with the other nodes. High availability ensures the robustness of Kubernetes in
    scenarios where a node is lost. Apart from the plain unavailability of a node,
    high availability should also tackle the risk of a data center going down. All
    the nodes of a Kubernetes cluster should not be hosted in the same data center;
    instead, the nodes of the cluster should be spread through different data centers.
    If connectivity to a data center is lost, or if a data center has an issue, the
    nodes hosted on the other data centers will be able to carry over. However, we
    might encounter more extreme scenarios, scenarios where instead of a node or a
    data center becoming unavailable, an entire region becomes disconnected. In those
    cases, being able to perform disaster recovery in another region is crucial.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 高可用；我们在 [*第 1 章*](B20970_01.xhtml#_idTextAnchor015)《*理解 Kubernetes
    Secrets 管理*》中看到过这一点。存储在 Kubernetes 中的一个 Secret 会存储在 etcd 中，而 etcd 节点是 Kubernetes
    集群的一部分。如果一个 etcd 节点出现故障，Secrets 仍然会保留在其他 etcd 节点上。这确保了 Kubernetes 会继续运行并且所有 Secrets
    都能正常工作。最终，一旦丢失的 etcd 节点恢复，它将与其他节点一起恢复操作。高可用性确保了 Kubernetes 在节点丢失的情况下仍能保持稳定运行。除了节点的普通不可用外，高可用性还应解决数据中心宕机的风险。Kubernetes
    集群的所有节点不应托管在同一个数据中心；相反，集群的节点应该分布在不同的数据中心中。如果失去对某个数据中心的连接，或者该数据中心出现问题，托管在其他数据中心的节点将能够继续工作。然而，我们可能会遇到更极端的情况，某些情况下，整个区域会变得无法连接，而不仅仅是某个节点或数据中心不可用。在这种情况下，能够在另一个区域执行灾难恢复变得至关重要。
- en: Disaster recovery
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 灾难恢复
- en: In [*Chapter 6*](B20970_06.xhtml#_idTextAnchor117), *Disaster Recovery and Backups*,
    we focused extensively on disaster recovery. When it comes to Secrets, it is crucial
    to have a disaster recovery plan in place. From a Secrets management perspective,
    the disaster recovery scenarios will vary on the decisions taken on managing Secrets.
    Secrets can be managed either on Kubernetes etcd or through external secret storage.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 6 章*](B20970_06.xhtml#_idTextAnchor117)《*灾难恢复与备份*》中，我们广泛讨论了灾难恢复。对于 Secrets，制定灾难恢复计划至关重要。从
    Secrets 管理的角度来看，灾难恢复场景将根据管理 Secrets 的决策有所不同。Secrets 可以通过 Kubernetes etcd 或外部 Secret
    存储进行管理。
- en: Secret storage using etcd
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 etcd 的 Secret 存储
- en: The approach taken to implement disaster recovery on a Kubernetes cluster will
    heavily influence the disaster recovery of Secrets that are managed through etcd.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 集群中实施灾难恢复的方法将极大地影响通过 etcd 管理的 Secrets 的灾难恢复。
- en: 'We have the following options:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下几个选项：
- en: Cluster created on demand in another region
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一个区域按需创建的集群
- en: Standby Kubernetes cluster in another region
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一个区域的备用 Kubernetes 集群
- en: Active-active Kubernetes clusters in multiple regions
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个区域的主动-主动 Kubernetes 集群
- en: The option of creating a cluster on demand in another region can be achieved
    with internal tooling such as keeping backups of etcd or by using tools such as
    Velero. In the case of a cloud provider, for example, GCP, you can duplicate a
    Kubernetes cluster with the click of a button.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过内部工具实现的选项，例如备份 etcd，或者使用如 Velero 之类的工具，可以在另一个区域按需创建集群。以云服务提供商 GCP 为例，您可以通过点击按钮复制
    Kubernetes 集群。
- en: In maintaining a standby cluster or active-active clusters, many of the choices
    are heavily dependent on how you perform deployments on Kubernetes. CI/CD is crucial.
    For example, for your standby cluster to be functional, your CI/CD job might need
    to push Secrets to two clusters. You might also follow the GitOps model. When
    it comes to the GitOps model, you might utilize a tool such as Argo CD. In those
    cases, the standby Kubernetes cluster can be updated by pulling the changes from
    a Git repository. This way, the Secrets are applied to the available clusters
    without the need to push the secret changes directly to the cluster.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在维护备用集群或主动-主动集群时，许多选择严重依赖于您在 Kubernetes 上执行部署的方式。CI/CD 非常重要。例如，对于您的备用集群能够正常运行，您的
    CI/CD 作业可能需要将 Secrets 推送到两个集群。您还可以采用 GitOps 模型。在 GitOps 模型中，您可以利用诸如 Argo CD 的工具。在这些情况下，备用
    Kubernetes 集群可以通过从 Git 存储库拉取更改来更新。这样，Secrets 就可以应用到可用集群上，而不需要直接将秘密更改推送到集群中。
- en: When it comes to Kubernetes and disaster recovery, there are various options,
    as we saw in [*Chapter 6*](B20970_06.xhtml#_idTextAnchor117), *Disaster Recovery*
    *and Backups*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 Kubernetes 和灾难恢复时，有各种选项，正如我们在[*第 6 章*](B20970_06.xhtml#_idTextAnchor117)，*灾难恢复和备份*
    中所看到的那样。
- en: External secret store
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 外部秘密存储
- en: With an external secret store, disaster recovery is managed by the secret store
    itself and its features. All the cloud-based Secrets store options we examined
    supported either cross-regional availability or the option for cross-region replication.
    Azure Vault and Google Cloud Secret Manager provide cross-region availability,
    and AWS Secrets Manager provides cross-region replication. In HashiCorp Vault
    Enterprise, there is also the option of cross-region replication.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过外部秘密存储，灾难恢复由秘密存储本身及其功能管理。我们检查的所有基于云的 Secrets 存储选项都支持跨区域可用性或跨区域复制选项。Azure Vault
    和 Google Cloud Secret Manager 提供跨区域可用性，AWS Secrets Manager 提供跨区域复制。在 HashiCorp
    Vault Enterprise 中，还有跨区域复制选项。
- en: Encryption
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密
- en: Encryption is crucial. We had a deep dive into encryption in [*Chapter 3*](B20970_03.xhtml#_idTextAnchor064),
    *Encrypting Secrets the Kubernetes-Native Way*. On every Kubernetes installation,
    it is crucial to follow encryption at rest, considering disk storage as well as
    the encryption of etcd Secrets.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 加密至关重要。我们深入研究了[*第 3 章*](B20970_03.xhtml#_idTextAnchor064)，*以 Kubernetes 本地方式加密
    Secrets*。在每个 Kubernetes 安装中，遵循磁盘存储以及 etcd Secrets 加密的加密是至关重要的。
- en: Auditing
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 审计
- en: We have seen in [*Chapter 5*](B20970_05.xhtml#_idTextAnchor092), *Security,
    Auditing, and Compliance*, why auditing matters and why it is needed in the first
    place. On every cloud provider we have worked with, the option of auditing was
    always present. Auditing is also available on HashiCorp Vault and CyberArk Conjur.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第 5 章*](B20970_05.xhtml#_idTextAnchor092)，*安全、审计和合规性* 中看到了为什么审计很重要以及为什么首先需要它。在我们所使用的每个云提供商中，审计选项始终存在。HashiCorp
    Vault 和 CyberArk Conjur 也提供了审计功能。
- en: We focused on and had an overview of the qualities that need to be in place
    when it comes to Secrets management in production. Next, we shall focus on how
    Secrets management and CI/CD come together and the risks to avoid.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重点关注和概述了在生产环境中需要放置的 Secrets 管理的特性。接下来，我们将关注 Secrets 管理与 CI/CD 的结合以及需要避免的风险。
- en: Secrets management from a CI/CD perspective
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 CI/CD 视角看 Secrets 管理
- en: 'Managing Secrets in CI/CD pipelines is an interesting concept. In previous
    chapters, we focused primarily on the Git-based concept of Secrets management
    and the secret-storage-based Secrets management. We have not mentioned manual
    secret persistence to Kubernetes. There are many reasons for that:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CI/CD 流水线中管理 Secrets 是一个有趣的概念。在之前的章节中，我们主要关注了基于 Git 的 Secrets 管理概念和基于 secret-storage
    的 Secrets 管理。我们没有提到手动持久化 Secrets 到 Kubernetes。其中有许多原因：
- en: You lose track of your Kubernetes deployment needs
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您会失去对 Kubernetes 部署需求的跟踪
- en: Dependencies are not visible
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖关系不可见
- en: No clear depiction of what is applied
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有清晰的应用描述
- en: Not compatible with infrastructure as code
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与基础设施即代码不兼容
- en: Next, we will focus on interacting with Secrets on our CI/CD pipelines.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重点关注在我们的 CI/CD 流水线上与 Secrets 交互。
- en: Integrating Secrets management into your CI/CD process
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Secrets 管理集成到您的 CI/CD 流程中
- en: Your CI/CD strategy will differ significantly depending on the approach taken
    for managing Secrets.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据管理 Secrets 所采用的方法，您的 CI/CD 策略将有显著差异。
- en: Git-based Secrets management
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于 Git 的 Secrets 管理
- en: By managing Secrets through a Git-based approach, CI/CD should be able to interact
    with the components involved.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过基于 Git 的方法管理机密，CI/CD 应该能够与涉及的组件进行交互。
- en: Depending on the encryption mechanism, you need to have credentials configured
    on the CI/CD account that will be able to interact with the KMS system that encrypts
    the credentials or a Kubernetes service account that can decrypt the Secrets.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据加密机制的不同，您需要在 CI/CD 账户中配置凭证，使其能够与加密凭证的 KMS 系统进行交互，或配置一个可以解密机密的 Kubernetes 服务账户。
- en: Let us examine the case of sealed Secrets, a concept we learned about in [*Chapter
    12*](B20970_12.xhtml#_idTextAnchor234), *Integrating with Secret Stores*, where
    a fine-grained Kubernetes role and a Kubernetes service account should be created.
    The reason is that the sealing operation happens inside the cluster. The sealed
    secret can then be stored on Git. To retrieve the actual value, you need to decrypt
    it through the cluster. The sealing operation can also happen offline; in this
    case, more steps are needed to make sure that the encryption key is securely handled.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看封印机密的案例，这个概念我们在 [*第 12 章*](B20970_12.xhtml#_idTextAnchor234)，《与机密存储集成》中了解过，其中需要创建一个细粒度的
    Kubernetes 角色和 Kubernetes 服务账户。原因在于封印操作发生在集群内部。封印后的机密可以存储在 Git 中。要检索实际的值，需要通过集群进行解密。封印操作也可以离线进行；在这种情况下，需要更多步骤来确保加密密钥的安全处理。
- en: External secret store and Workload Identity
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部机密存储和 Workload Identity
- en: So far, we have worked with Microsoft Azure Key Vault, Google Cloud Secret Manager,
    and AWS Secrets Manager. All of them support the integration of Workload Identity
    and GitHub Actions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了 Microsoft Azure Key Vault、Google Cloud Secret Manager 和 AWS Secrets
    Manager。它们都支持 Workload Identity 与 GitHub Actions 的集成。
- en: The traditional way to interact with a cloud component on a CI/CD pipeline was
    by attaching the credentials of the cloud provider on the CI/CD job. This practice
    increases security risks. The credentials, such as a service account or a key
    secret, are static credentials; if compromised and without a proper logging or
    audit system, these could be used for an extended period, creating a silent breach.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CI/CD 流水线中与云组件交互的传统方式是将云提供商的凭证附加到 CI/CD 作业中。这种做法增加了安全风险。凭证，如服务账户或密钥机密，都是静态凭证；如果被泄露且没有适当的日志记录或审计系统，这些凭证可能会被长期使用，导致潜在的安全漏洞。
- en: Workload Identity is a more secure solution. With Workload Identity, we can
    assign to a CI/CD job fine-grained permissions toward a cloud component. Workload
    Identity is not supported by all CI/CD providers out there; however, there is
    a strong adoption of the Workload Identity approach and it is expected to become
    the norm.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Workload Identity 是一种更安全的解决方案。通过 Workload Identity，我们可以为 CI/CD 作业分配精细化的权限，以便访问云组件。并不是所有的
    CI/CD 提供商都支持 Workload Identity；然而，Workload Identity 方法的采用正在逐步增加，并预计将成为标准。
- en: By using Workload Identity, a CI/CD job can have temporary credentials to interact
    with a cloud provider’s secret store. Since we have now had an introduction to
    Workload Identity, we will proceed and see it in action using GCP.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Workload Identity，CI/CD 作业可以获得临时凭证与云提供商的机密存储进行交互。既然我们已经对 Workload Identity
    有了初步了解，接下来我们将通过 GCP 实际演示。
- en: GitHub Actions and GCP Workload Identity integration
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GitHub Actions 和 GCP Workload Identity 集成
- en: One of the issues with CI/CD jobs interacting with cloud components is the permissions.
    Traditionally, this is resolved by uploading credentials to the CI/CD job variables
    with all the risks this solution can introduce, which we will cover later in this
    chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 作业与云组件交互时的一个问题是权限问题。传统上，这个问题是通过将凭证上传到 CI/CD 作业变量来解决的，但这种解决方案带来了很多风险，我们将在本章后面讨论这些风险。
- en: GitHub Action supports **OpenID Connect** (**OIDC**). Through OIDC, it is possible
    to authenticate between cloud providers and GitHub, using short-lived tokens.
    This way, we avoid the need for storing long-lived cloud Secrets in GitHub.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 支持 **OpenID Connect** (**OIDC**) 。通过 OIDC，可以使用短期令牌在云提供商和 GitHub
    之间进行身份验证。这样，我们就避免了在 GitHub 中存储长期有效的云机密。
- en: In [*Chapter 10*](B20970_10.xhtml#_idTextAnchor193), *Exploring Cloud Secret
    Store on GCP*, we integrated a GKE cluster with GCP’s Secret Manager, so we are
    already familiar with GCP as a platform. Imagine the scenario of our CI/CD jobs
    needing to interact with Secret Manager, which is integrated with GKE.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 10 章*](B20970_10.xhtml#_idTextAnchor193)，《探索 GCP 上的云机密存储》中，我们将 GKE 集群与
    GCP 的 Secret Manager 集成，因此我们已经对 GCP 这一平台有所了解。设想一下我们的 CI/CD 作业需要与已集成 GKE 的 Secret
    Manager 进行交互的场景。
- en: Without the support of OIDC, we would have to store a GCP service account key
    to the CI/CD job. Thanks to OIDC, we can set up the authentication from GitHub
    to GCP using Workload Identity Federation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 OIDC 的支持，我们将不得不将 GCP 服务帐户密钥存储在 CI/CD 作业中。得益于 OIDC，我们可以通过工作负载身份联合设置 GitHub
    与 GCP 之间的身份验证。
- en: 'First, we will have to configure an identity pool:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要配置身份池：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we include GitHub as an identity provider:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 GitHub 添加为身份提供者：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The identity pool is provisioned, and GitHub is one of the identity providers.
    The next step is to bind a service account on GCP to a GitHub repository:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 身份池已配置，GitHub 是其中一个身份提供者。接下来的步骤是将 GCP 上的服务帐户与 GitHub 仓库绑定：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Through this configuration, we allow authentications from the Workload Identity
    provider to impersonate the desired service account. Also, note that when we specified
    the Workload Identity pool as a member, we specified the GitHub repository where
    we shall host the actions that would require GCP access.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此配置，我们允许来自工作负载身份提供者的身份验证来模拟所需的服务帐户。此外，注意当我们指定工作负载身份池为成员时，我们也指定了将托管需要 GCP 访问的操作的
    GitHub 仓库。
- en: 'We are set up to proceed with the GitHub job configuration:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已准备好继续进行 GitHub 作业配置：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On the GitHub Actions console, we should be able to see the job successfully
    creating a token and authenticate upon the Workload Identity instance created,
    as well as receiving a secret from Secret Manager. Obviously, this way of authentication
    can be applied even when we want to interact with GCP.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub Actions 控制台上，我们应该能够看到作业成功创建令牌并对创建的工作负载身份实例进行身份验证，同时从 Secret Manager
    获取密钥。显然，这种身份验证方式也可以应用于我们与 GCP 交互时。
- en: Take note that the preceding steps print the secret on purpose since they serve
    as an example of how GitHub Actions and GCP Workload Identity integrate. You should
    not print any retrieved Secrets on the CI/CD console, as we shall mention later
    in the chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前述步骤故意打印了密钥，因为它们作为 GitHub Actions 与 GCP 工作负载身份集成的示例。你不应该在 CI/CD 控制台上打印任何检索到的密钥，如本章稍后提到的。
- en: In a nutshell, by utilizing Workload Identity, we can avoid storing long-lived
    credentials in a CI/CD job configuration. Also, we establish seamless integration
    with the cloud provider and make it easier to interact with cloud provider components
    such as Secret Manager on GCP.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，通过利用工作负载身份，我们可以避免在 CI/CD 作业配置中存储长期有效的凭证。此外，我们与云提供商之间建立了无缝的集成，使得与云提供商组件（如
    GCP 上的 Secret Manager）的交互更加简便。
- en: Vault as an external secret store
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vault 作为外部秘密存储
- en: As we have seen from the integration of Vault with Kubernetes, a token is needed
    to be able to interact with Vault. When we use a long-lived token, we face the
    risk of compromise. For this reason, instead of using a Vault token directly,
    we can proceed with the method of JWT with GitHub OIDC tokens.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 Vault 与 Kubernetes 集成中所看到的，交互 Vault 需要一个令牌。当我们使用长期有效的令牌时，可能会面临泄露的风险。为此，我们可以使用
    GitHub OIDC 令牌来替代直接使用 Vault 令牌，采用 JWT 方法。
- en: Each GitHub action receives an auto-generated OIDC token. We can configure trust
    between a GitHub Actions workflow and Vault using the OIDC provider of GitHub.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 GitHub Action 都会收到一个自动生成的 OIDC 令牌。我们可以使用 GitHub 的 OIDC 提供者来配置 GitHub Actions
    工作流与 Vault 之间的信任。
- en: A similar concept was Kubernetes authentication. We were taking the JWTs, originating
    from a Kubernetes service account, and using them to retrieve Secrets from Vault.
    Since Vault had already established trust with our Kubernetes cluster, it could
    validate the Secrets and return the credentials.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类似的概念是 Kubernetes 身份验证。我们使用来自 Kubernetes 服务帐户的 JWT 来检索 Vault 中的密钥。由于 Vault
    已经与我们的 Kubernetes 集群建立了信任，它可以验证密钥并返回凭证。
- en: A similar process happens with the GitHub OIDC provider and the HashiCorp integration.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与 GitHub OIDC 提供者和 HashiCorp 集成时也发生了类似的过程。
- en: Executing CI/CD pipelines on Kubernetes
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上执行 CI/CD 管道
- en: Another way to securely integrate CI/CD pipelines with a Kubernetes secret store
    is to run the pipeline inside Kubernetes. The CI/CD jobs run inside Kubernetes,
    so the credentials and other Kubernetes components are not exposed outside of
    our premises.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种安全地将 CI/CD 管道与 Kubernetes 秘密存储集成的方法是将管道运行在 Kubernetes 内部。CI/CD 作业运行在 Kubernetes
    内部，因此凭证和其他 Kubernetes 组件不会暴露到我们公司的外部。
- en: Many major cloud providers, such as GitHub Actions and GitLab, provide the option
    to manage CI/CD pipeline orchestration on GitHub and GitLab but execute the CI/CD
    jobs inside Kubernetes. There are numerous benefits to that approach.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 许多主要的云服务提供商，如 GitHub Actions 和 GitLab，提供了在 GitHub 和 GitLab 上管理 CI/CD 管道编排的选项，但将
    CI/CD 作业执行在 Kubernetes 内。采用这种方法有许多好处。
- en: By running a CI/CD job on-premises, you make it possible for the CI/CD job to
    interact with resources that reside only on-premises. For example, supposing a
    HashiCorp Vault installation is in a private network that is not publicly accessible.
    To integrate the Vault instance with an external CI/CD provider, we must make
    the Vault instance publicly accessible, which increases our security concerns.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在本地运行 CI/CD 作业，你使得 CI/CD 作业能够与仅存在于本地的资源进行交互。例如，假设一个 HashiCorp Vault 安装在一个私有网络中，这个网络是不可公开访问的。为了将
    Vault 实例与外部 CI/CD 提供商集成，我们必须使 Vault 实例可以公开访问，这就增加了我们的安全顾虑。
- en: By running a pipeline on-premises, that is not the case. Running CI/CD pipelines
    inside Kubernetes can harden the security of our CI/CD pipelines. Tekton is a
    very popular open source framework that enables us to create CI/CD systems in
    a Kubernetes installation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在本地运行管道，情况就不同了。在 Kubernetes 内运行 CI/CD 管道可以增强我们 CI/CD 管道的安全性。Tekton 是一个非常流行的开源框架，它使我们能够在
    Kubernetes 环境中创建 CI/CD 系统。
- en: Moving on, there is another approach to continuous delivery, which is through
    the GitOps model. Let us see how the GitOps model works by running an example
    with Argo CD.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来了解一种持续交付的方法，那就是通过 GitOps 模型。让我们通过使用 Argo CD 运行一个示例来看看 GitOps 模型是如何工作的。
- en: GitOps
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GitOps
- en: GitOps is a set of practices that is used to manage infrastructure and application
    configurations via a Git-centric approach. Argo CD follows the GitOps model. It
    monitors a Git repository that we specify and ensures that the application is
    in the desired state. Argo CD is a Kubernetes controller that monitors the running
    infrastructure and compares it with the infrastructure specified in the Git repository.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps 是一套用于通过 Git 集中式方法管理基础设施和应用配置的实践。Argo CD 遵循 GitOps 模型。它监控我们指定的 Git 仓库，并确保应用程序处于所需的状态。Argo
    CD 是一个 Kubernetes 控制器，监控运行中的基础设施，并将其与 Git 仓库中指定的基础设施进行比较。
- en: 'We can understand the model by doing a simple Argo CD installation:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过做一个简单的 Argo CD 安装来理解这个模型：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can now port forward so that we can interact with Argo CD without the need
    to expose the service through an ingress:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以进行端口转发，以便与 Argo CD 交互，而无需通过入口暴露服务：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In another session, we can retrieve the default admin autogenerated password,
    in order to log in to `argocd`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个会话中，我们可以检索默认的管理员自动生成的密码，以便登录到 `argocd`：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now create an application; we shall use the examples in the Argo CD
    repository ([https://github.com/argoproj/argocd-example-apps](https://github.com/argoproj/argocd-example-apps)):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个应用程序；我们将使用 Argo CD 仓库中的示例（[https://github.com/argoproj/argocd-example-apps](https://github.com/argoproj/argocd-example-apps)）：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: An application is now running based on a deployment file in another Git repository.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序现在基于另一个 Git 仓库中的部署文件运行。
- en: 'Let us examine GitOps and its compatibility with the Secrets management methods
    we have seen so far:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 GitOps 及其与我们到目前为止看到的 Secrets 管理方法的兼容性：
- en: Sealed Secrets can be supported without extra effort since the sealed Secrets
    controller will be able to apply any new Secrets distributed through Git.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sealed Secrets 可以得到支持，而无需额外的努力，因为 Sealed Secrets 控制器能够应用任何通过 Git 分发的新 Secrets。
- en: Solutions driven by external secret storage are not affected since the secret
    information resides on another component.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由外部秘密存储驱动的解决方案不受影响，因为秘密信息存储在另一个组件中。
- en: Helm Secrets support depends on the tool used for GitOps. Argo CD can support
    Helm Secrets; however, it requires modifications to facilitate the encryption
    and decryption of Secrets that are distributed through Helm charts.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm Secrets 支持取决于用于 GitOps 的工具。Argo CD 可以支持 Helm Secrets；然而，它需要进行修改以便支持通过 Helm
    charts 分发的 Secrets 的加密和解密。
- en: Now that we have had an overview of Secrets management and CI/CD, let us proceed
    with the risks that come with the integration of CI/CD and Secrets.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 Secrets 管理和 CI/CD 有了概览，让我们继续讨论将 CI/CD 与 Secrets 集成所带来的风险。
- en: Risks to avoid with Secrets in CI/CD pipelines
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 CI/CD 管道中使用 Secrets 时需要避免的风险
- en: A CI/CD pipeline can be subject to various risks when it comes to Secrets. It
    is quite easy to misconfigure a CI/CD pipeline, which can lead to problems such
    as leaking sensitive information, running overprivileged pipelines, and supply
    chain attacks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到秘密时，CI/CD 流水线可能面临各种风险。配置错误的 CI/CD 流水线很容易导致泄露敏感信息、运行特权过高的流水线和供应链攻击等问题。
- en: Leaking Secrets in a pipeline
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在流水线中泄露秘密
- en: Leaking Secrets in a pipeline is easier to accidentally do than you’d think.
    CI/CD pipelines by default treat secret information differently from other configuration
    variables. Take, for example, a GitHub Actions workflow. If we try to print a
    secret in a job, the secret will be masked, and thus the information will not
    be leaked. This is not enough. By changing the pipeline’s configuration, we can
    persist the secret value in a file. This makes it possible to print the file and
    retrieve the secret information. To make matters worse, CI/CD pipelines keep the
    job history and logs. In certain cases, the history cannot be erased or will be
    erased after some time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在流水线中泄露秘密比你想象的要容易得多。默认情况下，CI/CD 流水线会与其他配置变量区分对待秘密信息。例如，GitHub Actions 工作流。如果我们尝试在作业中打印一个秘密，秘密会被掩码，因此信息不会被泄露。这还不够。通过更改流水线的配置，我们可以将秘密值持久化到文件中。这样就可以打印文件并检索秘密信息。更糟糕的是，CI/CD
    流水线会保留作业历史记录和日志。在某些情况下，历史记录无法被删除，或者会在一段时间后删除。
- en: Another way that a secret can be leaked is by making it part of the artifacts
    generated by the CI/CD pipeline. In this situation, the Secrets can be downloaded
    through the CI/CD UI.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种泄露秘密的方式是将其作为 CI/CD 流水线生成的工件的一部分。在这种情况下，秘密可以通过 CI/CD 用户界面下载。
- en: These examples of misconfigured pipelines can lead to security incidents. The
    secret information has been leaked and so it needs to be rotated.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置错误的流水线示例可能导致安全事件。秘密信息已经泄露，因此需要进行轮换。
- en: Production Secrets
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生产秘密
- en: Another risk is using the same Secrets used in a production workload with a
    CI/CD pipeline. A secret in a production environment is used to perform different
    operations from the ones that take place in a CI/CD environment. Having a production
    secret on a CI/CD environment can lead to code that might run with more privileges
    than the ones needed if the CI/CD is misconfigured, and its usage might affect
    an actual production system. In the case of a secret leak, the risk impact is
    much greater when using a dedicated secret for a CI/CD job.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个风险是将生产工作负载中使用的相同秘密与 CI/CD 流水线一起使用。生产环境中的秘密用于执行与 CI/CD 环境中的操作不同的操作。在 CI/CD
    环境中使用生产秘密可能导致代码以比所需更高的权限运行，如果 CI/CD 配置错误，其使用可能会影响实际的生产系统。在秘密泄露的情况下，使用专门的秘密进行 CI/CD
    作业的风险影响会更大。
- en: Malevolent contributions
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恶意的贡献
- en: CI/CD can be a target for attackers trying to steal Secrets. A pull request
    on a repository that triggers a pipeline gives a variety of options for the pull
    request author to retrieve the secret value. For these cases, it is essential
    to protect the CI/CD jobs that interact with sensitive information. Branches should
    be protected, and certain pipelines should be segregated to enable fine-grained
    permissions and prevent access from individuals who might try to retrieve secret
    information through CI/CD jobs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 可能成为攻击者窃取秘密的目标。触发流水线的仓库上的拉取请求为拉取请求作者提供了多种选项来获取秘密值。在这些情况下，保护与敏感信息交互的 CI/CD
    作业至关重要。应该保护分支，并应将某些流水线进行隔离，以便实现细粒度的权限控制，并防止那些可能通过 CI/CD 作业试图检索秘密信息的人员访问。
- en: In open source projects, contributions might have the purpose of stealing Secrets
    or being part of a supply chain attack attempt. We can use GitHub Actions as an
    example, where workflows from forks do not have access to Secrets. Also, to prevent
    any abusive behavior on pull requests, GitHub Actions gives the option to approve
    workflow runs from public forks ([https://docs.github.com/en/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks](https://docs.github.com/en/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在开源项目中，贡献可能旨在窃取秘密或成为供应链攻击尝试的一部分。我们以 GitHub Actions 为例，其中来自 Fork 的工作流无法访问秘密。此外，为了防止拉取请求中的滥用行为，GitHub
    Actions 提供了从公共 Fork 批准工作流运行的选项（[https://docs.github.com/en/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks](https://docs.github.com/en/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks)）。
- en: Untrusted software
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不受信的软件
- en: A pipeline can be as secure as the software that is used to implement it. Throughout
    the internet, there is a wide variety of CI/CD software utilities, ranging from
    libraries to Docker containers. These software components can be outdated, exposing
    the pipeline to security vulnerabilities, or some of them might have been compromised
    by an attacker with the goal of a supply chain attack.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个管道的安全性取决于用于实现它的软件。在互联网上，有各种各样的 CI/CD 软件工具，从库到 Docker 容器不等。这些软件组件可能是过时的，从而暴露管道于安全漏洞，或者其中一些可能已被攻击者攻破，目标是供应链攻击。
- en: Take, for example, a Jenkins plugin or a GitHub workflow action that reads the
    Secrets from a pipeline and sends them to an external location. The same can happen
    with any utility that is not trusted or has even been compromised.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个 Jenkins 插件或 GitHub 工作流操作为例，它从管道中读取 Secrets 并将其发送到外部位置。任何不可信或甚至已被攻破的工具也可能发生类似情况。
- en: Software should be used only from trusted sources, and its authenticity should
    be verified, for example, using hash-based verification. Also, the software used
    in the pipelines should be the latest software that incorporates the necessary
    security patches.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 只能使用来自可信源的软件，并且应验证其真实性，例如使用基于哈希的验证。同时，管道中使用的软件应为最新版本，并包含必要的安全补丁。
- en: Pipelines with extra privileges
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拥有额外权限的管道
- en: CI/CD is essential for every company that needs to build, test, and release
    software. Since it has a crucial role, it is expected to interact with Secrets
    that might be shared by a Kubernetes installation. Secrets privileges that exceed
    the scope of a CI/CD job can cause serious incidents in the case of a leak or
    misconfiguration.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 对于每个需要构建、测试和发布软件的公司至关重要。由于其关键作用，它通常会与 Kubernetes 安装共享的 Secrets 进行交互。超出
    CI/CD 作业范围的 Secrets 权限，在泄漏或配置错误的情况下，可能会导致严重事件的发生。
- en: Take, for example, a CI/CD job used for testing purposes interacting with an
    external secret storage used by a Kubernetes cluster. Suppose this job deletes
    Secrets from the secret storage, targeting a staging environment. However, the
    permissions assigned to the pipeline are broad enough to enable the deletion of
    Secrets in a production environment. A pipeline misconfiguration can lead to data
    loss or even a production outage.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个用于测试的 CI/CD 作业与 Kubernetes 集群使用的外部密钥存储进行交互为例。假设该作业从密钥存储中删除 Secrets，目标是一个暂存环境。然而，分配给管道的权限足够广泛，允许它删除生产环境中的
    Secrets。管道配置错误可能导致数据丢失，甚至生产环境宕机。
- en: Now that we have had an overview of the risks associated with Secrets and CI/CD
    integration, let us proceed with identifying the best practices.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了与 Secrets 和 CI/CD 集成相关的风险，接下来让我们确定最佳实践。
- en: Best practices for secure CI/CD Secrets management
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全 CI/CD Secrets 管理的最佳实践
- en: 'We had an overview of CI/CD jobs interacting with Kubernetes Secrets. To ensure
    that we are secure, we need to follow certain practices:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们概述了 CI/CD 作业与 Kubernetes Secrets 的交互。为了确保安全，我们需要遵循一些最佳实践：
- en: Do not commit clear text Secrets
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要提交明文的 Secrets
- en: If using tokens, rotate them and make them short-lived
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用令牌，应定期更换令牌并使其具有短生命周期
- en: If an OICD-based integration is possible, use it, as it is more secure
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能，使用基于 OICD 的集成，因为它更加安全
- en: Moving pipelines to Kubernetes on-premises hardens security
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将管道迁移到本地 Kubernetes 环境有助于增强安全性
- en: The principle of least privilege should be followed
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应遵循最小权限原则
- en: Use dedicated Secrets for testing
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用专用的 Secrets 进行测试
- en: Do not use the same Secrets for testing and production
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在测试和生产环境中使用相同的 Secrets
- en: So far, we have focused on the ways to handle Kubernetes Secrets in production
    and the integration of Kubernetes Secrets and CI/CD. Next, we will focus on a
    case study for implementing a Secrets system within an organization.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要关注了如何在生产环境中处理 Kubernetes Secrets，以及 Kubernetes Secrets 与 CI/CD 的集成。接下来，我们将聚焦于一个在组织内实施
    Secrets 管理系统的案例研究。
- en: Lessons learned from real-world deployments
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从实际部署中吸取的教训
- en: Let us now look at how we can interact with Secrets on Kubernetes and what we
    should and should not do when we interact with Secrets on Kubernetes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何与 Kubernetes 上的 Secrets 进行交互，以及在与 Kubernetes 上的 Secrets 交互时，我们应该做什么和不应该做什么。
- en: Case study – Developing Secrets management
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 – 开发 Secrets 管理
- en: As more organizations embrace container orchestration, the following case study
    illustrates the journey toward establishing a robust system for Secrets management
    within an organization.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越多的组织采用容器编排，以下案例研究展示了在组织内部建立强大机密管理系统的过程。
- en: The Keywhiz Secrets management system at Square
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Square 的 Keywhiz 秘密管理系统
- en: Keywhiz is a system that Square developed to keep important digital keys and
    passwords, such as those used to secure websites, safe and in one place. This
    system is beneficial as the organization previously lacked secure methods for
    storing these Secrets. Keywhiz makes sure that only the right parts of Square
    can get to these Secrets when they need to, using secure connections.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Keywhiz 是 Square 开发的一个系统，用于存储重要的数字密钥和密码，例如用于保护网站的密钥，确保它们安全并集中存放。这个系统非常有用，因为组织之前缺乏安全的方法来存储这些机密信息。Keywhiz
    确保只有 Square 的正确部分在需要时才能访问这些机密，并通过安全的连接进行访问。
- en: Deep dive into Keywhiz’s secret system
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入了解 Keywhiz 的机密管理系统
- en: Let us dive deep into Keywhiz to see how Square built the system end to end.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解 Keywhiz，看看 Square 是如何从头到尾构建这个系统的。
- en: Business justification
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 商业正当性
- en: Square built Keywhiz with the idea that important Secrets should be hard to
    reach. They shouldn’t pop up in places where just anyone can see them, such as
    on a developer’s computer or the internet. Only the specific parts of Square that
    need these Secrets should be able to get them. This is especially true for services
    that use secure connections to protect data. Instead of using many steps or other
    services to get to these Secrets, Square’s services can get them directly. Even
    for special cases, such as when they need to use extra secure hardware, Keywhiz
    has a way to handle it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Square 在构建 Keywhiz 时，设想重要的机密信息应该难以访问。它们不应该出现在任何人都能看到的地方，例如开发人员的计算机或互联网上。只有 Square
    中需要这些机密的特定部分才能访问它们。对于使用安全连接保护数据的服务尤为重要。Square 的服务可以直接访问这些机密，而无需使用许多步骤或其他服务。即便是特殊情况，例如需要使用额外安全硬件时，Keywhiz
    也有处理方法。
- en: Keywhiz also focuses on not having too many Secrets scattered around, which
    can be risky. By keeping them all in one system, it’s easier to keep track of
    them and make sure they are safe. Plus, this system lets Square check on the health
    of their digital keys and passwords, for instance, to see whether they are strong
    enough or need to be changed soon.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Keywhiz 还注重避免将过多的机密信息散布在各处，因为这可能带来风险。通过将所有机密信息集中在一个系统中，跟踪它们并确保其安全变得更加容易。此外，这个系统还允许
    Square 检查其数字密钥和密码的健康状况，例如检查它们是否足够强大或是否需要尽快更换。
- en: It’s important for Square to know when and how a secret is used. So, Keywhiz
    keeps a detailed record of every time a secret is accessed. This isn’t something
    you can do if you just drop the Secrets onto servers as files. Although there
    are tools that can help keep an eye on this, they require extra work to set up.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Square 来说，了解机密信息何时以及如何被使用是非常重要的。因此，Keywhiz 会详细记录每次机密被访问的情况。如果仅仅将机密信息存储在服务器上作为文件，是无法做到这一点的。虽然有一些工具可以帮助监控这些信息，但它们需要额外的设置工作。
- en: Keywhiz is made to work with a lot of different services at Square. It has been
    set up to handle a wide range of needs, from securing websites to handling databases.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Keywhiz 是为 Square 的许多不同服务而设计的。它已经被设置为处理各种需求，从保护网站到管理数据库。
- en: The reliability of this system is key. It has to work all the time because Square’s
    services rely on these Secrets to run.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统的可靠性至关重要。它必须始终有效，因为 Square 的服务依赖于这些机密信息来运行。
- en: The system is also designed to be easy to use. If it wasn’t, people might try
    to take shortcuts, which could be less safe.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统还设计得易于使用。如果它不够易用，人们可能会尝试走捷径，这可能会降低安全性。
- en: Finally, Keywhiz separates the process of changing keys from updating software.
    This means that Square can update its security without having to change the whole
    system, which makes things safer and more flexible.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Keywhiz 将密钥更换与软件更新的过程分开。这意味着 Square 可以在不更改整个系统的情况下更新其安全性，从而使系统更安全且更灵活。
- en: Categorizing and centralizing the store Secrets
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分类并集中存储机密信息
- en: Square’s Keywhiz system takes the security of its digital Secrets seriously.
    It begins by organizing these Secrets into clear categories. This isn’t just about
    keeping things tidy—it’s about knowing exactly which part of Square’s system needs
    which Secrets to operate. From there, all Secrets are kept in one central place.
    This means they’re not scattered across different spots where they could be forgotten
    or, worse, fall into the wrong hands.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Square 的 Keywhiz 系统非常重视其数字机密的安全性。它首先将这些机密组织成明确的类别。这不仅仅是为了保持整洁——更重要的是，知道 Square
    系统中的哪个部分需要哪些机密来操作。从此，所有机密都保存在一个中心位置。这意味着它们不会分散在不同的位置，以至于可能被遗忘，或者更糟糕的是，落入不当之手。
- en: But what makes Keywhiz stand out is how it locks up these Secrets. Before a
    secret is saved in Square’s databases, it gets wrapped up in a layer of encryption—like
    putting a letter into a safe that only certain people can open. This involves
    a specific type of encryption known as **AES-GCM** ([https://en.wikipedia.org/wiki/Galois/Counter_Mode](https://en.wikipedia.org/wiki/Galois/Counter_Mode)).
    It’s recommended by the **National Institute of Standards and Technology** (**NIST**)
    in their Special Publication 800-38D as a preferred method for block cipher ([https://en.wikipedia.org/wiki/Block_cipher](https://en.wikipedia.org/wiki/Block_cipher))
    modes of operation, focusing on **Galois/Counter Mode** (**GCM**) and **Galois
    Message Authentication Code** (**GMAC**). Each secret gets its own unique encryption
    key, created using a method known as **HKDF** ([https://en.wikipedia.org/wiki/HKDF](https://en.wikipedia.org/wiki/HKDF)),
    a simple **key derivation function** (**KDF**) based on the HMAC message authentication
    code, which is a way to make sure that even if one key is discovered, the others
    remain safe. Square uses hardware security modules to contain derivation keys.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Keywhiz 的亮点在于它如何锁定这些机密。在机密被保存在 Square 的数据库中之前，它会被加密层包裹——就像把一封信放入一个只有特定人员才能打开的保险箱。这涉及一种特定类型的加密，称为
    **AES-GCM** （[https://en.wikipedia.org/wiki/Galois/Counter_Mode](https://en.wikipedia.org/wiki/Galois/Counter_Mode)）。它被
    **国家标准与技术研究所** （**NIST**）在其《特别出版物 800-38D》中推荐为块密码（[https://en.wikipedia.org/wiki/Block_cipher](https://en.wikipedia.org/wiki/Block_cipher)）操作模式的首选方法，重点关注
    **Galois/Counter Mode** （**GCM**）和 **Galois 消息认证码** （**GMAC**）。每个机密都有自己独特的加密密钥，该密钥通过一种叫做
    **HKDF** （[https://en.wikipedia.org/wiki/HKDF](https://en.wikipedia.org/wiki/HKDF)）的方法创建，HKDF
    是一种基于 HMAC 消息认证码的简单 **密钥派生函数**（**KDF**），它确保即使发现了一个密钥，其他密钥依然安全。Square 使用硬件安全模块来存储派生密钥。
- en: 'Now, when it comes to delivering these Secrets, Keywhiz makes sure that only
    the right parts of Square’s system, which they call *clients*, can get to them.
    The structure of access control revolves around three key elements: clients, groups,
    and Secrets. A “client” refers to any certificate that gains access to Secrets.
    These clients can belong to multiple groups, which are collections of clients.
    For a client to access a particular secret, the secret must be associated with
    at least one of the groups to which the client belongs. Typically, Keywhiz organizes
    this by creating three main types of groups: one for each service on a specific
    server, one for each distinct service, and a universal group that includes all
    clients.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当涉及到传递这些机密时，Keywhiz 确保只有 Square 系统中的正确部分，即它们称之为 *客户端*，可以访问这些机密。访问控制的结构围绕三个关键元素：客户端、组和机密。“客户端”是指任何能够访问机密的证书。这些客户端可以属于多个组，组是客户端的集合。为了使客户端能够访问特定的机密，该机密必须与客户端所属的至少一个组相关联。通常，Keywhiz
    通过创建三种主要类型的组来组织这一点：每个特定服务器上的每个服务一个组，每个独立服务一个组，以及包含所有客户端的通用组。
- en: Before, people tried other ways to keep Secrets safe, such as mixing them into
    the code where programs are written or manually adding them to servers. But these
    ways are risky—the Secrets can accidentally get shared with the world or get lost.
    Even trying to keep Secrets safe using systems that manage server settings isn’t
    ideal because those systems are meant to share their information across the company,
    which is not what you want for your Secrets.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，人们尝试过其他方式来保护机密的安全，比如将其混入程序代码中，或手动添加到服务器中。但这些方式很有风险——机密可能不小心与外界共享，或者丢失。即使试图使用管理服务器设置的系统来保护机密也并不理想，因为这些系统的目的是在公司内部共享信息，这显然不是你想要的机密保护方式。
- en: PKI as a source of the truth for authentication
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PKI 作为认证的真理来源
- en: '**Public key infrastructure** (**PKI**) is central to Square’s authentication
    process. It’s like a verification system that ensures that only the right parts
    of Square’s network can access the Secrets they need. To establish this trust,
    Square uses mTLS and X509 certificates, which are digital proofs of identity for
    services. Square simplifies this task with **certstrap**, a straightforward certificate
    management tool. This tool helps Square create its own certificate authorities,
    which you can think of as digital ID offices. With certstrap, Square can issue
    these digital IDs to its services, ensuring each one is recognized and trusted
    within its network.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**公钥基础设施** (**PKI**) 是 Square 身份验证过程的核心。它就像一个验证系统，确保只有 Square 网络中的正确部分可以访问所需的秘密信息。为了建立这种信任，Square
    使用 mTLS 和 X509 证书，后者是服务的数字身份验证凭证。Square 使用 **certstrap** 简化了这一任务，这是一个简单的证书管理工具。这个工具帮助
    Square 创建自己的证书颁发机构，可以将其视为数字身份证明机构。通过 certstrap，Square 可以向其服务发放这些数字身份证，确保每个服务在其网络中得到识别和信任。'
- en: certstrap allows Square to avoid the complexities of traditional tools such
    as OpenSSL. It enables Square to create a chain of trust where each service’s
    identity is verified and secured. This verification is crucial for Square, as
    it keeps communication between services secure, ensuring that Secrets are only
    accessed by authorized entities within the company.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: certstrap 使 Square 避免了传统工具（如 OpenSSL）的复杂性。它使 Square 能够创建一个信任链，其中每个服务的身份都得到了验证和保护。这种验证对
    Square 至关重要，因为它保持了服务之间通信的安全，确保只有公司内部的授权实体可以访问秘密信息。
- en: Authorization data model
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 授权数据模型
- en: 'In Square’s Keywhiz system, authorization—deciding who gets access to what—is
    a structured process. Here’s how Square has set it up:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Square 的 Keywhiz 系统中，授权—决定谁可以访问什么—是一个结构化的过程。以下是 Square 设置的方法：
- en: Clients are parts of Square’s systems, such as a service or an application,
    that need access to Secrets to work properly. They prove who they are with something
    called a client certificate. It’s like an ID card for systems.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端是 Square 系统的组成部分，例如需要访问秘密信息以正常工作的服务或应用程序。它们通过所谓的客户端证书来证明自己的身份，就像系统的身份证。
- en: Secrets are the sensitive bits of information that clients need to do their
    jobs, such as configuration files or passwords. Each secret has a unique name
    so there are no mixups, and they can’t be changed once they’re set. However, Square
    can keep multiple versions of a secret if updates are needed.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密信息是客户端执行任务所需的敏感数据，例如配置文件或密码。每个秘密信息都有一个唯一的名称，避免混淆，并且一旦设置，就无法更改。然而，如果需要更新，Square
    可以保留一个秘密的多个版本。
- en: Groups act as a meeting point for clients and Secrets. Think of groups as tags
    or labels. Square labels the clients and the Secrets with these group tags. When
    a client and a secret have the same group tag, the client can see and use the
    secret. It’s Square’s way of organizing which parts of their system can access
    which Secrets.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组作为客户端和秘密信息的交汇点。可以将组视为标签或标记。Square 用这些组标签标记客户端和秘密信息。当客户端和秘密信息拥有相同的组标签时，客户端就可以看到并使用该秘密信息。这是
    Square 组织系统中哪些部分可以访问哪些秘密信息的方式。
- en: Users are the people who manage Keywhiz at Square. They’re the ones setting
    up the system and deciding which clients and Secrets get which group tags. They
    log in to Keywhiz with secure methods, and after they’re in, they need a special
    code from Keywhiz to keep doing their work securely.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是管理 Square Keywhiz 的人员。是他们设置系统并决定哪些客户端和秘密信息属于哪些组标签。他们通过安全的方法登录到 Keywhiz，并在登录后需要一个来自
    Keywhiz 的特殊代码，以保持工作安全地继续进行。
- en: Square’s Keywhiz manages access through a structured authorization model of
    clients, Secrets, groups, and user management, maintaining secure and orderly
    permissions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Square 的 Keywhiz 通过结构化的授权模型管理访问权限，该模型涵盖客户端、秘密信息、组和用户管理，确保权限的安全与有序。
- en: Secrets distribution
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 秘密分发
- en: Square also maintains a Keywhiz client implementation called **Keysync**. Keysync
    is a program that connects to Square’s Keywhiz server securely and asks for the
    Secrets it needs to keep Square’s services running. It uses something called **mTLS**—a
    way of communicating securely—to make sure everything is safe and private.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Square 还维护一个名为 **Keysync** 的 Keywhiz 客户端实现。Keysync 是一个程序，它通过安全的方式连接到 Square
    的 Keywhiz 服务器，并请求它需要的秘密信息，以保持 Square 服务的正常运行。它使用称为 **mTLS** 的技术进行安全通信，确保一切都安全和私密。
- en: Once Keysync gets these Secrets, it keeps them in a secure area of the server’s
    memory called **tmpfs**. This is a temporary space that doesn’t save anything
    once the server is turned off. So, if there’s a power cut or the server has to
    be restarted, those Secrets don’t get left behind where they could be seen by
    others.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Keysync获取了这些Secrets，它会将其保存在服务器内存的安全区域，即**tmpfs**。这是一个临时空间，一旦服务器关闭，里面的内容不会保存。因此，如果发生停电或服务器需要重启，这些Secrets不会被遗留在可能被他人看到的地方。
- en: The neat thing about Keysync is that it’s built to handle unexpected problems.
    If there’s an issue with the Keywhiz server, Keysync will still have the Secrets
    it previously downloaded, so Square’s services can keep working without interruption.
    It’s only after a full server reboot that Keysync needs to get all the Secrets
    again.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Keysync的巧妙之处在于它设计时就考虑到了应对突发问题。如果Keywhiz服务器出现问题，Keysync仍然会保留它之前下载的Secrets，因此Square的服务可以继续正常运行，直到进行完全的服务器重启，Keysync才需要重新获取所有Secrets。
- en: To handle these Secrets, Square’s administrators have an admin CLI that allows
    them to type commands directly into the system to add, remove, or change Secrets
    as needed. It’s a straightforward way for them to keep everything up to date and
    to check on the health of the Secrets management system without having to navigate
    through complicated interfaces.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这些Secrets，Square的管理员有一个管理员CLI，允许他们直接在系统中输入命令，按需添加、删除或更改Secrets。这是一种简便的方式，使他们能够保持系统的更新，并检查Secrets管理系统的健康状况，而不必通过复杂的界面进行操作。
- en: Keysync, the CLI for Square’s Keywhiz interface, ensures the secure and confidential
    delivery of Secrets across different scenarios.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Keysync，Square的Keywhiz接口命令行工具，确保在不同场景下安全、机密地传递Secrets。
- en: Challenges and lessons of Keywhiz from a third-party view
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从第三方视角来看，Keywhiz的挑战和经验教训
- en: Given that Keywhiz was deprecated on September 18, 2023, and is no longer maintained,
    reflecting on the challenges and lessons it presented during its service is insightful.
    The recommendation to transition to HashiCorp Vault highlights the need for robust
    and actively supported Secrets management solutions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到Keywhiz已于2023年9月18日被弃用并停止维护，回顾它在服务期间所面临的挑战和所带来的经验教训，具有很大的启示意义。推荐转向HashiCorp
    Vault，强调了需要一个强大且积极维护的Secrets管理解决方案。
- en: Centralized management with Kubernetes cases is hard
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Kubernetes环境下的集中式管理很困难
- en: One of the core challenges Keywhiz faces in Kubernetes Secrets management is
    the inherent complexity of centralized management in a highly distributed and
    dynamic environment such as Kubernetes. Kubernetes environments often require
    a more flexible and decentralized approach to Secrets management. Although Keywhiz
    offers centralized control and strong encryption for Secrets, it may not be optimally
    configured for the decentralized and ephemeral nature of Kubernetes workloads.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Keywhiz在Kubernetes Secrets管理中面临的核心挑战之一是，在像Kubernetes这样高度分布且动态的环境中，集中式管理本身的复杂性。Kubernetes环境通常需要一种更加灵活和去中心化的Secrets管理方式。尽管Keywhiz提供了集中控制和强加密来保护Secrets，但它可能没有针对Kubernetes工作负载的去中心化和短暂性质进行最佳配置。
- en: For example, in Kubernetes, it’s essential to have a Secrets management solution
    that can handle the dynamic creation and deletion of Secrets, in line with the
    ephemeral nature of Kubernetes Pods and Services. Secrets management in Kubernetes
    also requires tight integration with Kubernetes’ **role-based access control**
    (**RBAC**) and the ability to manage Secrets across multiple clusters and namespaces
    efficiently.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Kubernetes中，必须有一个能够处理Secrets动态创建和删除的管理解决方案，这与Kubernetes Pods和Services的短暂特性相符。Kubernetes中的Secrets管理还需要与Kubernetes的**基于角色的访问控制**（**RBAC**）紧密集成，并能够高效地跨多个集群和命名空间管理Secrets。
- en: While Keywhiz excels at centralized Secrets management, providing strong encryption
    and a secure way to distribute Secrets to various services and platforms, adapting
    these capabilities to the specifics of Kubernetes can be challenging. Kubernetes
    environments often benefit from tools such as HashiCorp Vault, which offers extensive
    Kubernetes integration, including dynamic Secrets, integration with Kubernetes
    service accounts for authentication, and the ability to define fine-grained access
    control policies for Secrets.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Keywhiz在集中式Secrets管理方面表现出色，提供强加密并安全地将Secrets分发到各种服务和平台，但将这些能力适配到Kubernetes的特性上可能会有挑战。Kubernetes环境通常需要像HashiCorp
    Vault这样的工具，它提供了广泛的Kubernetes集成，包括动态Secrets、与Kubernetes服务帐户的身份验证集成，以及为Secrets定义细粒度访问控制策略的能力。
- en: A Secrets management system is not just one system but a whole ecosystem
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个秘密管理系统不仅是一个系统，而是一个完整的生态系统
- en: Keywhiz’s role in an organization’s ecosystem extends beyond its function as
    a standalone Secrets management tool. Its effectiveness relies heavily on its
    integration with the company’s existing workflows, policies, and organizational
    culture. This scenario illustrates that the efficacy of a Secrets management system
    is not determined solely by its technical capabilities but by how well it aligns
    with and supports the broader operational context of the organization.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Keywhiz 在组织生态系统中的作用不仅仅是作为一个独立的秘密管理工具。其有效性在很大程度上依赖于与公司现有工作流程、政策和组织文化的集成。这个场景说明，秘密管理系统的效果不仅仅取决于其技术能力，还取决于它如何与组织的整体运营环境对接并提供支持。
- en: For instance, consider a healthcare organization that adopts Keywhiz to manage
    sensitive data, such as patient records and login credentials for internal systems.
    In this setting, while Keywhiz serves as the repository for these Secrets, its
    utility is dependent on seamless integration with the organization’s existing
    healthcare information systems. This integration could involve syncing with employee
    directory services to manage access based on roles and departments. It would also
    entail aligning with healthcare compliance standards, where Keywhiz’s audit trails
    and encryption capabilities become critical in meeting regulatory requirements.
    In this way, Keywhiz becomes an integral part of the organization’s overall data
    security framework, influencing and being influenced by various factors beyond
    the immediate scope of secret storage.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个采用 Keywhiz 来管理敏感数据的医疗保健组织，如患者记录和内部系统的登录凭证。在这种环境下，尽管 Keywhiz 作为这些秘密的存储库，但其有效性依赖于与组织现有医疗信息系统的无缝集成。这种集成可能涉及与员工目录服务同步，以便根据角色和部门管理访问权限。它还需要与医疗合规标准对接，在这种情况下，Keywhiz
    的审计跟踪和加密功能对于满足监管要求至关重要。通过这种方式，Keywhiz 成为组织整体数据安全框架的一个不可或缺的部分，受到组织内外多种因素的影响。
- en: Lack of auditing as a story
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缺乏将审计作为故事的视角
- en: A notable limitation of Keywhiz is its approach to auditing, especially considering
    how it handles secret distribution. Keysync works as a client where Secrets are
    downloaded as `tmpfs` files, which are then used by applications. However, this
    model does not inherently provide detailed auditing data for each action taken
    on these Secrets, and specifically, it lacks visibility into whether applications
    are actively using the downloaded Secrets, as this interaction occurs client-side
    and is not directly observable by the Keywhiz server.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Keywhiz 的一个显著局限性是它在审计方面的处理方式，特别是它如何处理秘密分发。Keysync 作为客户端工作，秘密被下载为 `tmpfs` 文件，然后由应用程序使用。然而，这种模式并没有本质上为每个操作提供详细的审计数据，具体来说，它缺乏对应用程序是否正在积极使用已下载秘密的可见性，因为这一互动发生在客户端，并且无法直接通过
    Keywhiz 服务器观察到。
- en: 'This leads to potential gaps in the auditing process, such as the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能导致审计过程中出现潜在的漏洞，例如以下几点：
- en: Identifying the specific user or service that accessed a secret
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定访问秘密的具体用户或服务
- en: Recording the precise timestamp of each access
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录每次访问的精确时间戳
- en: Understanding the nature of the access, such as whether the secret was read,
    modified, and so on
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解访问的性质，例如是否读取或修改了秘密等
- en: Detecting the IP address or machine from which the secret was accessed
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测访问秘密的 IP 地址或机器
- en: The Keysync process does not reflect the real-time requirements for Secrets
    associated with applications, leading to challenges in maintaining a continuous
    and comprehensive audit trail. This gap can impact the ability to fully document
    the lifecycle of secret access within an organization, making it difficult to
    trace all interactions with sensitive data.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Keysync 过程无法满足与应用程序相关的秘密的实时需求，从而导致维护持续且全面的审计跟踪出现挑战。这一漏洞可能影响到全面记录组织内部秘密访问生命周期的能力，使得追踪所有与敏感数据的互动变得困难。
- en: Managing the Secrets lifecycle from end to end in a Kubernetes production cluster
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kubernetes 生产集群中从头到尾管理秘密的生命周期
- en: The previous chapter covered a broad range of topics, but there was a noticeable
    disconnect between the concepts discussed and practical examples for managing
    Secrets in a production environment. In this section, we will narrow our focus
    and delve into the end-to-end management of Secrets within a Kubernetes production
    cluster, offering a more practical, application-oriented perspective.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章涵盖了广泛的主题，但讨论的概念与在生产环境中管理秘密的实际例子之间存在明显的脱节。在本节中，我们将缩小焦点，深入探讨在Kubernetes生产集群中的秘密端到端管理，提供更具实践性、面向应用的视角。
- en: In exploring the management of Secrets in such an environment, we recognize
    that the process involves more than just secure storage. We shift our focus from
    mere storage repositories to a comprehensive view of Secrets usage throughout
    the system’s lifecycle. Secrets are integral to operational processes, embedded
    in the workflows that drive an organization’s digital operations.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索这种环境中秘密管理时，我们意识到这一过程不仅仅是安全存储。我们将关注点从单纯的存储库转向对整个系统生命周期中秘密使用的全面视角。秘密是运营流程的组成部分，嵌入到推动组织数字化运营的工作流中。
- en: The challenge lies in effectively managing the entire lifecycle of Secrets,
    from inception to decommissioning, with a rigorous emphasis on precision and security.
    This comprehensive approach is essential for organizations committed to high security
    and operational standards. Managing Secrets effectively is about understanding
    their generation, distribution, revocation, and decommissioning within the dynamic
    Kubernetes ecosystem. This section will guide you through the nuanced and vital
    role of Secrets management in maintaining a secure and efficient digital infrastructure.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于有效管理整个秘密的生命周期，从创建到废弃，并严格强调精确性和安全性。这种全面的方法对于致力于高安全性和高运营标准的组织至关重要。有效管理秘密是了解它们的生成、分发、撤销和废弃在动态的Kubernetes生态系统中的过程。本节将引导你了解在维护安全高效的数字基础设施中，秘密管理所扮演的细致而重要的角色。
- en: Finalizing your decision on comprehensive Secrets lifecycle management
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终决定关于全面的秘密生命周期管理
- en: When it comes to managing Secrets in a Kubernetes production environment, adopting
    a holistic and comprehensive approach is paramount. Secrets lifecycle management
    extends far beyond the mere aspect of secure storage, encompassing a range of
    critical processes from the initial provisioning to the final decommissioning
    and revocation.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes生产环境中管理秘密时，采用全面且系统的方法至关重要。秘密生命周期管理不仅仅是安全存储的一个方面，它涵盖了从最初的供应到最终的废弃和撤销的一系列关键过程。
- en: Provisioning involves the creation or generation of Secrets in a secure and
    controlled manner, ensuring that they are strong and unique and that they comply
    with organizational security policies. The storage phase requires a robust and
    secure repository, such as HashiCorp Vault or cloud Secrets stores, ensuring that
    Secrets are encrypted at rest and protected from unauthorized access. Distribution
    is a delicate operation, where Secrets must be securely transmitted to the required
    services or applications, ensuring integrity and confidentiality throughout transit.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 配置涉及以安全和可控的方式创建或生成秘密，确保它们强大且唯一，并符合组织的安全政策。存储阶段需要一个强大且安全的存储库，例如HashiCorp Vault或云端秘密存储，确保秘密在静态时加密并保护免受未经授权的访问。分发是一个微妙的操作，秘密必须安全地传输到所需的服务或应用程序中，确保在传输过程中保持完整性和机密性。
- en: Decommissioning comes into play when Secrets are no longer required, necessitating
    a secure process to retire them, ensuring that they cannot be reused or exploited.
    Finally, revocation is a critical step in the lifecycle, particularly in instances
    of compromise or when a secret’s integrity is in doubt. A swift and efficient
    revocation mechanism ensures that access is immediately cut off, mitigating potential
    damage.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 废弃过程在秘密不再需要时发挥作用，必须有一个安全的流程将它们退役，确保它们不能被重新使用或被利用。最后，撤销是生命周期中的关键步骤，特别是在发生泄露或秘密完整性存疑的情况下。迅速有效的撤销机制确保立即切断访问，减轻潜在的损害。
- en: Embracing a comprehensive Secrets lifecycle management approach ensures that
    Secrets are not just securely stored but are also properly managed throughout
    their entire lifecycle. This end-to-end perspective is not just a best practice
    but an organizational necessity to ensure the integrity of the Secrets and, by
    extension, the entire production system. As we delve deeper into each of these
    aspects in the subsequent sections, the overarching importance of a holistic approach
    to Secrets management in Kubernetes will become increasingly clear, highlighting
    its role as a critical component in the broader security and operational landscape
    of the organization.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 采用全面的 Secrets 生命周期管理方法，确保 Secrets 不仅被安全存储，还能在整个生命周期中得到妥善管理。这种端到端的视角不仅是一种最佳实践，也是确保
    Secrets 完整性以及整个生产系统完整性的组织需求。当我们在后续章节中深入探讨这些方面时，Kubernetes 中全面的 Secrets 管理方法的关键性将愈加明确，凸显其作为组织安全和运营环境中的关键组成部分的作用。
- en: High SLAs as the key to business sustainability
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高 SLA 作为商业可持续性的关键
- en: Maintaining high **service-level agreements** (**SLAs**) is vital for Secrets
    management within Kubernetes environments, emphasizing system reliability and
    availability as foundational aspects of business sustainability. This is particularly
    important in production environments where downtime or security breaches could
    have significant financial and operational implications.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 维持高 **服务水平协议** (**SLA**) 对于 Kubernetes 环境中的 Secrets 管理至关重要，强调系统的可靠性和可用性作为商业可持续性的基础性方面。这在生产环境中尤为重要，因为停机或安全漏洞可能会对财务和运营造成重大影响。
- en: To achieve this high level of reliability, businesses need to implement strong
    monitoring and alerting systems. Regular stress testing of the Secrets management
    system is also essential to identify and address potential vulnerabilities, ensuring
    the system can handle various operational stresses and maintain its SLA commitments.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一高可靠性，企业需要实施强大的监控和警报系统。定期对 Secrets 管理系统进行压力测试也至关重要，以识别和解决潜在的漏洞，确保系统能够应对各种操作压力，并保持其
    SLA 承诺。
- en: In the context of cloud Secrets storage, providers typically offer committed
    SLAs that meet the requirements of most use cases. However, for self-deployed
    Secrets management systems, different approaches are necessary to evaluate and
    ensure SLAs, especially when secret retrieval is critical for system infrastructure
    and platform usage.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在云 Secrets 存储的背景下，服务提供商通常会提供符合大多数用例要求的承诺 SLA。然而，对于自部署的 Secrets 管理系统，需要采用不同的方法来评估和确保
    SLA，尤其是在密钥检索对系统基础设施和平台使用至关重要时。
- en: One strategy to ensure high SLAs is the active-active replication model used
    by solutions such as HashiCorp Vault. This model provides continuous synchronization
    across multiple active systems, enhancing fault tolerance and availability. However,
    it’s not the only approach.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 确保高 SLA 的一种策略是使用如 HashiCorp Vault 等解决方案中的主动-主动复制模型。该模型通过多个活动系统之间的持续同步，增强了容错性和可用性。然而，这并不是唯一的方法。
- en: Alternative methods, such as using a secure Redis configuration for buffered
    Secrets, can offer temporary availability (e.g., for a few hours) and enhance
    platform reliability. In this scenario, Secrets are stored as encrypted ciphertext
    in Redis, which acts as a temporary buffer. This method not only secures the Secrets
    but also provides an additional layer of reliability, ensuring that Secrets are
    available during critical periods or in the event of primary system failures.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 替代方法，如使用安全的 Redis 配置来缓存 Secrets，可以提供临时可用性（例如，持续几个小时），并提高平台的可靠性。在这种情况下，Secrets
    被加密后以密文形式存储在 Redis 中，Redis 充当临时缓存。这种方法不仅确保了 Secrets 的安全性，还提供了额外的可靠性层，确保在关键时期或主要系统故障时，Secrets
    能够保持可用。
- en: Overall, the approach to maintaining high SLAs in Secrets management should
    be tailored to the specific needs and architecture of the Kubernetes environment.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，维持高 SLA 的方法应根据 Kubernetes 环境的具体需求和架构量身定制。
- en: Emergency recovery – backup and restore
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 紧急恢复 - 备份和恢复
- en: In Kubernetes production clusters, crafting an effective emergency recovery
    plan for Secrets management is essential. A robust recovery plan is key to quickly
    restoring operations in the event of data losses, system failures, or security
    incidents, thereby minimizing downtime. This proactive approach ensures that the
    Secrets management system can swiftly recover from unexpected disruptions, thus
    maintaining the continuity of the production environment.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 生产集群中，为密钥管理制定有效的紧急恢复计划至关重要。一个强有力的恢复计划是迅速恢复操作的关键，能够在数据丢失、系统故障或安全事件发生时最小化停机时间。这种前瞻性的做法确保密钥管理系统能够迅速从意外中断中恢复，从而保持生产环境的连续性。
- en: Regular backups play a critical role in safeguarding the integrity and availability
    of Secrets and configurations. These backups form the foundation for a reliable
    recovery mechanism, ensuring that there’s a dependable process for retrieving
    sensitive information and configurations following unforeseen data loss, hardware
    failures, or security breaches.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 定期备份在保护密钥和配置的完整性及可用性方面发挥着至关重要的作用。这些备份为可靠的恢复机制奠定了基础，确保在遭遇数据丢失、硬件故障或安全漏洞后，能够可靠地恢复敏感信息和配置。
- en: For further details and insights on this topic, you may refer to [*Chapter 6*](B20970_06.xhtml#_idTextAnchor117),
    *Disaster Recovery* *and Backups*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多详细信息和见解，请参考 [*第六章*](B20970_06.xhtml#_idTextAnchor117)，*灾难恢复* *与备份*。
- en: Not just storing but provisioning Secrets
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不仅仅是存储密钥，而是配置密钥。
- en: Provisioning and storing Secrets are critical steps in managing Secrets within
    a Kubernetes environment, acting as the initial point of entry and a significant
    opportunity to enforce secure usage models. By controlling the origin of Secrets
    and clearly defining their target resources, organizations can establish a robust
    framework for long-term Secrets management.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 配置和存储密钥是管理 Kubernetes 环境中密钥的关键步骤，作为初始入口点，并为强制执行安全使用模型提供重要机会。通过控制密钥的来源并明确其目标资源，组织可以建立一个稳健的长期密钥管理框架。
- en: When provisioning Secrets, it’s imperative to ensure transparency and traceability.
    Enforcing a clear and standardized process for secret creation helps in tracking
    where Secrets come from, their intended purpose, and their targeted resources.
    This practice aids in maintaining an organized Secrets inventory, making it simpler
    to manage and audit over time.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置密钥时，确保透明性和可追溯性是至关重要的。强制执行清晰且标准化的密钥创建流程有助于追踪密钥的来源、预期用途和目标资源。这一做法有助于保持有序的密钥清单，简化日后管理和审计工作。
- en: In terms of storing Secrets securely in Kubernetes, adopting best practices
    such as encryption at rest and in transit, using dedicated service accounts, and
    implementing role-based access controls is essential. Organizations should leverage
    Kubernetes’ native capabilities, such as Namespaces and NetworkPolicies, to provide
    additional layers of isolation and protection.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中安全存储密钥时，采用最佳实践，如静态和传输加密、使用专用服务帐户和实施基于角色的访问控制至关重要。组织应充分利用 Kubernetes
    的本地功能，如命名空间和网络策略，为密钥提供额外的隔离和保护层。
- en: A key aspect of ensuring long-term success in Secrets management is to enforce
    the use of specific secret types. Kubernetes supports various secret types, each
    tailored to specific use cases. By mandating the use of these types, organizations
    can benefit from Kubernetes’ built-in validation mechanisms, ensuring that Secrets
    conform to the expected structure and reducing the risk of misconfigurations.
    For instance, enforcing a secret type of `kubernetes.io/dockerconfigjson` for
    storing Docker registry credentials ensures that the secret’s content adheres
    to the expected format, reducing the risk of runtime errors.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 确保长远成功的密钥管理的一个关键方面是强制使用特定的密钥类型。Kubernetes 支持多种密钥类型，每种类型都针对特定的使用场景。通过强制使用这些类型，组织可以利用
    Kubernetes 内建的验证机制，确保密钥符合预期结构，减少配置错误的风险。例如，强制使用 `kubernetes.io/dockerconfigjson`
    类型来存储 Docker 注册表凭证，可以确保密钥内容符合预期格式，减少运行时错误的风险。
- en: Furthermore, utilizing specific secret types aids in creating a self-descriptive
    and more manageable environment. Developers and administrators can easily understand
    the purpose and usage of a secret based on its type, enhancing overall clarity
    and reducing the potential for mistakes. This practice also simplifies auditing
    and compliance processes, as it becomes straightforward to track and report on
    the usage of different types of Secrets across the Kubernetes cluster.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，利用特定类型的秘密有助于创建一个自描述且更易管理的环境。开发人员和管理员可以根据Secrets的类型轻松理解其目的和使用方式，从而提高整体清晰度并减少错误的可能性。这种做法还简化了审计和合规流程，因为在Kubernetes集群中追踪和报告不同类型Secrets的使用变得更加简单。
- en: Incorporating these practices into the provisioning and storage phases of Secrets
    management sets a solid foundation for secure and efficient secret handling. It
    ensures that Secrets are created, stored, and used in a manner that aligns with
    security best practices, providing a significant return on investment in terms
    of security, compliance, and manageability. By enforcing clear standards and utilizing
    Kubernetes’ native capabilities, organizations can create a robust and resilient
    Secrets management environment, ready to support their applications securely and
    efficiently.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些实践融入到Secrets管理的供应和存储阶段，为安全高效的秘密处理奠定了坚实的基础。它确保Secrets的创建、存储和使用符合安全最佳实践，为安全、合规性和可管理性方面提供了显著的投资回报。通过执行明确的标准并利用Kubernetes的原生功能，组织可以创建一个强大而弹性的Secrets管理环境，能够安全高效地支持其应用程序。
- en: Secrets rotation
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Secrets轮换
- en: The rotation of Secrets stands as a crucial practice in maintaining a secure
    Kubernetes environment, primarily due to the inherent security implications tied
    to static, long-lived credentials. Secrets, once compromised, can serve as gateways
    for malicious entities, leading to unauthorized access and potential data breaches.
    To mitigate such risks, implementing the periodic rotation of Secrets is necessary,
    ensuring that even if a secret were to be compromised, its lifespan would be limited,
    thereby reducing the potential damage inflicted.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets的轮换在维持安全的Kubernetes环境中至关重要，主要因为静态的、长期有效的凭证带来了固有的安全隐患。一旦Secrets被泄露，它们可能成为恶意实体的入口，导致未经授权的访问和潜在的数据泄露。为了减少这种风险，必须实施Secrets的定期轮换，确保即使一个秘密被泄露，其生命周期也会受到限制，从而减少可能造成的损害。
- en: However, the task of rotating Secrets is not without its challenges, especially
    when dealing with a large number of Secrets distributed across various services.
    This is where automation steps in, offering a streamlined and efficient solution.
    By leveraging automated systems, organizations can ensure timely rotations, aligning
    with best practices and compliance requirements. These systems work by periodically
    updating Secrets and credentials, distributing the updated versions to the respective
    services, and ensuring the outdated Secrets are retired securely.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，轮换Secrets的任务并非没有挑战，尤其是在处理分布在各个服务中的大量Secrets时。此时，自动化便提供了一个精简高效的解决方案。通过利用自动化系统，组织可以确保按时进行轮换，符合最佳实践和合规要求。这些系统通过定期更新Secrets和凭证，分发更新版本到相应的服务，并确保将过时的Secrets安全地淘汰。
- en: It is crucial to note that while automation plays a significant role in Secrets
    rotation, there may be exceptional cases where certain Secrets are exempt from
    rotation due to technical constraints or specific use cases. In these situations,
    it is imperative to maintain transparency and clear documentation, marking these
    Secrets accordingly to ensure visibility. Despite the exemption, a robust incident
    response plan must be in place, guaranteeing that if a security incident were
    to occur, these exempted Secrets could be rotated in a timely manner, mitigating
    potential risks and securing the environment. This comprehensive approach to Secrets
    rotation ensures not only the security of the Secrets themselves but also the
    resilience and integrity of the entire Kubernetes ecosystem.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，虽然自动化在Secrets轮换中起着重要作用，但可能存在一些特殊情况，某些Secrets由于技术限制或特定用例而被豁免于轮换。在这种情况下，必须保持透明性和清晰的文档记录，标明这些Secrets的特殊情况以确保可见性。尽管如此，仍然必须具备强有力的事件响应计划，确保如果发生安全事件，这些豁免的Secrets可以及时轮换，从而减轻潜在风险并保障环境安全。这种全面的Secrets轮换方法不仅保证了Secrets本身的安全性，还确保了整个Kubernetes生态系统的韧性和完整性。
- en: Handling secret updates and rotation
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理密钥更新和轮换
- en: Handling secret updates and rotations is a crucial aspect of maintaining security.
    As recommended by NIST, regularly rotating Secrets is essential to minimize security
    risks.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 处理密钥更新和轮换是保持安全性的重要方面。正如NIST所推荐的，定期轮换密钥是减少安全风险的关键。
- en: 'Our approach to updating Secrets involves several methods:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新密钥的方法包括几种方式：
- en: '**Monitoring and reloading**: We continually monitor for secret changes, updating
    them in application memory to ensure the latest values are used.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和重载**：我们持续监控密钥的变化，将其更新到应用程序内存中，确保使用最新的值。'
- en: '**Keyring mode**: This involves maintaining multiple versions of Secrets to
    prevent downtime. It’s important to monitor which version is in use and phase
    out older ones timely.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥链模式**：这涉及维护多个版本的密钥，以防止停机。重要的是监控使用中的版本，并及时淘汰旧版本。'
- en: '**Restart as reload method**: Implement an automatic system to restart Pods
    when Secrets change, possibly using Kubernetes jobs or other tools to detect changes
    and initiate restarts.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重启作为重载方法**：实施一个自动系统，在密钥更改时重启Pod，可能使用Kubernetes作业或其他工具来检测更改并启动重启。'
- en: 'Each application’s needs dictate the chosen method, focusing on the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序的需求决定了选择的方法，重点关注以下几点：
- en: '**Timely secret consumption**: Depending on the server’s capability to handle
    multiple values'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**及时使用密钥**：根据服务器处理多个值的能力'
- en: '**Graceful secret changes**: Ensuring applications manage new Secrets smoothly,
    without losing state or causing downtime'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平滑密钥更改**：确保应用程序平稳管理新密钥，不丢失状态或导致停机。'
- en: '**Downtime avoidance**: For applications that can’t afford downtime, use strategies
    such as multiple Pod replicas and rolling updates'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免停机**：对于无法容忍停机的应用程序，使用多Pod副本和滚动更新等策略'
- en: '**Monitoring and alerting**: Keep a robust system to monitor Secrets and Pods,
    with alerts for secret rotations and Pod restarts'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和警报**：保持一个强健的系统来监控密钥和Pod，设有密钥轮换和Pod重启的警报'
- en: This strategy aims for both security and operational efficiency, adapting to
    various application requirements on secret rotation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这一策略旨在同时确保安全性和操作效率，适应各种应用程序的密钥轮换需求。
- en: Sample Kubernetes manifest for automated secret rotation
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于自动密钥轮换的Kubernetes示例清单
- en: 'The following is a simplified example to illustrate how you might set up a
    Kubernetes job to trigger Pod restarts upon secret rotation:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简化的示例，说明如何设置Kubernetes作业，以便在密钥轮换时触发Pod重启：
- en: '[PRE8]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is a diagram showing the additional Secrets rotation job:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个展示附加密钥轮换作业的图示：
- en: "![Figure 13.1 – Cro\uFEFFn job for secret rotation](img/B20970_13_01.jpg)"
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – 密钥轮换的Cron作业](img/B20970_13_01.jpg)'
- en: Figure 13.1 – Cron job for secret rotation
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 密钥轮换的Cron作业
- en: In this example, the job runs a container that watches for secret rotations
    in Vault and restarts the relevant Pods in Kubernetes when a rotation is detected.
    This ensures that the init containers for the affected Pods run again, fetching
    the latest version of the Secrets. By adopting such strategies, you ensure that
    your applications remain secure with up-to-date Secrets while minimizing downtime
    and maintaining a robust and resilient deployment.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，作业运行一个容器，监视Vault中的密钥轮换，并在检测到轮换时重启Kubernetes中的相关Pod。这确保受影响Pod的初始化容器再次运行，获取最新版本的密钥。通过采用这些策略，可以确保应用程序保持安全，使用最新的密钥，同时最小化停机并保持稳健且有弹性的部署。
- en: Authorization sprawl issue
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权泛滥问题
- en: In Kubernetes, managing access to Secrets requires careful attention due to
    the delicate balance involved.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，管理对密钥的访问需要特别关注，因为涉及到微妙的平衡。
- en: The **authorization sprawl** issue in Kubernetes arises when permissions are
    set too broadly, often unintentionally, leading to significant security risks.
    This often occurs with RBAC configurations that are not adequately tailored, resulting
    in users or services gaining more privileges than necessary.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的**授权泛滥**问题发生在权限设置过于宽泛时，通常是无意间造成的，导致显著的安全风险。这通常出现在RBAC配置未充分定制的情况下，导致用户或服务获得超过必要的权限。
- en: 'Certainly, solutions such as Kubernetes RBAC and integration with identity
    management solutions are well known, but the real issues include the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，像Kubernetes RBAC和与身份管理解决方案的集成等解决方案是众所周知的，但实际问题包括以下几点：
- en: How to enforce compliance and prevent users from exploiting or circumventing
    the configuration source
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何强制执行合规性并防止用户利用或规避配置源
- en: How to effectively monitor and promptly revoke any policy violations
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何有效监控并及时撤销任何政策违规行为
- en: How to audit configuration-based access policy changes and understand their
    impact
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何审计基于配置的访问策略更改并理解其影响
- en: 'A typical misconfiguration in Kubernetes RBAC might unintentionally allow unexpected
    groups to access all Secrets:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes RBAC中的典型配置错误可能会无意中允许意外的用户组访问所有Secrets：
- en: '[PRE9]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, the `myapp-sa` service account is created with overly broad
    access to Pods and Secrets. The `myapp-role-binding` role binding exacerbates
    the issue by referencing `myapp-role`, which grants full access to these resources.
    As a result, `myapp-sa` is endowed with more permissions than necessary, posing
    a risk of unauthorized access to sensitive data.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`myapp-sa`服务账户被创建时具有过于宽泛的Pod和Secrets访问权限。`myapp-role-binding`角色绑定通过引用`myapp-role`加剧了这一问题，`myapp-role`授予对这些资源的完全访问权限。因此，`myapp-sa`拥有超过必要权限的权限，存在未经授权访问敏感数据的风险。
- en: Addressing this issue requires the implementation of fine-grained access controls
    that precisely define permissions for each role and user, adhering to the principle
    of least privilege. This entails granting only the level of access required for
    users to perform their specific tasks. Regular reviews and updates of RBAC policies
    are also essential.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题需要实施细粒度的访问控制，精确地定义每个角色和用户的权限，遵循最小权限原则。这意味着仅授予用户执行特定任务所需的访问权限。定期审查和更新RBAC策略也是至关重要的。
- en: Tagging, labeling, and masking on the client side
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端的标记、标签和屏蔽
- en: Within a Kubernetes environment, the approach to managing Secrets should be
    holistic, accounting for not just how Secrets are stored but also how they are
    managed and interacted with on the client side. Tagging, labeling, and masking
    Secrets become pivotal in this context. The rationale behind adopting these practices
    is grounded in their ability to enhance security, manageability, and adherence
    to compliance standards. By tagging and labeling Secrets, teams embed essential
    metadata that elucidates the secret’s purpose, associated resources, and lifecycle
    stage. This metadata becomes a powerful tool, aiding in implementing granular
    access controls and simplifying the tracking of secret usage across the system.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes环境中，管理Secrets的方法应是整体性的，不仅要考虑Secrets如何存储，还要考虑它们在客户端如何管理和交互。在此背景下，标记、标签和屏蔽Secrets变得至关重要。采用这些实践的理由在于它们能够增强安全性、可管理性并遵守合规标准。通过标记和标签Secrets，团队嵌入了关键的元数据，阐明了机密的目的、关联资源和生命周期阶段。这些元数据成为一项强大的工具，有助于实施精细的访问控制，并简化跨系统跟踪机密使用情况的过程。
- en: When it comes to implementation, these practices should be seamlessly integrated
    into the development and deployment workflows. Developers and operators should
    be encouraged, or even mandated, to include relevant tags and labels as part of
    their deployment configurations, ensuring that every secret is appropriately annotated
    from the outset. Masking, on the other hand, involves obscuring secret values
    in logs or UIs to preclude accidental exposure, which is a common risk, especially
    in debugging scenarios. Systems need to be configured to automatically recognize
    and redact sensitive information, a task that can be achieved through pattern
    recognition, checksums, or the explicit marking of sensitive fields in the application’s
    logging configuration.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施过程中，这些实践应无缝地集成到开发和部署工作流程中。应鼓励或甚至强制开发人员和操作人员在其部署配置中包含相关标签和标记，以确保每个机密从一开始就得到适当的注解。另一方面，屏蔽是指在日志或用户界面中遮蔽机密值，以防止意外暴露，这在调试场景中尤其常见。系统需要配置为自动识别和删除敏感信息，这一任务可以通过模式识别、校验和或在应用程序日志配置中明确标记敏感字段来实现。
- en: In the long term, the payoff of these practices is substantial. The wealth of
    metadata provided through tagging and labeling facilitates a robust and continuous
    audit trail, allowing teams to track and manage Secrets effectively over extended
    periods. This is crucial not just for day-to-day operational integrity but also
    for meeting stringent security and compliance requirements. Any unauthorized access
    or modifications can be quickly identified and rectified, ensuring that the organization’s
    Secrets management strategy is both secure and resilient. Meanwhile, masking ensures
    that even in scenarios where logs or UIs are exposed, the confidentiality of secret
    values is maintained, mitigating the risk of accidental exposure.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 从长远来看，这些实践的回报是巨大的。通过标记和标签提供的大量元数据促进了强大而持续的审计轨迹，使团队能够在较长时间内有效地追踪和管理机密。这不仅对日常操作的完整性至关重要，而且对于满足严格的安全性和合规性要求也至关重要。任何未经授权的访问或修改都可以迅速识别和纠正，确保组织的机密管理策略既安全又具有弹性。与此同时，掩码技术确保即使在日志或
    UI 被暴露的情况下，机密值的机密性仍然得到保持，从而减少了意外暴露的风险。
- en: By adopting these client-side practices, organizations lay down a foundation
    for a comprehensive Secrets management strategy, ensuring that Secrets are managed,
    tracked, and protected end to end within their Kubernetes environments. This approach
    not only fortifies the organization’s security posture but also ensures that its
    Secrets management practices are aligned with industry best practices and compliance
    standards.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用这些客户端实践，组织为全面的机密管理策略奠定了基础，确保机密在其 Kubernetes 环境中被管理、追踪和保护。这种方法不仅增强了组织的安全态势，还确保其机密管理实践与行业最佳实践和合规标准相一致。
- en: Auditing and monitoring on the server side
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端的审计和监控
- en: On the server side of Secrets management, regular auditing and robust monitoring
    play crucial roles in maintaining a secure and compliant Kubernetes environment.
    Auditing serves as a necessary practice for ensuring that all interactions with
    Secrets—be they accesses, modifications, or deletions—are meticulously recorded
    and reviewed. This practice is fundamental not just for maintaining the integrity
    of the Secrets themselves but also for verifying that all access patterns adhere
    to established security policies and compliance requirements. By implementing
    comprehensive auditing, organizations create a secure trail of evidence, facilitating
    accountability and transparency across all operations involving sensitive information.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在机密管理的服务器端，定期审计和强有力的监控在维护安全和合规的 Kubernetes 环境中发挥着至关重要的作用。审计作为一项必要的实践，确保所有与机密的交互——无论是访问、修改还是删除——都被细致地记录和审查。这一做法不仅对维护机密的完整性至关重要，还能够验证所有访问模式是否遵循既定的安全政策和合规要求。通过实施全面的审计，组织创建了安全的证据轨迹，促进了涉及敏感信息的所有操作的问责制和透明度。
- en: To achieve this level of oversight, it is imperative to utilize both techniques
    and tools that are tailored for robust auditing and monitoring. This includes
    implementing solutions that can provide real-time alerts and detailed access logs,
    ensuring that any anomalous or unauthorized activities are promptly detected and
    addressed. Tools such as audit logs in Kubernetes, and monitoring solutions such
    as Prometheus or Grafana, can be configured to work seamlessly within the environment,
    providing teams with the visibility they need to safeguard their Secrets. Additionally,
    integrating these tools with existing **security information and event management**
    (**SIEM**) systems can further enhance the organization’s capability to correlate
    events, identify patterns, and respond to potential threats swiftly and effectively.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种级别的监管，必须利用专为强大审计和监控量身定制的技术和工具。这包括实施能够提供实时警报和详细访问日志的解决方案，确保任何异常或未经授权的活动都能被及时检测和处理。像
    Kubernetes 的审计日志以及 Prometheus 或 Grafana 等监控解决方案，可以被配置为在环境中无缝工作，为团队提供所需的可见性，以保障其机密。此外，将这些工具与现有的**安全信息和事件管理**（**SIEM**）系统集成，能够进一步增强组织对事件关联、模式识别以及迅速有效应对潜在威胁的能力。
- en: The importance of consistent auditing for security and adherence to regulations,
    along with strategies and instruments to enhance thorough auditing, guarantees
    the proper monitoring of access and changes to Secrets.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性审计对于安全性和遵守法规的重要性，以及增强审计的策略和工具，确保了对机密访问和变更的适当监控。
- en: Ensuring secure Secrets distribution
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保安全的密钥分发
- en: Ensuring the secure distribution of Secrets within a Kubernetes environment
    is paramount, as insecure practices can lead to severe vulnerabilities and security
    breaches. When Secrets are distributed in plain text at rest, whether within the
    host’s filesystem or within a container’s environment, they become susceptible
    to unauthorized access and potential exploitation. This vulnerability is especially
    concerning if an attacker gains access to the host or container, as they could
    easily retrieve and misuse these Secrets.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在Kubernetes环境中安全地分发密钥至关重要，因为不安全的做法可能导致严重的漏洞和安全漏洞。当密钥以明文形式存储时，无论是在主机的文件系统中还是在容器环境中，它们都容易受到未经授权的访问和潜在的滥用。如果攻击者获得了主机或容器的访问权限，他们就能轻松地检索并滥用这些密钥，这种漏洞尤为令人担忧。
- en: Understanding and establishing clear security boundaries is critical in mitigating
    these risks. Organizations must take a proactive stance, implementing stringent
    controls and adopting a principle of least privilege to minimize the blast radius
    in the event of a security incident. This approach involves restricting access
    to Secrets, ensuring that only the necessary parties have access and that Secrets
    are not unnecessarily exposed.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 理解并建立明确的安全边界对于缓解这些风险至关重要。组织必须采取主动立场，实施严格的控制措施并采用最小权限原则，以在发生安全事件时最小化爆炸半径。这种方法涉及限制密钥的访问，确保只有必要的人员可以访问，并且密钥不会不必要地暴露。
- en: Building a trust chain during the Secrets distribution process is essential
    in maintaining the integrity and confidentiality of the Secrets. This involves
    verifying the authenticity and integrity of the Secrets at every step of the distribution
    process, from the moment they are generated or retrieved from the Secrets store,
    through their transmission, and finally, to their consumption by the intended
    services or applications. Various measures can be implemented to ensure this trust
    chain, including the use of encryption during transit, secure injection methods
    for Secrets delivery, and utilizing trusted platforms and identities for access
    control.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在密钥分发过程中建立信任链对于保持密钥的完整性和机密性至关重要。这涉及到在分发过程的每一个步骤中验证密钥的真实性和完整性，从它们生成或从密钥存储中检索的时刻开始，经过传输，最终到达预定的服务或应用程序进行使用。可以实施多种措施来确保这一信任链，包括在传输过程中使用加密技术、采用安全的密钥注入方法进行分发，并利用可信的平台和身份进行访问控制。
- en: Decommissioning and revoking Secrets
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退役和撤销密钥
- en: Decommissioning and revoking Secrets are critical aspects of Secrets lifecycle
    management, ensuring that outdated, compromised, or otherwise unnecessary Secrets
    are removed promptly and securely. Implementing best practices for decommissioning
    involves safely retiring Secrets and ensuring that they are purged from both the
    Secrets store and any environments where they may reside. This process must be
    thorough and systematic to prevent any potential security risks associated with
    lingering Secrets.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 退役和撤销密钥是密钥生命周期管理的关键环节，确保过时、已泄露或其他不再需要的密钥被及时且安全地移除。实施退役最佳实践包括安全地退役密钥，并确保它们从密钥存储和可能存在的任何环境中彻底清除。这个过程必须彻底且系统化，以防止与残留密钥相关的潜在安全风险。
- en: Integration of Secrets management into broader service decommission workflows
    is paramount. As services are retired or replaced, the associated Secrets should
    simultaneously undergo decommissioning. This ensures a cohesive and streamlined
    process, reducing the risk of oversight and potential security vulnerabilities.
    By embedding Secrets considerations directly into service decommissioning processes,
    organizations can enforce consistency and adherence to security protocols.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将密钥管理集成到更广泛的服务退役工作流中至关重要。当服务被退役或替换时，相关的密钥也应同时进行退役。这确保了一个协调一致、简化的过程，减少了疏漏和潜在安全漏洞的风险。通过将密钥考虑直接嵌入到服务退役过程中，组织可以加强一致性并遵守安全协议。
- en: Revocation protocols play a critical role in both proactive and reactive Secrets
    management. Proactively, Secrets should be rotated and revoked according to predefined
    schedules or triggers, such as the expiration of a certificate or the end of a
    service’s lifecycle. Reactively, in the event of a security incident or discovery
    of a compromised secret, immediate revocation is necessary to mitigate risks and
    prevent unauthorized access. Establishing clear and efficient revocation protocols
    ensures that teams can respond swiftly, minimizing the potential impact of a security
    breach.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 撤销协议在主动和被动的Secrets管理中都起着关键作用。主动管理中，Secrets应按照预定义的计划或触发条件进行轮换和撤销，例如证书到期或服务生命周期结束。被动管理中，一旦发生安全事件或发现Secrets泄露，必须立即撤销以减轻风险并防止未经授权的访问。建立清晰高效的撤销协议能确保团队能够迅速响应，最大限度地减少安全漏洞的潜在影响。
- en: Together, these practices fortify the Secrets management lifecycle, ensuring
    that Secrets are not only generated and used securely but are also retired and
    revoked with equal diligence. This comprehensive approach enhances the overall
    security posture of the Kubernetes environment, safeguarding sensitive information
    and maintaining the integrity of the production system.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实践共同加强了Secrets管理生命周期，确保Secrets不仅在生成和使用过程中保持安全，同时在退役和撤销时也保持同样的谨慎。这种全面的方法提升了Kubernetes环境的整体安全态势，保护敏感信息并维护生产系统的完整性。
- en: Responsibility, on-call support, penetration testing, and risk evaluation
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 责任、值班支持、渗透测试和风险评估
- en: The effective management of Secrets within a Kubernetes production environment
    necessitates a clear delineation of responsibilities, robust on-call support structures,
    and an ongoing commitment to security through penetration testing and risk evaluation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes生产环境中有效管理Secrets，需要明确划分责任、健全的值班支持结构，并通过渗透测试和风险评估持续致力于安全性。
- en: Responsibility and on-call support
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 责任与值班支持
- en: The team managing the deployment platform must clearly define and distribute
    the responsibilities associated with both Secrets distribution and Secrets store
    management. This encompasses not only the initial setup and distribution of Secrets
    but also their ongoing management, updates, and rotation. On-call responsibilities
    are a critical component of this, ensuring that there is always a knowledgeable
    and capable team member available to address any issues that may arise, ranging
    from access issues and misconfigurations to potential security incidents. These
    team members must be well versed in both the configuration and debugging of the
    Secrets management tools and the broader Kubernetes environment to effectively
    address and resolve incidents. Additionally, they should be actively involved
    in enhancement efforts, working to continuously improve the system’s stability,
    security, and efficiency.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 管理部署平台的团队必须明确划分并分配与Secrets分发和Secrets存储管理相关的责任。这不仅包括Secrets的初始设置和分发，还包括其持续管理、更新和轮换。值班责任是这一过程的关键组成部分，确保始终有具备专业知识和能力的团队成员可以应对可能出现的问题，从访问问题、配置错误到潜在的安全事件。这些团队成员必须熟练掌握Secrets管理工具的配置和调试工作，以及更广泛的Kubernetes环境，以有效地处理和解决事件。此外，他们还应积极参与系统的增强工作，不断提升系统的稳定性、安全性和效率。
- en: Penetration testing and risk evaluation
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渗透测试与风险评估
- en: The regular penetration testing of the production Secrets store is paramount
    in identifying and mitigating potential security risks. This proactive approach
    to security helps in uncovering vulnerabilities, assessing the robustness of access
    policies, and evaluating potential paths through which Secrets could be exposed.
    The results of these penetration tests should feed directly into the organization’s
    broader risk evaluation efforts, helping to build a comprehensive understanding
    of the system’s security posture and guiding informed decisions around risk mitigation.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 定期对生产环境中的Secrets存储进行渗透测试至关重要，能够识别和减轻潜在的安全风险。这种主动的安全方法有助于发现漏洞，评估访问策略的健壮性，并评估Secrets可能被暴露的路径。这些渗透测试的结果应直接纳入组织的更广泛风险评估工作中，帮助全面了解系统的安全态势，并为风险减缓提供有依据的决策指导。
- en: Penetration testing should not be a one-time effort but rather an ongoing practice,
    continuously evolving to address new threats and vulnerabilities as they emerge.
    It should cover various aspects of the Secrets management lifecycle, from the
    initial provisioning of Secrets, through their storage, distribution, and eventual
    decommissioning.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试不应是一次性的努力，而应是一个持续的实践，不断演进，以应对新出现的威胁和漏洞。它应涵盖 Secrets 管理生命周期的各个方面，从 Secrets
    的初步配置，到它们的存储、分发，直至最终的退役。
- en: By integrating these practices into the organization’s overall risk evaluation
    framework, teams can ensure that they are not only addressing immediate threats
    but also building a resilient system capable of withstanding future challenges.
    This comprehensive approach to responsibility, on-call support, penetration testing,
    and risk evaluation forms a critical component of maintaining a secure and efficient
    Secrets management framework within Kubernetes production environments.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些实践整合到组织的整体风险评估框架中，团队可以确保不仅解决了当前的威胁，还建立了一个能够应对未来挑战的弹性系统。对责任、值班支持、渗透测试和风险评估的全面方法，是在
    Kubernetes 生产环境中维持安全高效的 Secrets 管理框架的关键组成部分。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we delved into the intricacies of managing Kubernetes Secrets
    within production clusters. We highlighted the qualities necessary for effective
    Secrets management and examined various deployment strategies and their integration
    with CI/CD processes. Additionally, we explored a detailed case study on Keywhiz,
    which provided a thorough understanding of Secrets management development, emphasizing
    a holistic approach that covers the entire lifecycle of Secrets management.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了在生产集群中管理 Kubernetes Secrets 的复杂性。我们强调了有效的 Secrets 管理所需的品质，并审视了各种部署策略及其与
    CI/CD 流程的整合。此外，我们还通过一个关于 Keywhiz 的详细案例研究，全面理解了 Secrets 管理的发展，强调了涵盖 Secrets 管理整个生命周期的整体方法。
- en: The next chapter will offer a synthesis of the insights and knowledge we’ve
    gained throughout the book. It will also cast a forward-looking perspective on
    the evolution and future trends in Kubernetes Secrets management.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将总结我们在本书中获得的见解和知识，并对 Kubernetes Secrets 管理的演变及未来趋势提供前瞻性视角。
