<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer144">
<h1 class="chapterNumber">7</h1>
<h1 class="chapterTitle" id="_idParaDest-275">RBAC Policies and Auditing</h1>
<p class="normal">Authentication is only the first step in managing access to a cluster. Once access to a cluster is granted, it’s important to limit what accounts can do, depending on whether an account is for an automated system or a user. Authorizing access to resources is an important part of protecting against both accidental issues and bad actors looking to abuse a cluster.</p>
<p class="normal">In this chapter, we’re going to detail how Kubernetes authorizes access via its <strong class="keyWord">Role-Based Access Control</strong> (<strong class="keyWord">RBAC</strong>) model. The first part of this chapter will be a deep dive into how Kubernetes RBAC is configured, what options are available, and mapping the theory onto practical examples. Debugging and troubleshooting RBAC policies will be the focus of the second half.</p>
<p class="normal">In this chapter, we will cover the following topics:</p>
<ul>
<li class="bulletList">Introduction to RBAC</li>
<li class="bulletList">Mapping enterprise identities to Kubernetes to authorize access to resources</li>
<li class="bulletList">Implementing namespace multi-tenancy</li>
<li class="bulletList">Kubernetes auditing</li>
<li class="bulletList">Using <code class="inlineCode">audit2rbac</code> to debug policies</li>
</ul>
<p class="normal">Once you have completed this chapter, you’ll have the tools needed to manage access to your cluster via Kubernetes’ integrated RBAC model and debug issues when they arise. Next, let’s dive into the technical requirements for this chapter.</p>
<h1 class="heading-1" id="_idParaDest-276">Technical requirements</h1>
<p class="normal">This chapter has the following technical requirements:</p>
<ul>
<li class="bulletList">An Ubuntu 22.04+ server running Docker with a minimum of 4 GB of RAM, though 8 GB is suggested.</li>
<li class="bulletList">Scripts from the <code class="inlineCode">chapter7</code> folder from the repo, which you can access by going to this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition"><span class="url">https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition</span></a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-277">Introduction to RBAC</h1>
<p class="normal"><strong class="keyWord">RBAC</strong> stands<a id="_idIndexMarker748"/> for <strong class="keyWord">Role-Based Access Control</strong>. At its core is the idea of building permission sets, which are <a id="_idIndexMarker749"/>called <strong class="keyWord">Roles</strong>, and lists of subjects (users) that those permissions apply to. In this chapter, we’ll walk through building roles and their corresponding bindings to build out the permissions in our clusters.</p>
<h2 class="heading-2" id="_idParaDest-278">What’s a Role?</h2>
<p class="normal">In Kubernetes, a <strong class="keyWord">Role</strong> is a <a id="_idIndexMarker750"/>way to tie together permissions into an object standardized to a specific schema. By codifying <strong class="keyWord">Roles</strong> into this schema, you’re able to standardize and automate their creation and management.</p>
<p class="normal">Roles have rules, which are a collection of resources and verbs. Working backward, we have the following:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Verbs</strong>: The actions that can be<a id="_idIndexMarker751"/> taken on an API, such as reading (<code class="inlineCode">get</code>), writing (<code class="inlineCode">create</code>, <code class="inlineCode">update</code>, <code class="inlineCode">patch</code>, and <code class="inlineCode">delete</code>), or listing and watching.</li>
<li class="bulletList"><strong class="keyWord">Resources</strong>: Names of APIs to <a id="_idIndexMarker752"/>apply the verbs to, such as <code class="inlineCode">services</code>, <code class="inlineCode">endpoints</code>, and so on. Specific sub-resources, such as <code class="inlineCode">logs</code> and <code class="inlineCode">status</code>, may be listed as well. Specific resources can be named to provide very specific permissions on an object.</li>
</ul>
<p class="normal">A Role does not say who can perform the verbs on the resources—that is handled by <code class="inlineCode">RoleBindings</code> and <code class="inlineCode">ClusterRoleBindings</code>. We will learn more about these in the <em class="chapterRef">RoleBindings and ClusterRoleBindings</em> section.</p>
<p class="normal">The term “role” can have <a id="_idIndexMarker753"/>multiple meanings, and RBAC is often used in other contexts. In the enterprise world, the term “role” is often associated with a business role and used to convey entitlements to that <a id="_idIndexMarker754"/>role instead of a specific person.</p>
<figure class="mediaobject"><img alt="Diagram  Description automatically generated" height="272" src="../Images/B21165_07_01.png" width="678"/></figure>
<p class="packt_figref">Figure 7.1: RBAC versus entitlement-based access control</p>
<p class="normal">As an example, in <em class="italic">Figure 7.1</em>, a user is a member of the “role” for accounts payable. Being a member of this role automatically provides the entitlement to “write checks.” If our user’s job changes to accounts receivable, their permissions will change automatically because the permissions are tied to the user’s role. In enterprise RBAC models, what ties a user to a “role” is generally some context instead of a specific group membership or attribute value. For instance, users might be located in different parts of the corporate directory based on their “role.”</p>
<p class="normal">This is different from how Kubernetes uses the term “Role” to mean a list of permissions, and those permissions aren’t tied together because of a business role but because of a technical requirement. As we’ll see when we get to bindings, Kubernetes Roles are tightly bound to accounts and groups, and while the permissions of a <code class="inlineCode">Role</code> are grouped together for a specific function, that function is defined at a lower, technical level than “enterprise” roles.</p>
<p class="normal">Now that we’ve differentiated between what the “enterprise” definition of a role is from how Kubernetes defines a <code class="inlineCode">Role</code>, let’s dive into how you build a <code class="inlineCode">Role</code>.</p>
<p class="normal">Each resource that a role will be built from is identified by the following:</p>
<ul>
<li class="bulletList"><code class="inlineCode">apiGroups</code>: A list of groups the resources are a member of</li>
<li class="bulletList"><code class="inlineCode">resources</code>: The name of the object type for the resource (and potentially sub-resources)</li>
<li class="bulletList"><code class="inlineCode">resourceNames</code>: An optional list of specific objects to apply this rule to</li>
</ul>
<p class="normal">Each rule <em class="italic">must</em> have a list of <code class="inlineCode">apiGroups</code> and <code class="inlineCode">resources</code>. <code class="inlineCode">resourceNames</code> is optional.</p>
<p class="normal">Once the resource is identified in a rule, verbs can be specified. A verb is an action that can be taken on the resource, providing access to the object in Kubernetes.</p>
<p class="normal">If the desired access to an object should be <code class="inlineCode">all</code>, you do not need to add each verb; instead, the wildcard character may be used to identify all the <code class="inlineCode">verbs</code>, <code class="inlineCode">resources</code>, or <code class="inlineCode">apiGroups</code>.</p>
<h2 class="heading-2" id="_idParaDest-279">Identifying a Role</h2>
<p class="normal">The Kubernetes <a id="_idIndexMarker755"/>authorization page (<a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/"><span class="url">https://kubernetes.io/docs/reference/access-authn-authz/rbac/</span></a>) uses the<a id="_idIndexMarker756"/> following <code class="inlineCode">Role</code> as an example to allow someone to get the details of a pod and its logs:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-and-pod-logs-reader</span>
<span class="hljs-attr">rules:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">""</span>]
  <span class="hljs-attr">resources:</span> [<span class="hljs-string">"pods"</span>, <span class="hljs-string">"pods/log"</span>]
  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">"get"</span>, <span class="hljs-string">"list"</span>]
</code></pre>
<p class="normal">Before defining what a <code class="inlineCode">Role</code> manages, it’s important to note that <code class="inlineCode">Role</code> objects are namespaced, so the <code class="inlineCode">namespace</code> the <code class="inlineCode">Role</code> is created in means that the permissions it defines apply only within its own <code class="inlineCode">namespace</code>. In this example, the <code class="inlineCode">Role</code> only applies to the <code class="inlineCode">default namespace</code>.</p>
<p class="normal">Working backward to determine how this <code class="inlineCode">Role</code> was defined, we will start with <code class="inlineCode">resources</code>, since it is the easiest aspect to find. All objects in Kubernetes are represented by URLs. If you wanted to pull all the information about the pods in the <code class="inlineCode">default</code> <code class="inlineCode">namespace</code>, you would call the <code class="inlineCode">/api/v1/namespaces/default/pods</code> URL, and if you wanted the logs for a specific pod, you would call the <code class="inlineCode">/api/v1/namespaces/default/pods/mypod/log</code> URL.</p>
<p class="normal">The URL pattern <a id="_idIndexMarker757"/>will be true of all namespace-scoped objects. pods lines up to <code class="inlineCode">resources</code>, as does <code class="inlineCode">pods/log</code>. When trying to identify which resources you want to authorize, use the <code class="inlineCode">api-reference</code> document from the Kubernetes API documentation at <a href="https://kubernetes.io/docs/reference/#api-reference"><span class="url">https://kubernetes.io/docs/reference/#api-reference</span></a>.</p>
<p class="normal">If you are trying to access an additional path component after the name of the object (such as with <code class="inlineCode">status</code> and <code class="inlineCode">logs</code> on pods), it needs to be explicitly authorized. Authorizing <code class="inlineCode">Pods</code> does not immediately authorize <code class="inlineCode">logs</code> or <code class="inlineCode">status</code>.</p>
<p class="normal">Based on the use of URL mapping to <code class="inlineCode">resources</code>, your next thought may be that the <code class="inlineCode">verbs</code> field is going to be HTTP verbs. This is not the case. There is no <code class="inlineCode">GET</code> verb in Kubernetes. Verbs are instead defined by the schema of the object in the API server. The good news is that there’s a static mapping between HTTP verbs and RBAC verbs (<a href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/#determine-the-request-verb"><span class="url">https://kubernetes.io/docs/reference/access-authn-authz/authorization/#determine-the-request-verb</span></a>). Looking at this URL, notice that there are verbs on top of the HTTP verbs for <strong class="keyWord">impersonation</strong>. That’s because the RBAC model is used beyond authorizing specific APIs and is also used to authorize who can impersonate users. The focus of this chapter is going to be on the standard HTTP verb mappings.</p>
<p class="normal">The final component to identify is <code class="inlineCode">apiGroups</code>. APIs will be in an API group and that group will be part of their URL. You can find the group by looking at the API documentation for the object you are looking to authorize or by using the <code class="inlineCode">kubectl api-resources</code> command. For instance, to get <code class="inlineCode">apiGroups</code> for the <code class="inlineCode">Ingress</code> object, you could run:</p>
<pre class="programlisting con"><code class="hljs-con">kubectl api-resources -o wide | grep Ingress
ingressclasses networking.k8s.io/v1 false IngressClass [create delete deletecollection get list patch update watch]
ingresses ing networking.k8s.io/v1 true Ingress [create delete deletecollection get list patch update watch]
</code></pre>
<p class="normal">The second result gives you what you would see in the <code class="inlineCode">apiVersion</code> of a YAML version of an <code class="inlineCode">Ingress</code> object. Use this for <code class="inlineCode">apiGroups</code>, but without the version number. To apply a <code class="inlineCode">Role</code> to an <code class="inlineCode">Ingress</code> object, the <code class="inlineCode">apiGroups</code> would be <code class="inlineCode">networking.k8s.io</code>.</p>
<p class="normal">The inconsistencies in the RBAC model can make debugging difficult, to say the least. The last lab in this chapter will walk through the debugging process and take much of the guesswork<a id="_idIndexMarker758"/> out of defining your rules.</p>
<p class="normal">Now that we’ve defined the contents of a Role and how to define specific permissions, it’s important to note that Roles can be applied at both the namespace and cluster level.</p>
<h2 class="heading-2" id="_idParaDest-280">Roles versus ClusterRoles</h2>
<p class="normal">RBAC rules can be scoped <a id="_idIndexMarker759"/>either to specific namespaces or to the entire <a id="_idIndexMarker760"/>cluster. Taking the preceding example, if we defined it as a <code class="inlineCode">ClusterRole</code> instead of a <code class="inlineCode">Role</code>, and removed the namespace, we would have a <code class="inlineCode">Role</code> that authorizes someone to get the details and logs of all pods across the cluster. This new <code class="inlineCode">Role</code> could alternatively be used in individual namespaces to assign the permissions to the pods in a specific namespace:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-pod-and-pod-logs-reader</span>
<span class="hljs-attr">rules:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">""</span>]
  <span class="hljs-attr">resources:</span> [<span class="hljs-string">"pods"</span>, <span class="hljs-string">"pods/log"</span>]
  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">"get"</span>, <span class="hljs-string">"list"</span>]
</code></pre>
<p class="normal">Whether this permission is applied globally across a cluster or within the scope of a specific namespace depends on how it’s bound to the subjects it applies to. This will be covered in the <em class="chapterRef">RoleBindings and ClusterRoleBindings</em> section.</p>
<p class="normal">In addition to applying a set of rules across the cluster, <code class="inlineCode">ClusterRoles</code> are used to apply rules to resources that aren’t mapped to a namespace, such as <code class="inlineCode">PersistentVolume</code> and <code class="inlineCode">StorageClass</code> objects.</p>
<p class="normal">After learning how a <code class="inlineCode">Role</code> is defined, let’s explore the different ways <code class="inlineCode">Roles</code> can be designed for specific purposes. In the next sections, we’ll look at different patterns for defining <code class="inlineCode">Roles</code> and their application in a cluster.</p>
<h2 class="heading-2" id="_idParaDest-281">Negative Roles</h2>
<p class="normal">One of the<a id="_idIndexMarker761"/> most common<a id="_idIndexMarker762"/> requests for authorization is “<em class="italic">Can I write a Role that lets me do everything EXCEPT xyz</em>?”. In RBAC, the answer is <em class="italic">NO</em>. RBAC requires either every resource to be allowed or specific resources and verbs to be enumerated. There are two reasons for this in RBAC:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Better security through simplicity</strong>: Being able to enforce a rule that says <em class="italic">every Secret except this one</em> requires a much more complex evaluation engine than RBAC provides. The more complex an engine, the harder it is to test and validate, and the easier it is to break. A simpler engine is just simpler to code and keep secure.</li>
<li class="bulletList"><strong class="keyWord">Unintended consequences</strong>: Allowing someone to do everything <em class="italic">except</em> xyz leaves the door open for issues in unintended ways as the cluster grows and new capabilities are added.</li>
</ul>
<p class="normal">On the first point, an <a id="_idIndexMarker763"/>engine with this capability is difficult to build and maintain. It also<a id="_idIndexMarker764"/> makes the rules much harder to keep track of. To express this type of rule, you need to not only have authorization rules but also an order to those rules. For instance, to say <em class="italic">I want to allow everything except this Secret</em>, you would first need a rule that says <em class="italic">allow everything</em> and then a rule that says <em class="italic">deny this secret</em>. If you switch the rules to say <em class="italic">deny this secret</em> then <em class="italic">allow everything</em>, the first rule would be overridden. You could assign priorities to different rules, but that now makes it even more complex.</p>
<p class="normal">There are ways to implement this pattern, either by using a custom authorization webhook or by using a controller to dynamically generate RBAC <code class="inlineCode">Role</code> objects. These should both be considered security anti-patterns and so won’t be covered in this chapter.</p>
<p class="normal">The second point deals with unintended consequences. It’s becoming more popular to support the provisioning of infrastructure that isn’t Kubernetes using the operator pattern, where a custom controller looks for new instances of a <strong class="keyWord">CustomResourceDefinition</strong> (<strong class="keyWord">CRD</strong>) to provision <a id="_idIndexMarker765"/>infrastructure such as databases.</p>
<p class="normal">Amazon Web Services publishes an operator for this purpose (<a href="https://github.com/aws/aws-controllers-k8s"><span class="url">https://github.com/aws/aws-controllers-k8s</span></a>). These operators run in their own namespaces with administrative credentials for their cloud looking for new instances of their objects to provision resources. If you have a security model that allows everything “except…”, then once deployed, anyone in your cluster can provision cloud resources that have real costs and can create security holes. Enumerating your resources, from a security perspective, is an important part of knowing what is running and who has access.</p>
<p class="normal">The trend in Kubernetes clusters is to provide more control over infrastructure outside of the cluster via the custom resource API. You can provision anything from VMs to additional nodes, to any kind of API-driven cloud infrastructure. There are other tools you can use besides RBAC to mitigate the risk of someone creating a resource they shouldn’t, but these should be secondary measures.</p>
<p class="normal">So far, we’ve looked at how to create permissions for specific use cases. What happens if you need some flexibility to be able to define permissions more dynamically than the static lists we’re providing now? Next, we’ll discover how to use aggregated <code class="inlineCode">ClusterRoles</code> to provide a dynamic approach to permission lists.</p>
<h2 class="heading-2" id="_idParaDest-282">Aggregated ClusterRoles</h2>
<p class="normal"><code class="inlineCode">ClusterRoles</code> can <a id="_idIndexMarker766"/>become confusing quickly and be difficult to maintain. It’s best to break them up into smaller <code class="inlineCode">ClusterRoles</code> that can be combined as needed. Take the <code class="inlineCode">admin</code> <code class="inlineCode">ClusterRole</code>, which is designed to let someone do generally anything inside of a specific namespace. When we look at the <code class="inlineCode">admin</code> <code class="inlineCode">ClusterRole</code>, it enumerates just about every resource there is. You may think someone wrote this <code class="inlineCode">ClusterRole</code> so that it would contain all those resources, but that would be really inefficient, and what happens as new resource types get added to Kubernetes? The <code class="inlineCode">admin</code> <code class="inlineCode">ClusterRole</code> is an aggregated <code class="inlineCode">ClusterRole</code>. Take a look at the <code class="inlineCode">ClusterRole</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">admin</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">kubernetes.io/bootstrapping:</span> <span class="hljs-string">rbac-defaults</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">rbac.authorization.kubernetes.io/autoupdate:</span> <span class="hljs-string">'true'</span>
<span class="hljs-attr">rules:</span>
<span class="hljs-string">.</span>
<span class="hljs-string">.</span>
<span class="hljs-string">.</span>
<span class="hljs-attr">aggregationRule:</span>
  <span class="hljs-attr">clusterRoleSelectors:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">matchLabels:</span>
        <span class="hljs-attr">rbac.authorization.k8s.io/aggregate-to-admin:</span> <span class="hljs-string">'true'</span>
</code></pre>
<p class="normal">The key is the <code class="inlineCode">aggregationRule</code> section. This section tells Kubernetes to combine the rules for all <code class="inlineCode">ClusterRoles</code> where the <code class="inlineCode">rbac.authorization.k8s.io/aggregate-to-admin</code> label is <code class="inlineCode">true</code>. When a new CRD is created, an admin is not able to create instances of that CRD without adding a new <code class="inlineCode">ClusterRole</code> that includes this label. To allow namespace admin users to create an instance of the new <code class="inlineCode">myapi/superwidget</code> objects, create a new <code class="inlineCode">ClusterRole</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">aggregate-superwidget-admin</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-comment"># Add these permissions to the "admin" default role.</span>
    <span class="hljs-attr">rbac.authorization.k8s.io/aggregate-to-admin:</span> <span class="hljs-string">"true"</span>
<span class="hljs-attr">rules:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">"myapi"</span>]
  <span class="hljs-attr">resources:</span> [<span class="hljs-string">"superwidgets"</span>]
  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">"get"</span>, <span class="hljs-string">"list"</span>, <span class="hljs-string">"watch"</span>, <span class="hljs-string">"create"</span>, <span class="hljs-string">"update"</span>, <span class="hljs-string">"patch"</span>, <span class="hljs-string">"delete"</span>]
</code></pre>
<p class="normal">The next time you look at the <code class="inlineCode">admin</code> <code class="inlineCode">ClusterRole</code>, it will include <code class="inlineCode">myapi/superwidgets</code>. You can also reference <a id="_idIndexMarker767"/>this <code class="inlineCode">ClusterRole</code> directly for more specific permissions.</p>
<p class="normal">So far, we’ve focussed on creating permission lists via <code class="inlineCode">Roles</code> and <code class="inlineCode">ClusterRoles</code>. Next, we’ll work on assigning those permissions to users and services.</p>
<h2 class="heading-2" id="_idParaDest-283">RoleBindings and ClusterRoleBindings</h2>
<p class="normal">Once a permission is defined, it needs to be assigned to something to enable it. “Something” can be a user, a group, or a service account. These <a id="_idIndexMarker768"/>options are referred to as <strong class="keyWord">subjects</strong>. Just as with <code class="inlineCode">Roles</code> and <code class="inlineCode">ClusterRoles</code>, a <code class="inlineCode">RoleBinding</code> binds a <code class="inlineCode">Role</code> or <code class="inlineCode">ClusterRole</code> to a specific namespace, and a <code class="inlineCode">ClusterRoleBinding</code> will apply a <code class="inlineCode">ClusterRole</code> across the cluster. A<a id="_idIndexMarker769"/> binding can have many subjects but may only reference a single <code class="inlineCode">Role</code> or <code class="inlineCode">ClusterRole</code>. To assign the <code class="inlineCode">pod-and-pod-logs-reader</code> <code class="inlineCode">Role</code> created earlier in this<a id="_idIndexMarker770"/> chapter to a service account called <code class="inlineCode">mysa</code> in the default namespace, a user named <code class="inlineCode">podreader</code>, or anyone with the <code class="inlineCode">podreaders</code> group, create a <code class="inlineCode">RoleBinding</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">RoleBinding</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-and-pod-logs-reader</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span>
<span class="hljs-attr">subjects:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">mysa</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">podreader</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">Group</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">podreaders</span>
<span class="hljs-attr">roleRef:</span>
  <span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-and-pod-logs-reader</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
</code></pre>
<p class="normal">The preceding <code class="inlineCode">RoleBinding</code> lists <a id="_idIndexMarker771"/>three different <a id="_idIndexMarker772"/>subjects:</p>
<ul>
<li class="bulletList"><code class="inlineCode">ServiceAccount</code>: Any service account in the cluster can be authorized to a <code class="inlineCode">RoleBinding</code>. The namespace must be included since a <code class="inlineCode">RoleBinding</code> can authorize a service account in any namespace, not just the one the <code class="inlineCode">RoleBinding</code> is defined in.</li>
<li class="bulletList"><code class="inlineCode">User</code>: A user is asserted by the authentication process. Remember from <em class="chapterRef">Chapter 6</em>, <em class="italic">Integrating Authentication into Your Cluster</em>, that there are no objects in Kubernetes that represent users.</li>
<li class="bulletList"><code class="inlineCode">Group</code>: Just as with users, groups are asserted as part of the authentication process and have no object associated with them.</li>
</ul>
<p class="normal">Finally, the <code class="inlineCode">Role</code> we created earlier is referenced. In a similar fashion, to assign the same subjects the ability to read pods and their logs across the cluster, a <code class="inlineCode">ClusterRoleBinding</code> can be created to reference the <code class="inlineCode">cluster-pod-and-pod-logs-reader</code> <code class="inlineCode">ClusterRole</code> created earlier in the chapter:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-pod-and-pod-logs-reader</span>
<span class="hljs-attr">subjects:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">mysa</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">podreader</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">Group</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">podreaders</span>
<span class="hljs-attr">roleRef:</span>
  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-pod-and-pod-logs-reader</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
</code></pre>
<p class="normal">The <code class="inlineCode">ClusterRoleBinding</code> is bound<a id="_idIndexMarker773"/> to the same subjects but is bound to a <code class="inlineCode">ClusterRole</code> instead of a namespace-bound <code class="inlineCode">Role</code>. Now, instead of being able to read pod details and <code class="inlineCode">Pod/logs</code> in the<a id="_idIndexMarker774"/> default namespace, these users can read all pod details and <code class="inlineCode">Pod/logs</code> in all namespaces.</p>
<p class="normal">Till now, the focus has been on combining a <code class="inlineCode">Role</code> with a <code class="inlineCode">RoleBinding</code> and a <code class="inlineCode">ClusterRole</code> with a <code class="inlineCode">ClusterRoleBinding</code>. If you want to define the same permissions that are scoped to multiple namespaces, you’ll want a way to do that without reproducing the same <code class="inlineCode">Role</code> every time. Next, we’ll cover how to simplify <code class="inlineCode">Role</code> management by combining <code class="inlineCode">ClusterRoles</code> and <code class="inlineCode">RoleBindings</code>.</p>
<h3 class="heading-3" id="_idParaDest-284">Combining ClusterRoles and RoleBindings</h3>
<p class="normal">We have a use<a id="_idIndexMarker775"/> case where a log aggregator wants to<a id="_idIndexMarker776"/> pull logs from pod in multiple namespaces, but not all namespaces. A <code class="inlineCode">ClusterRoleBinding</code> is too broad. While the <code class="inlineCode">Role</code> could be recreated in each namespace, this is inefficient and a maintenance headache. Instead, define a <code class="inlineCode">ClusterRole</code> but reference it from a <code class="inlineCode">RoleBinding</code> in the applicable namespaces. This allows the reuse of permission definitions while still applying those permissions to specific namespaces. In general, note the following:</p>
<ul>
<li class="bulletList"><code class="inlineCode">ClusterRole</code> + <code class="inlineCode">ClusterRoleBinding</code> = cluster-wide permission</li>
<li class="bulletList"><code class="inlineCode">ClusterRole</code> + <code class="inlineCode">RoleBinding</code> = namespace-specific permission</li>
</ul>
<p class="normal">To apply our <code class="inlineCode">ClusterRoleBinding</code> in a specific namespace, create a <code class="inlineCode">Role</code>, referencing the <code class="inlineCode">ClusterRole</code> instead of a namespaced <code class="inlineCode">Role</code> object:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">RoleBinding</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-and-pod-logs-reader</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span>
<span class="hljs-attr">subjects:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">mysa</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">podreader</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">Group</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">podreaders</span>
<span class="hljs-attr">roleRef:</span>
  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-pod-and-pod-logs-reader</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
</code></pre>
<p class="normal">The<a id="_idIndexMarker777"/> preceding <code class="inlineCode">RoleBinding</code> lets us reuse the <a id="_idIndexMarker778"/>existing <code class="inlineCode">ClusterRole</code>. This cuts down on the number of objects that need to be tracked in the cluster and makes it easier to update permissions across the cluster if the <code class="inlineCode">ClusterRole</code> permissions need to change.</p>
<p class="normal">Having built our permissions and defined how to assign them, next, we’ll look at how to map enterprise identities into cluster policies.</p>
<h1 class="heading-1" id="_idParaDest-285">Mapping enterprise identities to Kubernetes to authorize access to resources</h1>
<p class="normal">One of the <a id="_idIndexMarker779"/>benefits of centralizing authentication is leveraging the enterprise’s existing identities instead of having to create new credentials that users who interact with your clusters need to remember. It’s important to know how to map your policies to these centralized users. In <em class="chapterRef">Chapter 6</em>, <em class="italic">Integrating Authentication into Your Cluster</em>, you created a cluster and integrated it with an “enterprise <strong class="keyWord">Active Directory</strong>.” To finish the integration, the following <code class="inlineCode">ClusterRoleBinding</code> was created:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">ou-cluster-admins</span>
<span class="hljs-attr">subjects:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">Group</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">cn=k8s-cluster-admins,ou=Groups,DC=domain,DC=com</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
<span class="hljs-attr">roleRef:</span>
  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-admin</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
</code></pre>
<p class="normal">This <a id="_idIndexMarker780"/>binding allows all users that are members of the <code class="inlineCode">cn=k8s-cluster-admins,ou=Groups,DC=domain,DC=com</code> group to have full cluster access. At the time, the focus was on authentication, so there weren’t many details provided as to why this binding was created.</p>
<p class="normal">What if we wanted to authorize our users directly? That way, we will have control over who has access to our cluster. Our RBAC <code class="inlineCode">ClusterRoleBinding</code> would look different:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">ou-cluster-admins</span>
<span class="hljs-attr">subjects:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">https://k8sou.apps.192-168-2-131.nip.io/auth/idp/k8sIdp#mmosley</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
<span class="hljs-attr">roleRef:</span>
  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-admin</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
</code></pre>
<p class="normal">Using the same <code class="inlineCode">ClusterRole</code> as before, this <code class="inlineCode">ClusterRoleBinding</code> will assign the <code class="inlineCode">cluster-admin</code> privileges only to my testing user.</p>
<p class="normal">The first issue to point out is that the user has the URL of our <strong class="keyWord">OpenID Connect</strong> issuer in front of the username. When OpenID Connect was first introduced, it was thought that Kubernetes would integrate with multiple identity providers and different types of identity providers, so the developers wanted you to be able to easily distinguish between users from different identity sources. For instance, <code class="inlineCode">mmosley</code> in domain 1 is a different user than <code class="inlineCode">mmosley</code> in domain 2. To ensure that a user’s identity doesn’t collide with another user across identity providers, Kubernetes requires the identity provider’s issuer to be prepended to your username. This rule doesn’t apply if the username claim defined in your API server flags is <code class="inlineCode">mail</code>. It also doesn’t apply if you’re using certificates or impersonation.</p>
<p class="normal">Beyond the inconsistent implementation requirements, this approach can cause problems in a few ways:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Changing your identity provider URL</strong>: Today, you’re using an identity provider at one URL, but tomorrow you decide to move it. Now, you need to go through every <code class="inlineCode">ClusterRoleBinding</code> and update them.</li>
<li class="bulletList"><strong class="keyWord">Audits</strong>: You can’t query for all <code class="inlineCode">RoleBindings</code> associated with a user. You need to instead enumerate every binding.</li>
<li class="bulletList"><strong class="keyWord">Large bindings</strong>: Depending on how many users you have, your bindings can become quite large and difficult to track.</li>
</ul>
<p class="normal">While there<a id="_idIndexMarker781"/> are tools you can use to help manage these issues, it’s much easier to associate your bindings with groups instead of individual users. You could use the <code class="inlineCode">mail</code> attribute to avoid the URL prefix, but that is considered an anti-pattern and will result in equally difficult changes to your cluster if an email address changes for any reason.</p>
<p class="normal">So far in this chapter, we have learned how to define access policies and map those policies to enterprise users. Next, we need to determine how clusters will be divided into tenants.</p>
<h1 class="heading-1" id="_idParaDest-286">Implementing namespace multi-tenancy</h1>
<p class="normal">Clusters deployed for <a id="_idIndexMarker782"/>multiple stakeholders, or tenants, should be divided up by namespace. This is the boundary that was designed in Kubernetes from the very beginning. When deploying namespaces, there are generally two <code class="inlineCode">ClusterRoles</code> that are assigned to users in the namespace:</p>
<ul>
<li class="bulletList"><code class="inlineCode">admin</code>: This aggregated <code class="inlineCode">ClusterRole</code> provides access to every verb and nearly every resource that ships with Kubernetes, making the <code class="inlineCode">admin</code> user the ruler of their namespace. The exception to this is any namespace-scoped object that could affect the entire cluster, such as <code class="inlineCode">ResourceQuotas</code>.</li>
<li class="bulletList"><code class="inlineCode">edit</code>: Similar to <code class="inlineCode">admin</code>, but without the ability to create RBAC <code class="inlineCode">Roles</code> or <code class="inlineCode">RoleBindings</code>.</li>
</ul>
<p class="normal">It’s important to note that the <code class="inlineCode">admin</code> <code class="inlineCode">ClusterRole</code> can’t make changes to the namespace object by itself. Namespaces are cluster-wide resources, so they can only be assigned permissions via a <code class="inlineCode">ClusterRoleBinding</code>.</p>
<p class="normal">Depending on your strategy for multi-tenancy, the <code class="inlineCode">admin</code> <code class="inlineCode">ClusterRole</code> may not be appropriate. The ability to generate RBAC <code class="inlineCode">Role</code> and <code class="inlineCode">RoleBinding</code> objects means that a namespace admin may grant themselves the ability to change resource quotas. This is where RBAC tends to fall apart and needs some additional options:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Don’t grant access to Kubernetes</strong>: Many cluster owners want to keep Kubernetes out of the hands of their users and limit their interaction with external CI/CD tools. This works well with microservices but begins to fall apart on multiple lines. First, more legacy applications being moved into Kubernetes means more legacy administrators needing to directly access their namespace. Second, if the Kubernetes team keeps users out of the clusters, they are now responsible. The people who own Kubernetes may not want to be the reason things aren’t happening the way application owners want them to and, often, the application owners want to be able to control their<a id="_idIndexMarker783"/> own infrastructure to ensure they can handle any situation that impacts their own performance.</li>
<li class="bulletList"><strong class="keyWord">Treat access as privileged</strong>: Most enterprises require a privileged user to access infrastructure. This is typically done using a privileged access model where an admin has a separate account that needs to be “checked out” in order to use it and is only authorized at certain times, as approved by a “change board” or process. The use of these accounts is closely monitored. This is a good approach if you already have a system in place, especially one that integrates with your enterprise’s central authentication system.</li>
<li class="bulletList"><strong class="keyWord">Give each tenant a cluster</strong>: This model moves multi-tenancy from the cluster to the infrastructure layer. You haven’t eliminated the problem, only moved where it is addressed. This can lead to sprawl that becomes unmanageable and costs can skyrocket depending on how you are implementing Kubernetes. In <em class="chapterRef">Chapter 9</em>, <em class="italic">Building Multitenant Clusters with vClusters</em>, we’ll explore how we can give each tenant its own cluster without having to worry about the sprawl as much.</li>
<li class="bulletList"><strong class="keyWord">Admission controllers</strong>: These augment RBAC by limiting which objects can be created. For instance, an admission controller can decide to block an RBAC policy from being created, even if RBAC explicitly allows it. This topic will be covered<a id="_idIndexMarker784"/> in <em class="chapterRef">Chapter 11</em>, <em class="italic">Extending Security Using Open Policy Agent</em>.</li>
</ul>
<p class="normal">In addition to authorizing access to namespaces and resources, a multi-tenant solution needs to know how to provision tenants. This topic will be covered in the final chapters – <em class="chapterRef">Chapter 18</em>, <em class="italic">Provisioning a Multitenant Platform</em>, and <em class="chapterRef">Chapter 19</em>, <em class="italic">Building a Developer Portal</em>.</p>
<p class="normal">Now that we have a strategy for implementing authorization policies, we’ll need a way to debug those policies as we create them and also to know when those policies are violated. Kubernetes provides an audit capability that will be the focus of the next section, where we will add the audit log to our KinD cluster and debug the implementation of RBAC policies.</p>
<h1 class="heading-1" id="_idParaDest-287">Kubernetes auditing</h1>
<p class="normal">The Kubernetes audit<a id="_idIndexMarker785"/> log is where you track what is happening in your cluster from an API perspective. It’s in JSON format, which makes reading it directly more difficult, but makes it much easier to parse using tools such as OpenSearch. In <em class="chapterRef">Chapter 15</em>, <em class="italic">Managing Clusters and Workloads</em>, we will cover how to create a full logging system using the <strong class="keyWord">OpenSearch</strong> stack.</p>
<h2 class="heading-2" id="_idParaDest-288">Creating an audit policy</h2>
<p class="normal">A policy file<a id="_idIndexMarker786"/> is used to control what events are recorded and where to store the logs, which can be a standard log file or a webhook. We have included an example audit policy in the <code class="inlineCode">chapter7</code> directory of the GitHub repository, and we will apply it to the KinD cluster that we have been using throughout the book.</p>
<p class="normal">An <strong class="keyWord">audit policy</strong> is a<a id="_idIndexMarker787"/> collection of rules that tell the API server which API calls to log and how. When Kubernetes parses the policy file, all rules are applied in order and only the initial matching policy event will be applied. If you have more than one rule for a certain event, you may not receive the expected data in your log files. For this reason, you need to be careful that your events are created correctly.</p>
<p class="normal">Policies use the <code class="inlineCode">audit.k8s.io</code> API and the manifest kind of <code class="inlineCode">Policy</code>. The following example shows the beginning of a <a id="_idIndexMarker788"/>policy file:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">audit.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Policy</span>
<span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">level:</span> <span class="hljs-string">Request</span>
    <span class="hljs-attr">userGroups:</span> [<span class="hljs-string">"system:nodes"</span>]
    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">"update"</span>,<span class="hljs-string">"patch"</span>]
    <span class="hljs-attr">resources:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">group:</span> <span class="hljs-string">""</span> <span class="hljs-comment"># core</span>
        <span class="hljs-attr">resources:</span> [<span class="hljs-string">"nodes/status"</span>, <span class="hljs-string">"pods/status"</span>]
    <span class="hljs-attr">omitStages:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"RequestReceived"</span>
</code></pre>
<p class="normal">While a policy<a id="_idIndexMarker789"/> file may look like a standard Kubernetes manifest, you do not apply it using <code class="inlineCode">kubectl</code>. A policy file is used with the <code class="inlineCode">--audit-policy-file</code> API flag on the API server(s). This will be explained in the <em class="chapterRef">Enabling auditing on a cluster</em> section.</p>
<p class="normal">To understand the rule and what it will log, we will go through each section in detail.</p>
<p class="normal">The first section of the rule is <code class="inlineCode">level</code>, which determines the type of information that will be logged for the event. There are four levels that can be assigned to events:</p>
<figure class="mediaobject"><img alt="Table 8.1 – Kubernetes auditing levels " height="200" src="../Images/B21165_Table_07_01.png" width="757"/></figure>
<p class="packt_figref">Table 7.1: Kubernetes auditing levels</p>
<p class="normal">The <code class="inlineCode">userGroups</code>, <code class="inlineCode">verbs</code>, and <code class="inlineCode">resources</code> values tell the API server the object and action that will trigger the auditing event. In this example, only requests from <code class="inlineCode">system:nodes</code> that attempt an action of <code class="inlineCode">update</code> or <code class="inlineCode">patch</code> on a <code class="inlineCode">node/status</code> or <code class="inlineCode">pod/status</code> on the <code class="inlineCode">core</code> API will create an event.</p>
<p class="normal"><code class="inlineCode">omitStages</code> tells the API server to skip any logging events during a stage, which helps you limit the amount of data that is logged. There are four stages that an API request goes through:</p>
<figure class="mediaobject"><img alt="Table 8.2 – Auditing stages " height="234" src="../Images/B21165_Table_07_02.png" width="793"/></figure>
<p class="packt_figref">Table 7.2: Auditing stages</p>
<p class="normal">In our example, we<a id="_idIndexMarker790"/> have set the event to ignore the <code class="inlineCode">RequestReceived</code> event, which tells the API server not to log any data for the incoming API request.</p>
<p class="normal">Every organization has its own auditing policy, and policy files can become long and complex. Don’t be afraid to set up a policy that logs everything until you get a handle on the types of events that you can create. Logging everything is not a good practice since the log files become very large. Even when pushing logs into an external system, like <strong class="keyWord">OpenSearch</strong>, there’s still a cost in processing and management. Fine-tuning an audit policy is a skill that is learned over time and as you learn more about the API server, you will start to learn what events are most valuable to audit.</p>
<p class="normal">Policy files are just the start of enabling cluster auditing, and now that we have an understanding of the policy file, let’s explain how to enable auditing on a cluster.</p>
<h2 class="heading-2" id="_idParaDest-289">Enabling auditing on a cluster</h2>
<p class="normal">Enabling <a id="_idIndexMarker791"/>auditing is specific to each distribution of Kubernetes. In this section, we<a id="_idIndexMarker792"/> will enable the audit log in KinD to understand the low-level steps. As a quick refresher, the finished product of the last chapter was a KinD cluster with impersonation enabled (instead of directly integrating with OpenID Connect). The rest of the steps and examples in this chapter assume this cluster is being used. Start with a fresh cluster and deploy <strong class="keyWord">OpenUnison</strong> with <a id="_idIndexMarker793"/>impersonation from <em class="chapterRef">Chapter 6</em>:</p>
<pre class="programlisting con"><code class="hljs-con">cd Kubernetes-An-Enterprise-Guide-Third-Edition/chapter2
kind delete cluster -n cluster01
./create-cluster.sh
cd  ../chapter6/user-auth
./deploy_openunison_imp_impersonation.sh
</code></pre>
<p class="normal">Next, we’re<a id="_idIndexMarker794"/> going to configure the API server to send audit log<a id="_idIndexMarker795"/> data to a file. This is more complex than setting a switch because kubeadm, the installer that KinD is built on, runs the API server as a static pod(s). The API server is a container inside of Kubernetes! This means that in order for us to tell the API server where to write log data to, we first have to have storage to write it to and then configure the API server’s pod to use that location as a volume. We’re going to walk through this process manually to give you experience with modifying the API server’s context.</p>
<p class="normal">You can follow the steps in this section manually or you can execute the included script, <code class="inlineCode">enable-auditing.sh</code>, in the <code class="inlineCode">chapter7</code> directory of the GitHub repository:</p>
<ol>
<li class="numberedList" value="1">First, copy the example audit policy from the <code class="inlineCode">chapter7 </code>directory to the API server:
        <pre class="programlisting con-one"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cd</span><span class="language-bash"> chapter7</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">docker </span><span class="hljs-con-built_in">exec</span><span class="language-bash"> -ti cluster01-control-plane </span><span class="hljs-con-built_in">mkdir</span><span class="language-bash"> /etc/kubernetes/audit</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">docker </span><span class="hljs-con-built_in">cp</span><span class="language-bash"> cm/k8s-audit-policy.yaml cluster01-control-plane:/etc/kubernetes/audit/</span>
</code></pre>
</li>
<li class="numberedList">Next, create the directories to store the audit log and policy configuration on the API server. We will <code class="inlineCode">exec</code> into the container since we need to modify the API server file in the next step:
        <pre class="programlisting con-one"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">docker </span><span class="hljs-con-built_in">exec</span><span class="language-bash"> -ti cluster01-control-plane </span><span class="hljs-con-built_in">mkdir</span><span class="language-bash"> /var/log/k8s</span>
</code></pre>
</li>
</ol>
<p class="normal-one">At this point, you have the audit policy on the API server and you can enable the API options to use the file.</p>
<ol>
<li class="numberedList" value="3">On the API server, edit the <code class="inlineCode">kubeadm</code> configuration file (you will need to install an editor such as vi by running <code class="inlineCode">apt-get update; apt-get install vim</code>), <code class="inlineCode">/etc/kubernetes/manifests/kube-apiserver.yaml</code>, which is the same file that we updated to enable OpenID Connect. To enable auditing, we need to add three values.</li>
</ol>
<p class="normal-one">It’s important to note that many Kubernetes clusters may only require the file and the API options. We need the second and third steps since we are using a KinD cluster for our testing.</p>
<p class="normal-one">First, add bold command-line flags for the API server that enable the audit logs. Along with the policy file, we can add options to control the log file rotation, retention, and maximum size:</p>
<pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-bullet">-</span> <span class="hljs-string">--tls-private-key-file=/etc/kubernetes/pki/apiserver.key</span>
<span class="code-highlight"><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">--audit-log-path=/var/log/k8s/audit.log</strong></span>
<span class="code-highlight"><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">--audit-log-maxage=1</strong></span>
<span class="code-highlight"><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">--audit-log-maxbackup=10</strong></span>
<span class="code-highlight"><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">--audit-log-maxsize=10</strong></span>
<span class="code-highlight"><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">--audit-policy-file=/etc/kubernetes/audit/k8s-audit-policy.yaml</strong></span>
</code></pre>
<p class="normal-one">Notice that <a id="_idIndexMarker796"/>the option is pointing to the policy file that <a id="_idIndexMarker797"/>you copied over in the previous step.</p>
<ol>
<li class="numberedList" value="4">Next, add the bold directories that store the policy configuration and the resulting logs to the <code class="inlineCode">volumeMounts</code> section:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/ca-certificates</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">usr-share-ca-certificates</span>
  <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span>
<span class="code-highlight"><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-attr-slc">mountPath:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">/var/log/k8s</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-attr-slc">name:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">var-log-k8s</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-attr-slc">readOnly:</strong><strong class="hljs-slc"> </strong><strong class="hljs-literal-slc">false</strong></span>
<span class="code-highlight"><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-attr-slc">mountPath:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">/etc/kubernetes/audit</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-attr-slc">name:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">etc-kubernetes-audit</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-attr-slc">readOnly:</strong><strong class="hljs-slc"> </strong><strong class="hljs-literal-slc">true</strong></span>
</code></pre>
</li>
<li class="numberedList">Finally, add the bold <code class="inlineCode">hostPath</code> configurations to the <code class="inlineCode">volumes</code> section so that Kubernetes knows where to mount the local paths:
        <pre class="programlisting code-one"><code class="hljs-code">  <span class="hljs-bullet">-</span> <span class="hljs-attr">hostPath:</span>
      <span class="hljs-attr">path:</span> <span class="hljs-string">/usr/share/ca-certificates</span>
      <span class="hljs-attr">type:</span> <span class="hljs-string">DirectoryOrCreate</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">usr-share-ca-certificates</span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-attr-slc">hostPath:</strong></span>
<span class="code-highlight"><strong class="hljs-slc">      </strong><strong class="hljs-attr-slc">path:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">/var/log/k8s</strong></span>
<span class="code-highlight"><strong class="hljs-slc">      </strong><strong class="hljs-attr-slc">type:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">DirectoryOrCreate</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-attr-slc">name:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">var-log-k8s</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-attr-slc">hostPath:</strong></span>
<span class="code-highlight"><strong class="hljs-slc">      </strong><strong class="hljs-attr-slc">path:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">/etc/kubernetes/audit</strong></span>
<span class="code-highlight"><strong class="hljs-slc">      </strong><strong class="hljs-attr-slc">type:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">DirectoryOrCreate</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-attr-slc">name:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">etc-kubernetes-audit</strong></span>
</code></pre>
</li>
<li class="numberedList">Save and exit the file.</li>
<li class="numberedList">Like all API <a id="_idIndexMarker798"/>option changes, you need to restart the <a id="_idIndexMarker799"/>API server for the changes to take effect; however, KinD will detect that the file has changed and restart the API server’s pod automatically.</li>
</ol>
<p class="normal-one">Exit the attached shell and check the pods in the <code class="inlineCode">kube-system</code> namespace:</p>
<pre class="programlisting con-one"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">kubectl get pod kube-apiserver-cluster01-control-plane -n kube-system</span>
NAME                                     READY   STATUS       RESTARTS   AGE
kube-apiserver-cluster01-control-plane   1/1     Running      0          47s
</code></pre>
<p class="normal-one">The API server is highlighted to have been running for only 47 seconds, showing that it successfully restarted.</p>
<p class="normal-one">Having verified that the API server is running, let’s look at the audit log to verify that it’s working correctly. To check the log, you can use <code class="inlineCode">docker exec</code> to tail <code class="inlineCode">audit.log</code>:</p>
<pre class="programlisting con-one"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">docker </span><span class="hljs-con-built_in">exec</span><span class="language-bash"> cluster01-control-plane  </span><span class="hljs-con-built_in">tail</span><span class="language-bash"> /var/log/k8s/audit.log</span>
</code></pre>
<p class="normal-one">This command generates the following log data:</p>
<pre class="programlisting con-one"><code class="hljs-con">{"kind":"Event","apiVersion":"audit.k8s.io/v1","level":"Metadata","auditID":"451ddf5d-763c-4d7c-9d89-7afc6232e2dc","stage":"ResponseComplete","requestURI":"/apis/discovery.k8s.io/v1/namespaces/default/endpointslices/kubernetes","verb":"get","user":{"username":"system:apiserver","uid":"7e02462c-26d1-4349-92ec-edf46af2ab31","groups":["system:masters"]},"sourceIPs":["::1"],"userAgent":"kube-apiserver/v1.21.1 (linux/amd64) kubernetes/5e58841","objectRef":{"resource":"endpointslices","namespace":"default","name":"kubernetes","apiGroup":"discovery.k8s.io","apiVersion":"v1"},"responseStatus":{"metadata":{},"code":200},"requestReceivedTimestamp":"2021-07-12T08:53:55.345776Z","stageTimestamp":"2021-07-12T08:53:55.365609Z","annotations":{"authorization.k8s.io/decision":"allow","authorization.k8s.io/reason":""}}
</code></pre>
<p class="normal">There is quite a<a id="_idIndexMarker800"/> bit of information in this JSON, and it would be challenging<a id="_idIndexMarker801"/> to find a specific event by looking at a log file directly. Luckily, now that you have auditing enabled, you can forward events to a central logging server. We will do this in <em class="chapterRef">Chapter 15</em>, <em class="italic">Monitoring Clusters and Workloads with Prometheus</em>, where we will deploy an <strong class="keyWord">EFK</strong> stack.</p>
<p class="normal">Now that we have auditing enabled, the next step is to practice debugging RBAC policies.</p>
<h1 class="heading-1" id="_idParaDest-290">Using audit2rbac to debug policies</h1>
<p class="normal">There is a<a id="_idIndexMarker802"/> tool called <code class="inlineCode">audit2rbac</code> that can reverse-engineer<a id="_idIndexMarker803"/> errors in the audit log into RBAC policy objects. In this section, we’ll use this tool to generate an RBAC policy after discovering that one of our users can’t perform an action they need to be able to do. This is a typical RBAC debugging process and learning how to use this tool can save you hours trying to isolate RBAC issues:</p>
<ol>
<li class="numberedList" value="1">In the previous chapter, a generic RBAC policy was created to allow all members of the <code class="inlineCode">cn=k8s-cluster-admins,ou=Groups,DC=domain,DC=com</code> group to be administrators in our cluster. If you’re logged into OpenUnison, log out.</li>
<li class="numberedList">Now, log in again with the username <code class="inlineCode">jjackson</code> and the password <code class="inlineCode">start123</code>.</li>
<li class="numberedList">Next, click on <strong class="screenText">Sign In</strong>. Once you’re logged in, go to the dashboard. Just as when OpenUnison was first deployed, there won’t be any namespaces or other information because the RBAC policy for cluster administrators doesn’t apply anymore.</li>
<li class="numberedList">Next, copy your <code class="inlineCode">kubectl</code> configuration from the token screen, making sure to paste it into a window that isn’t your main KinD terminal so you do not overwrite your master configuration.</li>
<li class="numberedList">Once your tokens are set, attempt to create a namespace called <code class="inlineCode">not-going-to-work</code>:
        <pre class="programlisting con-one"><code class="hljs-con">PS C:\Users\mlb&gt; kubectl create ns not-going-to-work
Error from server (Forbidden): namespaces is forbidden: User "jjackson" cannot create resource "namespaces" in API group "" at the cluster scope
</code></pre>
</li>
</ol>
<p class="normal-one">There’s enough information here to reverse-engineer an RBAC policy.</p>
<ol>
<li class="numberedList" value="6">In order to eliminate this error message, create a <code class="inlineCode">ClusterRole</code> with a resource for <code class="inlineCode">"namespaces"</code>, <code class="inlineCode">apiGroups</code> set to <code class="inlineCode">""</code>, and a verb of <code class="inlineCode">"create"</code> using your KinD administrative user:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-create-ns</span>
<span class="hljs-attr">rules:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">""</span>]
  <span class="hljs-attr">resources:</span> [<span class="hljs-string">"namespaces"</span>]
  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">"create"</span>]
</code></pre>
</li>
<li class="numberedList">Next, create <a id="_idIndexMarker804"/>a <code class="inlineCode">ClusterRoleBinding</code> for<a id="_idIndexMarker805"/> the user and this <code class="inlineCode">ClusterRole</code>:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-create-ns</span>
<span class="hljs-attr">subjects:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">jjackson</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
<span class="hljs-attr">roleRef:</span>
  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-create-ns</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
</code></pre>
</li>
<li class="numberedList">Once the <code class="inlineCode">ClusterRole</code> and <code class="inlineCode">ClusterRoleBinding</code> are created, try running the command again, and it will work:
        <pre class="programlisting con-one"><code class="hljs-con">PS C:\Users\mlb&gt; kubectl create ns not-going-to-work
namespace/not-going-to-work created
</code></pre>
</li>
</ol>
<p class="normal">Unfortunately, this is not likely how most RBAC debugging will go. Most of the time, debugging RBAC will not be this clear or simple. Typically, debugging RBAC means getting unexpected error messages between systems. For instance, if you’re deploying the <code class="inlineCode">kube-prometheus</code> project for monitoring, you’ll generally want to monitor by <code class="inlineCode">Service</code> objects, not by explicitly naming Pods. In order to do this, the Prometheus <code class="inlineCode">ServiceAccount</code> needs to be able to list the <code class="inlineCode">Service</code> objects in the namespace of the service you want to monitor. Prometheus won’t tell you this needs to happen; you just won’t see your services listed. A better way to debug is to use a tool that knows how to read the audit log and can reverse-engineer a set of roles and bindings based on the failures in the log.</p>
<p class="normal">The <code class="inlineCode">audit2rbac</code> tool is the best way to do this. It will read the audit log and give you a set of policies that will work. It may not be the exact policy that’s needed, but it will provide a good starting point. Let’s try it out:</p>
<ol>
<li class="numberedList" value="1">First, attach <a id="_idIndexMarker806"/>a shell to the <code class="inlineCode">control-plane</code> container of your cluster <a id="_idIndexMarker807"/>and download the tool from GitHub (<a href="https://github.com/liggitt/audit2rbac/releases"><span class="url">https://github.com/liggitt/audit2rbac/releases</span></a>):
        <pre class="programlisting con-one"><code class="hljs-con">root@cluster01-control-plane:/# curl -L https://github.com/liggitt/audit2rbac/releases/download/v0.8.0/audit2rbac-linux-amd64.tar.gz 2&gt;/dev/null &gt; audit2rbac-linux-amd64.tar.gz
root@cluster01-control-plane:/# tar -xvzf audit2rbac-linux-amd64.tar.gz
</code></pre>
</li>
<li class="numberedList">Before using the tool, make sure to close the browser with the Kubernetes dashboard in it to avoid polluting the logs. Also, remove the <code class="inlineCode">cluster-create-ns</code> <code class="inlineCode">ClusterRole</code> and <code class="inlineCode">ClusterRoleBinding</code> created previously. Finally, try creating the <code class="inlineCode">still-not-going-to-work</code> namespace:
        <pre class="programlisting con-one"><code class="hljs-con">PS C:\Users\mlb&gt; kubectl create ns still-not-going-to-work
Error from server (Forbidden): namespaces is forbidden: User "jjackson" cannot create resource "namespaces" in API group "" at the cluster scope
</code></pre>
</li>
<li class="numberedList">Next, use the <code class="inlineCode">audit2rbac</code> tool to look for any failures for your test user:
        <pre class="programlisting con-one"><code class="hljs-con">root@cluster01-control-plane:/# ./audit2rbac --filename=/var/log/k8s/audit.log  --user=jjackson
Opening audit source...
Loading events...
Evaluating API calls...
Generating roles...
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    audit2rbac.liggitt.net/version: v0.8.0
  labels:
    audit2rbac.liggitt.net/generated: "true"     audit2rbac.liggitt.net/user: jjackson
  name: audit2rbac:jjackson
rules:
- apiGroups:
  - ""   resources:
  - namespaces
  verbs:
  - create
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations:
    audit2rbac.liggitt.net/version: v0.8.0
  labels:
    audit2rbac.liggitt.net/generated: "true"     audit2rbac.liggitt.net/user: jjackson
  name: audit2rbac:jjackson
roleRef:|
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole|
  name: audit2rbac:jjackson
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: jjackson
Complete!
</code></pre>
</li>
<li class="numberedList">This<a id="_idIndexMarker808"/> command generated a policy that will allow the test user <a id="_idIndexMarker809"/>to create namespaces. This becomes an anti-pattern, though, of explicitly authorizing access to users.</li>
<li class="numberedList">In order to better leverage this policy, it would be better to use our group:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">create-ns-audit2rbac</span>
<span class="hljs-attr">rules:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">""</span>
  <span class="hljs-attr">resources:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">namespaces</span>
  <span class="hljs-attr">verbs:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">create</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">create-ns-audit2rbac</span>
<span class="hljs-attr">roleRef:</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">create-ns-audit2rbac</span>
<span class="hljs-attr">subjects:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
  <span class="hljs-attr">kind:</span> <span class="hljs-string">Group</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">cn=k8s-create-ns,ou=Groups,DC=domain,DC=com</span>
</code></pre>
</li>
</ol>
<p class="normal">The major<a id="_idIndexMarker810"/> change is highlighted. Instead of referencing the user directly, the <code class="inlineCode">ClusterRoleBinding</code> is now referencing the <code class="inlineCode">cn=k8s-create-ns,ou=Groups,DC=domain,DC=com</code> group <a id="_idIndexMarker811"/>so that any member of that group can now create namespaces.</p>
<h1 class="heading-1" id="_idParaDest-291">Summary</h1>
<p class="normal">This chapter’s focus was on <strong class="keyWord">RBAC</strong> policy creation and debugging. We explored how Kubernetes defines authorization policies and how it applies those policies to enterprise users. We also looked at how these policies can be used to enable multi-tenancy in your cluster. Finally, we enabled the audit log in our KinD cluster and learned how to use the <code class="inlineCode">audit2rbac</code> tool to debug RBAC issues.</p>
<p class="normal">Using Kubernetes’ built-in RBAC policy management objects lets you enable access that’s needed for operational and development tasks in your clusters. Knowing how to design policies can help limit the impact of issues, providing the confidence to let users do more on their own.</p>
<p class="normal">In the next chapter, <em class="chapterRef">Chapter 8</em>, <em class="italic">Managing Secrets</em>, we’ll learn how Kubernetes manages secret data and how you should integrate external secrets into your clusters using HashiCorp Vault and the External Secrets Operator.</p>
<h1 class="heading-1" id="_idParaDest-292">Questions</h1>
<ol>
<li class="numberedList" value="1">True or false – ABAC is the preferred method of authorizing access to Kubernetes clusters.<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">True</li>
<li class="alphabeticList level-2">False</li>
</ol>
</li>
<li class="numberedList">What are the three components of a <code class="inlineCode">Role</code>?<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">Subject, noun, and verb</li>
<li class="alphabeticList level-2">Resource, action, and group</li>
<li class="alphabeticList level-2"><code class="inlineCode">apiGroups</code>, resources, and verbs</li>
<li class="alphabeticList level-2">Group, resource, and sub-resource</li>
</ol>
</li>
<li class="numberedList">Where can you go to look up resource information?<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">Kubernetes API reference</li>
<li class="alphabeticList level-2">The library</li>
<li class="alphabeticList level-2">Tutorials and blog posts</li>
</ol>
</li>
<li class="numberedList">How can you reuse <code class="inlineCode">Roles</code> across namespaces?<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">You can’t; you need to re-create them.</li>
<li class="alphabeticList level-2">Define a <code class="inlineCode">ClusterRole</code> and reference it in each namespace as a <code class="inlineCode">RoleBinding</code>.</li>
<li class="alphabeticList level-2">Reference the <code class="inlineCode">Role</code> in one namespace with the <code class="inlineCode">RoleBindings</code> of other namespaces.</li>
<li class="alphabeticList level-2">None of the above.</li>
</ol>
</li>
<li class="numberedList">How should bindings reference users?<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">Directly, listing every user.</li>
<li class="alphabeticList level-2"><code class="inlineCode">RoleBindings</code> should only reference service accounts.</li>
<li class="alphabeticList level-2">Only <code class="inlineCode">ClusterRoleBindings</code> should reference users.</li>
<li class="alphabeticList level-2">Whenever possible, <code class="inlineCode">RoleBindings</code> and <code class="inlineCode">ClusterRoleBindings</code> should reference groups.</li>
</ol>
</li>
<li class="numberedList">True or false – RBAC can be used to authorize access to everything except for one resource.<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">True</li>
<li class="alphabeticList level-2">False</li>
</ol>
</li>
<li class="numberedList">True or false – RBAC is the only method of authorization in Kubernetes.<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">True</li>
<li class="alphabeticList level-2">False</li>
</ol>
</li>
</ol>
<h1 class="heading-1" id="_idParaDest-293">Answers</h1>
<ol>
<li class="numberedList" value="1">a: false</li>
<li class="numberedList">b: Resource, action, and group</li>
<li class="numberedList">a: Kubernetes API reference</li>
<li class="numberedList">b: Define a <code class="inlineCode">ClusterRole</code> and reference it in each namespace as a <code class="inlineCode">RoleBinding</code>.</li>
<li class="numberedList">d: Whenever possible, <code class="inlineCode">RoleBindings</code> and <code class="inlineCode">ClusterRoleBindings</code> should reference groups.</li>
<li class="numberedList">b: False</li>
<li class="numberedList">b: False</li>
</ol>
<h1 class="heading-1" id="_idParaDest-294">Join our book’s Discord space</h1>
<p class="normal">Join the book’s Discord workspace for a monthly <em class="italic">Ask Me Anything</em> session with the authors:</p>
<p class="normal"><a href="https://packt.link/K8EntGuide"><span class="url">https://packt.link/K8EntGuide</span></a></p>
<p class="normal"><img alt="" height="176" src="../Images/QR_Code965214276169525265.png" width="176"/></p>
</div>
</div></body></html>