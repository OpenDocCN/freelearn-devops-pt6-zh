- en: '*Chapter 7*: Installing and Running Operators with the Operator Lifecycle Manager'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, the Operator development work covered in previous chapters has
    been mostly self-contained. That is, the development and deployment processes
    covered so far have been primarily focused on local environments with relatively
    few external services expected to interact with the Operator we have been writing.
    While these processes are useful (and in some ways essential) to the early design
    of an Operator, there is an expectation for most Operators (and indeed, most software
    projects in general) that they will eventually be exposed to the outside world.
    This chapter will focus on this phase of an Operator's lifespan, wherein the Operator
    is presented and consumed by external users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B18147_01_ePub.xhtml#_idTextAnchor015), *Introduction to the
    Operator Framework*, the three main pillars of the Operator Framework were introduced.
    Several chapters of this book have already been devoted to the first pillar (the
    Operator SDK), but the remaining pillars have yet to be explored in detail. These
    are the **Operator Lifecycle Manager** (**OLM**) and **OperatorHub**. These two
    components of the Operator Framework are the key transitory elements in an Operator''s
    development from an experimental, local prototype to a published, installable
    product. In this chapter, we will cover the necessary steps to graduate from an
    Operator in development to one that is accessible by users, through the following
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OLM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your Operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with OperatorHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By packaging an Operator to be installed and managed by the OLM and then publishing
    that Operator on OperatorHub, we will be leveraging the standard deployment workflow
    that users expect from the Operator Framework. These steps are by no means necessary,
    as we have already shown that it is possible to manually build and deploy an Operator
    without the OLM or OperatorHub. But, it is the goal of this chapter to introduce
    these pillars of the Operator Framework to demonstrate how we can transform an
    Operator into a rich community project.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will continue to work with the nginx Operator that was written
    in [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066), *Developing an Operator
    with the Operator SDK,* and [*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078),
    *Developing an Operator – Advanced Functionality*. It will also assume access
    to a public Docker registry (previously used in [*Chapter 6*](B18147_06_ePub.xhtml#_idTextAnchor090),
    *Building and Deploying Your Operator*), as well as access to a running **Kubernetes**
    cluster. Therefore, the technical requirements of this chapter build upon most
    of the requirements from previous chapters, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to a Kubernetes cluster. It is recommended to use a disposable cluster
    created with a tool such as **kind** or **minikube** (see [*Chapter 6*](B18147_06_ePub.xhtml#_idTextAnchor090),
    *Building and Deploying Your Operator*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `kubectl` binary available on your local system for interacting with the
    Kubernetes cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `operator-sdk` binary available on your local system for deploying the OLM
    and building Operator manifests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker installed and running to build Operator bundle images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GitHub account and familiarity with the GitHub fork and pull request processes
    for submitting a new Operator to OperatorHub (demonstration only).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Code in Action video for this chapter can be viewed at: [https://bit.ly/3PPItsB](https://bit.ly/3PPItsB)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OLM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OLM was introduced in [*Chapter 1*](B18147_01_ePub.xhtml#_idTextAnchor015),
    *Introduction to the Operator Framework,* as a tool for installing and managing
    Operators within a cluster. Its features include the ability to provide control
    over upgrading installed Operators and making these Operators visible to cluster
    users. It also helps maintain cluster stability by enforcing Operator dependencies
    and preventing conflicting APIs from different Operators. This is a brief overview,
    but these features make it a powerful tool for deploying Operators in production
    environments. You can find more details about the OLM's features in the Operator
    Framework documentation at [https://olm.operatorframework.io/docs/#features-provided-by-olm](https://olm.operatorframework.io/docs/#features-provided-by-olm).
  prefs: []
  type: TYPE_NORMAL
- en: While this may make the OLM seem like a complex component to work with, it is
    actually no more than a set of resource manifests that can be installed in a cluster
    similarly to any other component or application (including Operators themselves).
    These resources include various **Pods** (managed by Deployments), **CustomResourceDefinitions**
    (**CRDs**), **namespaces**, **ServiceAccounts**, and **RoleBindings**.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the Operator SDK command-line tools provide simple commands for
    easily installing and interacting with the OLM in a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: So, before it is possible to install Operators with the OLM, we must first install
    the OLM itself. This section will show the steps required to do so. It will also
    demonstrate some additional commands for interacting with the OLM via the command
    line, which will be helpful later on when installing and managing our own Operator.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the OLM in a Kubernetes cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install the OLM, first ensure that you have administrative access to a running
    Kubernetes cluster. Even though using the OLM to manage Operators is an acceptable
    practice for production clusters, it is strongly recommended to use a disposable
    cluster (created with a tool such as kind) while following along with this chapter.
    This makes it easy and affordable to destroy and re-build the cluster from scratch
    if necessary. If you already have a cluster running from a previous chapter, it
    may even be useful to shut down that cluster in order to start fresh (with kind,
    the command to do so is `kind delete cluster`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, invoke the `operator-sdk` binary to install the OLM in your cluster with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command may take a moment to complete, but during that time you will see
    `operator-sdk` fetching the various resource manifests for the OLM and installing
    them in your Kubernetes cluster. Once this is complete, it will also print the
    final list of installed resources. Many of these are either cluster-scoped (such
    as the OLM-specific CRDs) or installed in the newly created `olm` namespace. You
    can see these resources by inspecting that namespace with `kubectl` using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notably, there are five Pods in this namespace that perform the core functions
    of the OLM. These Pods work together to provide the cohesive functionality that
    comprises the OLM, including tracking Operator subscriptions and watching for
    custom resources that indicate Operator installations in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the OLM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Along with `operator-sdk olm install` (which, as the name implies, installs
    the OLM in a cluster), the `operator-sdk` binary also provides two more OLM-specific
    commands: `olm uninstall` and `olm status`. The former will remove the OLM and
    all of its dependent manifests from your cluster, while the latter provides information
    on the current status of the OLM resources in the cluster. For a healthy OLM installation,
    that output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: However, if the OLM was not behaving properly or there were issues with Operators
    in your cluster, this command could be used to debug the cause. For example, you
    can run `kubectl delete crd/operatorgroups.operators.coreos.com` (which deletes
    the `OperatorGroups` CRD installed by the OLM). Following this, running `operator-sdk
    olm status` will show the error `no matches for kind "OperatorGroup" in version
    "operators.coreos.com/v1` next to the `global-operators` and `olm-operators` entries,
    indicating that the CRD is missing in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: This error can be repaired by uninstalling the OLM with `operator-sdk olm uninstall`
    and reinstalling it. Note that uninstalling the OLM does not uninstall any of
    the Operators it manages in the cluster. This is intentional to prevent data loss,
    but it also means that any desire to remove Operators from the cluster cannot
    be done by simply uninstalling the OLM.
  prefs: []
  type: TYPE_NORMAL
- en: Besides installing and checking on the health of the OLM itself, the other way
    to interact with it is by installing and managing Operators. But first, the Operator
    must be prepared in a way that the OLM will understand. This is called **the Operator's
    bundle**, and we will show how to generate it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Running your Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18147_06_ePub.xhtml#_idTextAnchor090), *Building and Deploying
    Your Operator*, we demonstrated ways to build and run an Operator manually by
    either compiling locally or building a Docker image to run in a Kubernetes cluster.
    But, neither of these methods is directly compatible with the OLM, so in order
    to provide an Operator that can be installed by the OLM, the Operator must be
    prepared with a bundle that contains metadata about the Operator in a format that
    the OLM understands. Then, this bundle can be passed to the OLM, which will handle
    the rest of the installation and life cycle management of the Operator.
  prefs: []
  type: TYPE_NORMAL
- en: Generating an Operator's bundle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Operator's bundle consists of various manifests that describe the Operator
    and provide additional metadata, such as its dependencies and APIs. Once created,
    these manifests can be compiled into a **bundle image**, which is a deployable
    container image that is used by the OLM to install the Operator in a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to generate the bundle manifests is by running `make bundle`.
    This command will ask you to provide some metadata about the Operator and compile
    that input into the output resource manifests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`make bundle` generates a container image name in some fields based on the
    same `IMG` environment variable used in [*Chapter 6*](B18147_06_ePub.xhtml#_idTextAnchor090),
    *Building and Deploying Your Operator*. Ensure that this environment variable
    is still set when generating the bundle, or that it is otherwise being passed
    to the `make bundle` command when it is invoked.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block shows the output of `make bundle`. In this case, we will
    fill out the prompts for our nginx Operator with the company name, `MyCompany`,
    as well as some additional keywords and contact information for the maintainers
    of the Operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'During this step, the generator will request the following inputs one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Display name for the operator`: This is the name that will be used for displaying
    the Operator on resources such as OperatorHub. So, it should be readable and clear
    with proper capitalization. For example, we have chosen `Nginx Operator`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Description for the operator`: This field provides a description of the Operator
    and its functionality. Similar to the display name, this is intended for users
    to see. Therefore, it should also be clear and thorough to describe the Operator''s
    functionality in detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Provider''s name for the operator`: This is the name of the provider, or developer,
    of the Operator. For a single developer, it can simply be your name. Or, for larger
    organizations, it could be a company or department name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Any relevant URL for the provider name`: This is the opportunity for developers
    to provide an external URL to find more information about the developer. This
    could be a personal blog, GitHub account, or corporate website.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Comma-separated list of keywords for your operator`: This is a list of keywords
    that can help users categorize and find your Operator. For this example, we have
    chosen `nginx,tutorial`, but you could just as easily provide a different list,
    such as `deployment,nginx,high availability,metrics`. This gives more insight
    into the key functionality we have developed for this Operator. Note also that
    the list is comma-separated, so `high availability` is one keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Comma-separated list of maintainers and their emails`: Finally, this section
    is a chance to provide the contact information for the maintainers of the Operator.
    This gives users information on who to contact for support or bug reporting. However,
    it can be useful for the developer''s privacy to provide a corporate address rather
    than personal contact information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These fields correspond to matching fields in the Operator's **cluster service
    version** (**CSV**) file (the CSV was briefly described in [*Chapter 1*](B18147_01_ePub.xhtml#_idTextAnchor015),
    *Introduction to the Operator Framework*, and will be explained in more detail
    later in this chapter under *Working with OperatorHub*). You can find more information
    about how each of these fields is used in the Operator Framework documentation
    at [https://sdk.operatorframework.io/docs/olm-integration/generation/#csv-fields](https://sdk.operatorframework.io/docs/olm-integration/generation/#csv-fields).
  prefs: []
  type: TYPE_NORMAL
- en: The CSV is one of several new files created in the project after running `make
    bundle`. The majority of these new files are created under a new directory called
    `bundle/`. There is also a new file at the root of the project called `bundle.Dockerfile`,
    which is used to compile the manifests into the bundle image.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the bundle files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The files generated by `make bundle` contain metadata about the Operator that
    can be used by the OLM to install and manage the Operator, as well as OperatorHub,
    to provide information to users about the Operator and its dependencies and capabilities.
    Within the `bundle/` directory are three subdirectories that contain the following
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tests/`: These are configuration files for running scorecard tests, which
    are a series of tests designed to validate the Operator''s bundle (see [https://sdk.operatorframework.io/docs/testing-operators/scorecard](https://sdk.operatorframework.io/docs/testing-operators/scorecard)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata/`: This contains an `annotations.yaml` file, which provides the OLM
    with information about an Operator''s version and dependencies. The annotations
    in this file must be the same as the labels specified in `bundle.Dockerfile` (more
    on that file shortly), and should usually not be modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manifests/`: This directory contains various manifests required by your operator,
    including the Operator''s CRD and metrics-related resources (if applicable). Most
    notably, however, is the CSV, which contains the bulk of the Operator''s metadata.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Operator''s CSV is the most interesting of these files, as it contains
    much of the information used by the OLM to process the creation of the Operator,
    as well as OperatorHub, to display important information to users about the Operator.
    The one created for our nginx Operator is named `nginx-operator.clusterserviceversion.yaml`,
    and contains the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Metadata, including a sample custom resource object (to be created by the user
    for configuring the Operator) and its capability level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A specification field with the Operator''s description, display name, display
    icon (if provided), and related CRDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Installation instructions, including the cluster permissions and Deployment
    specification for the Operator Pod (omitted here for brevity).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The install modes for the Operator, showing which namespace installation strategies
    it supports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Keywords, maintainer information, provider URL, and version (as provided when
    running `make bundle`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Together, this information can be packaged together to provide enough data for
    the OLM to deploy and manage the Operator in a cluster. That package is known
    as the bundle image.
  prefs: []
  type: TYPE_NORMAL
- en: Building a bundle image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the bundle manifests have been generated, the bundle image can be built
    by calling `make bundle-build`. This command builds a Docker container based on
    the `bundle.Dockerfile` file that was generated earlier by `make bundle`. That
    `Dockerfile` file contains the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the main `Dockerfile` file used to compile the Operator image in
    [*Chapter 6*](B18147_06_ePub.xhtml#_idTextAnchor090), *Building and Deploying
    Your Operator*, one of the key steps in this Dockerfile's build is to copy the
    essential bundle files from the `bundle/` directory into its own image (highlighted
    in the preceding code block). It also labels the resulting image with various
    metadata about the operator, its versions, and the tools used to build it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `make bundle-build` produces the following build log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, note that the name of the new container image is `example.com/nginx-operator-bundle`,
    which you can confirm by running `docker images`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This generic name is used because `make bundle-build` depends on a different
    environment variable than the `IMG` variable that was used earlier to build the
    Operator image manually (and generate the bundle manifests). To set a custom bundle
    image name, either tag the generated image or re-run `make bundle-build` with
    the `BUNDLE_IMG` variable set. An example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will generate the bundle image with the name `docker.io/myregistry/nginx-bundle:v0.0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing a bundle image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that in [*Chapter 6*](B18147_06_ePub.xhtml#_idTextAnchor090), *Building
    and Deploying Your Operator*, it was necessary to not only build the container
    image for the Operator but also push it to a publicly accessible registry. This
    made the image available to our Kubernetes cluster. Similarly, the bundle image
    must also be accessible by the cluster (and the OLM). For this reason, we must
    also push the bundle image to a registry so that the OLM can pull it into the
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Operator SDK makes this step easy with the `make bundle-push` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This command simply calls `docker push`, but it inherits the environment variables
    that have been set and used in previous commands (for example, `BUNDLE_IMG`).
    This convenience helps reduce the chance of making a mistake and pushing the wrong
    image name to the wrong registry.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an Operator bundle with the OLM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With a bundle image built and pushed to an accessible registry, it is simple
    to deploy the Operator from its bundle with the `operator-sdk run bundle` command.
    For example, we can now deploy the nginx Operator bundle from the previous section
    by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This command may take a few minutes to succeed. However, if the Operator's `ClusterServiceVersion`
    object fails to install, double-check that you have followed the steps to install
    **kube-prometheus** in the cluster, as detailed in [*Chapter 6*](B18147_06_ePub.xhtml#_idTextAnchor090),
    *Building and Deploying Your Operator*. If the Operator bundle has been built
    to include references to Prometheus resources, and these resources are not present
    in the cluster, this can cause the Operator's installation to fail.
  prefs: []
  type: TYPE_NORMAL
- en: This command creates the resources necessary for the OLM to install the nginx
    Operator using only the information in the Operator's bundle, including `CatalogSource`,
    `OperatorGroup`, `Subscription`, and `InstallPlan`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Operator can then be uninstalled using the `operator-sdk cleanup <packageName>`
    command, where `<packageName>` is defined in the Operator''s `PROJECT` file as
    `projectName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the normal development workflow for building and deploying Operators
    with the OLM manually. However, there is another source for Operators to install
    in a cluster. This is **OperatorHub**, and it is the focus of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with OperatorHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any successful open source project requires a dedicated community of users
    and developers to help the project''s ecosystem thrive. The Operator Framework
    is no different, and at the center of this community is the Operator catalog of
    [https://operatorhub.io/](https://operatorhub.io/). In fact, this centralization
    is the exact goal of OperatorHub, as stated on [https://operatorhub.io/about](https://operatorhub.io/about):'
  prefs: []
  type: TYPE_NORMAL
- en: While there are several approaches to implement Operators yielding the same
    level of integration with Kubernetes, what has been missing is a central location
    to find the wide array of great Operators that have been built by the community.
    OperatorHub.io aims to be that central location.
  prefs: []
  type: TYPE_NORMAL
- en: Launched in 2019 by a collaborative effort between **Red Hat**, **AWS**, **Google
    Cloud**, and **Microsoft**, OperatorHub has been a driving force in the growth
    and adoption of Kubernetes Operators. As of the time of writing, the OperatorHub
    index contains over 200 Operators (and this number continues to grow). Backed
    by only a public GitHub repository and many volunteer maintainers, the open concept
    of catalog moderation and acceptance of OperatorHub supports the very ideals of
    Kubernetes, by allowing anyone from any organization to contribute their Operator
    to the catalog and make it accessible to all.
  prefs: []
  type: TYPE_NORMAL
- en: In short, OperatorHub makes it easy to promote your own Operators, as well as
    finding and installing Operators developed by other providers. In this section,
    we'll demonstrate how to do both of these by working with the OperatorHub website
    and backend.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Operators from OperatorHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing an Operator from OperatorHub in your own Kubernetes cluster is very
    easy using the catalog on [https://operatorhub.io/](https://operatorhub.io/).
    You can begin by browsing the list of all available Operators, or by searching
    in the text box on the OperatorHub home page. You can also narrow down your search
    by category (available categories include **AI/Machine Learning**, **Big Data**,
    **Cloud Provider**, and **Monitoring**).
  prefs: []
  type: TYPE_NORMAL
- en: 'For an arbitrary example, the **Grafana** Operator can be found under **Monitoring**.
    Grafana is an analytics and monitoring visualization platform that provides rich,
    insightful tools for viewing application health. The following is a screenshot
    showing **Grafana Operator** and others available in the **Monitoring** category
    on OperatorHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Screenshot of the OperatorHub Monitoring category](img/B18147_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Screenshot of the OperatorHub Monitoring category
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the **Grafana Operator** tile opens up the information page for
    this specific Operator. This page includes information such as the Operator''s
    current functionality level in the Capability Model, which versions of the Operator
    have been published, and information about the provider and maintainer of the
    Operator. The following is a screenshot showing what the **Grafana Operator**
    information page looks like on OperatorHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Grafana Operator information page](img/B18147_07_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Grafana Operator information page
  prefs: []
  type: TYPE_NORMAL
- en: 'Also available on this page are installation instructions for this Operator,
    found by clicking the `install` command for this Operator. This is shown in the
    following screenshot of the Grafana Operator installation instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Grafana Operator installation instructions](img/B18147_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Grafana Operator installation instructions
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this command in a terminal produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this, the new namespace, `my-grafana-operator`, has been created
    with the resources necessary for this Operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In addition, this command also created an `OperatorGroup` object and `Subscription`
    object for this Operator. These resource types are CRDs that were installed in
    the cluster by the OLM and implemented by individual Operators to represent their
    installation. The details about what each of these objects does are available
    in the OperatorHub documentation at [https://operatorhub.io/how-to-install-an-operator](https://operatorhub.io/how-to-install-an-operator),
    but in summary, they define the user's (your) intent to install the Operator and
    inform the OLM about the location of the Operator's metadata on OperatorHub. The
    OLM uses this information to create the Deployment, Service, and other resources
    needed for the new Operator.
  prefs: []
  type: TYPE_NORMAL
- en: Once an Operator has been installed, it is usually up to the user to create
    the configuration CRD object for that Operator. With so many different CRDs floating
    around, this can get confusing to keep track of. However, many of these CRDs (such
    as `OperatorGroup` and `Subscription`) are installed and managed automatically
    by tools such as the OLM, and they do not require manual interaction. Generally,
    the user is only concerned with the CRD object for a specific Operator's configuration
    (such as the one that we created for our nginx Operator). Most Operator `README`
    files and OperatorHub descriptions will contain example CRDs and steps to get
    started with each Operator (and it is a good practice to do so with your own Operator
    as well).
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of your own Operator, contributing to the OperatorHub catalog is almost
    as easy as installing Operators from it. In the next section, we'll look at how
    each of these Operators made their way onto OperatorHub and how yours can, too.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting your own Operator to OperatorHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it is not required to publish any Operator publicly, many providers choose
    to do so, both for the benefit of the community and their own users. If the Operator
    you have developed is used to manage an application you offer to your users, public
    availability of the Operator can increase awareness of the application and bolster
    your organization's reputation among the open source community. Offering a free
    Operator shows your users that you are invested in providing a stable product
    with minimal engineering hours required on their part.
  prefs: []
  type: TYPE_NORMAL
- en: What Is Required from Operator SDK Projects?
  prefs: []
  type: TYPE_NORMAL
- en: The Operator SDK, like many Kubernetes projects, is released under the **Apache
    2.0 License**. This gives permissive usability of the project for commercial use,
    distribution, and private use (among other use cases). More information on the
    Operator SDK license is available at [https://github.com/operator-framework/operator-sdk/blob/master/LICENSE](https://github.com/operator-framework/operator-sdk/blob/master/LICENSE).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the nginx Operator that we have been developing throughout this book
    is only intended as a tutorial (and not meant for public use), we cannot demonstrate
    the process for submitting it to OperatorHub. However, the general process for
    submitting an Operator to OperatorHub is outlined at [https://operatorhub.io/contribute](https://operatorhub.io/contribute).
    In broad terms, this involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop an Operator that is ready for publishing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the Operator's bundle, including its CSV and related CRDs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **pull request** (**PR**) against the OperatorHub repository on GitHub
    ([https://github.com/k8s-operatorhub/community-operators](https://github.com/k8s-operatorhub/community-operators))
    with your Operator's metadata.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have been following the steps in this book up until this point, then
    you are already familiar with the first two steps. However, the third step is
    the most important part of submitting to OperatorHub, because the GitHub repository
    represents the entire catalog of Operators listed on OperatorHub. So, without
    the proper PR changes necessary to merge your Operator's information into this
    repository, it will not show up on OperatorHub.
  prefs: []
  type: TYPE_NORMAL
- en: Which OperatorHub Repository is which?
  prefs: []
  type: TYPE_NORMAL
- en: Some outdated documentation that is still available refers to two different
    OperatorHub repository locations, `community-operators` and `upstream-community-operators`,
    which were originally subdirectories of the now-archived OperatorHub repository
    at [https://github.com/operator-framework/community-operators](https://github.com/operator-framework/community-operators).
    The former is a remnant of the initial work done by Red Hat to publish OperatorHub
    (specifically, it refers to a location that was reserved for Operators to be listed
    on an integrated version of OperatorHub within Red Hat's OpenShift distribution
    of Kubernetes). This OpenShift-specific Operator index has since been decoupled
    from the community repository referenced earlier. There is documentation available
    for contributing to the OpenShift catalog for developers who are interested in
    doing so, but this chapter will focus on the community OperatorHub, which is platform-agnostic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to submit your Operator through GitHub are as follows (these steps
    assume some prior familiarity with GitHub and the fork/PR processes involved):'
  prefs: []
  type: TYPE_NORMAL
- en: Fork the OperatorHub repository ([https://github.com/k8s-operatorhub/community-operators](https://github.com/k8s-operatorhub/community-operators))
    into your own GitHub account. This allows you to clone a local copy of the repository
    to your machine and make changes to it that will later be pulled into the upstream
    catalog via your PR.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder for your Operator under the `operators/` directory. It must
    have a unique name from all other Operators (for example, we could create `operators/nginx-operator`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file called `ci.yaml` in this directory. This file defines versioning
    semantics as well as the reviewers allowed to make changes to your Operator (more
    information available at [https://k8s-operatorhub.github.io/community-operators/operator-ci-yaml/](https://k8s-operatorhub.github.io/community-operators/operator-ci-yaml/)).
    A simple `ci.yaml` file looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a directory in your Operator's folder for each version you wish to publish
    (for example, `operators/nginx-operator/0.0.1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the contents of the `bundle` directory from your Operator's project into
    the new version folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, copy the `bundle.Dockerfile` that was generated at your Operator's project
    root into the version folder.
  prefs: []
  type: TYPE_NORMAL
- en: Commit and push the changes to a new branch of your forked OperatorHub repository
    on GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate back to the upstream OperatorHub repository's PR page ([https://github.com/k8s-operatorhub/community-operators/pulls](https://github.com/k8s-operatorhub/community-operators/pulls))
    and click **New pull request**. Choose your fork and branch to merge into the
    upstream repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Read the PR template description and ensure that you have followed all of the
    steps outlined. These prerequisite steps help expedite the review and approval
    process of your Operator''s PR and include the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reviewing the community contribution guidelines
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing your Operator in a local cluster
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying your Operator's metadata aligns with the standards of OperatorHub
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensuring your Operator's description and versioning schema are sufficient for
    your users
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have reviewed the pre-submission checks in the PR template, submit
    your request. At this point, automated checks will validate your Operator's metadata
    to ensure it passes the quality thresholds for submission (and report any problems
    in a GitHub comment). If you need to make any changes to your submission in order
    for it to pass these checks, you can simply push the changes to your forked branch
    of the OperatorHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Once your PR passes the pre-submission checks, it should automatically merge
    your changes into the upstream repository. Soon thereafter, your Operator will
    be visible on [https://operatorhub.io/](https://operatorhub.io/) for the world
    to install!
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While this chapter introduced some new concepts, including the OLM and OperatorHub,
    many of the resources already listed in earlier *Troubleshooting* sections throughout
    this book still apply.
  prefs: []
  type: TYPE_NORMAL
- en: OLM support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OLM and its related resources are related in general to Operator SDK development.
    So, there is reasonable help for this topic available in the `#operator-sdk-dev`
    Slack channel on [slack.k8s.io](http://slack.k8s.io). The OLM is also available
    on GitHub for reporting issues at [https://github.com/operator-framework/operator-lifecycle-manager](https://github.com/operator-framework/operator-lifecycle-manager).
    The documentation for integrating an Operator with the OLM is available as a primary
    resource at [https://sdk.operatorframework.io/docs/olm-integration/](https://sdk.operatorframework.io/docs/olm-integration/).
  prefs: []
  type: TYPE_NORMAL
- en: OperatorHub support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OperatorHub is also available on GitHub at the catalog repository shown in this
    chapter ([https://github.com/k8s-operatorhub/community-operators](https://github.com/k8s-operatorhub/community-operators)).
    For issues with the frontend [https://operatorhub.io/](https://operatorhub.io/)
    website specifically, that code is located at [https://github.com/k8s-operatorhub/operatorhub.io](https://github.com/k8s-operatorhub/operatorhub.io).
    This repository provides detailed documentation on all of the necessary metadata
    and bundle files for OperatorHub submission (as well as the submission process
    itself) at [https://k8s-operatorhub.github.io/community-operators/](https://k8s-operatorhub.github.io/community-operators/).
  prefs: []
  type: TYPE_NORMAL
- en: 'OperatorHub also provides validators and tools for previewing your Operator''s
    submission prior to creating a PR against the repository. The preview tool is
    available at [https://operatorhub.io/preview](https://operatorhub.io/preview).
    Submitting the generated CSV in this tool will show a preview of how your Operator
    will look once it is submitted to OperatorHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Screenshot of the Nginx Operator preview on OperatorHub](img/B18147_07_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Screenshot of the Nginx Operator preview on OperatorHub
  prefs: []
  type: TYPE_NORMAL
- en: Previewing an Operator's presentation can be a very helpful manual step in testing
    that all of the metadata prepared for that Operator is going to present to new
    users in the way that you want. It can be easy to lose track of the confusing
    CRD and CSV definitions, so previewing it gives early visual confirmation that
    everything is set up correctly. It also verifies that the metadata is syntactically
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter concluded the primary development and publication of an Operator.
    If you have been following along up until this point while developing your own
    Operator, then congratulations! Your Operator is now published and accessible
    to new users thanks to the reach of OperatorHub. Starting from the early chapters
    of this book, we have shown the steps to design an Operator, develop its basic
    and advanced functionality with Go, build and deploy it for local testing, and
    finally, package and publish it for public distribution. However, very few Operator
    project life cycles will end at this point.
  prefs: []
  type: TYPE_NORMAL
- en: It is likely that most Operators will eventually need to evolve, change their
    provided features, and release new versions. Doing so in a consistent and predictable
    way benefits both your users and your maintainers by establishing expected release
    standards. These standards include policies for deprecation and timelines for
    new releases. In the next chapter, we will explain some of the existing best practices
    used among Kubernetes projects and provoke forward-looking thoughts about how
    to prepare for the ongoing maintenance and development of your new Operator.
  prefs: []
  type: TYPE_NORMAL
