<html><head></head><body>
		<div id="_idContainer147">
			<h1 class="chapter-number" id="_idParaDest-186"><a id="_idTextAnchor190"/>10</h1>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor191"/>GitOps for Infrastructure Automation – Terraform and Flux CD</h1>
			<p>In this chapter, we explore the powerful synergy between Terraform and Flux CD, two pivotal tools that epitomize the principles of GitOps and <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>). As cloud architectures become increasingly complex and dynamic, the need for sophisticated, automated tooling to manage these environments has become critical. Terraform allows users to define and provision cloud infrastructure using a high-level configuration language, creating a blueprint of resources that can be versioned and reused. Complementing this, Flux CD automates the deployment of applications and infrastructure changes by continuously syncing them from Git repositories to Kubernetes clusters. This integration not only simplifies the management of cloud resources but also ensures consistency and reliability across various stages of the deployment pipeline. Through detailed discussions, practical examples, and expert insights, this chapter will equip you with the knowledge to harness the combined power of Terraform and Flux CD, enabling you to automate your infrastructure efficiently and predictably in a <span class="No-Break">cloud-native world.</span></p>
			<p>In this chapter, we will delve into the following <span class="No-Break">key areas:</span></p>
			<ul>
				<li>Introducing infrastructure automation with Terraform and <span class="No-Break">Flux CD</span></li>
				<li>Setting up Terraform in a <span class="No-Break">GitOps workflow</span></li>
				<li>Exploring Flux CD – enabling <strong class="bold">continuous deployment</strong> (<strong class="bold">CD</strong>) <span class="No-Break">in Kubernetes</span></li>
				<li>Combining Terraform and Flux CD for <span class="No-Break">enhanced automation</span></li>
				<li>Version control and automation with Terraform and <span class="No-Break">Flux CD</span></li>
				<li>Multi-environment management with Terraform and <span class="No-Break">Flux CD</span></li>
			</ul>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor192"/>Technical requirements</h1>
			<p>Before diving into the integration of Terraform and Flux CD for GitOps workflows, it is essential to have a firm grasp of the foundational concepts discussed in earlier chapters of this book. Understanding the fundamentals of IaC, key Kubernetes concepts, and <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>)/CD principles will significantly enhance your comprehension of the material in this chapter. Practical familiarity with Terraform and initial setup experience with Kubernetes clusters are indispensable for applying the techniques covered. Access to a <strong class="bold">version control system</strong> (<strong class="bold">VCS</strong>), particularly Git, is critical as it forms the backbone of the GitOps methodology. This chapter assumes you have these prerequisites in place, enabling you to fully engage with the advanced strategies of using Terraform and Flux CD for efficient and scalable infrastructure automation. Before diving into deployment examples, it’s essential that you have at least a local Kubernetes cluster running. For more information about the different alternatives and OS bases, refer to the <em class="italic">Local cluster setup</em> section in <a href="B22100_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>. The relevant code and resource files for this chapter can be found in the <strong class="source-inline">Chapter10</strong> folder of our dedicated GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes"><span class="No-Break">https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor193"/>Introducing infrastructure automation with Terraform and Flux CD</h1>
			<p>In today’s rapidly evolving cloud computing landscape, the demand for agility, scalability, and reliability in managing infrastructure is paramount. Traditional manual approaches are no longer sufficient for modern applications. Enter <a id="_idIndexMarker851"/>IaC and GitOps, reshaping <a id="_idIndexMarker852"/>infrastructure management in cloud-native environments. Manual work remains crucial for platform engineers, such as understanding cloud resources to write effective Terraform<a id="_idIndexMarker853"/> scripts, and is often the first step before updating the Terraform Git repository. Leverage the GitOps framework to address cloud-native delivery challenges such as preventing configuration drifts and ensuring secure, error-free deployments. Implementing GitOps on Kubernetes introduces challenges, including managing complex configurations and maintaining synchronization between the Git repository and clusters. IaC is a methodology that treats infrastructure provisioning, configuration, and management as code. In essence, it enables developers and operations teams to define infrastructure resources—such<a id="_idIndexMarker854"/> as <strong class="bold">virtual machines</strong> (<strong class="bold">VMs</strong>), networks, and storage—using declarative or imperative code. We have already explored the concept of <a id="_idIndexMarker855"/>IaC in the previous chapter, where we utilized Terraform scripts to provision necessary resources in Azure <span class="No-Break">and AWS.</span></p>
			<p>This code is version-controlled, allowing for reproducible, consistent, and automated deployments. By codifying infrastructure configurations, IaC streamlines the deployment process, reduces human error, and enhances collaboration between development and <span class="No-Break">operations teams.</span></p>
			<p>GitOps, on the<a id="_idIndexMarker856"/> other hand, extends the principles of IaC to the realm of continuous delivery and deployment. Changes to the infrastructure are made via Git commits, enabling versioning, auditability, and collaboration. GitOps promotes a declarative approach to infrastructure management, where desired state configurations stored in Git repositories are automatically reconciled with the actual state of the infrastructure. This reconciliation is typically facilitated by specialized tools such as <span class="No-Break">Flux CD.</span></p>
			<p>Building on the foundational principles of IaC and GitOps introduced earlier, let’s consider a practical example, as shown in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.1</em>, of how companies can leverage Terraform<a id="_idIndexMarker857"/> and Flux CD<a id="_idIndexMarker858"/> for efficient <span class="No-Break">infrastructure management.</span></p>
			<p>Imagine a technology company that needs to rapidly scale its operations across multiple cloud environments while maintaining strict compliance and security standards. By using Terraform, the company can codify its infrastructure requirements into version-controlled configurations, which allows for quick deployment and easy replication of environments across AWS, Azure, or Google Cloud. With Flux CD integrated into this setup, any changes to the Terraform configurations in the Git repository automatically trigger updates within the Kubernetes clusters. This seamless integration ensures that the infrastructure evolves consistently with the application code, reducing discrepancies and potential errors. The result is a robust, scalable, and compliant infrastructure that can adapt swiftly to the changing needs of the business, all while minimizing manual oversight <span class="No-Break">and intervention:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer142">
					<img alt="Figure 10.1 – Example of a company leveraging Terraform and Flux CD for efficient infrastructure management" src="image/B22100_10_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Example of a company leveraging Terraform and Flux CD for efficient infrastructure management</p>
			<p>In the context of modern cloud environments, where agility and scalability are imperative, the adoption of IaC and GitOps offers numerous benefits. Firstly, it enables organizations to achieve infrastructure automation, allowing for rapid provisioning, scaling, and modification of resources. Secondly, it enhances reproducibility and consistency across environments, mitigating the risk of configuration drift and ensuring reliability. Thirdly, it fosters collaboration and visibility, as infrastructure configurations are stored and version-controlled in accessible Git repositories. Finally, it promotes resilience and observability, with automated reconciliation mechanisms ensuring that the infrastructure remains in the desired state. We will delve deeper into the topics of IaC and GitOps in the upcoming sections of this chapter, using <span class="No-Break">practical examples.</span></p>
			<p>Now, it’s time to begin configuring <span class="No-Break">our environment.</span></p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor194"/>Setting up Terraform in a GitOps workflow</h1>
			<p>Having established the foundational concepts of IaC and GitOps, we now understand how the integration of Terraform and Flux CD can <em class="italic">transform infrastructure management</em>. With this robust groundwork in place, we will guide you through configuring Terraform to work seamlessly with Flux CD, setting the stage for a cohesive and automated infrastructure deployment process that aligns with modern cloud-native practices. Terraform was introduced and briefly discussed in <a href="B22100_04.xhtml#_idTextAnchor065"><span class="No-Break"><em class="italic">Chapter 4</em></span></a> and further explored in the context of <em class="italic">Kubernetes deployments with Azure DevOps and AWS CodePipeline</em> in <a href="B22100_09.xhtml#_idTextAnchor176"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>. For the remainder of this chapter, we will assume that the reader has a solid understanding of Terraform and that it is already properly set up locally. For more information on what<a id="_idIndexMarker859"/> Terraform is and how to install it, please visit the following link: <a href="https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli">https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli</a>. To check that Terraform is correctly installed, in a new terminal, type the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
<strong class="bold">$ terraform version</strong></pre>			<p>The output of the preceding command should be similar <span class="No-Break">to this:</span></p>
			<pre class="source-code">
Terraform v1.7.5</pre>			<p>In our example of setting up Terraform within a GitOps workflow, we’ll use Flux to monitor changes in a Git repository containing Terraform scripts. Flux will then apply these changes to manage Azure cloud resources, specifically targeting a designated resource group, a virtual network, and <span class="No-Break">a subnet.</span></p>
			<p>To successfully implement this setup, you must meet the <span class="No-Break">following prerequisites:</span></p>
			<ul>
				<li><strong class="bold">A functional Kubernetes cluster</strong>: For this <a id="_idIndexMarker860"/>tutorial, we’ll use <strong class="source-inline">minikube</strong> installed locally. Alternatively, you could choose a <a id="_idIndexMarker861"/>managed<a id="_idIndexMarker862"/> cluster environment such as <strong class="bold">Azure Kubernetes Service</strong> (<strong class="bold">AKS</strong>) or <strong class="bold">Amazon Elastic Kubernetes </strong><span class="No-Break"><strong class="bold">Service</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">EKS</strong></span><span class="No-Break">).</span></li>
				<li><strong class="bold">Helm and kubectl</strong>: Ensure<a id="_idIndexMarker863"/> both tools <a id="_idIndexMarker864"/>are installed and <span class="No-Break">configured correctly.</span></li>
				<li><strong class="bold">GitHub account</strong>: While this example <a id="_idIndexMarker865"/>uses GitHub, Flux bootstrap supports other repositories as well. For additional details, refer to the Flux <a id="_idIndexMarker866"/>documentation <span class="No-Break">at </span><a href="https://fluxcd.io/flux/installation/#bootstrap-providers"><span class="No-Break">https://fluxcd.io/flux/installation/#bootstrap-providers</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">GitHub personal access token (PAT)</strong>: This is <a id="_idIndexMarker867"/>necessary for private repositories or for operations that require authentication. More information <a id="_idIndexMarker868"/>about PATs is available <span class="No-Break">at </span><a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens"><span class="No-Break">https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">An Azure account</strong>: You may <a id="_idIndexMarker869"/>also use an <a id="_idIndexMarker870"/>Azure account, based on<a id="_idIndexMarker871"/> your preference (please note that the examples in this and the upcoming sections are specifically designed <span class="No-Break">for Azure).</span></li>
			</ul>
			<p>Before delving deeper into the setup of the workflow, the next section will discuss what Tofu Controller is and why it is the engine and core of the <span class="No-Break">reconciliation process.</span></p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor195"/>Tofu Controller (formerly Weave TF-Controller)</h2>
			<p><strong class="bold">Tofu Controller</strong> (refer to https://github.com/flux-iac/tofu-controller), formerly known<a id="_idIndexMarker872"/> as <strong class="bold">Weave TF-Controller</strong>, serves as a pivotal element within the Flux ecosystem, enabling the<a id="_idIndexMarker873"/> reconciliation of <strong class="bold">OpenTofu</strong> and Terraform resources in a<a id="_idIndexMarker874"/> <span class="No-Break">GitOps manner.</span></p>
			<p class="callout-heading">OpenTofu</p>
			<p class="callout">OpenTofu, formerly <a id="_idIndexMarker875"/>known as OpenTF, is an open source, community-driven fork of Terraform managed by the Linux Foundation. Designed to enhance the management of IaC within cloud-native environments, OpenTofu seamlessly integrates with existing GitOps workflows, enabling users to declaratively manage their infrastructure using tools such as Terraform. Both<a id="_idIndexMarker876"/> OpenTofu and Terraform use declarative <strong class="bold">HashiCorp Configuration Language</strong> (<strong class="bold">HCL</strong>) syntax for provisioning infrastructure but differ in their licensing: Terraform now operates under <a id="_idIndexMarker877"/>a <strong class="bold">Business Source License</strong> (<strong class="bold">BSL</strong>), while OpenTofu is released<a id="_idIndexMarker878"/> under the open source <strong class="bold">Mozilla Public License</strong> (<strong class="bold">MPL</strong>). OpenTofu’s primary goal is to bridge the gap between complex infrastructure setups and the scalable, automated management capabilities required by modern cloud environments. By leveraging OpenTofu, organizations can efficiently apply GitOps principles to their infrastructure, ensuring consistency, reliability, and swift deployment of <span class="No-Break">cloud resources.</span></p>
			<p>With Tofu Controller, organizations <a id="_idIndexMarker879"/>can adopt GitOps practices for their infrastructure at a pace that suits their operational needs and readiness—meaning that there is no requirement to convert all resources to <span class="No-Break">GitOps immediately.</span></p>
			<p>Flexibility and pace emphasizing <a id="_idIndexMarker880"/>the <strong class="bold">at-your-own-pace</strong> approach, Tofu Controller allows for incremental adoption of GitOps. This flexibility is crucial for organizations that may want to gradually shift their operations without the need for a full-scale immediate transformation. It enables teams to manage changes and adaptations more comfortably, ensuring that each step toward GitOps can be thoroughly planned <span class="No-Break">and implemented.</span></p>
			<p>Tofu Controller supports various GitOps models, each catering to different needs and stages of <span class="No-Break">infrastructure management:</span></p>
			<ul>
				<li><strong class="bold">GitOps Automation Model</strong>: This model provides a comprehensive approach to GitOps, encompassing<a id="_idIndexMarker881"/> everything from provisioning to enforcement. For <a id="_idIndexMarker882"/>instance, it could manage the entire lifecycle of an AKS/EKS cluster via GitOps, automating numerous <span class="No-Break">underlying processes.</span></li>
				<li><strong class="bold">Hybrid GitOps Automation Model</strong>: Ideal for environments with pre-existing resources, this model allows<a id="_idIndexMarker883"/> selective GitOps adoption. For example, if an organization already has an AKS/EKS cluster, it can choose GitOps if only<a id="_idIndexMarker884"/> certain components such as the node group or security group integrate new capabilities while maintaining <span class="No-Break">existing configurations.</span></li>
				<li><strong class="bold">State Enforcement Model</strong>: Ensures that <a id="_idIndexMarker885"/>the current infrastructure <a id="_idIndexMarker886"/>state matches the Terraform state file (<strong class="source-inline">TFSTATE</strong>), using GitOps principles to enforce the desired state without making additional changes and correcting any deviations to maintain consistency <span class="No-Break">and reliability.</span></li>
				<li><strong class="bold">Drift Detection Model</strong>: Monitors for <a id="_idIndexMarker887"/>configuration drifts between the actual state and the Terraform state file, detecting changes not <a id="_idIndexMarker888"/>reflected in the <strong class="source-inline">TFSTATE</strong> file and allowing organizations to proactively address and manage <span class="No-Break">these changes.</span></li>
			</ul>
			<p>For the current example and for the upcoming sections, we will utilize the <strong class="bold">GitOps Automation</strong> model <span class="No-Break">previously mentioned.</span></p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor196"/>Getting started with the setup</h2>
			<p>Now that we<a id="_idIndexMarker889"/> have introduced the main topics and outlined<a id="_idIndexMarker890"/> the necessary requirements, we have reached the hands-on part of the workflow setup. To complete the first part of this setup, we need to complete the following <span class="No-Break">numbered steps:</span></p>
			<ol>
				<li><strong class="bold">Create a dedicated minikube cluster for Flux</strong>: To create a <strong class="source-inline">minikube </strong>cluster dedicated to <a id="_idIndexMarker891"/>Flux setup, in a new terminal, type the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ minikube start --profile flux-cluster</strong></pre><p class="list-inset">After a few minutes, the output should be like <span class="No-Break">the following:</span></p><pre class="source-code">😄<strong class="bold">  [flux-cluster] minikube v1.33.0 on Ubuntu 22.04 (amd64)</strong>
✨<strong class="bold">  Automatically selected the docker driver</strong>
📌<strong class="bold">  Using Docker driver with root privileges</strong>
👍<strong class="bold">  Starting "flux-cluster" primary control-plane node in "flux-cluster" cluster</strong>
<strong class="bold">…</strong>
🌟<strong class="bold">  Enabled addons: storage-provisioner, default-storageclass</strong>
🏄<strong class="bold">  Done! kubectl is now configured to use "flux-cluster" cluster and "default" namespace by default</strong></pre><p class="list-inset">This indicates that your cluster is ready to <span class="No-Break">be used.</span></p></li>				<li><strong class="bold">Install the </strong><span class="No-Break"><strong class="bold">Flux CLI</strong></span><span class="No-Break">:</span><ol><li class="upper-roman">To set <a id="_idIndexMarker892"/>up the Flux CLI, type the <a id="_idIndexMarker893"/><span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker894"/></span><span class="No-Break"> command:</span></li></ol><pre class="source-code">
<strong class="bold">$ curl -s https://fluxcd.io/install.sh | sudo bash</strong></pre><p class="list-inset">For more information or troubleshooting, please refer to the official Flux documentation <span class="No-Break">at </span><a href="https://fluxcd.io/flux/installation/"><span class="No-Break">https://fluxcd.io/flux/installation/</span></a><span class="No-Break">.</span></p><ol><li class="upper-roman" value="2">To verify that the Flux CLI is correctly installed, type the <span class="No-Break">following command:</span></li></ol><pre class="source-code"><strong class="bold">$ flux –version</strong></pre><p class="list-inset">The output of the preceding command should look <span class="No-Break">like this:</span></p><pre class="source-code">flux version 2.2.3</pre></li>				<li><strong class="bold">Create a GitHub repository</strong>: For this <a id="_idIndexMarker895"/>walkthrough, I’ve created a GitHub repository named <strong class="source-inline">gitops-terraform-workflow</strong>, but feel free to create a repository according to your preferences. We will use a private repository for this setup. To create a GitHub account, please refer to the <em class="italic">GitHub account</em> section in <a href="B22100_03.xhtml#_idTextAnchor051"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> of this book. After creating the GitHub repository, clone it locally to your laptop. For the Git commands, please refer to the <em class="italic">Basics of Git </em>section in <a href="B22100_03.xhtml#_idTextAnchor051"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> of <span class="No-Break">this book.</span></li>
				<li><strong class="bold">Flux bootstrap </strong><span class="No-Break"><strong class="bold">for GitHub</strong></span><span class="No-Break">:</span><ol><li class="upper-roman">The <strong class="source-inline">flux bootstrap</strong> GitHub <a id="_idIndexMarker896"/>command installs Flux controllers on a Kubernetes cluster, enabling synchronization with a GitHub repository. This setup involves committing Flux manifests to the repository and configuring Flux for self-updates from Git. Once executed, all operations on the cluster, including Flux updates, can be managed via <strong class="source-inline">git push</strong>, removing the need for direct cluster interaction. To interact with the GitHub API, the command requires a GitHub PAT with administrative permissions, which can be set as an <span class="No-Break">environment variable:</span></li></ol><pre class="source-code">
<strong class="bold">$ export GITHUB_TOKEN=[GITHUB_PAT_TOKEN]</strong></pre><ol><li class="upper-roman" value="2">Now, you<a id="_idIndexMarker897"/> can run the bootstrap for a repository <a id="_idIndexMarker898"/>on your personal GitHub account by entering the <span class="No-Break">following command:</span></li></ol><pre class="source-code"><strong class="bold">    flux bootstrap github \</strong>
<strong class="bold">      --token-auth \</strong>
<strong class="bold">      --owner=[GITHUB_ACCOUNT] \</strong>
<strong class="bold">      --repository=gitops-terraform-workflow \</strong>
<strong class="bold">      --branch=main \</strong>
<strong class="bold">      --path=clusters/local \</strong>
<strong class="bold">      --personal</strong></pre><p class="list-inset">The execution of the <a id="_idIndexMarker899"/>command should take a few minutes, and a successful output should look like <span class="No-Break">the following:</span></p><pre class="source-code">► connecting to github.com
► cloning branch "main" from Git repository "https://github.com/pietrolibro/gitops-terraform-workflow.git"
…
► confirming components are healthy
✔ helm-controller: deployment ready
✔ kustomize-controller: deployment ready
✔ notification-controller: deployment ready
✔ source-controller: deployment ready
✔ all components are healthy</pre><ol><li class="upper-roman" value="3">By running the following <strong class="source-inline">kubectl</strong> command, you should notice that a <strong class="source-inline">flux-system</strong> namespace has <span class="No-Break">been created:</span></li></ol><pre class="source-code"><strong class="bold">$ kubectl get namespaces</strong>
NAME              STATUS   AGE
default           Active   26m
flux-system       Active   3m30s
kube-node-lease   Active   26m
kube-public       Active   26m
kube-system       Active   26m</pre></li>				<li><strong class="bold">Install the TF-Controller</strong>: Now, we are <a id="_idIndexMarker900"/>ready to install the TF-Controller <span class="No-Break">previously</span><span class="No-Break"><a id="_idIndexMarker901"/></span><span class="No-Break"> mentioned:</span><ol><li class="upper-roman">Enter the<a id="_idIndexMarker902"/> <span class="No-Break">following command:</span></li></ol><pre class="source-code">
<strong class="bold">$ kubectl apply -f https://raw.githubusercontent.com/flux-iac/tofu-controller/main/docs/release.yaml</strong></pre><ol><li class="upper-roman" value="2">Now, we are ready to install the previously mentioned Tofu Controller. Enter the <span class="No-Break">following command:</span></li></ol><pre class="source-code">helmrepository.source.toolkit.fluxcd.io/tf-controller created
helmrelease.helm.toolkit.fluxcd.io/tf-controller created</pre></li>				<li><strong class="bold">Create an Azure service principal (SP)</strong>: To provision Azure resources into a specific <a id="_idIndexMarker903"/>Azure subscription, we need to create an SP with the <strong class="source-inline">Contributor</strong> role. To do this, type the <span class="No-Break">following commands:</span><pre class="source-code">
<strong class="bold">subscriptionId="$(az account list --query "[?name=='AZURE_SUBSCRIPTION_NAME'].id" --output tsv)"</strong>
<strong class="bold">az account set --subscription=$subscriptionId</strong>
<strong class="bold">az ad sp create-for-rbac --role="Contributor" --scopes="/subscriptions/$subscriptionId" --name gitops-terraform-sp</strong></pre><p class="list-inset">The output<a id="_idIndexMarker904"/> contains sensitive credentials that you <a id="_idIndexMarker905"/>must protect. Ensure that you do not include these credentials in your code or check them into your source control. For more information on managing Azure SPs, <span class="No-Break">visit </span><a href="https://aka.ms/azadsp-cli"><span class="No-Break">https://aka.ms/azadsp-cli</span></a><span class="No-Break">:</span></p><pre class="source-code">{
  "appId": "application-id",
  "displayName": "gitops-terraform-sp",
  "password": "generated-password",
  "tenant": "tenant-uid"
}</pre><p class="list-inset">The values correspond to the Terraform variables as follows: <strong class="source-inline">appId</strong> serves as the <strong class="source-inline">client_id</strong> variable, <strong class="source-inline">password</strong> is used as the <strong class="source-inline">client_secret</strong> variable, and <strong class="source-inline">tenant</strong> is the <strong class="source-inline">tenant_id</strong> variable as <span class="No-Break">defined previously.</span></p></li>				<li><strong class="bold">Define </strong><span class="No-Break"><strong class="bold">Kubernetes Secrets</strong></span><span class="No-Break">:</span><ol><li class="upper-roman">We are running Terraform in <a id="_idIndexMarker906"/>a Kubernetes cluster using Flux to automate Terraform operations, so we need to use Kubernetes Secrets to store Azure credentials and the PAT. These secrets are then mounted into your Pod where Terraform executes. To define a secret for the GitHub repository, please refer to the <strong class="source-inline">github-repository-secret.yaml</strong> file located in the definitions folder of the chapter’s repository. The <a id="_idIndexMarker907"/>content of the file is <span class="No-Break">as follows:</span></li></ol><pre class="source-code">
apiVersion: v1
kind: Secret
metadata:
  name: github-repository-secret
  namespace: flux-system
type: Opaque
data:
  username: &lt;github_accountname-base64&gt;
  password: &lt;github_pat-base64&gt;</pre><ol><li class="upper-roman" value="2">The username and password need to be <strong class="source-inline">base64</strong> encoded. To encode these using the command line, you can use the following command: <strong class="source-inline">echo -n 'your-string' | base64</strong>. After encoding, apply the secret using <strong class="source-inline">kubectl</strong> in the <span class="No-Break">usual manner:</span></li></ol><pre class="source-code"><strong class="bold">$ kubectl apply -f github-repository-secret.yaml</strong></pre><ol><li class="upper-roman" value="3">Now, we <a id="_idIndexMarker908"/>need to create a Kubernetes secret<a id="_idIndexMarker909"/> for the Azure credentials of the SP we previously created. Use the following command to <span class="No-Break">do so:</span></li></ol><pre class="source-code"><strong class="bold">$ kubectl create secret generic azure-creds \</strong>
<strong class="bold">    --from-literal=ARM_SUBSCRIPTION_ID='SP_SUB_ID' \</strong>
<strong class="bold">    --from-literal=ARM_TENANT_ID='SP_TENANT_ID' \</strong>
<strong class="bold">    --from-literal=ARM_CLIENT_ID='SP_APPID' \</strong>
<strong class="bold">    --from-literal=ARM_CLIENT_SECRET='SP_PASSWORD' \</strong>
<strong class="bold">    --namespace flux-system</strong></pre><ol><li class="upper-roman" value="4">To verify the creation of the secret, use the <span class="No-Break">following command:</span></li></ol><pre class="source-code"><strong class="bold">$ kubectl get secrets -n flux-system</strong>
<strong class="bold">NAME       TYPE                       DATA   AGE</strong>
<strong class="bold">azure-creds               Opaque      4      16s</strong>
<strong class="bold">flux-system               Opaque      2      34m</strong>
<strong class="bold">github-repository-secret  Opaque      2      25s</strong>
<strong class="bold">…</strong></pre></li>			</ol>
			<p class="callout-heading">Kubernetes Secret</p>
			<p class="callout">A Kubernetes Secret<a id="_idIndexMarker910"/> is a resource used in Kubernetes to hold a small amount of sensitive data such as passwords, tokens, or keys. This data is stored in <strong class="source-inline">base64</strong>-encoded format and can be used by pods to handle operations that require confidentiality and security, helping to prevent sensitive information from being exposed in your application code or logs. The term <em class="italic">opaque</em> in the context of Kubernetes Secrets refers to the default type of Secret. It is used when the specific type of Secret (such as a service account token or Docker configuration) doesn’t need to be indicated. Essentially, <em class="italic">opaque</em> indicates that the content of the Secret is arbitrary and not structured to represent any specific type of <span class="No-Break">confidential data.</span></p>
			<ol>
				<li value="8">Now, we <a id="_idIndexMarker911"/>need to link the GitHub repository <a id="_idIndexMarker912"/>with the GitHub repository secret using the <strong class="source-inline">github-repository-definition.yaml</strong> file located in the definitions folder (the <strong class="source-inline">flux-gitops-definitions</strong> folder defined in the repository accompanying this chapter). Apply it using the <span class="No-Break">usual command:</span><pre class="source-code">
<strong class="bold">$ kubectl apply -f github-repository-definition.yaml</strong>
gitrepository.source.toolkit.fluxcd.io/gitops-terraform-repository created</pre></li>				<li><strong class="bold">Docker image for the TF-Controller</strong>: Now, we need to create a custom Docker image to run the <a id="_idIndexMarker913"/>TF-Controller. The Dockerfile definition is contained in the Docker directory. For Docker commands, please refer to <em class="italic">Publishing the image to a container registry</em> section in <a href="B22100_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>. To build a custom Docker image, use the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ docker build -f ./Docker/dockerfile -t pietrolibro/gitops-terraform:tf_az_cli_1_1</strong> .</pre></li>				<li>Then, you need to publish it in a repository reachable from your Kubernetes cluster. To push the command, after logging in to Docker, use the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ docker push pietrolibro/gitops-terraform:tf_az_cli_1_1</strong></pre></li>				<li><strong class="bold">Create a Terraform script</strong>: Please refer to the Terraform script<a id="_idIndexMarker914"/> named <strong class="source-inline">main.tf</strong> in the <strong class="source-inline">iac/azure/vnet</strong> subfolder of the repository accompanying this chapter.  The Terraform script provisions a set of network resources in Microsoft Azure. It configures the Azure provider and defines a resource group named <strong class="source-inline">gitops-terraform-rg</strong> in the Switzerland North region, serving as a container for related Azure resources. The script also establishes a virtual network called <strong class="source-inline">gitops-terraform-vnet</strong> within this resource group, with an address space of <strong class="source-inline">10.0.0.0/16</strong>. Additionally, it creates a default subnet within this<a id="_idIndexMarker915"/> virtual network, allocated with an<a id="_idIndexMarker916"/> address range of <strong class="source-inline">10.0.0.0/24</strong>. This setup structures the Azure cloud infrastructure effectively, facilitating the management and scalability of network components within the <span class="No-Break">specified region.</span></li>
			</ol>
			<p>At this point, we can commit and push the code to the GitHub repository, concluding the first part of our journey of setting up Terraform within our GitOps workflow. The next stop on our journey, which will be described in the upcoming sections, focuses on enabling CD in Kubernetes <span class="No-Break">with Flux.</span></p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor197"/>Exploring Flux CD – enabling CD in Kubernetes</h1>
			<p>Flux CD <a id="_idIndexMarker917"/>automates the application of configurations and updates to a Kubernetes cluster based on changes pushed to a Git repository. This approach not only ensures consistency across environments but also enhances security and auditability by maintaining a clear, version-controlled history of all deployments. Flux continuously monitors a designated Git repository for changes to Kubernetes manifests, Helm charts, or configuration files. When a change is detected, Flux automatically applies these updates to the corresponding Kubernetes cluster. This automation is comprehensive, extending not only to applications but also to the Kubernetes infrastructure itself, enabling entire environments to be managed <span class="No-Break">as code.</span></p>
			<p>Key features<a id="_idIndexMarker918"/> of Flux CD include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Automated synchronization</strong>: Flux regularly checks the Git repository for changes and synchronizes the state of the <span class="No-Break">cluster accordingly</span></li>
				<li><strong class="bold">Immutable deployments</strong>: By treating infrastructure as immutable, Flux discourages manual interventions and <span class="No-Break">promotes reproducibility</span></li>
				<li><strong class="bold">Security and compliance</strong>: Changes are pulled from Git, ensuring that only approved changes are deployed, thereby enhancing security <span class="No-Break">and compliance</span></li>
			</ul>
			<p>It’s time to<a id="_idIndexMarker919"/> return to our journey, which we paused at the end of the previous section. Now, we need to configure the Flux instance to track its respective directory or branch in the Git repository. This is where the beauty of the Terraform Controller comes into play—it does all the hard work <span class="No-Break">for you.</span></p>
			<p>We need to create a YAML file (refer to the <strong class="source-inline">azvnet-gitops-automation.yaml</strong> file defined in the repository for this chapter) <span class="No-Break">like so:</span></p>
			<pre class="source-code">
<strong class="bold">apiVersion</strong>: infra.contrib.fluxcd.io/v1alpha2
kind: <strong class="bold">Terraform</strong>
metadata:
  name: <strong class="bold">gitops-terraform-automation</strong>
  namespace: <strong class="bold">flux-system</strong>
spec:
  <strong class="bold">interval</strong>: 1m
  <strong class="bold">approvePlan</strong>: auto
  <strong class="bold">destroyResourcesOnDeletion</strong>: true
  <strong class="bold">path: ./iac/azure/vnet</strong>
  sourceRef:
…
  <strong class="bold">runnerPodTemplate</strong>:
    <strong class="bold">spec</strong>:
      env:
        - name: <strong class="bold">ARM_SUBSCRIPTION_ID</strong>
          valueFrom:
            secretKeyRef:
              name: <strong class="bold">azure-creds</strong>
              key: <strong class="bold">ARM_SUBSCRIPTION_ID</strong>
        …</pre>			<p>This YAML file<a id="_idIndexMarker920"/> defines a <strong class="source-inline">Terraform</strong> resource for use within the Flux CD framework, specifically designed to manage IaC deployments automatically. The configuration details the API version and specifies that the resource type is <strong class="source-inline">Terraform</strong>, indicating its role in managing and applying Terraform configurations <span class="No-Break">through Flux.</span></p>
			<p>The resource is named <strong class="source-inline">gitops-terraform-automation</strong> and is located within the <strong class="source-inline">flux-system</strong> namespace, which is typically designated for Flux CD operations. The specifications include an interval setting of 1 minute, indicating how frequently Flux checks the Git repository for changes in the designated directory. It is configured to automatically approve and apply changes (<strong class="source-inline">approvePlan: auto</strong>) and to destroy all managed resources if this Terraform configuration is deleted from Kubernetes (<strong class="source-inline">destroyResourcesOnDeletion: true</strong>). The <strong class="source-inline">./iac/azure/vnet</strong> path specifies where in the Git repository the Terraform configurations are located, which Flux <span class="No-Break">will monitor.</span></p>
			<p>The <strong class="source-inline">sourceRef</strong> instance<a id="_idIndexMarker921"/> points to a Git repository named <strong class="source-inline">flux-system</strong>, identifying the specific repository Flux should monitor. This setup allows Flux to automatically manage updates and maintain the environment as specified in <span class="No-Break">the repository.</span></p>
			<p>The <strong class="source-inline">runnerPodTemplate</strong> section configures the environment variables for the pod that executes the Terraform commands, securing access to Azure services. Variables such as <strong class="source-inline">ARM_SUBSCRIPTION_ID</strong>, <strong class="source-inline">ARM_CLIENT_ID</strong>, <strong class="source-inline">ARM_CLIENT_SECRET</strong>, and <strong class="source-inline">ARM_TENANT_ID</strong> are essential for Azure interactions and are pulled securely from a Kubernetes secret named <strong class="source-inline">azure-creds</strong>. This ensures that sensitive credentials are managed securely and only made available to the <span class="No-Break">necessary processes.</span></p>
			<p>By leveraging this configuration, Flux CD automates the deployment and management of Azure virtual networks defined in the Terraform configurations at the specified path in the repository. The automation encompasses monitoring for changes, applying updates, and ensuring the environment remains consistent with the declared state in the repository. This setup epitomizes the principles of GitOps by using Git as a <strong class="bold">single</strong> <strong class="bold">source of truth</strong> (<strong class="bold">SSOT</strong>) and <a id="_idIndexMarker922"/>automating the reconciliation process between the desired state defined in Git and the actual state of the infrastructure <span class="No-Break">in Azure.</span></p>
			<p>To make the magic happen and bring the configuration to life, we need to apply it <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">kubectl</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
<strong class="bold">$ kubectl apply -f ./definitions/azvnet-gitops-automation.yaml</strong>
<strong class="bold">terraform.infra.contrib.fluxcd.io/gitops-terraform-automation created</strong></pre>			<p>To monitor and verify the reconciliation process initiated by Flux CD, you can use the <strong class="source-inline">kubectl</strong> command to query the status of resources managed by Flux. Here’s how to check the <span class="No-Break">reconciliation process:</span></p>
			<pre class="source-code">
<strong class="bold">$ kubectl get terraforms.infra.contrib.fluxcd.io -n flux-system  -w</strong></pre>			<p>This command displays the current status of the <span class="No-Break">Terraform configuration:</span></p>
			<pre class="source-code">
NAME        READY     STATUS                       AGE
gitops-ter… Unknown   Reconciliation in progress   9s
gitops-ter… Unknown   Initializing                 15s
gitops-ter… Unknown   Terraform Planning           22s
gitops-ter… Unknown   Plan generated               30s
gitops-ter… Unknown   Applying                     30s
gitops-ter… Unknown   Applying                     30s
gitops-ter… Unknown   Applied successfully: main@sha1:2eeaefba687fbd3d4caea404fc332ee7c5d8b144   43s
gitops-ter… True      <strong class="bold">Applied successfully</strong>: main@sha1:2eeaefba687fbd3d4caea404fc332ee7c5d8b144   44s</pre>			<p>As indicated by the<a id="_idIndexMarker923"/> output of the previous command, the Terraform script has been successfully applied at a certain point. For further confirmation, we can open the Azure portal and visually inspect the provisioned infrastructure, as illustrated in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer143">
					<img alt="Figure 10.2 – Azure resources provisioned by Terraform and GitOps" src="image/B22100_10_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Azure resources provisioned by Terraform and GitOps</p>
			<p>Fantastic work! You have successfully integrated IaC using Terraform along with GitOps principles through Flux CD. By adopting this approach, you have laid a robust foundation for managing your cloud resources in a way that promotes consistency, reduces errors, and <span class="No-Break">streamlines operations.</span></p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor198"/>Combining Terraform and Flux CD for enhanced automation</h1>
			<p>Combining<a id="_idIndexMarker924"/> Terraform and Flux CD for enhanced automation offers significant advantages in managing cloud infrastructure efficiently and resiliently. Here’s how this integration can be advantageous in various <span class="No-Break">practical scenarios.</span></p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor199"/>Providing new infrastructure by updating Terraform files</h2>
			<p>One of <a id="_idIndexMarker925"/>the standout benefits of integrating Terraform with Flux CD is the simplicity with which new infrastructure components can be added. For example, suppose you need to add a new subnet to an existing Azure virtual network. By merely updating the Terraform file to include the new subnet definition and committing this change to your repository, Flux CD automatically detects the update and applies it. This seamless process eliminates the need for manual intervention in the cloud environment, thereby reducing the potential for human error and accelerating deployment times. Automation ensures that infrastructure adjustments, such as scaling out to accommodate growth, are handled promptly <span class="No-Break">and accurately.</span></p>
			<p>We can immediately test this aspect by updating the <strong class="source-inline">main.tf</strong> file presented in <em class="italic">step 8</em> of the <em class="italic">Setting up Terraform in a GitOps workflow</em> section. Append the following code block to the end of <span class="No-Break">the file:</span></p>
			<pre class="source-code">
resource "<strong class="bold">azurerm_subnet</strong>" "azure_bastion_subnet" {
  name                 = «<strong class="bold">AzureBastionSubnet</strong>"
  resource_group_name  = azurerm_resource_group.gitops_terraform_rg.name
  virtual_network_name = azurerm_virtual_network.gitops_terraform_vnet.name
  address_prefixes     = [«<strong class="bold">10.0.1.0/26</strong>"]
}</pre>			<p>This <a id="_idIndexMarker926"/>Terraform code block creates a subnet named <strong class="source-inline">AzureBastionSubnet</strong> within a specified Azure virtual network and resource group. It assigns the subnet an IP address range of <strong class="source-inline">10.0.1.0/26</strong>. The subnet resource is identified within Terraform as <strong class="source-inline">azure_bastion_subnet</strong>, and it references the names of both the virtual network and resource group from other resources defined in the <span class="No-Break">Terraform configuration.</span></p>
			<p>At this point, simply commit and push the code to trigger a reconciliation loop. You will then see the process in action, as <span class="No-Break">illustrated next:</span></p>
			<pre class="source-code">
gitops-ter…   Unknown   Reconciliation in progress    3h12m
gitops-ter…   Unknown   Initializing                3h12m
gitops-ter…   Unknown   Terraform Planning            3h12m
gitops-ter…   Unknown   Plan generated                3h12m
gitops-ter…   Unknown   Applying                    3h12m
gitops-ter…   Unknown   Applied successfully: main@sha1:a3b32ed48dda027b0c5e40a65c7be56e1cc7dd50       3h13m
gitops-ter…   True      Applied successfully: main@sha1:a3b32ed48dda027b0c5e40a65c7be56e1cc7dd50       3h13m</pre>			<p>Open the Azure portal to visually verify the results, as illustrated in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer144">
					<img alt="Figure 10.3 – After the reconciliation process, the gitops-terraform-vnet virtual network in the Azure portal contains two subnets" src="image/B22100_10_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – After the reconciliation process, the gitops-terraform-vnet virtual network in the Azure portal contains two subnets</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor200"/>Enhanced disaster recovery capabilities</h2>
			<p>In the<a id="_idIndexMarker927"/> event of a disaster, the combination of Terraform and Flux CD significantly enhances recovery capabilities. Terraform’s ability to describe the complete IaC means that entire environments can be replicated swiftly and accurately. Flux CD plays a crucial role by continuously ensuring that the state of the cloud environment matches the configurations defined in your Git repository. If a disaster strikes, you can quickly redeploy your infrastructure to a known good state as defined in the repository, drastically reducing downtime and the complexity often associated with <span class="No-Break">recovery processes.</span></p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor201"/>Creating and managing multi-stage environments</h2>
			<p>When managing<a id="_idIndexMarker928"/> complex deployments that involve multiple stages, such as development, staging, and production, the division of the repository becomes essential. With Terraform and Flux CD, you can split your repository appropriately to manage these environments separately yet consistently. Each environment can have its configuration files and Terraform plans, which Flux CD can manage independently. This setup not only keeps your deployments organized but also enforces consistency and isolation between environments. Changes can be tested in development or staging environments through automated pipelines and only promoted to production once verified, ensuring stability and reliability in your <span class="No-Break">production deployments.</span></p>
			<p>As seen so far, this strategic integration of Terraform and Flux CD not only streamlines the operational aspects of cloud infrastructure management but also enhances strategic capabilities such as quick scaling, robust <strong class="bold">disaster recovery</strong> (<strong class="bold">DR</strong>), and effective multi-environment handling. With Flux CD, updates<a id="_idIndexMarker929"/> and changes are applied systematically and predictably, reducing the likelihood of human error and the overhead associated with <span class="No-Break">manual deployments.</span></p>
			<p>In the next section, we will explore how Terraform and Flux CD utilize version control and automation to enhance infrastructure management, ensuring transparency, collaboration, and security throughout the <span class="No-Break">deployment process.</span></p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor202"/>Version control and automation with Terraform and Flux CD</h1>
			<p>Terraform uses<a id="_idIndexMarker930"/> version control to manage the state of your infrastructure, which allows for tracking changes, auditing, and collaborating on infrastructure development. By storing Terraform configurations in version-controlled repositories, teams can review changes through pull requests, maintain a history of configurations, and revert to previous states when necessary. This process enhances transparency and collaboration among team members, fostering a more controlled and secure environment for <span class="No-Break">deploying infrastructure.</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor203"/>Security and best practices with Terraform and Flux CD</h2>
			<p>When combining<a id="_idIndexMarker931"/> Terraform with Flux CD, security is significantly enhanced by the inherent design of GitOps and the nature of declarative infrastructure management. All changes to the infrastructure are committed to version control, which means every change is auditable <span class="No-Break">and traceable.</span></p>
			<p>To enhance security further, we can deploy <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Access control</strong>: Implement strict access controls on your Git repositories. Use branch protection rules to ensure that changes are reviewed and approved before they are merged, preventing unauthorized modifications to <span class="No-Break">your infrastructure.</span></li>
				<li><strong class="bold">Secrets management</strong>: Never store secrets directly in your Git repositories. Instead, leverage Kubernetes Secrets or integrate with a secrets management tool such as HashiCorp Vault or Azure Key Vault. Flux CD can securely pull secrets and inject them into the <span class="No-Break">deployment pipeline.</span></li>
				<li><strong class="bold">Automated compliance scans</strong>: Integrate compliance scanning tools into your CI/CD pipeline to automatically check Terraform plans for compliance with security <a id="_idIndexMarker932"/>policies and best practices before they <span class="No-Break">are applied.</span></li>
			</ul>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor204"/>Best practices for configuration and maintenance</h2>
			<p>Here are some best practices for configuration <span class="No-Break">and maintenance:</span></p>
			<ul>
				<li><strong class="bold">Immutability</strong>: Treat<a id="_idIndexMarker933"/> infrastructure as immutable. Rebuild infrastructure from scratch frequently to ensure that the actual state aligns with the state defined in <span class="No-Break">Terraform configurations.</span></li>
				<li><strong class="bold">Code review and pair programming</strong>: Enforce code reviews for all infrastructure changes. Pair programming can also be used for critical changes, involving more than one set of eyes before changes <span class="No-Break">go live.</span></li>
				<li><strong class="bold">CI</strong>: Integrate CI processes to test infrastructure changes automatically. This includes testing Terraform plans and applying them to a non-production environment before they affect your <span class="No-Break">production infrastructure.</span></li>
			</ul>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor205"/>Best practices for managing multi-environment configurations</h2>
			<p>Managing <a id="_idIndexMarker934"/>multiple environments (dev, staging, production) effectively requires a well-organized <span class="No-Break">repository structure.</span></p>
			<p>Here are some <span class="No-Break">best practices:</span></p>
			<ul>
				<li><strong class="bold">Environment branching</strong>: Maintains<a id="_idIndexMarker935"/> a single repository, but uses different branches for each environment, merging changes from development branches to production branches through a <span class="No-Break">controlled process.</span></li>
				<li><strong class="bold">Parameterization</strong>: Use variables and outputs to customize Terraform configurations for different environments. Avoid hardcoding values directly into <span class="No-Break">Terraform files.</span></li>
				<li><strong class="bold">Environment parity</strong>: Keep your development, staging, and production environments as similar as possible. This reduces the chances of encountering unexpected behaviors in production that weren’t evident in dev or staging. The optimal approach to managing multi-environment configurations hinges on several factors, such as organization size, project complexity, regulatory demands, and the balancing act between security and operational efficiency. For organizations in highly regulated industries, such as finance or healthcare, where security is paramount, using separate repositories for each environment might be advisable to enhance security by isolating production settings from development and testing environments. This method limits access to sensitive configurations and minimizes the risk of inadvertent changes. Alternatively, if rapid development and deployment are critical, a single repository with separate directories for each environment can simplify the management of changes across environments, though it necessitates strict access controls and vigilant monitoring to protect production configurations. For those seeking a balance between security and simplicity, a hybrid approach could be suitable, involving a single repository for all non-sensitive environments and a separate one for production. Regardless of the chosen strategy, implementing robust version control practices, clear access controls, and automated deployment pipelines will be essential to maintain<a id="_idIndexMarker936"/> efficiency and safeguard the integrity <span class="No-Break">of environments.</span></li>
			</ul>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor206"/>Git workflow strategies</h2>
			<p>To effectively<a id="_idIndexMarker937"/> manage your infrastructure and streamline your development workflow, it’s essential to adopt best practices that align with your team’s dynamics and project requirements. Consider the <span class="No-Break">following strategies:</span></p>
			<ul>
				<li><strong class="bold">Trunk-based development versus Git Flow</strong>: Choose a Git workflow that suits your team’s needs. Trunk-based development encourages shorter-lived branches and might be more suitable for fast-paced environments, while Git Flow can provide more control through designated branches for features, releases, <span class="No-Break">and hotfixes.</span></li>
				<li><strong class="bold">Automated testing and promotion</strong>: Use automated testing to validate changes in lower environments. Only promote changes to the next environment once they pass all tests. Automate this promotion using Flux CD, which can monitor different branches or folders and apply changes to the <span class="No-Break">respective environments.</span></li>
			</ul>
			<p>Now that we have a comprehensive understanding of Terraform, GitOps, and Flux, along with best practices, we can combine all these elements in a practical example. This example will focus on managing a multi-environment setup, which we will describe in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor207"/>Multi-environment management with Terraform and Flux CD</h1>
			<p>In the final <a id="_idIndexMarker938"/>section of this book, you’ll explore a detailed application of the concepts we’ve discussed, using a Kubernetes cluster (<strong class="source-inline">minikube</strong>) to manage a multi-environment setup with Flux CD for IaC. This real-world example will demonstrate how to effectively deploy separate environments for <strong class="bold">development</strong> (<strong class="source-inline">dev</strong>), <strong class="bold">staging </strong>(<strong class="source-inline">staging</strong>), and <strong class="bold">production</strong> (<strong class="source-inline">prod</strong>). <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.4</em> illustrates the <span class="No-Break">described example:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer145">
					<img alt="Figure 10.4 – Example of multi-environment management with Terraform and Flux CD" src="image/B22100_10_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Example of multi-environment management with Terraform and Flux CD</p>
			<p>GitHub will <a id="_idIndexMarker939"/>serve as the VCS, and the directory hierarchy will be organized <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
|---clusters/mgmt
|---flux-gitops-definitions
|---multi-env
     |---iac
          |---azure
               |---base
               |---dev
               |---staging
               |---prod</pre>			<p>In this structure, we have <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">clusters/mgmt</strong>: Contains the Flux configuration files installed by the bootstrap for the management cluster (<strong class="source-inline">minikube</strong>, <span class="No-Break">running locally).</span></li>
				<li><strong class="source-inline">multi-env/iac/azure</strong>: Contains subdirectories for the different environments (<strong class="source-inline">dev</strong>, <strong class="source-inline">staging</strong>, and <strong class="source-inline">prod</strong>), each intended for managing infrastructure specific to that environment using <span class="No-Break">Terraform scripts.</span></li>
				<li><strong class="source-inline">Base</strong>: Contains<a id="_idIndexMarker940"/> the main Terraform files (<strong class="source-inline">main.tf</strong> and <strong class="source-inline">variables.tf</strong>), which define the Azure resources (such as AKS, virtual network, <strong class="bold">Azure Container Registry</strong> (<strong class="bold">ACR</strong>), and <a id="_idIndexMarker941"/>so on) from an infrastructure perspective. These files are copied into the corresponding environment subfolder as needed to tailor the infrastructure setup for each <span class="No-Break">specific environment.</span></li>
			</ul>
			<p>The <strong class="source-inline">flux-gitops-definitions</strong> directory contains various manifest YAML files essential for configuring the GitHub repository and secret. This setup involves <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">GitHub repository configuration</strong>: YAML files in this directory help link the Flux installation with the GitHub repository, specifying where Flux should listen for updates and which branch <span class="No-Break">to monitor.</span></li>
				<li><strong class="bold">Secrets management</strong>: Includes the setup for Kubernetes secrets that store sensitive information, such as GitHub access tokens or cloud provider credentials. These secrets ensure that Flux can securely access the repository and interact with other services <span class="No-Break">as needed.</span></li>
				<li><strong class="bold">Resource definitions</strong>: Manifests that define how resources should be applied, rolled out, and managed across <span class="No-Break">different environments.</span></li>
			</ul>
			<p>For the following example, we will continue using the same GitHub repository as before (although you are welcome to create a new one if you prefer). Additionally, we will initiate a new <span class="No-Break"><strong class="source-inline">minikube</strong></span><span class="No-Break"> cluster:</span></p>
			<ol>
				<li>To do this, start<a id="_idIndexMarker942"/> by opening a new terminal window and enter the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ minikube start --profile mgmt-cluster</strong></pre></li>				<li>While waiting for the competition to start, we’ll need to export <strong class="source-inline">GITHUB_TOKEN</strong>. This can be done by entering the following command in <span class="No-Break">your terminal:</span><pre class="source-code">
<strong class="bold">export GITHUB_TOKEN=ghp_XYZ</strong></pre></li>				<li>Now that <strong class="source-inline">GITHUB_TOKEN</strong> is set, you can proceed to install Flux on your cluster using the bootstrap command. Execute the following in <span class="No-Break">your terminal:</span><pre class="source-code">
<strong class="bold">flux bootstrap github \</strong>
<strong class="bold">      --token-auth \</strong>
<strong class="bold">      --context=mgmt-cluster \</strong>
<strong class="bold">      --owner=[GITHUB_ACCOUNT] \</strong>
<strong class="bold">      --repository=[GITHUB_REPOSITORY] \</strong>
<strong class="bold">      --branch=develop \</strong>
<strong class="bold">      --path=clusters/mgmt \</strong>
<strong class="bold">      --personal</strong></pre><p class="list-inset">Once the command has finished executing, you should see an output similar to <span class="No-Break">the following:</span></p><pre class="source-code">► connecting to github.com
► cloning branch "develop" from Git repository "https://github.com/...
✔ cloned repository
► generating component manifests
…
✔ kustomize-controller: deployment ready
✔ notification-controller: deployment ready
✔ source-controller: deployment ready
✔ all components are healthy</pre></li>				<li>Now that Flux is successfully bootstrapped, the next step is to install the TF-Controller. Here’s how <span class="No-Break">to proceed:</span><pre class="source-code">
<strong class="bold">$ kubectl apply -f https://raw.githubusercontent.com/flux-iac/tofu-controller/main/docs/release.yaml</strong></pre></li>				<li>Once the <a id="_idIndexMarker943"/>command is executed, you should verify that the TF-Controller has been installed correctly and is running. You can check the status of the pods in the namespace where the TF-Controller is installed, typically in the <strong class="source-inline">flux-system</strong> namespace or a specific namespace designated <span class="No-Break">for it:</span><pre class="source-code">
<strong class="bold">$ kubectl get pods -n flux-system</strong>
<strong class="bold">NAME                      READY   STATUS    RESTARTS  AGE</strong>
<strong class="bold">helm-controller…          1/1     Running   0         4m47s</strong>
<strong class="bold">kustomize-contr…            1/1     Running   0         4m47s</strong>
<strong class="bold">notification-co…          1/1     Running   0         4m47s</strong>
<strong class="bold">source-controll…          1/1     Running   0         4m47s</strong></pre><p class="list-inset">Look for pods related to the TF-Controller and ensure they are in the <span class="No-Break"><strong class="source-inline">Running</strong></span><span class="No-Break"> state.</span></p></li>				<li>Since we<a id="_idIndexMarker944"/> are using a new <strong class="source-inline">minikube</strong> cluster (or alternative cluster) and our goal is to provision resources on Azure, we need to create the <span class="No-Break">corresponding secret:</span><pre class="source-code">
<strong class="bold">$ kubectl create secret generic azure-creds \</strong>
<strong class="bold">    --from-literal=ARM_SUBSCRIPTION_ID='SP_SUB_ID' \</strong>
<strong class="bold">    --from-literal=ARM_TENANT_ID='SP_TENANT_ID' \</strong>
<strong class="bold">    --from-literal=ARM_CLIENT_ID='SP_APPID' \</strong>
<strong class="bold">    --from-literal=ARM_CLIENT_SECRET='SP_PASSWORD' \</strong>
<strong class="bold">    --namespace flux-system</strong></pre></li>				<li>To set up a multi-environment infrastructure using Terraform, you’ll need to create a new (empty) <strong class="source-inline">main.tf</strong> file in each environment-specific subdirectory (<strong class="source-inline">dev</strong>, <strong class="source-inline">staging</strong>, <strong class="source-inline">prod</strong>) within the <strong class="source-inline">multi-env/iac/azure</strong> main directory. Here’s how to structure the <strong class="source-inline">main.tf</strong> file for <span class="No-Break">each environment:</span><pre class="source-code">
provider "azurerm" {
  features {}
}</pre></li>				<li>Now, change your working directory to where <strong class="source-inline">flux-gitops-definitions</strong> is located. This directory should contain your YAML files for the GitHub repository configuration (<strong class="source-inline">github-repository-definition.yaml</strong>) and the secret (<strong class="source-inline">github-repository-secret.yaml</strong>). First, apply the <em class="italic">GitHub repository secret</em>, which contains the credentials that Flux CD will use to access your <span class="No-Break">GitHub repository:</span><pre class="source-code">
<strong class="bold">$ kubectl apply -f github-repository-secret.yaml</strong></pre></li>				<li>Next, apply the <em class="italic">GitHub repository definition</em>. This  definition will link your Kubernetes setup with the GitHub repository, setting the groundwork for Flux CD to monitor changes and manage resources according to <span class="No-Break">GitOps principles:</span><pre class="source-code">
<strong class="bold">$ kubectl apply -f github-repository-definition.yaml</strong></pre></li>				<li>Before continuing, it’s important to commit and push the changes we’ve made so far. Then, we need to apply the automation configurations for each environment by executing the <span class="No-Break">following commands:</span><pre class="source-code">
<strong class="bold">$ kubectl apply -f dev-iac-automation.yaml</strong>
<strong class="bold">$ kubectl apply -f staging-iac-automation.yaml</strong>
<strong class="bold">$ kubectl apply -f prod-iac-automation.yaml</strong></pre></li>				<li>Afterward, check the reconciling process to ensure that the configurations are being <span class="No-Break">applied </span><span class="No-Break"><a id="_idIndexMarker945"/></span><span class="No-Break">correctly:</span><pre class="source-code">
<strong class="bold">$ kubectl get terraforms.infra.contrib.fluxcd.io -n flux-system  -w</strong>
NAME                          READY   STATUS                                                            AGE
dev-cluster-tf-automation       True    No drift: develop@sha1:c93...   3m48s
prod-cluster-tf-automation      True    No drift: develop@sha1:c93...   3m31s
staging-cluster-tf-automation   True    No drift: develop@sha1:c93...   3m37s
dev-cluster-tf-automation       Unknown   Reconciliation in progress                                        3m48s
staging-cluster-tf-automation   Unknown   Reconciliation in progress                                        3m38s
prod-cluster-tf-automation      Unknown   Reconciliation in progress                                        3m33s</pre></li>				<li>At this point, the <a id="_idIndexMarker946"/>reconciliation process is in progress, but no resources will be provisioned because the <strong class="source-inline">main.tf</strong> file in each directory does not define any resources. To address this, copy the <strong class="source-inline">main.tf</strong> and <strong class="source-inline">variables.tf</strong> files from the <strong class="source-inline">base</strong> directory to each subdirectory corresponding to the specific environments. Then, for each environment, open the <strong class="source-inline">variables.tf</strong> file and update it according to the needs of the <strong class="source-inline">dev</strong>, <strong class="source-inline">staging</strong>, and <span class="No-Break"><strong class="source-inline">prod</strong></span><span class="No-Break"> environments:</span><pre class="source-code">
variable "<strong class="bold">environment</strong>" {
  …
  default     = <strong class="bold">"dev"</strong>
}
variable "location" {
  …
}
variable "<strong class="bold">rg</strong>" {
  …
  default     = «<strong class="bold">gitops-dev-rg</strong>"
}</pre></li>				<li>Now, it’s time to commit and push the updated code to your Git repository. After doing so, you can observe the reconciliation process to see how Flux CD responds to <span class="No-Break">the changes:</span><pre class="source-code">
<strong class="bold">$ kubectl get terraforms.infra.contrib.fluxcd.io -n flux-system  -w</strong></pre><p class="list-inset">This procedure provides real-time feedback on how Flux CD manages and applies updates from your Git repository. The reconciliation process may take some time to fully provision the resources defined in the Terraform scripts. The results are illustrated in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p></li>			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer146">
					<img alt="Figure 10.5 – Resources provisioned by the GitOps automation reconciliation process" src="image/B22100_10_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Resources provisioned by the GitOps automation reconciliation process</p>
			<p>Well done! Now, you can try making changes to the infrastructure code in one of the environments and see how the GitOps automation updates and syncs the infrastructure with your repository. What we’ve explored is just a glimpse of using GitOps for managing multi-environment setups. We haven’t covered using pull requests or installing applications yet—these topics will be addressed in the <span class="No-Break">next chapter.</span></p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor208"/>Summary</h1>
			<p>In this chapter, we explored the dynamic synergy between Terraform and Flux CD, showcasing how these tools bolster infrastructure automation using GitOps and IaC principles. The chapter introduced Terraform for defining and provisioning cloud infrastructure, alongside Flux CD, which automates the deployment process by continuously syncing changes from Git repositories to Kubernetes clusters. It thoroughly covered the fundamentals of integrating Terraform within a GitOps workflow, ensuring seamless management and scaling of cloud resources. Special attention was given to best practices for maintaining multiple environments such as development, QA, and staging, emphasizing the importance of environment-specific configurations to maintain consistency, reduce errors, and streamline operations across various cloud setups. Practical examples throughout the chapter demonstrated how to utilize these tools to effectively manage complex deployments, with a strong focus on the critical roles of version control and <span class="No-Break">automated reconciliation.</span></p>
			<p>Building on the foundational concepts and best practices discussed, the next chapter will delve deeper into practical applications and real-world scenarios, showcasing how these strategies can be effectively implemented to optimize cloud <span class="No-Break">infrastructure management.</span></p>
		</div>
	</body></html>