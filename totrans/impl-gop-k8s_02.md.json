["```\n    pietro), which does not need to match your Windows username. The next step involves setting the password that will be used to run a command as an administrator (sudo). If the operations are completed correctly, the Terminal window should look like this:\n    ```", "```\n    $ sudo apt update\n    $ sudo apt upgrade\n    ```", "```\n    $ curl -sfL https://get.k3s.io | sh -s - --write-kubeconfig-mode 644\n    ```", "```\n$ k3s --version\n```", "```\n$ k3s check-config\n```", "```\n$ kubectl get nodes\n```", "```\n$ kubectl cluster-info\n```", "```\napiVersion: v1\nkind: Pod\nmetadata:\n  name: hw-gitops-folks\nspec:\n  containers:\n  - name: hw-gitops-folks-container\n    image: k8s.gcr.io/echoserver:1.4\n    ports:\n    - containerPort: 8080\n```", "```\n    $ kubectl get pods\n    ```", "```\n    No resources found in default namespace\n    ```", "```\n    kube-system namespace. These Pods are essential for the operation of the Kubernetes system. The specific Pods and their statuses are detailed in *Figure 2**.11*, offering a comprehensive view of the active system components within this crucial namespace:\n    ```", "```\n    $ kubectl create namespace gitops-kubernetes\n    ```", "```\n    namespace/gitops-kubernetes created\n    ```", "```\n    hello-world image and a service to make the deployment accessible (the complete version of the manifest mentioned here can be found in this book’s GitHub repository):\n\n    ```", "```\n\n    To apply the manifest, we need to save it in a `.yaml` (or .`yml`) file, such as `hello-world-deployment.yaml` (its name isn’t important).\n    ```", "```\n    hello-world-deployment that runs a container using the nginxdemos/hello image, which serves a simple HTML page. The container is configured to expose port 80. In the metadata section, we have specified to run the Pod in the namespace we created previously – that is, namespace: gitops-kubernetes.\n    ```", "```\n    $ kubectl apply -f hello-world-deployment.yaml\n    ```", "```\n    deployment.apps/hello-world-deployment created\n    service/hello-world-service unchanged\n    ```", "```\n    $ kubectl get pods --namespace gitops-kubernetes & kubectl get services --namespace gitops-kubernetes\n    ```", "```\n    [POD_NAME] with the name of your Pod. For instance, in *Figure 2**.12*, the name of the pod is hello-world-deployment-6b7f766747-nxj44. Here, [LOCAL_PORT] should be replaced with the local port on your machine – for example, 9000 (ensure that the local port is not already used by another running service!) – while [REMOTE_PORT] should be replaced with the port on the Pod that you want to forward traffic to. In our case, as reported in *Figure 2**.10*, the Pod port is 80.\n    ```", "```\n    $ kubectl port-forward hello-world-deployment-6b7f766747-nxj44 --namespace gitops-kubernetes 9000:80\n    ```", "```\n    Forwarding from 127.0.0.1:9000 -> 80\n    Forwarding from [::1]:9000 -> 80\n    ```", "```\n    curl to send a request to the local port that is being forwarded:\n\n    ```", "```\n\n    ```", "```\n$ sudo docker run hello-world\n```", "```\n# Use an official Python runtime as a parent image\nFROM python:3.8-slim\n# Set the working directory in the container\nWORKDIR /usr/src/app\n# Copy the current directory contents into the container at /usr/src/app\nCOPY . .\n# Install any needed packages specified in requirements.txt\nRUN pip install --no-cache-dir -r requirements.txt\n# Make port 80 available to the world outside this container\nEXPOSE 80\n# Define environment variable\nENV NAME World\n# Run app.py when the container launches\nCMD [\"python\", \"app.py\"]\n```", "```\n$ sudo docker build -t hello-world-py-app:1.0 .\n```", "```\n$ docker images\nREPOSITORY           TAG       IMAGE ID       CREATED         SIZE\nhello-world-py-app   1.0       765f270eef8c   7 minutes ago   139MB\nhello-world          latest    d2c94e258dcb   8 months ago    13.3kB\n```", "```\n$ sudo docker run -p 8080:8080 -ti hello-world-py-app:1.0\n```", "```\n$ curl http://localhost:8080\n```", "```\n$ curl localhost:8080/[YOUR_NAME_HERE]\n```", "```\n…\n@app.route('/datetime')\ndef datetime():\n    import datetime\n    now = datetime.datetime.now()\n    return now.strftime(\"%Y-%m-%d %H:%M:%S\")\n…\n```", "```\n    $ sudo docker build -t hello-world-py-app:2.0 .\n    ```", "```\n    $ sudo docker images\n    ```", "```\n    hello-world-py-app   2.0       a7d7ab4514fa   19 seconds ago      145MB\n    hello-world-py-app   1.0       3f8f095a7b37   About an hour ago   145MB\n    ```", "```\n    $ sudo docker run -p 8080:8080 -ti hello-world-py-app:2.0\n    ```", "```\n    * Serving Flask app 'app'\n    * Debug mode: on\n    WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.\n     * Running on all addresses (0.0.0.0)\n     * Running on http://127.0.0.1:8080\n     * Running on http://172.17.0.2:8080\n    Press CTRL+C to quit\n    …\n    ```", "```\n    $ curl http://localhost:8080/datetime\n    ```", "```\n    2024-01-13 12:39:50\n    ```", "```\n    username/repository:tag format. Run the following command to tag the previously built image:\n\n    ```", "```\n\n    ```", "```\n    hello-world-py-app:2.0 image is listed there.\n    ```", "```\n        spec:\n          sectioners:\n          - name: first-cd-pipeline\n            image: [yourusername]/hello-world-py-app:2.0\n    ```", "```\n    $ kubectl apply -f first-cd-pipeline-deployment.yaml\n    ```", "```\n    deployment.apps/first-cd-pipeline-deployment created\n    service/first-cd-pipeline-service created\n    ```", "```\n    $ kubectl get pods --namespace gitops-kubernetes & kubectl get services --namespace gitops-kubernetes\n    ```", "```\n    NAME                        TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE\n    first-cd-pipeline-service   NodePort   10.43.172.10   <none>        80:30007/TCP   29s\n    NAME                         READY   STATUS    RESTARTS   AGE\n    first-cd-pipeline-deployment-5b85cfd665-5626b   1/1     Running   0          29s\n    ```", "```\n    curl to test that the new feature has been deployed and hosted by the K3s cluster:\n\n    ```", "```\n\n    You should see an output similar to the following:\n\n    ```", "```\n\n    ```", "```\n    $ kubectl delete -f first-cd-pipeline-deployment.yaml\n    ```"]