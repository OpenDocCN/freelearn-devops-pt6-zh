- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Governing Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed at length different ways to extend Kubernetes,
    including validating and mutating requests during the admission control phase.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the growing role of Kubernetes in large
    enterprise organizations, what governance is, and how it is applied in Kubernetes.
    We will look at policy engines, review some popular ones, and then dive deep into
    Kyverno.
  prefs: []
  type: TYPE_NORMAL
- en: This ties in nicely with the previous chapter because policy engines are built
    on top of the Kubernetes admission control mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: More and more enterprise organizations put more and more of their proverbial
    eggs in the Kubernetes basket. These large organizations have severe security,
    compliance, and governance needs. Kubernetes policy engines are here to address
    these concerns and make sure that enterprise organizations can fully embrace Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the topics we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes in the enterprise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Kubernetes governance?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Policy engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Kyverno deep dive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s jump right in and understand the growing role and importance of Kubernetes
    in the enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes in the enterprise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The journey and adoption rate of the Kubernetes platform are unprecedented.
    It launched officially in 2016, and in a few years it has conquered the world
    of infrastructure. 96% of organizations that participated in the most recent CNCF
    survey are using or evaluating Kubernetes. The penetration of Kubernetes is across
    multiple dimensions: organization size, geographical location, and production
    and no-production environments. What is even more impressive is that Kubernetes
    can go under the hood and become the foundation that other technologies and platforms
    are built on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this in its widespread adoption by all the cloud providers that
    offer various flavors of managed Kubernetes, as well as with the hosted platform-as-a-service
    offerings from many vendors. Check out the CNCF-certified Kubernetes software
    conformance list: [https://www.cncf.io/certification/software-conformance](https://www.cncf.io/certification/software-conformance).'
  prefs: []
  type: TYPE_NORMAL
- en: Having a variety of certified vendors and value-added resellers, an ecosystem
    of multiple companies, etc. is extremely important for enterprise organizations.
    Enterprise organizations need much more than the latest shiny technology. The
    stakes are high, the failure rate of large infrastructure projects is high, and
    the consequences of failure are harsh. Combine all these factors, and the result
    is that enterprise organizations are very change-resistent and risk-averse when
    it comes to their technology. A lot of critical software systems in diverse fields
    like traffic control, insurance, healthcare, communication systems, and airlines
    are still running on software that was written 40–50 years ago, using languages
    like COBOL and Fortran.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements of enterprise software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at some requirements of enterprise software:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling large amounts of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with other systems and applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing robust security features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being scalable and available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being flexible and customizable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being compliant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having support from trusted vendors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having strong governance (much more on that later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does Kubernetes fit the bill?
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes and enterprise software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reason Kubernetes usage has grown so much in the enterprise software area
    is that it actually ticks all the boxes and keeps improving.
  prefs: []
  type: TYPE_NORMAL
- en: As the de facto standard for container orchestration platforms, it can serve
    as the foundation for all container-based deployment. Its ecosystem satisfies
    any integration needs, as every vendor must be able to run on Kubernetes. The
    long-term prospects for Kubernetes are extremely high, as it is a true team effort
    from many companies and organizations, and it is steered by an open and successful
    process that keeps delivering. Kubernetes spearheads the shift toward multi-cloud
    and hybrid-cloud deployments following industry-wide standards
  prefs: []
  type: TYPE_NORMAL
- en: The extensibility and flexibility of Kubernetes mean it can cater to any type
    of customization a particular enterprise will need.
  prefs: []
  type: TYPE_NORMAL
- en: It is truly a remarkable project that is designed on solid conceptual architecture
    and is able to deliver results consistently in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: At this point it’s clear that Kubernetes is great for enterprise organizations,
    but how does it address the need for governance?
  prefs: []
  type: TYPE_NORMAL
- en: What is Kubernetes governance?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Governance is one of the important requirements for enterprise organizations.
    In a nutshell, it means controlling the way an organization operates. Some elements
    of governance are:'
  prefs: []
  type: TYPE_NORMAL
- en: Policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Risk management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Administration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Governance includes a way to specify policies and mechanisms to enforce the
    policies, as well as reporting and auditing. Let’s look at various areas and practices
    of governance in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Image management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Containers run software baked into images. Managing these images is a critical
    activity in operating a Kubernetes-based system. There are several dimensions
    to consider: how do you bake your images? How do you vet third-party images? Where
    do you store your images? Making poor choices here can impact the performance
    of your system (for example, if you use large bloated base images) and crucially
    the security of your system (for example, if you use compromised or vulnerable
    base images). Image management policies can force image scanning or ensure that
    you can only use vetted images from specific image registries.'
  prefs: []
  type: TYPE_NORMAL
- en: Pod security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The unit of work of Kubernetes is the pod. There are many security settings
    you can set for a pod and its containers. The default security settings are unfortunately
    very lax. Validating and enforcing pod security policies can remediate this. Kubernetes
    has strong support and guidance for pod security standards as well as several
    built-in profiles. Each pod has a security context as we discussed in *Chapter
    4*, *Securing Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://kubernetes.io/docs/concepts/security/pod-security-standards/](https://kubernetes.io/docs/concepts/security/pod-security-standards/)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Network policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes network policies control traffic flow between pods and other network
    entities at layers 3 and 4 of the OSI network model (IP addresses and ports).
    The network entities may be pods that have a specific set of labels or all pods
    in a namespace with a specific set of labels. Finally, a network policy can also
    block pod access to/from a specific IP block.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of governance, network policies can be used to enforce compliance
    with security and regulatory requirements by controlling network access and communication
    between pods and other resources.
  prefs: []
  type: TYPE_NORMAL
- en: For example, network policies can be used to prevent pods from communicating
    with certain external networks. Network policies can also be used to enforce the
    separation of duties and prevent unauthorized access to sensitive resources within
    a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://kubernetes.io/docs/concepts/services-networking/network-policies/](https://kubernetes.io/docs/concepts/services-networking/network-policies/)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes is very flexible and provides a lot of controls for many aspects
    of its operation. The DevOps practices often used in a Kubernetes-based system
    allow teams a lot of control over how their workloads are deployed, how they scale,
    and what resources they use. Kubernetes provides configuration constraints like
    quotas and limits. With more advanced admission controllers you can validate and
    enforce policies that control any aspect of resource creation, such as the maximum
    size of an auto-scaling deployment, the total amount of persistent volume claims,
    and requiring that memory requests always equal memory limits (not necessarily
    a good idea).
  prefs: []
  type: TYPE_NORMAL
- en: RBAC and admission control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes **RBAC** (**Role-Based Access Control**) operates at the resource
    and verb level. Every Kubernetes resource has operations (verbs) that can be performed
    against it. With RBAC you define roles that are sets of permissions over resources,
    which you can apply at the namespace level or cluster level. It is a bit of a
    coarse-grained tool, but it is very convenient, especially if you segregate your
    resources at the namespace level and use cluster-level permissions only to manage
    workloads that operate across the entire cluster.
  prefs: []
  type: TYPE_NORMAL
- en: If you need something more granular that depends on specific attributes of resources,
    then admission controllers can handle it. We will explore this option later in
    the chapter when discussing policy engines.
  prefs: []
  type: TYPE_NORMAL
- en: Policy management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Governance is built around policies. Managing all these policies, organizing
    them, and ensuring they address the governance needs of an organization takes
    a lot of effort and is an ongoing task. Be prepared to devote resources to evolving
    and maintaining your policies.
  prefs: []
  type: TYPE_NORMAL
- en: Policy validation and enforcement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once a set of policies are in place, you need to validate requests to the Kubernetes
    API server against those policies and reject requests that violate these policies.
    There is another approach to enforcing policies that involves mutating incoming
    requests to comply with a policy. For example, if a policy requires that each
    pod must have a memory request of at most 2 GiB, then a mutating policy can trim
    down the memory request of pods with larger memory requests to 2 GiB.
  prefs: []
  type: TYPE_NORMAL
- en: Polices don’t have to be rigid. Exceptions and exclusions can be made for special
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Reporting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you manage a large number of policies and vet all requests it’s important
    to have visibility into how your policies can help you govern your system, prevent
    issues, and learn from usage patterns. Reports can provide insights by capturing
    and consolidating the results of policy decisions. As a human user you may view
    reports about policy violations and rejected and mutated requests, and detect
    trends or anomalies. At a higher level you can employ automated analysis, including
    an ML-based model to extract meaning from a large number of detailed reports.
  prefs: []
  type: TYPE_NORMAL
- en: Audit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes audit logs provide a timestamped play-by-play of every event in the
    system. When you couple audit data with governance reports you can piece together
    the timeline of incidents, especially security incidents, where the culprit can
    be identified by combining data from multiple sources, starting with a policy
    violation and ending with a root cause.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have covered the terrain of what governance is and how it specifically
    relates to Kubernetes. We emphasized the importance of policies to govern your
    system. Let’s look at policy engines and how they implement these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Policy engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Policy engines in Kubernetes provide comprehensive coverage of governance needs
    and complement built-in mechanisms, like network policies and RBAC. Policy engines
    can verify and ensure that your system utilizes best practices, follows security
    guidelines, and complies with external policies. In this section, we will look
    at admission control as the primary mechanism where policy engines hook into the
    system, the responsibilities of a policy engine, and a review of existing policy
    engines. After this, we will then dive deep into one of the best policy engines
    out there – Kyverno.
  prefs: []
  type: TYPE_NORMAL
- en: Admission control as the foundation of policy engines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Admission control is part of the life cycle of requests hitting the Kubernetes
    API server. We discussed it in depth in *Chapter 15*, *Extending Kubernetes*.
    As you recall, dynamic admission controllers are webhook servers that listen for
    admission review requests and accept, deny, or mutate them. Policy engines are
    first and foremost sophisticated admission controllers that register to listen
    for all requests that are relevant to their policies.
  prefs: []
  type: TYPE_NORMAL
- en: When a request comes in, the policy engine will apply all relevant policies
    to decide the fate of the request. For example, if a policy determines that Kubernetes
    services of the `LoadBalancer` type may be created only in a namespace called
    `load_balancer`, then the policy engine will register to listen for all Kubernetes
    service creation and update requests. When a service creation or update request
    arrives, the policy engine will check the type of the service and its namespace.
    If the service type is `LoadBalancer` and the namespace is not `load_balancer`,
    then the policy engine will reject the request. Note that this is something that
    can’t be done using RBAC. This is because RBAC can’t look at the type of service
    to determine if the request is valid or not.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how the policy engine utilizes the dynamic admission
    control process of Kubernetes, let’s look at the responsibilities of a policy
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: Responsibilities of a policy engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The policy engine is the primary tool for applying governance to a Kubernetes-based
    system. The policy engine should allow the administrators to define policies that
    go above and beyond the built-in Kubernetes policies, like RBAC and network policies.
    That often means coming up with a policy declaration language. The policy declaration
    language needs to be rich enough to cover all the nuances of Kubernetes, including
    fine-grained application to different resources and access to all the relevant
    information to base accept or reject decisions on for each resource.
  prefs: []
  type: TYPE_NORMAL
- en: The policy engine should also provide a way to organize, view, and manage policies.
    Ideally, the policy engine provides a good way to test policies before applying
    them to a live cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The policy engine has to provide a way to deploy policies to the cluster, and
    of course, it needs to apply the policies that are relevant for each request and
    decide if the request should be accepted as is, rejected, or modified (mutated).
    A policy engine may provide a way to generate additional resources when a request
    comes in. For example, when a new Kubernetes deployment is created, a policy engine
    may automatically generate a Horizontal Pod Autoscaler for the deployment. A policy
    engine may also listen to events that occur in the cluster and take action. Note
    that this capability goes beyond dynamic admission control, but it still enforces
    policies on the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review some Kubernetes policy engines and how they fulfill these responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Quick review of open source policy engines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When evaluating solutions, it’s very helpful to come up with evaluation criteria
    up front, since policy engines can deeply impact the operation of your Kubernetes
    cluster and its workloads’ maturity is a key element. Excellent documentation
    is crucial too, since the surface area of a policy engine is very large and you
    need to understand how to work with it. The capabilities of a policy engine determine
    what use cases it can handle. Writing policies is how administrators convey their
    governance intentions to the policy engine. It’s important to evaluate the user
    experience of writing and testing policies and what tooling is available to support
    these activities. Deploying the policies to the cluster is another must-have element.
    Finally, viewing reports and understanding the state of governance can be neglected.
  prefs: []
  type: TYPE_NORMAL
- en: We will review five policy engines along these dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: OPA/Gatekeeper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Open Policy Agent** (**OPA**) is a general-purpose policy engine that goes
    beyond Kubernetes ([https://www.openpolicyagent.org](https://www.openpolicyagent.org)).
    Its scope is very broad and it operates on any JSON value.'
  prefs: []
  type: TYPE_NORMAL
- en: Gatekeeper ([https://open-policy-agent.github.io/gatekeeper](https://open-policy-agent.github.io/gatekeeper))
    brings the OPA policy engine to Kubernetes by packaging it as an admission control
    webhook.
  prefs: []
  type: TYPE_NORMAL
- en: OPA/Gatekeeper is definitely the most mature policy engine. It was created in
    2017\. It is a graduated CNCF project, and it has 2.9k stars on GitHub at the
    time of writing. It is even used as a foundation for Azure policy on AKS. See
    [https://learn.microsoft.com/en-us/azure/governance/policy/concepts/policy-for-kubernetes](https://learn.microsoft.com/en-us/azure/governance/policy/concepts/policy-for-kubernetes).
  prefs: []
  type: TYPE_NORMAL
- en: OPA has its own special language called Rego ([https://www.openpolicyagent.org/docs/latest/policy-language/](https://www.openpolicyagent.org/docs/latest/policy-language/))
    for defining policies. Rego has a strong theoretical basis inspired by Datalog,
    but it may not be very intuitive and easy to grasp.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the architecture of OPA/Gatekeeper:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_16_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: OPA/Gatekeeper architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Overall, OPA/Gatekeeper is very powerful but seems a little clunky compared
    to other Kubernetes policy engines, as the OPA policy engine is bolted on top
    of Kubernetes via Gatekeeper.
  prefs: []
  type: TYPE_NORMAL
- en: OPA/Gatekeeper has mediocre documentation that is not very easy to navigate.
    However, it does have a policy library you can use as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you appreciate the maturity, and you’re not too concerned about
    using Rego and some friction, it may be a good choice for you.
  prefs: []
  type: TYPE_NORMAL
- en: Kyverno
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kyverno ([https://kyverno.io](https://kyverno.io)) is a mature and robust policy
    engine that was designed especially for Kubernetes from the get-go. It was created
    in 2019 and has made huge strides since then. It is a CNCF incubating project
    and has surpassed OPA/Gatekeeper in popularity on GitHub with 3.3k stars at the
    time of writing. Kyverno uses YAML JMESPath ([https://jmespath.org](https://jmespath.org))
    to define policies, which are really just Kubernetes custom resources. It has
    excellent documentation and a lot of examples to get you started writing your
    own policy.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, Kyverno is both powerful and easy to use. It has huge momentum behind
    it, and it keeps getting better and improving its performance and operation at
    scale. It is the best Kubernetes policy engine at the moment in my opinion. We
    will dive deep into Kyverno later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: jsPolicy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: jsPolicy ([https://www.jspolicy.com](https://www.jspolicy.com)) is an interesting
    project from Loft that has brought virtual clusters to the Kubernetes community.
    Its claim to fame is that it runs policies in a secure and performant browser-like
    sandbox, and you define the policies in JavaScript or TypeScript. The approach
    is refreshing, and the project is very slick and streamlined with good documentation.
    Unfortunately, it seems like Loft is focused on other projects and jsPolicy doesn’t
    get a lot of attention. It has only 242 GitHub stars ([https://github.com/loft-sh/jspolicy](https://github.com/loft-sh/jspolicy))
    at the time of writing, and the last commit was 6 months ago.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of utilizing the JavaScript ecosystem to package and share policies,
    as well as use its robust tooling to test and debug policies, has a lot of merit.
  prefs: []
  type: TYPE_NORMAL
- en: jsPolicy provides validating, mutating, and controller policies. Controller
    policies allow you to react to events occurring in the cluster outside the scope
    of admission control.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the architecture of jsPolicy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![js Policy architecture](img/B18998_16_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: jsPolicy architecture'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, I wouldn’t commit to jsPolicy since it may have been abandoned.
    However, if Loft or someone else decides to invest in it, it may be a contender
    in the field of Kubernetes policy engines.
  prefs: []
  type: TYPE_NORMAL
- en: Kubewarden
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubewarden ([https://www.kubewarden.io](https://www.kubewarden.io)) is another
    innovative policy engine. It is a CNCF sandbox project. Kubewarden focuses on
    being language-agnostic and allows you to write your policies in a variety of
    languages. The policies are then packaged into WebAssembly modules that are stored
    in any OCI registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'In theory, you can use any language that can be compiled into WebAssembly.
    In practice, the following languages are supported, but there are limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: Rust (of course, the most mature)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go (you need to use a special compiler, TinyGo, which doesn’t support all of
    Go’s features)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rego (using OPA directly or Gatekeeper – missing mutating policies)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift (using SwiftWasm, which requires some post-build optimizations)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript (or rather a subset called AssemblyScript)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubewarden supports validating, mutating, and context-aware policies. Context-aware
    policies are policies that use additional information to form an opinion of whether
    a request should be admitted or rejected. The additional information may include,
    for example, lists of namespaces, services, and ingresses that exist in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Kubewarden has a CLI called kwctl ([https://github.com/kubewarden/kwctl](https://github.com/kubewarden/kwctl))
    for managing your policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram of Kubewarden’s architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![KubeWarden architecture](img/B18998_16_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: Kubewarden architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Kubewarden is still evolving and growing. It has some nice ideas and motivations,
    but at this stage, it may appeal to you most if you are on the Rust wagon and
    prefer to write your policies in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at the landscape of Kubernetes open source policy engines,
    let’s dive in and take a closer look at Kyverno.
  prefs: []
  type: TYPE_NORMAL
- en: Kyverno deep dive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kyverno is a rising star in the Kubernetes policy engine arena. Let’s get hands-on
    with it, and see how it works and why it is so popular. In this section, we will
    introduce Kyverno, install it, and learn how to write, apply, and test policies.
  prefs: []
  type: TYPE_NORMAL
- en: Quick intro to Kyverno
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kyverno is a policy engine that was designed especially for Kubernetes. If you
    have some experience working with kubectl, Kubernetes manifests, or YAML, then
    Kyverno will feel very familiar. You define policies and configuration using YAML
    manifests and the JMESPath language, which is very close to the JSONPATH format
    of kubectl.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the Kyverno architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kyverno architecture](img/B18998_16_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: Kyverno architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kyverno covers a lot of ground and has many features:'
  prefs: []
  type: TYPE_NORMAL
- en: GitOps for policy management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource validation (to reject invalid resources)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource mutation (to modify invalid resources)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource generation (to generate additional resources automatically)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying container images (important for software supply chain security)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting image metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using label selectors and wildcards to match and exclude resources (Kubernetes-native)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using overlays to validate and mutate resources (similar to Kustomize!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing configurations across namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating in reporting or enforcing mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying policies using a dynamic admission webhook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying policies at CI/CD time using the Kyverno CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing policies and validating resources ad hoc using the Kyverno CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-availability mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fail open or closed (allowing or rejecting resources when the Kyverno admission
    webhook is down)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Policy violation reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web UI for easy visualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observability support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is an impressive list of features and capabilities. The Kyverno developers
    keep evolving and improving it. Kyverno has made big strides in scalability, performance,
    and the ability to handle a large number of policies and resources.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s install Kyverno and configure it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Kyverno
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kyverno follows a similar upgrade policy as Kubernetes itself, where the node
    components version must be at most two minor versions below the control plane
    version. At the time of writing, Kyverno 1.8 is the latest version, which supports
    Kubernetes versions 1.23–1.25.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install Kyverno using kubectl or Helm. Let’s go with the Helm option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s install Kyverno, using the default single replica, into its own namespace.
    Using one replica is NOT recommended for production, but it’s okay for experimenting
    with Kyverno. To install it in high-availability mode, add the `--set replicaCount=3`
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s observe what we have just installed using the ketall kubectl plugin:
    ([https://github.com/corneliusweig/ketall](https://github.com/corneliusweig/ketall)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Kyverno installed all the expected resources: deployment, services,
    roles and role bindings, config maps, and secrets. We can tell that Kyverno exposes
    metrics and uses leader election too.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, Kyverno installed many CRDs (at the cluster scope):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, Kyverno configures several admission control webhooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows the result of a typical Kyverno installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kyverno installation](img/B18998_16_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: Typical Kyverno installation'
  prefs: []
  type: TYPE_NORMAL
- en: Installing pod security policies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Kyverno has an extensive library of pre-built policies. We can install the
    pod security standard policies (see [https://kyverno.io/policies/pod-security/](https://kyverno.io/policies/pod-security/))
    using Helm too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the policies themselves are cluster policies and are not visible
    in the namespace `kyverno-policies`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We will review some of these policies in depth later. First, let’s see how to
    configure Kyverno.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Kyverno
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can configure the behavior of Kyverno by editing the Kyverno config map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `resourceFilters` flag is a list in the format `[kind,namespace,name]`,
    where each element may be a wildcard too, that tells Kyverno which resources to
    ignore. Resources that match any of the filters will not be subject to any Kyverno
    policy. This is good practice if you have a lot of policies to save the evaluation
    effort against all policies.
  prefs: []
  type: TYPE_NORMAL
- en: The `webHooks` flag allows you to filter out whole namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: The `excludeGroupRole` flag is a string of comma-separated roles. It will exclude
    requests, where a user has one of the specified roles from Kyverno admission control.
    The default list is `system:serviceaccounts:kube-system,system:nodes,system:kube-scheduler`.
  prefs: []
  type: TYPE_NORMAL
- en: The `excludeUsername` flag represents a string consisting of Kubernetes usernames
    separated by commas. When a user enables `Synchronize` in `generate policy`, Kyverno
    becomes the only entity capable of updating or deleting generated resources. However,
    administrators have the ability to exclude specific usernames from accessing the
    delete/update-generated resource functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The `generateSuccessEvents` flag is a Boolean parameter used to determine whether
    success events should be generated. By default, this flag is set to `false`, indicating
    that success events are not generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the Kyverno container provides several container arguments that
    can be configured to customize its behavior and functionality. These arguments
    allow for fine-tuning and customization of Kyverno’s behavior within the container.
    You can edit the list of args in the Kyverno deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the pre-configured `--autogenInternals` and `--loggingFormat`,
    the following flags are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`admissionReports`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowInsecureRegistry`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoUpdateWebhooks`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backgroundScan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clientRateLimitBurst`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clientRateLimitQPS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disableMetrics`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enableTracing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`genWorkers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imagePullSecrets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imageSignatureRepository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubeconfig`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxQueuedEvents`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metricsPort`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`otelCollector`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`otelConfig`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`profile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`profilePort`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protectManagedResources`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reportsChunkSize`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serverIP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`splitPolicyReport` (deprecated – will be removed in 1.9)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transportCreds`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webhookRegistrationTimeout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webhookTimeout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the flags have a default value, and you only need to specify them if you
    want to override the defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Check out [https://kyverno.io/docs/installation/#container-flags](https://kyverno.io/docs/installation/#container-flags)
    for details on each flag.
  prefs: []
  type: TYPE_NORMAL
- en: We installed Kyverno, observed the various resources it installed, and looked
    at its configuration. It’s time to check out the policies and rules of Kyverno.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Kyverno policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the user level, the unit of work in Kyverno is policies. You can apply policies
    as Kubernetes resources, write and edit your own policies, and test policies using
    the Kyverno CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying a Kyverno policy is as simple as applying any other resource. Let’s
    take a look at one of the policies we installed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The purpose of the policy is to prevent pods from requesting extra Linux capabilities
    beyond the allowed list (see [https://linux-audit.com/linux-capabilities-101/](https://linux-audit.com/linux-capabilities-101/)).
    One of the capabilities that is not allowed is `NET_ADMIN`. Let’s create a pod
    that requests this capability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The pod was created, and we can verify that it has the `NET_ADMIN` capability.
    I use a kind cluster, so the cluster node is just a Docker process we can exec
    into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’re in a shell inside the node, we can search for the process of
    our container, which just sleeps for 999,999 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s check the capabilities of our process, 4549:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the `cap_net_admin` is present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kyverno didn’t prevent the pod from being created because the policy operates
    in audit mode only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s delete the pod and change the policy to “enforce” mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we try to create the pod again, the result is very different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Kyverno admission webhook enforced the policy and rejected the pod creation.
    It even tells us which policy was responsible (`disallow-capabilities`) and displays
    a nice message that explains the reason for the rejection, including a list of
    the allowed capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: It is pretty simple to apply policies. Writing policies is much more involved
    and requires an understanding of resource requests, Kyverno matching rules, and
    the JMESPath language. Before we can write policies, we need to understand how
    they are structured and what their different elements are.
  prefs: []
  type: TYPE_NORMAL
- en: Kyverno policies in depth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn all the fine details about Kyverno policies.
    A Kyverno policy has a set of rules that define what the policy actually does
    and several general settings that define how the policy behaves in different scenarios.
    Let’s start with the policy settings and then move on to rules and different use
    cases, such as validating, mutating, and generating resources.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding policy settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Kyverno policy may have the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`applyRules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validationFailureAction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validationFailureActionOverrides`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`background`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schemaValidation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`failurePolicy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webhookTimeoutSeconds`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `applyRules` setting determines if only one or multiple rules apply to matching
    resources. The valid values are “One” and “All” (the default). If `applyRules`
    is set to “One” then the first matching rule will be evaluated and other rules
    will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The `validationFailureAction` setting determines if a failed validation policy
    rule should reject the admission request or just report it. The valid values are
    “audit” (default – always allows and just reports violations) and “enforce” (blocks
    invalid requests).
  prefs: []
  type: TYPE_NORMAL
- en: The `validationFailureActionOverrides` setting is a `ClusterPolicy` attribute
    that overrides the `validationFailureAction` for specific namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: The `background` setting determines if policies are applied to existing resources
    during a background scan. The default is “true”.
  prefs: []
  type: TYPE_NORMAL
- en: The `schemaValidation` setting determines if policy validation checks are applied.
    The default is “true”.
  prefs: []
  type: TYPE_NORMAL
- en: The `failurePolicy` setting determines how the API server behaves if the webhook
    fails to respond. The valid values are “Ignore” and “Fail” (the default). If the
    setting is “Fail” then even valid resource requests will be denied, while the
    webhook is unreachable.
  prefs: []
  type: TYPE_NORMAL
- en: The `webhookTimeoutSeconds` determines the maximum time in seconds that the
    webhook is allowed to evaluate a policy. The valid values are between 1 and 30
    seconds. The default is 10 seconds. If the webhook failed to respond in time,
    the `failurePolicy` (see above) determines the fate of the request.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Kyverno policy rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each Kyverno policy has one or more rules. Each rule has a `match` declaration,
    an optional `exclude` declaration, an optional `preconditions` declaration, and
    exactly one of the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`validate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mutate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verifyImages`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The diagram below demonstrates the structure of a Kyverno policy and its rules
    (policy settings are omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kyverno rule structure](img/B18998_16_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.6: Kyverno rule structure'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go over the different declarations and explore some advanced topics too.
  prefs: []
  type: TYPE_NORMAL
- en: Matching requests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When a resource request arrives, the Kyverno webhook needs to determine for
    each policy if the requested resource and/or operation is relevant for the current
    policy. The mandatory `match` declaration has several filters that determine if
    the policy should evaluate the current request. The filters are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subjects`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`roles`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clusterRoles`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `match` declaration may have multiple filters grouped under an `any` statement
    or an `all` statement. When filters are grouped under `any`, then Kyverno will
    apply OR semantics to match them, and if any of the filters match the request,
    the request is considered matched. When filters are grouped under `all`, then
    Kyverno will apply AND semantics, and all the filters must match in order for
    the request to be considered a match.
  prefs: []
  type: TYPE_NORMAL
- en: This can be a little overwhelming. Let’s look at an example. The following policy
    spec has a single rule called `some-rule`. The rule has a `match` declaration
    with two resource filters under an `any` statement. The first resource filter
    matches resources of kind `Service` with names `service-1` or `service-2`. The
    second resource filter matches resources of kind `Service` in the namespace `ns-1`.
    This rule will match any Kubernetes service named `service-1` or `service-2` in
    any namespace, as well as any service in the namespace `ns-1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at another example. This time we add a cluster role filter. The following
    rule will match requests where the kind is a service named `service-1` and the
    requesting user has a cluster role called `some-cluster-role`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The admission review resource contains all the roles and cluster roles bound
    to the requesting user or service account.
  prefs: []
  type: TYPE_NORMAL
- en: Excluding resources
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Excluding resources is very similar to matching. It is very common to set policies
    that disallow all requests to create or update some resources unless they are
    made in certain namespaces or by users with certain roles. Here is an example
    that matches all services but excludes the `ns-1` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Another common exclusion is for specific roles like `cluster-admin`.
  prefs: []
  type: TYPE_NORMAL
- en: Using preconditions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Limiting the scope of a policy using `match` and `exclude` is great, but in
    many cases it is not sufficient. Sometimes, you need to select resources based
    on fine-grained details such as memory requests. Here is an example that matches
    all pods that request memory of less than 1 GiB.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for the key value uses JMESPath ([https://jmespath.org](https://jmespath.org))
    on the built-in request object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Validating requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The primary use case of Kyverno is validating requests. Validating rules have
    a `validate` statement. The `validate` statement has a `message` field that will
    be displayed if the request fails to validate. A validating rule has two forms,
    pattern-based validation and deny-based validation. Let’s examine each of them.
    As you may recall, the result of a resource failing to validate depends on the
    `validationFailureAction` field, which can be `audit` or `enforce`.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern-based validation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A rule with pattern-based validation has a `pattern` field under the `validate`
    statement. If the resource doesn’t match the pattern, the rule failed. Here is
    an example of pattern-based validation, where the resource must have a label called
    `app`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The validation part will only be applied to requests that comply with the `match`
    and `preconditions` statements and are not excluded by the `exclude` statement,
    if there are any.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also apply operators to values in the pattern – for example, here is
    a validation rule that requires that the number of replicas of a deployment will
    be at least 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Deny-based validation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A rule with deny-based validation has a `deny` field under the `validate` statement.
    Deny rules are similar to the preconditions that we saw earlier for selecting
    resources. Each deny condition has a key, an operator, and a value. A common use
    for the deny condition is disallowing a specific operation such as `DELETE`. The
    following examples use deny-based validation to prevent the deletion of Deployments
    and StatefulSets. Note the use of request variables both for the message and the
    key. For `DELETE` operations the deleted object is defined as `request.oldObject`
    and not `request.object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There is more to validation, which you can explore here: [https://kyverno.io/docs/writing-policies/validate/](https://kyverno.io/docs/writing-policies/validate/)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s turn our attention to mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mutation may sound scary, but all it is is modifying the resource in a request
    in some way. Note that the mutated request will still go through validation even
    if it matches any policy. It is not possible to change the kind of the requested
    object, but you can change its properties. The benefit of mutation is that you
    can automatically fix invalid requests, which is typically a better user experience
    instead of blocking invalid requests. The downside (especially if the invalid
    resources were created as part of a CI/CD pipeline) is that it creates a dissonance
    between the source code and the actual resources in the cluster. However, it is
    great for use cases where you want to control some aspects that users don’t need
    to be aware of, as well as during migration.
  prefs: []
  type: TYPE_NORMAL
- en: Enough theory – let’s see what mutation looks like in Kyverno. You still need
    to select the resources to mutate, which means that the `match`, `exclude`, and
    `precondition` statements are still needed for mutation policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, instead of a `validate` statement you will have a `mutate` statement.
    Here is an example that uses the `patchStrategicMerge` flavor to set the `imagePullPolicy`
    of containers that use an image with the `latest` tag. The syntax is similar to
    Kustomize overlays and merges with the existing resource. The reason the `image`
    field is in parentheses is because of a JMESPath feature called anchors ([https://kyverno.io/docs/writing-policies/validate/#anchors](https://kyverno.io/docs/writing-policies/validate/#anchors)),
    where the rest of the subtree is applied only if the given field matches it. In
    this case it means the `imagePullPolicy` will only be set for images that satisfy
    the condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: patch-config-map'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'match:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'any:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- resources:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'names:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- the-config-map'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kinds:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- ConfigMap'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'mutate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'patchesJson6902: |-'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- path: "/data/properties"'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'op: add'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'value: |'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: prop-1=value-1
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: prop-2=value-2
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- path: "/data/key"'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'op: add'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'value: some-string'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: deny-all-traffic'
  prefs: []
  type: TYPE_NORMAL
- en: 'match:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'any:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kinds:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Namespace'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'generate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kind: NetworkPolicy'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'apiVersion: networking.k8s.io/v1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: deny-all-traffic'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'namespace: "{{request.object.metadata.name}}"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'data:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'spec:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '# select all pods in the namespace'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'podSelector: {}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'policyTypes:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Ingress'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Egress'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: clone-config-map'
  prefs: []
  type: TYPE_NORMAL
- en: 'match:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'any:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kinds:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Namespace'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'generate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kind: ConfigMap'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'apiVersion: v1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '# Name of the generated resource'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: default-config'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'namespace: "{{request.object.metadata.name}}"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'synchronize: true'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'clone:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'namespace: default'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: config-template'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: configmap-lookup'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'context:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: dictionary'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'configMap:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: some-config-map'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'namespace: some-namespace'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'match:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'any:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- resources:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kinds:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Pod'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'mutate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'patchStrategicMerge:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'labels:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'environment: "{{dictionary.data.env}}"'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: $ cat <<EOF | k apply -f -
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: kyverno.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterPolicy'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: disallow-some-services'
  prefs: []
  type: TYPE_NORMAL
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'validationFailureAction: Enforce'
  prefs: []
  type: TYPE_NORMAL
- en: 'rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: some-rule'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'match:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'any:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- resources:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kinds:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Service'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'names:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- "service-1"'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- "service-2"'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- resources:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kinds:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Service'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'namespaces:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- "ns-1"'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'validate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'message: >-'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: services named service-1 and service-2 and
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: any service in namespace ns-1 are not allowed
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'deny: {}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: EOF
  prefs: []
  type: TYPE_NORMAL
- en: clusterpolicy.kyverno.io/disallow-some-services created
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: $ k create service clusterip service-1 -n default --tcp=80 --dry-run=server
  prefs: []
  type: TYPE_NORMAL
- en: 'error: failed to create ClusterIP service: admission webhook "validate.kyverno.svc-fail"
    denied the request:'
  prefs: []
  type: TYPE_NORMAL
- en: 'policy Service/default/service-1 for resource violations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'disallow-some-services:'
  prefs: []
  type: TYPE_NORMAL
- en: 'some-rule: services named service-1 and service-2 and  any service in namespace'
  prefs: []
  type: TYPE_NORMAL
- en: ns-1 are not allowed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'exclude-services-namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: 'some-rule: services are not allowed, except in the ns-1 namespace'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: $ k create service clusterip service-1 -n default --tcp=80 --dry-run=client
  prefs: []
  type: TYPE_NORMAL
- en: service/service-1 created (dry run)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: $ k create service clusterip service-3 -n default --tcp=80 --dry-run=server
  prefs: []
  type: TYPE_NORMAL
- en: service/service-3 created (server dry run)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: $ k create ns ns-1
  prefs: []
  type: TYPE_NORMAL
- en: $ k create service clusterip service-3 -n ns-1 --tcp=80 --dry-run=server
  prefs: []
  type: TYPE_NORMAL
- en: 'error: failed to create ClusterIP service: admission webhook "validate.kyverno.svc-fail"
    denied the request:'
  prefs: []
  type: TYPE_NORMAL
- en: 'policy Service/ns-1/service-3 for resource violation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'disallow-some-services:'
  prefs: []
  type: TYPE_NORMAL
- en: 'some-rule: services named service-1 and service-2 and  any service in namespace'
  prefs: []
  type: TYPE_NORMAL
- en: ns-1 are not allowed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '$ k patch clusterpolicies.kyverno.io disallow-some-services --type merge -p
    ''{"spec": {"validationFailureAction": "Audit"}}'''
  prefs: []
  type: TYPE_NORMAL
- en: clusterpolicy.kyverno.io/disallow-some-services patched
  prefs: []
  type: TYPE_NORMAL
- en: $ k create service clusterip service-3 -n ns-1 --tcp=80 --dry-run=server
  prefs: []
  type: TYPE_NORMAL
- en: service/service-3 created (server dry run)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: $ k get policyreports.wgpolicyk8s.io -n ns-1
  prefs: []
  type: TYPE_NORMAL
- en: NAME                          PASS   FAIL   WARN   ERROR   SKIP   AGE
  prefs: []
  type: TYPE_NORMAL
- en: cpol-disallow-some-services   0      1      0      0       0      2m4s
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: $ cat <<EOF | k apply -f -
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: kyverno.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterPolicy'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: set-image-pull-policy'
  prefs: []
  type: TYPE_NORMAL
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: set-image-pull-policy'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'match:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'any:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- resources:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kinds:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Pod'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'mutate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'patchStrategicMerge:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'spec:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'containers:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '# match images which end with :latest'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- (image): "*:latest"'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: set the imagePullPolicy to "IfNotPresent"
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'imagePullPolicy: "IfNotPresent"'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: EOF
  prefs: []
  type: TYPE_NORMAL
- en: clusterpolicy.kyverno.io/set-image-pull-policy created
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: $ cat <<EOF | k apply -f -
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: Pod'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: some-pod'
  prefs: []
  type: TYPE_NORMAL
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: some-container'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'image: g1g1/py-kube:latest'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- sleep'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- "9999"'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: EOF
  prefs: []
  type: TYPE_NORMAL
- en: pod/some-pod created
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: $ k get po some-pod -o yaml | yq '.spec.containers[0].imagePullPolicy'
  prefs: []
  type: TYPE_NORMAL
- en: IfNotPresent
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: $ k delete clusterpolicy set-image-pull-policy
  prefs: []
  type: TYPE_NORMAL
- en: clusterpolicy.kyverno.io "set-image-pull-policy" deleted
  prefs: []
  type: TYPE_NORMAL
- en: $ cat <<EOF | k apply -f -
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: Pod'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: another-pod'
  prefs: []
  type: TYPE_NORMAL
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: some-container'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'image: g1g1/py-kube:latest'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- sleep'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- "9999"'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: EOF
  prefs: []
  type: TYPE_NORMAL
- en: pod/another-pod created
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: $ k get po another-pod -o yaml | yq '.spec.containers[0].imagePullPolicy'
  prefs: []
  type: TYPE_NORMAL
- en: Always
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: cat <<EOF | k apply -f -
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: kyverno.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterPolicy'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: deny-all-traffic'
  prefs: []
  type: TYPE_NORMAL
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: deny-all-traffic'
  prefs: []
  type: TYPE_NORMAL
- en: 'match:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'any:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kinds:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Namespace'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'exclude:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'any:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'namespaces:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- kube-system'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- default'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- kube-public'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- kyverno'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'generate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kind: NetworkPolicy'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'apiVersion: networking.k8s.io/v1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: deny-all-traffic'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'namespace: "{{request.object.metadata.name}}"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'data:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'spec:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '# select all pods in the namespace'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'podSelector: {}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'policyTypes:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Ingress'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Egress'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: EOF
  prefs: []
  type: TYPE_NORMAL
- en: clusterpolicy.kyverno.io/deny-all-traffic created
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: $ k create ns ns-2
  prefs: []
  type: TYPE_NORMAL
- en: namespace/ns-2 created
  prefs: []
  type: TYPE_NORMAL
- en: $ k get networkpolicy -n ns-2
  prefs: []
  type: TYPE_NORMAL
- en: NAME               POD-SELECTOR   AGE
  prefs: []
  type: TYPE_NORMAL
- en: deny-all-traffic   <none>         15s
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: $ kyverno version
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: 1.8.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Time: 2022-12-20T08:41:43Z'
  prefs: []
  type: TYPE_NORMAL
- en: 'Git commit ID: c19061758dc4203106ab6d87a245045c20192721'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: $ kyverno
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Native Policy Management
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage:'
  prefs: []
  type: TYPE_NORMAL
- en: kyverno [command]
  prefs: []
  type: TYPE_NORMAL
- en: 'Available Commands:'
  prefs: []
  type: TYPE_NORMAL
- en: apply       applies policies on resources
  prefs: []
  type: TYPE_NORMAL
- en: completion  Generate the autocompletion script for the specified shell
  prefs: []
  type: TYPE_NORMAL
- en: help        Help about any command
  prefs: []
  type: TYPE_NORMAL
- en: jp          Provides a command-line interface to JMESPath, enhanced with Kyverno
    specific custom functions
  prefs: []
  type: TYPE_NORMAL
- en: test        run tests from directory
  prefs: []
  type: TYPE_NORMAL
- en: version     Shows current version of kyverno
  prefs: []
  type: TYPE_NORMAL
- en: 'Flags:'
  prefs: []
  type: TYPE_NORMAL
- en: --add_dir_header           If true, adds the file directory to the header of
    the log messages
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -h, --help                     help for kyverno
  prefs: []
  type: TYPE_NORMAL
- en: --log_file string          If non-empty, use this log file (no effect when -logtostderr=true)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --log_file_max_size uint   Defines the maximum size a log file can grow to (no
    effect when -logtostderr=true). Unit is megabytes. If the value is 0, the maximum
    file size is unlimited. (default 1800)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --one_output               If true, only write logs to their native severity
    level (vs also writing to each lower severity level; no effect when -logtostderr=true)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --skip_headers             If true, avoid header prefixes in the log messages
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --skip_log_headers         If true, avoid headers when opening log files (no
    effect when -logtostderr=true)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -v, --v Level                  number for the log level verbosity
  prefs: []
  type: TYPE_NORMAL
- en: Use "kyverno [command] --help" for more information about a command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: $ k apply -f some-pod.yaml -o yaml --dry-run=server | yq '.spec.containers[0].imagePullPolicy'
  prefs: []
  type: TYPE_NORMAL
- en: Always
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: $ kyverno apply mutate-image-pull-policy.yaml --resource some-pod.yaml
  prefs: []
  type: TYPE_NORMAL
- en: Applying 1 policy rule to 1 resource...
  prefs: []
  type: TYPE_NORMAL
- en: 'mutate policy set-image-pull-policy applied to default/Pod/some-pod:'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: Pod'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: some-pod'
  prefs: []
  type: TYPE_NORMAL
- en: 'namespace: default'
  prefs: []
  type: TYPE_NORMAL
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '- command:'
  prefs: []
  type: TYPE_NORMAL
- en: '- sleep'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- "9999"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'image: g1g1/py-kube:latest'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'imagePullPolicy: IfNotPresent'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: some-container'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '---'
  prefs: []
  type: TYPE_NORMAL
- en: 'pass: 1, fail: 0, warn: 0, error: 0, skip: 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: $ cat some-pod.yaml
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: Pod'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: some-pod'
  prefs: []
  type: TYPE_NORMAL
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: some-container'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'image: g1g1/py-kube:latest'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- sleep'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- "9999"'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: $ cat some-pod.yaml | kyverno jp 'length(spec.containers[0].command) | subtract(@,
    `1`)'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'name: <some name>'
  prefs: []
  type: TYPE_NORMAL
- en: 'policies:'
  prefs: []
  type: TYPE_NORMAL
- en: '- <path/to/policy.yaml>'
  prefs: []
  type: TYPE_NORMAL
- en: '- <path/to/policy.yaml>'
  prefs: []
  type: TYPE_NORMAL
- en: 'resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '- <path/to/resource.yaml>'
  prefs: []
  type: TYPE_NORMAL
- en: '- <path/to/resource.yaml>'
  prefs: []
  type: TYPE_NORMAL
- en: 'variables: variables.yaml # optional file for declaring variables'
  prefs: []
  type: TYPE_NORMAL
- en: 'userinfo: user_info.yaml # optional file for declaring admission request information
    (roles, cluster roles and subjects)'
  prefs: []
  type: TYPE_NORMAL
- en: 'results:'
  prefs: []
  type: TYPE_NORMAL
- en: '- policy: <name>'
  prefs: []
  type: TYPE_NORMAL
- en: 'rule: <name>'
  prefs: []
  type: TYPE_NORMAL
- en: 'resource: <name>'
  prefs: []
  type: TYPE_NORMAL
- en: 'resources: # optional, primarily for `validate` rules. One of either `resource`
    or `resources[]` must be specified. Use `resources[]` when a number of different
    resources should all share the same test result.'
  prefs: []
  type: TYPE_NORMAL
- en: '- <name_1>'
  prefs: []
  type: TYPE_NORMAL
- en: '- <name_2>'
  prefs: []
  type: TYPE_NORMAL
- en: 'namespace: <name> # when testing for a resource in a specific Namespace'
  prefs: []
  type: TYPE_NORMAL
- en: 'patchedResource: <file_name.yaml> # when testing a mutate rule this field is
    required.'
  prefs: []
  type: TYPE_NORMAL
- en: 'generatedResource: <file_name.yaml> # when testing a generate rule this field
    is required.'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: <kind>'
  prefs: []
  type: TYPE_NORMAL
- en: 'result: pass'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'name: test-some-rule'
  prefs: []
  type: TYPE_NORMAL
- en: 'policies:'
  prefs: []
  type: TYPE_NORMAL
- en: '- ../disallow-some-services-policy.yaml'
  prefs: []
  type: TYPE_NORMAL
- en: 'resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '- test-service-ok.yaml'
  prefs: []
  type: TYPE_NORMAL
- en: '- test-service-bad-name.yaml'
  prefs: []
  type: TYPE_NORMAL
- en: '- test-service-bad-namespace.yaml'
  prefs: []
  type: TYPE_NORMAL
- en: 'results:'
  prefs: []
  type: TYPE_NORMAL
- en: '- policy: disallow-some-services'
  prefs: []
  type: TYPE_NORMAL
- en: 'rule: some-rule'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- service-ok'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kind: Service'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'result: skip'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- policy: disallow-some-services'
  prefs: []
  type: TYPE_NORMAL
- en: 'rule: some-rule'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- service-1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kind: Service'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'result: fail'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- policy: disallow-some-services'
  prefs: []
  type: TYPE_NORMAL
- en: 'rule: some-rule'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- service-in-ns-1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kind: Service'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'namespace: ns-1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'result: fail'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '- policy: disallow-some-services'
  prefs: []
  type: TYPE_NORMAL
- en: 'rule: some-rule'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- service-ok'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'result: skip'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '- policy: disallow-some-services'
  prefs: []
  type: TYPE_NORMAL
- en: 'rule: some-rule'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- service-1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kind: Service'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'result: fail'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'apiVersion: v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: Service'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'labels:'
  prefs: []
  type: TYPE_NORMAL
- en: 'app: service-1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: service-1'
  prefs: []
  type: TYPE_NORMAL
- en: 'namespace: ns-2'
  prefs: []
  type: TYPE_NORMAL
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: https'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'port: 443'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'targetPort: https'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'selector:'
  prefs: []
  type: TYPE_NORMAL
- en: 'app: some-app'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '- policy: disallow-some-services'
  prefs: []
  type: TYPE_NORMAL
- en: 'rule: some-rule'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- service-in-ns-1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kind: Service'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'namespace: ns-1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'result: fail'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: $ kyverno test .
  prefs: []
  type: TYPE_NORMAL
- en: Executing test-some-rule...
  prefs: []
  type: TYPE_NORMAL
- en: applying 1 policy to 3 resources...
  prefs: []
  type: TYPE_NORMAL
- en: │───│────────────────────────│───────────│──────────────────────────────│────────│
  prefs: []
  type: TYPE_NORMAL
- en: '│ # │ POLICY                 │ RULE      │ RESOURCE                     │ RESULT
    │'
  prefs: []
  type: TYPE_NORMAL
- en: │───│────────────────────────│───────────│──────────────────────────────│────────│
  prefs: []
  type: TYPE_NORMAL
- en: │ 1 │ disallow-some-services │ some-rule │ ns-2//service-ok             │ Pass   │
  prefs: []
  type: TYPE_NORMAL
- en: │ 2 │ disallow-some-services │ some-rule │ ns-2/Service/service-1       │ Pass   │
  prefs: []
  type: TYPE_NORMAL
- en: │ 3 │ disallow-some-services │ some-rule │ ns-1/Service/service-in-ns-1 │ Pass   │
  prefs: []
  type: TYPE_NORMAL
- en: │───│────────────────────────│───────────│──────────────────────────────│────────│
  prefs: []
  type: TYPE_NORMAL
- en: 'Test Summary: 3 tests passed and 0 tests failed'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: kyverno test . --test-case-selector "policy=disallow-some-services, rule=some-rule,
    resource=service-ok"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: $ k create service clusterip service-3 -n ns-1 --tcp=80
  prefs: []
  type: TYPE_NORMAL
- en: service/service-3 created
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: $ k get polr -n ns-1
  prefs: []
  type: TYPE_NORMAL
- en: NAME                          PASS   FAIL   WARN   ERROR   SKIP   AGE
  prefs: []
  type: TYPE_NORMAL
- en: cpol-disallow-some-services   0      1      0      0       0      1m
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: $ k create service clusterip service-4 -n ns-1 --tcp=80
  prefs: []
  type: TYPE_NORMAL
- en: service/service-4 created
  prefs: []
  type: TYPE_NORMAL
- en: $ k get polr -n ns-1
  prefs: []
  type: TYPE_NORMAL
- en: NAME                          PASS   FAIL   WARN   ERROR   SKIP   AGE
  prefs: []
  type: TYPE_NORMAL
- en: cpol-disallow-some-services   0      2      0      0       0      2m
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: $ k get polr cpol-disallow-some-services -n ns-1 -o yaml
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: wgpolicyk8s.io/v1alpha2'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: PolicyReport'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'creationTimestamp: "2023-01-22T04:01:12Z"'
  prefs: []
  type: TYPE_NORMAL
- en: 'generation: 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'labels:'
  prefs: []
  type: TYPE_NORMAL
- en: 'app.kubernetes.io/managed-by: kyverno'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'cpol.kyverno.io/disallow-some-services: "2472317"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: cpol-disallow-some-services'
  prefs: []
  type: TYPE_NORMAL
- en: 'namespace: ns-1'
  prefs: []
  type: TYPE_NORMAL
- en: 'resourceVersion: "2475547"'
  prefs: []
  type: TYPE_NORMAL
- en: 'uid: dadcd6ae-a867-4ec8-bf09-3e6ca76da7ba'
  prefs: []
  type: TYPE_NORMAL
- en: 'results:'
  prefs: []
  type: TYPE_NORMAL
- en: '- message: services named service-1 and service-2 and  any service in namespace
    ns-1'
  prefs: []
  type: TYPE_NORMAL
- en: are not allowed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'policy: disallow-some-services'
  prefs: []
  type: TYPE_NORMAL
- en: 'resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '- apiVersion: v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: Service'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: service-4'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'namespace: ns-1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'uid: 4d473ac1-c1b1-4929-a70d-fad98a411428'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'result: fail'
  prefs: []
  type: TYPE_NORMAL
- en: 'rule: some-rule'
  prefs: []
  type: TYPE_NORMAL
- en: 'scored: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'source: kyverno'
  prefs: []
  type: TYPE_NORMAL
- en: 'timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: 'nanos: 0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'seconds: 1674361576'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- message: services named service-1 and service-2 and  any service in namespace
    ns-1'
  prefs: []
  type: TYPE_NORMAL
- en: are not allowed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'policy: disallow-some-services'
  prefs: []
  type: TYPE_NORMAL
- en: 'resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '- apiVersion: v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: Service'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: service-3'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'namespace: ns-1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'uid: 62458ac4-fe39-4854-9f5a-18b26109511a'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'result: fail'
  prefs: []
  type: TYPE_NORMAL
- en: 'rule: some-rule'
  prefs: []
  type: TYPE_NORMAL
- en: 'scored: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'source: kyverno'
  prefs: []
  type: TYPE_NORMAL
- en: 'timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: 'nanos: 0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'seconds: 1674361426'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'summary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'error: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'fail: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'pass: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'skip: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'warn: 0'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: $ helm repo add policy-reporter https://kyverno.github.io/policy-reporter
  prefs: []
  type: TYPE_NORMAL
- en: '"policy-reporter" has been added to your repositories'
  prefs: []
  type: TYPE_NORMAL
- en: $ helm repo update
  prefs: []
  type: TYPE_NORMAL
- en: Hang tight while we grab the latest from your chart repositories...
  prefs: []
  type: TYPE_NORMAL
- en: '...Successfully got an update from the "policy-reporter" chart repository'
  prefs: []
  type: TYPE_NORMAL
- en: '...Successfully got an update from the "kyverno" chart repository'
  prefs: []
  type: TYPE_NORMAL
- en: Update Complete. ![](img/B18998_09_001.png)Happy Helming!![](img/B18998_09_001.png)
  prefs: []
  type: TYPE_NORMAL
- en: $ helm upgrade --install policy-reporter policy-reporter/policy-reporter --create-namespace
    -n policy-reporter --set ui.enabled=true
  prefs: []
  type: TYPE_NORMAL
- en: Release "policy-reporter" does not exist. Installing it now.
  prefs: []
  type: TYPE_NORMAL
- en: 'NAME: policy-reporter'
  prefs: []
  type: TYPE_NORMAL
- en: 'LAST DEPLOYED: Sat Jan 21 20:39:42 2023'
  prefs: []
  type: TYPE_NORMAL
- en: 'NAMESPACE: policy-reporter'
  prefs: []
  type: TYPE_NORMAL
- en: 'STATUS: deployed'
  prefs: []
  type: TYPE_NORMAL
- en: 'REVISION: 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'TEST SUITE: None'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: $ k port-forward service/policy-reporter-ui 8080:8080 -n policy-reporter
  prefs: []
  type: TYPE_NORMAL
- en: Forwarding from 127.0.0.1:8080 -> 8080
  prefs: []
  type: TYPE_NORMAL
- en: Forwarding from [::1]:8080 -> 8080
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can browse `http://localhost:8080` and view policy reports visually.
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard shows the failing policy reports. We can see our 20 failures in
    the `kube-system` namespace and our 2 failures in the `ns-1` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '![Policy Reporter UI - Dashboard](img/B18998_16_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.7: Policy Reporter UI – Dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: The failures in kube-system are due to the best practice security policies we
    installed with Kyverno.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can scroll down and see more details about the failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Title: Inserting image...](img/B18998_16_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.8: Policy Reporter UI – Results'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also select from the sidebar the “Policy Reports” option and then see
    passing results. We can also filter policy reports using different criteria like
    policies, kinds, categories, severities, and namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Policy Reporter UI - Policy Reports](img/B18998_16_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.9: Policy Reporter UI – Policy Reports'
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the policy reporter UI has a slick look and provides a great option
    for exploring, filtering, and searching policy reports.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the increasing adoption of Kubernetes in large enterprise
    organizations and the importance of governance in managing these deployments.
    We looked at the concept of policy engines and how they are built on top of the
    Kubernetes admission control mechanism. We discussed how policy engines are used
    to address security, compliance, and governance concerns. We also provided a review
    of popular policy engines. Finally, we did a deep dive into Kyverno, in which
    we explained in detail how it works. Then, we jumped in, wrote some policies,
    tested them, and reviewed policy reports. If you run a non-trivial production
    system on Kubernetes, you should very seriously consider having Kyverno (or another
    policy engine) as a core component. This is a perfect segue to the next chapter
    where we will discuss Kubernetes in production.
  prefs: []
  type: TYPE_NORMAL
