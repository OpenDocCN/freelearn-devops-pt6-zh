<html><head></head><body>
		<div id="_idContainer047">
			<h1 id="_idParaDest-81" class="chapter-number"><a id="_idTextAnchor081"/>5</h1>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor082"/>Using Helm to Manage a Kubernetes Application</h1>
			<p>In the previous chapter, we described how you can deploy a simple application using kubectl and a standard Kubernetes manifest. The challenge with using this approach is the manifest files are fixed. If you wanted to change the tag for a web server in a manifest for different environments (development, test, production, etc.) you would need to have multiple manifests or alter the manifest content every time you <span class="No-Break">deploy it.</span></p>
			<p>In this chapter, we introduce <strong class="bold">Helm</strong>, a tool<a id="_idIndexMarker207"/> that can be used to define, install, and upgrade complex applications and allows you to easily customize deployments for different environments. Specifically, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Understanding Helm and <span class="No-Break">its architecture</span></li>
				<li>Installing the <span class="No-Break">Helm binary</span></li>
				<li>Deploying a sample Kubernetes application <span class="No-Break">with Helm</span></li>
				<li>Creating, deploying, updating, and rolling back a <span class="No-Break">Helm chart</span></li>
				<li>Deleting an application <span class="No-Break">via Helm</span></li>
				<li>Deploying a Helm chart <span class="No-Break">with Lens</span></li>
			</ul>
			<p class="callout-heading">Important note</p>
			<p class="callout">Helm is an <a id="_idIndexMarker208"/>abstraction on top of Kubernetes, and, as such, there is no difference between using Helm on EKS or another Kubernetes distribution or Deployment. We will focus on the basic functionality of Helm in this chapter. More advanced operations/configurations can be found by following the link in the <em class="italic">Further </em><span class="No-Break"><em class="italic">reading</em></span><span class="No-Break"> section.</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor083"/>Technical requirements</h1>
			<p>Before starting this chapter, please ensure that the following is <span class="No-Break">in place:</span></p>
			<ul>
				<li>You have a working EKS cluster and are able to perform <span class="No-Break">administrative tasks</span></li>
				<li>kubectl is installed and properly configured on <span class="No-Break">your workstation</span></li>
				<li>You have network connectivity to your EKS <span class="No-Break">API endpoint</span></li>
				<li>You are familiar with YAML, basic networking, and <span class="No-Break">EKS architecture</span></li>
			</ul>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/>Understanding Helm and its architecture</h1>
			<p>As we saw in the<a id="_idIndexMarker209"/> previous chapters, Kubernetes YAML templates are fine for simple applications. However, as you try and cope with complex applications where you have multiple components, several dependencies between these components, and the need to deploy and update these components frequently using techniques such as blue/green deployments, you need something more; you need a <span class="No-Break">package manager.</span></p>
			<p>Package management is not a new idea; you can see a similar concept and critical software package management tools in software such as APT/YUM on Linux, Homebrew on Mac, or Chocolatey on Windows. Similarly, Helm can be considered the package management tool <span class="No-Break">for Kubernetes.</span></p>
			<p>Helm is composed of <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Charts</strong>: A package of <a id="_idIndexMarker210"/>pre-configured <span class="No-Break">Kubernetes resources</span></li>
				<li><strong class="bold">Releases</strong>: A specific<a id="_idIndexMarker211"/> instance of a chart that has been deployed to the cluster <span class="No-Break">using Helm</span></li>
				<li><strong class="bold">Repositories</strong>: A group of <a id="_idIndexMarker212"/>published charts that can be made available <span class="No-Break">to others</span></li>
				<li><strong class="bold">Helm binary</strong>: A <a id="_idIndexMarker213"/>tool used to deploy <span class="No-Break">a chart/release</span></li>
			</ul>
			<p>In the next few sections, we will explore these components in <span class="No-Break">more detail.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/>The benefit of Helm</h2>
			<p>The primary <a id="_idIndexMarker214"/>benefit of using Helm is to simplify the way Kubernetes resources are created and deployed. Helm allows developers to adopt a <strong class="bold">don’t repeat yourself</strong><em class="italic"> </em>(<strong class="bold">DRY</strong>) approach, allows<a id="_idIndexMarker215"/> default attributes to be set but still allows them to be modified (overridden) to support different use cases <span class="No-Break">or environments.</span></p>
			<p>Developers also can easily share the template through a <em class="italic">Helm Chart Repository</em>. For example, if you want to install Prometheus (an open source monitoring system on Kubernetes) in development, you can manually create the manifests, specify the standard images, set up any supporting resources – such as ingress, deployment, and service – configure any environment variables, and repeat the process <span class="No-Break">for production.</span></p>
			<p>Instead of all this work, you can simply add the Helm Chart Repository for Prometheus using the following commands and then <span class="No-Break">deploy it:</span></p>
			<pre class="console">
$ helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
$ helm install stable/prometheus</pre>
			<p>There are some alternatives to Helm, namely Kustomize (<a href="https://kustomize.io/">https://kustomize.io/</a>), which builds on layers of YAML while also creating a custom operator for your application to manage its life cycle; an example of this is the Kafka operator. Helm, however, remains the simplest way to customize and <span class="No-Break">deploy applications.</span></p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor086"/>Getting to know Helm charts</h2>
			<p>The basic configuration <a id="_idIndexMarker216"/>item in Helm is the chart. A template that consists of a Kubernetes application that is used by Helm, is called a <strong class="bold">chart</strong>. The chart has a standard file and directory structure, shown next. You can use the <strong class="source-inline">$ helm create &lt;mychartname&gt;</strong> command to create <span class="No-Break">this structure:</span></p>
			<pre class="source-code">
mychartname/
|
|- .helmignore
|
|- Chart.yaml
|
|- values.yaml
|
|- charts/
|
|- templates/</pre>
			<p>Let's look at each of the components of <span class="No-Break">a chart:</span></p>
			<ul>
				<li>The <strong class="source-inline">.helmignore</strong> file works like a <strong class="source-inline">.gitignore</strong> file and specifies files or directories to be ignored by the <span class="No-Break">Helm command.</span></li>
				<li>The <strong class="source-inline">Chart.yaml</strong> file holds metadata about the chart you are packaging, such as your version of the <span class="No-Break">chart itself.</span></li>
				<li>The <strong class="source-inline">values.yaml</strong> file stores any values used for the deployment. You will normally see one file, the default values, but multiple value files can be used for <span class="No-Break">different environments.</span></li>
				<li>The <strong class="source-inline">charts</strong> directory is used to store other charts that your chart may <span class="No-Break">depend on.</span></li>
				<li>The <strong class="source-inline">templates</strong> directory holds the actual manifest you have created to support the deployment of your application. This may consist of multiple YAML files to deploy pods, config maps, secrets, and <span class="No-Break">so on.</span></li>
			</ul>
			<p>Values are<a id="_idIndexMarker217"/> transposed into the chart using the <strong class="source-inline">{{ define }}</strong> directive, which means the templates are significantly more flexible than standard Kubernetes manifests. What follows is an example of Helm manifest that shows a resource, in this case, a ConfigMap can <span class="No-Break">be modified:</span></p>
			<pre class="source-code">
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"</pre>
			<p>In this example, the name of the ConfigMap will be a combination of <strong class="source-inline">Release.Name</strong> and the <strong class="source-inline">-configmap</strong> string. For example, if your chart name is <em class="italic">CM1</em>, the resulting ConfigMap will be<a id="_idIndexMarker218"/> <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">CM1-configmap</strong></span><span class="No-Break">.</span></p>
			<p>Now that we have discussed the basic configuration, let’s look at how we actually install and <span class="No-Break">use Helm.</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor087"/>Installing the Helm binary</h1>
			<p>Helm can be easily <a id="_idIndexMarker219"/>installed and can be compliable with many different operating systems. You can refer to the following instruction to set up Helm on <span class="No-Break">your system:</span></p>
			<p><a href="https://helm.sh/docs/intro/install/"><span class="No-Break">https://helm.sh/docs/intro/install/</span></a></p>
			<p>You must configure kubectl to work for Amazon EKS. If you have not already done this, please refer to <a href="B18129_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Building Your First EKS Cluster</em>, to help you configure <span class="No-Break">kubectl properly.</span></p>
			<p>On Linux, you can use the following command to download and install the <span class="No-Break">Helm binary:</span></p>
			<pre class="console">
$ curl -L https://git.io/get_helm.sh | bash -s -- --version v3.8.2</pre>
			<p>At the time of writing this book, Helm 3.9.x had some issues using the AWS authenticator plugin, so v3.8.2 is used. You will need to make sure that the <strong class="source-inline">/usr/local/bin/</strong> directory is in <span class="No-Break">your </span><span class="No-Break"><strong class="source-inline">PATH</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor088"/>Deploying a sample Kubernetes application with Helm</h1>
			<p>In the <a id="_idIndexMarker220"/>previous chapter, we deployed the<a id="_idIndexMarker221"/> NGINX ingress controller using the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ kubectl create -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/I</pre>
			<p>If we want to <a id="_idIndexMarker222"/>install it using Helm, we need to<a id="_idIndexMarker223"/> perform the <span class="No-Break">following tasks:</span></p>
			<ol>
				<li>Add the public stable repository to your <span class="No-Break">Helm configuration:</span><pre class="source-code">
<strong class="bold">$ helm repo add nginx-stable https://helm.nginx.com/stable</strong></pre></li>
				<li>Refresh the <span class="No-Break">repository information:</span><pre class="source-code">
<strong class="bold">$ helm repo update</strong></pre></li>
				<li>We can then show the charts in <span class="No-Break">the repository:</span><pre class="source-code">
<strong class="bold">$ helm search repo nginx-stable</strong></pre></li>
				<li>One of the charts will be <strong class="source-inline">nginx-ingress</strong>, which can be installed using the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ helm install my-release nginx-stable/nginx-ingress</strong></pre></li>
				<li>The chart release can be viewed using either of <span class="No-Break">these commands:</span><pre class="source-code">
<strong class="bold">$ helm list</strong>
<strong class="bold">$ helm history my-release</strong></pre></li>
				<li>You can also<a id="_idIndexMarker224"/> view the Kubernetes<a id="_idIndexMarker225"/> resources using the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ kubectl api-resources --verbs=list -o name | xargs -n 1 kubectl get --show-kind -l app.kubernetes.io/instance=my-release --ignore-not-found -o name</strong></pre></li>
			</ol>
			<p>Let’s look at how we create a new Helm chart <span class="No-Break">from scratch.</span></p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>Creating, deploying, updating, and rolling back a Helm chart</h1>
			<p>As you can see from the previous example, deploying pre-packaged applications with Helm is pretty simple. Deploying your own application is also easy. We start with the following command, which will create a directory in your current directory called <strong class="source-inline">myhelmchart</strong> and <a id="_idIndexMarker226"/>populate it with the relevant files <span class="No-Break">and templates:</span></p>
			<pre class="console">
$ helm create myhelmchart</pre>
			<p>By default, the <strong class="source-inline">values.yaml</strong> file created by this command contains references to a single NGINX pod and creates a <strong class="source-inline">ClusterIP</strong> service, which is only accessible from within the cluster. The key values from the default file are <span class="No-Break">shown next:</span></p>
			<pre class="source-code">
replicaCount: 1
image:
  repository: nginx
service:
  type: ClusterIP</pre>
			<p>We can easily deploy this new Helm chart using the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ helm install example ./myhelmchart --set service.type=NodePort</pre>
			<p>This will <a id="_idIndexMarker227"/>override the <strong class="source-inline">service.type</strong> value seen in the <strong class="source-inline">values.yaml</strong> file with a <strong class="source-inline">NodePort</strong> service, so it is now exposed outside of the cluster. We can then validate the chart deployment with the following command and see the name of the <strong class="source-inline">NodePort</strong> service that was created, along with the other <span class="No-Break">Kubernetes resources:</span></p>
			<pre class="console">
$ kubectl api-resources --verbs=list -o name | xargs -n 1 kubectl get --show-kind -l app.kubernetes.io/instance=example --ignore-not-found -o name
endpoints/example-myhelmchart
pod/example-myhelmchart-cb76665d4-sq4lk
serviceaccount/example-myhelmchart
service/example-myhelmchart
deployment.apps/example-myhelmchart
replicaset.apps/example-myhelmchart-cb76665d4
endpointslice.discovery.k8s.io/example-myhelmchart-8kw8t</pre>
			<p>If you run the following command using the service name from the previous step, you will be able to extract the IP address and port of the service and curl the <span class="No-Break"><strong class="source-inline">NodePort</strong></span><span class="No-Break"> service:</span></p>
			<pre class="console">
$ export NODE_PORT=$(kubectl get --namespace default -o jsonpath="{.spec.ports[0].nodePort}" services example-myhelmchart) | curl http://$NODE_IP:$NODE_PORT</pre>
			<p>To update the <a id="_idIndexMarker228"/>Helm deployment, we are going to perform the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker229"/></span><span class="No-Break"> steps:</span></p>
			<ol>
				<li>Modify the <strong class="source-inline">values.yaml</strong> file and increase <strong class="source-inline">replicaCount:</strong> to <strong class="source-inline">2</strong>. We can also change the <strong class="source-inline">service.type</strong> value <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">NodePort</strong></span><span class="No-Break">.</span></li>
				<li>Modify the <strong class="source-inline">Chart.yaml</strong> file and update <strong class="source-inline">version</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0.2.0</strong></span><span class="No-Break">.</span></li>
				<li>Validate <span class="No-Break">the changes:</span><pre class="source-code">
<strong class="bold">$ helm lint</strong></pre></li>
				<li>Then roll out <span class="No-Break">the changes:</span><pre class="source-code">
<strong class="bold">$ helm upgrade example ./myhelmchart</strong></pre></li>
				<li>We can then validate <span class="No-Break">the deployment:</span><pre class="source-code">
<strong class="bold">$ helm history example</strong></pre></li>
			</ol>
			<p>You will notice the revision number shown next when you run the <span class="No-Break">preceding command:</span></p>
			<pre class="source-code">
<strong class="bold">$ helm history example</strong>
<strong class="bold">REVISION  UPDATED STATUS   CHART   APP VERSION     DESCRIPTION</strong>
<strong class="bold">1 Sat xx superseded  myhelmchart-0.1.0 1.16.0 Install complete</strong>
<strong class="bold">2 Sat xx deployed  myhelmchart-0.2.0  1.16.0 Upgrade complete</strong></pre>
			<ol>
				<li value="6">We can also<a id="_idIndexMarker230"/> validate that two Pods exist for <span class="No-Break">the Deployment:</span><pre class="source-code">
<strong class="bold">kubectl get pod | grep example</strong></pre></li>
			</ol>
			<p>You can easily roll back to a<a id="_idIndexMarker231"/> previous revision using the <strong class="source-inline">helm rollback example 1</strong> command, where <strong class="source-inline">1</strong> represents the revision you want to return to. This is one of the major advantages of Helm over basic Kubernetes manifests, each change to the manifest can be versioned and deployed as a new revision, and if issues occur, you can easily roll back to a <span class="No-Break">previous version/revision.</span></p>
			<p>The <strong class="source-inline">helm list</strong> command can show all the revisions in the cluster, which are stored as Kubernetes Secrets in the namespace where the release is deployed. Next, let’s look at how we remove our <span class="No-Break">Helm application.</span></p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>Deleting an application via the Helm command</h1>
			<p>Helm<a id="_idIndexMarker232"/> provides a simple <strong class="source-inline">uninstall</strong> command to delete the<a id="_idIndexMarker233"/> application release. The first step is to determine which Helm deployment you want to remove using the <strong class="source-inline">helm </strong><span class="No-Break"><strong class="source-inline">list</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
$ helm list --all-namespaces
NAME  NAMESPACE REVISION  UPDATED     STATUS          CHART                    APP VERSION
cm1             default             1          2022- deployed        myhelmchart-0.1.0       1.16.0
example         default         4           2022- deployed        myhelmchart-0.2.0       1.16.0
my-release      default        1          2022- deployed        nginx-ingress-0.13.2    2.2.2</pre>
			<p>In this example, we<a id="_idIndexMarker234"/> want to remove the example deployment, so we<a id="_idIndexMarker235"/> can simply run the <strong class="source-inline">$ helm uninstall example</strong> command and all the resources created by the chart or charts will <span class="No-Break">be removed.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This will remove all deployment history as well. Please also make sure you have removed all the Helm charts using the <strong class="source-inline">$ helm </strong><span class="No-Break"><strong class="source-inline">uninstall</strong></span><span class="No-Break"> command.</span></p>
			<p>In this section, we reviewed using the Helm binary to deploy public charts and create, update, roll back, and delete your own charts. In the next section, we will show you how to use Lens to <span class="No-Break">deploy charts.</span></p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor091"/>Deploying a Helm chart with Lens</h1>
			<p>In the previous chapter, we discussed how to visualize your Kubernetes resources using Lens. However, you can also use Lens to manage Helm charts. Please refer to <a href="B18129_04.xhtml#_idTextAnchor067"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Running Your First Application on EKS</em> (the <em class="italic">Visualizing your workloads</em> section), for guidance on the setup <span class="No-Break">of Lens.</span></p>
			<p>By default, Lens<a id="_idIndexMarker236"/> will fetch available Helm repositories from the public Artifact Hub (<a href="https://artifacthub.io/">https://artifacthub.io/</a>) and Bitnami. As we are going to redeploy the NGINX ingress controller we deployed using the Helm <strong class="bold">Command Line Interface</strong> <strong class="bold">(CLI)</strong>, we need to add a custom repository. To do this, follow<a id="_idIndexMarker237"/> these steps <a id="_idIndexMarker238"/>while referring to <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<ol>
				<li>Choose <strong class="bold">Lens</strong> | <strong class="bold">Preferences</strong> from the <span class="No-Break">main toolbar.</span></li>
				<li>Then <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Kubernetes</strong></span><span class="No-Break">.</span></li>
				<li>Select <strong class="bold">Add custom Helm Repo</strong> from the <span class="No-Break">Kubernetes panel.</span></li>
				<li>This will display a pop-up box, which works in the same way as the <strong class="source-inline">helm repo add</strong> command. Here, we are going to add the NGINX repository we used in a previous <span class="No-Break">example: </span><a href="https://helm.nginx.com/stable"><span class="No-Break">https://helm.nginx.com/stable</span></a><span class="No-Break">.</span></li>
			</ol>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B18129_05_01.jpg" alt="Figure 5.1 – Adding a custom Helm repository in Lens"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Adding a custom Helm repository in Lens</p>
			<p>Once the<a id="_idIndexMarker239"/> repository has been added, we can now deploy charts<a id="_idIndexMarker240"/> from it. To do this, follow these steps while referring to <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<ol>
				<li>Select <span class="No-Break">your cluster.</span></li>
				<li>Choose <strong class="bold">Helm</strong> | <strong class="bold">Charts</strong>. This will show all the charts available to you based on the repositories <span class="No-Break">you’ve added.</span></li>
				<li>Filter out NGINX as we have done in the following screenshot, and you will see two NGINX ingress controller charts: one from Bitnami and the other <span class="No-Break">from NGINX.</span></li>
			</ol>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B18129_05_02.jpg" alt="Figure 5.2 – Finding the required chart in Lens"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Finding the required chart in Lens</p>
			<ol>
				<li value="4">Click on the <span class="No-Break">NGINX chart.</span></li>
				<li>This will bring<a id="_idIndexMarker241"/> up another panel where you must click <a id="_idIndexMarker242"/>on <strong class="bold">Install</strong>. Fill in the details (or leave them unchanged) and click <strong class="bold">Install</strong> again. The chart will be deployed, as shown in the <span class="No-Break">following screenshot:</span></li>
			</ol>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B18129_05_03.jpg" alt="Figure 5.3 – Installing a chart in Lens"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Installing a chart in Lens</p>
			<ol>
				<li value="6">You can now click on the <strong class="bold">Releases</strong> tab, and you will see all the deployed Helm charts. In the following example, we only have the NGINX ingress controller deployed. From the <strong class="bold">Releases</strong> tab, you can also upgrade and delete the release by clicking on the<a id="_idIndexMarker243"/> three dots (the kebab menu) on the right <a id="_idIndexMarker244"/>of <span class="No-Break">the chart:</span></li>
			</ol>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B18129_05_04.jpg" alt="Figure 5.4 – Viewing Releases in Lens"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Viewing Releases in Lens</p>
			<p>As you can see, Lens performs the same functions that the Helm binary does but just provides it in a graphical view. As discussed in the previous chapter, Lens also allows you to review the running workloads, something we had to do with Kubectl. Hence, Lens helps bring together these tools, but it is still recommended that you know how to use both Kubectl and Helm if you’re going to work with multiple clusters <span class="No-Break">in production.</span></p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor092"/>Summary</h1>
			<p>In this chapter, we learned how to use Helm to accelerate application deployment on Kubernetes and improve the efficiency of template creation. This included how to install the Helm CLI and use it to deploy applications (charts) hosted in a public repository. We then created our own chart, customized it, deployed it, modified the configuration, deployed the new revision, rolled back to a previous revision, and finally deleted it from <span class="No-Break">our cluster.</span></p>
			<p>We then discussed how we could perform similar activities using a third-party tool, Lens, and how it achieves the same things but provides a graphical user interface while also integrating multiple views such as Kubernetes resources (kubectl) and <span class="No-Break">Helm releases.</span></p>
			<p>In the next chapter, we will look deeper into how you access and secure your EKS cluster, focusing on how you access the EKS cluster endpoints and <span class="No-Break">authenticate users.</span></p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor093"/>Further reading</h1>
			<ul>
				<li>An example <span class="No-Break">operator: </span><a href="https://docs.confluent.io/5.5.1/installation/operator/index.html"><span class="No-Break">https://docs.confluent.io/5.5.1/installation/operator/index.html</span></a></li>
				<li>Understanding Helm in more <span class="No-Break">detail: </span><a href="https://helm.sh/docs/"><span class="No-Break">https://helm.sh/docs/</span></a></li>
			</ul>
		</div>
	

		<div id="_idContainer048" class="Content">
			<h1 id="_idParaDest-94"><a id="_idTextAnchor094"/>Part 2: Deep Dive into EKS</h1>
		</div>
		<div id="_idContainer049">
			<p>In this section, we will dive deeper into EKS and its various components. This part aims to demystify key aspects such as security, networking, and node groups, providing you with a comprehensive understanding of each feature. Finally, you will take away strategies regarding how to upgrade your EKS cluster version and follow the upstream Kubernetes <span class="No-Break">release cadence.</span></p>
			<p>This part contains the <span class="No-Break">following topics:</span></p>
			<ul>
				<li><a href="B18129_06.xhtml#_idTextAnchor095"><em class="italic">Chapter 6</em></a>, <em class="italic">Securing and Accessing Clusters on EKS</em></li>
				<li><a href="B18129_07.xhtml#_idTextAnchor107"><em class="italic">Chapter 7</em></a>, <em class="italic">Networking in EKS</em></li>
				<li><a href="B18129_08.xhtml#_idTextAnchor123"><em class="italic">Chapter 8</em></a>, <em class="italic">Managing Worker Nodes on EKS</em></li>
				<li><a href="B18129_09.xhtml#_idTextAnchor135"><em class="italic">Chapter 9</em></a>, <em class="italic">Advanced Networking with EKS</em></li>
				<li><a href="B18129_10.xhtml#_idTextAnchor146"><em class="italic">Chapter 10</em></a>, <em class="italic">Upgrading EKS Clusters</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer050">
			</div>
		</div>
		<div>
			<div id="_idContainer051" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer052">
			</div>
		</div>
	</body></html>