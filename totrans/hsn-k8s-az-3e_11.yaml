- en: 7\. Monitoring the AKS cluster and the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to deploy applications on an AKS cluster, let's focus
    on how you can ensure that your cluster and applications remain available. In
    this chapter, you will learn how to monitor your cluster and the applications
    running on it. You'll explore how Kubernetes makes sure that your applications
    are running reliably using readiness and liveness probes.
  prefs: []
  type: TYPE_NORMAL
- en: You will also learn how **AKS Diagnostics** and **Azure Monitor** are used,
    and how they are integrated within the Azure portal. You will see how you can
    use AKS Diagnostics to monitor the status of the cluster itself, and how Azure
    Monitor helps monitor the pods on the cluster and allows you to get access to
    the logs of the pods at scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'In brief, the following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and debugging applications using `kubectl`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing metrics reported by Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing metrics from Azure Monitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start the chapter by reviewing some of the commands in `kubectl` that
    you can use to monitor your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Commands for monitoring applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Monitoring the health of applications deployed on Kubernetes as well as the
    Kubernetes infrastructure itself is essential for providing a reliable service
    to your customers. There are two primary use cases for monitoring:'
  prefs: []
  type: TYPE_NORMAL
- en: Ongoing monitoring to get alerts if something is not behaving as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting and debugging application errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When observing an application running on top of a Kubernetes cluster, you''ll
    need to examine multiple things in parallel, including containers, pods, services,
    and the nodes in the cluster. For ongoing monitoring, you''ll need a monitoring
    system such as Azure Monitor or Prometheus. Azure Monitor will be introduced later
    in this chapter. Prometheus ([https://prometheus.io/](https://prometheus.io/))
    is a popular open-source solution within the Kubernetes ecosystem to monitor Kubernetes
    environments. For troubleshooting, you''ll need to interact with the live cluster.
    The most common commands used for troubleshooting are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each of these commands will be described in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with the practical examples, recreate the guestbook example again
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While the `create` command is running, you will watch its progress in the following
    sections. Let's start by exploring the `get` command.
  prefs: []
  type: TYPE_NORMAL
- en: The kubectl get command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see the overall picture of deployed applications, `kubectl` provides the
    `get` command. The `get` command lists the resources that you specify. Resources
    can be pods, ReplicaSets, ingresses, nodes, deployments, secrets, and so on. You
    have already run this command in the previous chapters to verify that an application
    was ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following `get` command, which will get us the resources and their
    statuses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will show you all the deployments, ReplicaSets, pods, and services in
    your namespace:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Output displaying all the resources running in the default namespace](img/B17338_07_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.1: All the resources running in the default namespace'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Focus your attention on the pods in your deployment. You can get the status
    of the pods with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see that only the pods are shown, as seen in *Figure 7.2*. Let''s
    investigate this in detail:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Checking the status of all the pods in the namespace](img/B17338_07_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.2: All the pods in your namespace'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first column indicates the pod name, for example, `frontend-766d4f77cb-ds6gb`.
    The second column indicates how many containers in the pod are ready against the
    total number of containers in the pod. Readiness is defined via a readiness probe
    in Kubernetes. There is a dedicated section called *Readiness and liveness probes*
    later in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The third column indicates the status, for example, `Pending`, `ContainerCreating`,
    `Running`, and so on. The fourth column indicates the number of restarts, while
    the fifth column indicates the age when the pod was asked to be created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you need more information about your pod, you can add extra columns to the
    output of a `get` command by adding `-o wide` to the command like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will show you additional information, as shown in *Figure 7.3*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Getting additional details of all the pods in the namespace](img/B17338_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Adding -o wide shows more details on the pods'
  prefs: []
  type: TYPE_NORMAL
- en: The extra columns include the IP address of the pod, the node it is running
    on, the nominated node, and readiness gates. A nominated node is only set when
    a higher-priority pod preempts a lower-priority pod. The nominated node field
    would then be set on the higher-priority pod. It signifies the node that the higher-priority
    pod will be scheduled once the lower-priority pod has terminated gracefully. A
    readiness gate is a way to introduce external system components as the readiness
    for a pod.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a `get pods` command only shows the state of the current pod. As we
    will see next, things can fail at any of the states, and we need to use the `kubectl
    describe` command to dig deeper.
  prefs: []
  type: TYPE_NORMAL
- en: The kubectl describe command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `kubectl describe` command gives you a detailed view of the object you
    are describing. It contains the details of the object itself, as well as any recent
    events related to that object. While the `kubectl get events` command lists all
    the events for the entire namespace, with the `kubectl describe` command, you
    would get only the events for that specific object. If you are interested in just
    pods, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command lists all the information pertaining to all pods. This
    is typically too much information to contain in a typical shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want information on a particular pod, you can type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can either use a slash or a space in between `pod` and `<pod-name>`. The
    following two commands will have the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl describe pod/<pod-name>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl describe pod <pod-name>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get an output similar to *Figure 7.4*, which will be explained in
    detail later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Describing an individual pod to show a detailed output of that object](img/B17338_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Describing an object shows the detailed output of that object'
  prefs: []
  type: TYPE_NORMAL
- en: From the description, you can get the node on which the pod is running, how
    long it has been running, its internal IP address, the Docker image name, the
    ports exposed, the `env` variables, and the events (from within the past hour).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the pod name is `frontend-766d4f77cb-ds6gb`. As mentioned
    in *Chapter 1, Introduction to containers and Kubernetes*, it has the `<ReplicaSet
    name>-<random 5 chars>` format. The `replicaset` name itself is randomly generated
    from the deployment name front end: `<deployment name>-<random-string>`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.5* shows the relationship between a deployment, a ReplicaSet, and
    pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A flowchart describing the relationship between a deployment, a ReplicaSet,
    and pods](img/B17338_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Relationship between a deployment, a ReplicaSet, and pods'
  prefs: []
  type: TYPE_NORMAL
- en: The namespace under which this pod runs is `default`. So far, you have just
    been using the `default` namespace, appropriately named `default`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another section that is important from the preceding output is the `node` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `node` section lets you know which physical node/VM the pod is running on.
    If the pod is repeatedly restarting or having issues running and everything else
    seems OK, there might be an issue with the node itself. Having this information
    is essential to perform advanced debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the time the pod was initially scheduled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This doesn't mean that the pod has been running since that time, so the time
    can be misleading in that sense. If a health event occurs (for example, a container
    crashes), the pod will reset automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add more information about a workload in Kubernetes using `Labels`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Labels are a commonly used functionality in Kubernetes. For example, this is
    how links between objects, such as `service` to `pod` and `deployment` to `ReplicaSet`
    to `pod` (*Figure 7.5*), are made. If you see that traffic is not being routed
    to a pod from a service, this is the first thing you should check. Also, you'll
    notice that the `pod-template-hash` label also occurs in the pod name. This is
    how the link between the ReplicaSet and the pod is made. If the labels don't match,
    the resources won't attach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows the internal IP of the pod and its status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in previous chapters, when building out your application, the pods
    can be moved to different nodes and get a different IP, so you should avoid using
    these IP addresses. However, when debugging application issues, having a direct
    IP for a pod can help with troubleshooting. Instead of connecting to your application
    through a service object, you can connect directly from one pod to another using
    the other pod's IP address to test connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The containers running in the pod and the ports that are exposed are listed
    in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you are getting the `gb-frontend` container with the `v4` tag
    from the `gcr.io` container registry, and the repository name is `google-samples`.
  prefs: []
  type: TYPE_NORMAL
- en: Port `80` is exposed to outside traffic. Since each pod has its own IP, the
    same port can be exposed for multiple instances of the same pod even when running
    on the same host. For instance, if you had two pods running a web server on the
    same node, both could use port `80`, since each pod has its own IP address. This
    is a huge management advantage as you don't have to worry about port collisions
    on the same node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any events that occurred in the previous hour show up here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using `kubectl describe` is very useful to get more context about the resources
    you are running. The final section contains events related to the object you were
    describing. You can get all events in your cluster using the `kubectl get events`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the events for all resources in the system, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Kubernetes maintains events for only 1 hour by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything goes well, you should have an output similar to *Figure 7.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the kubectl get events command to display all events from the past
    hour](img/B17338_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Getting the events shows all events from the past hour'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.6* only shows the event for one pod, but as you can see in your output,
    the output for this command contains the events for all resources that were recently
    created, updated, or deleted.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have learned about the commands you can use to inspect
    a Kubernetes application. In the next section, you'll focus on debugging application
    failures.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of how to inspect applications, you
    can start seeing how you can debug issues with deployments.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, common errors will be introduced, and you'll determine how
    to debug and fix them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t implemented the Guestbook application already, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After a couple of seconds, the application should be up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Image pull errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you are going to introduce image pull errors by setting the
    image tag value to a non-existent one. An image pull error occurs when Kubernetes
    cannot download the image for the container it needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command on Azure Cloud Shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, change the image tag from `v4` to `v_non_existent` by executing the following
    steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Type `/gb-frontend` and hit the *Enter* key to have your cursor brought to the
    image definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hit the *I* key to go into insert mode. Delete `v4` and type `v_non_existent`
    as shown in *Figure 7.7*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Using Azure Cloud Shell to change the image tag from v4 to v_non_existent](img/B17338_07_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.7: Changing the image tag from v4 to v_non_existent'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, close the editor by first hitting the *Esc* key, then type `:wq!` and hit
    *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command to list all the pods in the current namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding command should indicate errors, as shown in *Figure 7.8*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Displaying all the pods in the current namespace to indicate status errors](img/B17338_07_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.8: One of the pods has the status of either ErrImagePull or ImagePullBackOff'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You might see either a status called `ErrImagePull` or `ImagePullBackOff`. Both
    errors refer to the fact that Kubernetes cannot pull the image from the registry.
    The `ErrImagePull` error describes just this; `ImagePullBackOff` describes that
    Kubernetes will back off (wait) before retrying to download the image. This back-off
    has an exponential delay, going from 10 to 20 to 40 seconds and beyond, up to
    5 minutes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following command to get the full error details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A sample error output is shown in *Figure 7.9*. The key error message is highlighted
    in red:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Describing an individual pod to display more details on the error](img/B17338_07_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.9: Using describe shows more details on the error'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The events clearly show that the image does not exist. Errors such as passing
    invalid credentials to private Docker repositories will also show up here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s fix the error by setting the image tag back to `v4`. First, type the
    following command in Cloud Shell to edit the deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Type `/gb-frontend` and hit *Enter* to have your cursor brought to the image
    definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit the *I* key to go into insert mode. Delete `v_non_existent`, and type `v4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, close the editor by first hitting the *Esc* key, then type `:wq!` and hit
    *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should automatically fix the deployment. You can verify it by getting the
    events for the pods again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: Because Kubernetes did a rolling update, the front end was continuously available
    with zero downtime. Kubernetes recognized a problem with the new specification
    and stopped rolling out additional changes automatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Image pull errors can occur when images aren't available or when you don't have
    access to the container registry. In the next section, you'll explore an error
    within the application itself.
  prefs: []
  type: TYPE_NORMAL
- en: Application errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will now see how to debug an application error. The errors in this section
    will be self- induced, similar to the last section. The method for debugging the
    issue is the same as the one we used to debug errors on running applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, get the public IP of the front-end service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Connect to the service by pasting its public IP in a browser. Create a couple
    of entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Creating entries in the guestbook application](img/B17338_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: Make a couple of entries in the guestbook application'
  prefs: []
  type: TYPE_NORMAL
- en: You now have an instance of the guestbook application running. To improve the
    experience with the example, it's best to scale down the front end so there is
    only a single replica running.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling down the front end
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *Chapter 3*, *Application deployment on AKS*, you learned how the deployment
    of the front end has a configuration of `replicas=3`. This means that the requests
    the application receives can be handled by any of the pods. To introduce the application
    error and note the errors, you'll need to make changes in all three of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'But to make this example easier, set `replicas` to `1`, so that you have to
    make changes to only one pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Having only one replica running will make introducing the error easier. Let's
    now introduce this error.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing an app error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this case, you are going to make the **Submit** button fail to work. You
    will need to modify the application code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is not advised to make production changes to your application by using `kubectl
    exec` to execute commands in your pods. If you need to make changes to your application,
    the preferred way is to create a new container image and update your deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will use the `kubectl exec` command. This command lets you run commands
    on the command line of that pod. With the `-it` option, it attaches an interactive
    terminal to the pod and gives you a shell that you can run commands on. The following
    command launches a Bash terminal on the pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will enter a Bash shell environment as shown in *Figure 7.11*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Executing a command to launch and enter a Bash terminal on the pod](img/B17338_07_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.11: Getting a pod''s name and getting access to a shell inside the
    pod'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you are in the container shell, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code installs the `vim` editor so that we can edit the file to
    introduce an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, use `vim` to open the `guestbook.php` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code at line 17, below the line `if ($_GET[''cmd''] == ''set'')
    {`. Remember, to edit a line in `vim`, you hit the *I* key. After you are done
    editing, you can exit by hitting *Esc*, and then type `:wq!` and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The file will look like *Figure 7.12*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Output displaying the updated code that introduced an error and additional
    logging](img/B17338_07_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.12: The updated code that introduced an error and additional logging'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You have now introduced an error where reading messages will work, but not writing
    them. You have done this by asking the front end to connect to the Redis master
    at the non-existent localhost server. The writes should fail. At the same time,
    to make this demo more visual, we added some additional logging to this section
    of the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your guestbook application by browsing to its public IP, and you should
    see the entries from earlier:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Guestbook application displaying entries from earlier](img/B17338_07_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.13: The entries from earlier are still present'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, create a new message by typing a message and hitting the **Submit** button:![Creating
    a new message in the guestbook application](img/B17338_07_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.14: A new message was created'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Submitting a new message makes it appear in the application. If you did not
    know any better, you would have thought the entry was written successfully to
    the database. However, if you refresh your browser, you will see that the message
    is no longer there.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To verify that the message has not been written to the database, hit the **Refresh**
    button in your browser; you will see just the initial entries, and the new entry
    has disappeared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Refreshing the webpage to confirm there the new message wasn’t persisted](img/B17338_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: The new message has disappeared'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an app developer or operator, you''ll probably get a ticket like this: `After
    the new deployment, new entries are not persisted. Fix it`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using logs to identify the root cause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step toward resolution is to get the logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exit out of the front-end pod for now and get the logs for this pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note:'
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can add the `-f` flag after `kubectl logs` to get a live log stream, as
    follows: `kubectl logs <pod-name> -f`. This is useful during live debugging sessions.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will see entries such as those seen in *Figure 7.16*:![Output displaying
    the new message as part of the application logs](img/B17338_07_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.16: The new message shows up as part of the application logs'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Hence, you know that the error is somewhere when writing to the database in
    the `set` section of the code. When you see the entry `hostname at the beginning
    of 'set' command localhost`, you know that the error is between this line and
    the start of the client, so the setting of `$host = 'localhost'` must be the offending
    error. This error is not as uncommon as you would think and, as you just saw,
    could have easily gone through QA unless there had been a specific instruction
    to refresh the browser. It could have worked perfectly well for the developer,
    as they could have a running Redis server on the local machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you have used logs in Kubernetes to root cause the issue, let's get
    to resolving the error and getting our application back to a healthy state.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the issue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two options to fix this bug you introduced: you can either navigate
    into the pod and make the code changes, or you can ask Kubernetes to give us a
    healthy new pod. It is not recommended to make manual changes to pods, so in the
    next step, you will use the second approach. Let''s fix this bug by deleting the
    faulty pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As there is a ReplicaSet that controls the pods, you should immediately get
    a new pod that has started from the correct image. Try to connect to the guestbook
    again and verify that messages persist across browser refreshes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following points summarize what was covered in this section on how to identify
    an error and how to fix it:'
  prefs: []
  type: TYPE_NORMAL
- en: Errors can come in many shapes and forms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the errors encountered by the deployment team are configuration issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use logs to identify the root cause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `kubectl exec` on a container is a useful debugging strategy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that broadly allowing `kubectl exec` is a serious security risk, as it
    lets the Kubernetes operator execute commands directly in the pods they have access
    to. Make sure that only a subset of operators has the ability to use the `kubectl
    exec` command. You can use role-based access control to manage this access restriction,
    as you'll learn in *Chapter 8, Role-based access control in AKS*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything printed to `stdout` and `stderr` shows up in the logs (independent
    of the application/language/logging framework).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, you introduced an application error to the guestbook application
    and leveraged Kubernetes logs to pinpoint the issue in the code. In the next section,
    you will learn about a powerful mechanism in Kubernetes called **readiness** and
    **liveness probes**.
  prefs: []
  type: TYPE_NORMAL
- en: Readiness and liveness probes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readiness and liveness probes were briefly touched upon in the previous section.
    In this section, you'll explore them in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes uses liveness and readiness probes to monitor the availability of
    your applications. Each probe serves a different purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: A **liveness probe** monitors the availability of an application while it is
    running. If a liveness probe fails, Kubernetes will restart your pod. This could
    be useful to catch deadlocks, infinite loops, or just a "stuck" application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **readiness probe** monitors when your application becomes available. If a
    readiness probe fails, Kubernetes will not send any traffic to the unready pods.
    This is useful if your application has to go through some configuration before
    it becomes available, or if your application has become overloaded but is recovering
    from the additional load. By having a readiness probe fail, your application will
    temporarily not get any more traffic, giving it the ability to recover from the
    increased load.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liveness and readiness probes don't need to be served from the same endpoint
    in your application. If you have a smart application, that application could take
    itself out of rotation (meaning no more traffic is sent to the application) while
    still being healthy. To achieve this, it would have the readiness probe fail but
    have the liveness probe remain active.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build this out in an example. You will create two nginx deployments, each
    with an index page and a health page. The index page will serve as the liveness
    probe.
  prefs: []
  type: TYPE_NORMAL
- en: Building two web containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this example, you''ll use a couple of web pages that will be used to connect
    to a readiness and a liveness probe. The files are present in the code files for
    this chapter. Let''s first create `index1.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, create `index2.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also create a health page, `healthy.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step, you''ll mount these files to your Kubernetes deployments.
    To do this, you''ll turn each of these into a `configmap` that you will connect
    to your pods. You''ve already learned about configmaps in *Chapter 3, Application
    deployment on AKS*. Use the following commands to create the `configmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'With that out of the way, you can go ahead and create your two web deployments.
    Both will be very similar, with just the `configmap` changing. The first deployment
    file (`webdeploy1.yaml`) looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things to highlight in this deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 23-28**: This is the liveness probe. The liveness probe points to the
    health page. Remember, if the health page fails, the container will restart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 29-32**: This is the readiness probe. The readiness probe in our case
    points to the index page. If this page fails, the pod will temporarily not be
    sent any traffic but will remain running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sleep` command (so the container keeps running).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can create this deployment using the following command. You can also deploy
    the second version for `server 2`, which is similar to `server 1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can also create a service (`webservice.yaml`) that routes traffic
    to both deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create that service using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You now have the application up and running. In the next section, you'll introduce
    some failures to verify the behavior of the liveness and readiness probes.
  prefs: []
  type: TYPE_NORMAL
- en: Experimenting with liveness and readiness probes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, the functionality of the liveness and readiness probes
    was explained, and you created a sample application. In this section, you will
    introduce errors in this application and verify the behavior of the liveness and
    readiness probes. You will see how a failure of the readiness probe will cause
    the pod to remain running but no longer accept traffic. After that, you will see
    how a failure of the liveness probe will cause the pod to be restarted.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by failing the readiness probe.
  prefs: []
  type: TYPE_NORMAL
- en: Failing the readiness probe causes traffic to temporarily stop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have a simple application up and running, you can experiment with
    the behavior of the liveness and readiness probes. To start, let''s get the service''s
    external IP to connect to our web server using the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you hit the external IP in the browser, you should see a single line that
    either says **Server 1** or **Server 2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Browsing to the external IP in the browser shows the application returning
    traffic from server 1 ](img/B17338_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.17: Our application is returning traffic from server 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'During the upcoming tests, you''ll use a small script called `testWeb.sh` that
    has been provided in the code samples for this chapter to connect to your web
    page 50 times, so you can monitor a good distribution of results between servers
    1 and 2\. You''ll first need to make that script executable, and then you can
    run that script while your deployment is fully healthy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'During healthy operations, we can see that server 1 and server 2 are hit almost
    equally, with `24` hits for server 1 and `26` for server 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output displaying a healthy application with its traffic load-balanced between
    server 1 and server 2](img/B17338_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.18: While the application is healthy, traffic is load-balanced between
    server 1 and server 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now move ahead and fail the readiness probe in server 1\. To do this,
    you will use the `kubectl exec` command to move the index file to a different
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is executed, we can view the change in the pod status with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the readiness state of the server 1 pod change to `0/1`, as
    shown in *Figure 7.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First, a command is executed to stop directing traffic to server 1\. Then,
    using kubectl get pods -w, the ready attribute of the server 1 pod changes from
    1/1 to 0/1](img/B17338_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.19: The failing readiness probes causes server 1 to not have any READY
    containers'
  prefs: []
  type: TYPE_NORMAL
- en: 'This should direct no more traffic to the server 1 pod. Let''s verify that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Traffic should be redirected to server 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output displaying all traffic is directed to server 2](img/B17338_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.20: All traffic is now served by server 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now restore the state of server 1 by moving the file back to its rightful
    place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the pod to a **Ready** state and should again split traffic
    equally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show an output similar to *Figure 7.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![After restoring the readiness probe, traffic is load-balanced again](img/B17338_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.21: Restoring the readiness probe causes traffic to be load-balanced
    again'
  prefs: []
  type: TYPE_NORMAL
- en: A failing readiness probe will cause Kubernetes to no longer send traffic to
    the failing pod. You have verified this by causing a readiness probe in your example
    application to fail. In the next section, you'll explore the impact of a failing
    liveness probe.
  prefs: []
  type: TYPE_NORMAL
- en: A failing liveness probe restarts the pod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can repeat the previous process with the liveness probe as well. When the
    liveness probe fails, Kubernetes is expected to restart that pod. Let''s try this
    by deleting the health file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what this does to the pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see that the pod restarts within a couple of seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output displaying a failing liveness probe that causes the pod to restart](img/B17338_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.22: A failing liveness probe will cause the pod to be restarted'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in *Figure 7.22*, the pod was successfully restarted, with limited
    impact. You can inspect what was going on in the pod by running a `describe` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will give you an output similar to *Figure 7.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![More details on the pod showing the failing liveness probe caused the pod
    to be restarted](img/B17338_07_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.23: More details on the pod showing how the liveness probe failed'
  prefs: []
  type: TYPE_NORMAL
- en: In the `describe` command, you can clearly see that the pod failed the liveness
    probe. After three failures, the container was killed and restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concludes the experiment with liveness and readiness probes. Remember
    that both are useful for your application: a readiness probe can be used to temporarily
    stop traffic to your pod, so it has to deal with less load. A liveness probe is
    used to restart your pod if there is an actual failure in the pod.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also make sure to clean up the deployments you just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Liveness and readiness probes are useful to ensure that only healthy pods will
    receive traffic in your cluster. In the next section, you will explore different
    metrics reported by Kubernetes that you can use to verify the state of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics reported by Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes reports multiple metrics. In this section, you'll first use a number
    of `kubectl` commands to get these metrics. Afterward, you'll look into Azure
    Monitor for containers to see how Azure helps with container monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Node status and consumption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The nodes in your Kubernetes are the servers running your application. Kubernetes
    will schedule pods to different nodes in the cluster. You need to monitor the
    status of your nodes to ensure that the nodes themselves are healthy and that
    the nodes have enough resources to run new applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to get information about the nodes on the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command lists their name, status, and age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the kubectl get nodes command to get information about the nodes
    on the cluster](img/B17338_07_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.24: There are two nodes in this cluster'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get more information by passing the `-o wide` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The output lists the underlying `OS-IMAGE` and `INTERNAL-IP`, and other useful
    information, which can be viewed in *Figure 7.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the -o wide option to the command to display more details about the
    nodes](img/B17338_07_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.25: Using -o wide adds more details about the nodes'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out which nodes are consuming the most resources by using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'It shows the CPU and memory usage of the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output displaying CPU and memory utilization of the nodes](img/B17338_07_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.26: CPU and memory utilization of the nodes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this is the actual consumption at that point in time, not the number
    of requests a certain node has. To get the requests, you can execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show you the requests and limits per pod, as well as the cumulative
    amount for the whole node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output displaying requests and limits per pod, as well as the total of allocated
    resources](img/B17338_07_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.27: Describing the nodes shows details on requests and limits'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 7.27*, the `describe node` command outputs the requests
    and limits per pod, across namespaces. This is a good way for cluster operators
    to verify how much load is being put on the cluster, across all namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: You now know where you can find information about the utilization of your nodes.
    In the next section, you will look into how you can get the same metrics for individual
    pods.
  prefs: []
  type: TYPE_NORMAL
- en: Pod consumption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pods consume CPU and memory resources from an AKS cluster. Requests and limits
    are used to configure how much CPU and memory a pod can consume. Requests are
    used to reserve a minimum amount of CPU and memory, while limits are used to set
    a maximum amount of CPU and memory per pod.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how you can use `kubectl` to get information
    about the CPU and memory utilization of pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by exploring how you can see the requests and limits for a pod
    that you currently have running:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, you will use the pods running in the `kube-system` namespace.
    Get all the pods in this namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should show something similar to *Figure 7.28*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Output displaying pods running in the kube-system namespace](img/B17338_07_28.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.28: The pods running in the kube-system namespace'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s get the requests and limits for one of the `coredns` pods. This can
    be done using the `describe` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `describe` command, there should be a section similar to *Figure 7.29*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Displaying the limits and requests for the CoreDNS pod](img/B17338_07_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.29: Limits and requests for the CoreDNS pod'
  prefs: []
  type: TYPE_NORMAL
- en: This shows you that this pod has a memory limit of `170Mi`, no CPU limit, and
    has a request for 100 m CPU (which means 0.1 CPU) and `70Mi` of memory. This means
    that if this pod were to consume more than 170 MiB of memory, Kubernetes would
    restart that pod. Kubernetes has also reserved 0.1 CPU core and 70 MiB of memory
    for this pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Requests and limits are used to perform capacity management in a cluster. You
    can also get the actual CPU and memory consumption of a pod. Run the following
    command and you''ll get the actual pod consumption in all namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This should show you anoutput similar to *Figure 7.30*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running a command to get the actual pod consumption in all namespaces](img/B17338_07_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.30: Seeing the CPU and memory consumption of pods'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `kubectl top` command shows the CPU and memory consumption at the
    point in time when the command was run. In this case, you can see that the `coredns`
    pods are using `3m` CPU and `10Mi` of memory.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have used the `kubectl` command to get an insight into
    the resource utilization of the nodes and pods in your cluster. This is useful
    information, but it is limited to that specific point in time. In the next section,
    you'll use the Azure portal to get more detailed information on the cluster and
    the applications on top of the cluster. You'll start by exploring the **AKS Diagnostics**
    pane.
  prefs: []
  type: TYPE_NORMAL
- en: Using AKS Diagnostics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are experiencing issues in AKS, a good place to start your exploration
    is the **AKS Diagnostics** pane. It provides you with tools that help investigate
    any issues related to underlying infrastructure or system cluster components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: AKS Diagnostics is in preview at the time of writing this book. This means functionality
    might be added or removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access AKS Diagnostics, hit the **Diagnose and solve problems** option in
    the AKS menu. This will open up Diagnostics, as shown in *Figure 7.31*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of the AKS Diagnostics pane in the Azure portal](img/B17338_07_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.31: Accessing AKS Diagnostics'
  prefs: []
  type: TYPE_NORMAL
- en: 'AKS Diagnostics gives you two tools to diagnose and explore issues. One is
    **Cluster Insights**, and the other is **Networking**. Cluster Insights uses cluster
    logs and configuration on your cluster to perform a health check and compare your
    cluster against best practices. It contains useful information and relevant health
    indicators in case anything is misconfigured in your cluster. An example output
    of Cluster Insights is shown in *Figure 7.32*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example output of Cluster Insights as seen in the Azure portal](img/B17338_07_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.32: Example output from Cluster Insights'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Networking section of AKS Diagnostics allows you to interactively troubleshoot
    networking issues in your cluster. As you open the Networking view, you are presented
    with several questions that will then trigger network health checks and configuration
    reviews. Once you select one of those options, the interactive tool will give
    you the output from those checks, as shown in *Figure 7.33*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagnosing networking issues using AKS Diagnostics](img/B17338_07_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.33: Diagnosing networking issues using AKS Diagnostics'
  prefs: []
  type: TYPE_NORMAL
- en: Using AKS Diagnostics is very useful when you are facing infrastructure issues
    on your cluster. The tool does a scan of your environment and verifies whether
    everything is running and configured well. However, it does not scan your applications.
    That is where Azure Monitor comes in; it allows you to monitor your application
    and access your application logs.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Monitor metrics and logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously in this chapter, you explored the status and metrics of nodes and
    pods in your cluster using the `kubectl` command-line tool. In Azure, you can
    get more metrics from nodes and pods and explore the logs from pods in your cluster.
    Let's start by exploring AKS Insights in the Azure portal.
  prefs: []
  type: TYPE_NORMAL
- en: AKS Insights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Insights** section of the AKS pane provides most of the metrics you need
    to know about your cluster. It also has the ability to drill down to the container
    level. You can also see the logs of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Insights section of the AKS pane relies on Azure Monitor for containers.
    If you created the cluster using the portal defaults, this is enabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes makes metrics available but doesn't store them. Azure Monitor can
    be used to store these metrics and make them available to query over time. To
    collect the relevant metrics and logs into Insights, Azure connects to the Kubernetes
    API to collect the metrics and logs to then store them in Azure Monitor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Logs of a container could contain sensitive information. Therefore, the rights
    to review logs should be controlled and audited.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore the **Insights** tab of the AKS pane, starting with the cluster
    metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Insights** shows the cluster metrics. *Figure 7.34* shows the CPU utilization
    and the memory utilization of all the nodes in the cluster. You can optionally
    add additional filters to filter to a particular namespace, node, or node pool.
    There also is a live option, which gives you more real-time information on your
    cluster status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing CPU and memory utilization for the cluster in the Cluster tab](img/B17338_07_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.34: The Cluster tab shows CPU and memory utilization for the cluster'
  prefs: []
  type: TYPE_NORMAL
- en: 'The cluster metrics also show the node count and the number of active pods.
    The node count is important, as you can track whether you have any nodes that
    are in a **Not Ready** state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking the node count and the number of active pods in the Cluster tab](img/B17338_07_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.35: The Cluster tab shows the node count and the number of active
    pods'
  prefs: []
  type: TYPE_NORMAL
- en: The **Cluster** tab can be used to monitor the status of the nodes in the cluster.
    Next, you'll explore the **Reports** tab.
  prefs: []
  type: TYPE_NORMAL
- en: Reports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Reports** tab in AKS Insights gives you access to a number of preconfigured
    monitoring workbooks. These workbooks combine text, log queries, metrics, and
    parameters together and give you rich interactive reports. You can drill down
    into each individual report to get more information and prebuilt log queries.
    The available reports are shown in *Figure 7.36*:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Reports functionality is in preview at the time of writing this book.
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of the Reports tab that allows access to preconfigured monitoring
    workbooks](img/B17338_07_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.36: The Reports tab gives you access to preconfigured monitoring workbooks'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, you can explore the **Deployments** workbook. This is shown
    in *Figure 7.37*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of the Deployments workbook, which shows the status of all the
    deployments](img/B17338_07_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.37: The Deployments workbook shows you the status of your deployments'
  prefs: []
  type: TYPE_NORMAL
- en: This shows you all the deployments by default, their health, and up-to-date
    status. As you can see, it shows you that **server1** was temporarily unavailable
    when you were doing the exploration with liveness and readiness probes earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can drill down further into the status of the individual deployments. If
    you click on the **Log** button highlighted in *Figure 7.37*, you get redirected
    to Log Analytics with a prebuilt query. You can then modify this query and get
    deeper insights into your workload, as shown in *Figure 7.38*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drilling down in Log Analytics to get more details on the deployments](img/B17338_07_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.38: Drilling down in Log Analytics to get more details on your deployments'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The queries used in Log Analytics make use of the **Kusto Query Language**
    (**KQL**). To learn more about KQL, please refer to the documentation: [https://docs.microsoft.com/azure/data-explorer/kusto/concepts/](https://docs.microsoft.com/azure/data-explorer/kusto/concepts/)'
  prefs: []
  type: TYPE_NORMAL
- en: The **Reports** tab in AKS Insights gives you a number of prebuilt monitoring
    workbooks. The next tab is the **Nodes** tab.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Nodes** view shows you detailed metrics for your nodes. It also shows
    you which pods are running on each node, as you can see in *Figure 7.39*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detailed metrics of the nodes as seen in the Nodes pane](img/B17338_07_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.39: Detailed metrics of the nodes in the Nodes pane'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that different metrics can be viewed from the dropdown menu right next
    to the search bar. If you need even more details, you can click through and get
    Kubernetes event logs from your nodes as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Clicking on the View Kubernetes event logs option to get the logs from a
    cluster](img/B17338_07_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.40: Click on View Kubernetes event logs to get the logs from a cluster'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will open Azure Log Analytics and will have pre-created a query for you
    that shows the logs for your node. In the example in *Figure 7.41*, you can see
    that the node was rebooted a couple of times and hit an `InvalidDiskCapacity`
    warning as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of Log Analytics displaying a pre-created query to show the logs
    for your node](img/B17338_07_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.41: Log Analytics showing the logs for the nodes'
  prefs: []
  type: TYPE_NORMAL
- en: This gives you information about the status of your nodes. Next, you'll explore
    the **Controllers** tab.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Controllers** tab shows you details on all the controllers (that is,
    ReplicaSets, DaemonSets, and so on) on your cluster and the pods running in them.
    This shows you a controller-centric view of running pods. For instance, you can
    find the **server1** ReplicaSet and see all the pods and containers running in
    it, as shown in *Figure 7.42*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of the Controllers tab displaying all the pods running in a ReplicaSet](img/B17338_07_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.42: The Controllers tab shows you all the pods running in a ReplicaSet'
  prefs: []
  type: TYPE_NORMAL
- en: The next tab is the **Containers** tab, which will show you the metrics, logs,
    and environment variables for a container.
  prefs: []
  type: TYPE_NORMAL
- en: Container metrics, logs, and environment variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Clicking on the **Containers** tab lists the container metrics, environment
    variables, and access to its logs, as shown in *Figure 7.43*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of the Containers tab displaying all the individual containers](img/B17338_07_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.43: The Containers tab shows us all the individual containers'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You might notice a couple of containers with an `Unknown` state. If a container
    in the `unknown` status, that is because Azure Monitor has logs and information
    about that container, but the container is no longer running on the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get access to the container''s logs from this view as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Clicking the View container logs option to access the logs from the containers
    tab itself](img/B17338_07_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.44: Access the container''s logs'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will show you all the logs that Kubernetes logged from your application.
    Earlier in the chapter, you used `kubectl` to get access to container logs. Using
    this approach can be a lot more productive, as you can edit the log queries and
    correlate logs from different pods and applications in a single view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying logs that Kubernetes logged from the application in a single view](img/B17338_07_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.45: Logs are collected and can be queried'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the logs, this view also shows the environment variables that are
    set for the container. To see the environment variables, scroll down in the right
    cell of the **Containers** view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the environment variables set for the container](img/B17338_07_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.46: The environment variables set for the container'
  prefs: []
  type: TYPE_NORMAL
- en: The final tab in AKS Insights is the **Deployments** tab, which you'll explore
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Deployments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final tab is the **Deployments** tab. This tab gives you an overview of
    all deployments in the cluster and allows you to get the definition of the deployment
    by selecting it. As you can see in *Figure 7.47*, you can get this view either
    in **Describe** (in text format) or in **RAW** (YAML format):'
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of the Deployments tab in the AKS Insights pane](img/B17338_07_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.47: The Deployments tab in AKS Insights'
  prefs: []
  type: TYPE_NORMAL
- en: By using the **Insights** pane in AKS, you can get detailed information about
    your cluster. You explored the different tabs in this section and learned how
    you can drill down and get access to customizable log queries to get even more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that concludes this section. Let''s make sure to clean up all the resources
    created in this chapter by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this section, you explored monitoring applications running on top of Kubernetes.
    You used the AKS **Insights** tab in the Azure portal to get a detailed view of
    your cluster and the containers running on the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You started this chapter by learning how to use different `kubectl` commands
    to monitor an application. Then, you explored how logs created in Kubernetes can
    be used to debug that application. The logs contain all the information that is
    written to `stdout` and `stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, you switched to the Azure portal and started using AKS Diagnostics
    to explore infrastructure issues. Lastly, you explored the use of Azure Monitor
    and AKS Insights to show the AKS metrics and environment variables, as well as
    logs with log filtering.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to connect an AKS cluster to Azure PaaS
    services. You will specifically focus on how you can connect an AKS cluster to
    a MySQL database managed by Azure.
  prefs: []
  type: TYPE_NORMAL
