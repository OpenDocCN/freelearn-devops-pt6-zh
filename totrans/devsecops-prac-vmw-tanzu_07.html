<html><head></head><body>
<div id="_idContainer149">
<h1 class="chapter-number" id="_idParaDest-131"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-132"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.2.1">Orchestrating Containers across Clouds with Tanzu Kubernetes Grid</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we learned about Harbor, a container registry, that is covered as a part of the Tanzu product bundle. </span><span class="koboSpan" id="kobo.3.2">After learning about hosting our container images with Harbor, let’s learn how to deploy them on Kubernetes in this chapter with Tanzu Kubernetes Grid, a multi-cloud and enterprise-ready Kubernetes distribution of Tanzu. </span><span class="koboSpan" id="kobo.3.3">Kubernetes has become widely accepted and the default norm in the industry to run containers</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.4.1"> in the past few years. </span><span class="koboSpan" id="kobo.4.2">As per a recent survey by the </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">Cloud Native Computing Foundation</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.7.1">CNCF</span></strong><span class="koboSpan" id="kobo.8.1">), 96% of the responding organizations</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.9.1"> were either evaluating or already using Kubernetes (source: </span><a href="https://www.cncf.io/wp-content/uploads/2022/02/CNCF-Annual-Survey-2021.pdf"><span class="koboSpan" id="kobo.10.1">https://www.cncf.io/wp-content/uploads/2022/02/CNCF-Annual-Survey-2021.pdf</span></a><span class="koboSpan" id="kobo.11.1">)! </span><span class="koboSpan" id="kobo.11.2">Additionally, a large sum of them used Kubernetes on different cloud platforms for reasons such as risk mitigation, avoiding vendor lock-ins, and efficient operational expenditure. </span><span class="koboSpan" id="kobo.11.3">But operating large Kubernetes platforms on one or more clouds is a non-trivial effort for various reasons. </span><span class="koboSpan" id="kobo.11.4">Each cloud platform has APIs and distinct ways to manage Kubernetes services. </span><span class="koboSpan" id="kobo.11.5">The complexity increases when the organizations also need to run Kubernetes services on-premises. </span><span class="koboSpan" id="kobo.11.6">For such on-premises Kubernetes deployments, many enterprises build their own platforms with custom automation. </span><span class="koboSpan" id="kobo.11.7">While building such custom platforms using open source tools brings initial cost savings, maintaining them for a long time is very difficult when the original people who built the platforms move out of the organizations. </span><span class="koboSpan" id="kobo.11.8">Rather, the organizations could better utilize their talents to build more revenue-generating custom applications for their businesses</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.12.1"> by using an enterprise-grade product such as </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">Tanzu Kubernetes Grid</span></strong><span class="koboSpan" id="kobo.14.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.15.1">TKG</span></strong><span class="koboSpan" id="kobo.16.1">) for such </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">below-value-line concerns.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">TKG is VMware’s Kubernetes distribution that comes with all the bells and whistles to deploy enterprise-grade container platforms on vSphere-based on-premises data centers, </span><strong class="bold"><span class="koboSpan" id="kobo.19.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.20.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.21.1">AWS</span></strong><span class="koboSpan" id="kobo.22.1">), and Azure public cloud infrastructure. </span><span class="koboSpan" id="kobo.22.2">In this chapter, we will learn about this product in detail and will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">following topics:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.24.1">Why Tanzu Kubernetes Grid?</span></strong><span class="koboSpan" id="kobo.25.1">: A walkthrough of the features and capabilities </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">of TKG</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.27.1">Unboxing Tanzu Kubernetes Grid</span></strong><span class="koboSpan" id="kobo.28.1">: A detailed overview of the components and the concepts </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">of TKG</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.30.1">Getting started with Tanzu Kubernetes Grid</span></strong><span class="koboSpan" id="kobo.31.1">: Learn how to install and </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">configure TKG</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.33.1">Common day-2 operations with Tanzu Kubernetes Grid</span></strong><span class="koboSpan" id="kobo.34.1">: Learn how to perform various cluster life cycle activities </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">with TKG</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.36.1">Let’s get started by learning about the background of Tanzu </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">Kubernetes Grid.</span></span></p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.38.1">Why Tanzu Kubernetes Grid?</span></h1>
<p><span class="koboSpan" id="kobo.39.1">In a nutshell, TKG</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.40.1"> is an enterprise-supported flavor of the open source Kubernetes platform. </span><span class="koboSpan" id="kobo.40.2">Like many other distributions, TKG uses the upstream Kubernetes distributions without modifying the open source code base. </span><span class="koboSpan" id="kobo.40.3">However, there are a few good reasons why an enterprise would like to use TKG over the open source community – </span><em class="italic"><span class="koboSpan" id="kobo.41.1">vanilla</span></em><span class="koboSpan" id="kobo.42.1"> – distribution of Kubernetes. </span><span class="koboSpan" id="kobo.42.2">We’ll explore those reasons in </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">this section.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.44.1">Multi-cloud application deployments</span></h2>
<p><span class="koboSpan" id="kobo.45.1">As per a survey done by Gartner (</span><a href="https://www.gartner.com/smarterwithgartner/why-organizations-choose-a-multicloud-strategy"><span class="koboSpan" id="kobo.46.1">https://www.gartner.com/smarterwithgartner/why-organizations-choose-a-multicloud-strategy</span></a><span class="koboSpan" id="kobo.47.1">), over 81% of respondents</span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.48.1"> said that they</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.49.1"> have a multi-cloud deployment or strategy. </span><span class="koboSpan" id="kobo.49.2">Enterprises have multi-cloud strategies for reasons such as avoiding vendor lock-ins and using the best services offered by the respective cloud provider. </span><span class="koboSpan" id="kobo.49.3">Additionally, the enterprises have applications that may not be deployed on a public cloud platform and hence deployed on-premises. </span><span class="koboSpan" id="kobo.49.4">Kubernetes offers a great option to allow application deployments in multi-cloud and hybrid cloud platforms. </span><span class="koboSpan" id="kobo.49.5">Once an application is ready to run in Kubernetes wrapped in a container, it can be deployed on any upstream conformant Kubernetes platform deployed in any cloud or data center. </span><span class="koboSpan" id="kobo.49.6">Kubernetes made the multi-cloud deployment of applications almost trivial. </span><span class="koboSpan" id="kobo.49.7">Kubernetes manages containerized applications well, but at its core, it does not know how to manage the infrastructure on which it is deployed. </span><span class="koboSpan" id="kobo.49.8">That makes the platform and infrastructure management an external concern. </span><span class="koboSpan" id="kobo.49.9">All major cloud providers offer Kubernetes as a service in addition to the option of just using their infrastructure to deploy a self-managed Kubernetes platform. </span><span class="koboSpan" id="kobo.49.10">However, every platform has its own interfaces and hence a different user experience. </span><span class="koboSpan" id="kobo.49.11">Additionally, every platform has its own flavors of operating systems, networks, storage, and compute-level differences. </span><span class="koboSpan" id="kobo.49.12">Managing large Kubernetes platforms itself is a hard problem to solve, which is amplified even more when we need to manage a multi-cloud environment. </span><span class="koboSpan" id="kobo.49.13">While learning the details of one cloud platform is not complex enough, now, the infrastructure and the platform teams need to learn the same for more than one cloud platform if they aim to deploy Kubernetes in a multi-cloud fashion. </span><span class="koboSpan" id="kobo.49.14">Because of these reasons and the complexities involved, several enterprises avoid going multi-cloud despite the involved risks in using just </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">one platform.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">TKG addresses these challenges by providing a uniform experience to operate Kubernetes on vSphere (for on-premises deployment), AWS, and Azure cloud platforms. </span><span class="koboSpan" id="kobo.51.2">One of the core components</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.52.1"> of TKG is the Cluster API (</span><a href="https://cluster-api.sigs.k8s.io/"><span class="koboSpan" id="kobo.53.1">https://cluster-api.sigs.k8s.io/</span></a><span class="koboSpan" id="kobo.54.1">), a CNCF open source project that provides an abstraction layer on top of the infrastructure. </span><span class="koboSpan" id="kobo.54.2">The Cluster API deploys and manages Kubernetes nodes with the required storage and network configuration for the selected cloud platform. </span><span class="koboSpan" id="kobo.54.3">Additionally, TKG exposes its interfaces using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">tanzu</span></strong><span class="koboSpan" id="kobo.56.1"> CLI by providing the same user interface to perform different Kubernetes cluster life cycle operations, irrespective of the infrastructure provider. </span><span class="koboSpan" id="kobo.56.2">TKG</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.57.1"> also bundles VMware-supported operating system layers for the three supported cloud providers. </span><span class="koboSpan" id="kobo.57.2">With all these characteristics, TKG provides an easy-to-consume multi-cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">Kubernetes platform.</span></span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.59.1">Open source alignment</span></h2>
<p><span class="koboSpan" id="kobo.60.1">Another of the main benefits</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.61.1"> of using TKG is its usage of open source tools for different use cases. </span><span class="koboSpan" id="kobo.61.2">As its core component, TKG uses the upstream open source Kubernetes distribution maintained by the CNCF community. </span><span class="koboSpan" id="kobo.61.3">TKG does not fork the source code of any of its open source components to add its own flavor and customization. </span><span class="koboSpan" id="kobo.61.4">This characteristic provides TKG consumers with all the benefits of using open source software, including avoidance of vendor lock-ins via portability, and an avenue to enrich the functionalities to their needs via open </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">source contributions.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">Considering these benefits, all enterprises have wanted to use open source solutions as much as possible in the past few years. </span><span class="koboSpan" id="kobo.63.2">However, the cloud-native ecosystem is very crowded with open source products that solve similar problems and have different levels of maturity to be used in production setups. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.64.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.65.1">.1</span></em><span class="koboSpan" id="kobo.66.1"> is a screenshot taken from the CNCF website (</span><a href="https://landscape.cncf.io/"><span class="koboSpan" id="kobo.67.1">https://landscape.cncf.io/</span></a><span class="koboSpan" id="kobo.68.1">) showing an extremely crowded space with tools solving</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.69.1"> different problems running containerized applications. </span><span class="koboSpan" id="kobo.69.2">Picking the right tool for the right problem</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.70.1"> with acceptable maturity, a vibrant community, and enterprise-level support is a challenging task. </span><span class="koboSpan" id="kobo.70.2">And the landscape is constantly changing by adding new solutions to the list very frequently. </span><span class="koboSpan" id="kobo.70.3">Adding more to the complexity, the compatibility of one tool working with another is not always the case. </span><span class="koboSpan" id="kobo.70.4">So, there are three possible solutions to </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">this issue:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.72.1">Enterprises would build their custom container platforms by carefully evaluating their options in this diverse and crowded landscape by running long proof-of-concept projects to narrow down their choices. </span><span class="koboSpan" id="kobo.72.2">While this would provide all the control and possible short-term cost benefits, there are some considerable drawbacks to this approach. </span><span class="koboSpan" id="kobo.72.3">One of them is that enterprises may need to spend a lot of productive time with their engineers to build a custom container platform. </span><span class="koboSpan" id="kobo.72.4">Finding right talents from the market and building required skills internally are hard and expensive challenges. </span><span class="koboSpan" id="kobo.72.5">Additionally, such skilled people would be in high demand in the market and may not stay with the enterprise for a long time to support what they have built internally. </span><span class="koboSpan" id="kobo.72.6">And then, such custom-built solutions quickly become an expensive liability for </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">the organization.</span></span></li>
<li><span class="koboSpan" id="kobo.74.1">Enterprises would choose all the solutions provided by a cloud provider, where the enterprises no longer need to spend time selecting the tools and worry about the support and compatibility of those tools. </span><span class="koboSpan" id="kobo.74.2">This way, an enterprise can build a robust and production-grade container platform using all the services provided by a single hyper-scaler such as AWS, Azure, or Google Cloud Platform. </span><span class="koboSpan" id="kobo.74.3">However, this approach could result in potential vendor lock-ins. </span><span class="koboSpan" id="kobo.74.4">The </span><em class="italic"><span class="koboSpan" id="kobo.75.1">divorce</span></em><span class="koboSpan" id="kobo.76.1"> would be very painful in the long term and it would be an expensive </span><em class="italic"><span class="koboSpan" id="kobo.77.1">marriage</span></em><span class="koboSpan" id="kobo.78.1"> with one </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">cloud provider:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer113">
<span class="koboSpan" id="kobo.80.1"><img alt="Figure 7.1 – CNCF landscape" src="image/B18145_07_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.81.1">Figure 7.1 – CNCF landscape</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.82.1">Enterprises would pick a multi-cloud platform such as Tanzu that would abstract an infrastructure provider, resulting in the portability of workloads deployed on the platform. </span><span class="koboSpan" id="kobo.82.2">Like the first two approaches, this one also has a drawback. </span><span class="koboSpan" id="kobo.82.3">Using such multi-cloud platforms might result in a vendor lock-in situation for the vendor of the multi-cloud platform provider itself. </span><span class="koboSpan" id="kobo.82.4">There is no foolproof solution to avoid vendor lock-ins when we use any third-party product. </span><span class="koboSpan" id="kobo.82.5">However, this risk could be somewhat mitigated if the third-party solution is fully backed by open source components, which is exactly the case </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">with TKG.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.84.1">TKG is a bundle</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.85.1"> of many different popular open source projects, including Kubernetes as a container runtime, the Cluster API for Kubernetes cluster life cycle management, Antrea for container overlay networking, Ubuntu and Photon as the node operating systems, Fluent Bit for logging, Prometheus and Grafana for monitoring, and many others. </span><span class="koboSpan" id="kobo.85.2">We will cover them all in the next section. </span><span class="koboSpan" id="kobo.85.3">VMware supplies signed binaries for all these open source tools that work together for a given release of TKG. </span><span class="koboSpan" id="kobo.85.4">This way, TKG helps enterprises avoid going through the painful process of tool selection, makes them work together, gets them supported, and avoids vendor lock-ins to a </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">good extent.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">With this, we have answered the question </span><em class="italic"><span class="koboSpan" id="kobo.88.1">Why Tanzu Kubernetes Grid?</span></em><span class="koboSpan" id="kobo.89.1"> Now, let’s understand what is included in the TKG bundle and its </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">core concepts.</span></span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.91.1">Unboxing Tanzu Kubernetes Grid</span></h1>
<p><span class="koboSpan" id="kobo.92.1">In this section, we will review all the building blocks of TKG, including its interface and core and extension components. </span><span class="koboSpan" id="kobo.92.2">After that, we will understand the core concepts of this platform to understand how it works. </span><span class="koboSpan" id="kobo.92.3">We have a long way to go, so </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">let’s start.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.94.1">Building blocks of Tanzu Kubernetes Grid</span></h2>
<p><span class="koboSpan" id="kobo.95.1">As mentioned in the previous section, TKG</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.96.1"> is a collection of many open source tools that solve different problems that, together, make an enterprise-grade Kubernetes platform. </span><span class="koboSpan" id="kobo.96.2">We can distribute these components into three categories – interface, core, and extensions – as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.97.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.98.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer114">
<span class="koboSpan" id="kobo.100.1"><img alt="Figure 7.2 – Tanzu Kubernetes Grid bundle" src="image/B18145_07_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.101.1">Figure 7.2 – Tanzu Kubernetes Grid bundle</span></p>
<p><span class="koboSpan" id="kobo.102.1">Let’s review all these components to learn about their roles in the </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">TKG bundle.</span></span></p>
<h3><span class="koboSpan" id="kobo.104.1">Interface components of Tanzu Kubernetes Grid</span></h3>
<p><span class="koboSpan" id="kobo.105.1">As the name suggests, these components</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.106.1"> include TKG’s interfaces with users and infrastructure providers, including vSphere, AWS, and Azure. </span><span class="koboSpan" id="kobo.106.2">The following section specifies these tools in </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">more detail.</span></span></p>
<h4><span class="koboSpan" id="kobo.108.1">Tanzu command-line interface (CLI)</span></h4>
<p><span class="koboSpan" id="kobo.109.1">Like a few</span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.110.1"> other products in the Tanzu product portfolio, TKG also uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">tanzu</span></strong><span class="koboSpan" id="kobo.112.1"> CLI as its primary user interface. </span><span class="koboSpan" id="kobo.112.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">tanzu</span></strong><span class="koboSpan" id="kobo.114.1"> CLI has a plugin structure that allows different Tanzu products to use the same interface. </span><span class="koboSpan" id="kobo.114.2">TKG uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">tanzu</span></strong><span class="koboSpan" id="kobo.116.1"> CLI for all cluster operations, such as viewing, creating, scaling, deleting, and upgrading TKG clusters. </span><span class="koboSpan" id="kobo.116.2">We will use this CLI in the next section when we set up our TKG foundation. </span><span class="koboSpan" id="kobo.116.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">tanzu</span></strong><span class="koboSpan" id="kobo.118.1"> CLI is a part of the broader open source project named Tanzu Framework (</span><a href="https://github.com/vmware-tanzu/tanzu-framework"><span class="koboSpan" id="kobo.119.1">https://github.com/vmware-tanzu/tanzu-framework</span></a><span class="koboSpan" id="kobo.120.1">). </span><span class="koboSpan" id="kobo.120.2">You can learn more about this CLI </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">here: </span></span><a href="https://github.com/vmware-tanzu/tanzu-framework/tree/main/docs/cli"><span class="No-Break"><span class="koboSpan" id="kobo.122.1">https://github.com/vmware-tanzu/tanzu-framework/tree/main/docs/cli</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.123.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">In addition to this CLI, the Tanzu</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.125.1"> portfolio includes a </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">graphical user interface</span></strong><span class="koboSpan" id="kobo.127.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.128.1">GUI</span></strong><span class="koboSpan" id="kobo.129.1">) tool named </span><strong class="bold"><span class="koboSpan" id="kobo.130.1">Tanzu Mission Control</span></strong><span class="koboSpan" id="kobo.131.1"> for all TKG cluster</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.132.1"> operations. </span><span class="koboSpan" id="kobo.132.2">We will learn about this tool in detail in </span><a href=""><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.133.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.134.1">, </span><em class="italic"><span class="koboSpan" id="kobo.135.1">Managing and Controlling Kubernetes Clusters with Tanzu </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.136.1">Mission Control</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.138.1">Tanzu Kubernetes Grid installer</span></h4>
<p><span class="koboSpan" id="kobo.139.1">The TKG installer is a GUI</span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.140.1"> component that provides a wizard for installing TKG on a selected infrastructure, which could be either vSphere, AWS, or Azure at the time of writing. </span><span class="koboSpan" id="kobo.140.2">During the initial setup of TKG, a very small bootstrapped Kubernetes cluster is deployed</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.141.1"> on the operator’s workstation (also called a </span><strong class="bold"><span class="koboSpan" id="kobo.142.1">bootstrap machine</span></strong><span class="koboSpan" id="kobo.143.1">). </span><span class="koboSpan" id="kobo.143.2">The TKG installer pods get deployed on that local Kubernetes cluster to deploy and start the GUI in the bootstrap machine. </span><span class="koboSpan" id="kobo.143.3">The operator then uses the locally running TKG installer’s GUI to deploy the actual TKG foundation on the targeted cloud infrastructure. </span><span class="koboSpan" id="kobo.143.4">It seems to be confusing because here, TKG uses a (small) Kubernetes platform to deploy a (large) Kubernetes platform. </span><span class="koboSpan" id="kobo.143.5">We will use this GUI during our TKG installation steps in the </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">It is worth noting that TKG also provides a way to install the foundation using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">tanzu</span></strong><span class="koboSpan" id="kobo.147.1"> CLI as well, along with the GUI experience. </span><span class="koboSpan" id="kobo.147.2">However, it is recommended to use the GUI for the first installation as the wizard that’s used in the GUI generates an installation configuration file that can later be used with little modifications to quickly install other similar TKG foundations</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.148.1"> using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">tanzu</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.150.1"> CLI.</span></span></p>
<h4><span class="koboSpan" id="kobo.151.1">kind</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.152.1">kind</span></strong><span class="koboSpan" id="kobo.153.1"> stands for </span><strong class="bold"><span class="koboSpan" id="kobo.154.1">Kubernetes inside Docker</span></strong><span class="koboSpan" id="kobo.155.1">. </span><span class="koboSpan" id="kobo.155.2">kind is an open source project</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.156.1"> under the</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.157.1"> umbrella of Kubernetes </span><strong class="bold"><span class="koboSpan" id="kobo.158.1">Special Interest Groups</span></strong><span class="koboSpan" id="kobo.159.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.160.1">SIGs</span></strong><span class="koboSpan" id="kobo.161.1">) (</span><a href="https://kind.sigs.k8s.io/"><span class="koboSpan" id="kobo.162.1">https://kind.sigs.k8s.io/</span></a><span class="koboSpan" id="kobo.163.1">) that allows</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.164.1"> you to deploy a very tiny Kubernetes cluster</span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.165.1"> as a container running inside a Docker environment. </span><span class="koboSpan" id="kobo.165.2">kind is a CNCF-conformant Kubernetes installer and typically gets deployed in local desktop environments to deploy a small Kubernetes cluster. </span><span class="koboSpan" id="kobo.165.3">The TKG installer pods get deployed in a kind cluster for bootstrap purposes only. </span><span class="koboSpan" id="kobo.165.4">Once the actual TKG foundation has been installed, the kind cluster is destroyed, along with the running installer components, since their purpose has come to </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">an end.</span></span></p>
<h4><span class="koboSpan" id="kobo.167.1">Cluster API</span></h4>
<p><span class="koboSpan" id="kobo.168.1">Kubernetes</span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.169.1"> includes a tool named </span><strong class="bold"><span class="koboSpan" id="kobo.170.1">Kubeadm</span></strong><span class="koboSpan" id="kobo.171.1"> (</span><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/"><span class="koboSpan" id="kobo.172.1">https://kubernetes.io/docs/reference/setup-tools/kubeadm/</span></a><span class="koboSpan" id="kobo.173.1">) that helps configure a</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.174.1"> server to make</span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.175.1"> it a Kubernetes cluster</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.176.1"> node. </span><span class="koboSpan" id="kobo.176.2">It does this by installing the required Kubernetes-specific components. </span><span class="koboSpan" id="kobo.176.3">Kubeadm helps the node join the cluster as best practice </span><em class="italic"><span class="koboSpan" id="kobo.177.1">fast paths</span></em><span class="koboSpan" id="kobo.178.1"> for creating Kubernetes clusters. </span><span class="koboSpan" id="kobo.178.2">However, Kubeadm does not know how to provision the required infrastructure for the given cloud provider. </span><span class="koboSpan" id="kobo.178.3">Kubeadm requires the servers to be created with the required compute, storage, and networking setup before it can convert those servers into Kubernetes nodes. </span><span class="koboSpan" id="kobo.178.4">This gap in infrastructure management in Kubeadm is filled by the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.179.1">Cluster API</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">A TKG user would never directly use the Cluster API, but it is one of the most important building blocks of TKG that interfaces with and abstracts</span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.182.1"> the underlying cloud infrastructure. </span><span class="koboSpan" id="kobo.182.2">The term </span><strong class="bold"><span class="koboSpan" id="kobo.183.1">API</span></strong><span class="koboSpan" id="kobo.184.1"> stands for </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">application program interface</span></strong><span class="koboSpan" id="kobo.186.1"> – a well-known term in the field of computer programming. </span><span class="koboSpan" id="kobo.186.2">The Cluster API</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.187.1"> is also a SIG project (</span><a href="https://cluster-api.sigs.k8s.io/"><span class="koboSpan" id="kobo.188.1">https://cluster-api.sigs.k8s.io/</span></a><span class="koboSpan" id="kobo.189.1">). </span><span class="koboSpan" id="kobo.189.2">The purpose of this project is to provide an interface layer to platforms such as TKG to perform various Kubernetes life cycle operations, including cluster provisioning, upgrading, and operating. </span><span class="koboSpan" id="kobo.189.3">As we know, different cloud providers have different ways of operating their infrastructure. </span><span class="koboSpan" id="kobo.189.4">A virtual machine in the world of vSphere is called an EC2 machine</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.190.1"> in the world of AWS. </span><span class="koboSpan" id="kobo.190.2">A virtual network boundary in AWS is known as a </span><strong class="bold"><span class="koboSpan" id="kobo.191.1">Virtual Private Cloud</span></strong><span class="koboSpan" id="kobo.192.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.193.1">VPC</span></strong><span class="koboSpan" id="kobo.194.1">) but it is called a </span><strong class="bold"><span class="koboSpan" id="kobo.195.1">Virtual Network</span></strong><span class="koboSpan" id="kobo.196.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.197.1">VNet</span></strong><span class="koboSpan" id="kobo.198.1">) in Azure. </span><span class="koboSpan" id="kobo.198.2">The implementation of the Cluster API interfaces</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.199.1"> abstracts such cloud-specific terminologies and </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">operational differences.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">To provide fully automated Kubernetes</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.202.1"> cluster life cycle management, TKG uses the Cluster API; the Cluster API</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.203.1"> uses Kubeadm internally. </span><span class="koboSpan" id="kobo.203.2">This way, TKG fully leverages different open source projects to provide a uniform multi-cloud Kubernetes cluster </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">management experience.</span></span></p>
<h4><span class="koboSpan" id="kobo.205.1">Carvel</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.206.1">Carvel</span></strong><span class="koboSpan" id="kobo.207.1"> (</span><a href="https://carvel.dev/"><span class="koboSpan" id="kobo.208.1">https://carvel.dev/</span></a><span class="koboSpan" id="kobo.209.1">) is one additional open source</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.210.1"> package</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.211.1"> management</span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.212.1"> toolkit that TKG uses for installing itself and other optional packages. </span><span class="koboSpan" id="kobo.212.2">Carvel is a very powerful and flexible packaging tool for Kubernetes deployments. </span><span class="koboSpan" id="kobo.212.3">Carvel contains multiple tools for different package management and deployment tasks, as listed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">following points:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.214.1">kapp-controller</span></em><span class="koboSpan" id="kobo.215.1">: To provide continuous</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.216.1"> delivery for apps and packages deployed on Kubernetes clusters in a </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">GitOps way</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.218.1">ytt</span></em><span class="koboSpan" id="kobo.219.1">: To create and use templatized YAML configurations for package deployment, allowing package configuration customization during their installations on </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">Kubernetes clusters</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.221.1">kapp</span></em><span class="koboSpan" id="kobo.222.1">: To bundle multiple Kubernetes resources as one application package that can be installed, upgraded, or deleted as </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">one unit</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.224.1">kbld</span></em><span class="koboSpan" id="kobo.225.1">: To build or reference container images used in the Kubernetes resource configuration in an </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">immutable way</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.227.1">imgpkg</span></em><span class="koboSpan" id="kobo.228.1">: To package, distribute, and relocate Kubernetes configuration and the associated container images as </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">one bundle</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.230.1">vendir</span></em><span class="koboSpan" id="kobo.231.1">: To declaratively state a </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">directory’s contents</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.233.1">secretgen-controller</span></em><span class="koboSpan" id="kobo.234.1">: To manage various types</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.235.1"> of secrets used by </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">the packages</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.237.1">After learning about the interface related components of TKG, let’s review the core components of </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">TKG now.</span></span></p>
<h3><span class="koboSpan" id="kobo.239.1">Core components of Tanzu Kubernetes Grid</span></h3>
<p><span class="koboSpan" id="kobo.240.1">In addition to the interfacing components</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.241.1"> that we saw previously, TKG contains a set of core components that are the most basic building blocks for a Kubernetes platform. </span><span class="koboSpan" id="kobo.241.2">Let’s learn about </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">them here.</span></span></p>
<h4><span class="koboSpan" id="kobo.243.1">Operating systems</span></h4>
<p><span class="koboSpan" id="kobo.244.1">One of the many advantages</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.245.1"> of using TKG is that you get a supported and hardened operating system from VMware for Kubernetes nodes. </span><span class="koboSpan" id="kobo.245.2">TKG supports Photon and Ubuntu Linux-based operating systems. </span><span class="koboSpan" id="kobo.245.3">Additionally, TKG allows you to build among the supported and a few other flavors of Linux and Windows operating systems with a certain level </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">of customization.</span></span></p>
<h4><span class="koboSpan" id="kobo.247.1">Kubernetes</span></h4>
<p><span class="koboSpan" id="kobo.248.1">Kubernetes</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.249.1"> is the main ingredient of TKG. </span><span class="koboSpan" id="kobo.249.2">Each</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.250.1"> version of TKG includes one or more versions of upstream open source Kubernetes distributions without any modifications. </span><span class="koboSpan" id="kobo.250.2">This component is the main Kubernetes platform, including the main set of tools that make the platform. </span><span class="koboSpan" id="kobo.250.3">It includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">following tools:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.252.1">kube-apiserver</span></em><span class="koboSpan" id="kobo.253.1">: An API interface for the Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">control plane</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.255.1">etcd</span></em><span class="koboSpan" id="kobo.256.1">: A key-value store to persist the state of the Kubernetes cluster and its </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">workload configuration</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.258.1">kube-scheduler</span></em><span class="koboSpan" id="kobo.259.1">: To host newly created pods in a node based on various </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">selection criteria</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.261.1">kube-controller-manager</span></em><span class="koboSpan" id="kobo.262.1">: To run different control processes to manage nodes, jobs, service endpoints, and </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">service accounts</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.264.1">cloud-controller-manager</span></em><span class="koboSpan" id="kobo.265.1">: To run different cloud/infrastructure-specific processes to manage node health checks, routes, and cloud-specific service </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">load balancers</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.267.1">kubelet</span></em><span class="koboSpan" id="kobo.268.1">: A node-residing agent to ensure pods’ running status and report back to the </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">control plane</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.270.1">kube-proxy</span></em><span class="koboSpan" id="kobo.271.1">: A node-residing network proxy that ensures service routes to their endpoint pods running on </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">the node</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.273.1">Container runtime</span></em><span class="koboSpan" id="kobo.274.1">: A node-residing software (</span><strong class="bold"><span class="koboSpan" id="kobo.275.1">containerd</span></strong><span class="koboSpan" id="kobo.276.1"> in the case of TKG) that runs </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.277.1">and </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">manages containers</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.279.1">In addition to these core components</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.280.1"> of Kubernetes, there are a few </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.281.1">more core components that TKG includes that are required for the platform to operate. </span><span class="koboSpan" id="kobo.281.2">Let’s take </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">a look.</span></span></p>
<h4><span class="koboSpan" id="kobo.283.1">Metrics Server</span></h4>
<p><span class="koboSpan" id="kobo.284.1">Metrics Server</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.285.1"> aggregates resource</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.286.1"> usage data, such as container, node CPU, and memory usage, in a Kubernetes cluster and makes it available via the Metrics API defined in Kubernetes. </span><span class="koboSpan" id="kobo.286.2">This component is required to pull details after using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">kubectl top node</span></strong><span class="koboSpan" id="kobo.288.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">kubectl top </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">pod</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.291.1"> command.</span></span></p>
<h4><span class="koboSpan" id="kobo.292.1">Container Storage Interface (CSI)</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.293.1">Container Storage Interface</span></strong><span class="koboSpan" id="kobo.294.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.295.1">CSI</span></strong><span class="koboSpan" id="kobo.296.1">) is a Kubernetes specification</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.297.1"> that requires</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.298.1"> implementation from the storage infrastructure provider. </span><span class="koboSpan" id="kobo.298.2">This will be used in the Kubernetes platform to provide persistent volumes for the workloads that need them. </span><span class="koboSpan" id="kobo.298.3">It provides Kubernetes users with more options for different</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.299.1"> storage solutions. </span><span class="koboSpan" id="kobo.299.2">One Kubernetes</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.300.1"> cluster may have different types of storage, including </span><strong class="bold"><span class="koboSpan" id="kobo.301.1">solid-state drives</span></strong><span class="koboSpan" id="kobo.302.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.303.1">SSDs</span></strong><span class="koboSpan" id="kobo.304.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.305.1">magnetic drives</span></strong><span class="koboSpan" id="kobo.306.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.307.1">HDDs</span></strong><span class="koboSpan" id="kobo.308.1">), and other variants that provide different rates of data input and output. </span><span class="koboSpan" id="kobo.308.2">TKG uses</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.309.1"> the infrastructure-specific storage</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.310.1"> driver for vSphere, AWS, </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">or Azure.</span></span></p>
<h4><span class="koboSpan" id="kobo.312.1">CoreDNS</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.313.1">CoreDNS</span></strong><span class="koboSpan" id="kobo.314.1"> (</span><a href="https://coredns.io/"><span class="koboSpan" id="kobo.315.1">https://coredns.io/</span></a><span class="koboSpan" id="kobo.316.1">) is an open source DNS server</span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.317.1"> that is used</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.318.1"> to provide Kubernetes</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.319.1"> service name resolution. </span><span class="koboSpan" id="kobo.319.2">The open source Kubernetes installs kube-dns for this purpose but allows you to replace kube-dns with CoreDNS, which is a more enhanced DNS server. </span><span class="koboSpan" id="kobo.319.3">TKG clusters get deployed </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">with CoreDNS.</span></span></p>
<h4><span class="koboSpan" id="kobo.321.1">Container Network Interface (CNI)</span></h4>
<p><span class="koboSpan" id="kobo.322.1">As per the Kubernetes networking</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.323.1"> specification, every pod</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.324.1"> in a cluster should have a unique IP address and should be able to communicate with other pods</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.325.1"> on any other node of the cluster without any </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">network address translation</span></strong><span class="koboSpan" id="kobo.327.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.328.1">NAT</span></strong><span class="koboSpan" id="kobo.329.1">). </span><span class="koboSpan" id="kobo.329.2">Additionally, all the agents running in nodes, such as kubelet, should be able to communicate with each pod running on their respective node. </span><span class="koboSpan" id="kobo.329.3">These requirements ensure smooth communication between apps deployed on the same cluster. </span><span class="koboSpan" id="kobo.329.4">However, we need a specific networking</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.330.1"> arrangement to implement this specification. </span><span class="koboSpan" id="kobo.330.2">This is the CNI implementation, which is also known as the overlay network for Kubernetes clusters. </span><span class="koboSpan" id="kobo.330.3">There are many</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.331.1"> CNI implementations that we can choose from to be used in Kubernetes</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.332.1"> clusters. </span><span class="koboSpan" id="kobo.332.2">Out of them, TKG supports </span><strong class="bold"><span class="koboSpan" id="kobo.333.1">Antrea</span></strong><span class="koboSpan" id="kobo.334.1"> (</span><a href="https://antrea.io/"><span class="koboSpan" id="kobo.335.1">https://antrea.io/</span></a><span class="koboSpan" id="kobo.336.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.337.1">Calico</span></strong><span class="koboSpan" id="kobo.338.1"> (</span><a href="https://www.tigera.io/project-calico/"><span class="koboSpan" id="kobo.339.1">https://www.tigera.io/project-calico/</span></a><span class="koboSpan" id="kobo.340.1">), which we can choose</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.341.1"> from during </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">platform setup.</span></span></p>
<h4><span class="koboSpan" id="kobo.343.1">Control plane load balancers</span></h4>
<p><span class="koboSpan" id="kobo.344.1">TKG can create multi-master Kubernetes</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.345.1"> clusters for high availability</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.346.1"> of the control plane objects of a Kubernetes cluster. </span><span class="koboSpan" id="kobo.346.2">Such clusters typically have three Kubernetes control plane (master) nodes serving Kubernetes API traffic and performing crucial workload management activities. </span><span class="koboSpan" id="kobo.346.3">For a TKG deployment on AWS and Azure, TKG creates their respective virtual load balancer objects to front these control plane nodes for the API server</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.347.1"> traffic distribution. </span><span class="koboSpan" id="kobo.347.2">For vSphere, TKG includes </span><strong class="bold"><span class="koboSpan" id="kobo.348.1">NSX Advanced Load Balancer</span></strong><span class="koboSpan" id="kobo.349.1"> (</span><a href="https://www.vmware.com/products/nsx-advanced-load-balancer.html"><span class="koboSpan" id="kobo.350.1">https://www.vmware.com/products/nsx-advanced-load-balancer.html</span></a><span class="koboSpan" id="kobo.351.1">) to create a virtual load balancer</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.352.1"> for the same purpose. </span><span class="koboSpan" id="kobo.352.2">However, if TKG is not configured with NSX Advanced Load Balancer on vSphere, it uses an open source</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.353.1"> and lightweight virtual</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.354.1"> load balancer named </span><strong class="bold"><span class="koboSpan" id="kobo.355.1">kube-vip</span></strong><span class="koboSpan" id="kobo.356.1"> (</span><a href="https://kube-vip.io/"><span class="koboSpan" id="kobo.357.1">https://kube-vip.io/</span></a><span class="koboSpan" id="kobo.358.1">). </span><span class="koboSpan" id="kobo.358.2">kube-vip is also a </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">CNCF-governed</span></span><span class="No-Break"><a id="_idIndexMarker425"/></span><span class="No-Break"><span class="koboSpan" id="kobo.360.1"> project.</span></span></p>
<h3><span class="koboSpan" id="kobo.361.1">Extension packages of Tanzu Kubernetes Grid</span></h3>
<p><span class="koboSpan" id="kobo.362.1">The open source Kubernetes</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.363.1"> distribution comes with the minimal components required to deploy a Kubernetes platform. </span><span class="koboSpan" id="kobo.363.2">However, to deploy a production-grade Kubernetes environment, we need several other capabilities, such as logging, monitoring, access control, backup and restore, and more. </span><span class="koboSpan" id="kobo.363.3">Since TKG is an enterprise-grade Kubernetes distribution, it also comes with many such open source extension packages with VMware-signed binaries. </span><span class="koboSpan" id="kobo.363.4">Let’s check these </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">components out.</span></span></p>
<h4><span class="koboSpan" id="kobo.365.1">Logging</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.366.1">Fluent Bit</span></strong><span class="koboSpan" id="kobo.367.1"> (</span><a href="https://fluentbit.io/"><span class="koboSpan" id="kobo.368.1">https://fluentbit.io/</span></a><span class="koboSpan" id="kobo.369.1">) is a high-performance-focused</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.370.1"> open source log</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.371.1"> forwarding tool </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.372.1">for different flavors of Linux and Windows operating systems. </span><span class="koboSpan" id="kobo.372.2">Fluent Bit is also a CNCF sub-project. </span><span class="koboSpan" id="kobo.372.3">The purpose of this tool is to process logs emitted from Kubernetes nodes and the workload pods and can be configured to plumb them to a long list of possible log aggregation destinations, including Splunk, Elasticsearch, Amazon CloudWatch, Kafka, and </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">many more.</span></span></p>
<h4><span class="koboSpan" id="kobo.374.1">Ingress controller</span></h4>
<p><span class="koboSpan" id="kobo.375.1">TKG supplies </span><strong class="bold"><span class="koboSpan" id="kobo.376.1">Contour</span></strong><span class="koboSpan" id="kobo.377.1"> (</span><a href="https://projectcontour.io/"><span class="koboSpan" id="kobo.378.1">https://projectcontour.io/</span></a><span class="koboSpan" id="kobo.379.1">) binaries as an extended</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.380.1"> package</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.381.1"> to provide</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.382.1"> an ingress type</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.383.1"> of routing for the external-facing services deployed on Kubernetes clusters. </span><span class="koboSpan" id="kobo.383.2">Contour is an open</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.384.1"> source project under the CNCF umbrella that internally uses the </span><strong class="bold"><span class="koboSpan" id="kobo.385.1">Envoy proxy</span></strong><span class="koboSpan" id="kobo.386.1"> (</span><a href="https://www.envoyproxy.io/"><span class="koboSpan" id="kobo.387.1">https://www.envoyproxy.io/</span></a><span class="koboSpan" id="kobo.388.1">), another CNCF open source</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.389.1"> project. </span><span class="koboSpan" id="kobo.389.2">Together with Envoy (as the data plane), Contour (as the control plane) provides the required implementation of the ingress controller to provide the HTTP-level (network layer 7) service routing defined using the ingress resources </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">of Kubernetes.</span></span></p>
<h4><span class="koboSpan" id="kobo.391.1">Identity and authentication</span></h4>
<p><span class="koboSpan" id="kobo.392.1">TKG includes </span><strong class="bold"><span class="koboSpan" id="kobo.393.1">Pinniped</span></strong><span class="koboSpan" id="kobo.394.1"> (</span><a href="https://pinniped.dev/"><span class="koboSpan" id="kobo.395.1">https://pinniped.dev/</span></a><span class="koboSpan" id="kobo.396.1">), another CNCF open</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.397.1"> source project</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.398.1"> backed by VMware</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.399.1"> to provide an easy button for the Kubernetes cluster’s user identity and authentication management. </span><span class="koboSpan" id="kobo.399.2">The upstream Kubernetes distribution does not include any authentication mechanism and only provides the configuration for authorization. </span><span class="koboSpan" id="kobo.399.3">Hence, to allow cluster users</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.400.1"> to get authenticated</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.401.1"> using existing identity providers based on a </span><strong class="bold"><span class="koboSpan" id="kobo.402.1">Lightweight Directory Access Protocol</span></strong><span class="koboSpan" id="kobo.403.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.404.1">LDAP</span></strong><span class="koboSpan" id="kobo.405.1">) server or </span><strong class="bold"><span class="koboSpan" id="kobo.406.1">Open ID Connect</span></strong><span class="koboSpan" id="kobo.407.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.408.1">OIDC</span></strong><span class="koboSpan" id="kobo.409.1">), TKG supplies Pinniped as an </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">extension package.</span></span></p>
<h4><span class="koboSpan" id="kobo.411.1">Observability</span></h4>
<p><span class="koboSpan" id="kobo.412.1">For cluster observability, TKG also</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.413.1"> supplies the</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.414.1"> signed binaries for </span><strong class="bold"><span class="koboSpan" id="kobo.415.1">Prometheus</span></strong><span class="koboSpan" id="kobo.416.1"> (</span><a href="https://prometheus.io/"><span class="koboSpan" id="kobo.417.1">https://prometheus.io/</span></a><span class="koboSpan" id="kobo.418.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.419.1">Grafana</span></strong><span class="koboSpan" id="kobo.420.1"> (</span><a href="https://github.com/grafana/grafana"><span class="koboSpan" id="kobo.421.1">https://github.com/grafana/grafana</span></a><span class="koboSpan" id="kobo.422.1">), two very popular open source</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.423.1"> monitoring tools for the Kubernetes ecosystem. </span><span class="koboSpan" id="kobo.423.2">Here, Prometheus</span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.424.1"> is a metrics aggregator engine and Grafana is a metrics rendering tool for visualization. </span><span class="koboSpan" id="kobo.424.2">In addition to these </span><em class="italic"><span class="koboSpan" id="kobo.425.1">batteries included</span></em><span class="koboSpan" id="kobo.426.1"> monitoring tools, TKG also supports first-class integration</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.427.1"> with VMware Aria operations for Applications, a </span><strong class="bold"><span class="koboSpan" id="kobo.428.1">Software-as-a-Service</span></strong><span class="koboSpan" id="kobo.429.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.430.1">SaaS</span></strong><span class="koboSpan" id="kobo.431.1">) platform in the VMware portfolio, for more capabilities around scaling, functionality, and power for full stack observability. </span><span class="koboSpan" id="kobo.431.2">We will cover this product in detail in </span><a href="B18145_10.xhtml#_idTextAnchor193"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.432.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.433.1">, </span><em class="italic"><span class="koboSpan" id="kobo.434.1">Realizing Full-Stack Visibility with VMware Aria Operations </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.435.1">for Applications</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.437.1">Container registry</span></h4>
<p><span class="koboSpan" id="kobo.438.1">TKG also comes with </span><strong class="bold"><span class="koboSpan" id="kobo.439.1">Harbor</span></strong><span class="koboSpan" id="kobo.440.1">, a purpose-built container</span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.441.1"> registry, as an</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.442.1"> extended package that can be installed in the cluster if required. </span><span class="koboSpan" id="kobo.442.2">We covered Harbor extensively in </span><a href="B18145_06.xhtml#_idTextAnchor112"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.443.1">Chapter 6</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.444.1">, Managing Container Images </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.445.1">with Harbor</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.447.1">Backup and restore</span></h4>
<p><span class="koboSpan" id="kobo.448.1">Disaster recovery is a very important</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.449.1"> aspect of platform-supporting production applications. </span><span class="koboSpan" id="kobo.449.2">A Kubernetes cluster is not any different running critical production workloads. </span><span class="koboSpan" id="kobo.449.3">However, Kubernetes does not include anything to back up and restore the state of the workloads running on its clusters. </span><span class="koboSpan" id="kobo.449.4">To fill</span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.450.1"> this gap, TKG includes </span><strong class="bold"><span class="koboSpan" id="kobo.451.1">Velero</span></strong><span class="koboSpan" id="kobo.452.1"> (</span><a href="https://velero.io/"><span class="koboSpan" id="kobo.453.1">https://velero.io/</span></a><span class="koboSpan" id="kobo.454.1">) as an extension package</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.455.1"> in the bundle. </span><span class="koboSpan" id="kobo.455.2">Velero is also an open source project under the CNCF umbrella. </span><span class="koboSpan" id="kobo.455.3">Velero provides ways to take backups and restore them later at the cluster level, Kubernetes namespace level, or for specific workloads based on their attached metadata. </span><span class="koboSpan" id="kobo.455.4">Velero can also take backups of the persistent volumes containing stateful application data and restore them when required. </span><span class="koboSpan" id="kobo.455.5">This is the tool that is used under the hood</span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.456.1"> of Tanzu Mission Control for backup and recovery features. </span><span class="koboSpan" id="kobo.456.2">We will cover this in detail in </span><a href=""><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.457.1">Chapter 9</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.458.1">, Managing and Controlling Kubernetes Clusters with Tanzu </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.459.1">Mission Control</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.461.1">ExternalDNS</span></h4>
<p><span class="koboSpan" id="kobo.462.1">TKG also supplies </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">ExternalDNS</span></strong><span class="koboSpan" id="kobo.464.1"> (</span><a href="https://github.com/kubernetes-sigs/external-dns"><span class="koboSpan" id="kobo.465.1">https://github.com/kubernetes-sigs/external-dns</span></a><span class="koboSpan" id="kobo.466.1">), an open source Kubernetes</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.467.1"> SIG project, as an extension</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.468.1"> package. </span><span class="koboSpan" id="kobo.468.2">ExternalDNS allows you to control the DNS records dynamically for the external-facing services deployed on the cluster using a Kubernetes resource definition file in a way that is agnostic to a DNS provider. </span><span class="koboSpan" id="kobo.468.3">The external services running on a Kubernetes cluster can get the required DNS record binding handled by ExternalDNS on a linked DNS server such as AWS Route53 or Google Cloud DNS. </span><span class="koboSpan" id="kobo.468.4">In a way, it provides a way to control external DNS configurations using Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">resource definitions.</span></span></p>
<h4><span class="koboSpan" id="kobo.470.1">cert-manager</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.471.1">cert-manager</span></strong><span class="koboSpan" id="kobo.472.1"> (</span><a href="https://cert-manager.io/"><span class="koboSpan" id="kobo.473.1">https://cert-manager.io/</span></a><span class="koboSpan" id="kobo.474.1">) is another CNCF open</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.475.1"> source project</span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.476.1"> that TKG includes</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.477.1"> as an extension to manage X.509 (identity) certificates used in a Kubernetes cluster. </span><span class="koboSpan" id="kobo.477.2">cert-manager obtains certificates from a variety of configured certificate issuers, ensures certificate validity, and tries to renew them </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">before expiry.</span></span></p>
<p><span class="koboSpan" id="kobo.479.1">Now that we have seen what components TKG contains, let’s learn about some of the important concepts of </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">this platform.</span></span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.481.1">Important concepts of Tanzu Kubernetes Grid</span></h2>
<p><span class="koboSpan" id="kobo.482.1">TKG is a distributed system with several moving parts. </span><span class="koboSpan" id="kobo.482.2">To understand how TKG works, we need to learn a few concepts of this system. </span><span class="koboSpan" id="kobo.482.3">Let’s take </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">a look.</span></span></p>
<h3><span class="koboSpan" id="kobo.484.1">Bootstrap cluster</span></h3>
<p><span class="koboSpan" id="kobo.485.1">As discussed earlier</span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.486.1"> in this chapter, TKG uses a kind cluster to deploy</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.487.1"> a TKG foundation on the selected infrastructure. </span><span class="koboSpan" id="kobo.487.2">This kind cluster is very small and runs in a Docker container in the operator’s workstation, which is typically a personal computer. </span><span class="koboSpan" id="kobo.487.3">This kind cluster contains the required machinery, including the Tanzu installation portal and other components that help bootstrap a TKG foundation. </span><span class="koboSpan" id="kobo.487.4">Because of this, this kind cluster is also known as a </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">bootstrap cluster.</span></span></p>
<h3><span class="koboSpan" id="kobo.489.1">Tanzu Kubernetes releases (TKrs)</span></h3>
<p><span class="koboSpan" id="kobo.490.1">A TKG deployment</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.491.1"> may support multiple different versions of Kubernetes. </span><span class="koboSpan" id="kobo.491.2">A TKr is a custom resource definition under TKG that contains a reference to one such Kubernetes version that TKG can deploy and manage. </span><span class="koboSpan" id="kobo.491.3">TKrs include components such as Antrea with its linked version definition for the given Kubernetes version. </span><span class="koboSpan" id="kobo.491.4">The management cluster of TKG runs a TKr controller that keeps checking the public registry for a new Kubernetes version availability. </span><span class="koboSpan" id="kobo.491.5">Once a new version is available, the TKr controller downloads the required artifacts on the TKG management cluster to make it available for use. </span><span class="koboSpan" id="kobo.491.6">This way, one TKG management cluster may deploy and manage multiple versions of Kubernetes clusters supported under that TKG version. </span><span class="koboSpan" id="kobo.491.7">This arrangement</span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.492.1"> provides flexibility to different teams wanting to run their applications on different Kubernetes versions that are still managed by the same TKG </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">control plane.</span></span></p>
<h3><span class="koboSpan" id="kobo.494.1">Management cluster</span></h3>
<p><span class="koboSpan" id="kobo.495.1">Every TKG foundation</span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.496.1"> has one management cluster. </span><span class="koboSpan" id="kobo.496.2">A management cluster</span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.497.1"> is nothing but a Kubernetes cluster running specific workloads used to life cycle other Kubernetes clusters. </span><span class="koboSpan" id="kobo.497.2">A TKG foundation and thus its management cluster is infrastructure specific. </span><span class="koboSpan" id="kobo.497.3">Because of that, we need one management cluster for vSphere, one for AWS, and one for Azure if we want to deploy TKG clusters on all the platforms. </span><span class="koboSpan" id="kobo.497.4">This is because a management cluster contains underlying cloud-specific Cluster API configuration. </span><span class="koboSpan" id="kobo.497.5">This way, a management cluster can create multiple Kubernetes workload clusters on the same cloud platform where it is deployed. </span><span class="koboSpan" id="kobo.497.6">In addition to creating, scaling, upgrading, and deleting a Kubernetes cluster, the management cluster also keeps track of the actual versus the desired state of the Kubernetes cluster nodes if it is configured to do so. </span><span class="koboSpan" id="kobo.497.7">The management cluster restarts or recreates an unhealthy or missing node from a cluster it manages. </span><span class="koboSpan" id="kobo.497.8">A management cluster is just a normal Kubernetes cluster and can also run any custom app, but it should only be used for its main purpose, which is to operate a large number of Kubernetes clusters. </span><span class="koboSpan" id="kobo.497.9">Its access</span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.498.1"> and permission should be very much restrictive to the TKG platform operations team considering the level of access it has over other Kubernetes clusters managed by it. </span><span class="koboSpan" id="kobo.498.2">The TKG platform operators may give limited access to a management cluster using Kubernetes namespaces under the management cluster. </span><span class="koboSpan" id="kobo.498.3">This way, different teams can use the same management cluster to life cycle their Kubernetes clusters linked with a specific namespace of the management cluster. </span><span class="koboSpan" id="kobo.498.4">In addition to the upstream Kubernetes components, a TKG management cluster has the following TKG-specific components deployed </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">into it:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.500.1">Cluster </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">API components</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.502.1">cert-manager</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.503.1">secretgen-controller</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.504.1">kapp-controller</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.505.1">tkr-controller</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.506.1">Workload cluster</span></h3>
<p><span class="koboSpan" id="kobo.507.1">A workload cluster</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.508.1"> is a normal Kubernetes</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.509.1"> cluster created by a management cluster. </span><span class="koboSpan" id="kobo.509.2">A workload cluster is where we deploy our apps. </span><span class="koboSpan" id="kobo.509.3">Depending on the organization’s practices and scale, different teams and their application environments may use separate workload clusters. </span><span class="koboSpan" id="kobo.509.4">The size in terms of the number of nodes in a workload cluster is only limited to the infrastructure availability. </span><span class="koboSpan" id="kobo.509.5">However, it is recommended to keep a cluster size as small as possible to reduce the blast radius if something goes wrong and for quicker maintenance time. </span><span class="koboSpan" id="kobo.509.6">TKG makes it very easy to manage many Kubernetes clusters. </span><span class="koboSpan" id="kobo.509.7">As we discussed previously, workload clusters under a management cluster may have different supported versions of Kubernetes based on the requirements of the teams </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">using them.</span></span></p>
<h3><span class="koboSpan" id="kobo.511.1">Node pool</span></h3>
<p><span class="koboSpan" id="kobo.512.1">A TKG cluster may have different types</span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.513.1"> of worker nodes</span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.514.1"> that have different configurations and resources attached to a cluster. </span><span class="koboSpan" id="kobo.514.2">Such heterogeneous node types allow different kinds of workloads to leverage them for specific resource requirements or just for isolation purposes. </span><span class="koboSpan" id="kobo.514.3">For example, a workload cluster may have</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.515.1"> some number of nodes with a consumable </span><strong class="bold"><span class="koboSpan" id="kobo.516.1">graphical processing unit</span></strong><span class="koboSpan" id="kobo.517.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.518.1">GPU</span></strong><span class="koboSpan" id="kobo.519.1">) that can be utilized by extremely compute-hungry machine learning workloads deployed on the cluster. </span><span class="koboSpan" id="kobo.519.2">We can add such different types of nodes to a workload cluster using </span><strong class="bold"><span class="koboSpan" id="kobo.520.1">node pools</span></strong><span class="koboSpan" id="kobo.521.1"> in TKG. </span><span class="koboSpan" id="kobo.521.2">Later, we can configure such nodes with taints and tolerations to only allow the workloads that need to use certain types of nodes to </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">be scheduled.</span></span></p>
<h3><span class="koboSpan" id="kobo.523.1">Deployment topologies</span></h3>
<p><span class="koboSpan" id="kobo.524.1">TKG supports two different deployment topologies</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.525.1"> for creating the management and </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">workload clusters:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.527.1">Dev Plan</span></strong><span class="koboSpan" id="kobo.528.1">: In this topology, TKG creates a single</span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.529.1"> control plane node and the required number of worker nodes. </span><span class="koboSpan" id="kobo.529.2">This plan is used for non-critical deployments that can tolerate the unavailability of the Kubernetes API server, etcd, and other control</span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.530.1"> plane functions. </span><span class="koboSpan" id="kobo.530.2">This topology requires fewer resources and is typically used for </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">lab environments.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.532.1">Prod Plan</span></strong><span class="koboSpan" id="kobo.533.1">: In this topology, TKG creates</span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.534.1"> three control plane nodes and fronts them with a load balancer to provide a highly available Kubernetes control plane. </span><span class="koboSpan" id="kobo.534.2">As the name suggests, it is used for clusters that will host critical workloads and may not tolerate any control plane downtime for </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">cluster operations.</span></span></li>
</ol>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.536.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.537.1">.3</span></em><span class="koboSpan" id="kobo.538.1"> shows how TKG works at a high level. </span><span class="koboSpan" id="kobo.538.2">As shown in this figure, an operator uses either the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">tanzu</span></strong><span class="koboSpan" id="kobo.540.1"> CLI or the TKG bootstrap UI to supply the required configuration for the foundation. </span><span class="koboSpan" id="kobo.540.2">Once the management cluster has been created, the operator can directly use it to create the required number of </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">workload clusters:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer115">
<span class="koboSpan" id="kobo.542.1"><img alt="Figure 7.3 – TKG layout" src="image/B18145_07_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.543.1">Figure 7.3 – TKG layout</span></p>
<p><span class="koboSpan" id="kobo.544.1">In the next section, we will learn how to create a TKG management cluster on AWS and understand the operation flow </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">in detail.</span></span></p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.546.1">Getting started with Tanzu Kubernetes Grid</span></h1>
<p><span class="koboSpan" id="kobo.547.1">TKG, being a multi-cloud</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.548.1"> solution, can be installed on a vSphere-based on-premises</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.549.1"> environment, or Microsoft Azure and </span><strong class="bold"><span class="koboSpan" id="kobo.550.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.551.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.552.1">AWS</span></strong><span class="koboSpan" id="kobo.553.1">)-based public cloud platforms. </span><span class="koboSpan" id="kobo.553.2">To keep this chapter to an acceptable length, we will only cover how to install and configure a TKG foundation on AWS. </span><span class="koboSpan" id="kobo.553.3">You may find additional TKG installation and configuration</span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.554.1"> details </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">here: </span></span><a href="https://docs.vmware.com/en/VMware-Tanzu-Kubernetes-Grid/1.5/vmware-tanzu-kubernetes-grid-15/GUID-mgmt-clusters-prepare-deployment.html"><span class="No-Break"><span class="koboSpan" id="kobo.556.1">https://docs.vmware.com/en/VMware-Tanzu-Kubernetes-Grid/1.5/vmware-tanzu-kubernetes-grid-15/GUID-mgmt-clusters-prepare-deployment.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.557.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.558.1">We will perform the following tasks in </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">this section:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.560.1">Configure the bootstrap machine – the operator workstation from where the installation will </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">be triggered</span></span></li>
<li><span class="koboSpan" id="kobo.562.1">Deploy the TKG </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">management cluster</span></span></li>
<li><span class="koboSpan" id="kobo.564.1">Create a TKG workload cluster using the </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">management cluster</span></span></li>
<li><span class="koboSpan" id="kobo.566.1">Obtain access to the </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">workload cluster</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.568.1">But before we do that, we need to ensure that the following prerequisites are met to complete </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">these tasks.</span></span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.570.1">Prerequisites</span></h2>
<p><span class="koboSpan" id="kobo.571.1">The following are the prerequisites</span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.572.1"> to follow the TKG installation instructions given in </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">this section:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.574.1">An AWS account with </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">the following:</span></span><ul><li><span class="koboSpan" id="kobo.576.1">An access key and an access </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">key secret</span></span></li><li><span class="koboSpan" id="kobo.578.1">An SSH key pair registered with the account for the region where TKG is </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">being installed</span></span></li><li><span class="koboSpan" id="kobo.580.1">Permission to create</span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.581.1"> a CloudFormation stack that defines </span><strong class="bold"><span class="koboSpan" id="kobo.582.1">Identity and Access Management</span></strong><span class="koboSpan" id="kobo.583.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.584.1">IAM</span></strong><span class="koboSpan" id="kobo.585.1">) resources and </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">their permissions</span></span></li><li><span class="koboSpan" id="kobo.587.1">A sufficient resource quota that’s allowed to create two </span><strong class="bold"><span class="koboSpan" id="kobo.588.1">Virtual Private Clouds</span></strong><span class="koboSpan" id="kobo.589.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.590.1">VPCs</span></strong><span class="koboSpan" id="kobo.591.1">), nine subnets (two internet-facing and one internal per availability zone) in the VPC, four EC2 security groups, two internet gateways, three NAT gateways, and three Elastic IP addresses in the selected region for </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">TKG deployment</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.593.1">A Linux or Mac workstation with </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">the following:</span></span><ul><li><span class="No-Break"><span class="koboSpan" id="kobo.595.1">Internet access</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.596.1">Command-line access</span></span></li><li><span class="koboSpan" id="kobo.597.1">Web </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">browser access</span></span></li><li><span class="koboSpan" id="kobo.599.1">Port </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">6443</span></strong><span class="koboSpan" id="kobo.601.1"> access to all the EC2 instances to access </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">Kubernetes APIs</span></span></li><li><span class="koboSpan" id="kobo.603.1">Docker Desktop installed and running with 6 </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">GB allocated</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.605.1">2-core CPU</span></span></li><li><span class="koboSpan" id="kobo.606.1">The kubectl CLI v1.22 </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">or higher</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.608.1">Access</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.609.1"> to a </span><strong class="bold"><span class="koboSpan" id="kobo.610.1">Network Time Protocol</span></strong><span class="koboSpan" id="kobo.611.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.612.1">NTP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">) server</span></span></li>
<li><span class="koboSpan" id="kobo.614.1">Access to </span><a href="https://my.vmware.com/"><span class="koboSpan" id="kobo.615.1">https://my.vmware.com/</span></a><span class="koboSpan" id="kobo.616.1"> with an account set up to download</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.617.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">required binaries</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.619.1">Let’s start with</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.620.1"> the first task, which is to prepare the bootstrap machine that will be used for this installation. </span><span class="koboSpan" id="kobo.620.2">We will need a few tools and environmental configurations before we begin </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">the installation.</span></span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.622.1">Configuring the bootstrap machine</span></h2>
<p><span class="koboSpan" id="kobo.623.1">The following sub-tasks prepare</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.624.1"> a bootstrap machine</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.625.1"> with the required tools and configuration for TKG setup </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">on AWS.</span></span></p>
<h3><span class="koboSpan" id="kobo.627.1">Installing Tanzu and the Kubectl CLI</span></h3>
<p><span class="koboSpan" id="kobo.628.1">Follow</span><a id="_idIndexMarker483"/> <span class="No-Break"><span class="koboSpan" id="kobo.629.1">these</span></span><span class="No-Break"><a id="_idIndexMarker484"/></span><span class="No-Break"><span class="koboSpan" id="kobo.630.1"> steps:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.631.1">Create a directory on your local machine where you will store the </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">required artifacts:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.633.1">
$ mkdir $HOME/tkg-154</span></pre></li>
<li><span class="koboSpan" id="kobo.634.1">Go to </span><a href="https://my.vmware.com/"><span class="koboSpan" id="kobo.635.1">https://my.vmware.com/</span></a><span class="koboSpan" id="kobo.636.1"> and log in using your My </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">VMware</span></span><span class="No-Break"><a id="_idIndexMarker485"/></span><span class="No-Break"><span class="koboSpan" id="kobo.638.1"> credentials.</span></span></li>
<li><span class="koboSpan" id="kobo.639.1">Go to </span><a href="https://customerconnect.vmware.com/downloads/details?downloadGroup=TKG-154&amp;productId=1162"><span class="koboSpan" id="kobo.640.1">https://customerconnect.vmware.com/downloads/details?downloadGroup=TKG-154&amp;productId=1162</span></a><span class="koboSpan" id="kobo.641.1"> to download the </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">required</span></span><span class="No-Break"><a id="_idIndexMarker486"/></span><span class="No-Break"><span class="koboSpan" id="kobo.643.1"> artifacts.</span></span></li>
<li><span class="koboSpan" id="kobo.644.1">Make sure that the selected version in the dropdown </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">is </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.646.1">1.5.4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer116">
<span class="koboSpan" id="kobo.648.1"><img alt="Figure 7.4 – Selecting a download version" src="image/B18145_07_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.649.1">Figure 7.4 – Selecting a download version</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.650.1">Under the </span><strong class="bold"><span class="koboSpan" id="kobo.651.1">Product Downloads</span></strong><span class="koboSpan" id="kobo.652.1"> tab, scroll to the </span><strong class="bold"><span class="koboSpan" id="kobo.653.1">VMware Tanzu CLI 1.5.4</span></strong><span class="koboSpan" id="kobo.654.1"> section and download the binary for your operating system. </span><span class="koboSpan" id="kobo.654.2">Note that the procedure followed in this chapter is being done on a macOS machine. </span><span class="koboSpan" id="kobo.654.3">While most of the commands listed in this chapter should work on the other platforms, there could be some </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">minor differences:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer117">
<span class="koboSpan" id="kobo.656.1"><img alt="Figure 7.5 – Downloading the appropriate Tanzu CLI" src="image/B18145_07_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.657.1">Figure 7.5 – Downloading the appropriate Tanzu CLI</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.658.1">Accept</span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.659.1"> the End User </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">License</span></span><span class="No-Break"><a id="_idIndexMarker488"/></span><span class="No-Break"><span class="koboSpan" id="kobo.661.1"> Agreement:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer118">
<span class="koboSpan" id="kobo.662.1"><img alt="Figure 7.6 – Accepting the End User License Agreement" src="image/B18145_07_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.663.1">Figure 7.6 – Accepting the End User License Agreement</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.664.1">Download the binary into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">$HOME/tkg-154</span></strong><span class="koboSpan" id="kobo.666.1"> directory that we created in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.667.1">step 1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.669.1">Now, on the same page when you downloaded the binaries, go to the </span><strong class="bold"><span class="koboSpan" id="kobo.670.1">Kubectl 1.22.9 for VMware Tanzu Kubernetes Grid </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.671.1">1.5.4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.672.1"> section:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer119">
<span class="koboSpan" id="kobo.673.1"><img alt="Figure 7.7 – Downloading the appropriate Kubectl CLI" src="image/B18145_07_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.674.1">Figure 7.7 – Downloading the appropriate Kubectl CLI</span></p>
<ol>
<li value="9"><span class="koboSpan" id="kobo.675.1">Download the binary into the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">$</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">HOME/tkg-154</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.678.1"> directory.</span></span></li>
<li><span class="koboSpan" id="kobo.679.1">Go into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">$HOME/tkg-154</span></strong><span class="koboSpan" id="kobo.681.1"> directory and extract</span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.682.1"> the CLI binaries you downloaded</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.683.1"> previously. </span><span class="koboSpan" id="kobo.683.2">Run the following commands to </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">do this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.685.1">
$ cd $HOME/tkg-154</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.686.1">
$ tar -xvf tanzu-cli-bundle-darwin-amd64.tar.gz</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.687.1">
$ gunzip -dvf kubectl-mac-v1.22.9+vmware.1.gz</span></pre></li>
<li><span class="koboSpan" id="kobo.688.1">Install the Tanzu CLI on you </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">local system:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.690.1">
$ sudo install cli/core/v0.11.6/tanzu-core-darwin_amd64 /usr/local/bin/tanzu</span></pre></li>
<li><span class="koboSpan" id="kobo.691.1">Verify the installation by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">following command:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.693.1">
$ tanzu version</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.694.1">You should see version 0.11.6 in </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">the output.</span></span></p>
<ol>
<li value="13"><span class="koboSpan" id="kobo.696.1">Initialize the </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">Tanzu CLI:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.698.1">
$ tanzu init</span></pre></li>
<li><span class="koboSpan" id="kobo.699.1">Clean up any pre-existing Tanzu plugins for a </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">clean start:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.701.1">
$ tanzu plugin clean</span></pre></li>
<li><span class="koboSpan" id="kobo.702.1">Make sure you are under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">$HOME/tkg-154</span></strong><span class="koboSpan" id="kobo.704.1"> directory, which contains the extracted </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">cli</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.706.1"> directory:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.707.1">
$ cd $HOME/tkg-154/</span></pre></li>
<li><span class="koboSpan" id="kobo.708.1">Run the following command to install all the required plugins for this </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">TKG release:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.710.1">
$ tanzu plugin sync</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.711.1">You should</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.712.1"> be able to see the following output</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.713.1"> for the </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">command’s execution:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.715.1">
Checking for required plugins...
</span><span class="koboSpan" id="kobo.715.2">Installing plugin 'cluster:v0.11.6'
Installing plugin 'kubernetes-release:v0.11.6'
Installing plugin 'login:v0.11.6'
Installing plugin 'management-cluster:v0.11.6'
Installing plugin 'package:v0.11.6'
Installing plugin 'pinniped-auth:v0.11.6'
Installing plugin 'secret:v0.11.6'
Successfully installed all required plugins
  Done</span></pre>
<ol>
<li value="17"><span class="koboSpan" id="kobo.716.1">Verify the plugin’s installation status by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">following command:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.718.1">
$ tanzu plugin list</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.719.1">You should be able to see all the plugins listed, along with their versions and statuses, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer120">
<span class="koboSpan" id="kobo.721.1"><img alt="Figure 7.8 – Installed TKG plugin list" src="image/B18145_07_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.722.1">Figure 7.8 – Installed TKG plugin list</span></p>
<p><span class="koboSpan" id="kobo.723.1">Now, let’s install the </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">Kubectl CLI.</span></span></p>
<ol>
<li value="18"><span class="koboSpan" id="kobo.725.1">Run the following</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.726.1"> commands from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">$HOME/tkg-154</span></strong><span class="koboSpan" id="kobo.728.1"> directory, which is where </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.729.1">we downloaded and extracted the </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">Kubectl CLI:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.731.1">
$ chmod ugo+x kubectl-mac-v1.22.9+vmware.1</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.732.1">
$ sudo install kubectl-mac-v1.22.9+vmware.1 /usr/local/bin/kubectl</span></pre></li>
<li><span class="koboSpan" id="kobo.733.1">Verify the installation by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">kubectl version</span></strong><span class="koboSpan" id="kobo.735.1"> command. </span><span class="koboSpan" id="kobo.735.2">You should see the client version </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">as v1.22.9+vmware.1.</span></span></li>
</ol>
<h3><span class="koboSpan" id="kobo.737.1">Installing Carvel tools</span></h3>
<p><span class="koboSpan" id="kobo.738.1">As we discussed</span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.739.1"> in the previous section, TKG uses the Carvel toolkit for its packaging and installation. </span><span class="koboSpan" id="kobo.739.2">For that reason, we will need some of the Carvel tool’s CLI binaries installed in the bootstrap machine. </span><span class="koboSpan" id="kobo.739.3">The Tanzu CLI bundle that we previously downloaded and extracted contains all these tools. </span><span class="koboSpan" id="kobo.739.4">The following steps describe the procedure to </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">install them:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.741.1">Go to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">cli</span></strong><span class="koboSpan" id="kobo.743.1"> directory </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">under </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">$HOME/tkg-154</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.747.1">
$ cd $HOME/tkg-154/cli</span></pre></li>
<li><span class="koboSpan" id="kobo.748.1">Install </span><strong class="bold"><span class="koboSpan" id="kobo.749.1">ytt</span></strong><span class="koboSpan" id="kobo.750.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">following commands:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.752.1">
$ gunzip ytt-darwin-amd64-v0.37.0+vmware.1.gz</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.753.1">
$ chmod ugo+x ytt-darwin-amd64-v0.37.0+vmware.1</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.754.1">
$ mv ./ytt-darwin-amd64-v0.37.0+vmware.1 /usr/local/bin/ytt</span></pre></li>
<li><span class="koboSpan" id="kobo.755.1">Verify the </span><strong class="bold"><span class="koboSpan" id="kobo.756.1">ytt</span></strong><span class="koboSpan" id="kobo.757.1"> installation by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">ytt --</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">version</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.760.1"> command.</span></span></li>
<li><span class="koboSpan" id="kobo.761.1">Install </span><strong class="bold"><span class="koboSpan" id="kobo.762.1">kapp</span></strong><span class="koboSpan" id="kobo.763.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">following commands:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.765.1">
$ gunzip kapp-darwin-amd64-v0.42.0+vmware.2.gz</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.766.1">
$ chmod ugo+x kapp-darwin-amd64-v0.42.0+vmware.2</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.767.1">
$ mv ./kapp-darwin-amd64-v0.42.0+vmware.2 /usr/local/bin/kapp</span></pre></li>
<li><span class="koboSpan" id="kobo.768.1">Verify the </span><strong class="bold"><span class="koboSpan" id="kobo.769.1">kapp</span></strong><span class="koboSpan" id="kobo.770.1"> installation by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">kapp --</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">version</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.773.1"> command.</span></span></li>
<li><span class="koboSpan" id="kobo.774.1">Install </span><strong class="bold"><span class="koboSpan" id="kobo.775.1">kbld</span></strong><span class="koboSpan" id="kobo.776.1"> with</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.777.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">following commands:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.779.1">
$ gunzip kbld-darwin-amd64-v0.31.0+vmware.1.gz</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.780.1">
$ chmod ugo+x kbld-darwin-amd64-v0.31.0+vmware.1</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.781.1">
$ mv ./kbld-darwin-amd64-v0.31.0+vmware.1 /usr/local/bin/kbld</span></pre></li>
<li><span class="koboSpan" id="kobo.782.1">Verify the </span><strong class="bold"><span class="koboSpan" id="kobo.783.1">kbld</span></strong><span class="koboSpan" id="kobo.784.1"> installation by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">kbld --</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">version</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.787.1"> command.</span></span></li>
<li><span class="koboSpan" id="kobo.788.1">Install </span><strong class="bold"><span class="koboSpan" id="kobo.789.1">imgpkg</span></strong><span class="koboSpan" id="kobo.790.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">following commands:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.792.1">
$ gunzip imgpkg-darwin-amd64-v0.22.0+vmware.1.gz</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.793.1">
$ chmod ugo+x imgpkg-darwin-amd64-v0.22.0+vmware.1</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.794.1">
$ mv ./imgpkg-darwin-amd64-v0.22.0+vmware.1 /usr/local/bin/imgpkg</span></pre></li>
<li><span class="koboSpan" id="kobo.795.1">Verify the </span><strong class="bold"><span class="koboSpan" id="kobo.796.1">imgpkg</span></strong><span class="koboSpan" id="kobo.797.1"> installation by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">imgpkg --</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">version</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.800.1"> command.</span></span></li>
</ol>
<h3><span class="koboSpan" id="kobo.801.1">Installing AWS-specific tools</span></h3>
<p><span class="koboSpan" id="kobo.802.1">Deploying a TKG foundation</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.803.1"> on the AWS platform requires the </span><strong class="bold"><span class="koboSpan" id="kobo.804.1">aws</span></strong><span class="koboSpan" id="kobo.805.1"> CLI to be installed on the bootstrap machine. </span><span class="koboSpan" id="kobo.805.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">configure this:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.807.1">Install the </span><strong class="bold"><span class="koboSpan" id="kobo.808.1">aws</span></strong><span class="koboSpan" id="kobo.809.1"> CLI using the instructions</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.810.1"> provided </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">at </span></span><a href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html"><span class="No-Break"><span class="koboSpan" id="kobo.812.1">https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.813.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.814.1">Verify the installation of the </span><strong class="bold"><span class="koboSpan" id="kobo.815.1">aws</span></strong><span class="koboSpan" id="kobo.816.1"> CLI by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">following command:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.818.1">
$ aws –version</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.819.1">You should be able to see the CLI version listed, as shown in the following output. </span><span class="koboSpan" id="kobo.819.2">The version could be different in your case, depending on when it is installed, but it should </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">be v2.x:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.821.1">
aws-cli/2.5.3 Python/3.9.11 Darwin/21.4.0 exe/x86_64 prompt/off</span></pre>
<ol>
<li value="3"><span class="koboSpan" id="kobo.822.1">Run the following command</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.823.1"> to configure the access profile for your AWS account to be used for this installation with the previously defined permissions </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">and quotas:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.825.1">
$ aws configure –profile tkg</span></pre></li>
<li><span class="koboSpan" id="kobo.826.1">Supply the values of the access key, secret access key, region, and command output format, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.828.1">
AWS Access Key ID [None]: ********************</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.829.1">
AWS Secret Access Key [None]: ****************************************</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.830.1">
Default region name [None]: us-east-1</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.831.1">
Default output format [None]: text</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.832.1">Here, you may replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">us-east-1</span></strong><span class="koboSpan" id="kobo.834.1"> with any other AWS region of your choice with the previously listed </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">prerequisites fulfilled.</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.836.1">Run the following command to ensure you can see the existing SSH key pair in the region as it was listed in </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">the prerequisites:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.838.1">
$ aws ec2 describe-key-pairs --profile tkg</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.839.1">This command’s output should show at least one key </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">pair listed.</span></span></p>
<p><span class="koboSpan" id="kobo.841.1">We now have all the required tools configured in the bootstrap machine to begin installing the TKG management cluster. </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">Let’s begin.</span></span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.843.1">Installing the management cluster</span></h2>
<p><span class="koboSpan" id="kobo.844.1">In this section, we will </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.845.1">use the Tanzu</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.846.1"> installer UI to deploy the management cluster on the configured </span><span class="No-Break"><span class="koboSpan" id="kobo.847.1">AWS account.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.848.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.849.1">By default, the upstream Kubernetes distribution does not come with user authentication capabilities and allows the user to have admin-level access. </span><span class="koboSpan" id="kobo.849.2">To fill this gap, TKG comes with Pinniped to integrate an external LDAP or OIDC identity provider. </span><span class="koboSpan" id="kobo.849.3">To minimize installation prerequisites and complexity, we will not use such an integration, which requires a pre-existing LDAP or OIDC setup access. </span><span class="koboSpan" id="kobo.849.4">A real-life TKG cluster should never be configured without such integration with an external identity provider. </span><span class="koboSpan" id="kobo.849.5">You can learn more</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.850.1"> about this topic </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">here: </span></span><a href="https://docs.vmware.com/en/VMware-Tanzu-Kubernetes-Grid/1.5/vmware-tanzu-kubernetes-grid-15/GUID-iam-configure-id-mgmt.html"><span class="No-Break"><span class="koboSpan" id="kobo.852.1">https://docs.vmware.com/en/VMware-Tanzu-Kubernetes-Grid/1.5/vmware-tanzu-kubernetes-grid-15/GUID-iam-configure-id-mgmt.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.853.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.854.1">Additionally, despite aiming for minimal complexity and an infrastructure footprint, following this </span><strong class="bold"><span class="koboSpan" id="kobo.855.1">TKG configuration on AWS will incur cloud service usage charges in your AWS account</span></strong><span class="koboSpan" id="kobo.856.1"> as it will use the EC2 instance types that are not qualified for the free-tier credits, along with some other chargeable services such as Elastic IP, NAT gateways, EBS volumes, Elastic Load Balancers, and a few others. </span><span class="koboSpan" id="kobo.856.2">If you plan to follow this guide to install TKG on AWS, it is recommended that you also clean up the resources using the procedure described later in this chapter, followed by a manual inspection to verify the removal of all </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">provisioned resources.</span></span></p>
<p><span class="koboSpan" id="kobo.858.1">The following steps outline the </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">installation procedure:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.860.1">Ensure the local Docker daemon is running to deploy and run containers on the </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">bootstrap machine.</span></span></li>
<li><span class="koboSpan" id="kobo.862.1">Run the following command to start the installer UI in the default browser window of the bootstrap workstation. </span><span class="koboSpan" id="kobo.862.2">This UI supports Chrome, Safari, Firefox, Internet Explorer, and Edge, along with their considerably </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">newer versions:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.864.1">
$ tanzu mc create --ui</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.865.1">This command should</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.866.1"> automatically open the browser window with the UI running. </span><span class="koboSpan" id="kobo.866.2">Otherwise, it can be accessed </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">http://127.0.0.1:8080/</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.870.1">Click on the </span><strong class="bold"><span class="koboSpan" id="kobo.871.1">DEPLOY</span></strong><span class="koboSpan" id="kobo.872.1"> button under </span><strong class="bold"><span class="koboSpan" id="kobo.873.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.874.1">, as highlighted in the </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">following screenshot:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer121">
<span class="koboSpan" id="kobo.876.1"><img alt="Figure 7.9 – Selecting Amazon Web Services for deployment" src="image/B18145_07_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.877.1">Figure 7.9 – Selecting Amazon Web Services for deployment</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.878.1">Select the necessary AWS account details by following these sub-steps; these are highlighted in the </span><span class="No-Break"><span class="koboSpan" id="kobo.879.1">following screenshot:</span></span><ol><li><span class="koboSpan" id="kobo.880.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.881.1">AWS CREDENTIAL TYPE</span></strong><span class="koboSpan" id="kobo.882.1"> to </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.883.1">Credential Profile</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">.</span></span></li><li><span class="koboSpan" id="kobo.885.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.886.1">tkg</span></strong><span class="koboSpan" id="kobo.887.1"> from the </span><strong class="bold"><span class="koboSpan" id="kobo.888.1">AWS CREDENTIAL PROFILE</span></strong><span class="koboSpan" id="kobo.889.1"> dropdown and its associated </span><strong class="bold"><span class="koboSpan" id="kobo.890.1">REGION</span></strong><span class="koboSpan" id="kobo.891.1"> that we configured during the </span><strong class="bold"><span class="koboSpan" id="kobo.892.1">aws</span></strong><span class="koboSpan" id="kobo.893.1"> CLI setup earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">this chapter.</span></span></li><li><span class="koboSpan" id="kobo.895.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.896.1">CONNECT</span></strong><span class="koboSpan" id="kobo.897.1"> button to ensure the UI can connect to the select AWS account using the previously </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">created configuration.</span></span></li><li><span class="koboSpan" id="kobo.899.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.900.1">NEXT</span></strong><span class="koboSpan" id="kobo.901.1"> button to move to the next </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">configuration section:</span></span></li></ol></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer122">
<span class="koboSpan" id="kobo.903.1"><img alt="Figure 7.10 – Selecting an AWS account for the installation" src="image/B18145_07_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.904.1">Figure 7.10 – Selecting an AWS account for the installation</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.905.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.906.1">NEXT</span></strong><span class="koboSpan" id="kobo.907.1"> button to choose </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.908.1">the default VPC configuration, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">following screenshot:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer123">
<span class="koboSpan" id="kobo.910.1"><img alt="Figure 7.11 – Choosing the default VPC configuration" src="image/B18145_07_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.911.1">Figure 7.11 – Choosing the default VPC configuration</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.912.1">Set the management cluster deployment plan to </span><strong class="bold"><span class="koboSpan" id="kobo.913.1">Development</span></strong><span class="koboSpan" id="kobo.914.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.915.1">INSTANCE TYPE</span></strong><span class="koboSpan" id="kobo.916.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.917.1">t3.large</span></strong><span class="koboSpan" id="kobo.918.1">. </span><span class="koboSpan" id="kobo.918.2">This instance type has 2 vCPUs and 8 GiB memory, which is just good enough for a </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">lab-like setup:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer124">
<span class="koboSpan" id="kobo.920.1"><img alt="Figure 7.12 – Selecting the management cluster’s deployment plan and instance type" src="image/B18145_07_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.921.1">Figure 7.12 – Selecting the management cluster’s deployment plan and instance type</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.922.1">Enter other details of the management cluster, as listed in the following sub-steps and shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">following screenshot:</span></span><ol><li><span class="koboSpan" id="kobo.924.1">Enter a short name under </span><strong class="bold"><span class="koboSpan" id="kobo.925.1">MANAGEMENT CLUSTER NAME</span></strong><span class="koboSpan" id="kobo.926.1"> – that </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">is, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">tkg-aws-mgmt-cluster</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">.</span></span></li><li><span class="koboSpan" id="kobo.930.1">Enter the name of the SSH key-pair that’s available to the account you obtained in </span><em class="italic"><span class="koboSpan" id="kobo.931.1">step 5</span></em><span class="koboSpan" id="kobo.932.1"> of the </span><strong class="bold"><span class="koboSpan" id="kobo.933.1">aws</span></strong><span class="koboSpan" id="kobo.934.1"> CLI configuration under </span><strong class="bold"><span class="koboSpan" id="kobo.935.1">EC2 </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.936.1">KEY PAIR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">.</span></span></li><li><span class="koboSpan" id="kobo.938.1">Leave the default selection as-is for the </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">checkbox options.</span></span></li><li><span class="koboSpan" id="kobo.940.1">Select one of the availability</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.941.1"> zones from the </span><strong class="bold"><span class="koboSpan" id="kobo.942.1">AVAILABILITY ZONE 1</span></strong><span class="koboSpan" id="kobo.943.1"> dropdown for the selected region to deploy the management cluster into. </span><span class="koboSpan" id="kobo.943.2">For the </span><strong class="bold"><span class="koboSpan" id="kobo.944.1">Production</span></strong><span class="koboSpan" id="kobo.945.1"> deployment plan, we need to select three availability zones for the three control plane nodes of the </span><span class="No-Break"><span class="koboSpan" id="kobo.946.1">management cluster.</span></span></li><li><span class="koboSpan" id="kobo.947.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.948.1">t3.large</span></strong><span class="koboSpan" id="kobo.949.1"> as the worker node instance type from the </span><strong class="bold"><span class="koboSpan" id="kobo.950.1">AZ1 WORKER NODE INSTANCE </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.951.1">TYPE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.952.1"> dropdown.</span></span></li><li><span class="koboSpan" id="kobo.953.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.954.1">NEXT</span></strong><span class="koboSpan" id="kobo.955.1"> button to </span><span class="No-Break"><span class="koboSpan" id="kobo.956.1">move on:</span></span></li></ol></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer125">
<span class="koboSpan" id="kobo.957.1"><img alt="Figure 7.13 – Entering the management cluster’s details" src="image/B18145_07_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.958.1">Figure 7.13 – Entering the management cluster’s details</span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.959.1">Optionally, enter management cluster metadata and click the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.960.1">NEXT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.961.1"> button:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer126">
<span class="koboSpan" id="kobo.962.1"><img alt="Figure 7.14 – Entering the management cluster’s metadata" src="image/B18145_07_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.963.1">Figure 7.14 – Entering the management cluster’s metadata</span></p>
<ol>
<li value="9"><span class="koboSpan" id="kobo.964.1">Leave the default Kubernetes</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.965.1"> container network configuration as-is and click the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.966.1">NEXT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.967.1"> button:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer127">
<span class="koboSpan" id="kobo.968.1"><img alt="Figure 7.15 – Leaving the default Kubernetes network configuration as-is" src="image/B18145_07_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.969.1">Figure 7.15 – Leaving the default Kubernetes network configuration as-is</span></p>
<ol>
<li value="10"><span class="koboSpan" id="kobo.970.1">Disable the identity management settings and click the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.971.1">NEXT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.972.1"> button:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer128">
<span class="koboSpan" id="kobo.973.1"><img alt="Figure 7.16 – Disabling identity management settings" src="image/B18145_07_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.974.1">Figure 7.16 – Disabling identity management settings</span></p>
<ol>
<li value="11"><span class="koboSpan" id="kobo.975.1">Select the management</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.976.1"> cluster’s operating system image, as highlighted in the screenshot, and click the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.977.1">NEXT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.978.1"> button:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer129">
<span class="koboSpan" id="kobo.979.1"><img alt="Figure 7.17 – Selecting the management cluster’s operating system" src="image/B18145_07_17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.980.1">Figure 7.17 – Selecting the management cluster’s operating system</span></p>
<ol>
<li value="12"><span class="koboSpan" id="kobo.981.1">Optionally, choose</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.982.1"> to participate in VMware’s </span><strong class="bold"><span class="koboSpan" id="kobo.983.1">Customer Experience Improvement Program</span></strong><span class="koboSpan" id="kobo.984.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.985.1">CEIP</span></strong><span class="koboSpan" id="kobo.986.1">) and click the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.987.1">NEXT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.988.1"> button:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer130">
<span class="koboSpan" id="kobo.989.1"><img alt="Figure 7.18 – Choosing to participate in the Customer Experience Improvement Program" src="image/B18145_07_18.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.990.1">Figure 7.18 – Choosing to participate in the Customer Experience Improvement Program</span></p>
<ol>
<li value="13"><span class="koboSpan" id="kobo.991.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.992.1">REVIEW CONFIGURATION</span></strong><span class="koboSpan" id="kobo.993.1"> button to verify the inputs before triggering the management cluster creation </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">on AWS:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer131">
<span class="koboSpan" id="kobo.995.1"><img alt="Figure 7.19 – Opening the configuration summary for review" src="image/B18145_07_19.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.996.1">Figure 7.19 – Opening the configuration summary for review</span></p>
<ol>
<li value="14"><span class="koboSpan" id="kobo.997.1">The following screenshot</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.998.1"> shows the bottom of the verification summary page. </span><span class="koboSpan" id="kobo.998.2">The command that’s displayed can be used in the future to trigger the same deployment again using the Tanzu CLI. </span><span class="koboSpan" id="kobo.998.3">The </span><strong class="bold"><span class="koboSpan" id="kobo.999.1">EXPORT CONFIGURATION</span></strong><span class="koboSpan" id="kobo.1000.1"> link at the bottom-right corner allows us to export this configuration in a file that can be used as a reference to deploy other management clusters on AWS with the required modifications. </span><span class="koboSpan" id="kobo.1000.2">Finally, click the </span><strong class="bold"><span class="koboSpan" id="kobo.1001.1">DEPLOY MANAGEMENT CLUSTER</span></strong><span class="koboSpan" id="kobo.1002.1"> button to trigger </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">the deployment:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer132">
<span class="koboSpan" id="kobo.1004.1"><img alt="Figure 7.20 – Triggering the management cluster’s deployment" src="image/B18145_07_20.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1005.1">Figure 7.20 – Triggering the management cluster’s deployment</span></p>
<ol>
<li value="15"><span class="koboSpan" id="kobo.1006.1">You will see various deployment logs and their installation statuses, as shown in the following screenshot. </span><span class="koboSpan" id="kobo.1006.2">As you can see in the logs, the Cluster API is creating the required infrastructure component to deploy the management cluster </span><span class="No-Break"><span class="koboSpan" id="kobo.1007.1">on AWS:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer133">
<span class="koboSpan" id="kobo.1008.1"><img alt="Figure 7.21 – Deployment status with logs" src="image/B18145_07_21.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1009.1">Figure 7.21 – Deployment status with logs</span></p>
<ol>
<li value="16"><span class="koboSpan" id="kobo.1010.1">The installation</span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.1011.1"> should ideally be completed in about 10 to 15 minutes and you should see a success message, as shown in the following screenshot. </span><span class="koboSpan" id="kobo.1011.2">As highlighted in this screenshot, the logs also highlight how to access the management cluster from the bootstrap machine to perform different TKG operations. </span><span class="koboSpan" id="kobo.1011.3">You should also be able to see these logs on the command line from where you fired the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">tanzu mc create --ui</span></strong><span class="koboSpan" id="kobo.1013.1"> command, which brought up the installation </span><span class="No-Break"><span class="koboSpan" id="kobo.1014.1">browser window:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer134">
<span class="koboSpan" id="kobo.1015.1"><img alt="Figure 7.22 – Successful management cluster installation" src="image/B18145_07_22.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1016.1">Figure 7.22 – Successful management cluster installation</span></p>
<p><span class="koboSpan" id="kobo.1017.1">Now that we have finished installing the management cluster, let’s learn how to use it to create our first TKG </span><span class="No-Break"><span class="koboSpan" id="kobo.1018.1">workload cluster.</span></span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.1019.1">Creating a workload cluster</span></h2>
<p><span class="koboSpan" id="kobo.1020.1">The following steps outline the procedure</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.1021.1"> to access the newly created TKG management cluster using the bootstrap machine</span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.1022.1"> from where we triggered the management cluster installation. </span><span class="koboSpan" id="kobo.1022.2">As a part of the installation steps, TKG adds the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">kubeconfig</span></strong><span class="koboSpan" id="kobo.1024.1"> details to the bootstrap machine to allow administrator-level access to the management cluster and hence the Tanzu CLI pointing to the management cluster. </span><span class="koboSpan" id="kobo.1024.2">Let’s use the management cluster and the Tanzu CLI to create our first workload cluster. </span><span class="koboSpan" id="kobo.1024.3">The following steps will be performed on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">bootstrap machine:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1026.1">Run the following command to set the kubectl context pointing to the newly created TKG </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">management cluster:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1028.1">
$ kubectl config use-context tkg-aws-mgmt-cluster-admin@tkg-aws-mgmt-cluster</span></pre></li>
<li><span class="koboSpan" id="kobo.1029.1">Run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">tanzu mc get</span></strong><span class="koboSpan" id="kobo.1031.1"> command to view the details of the management cluster. </span><span class="koboSpan" id="kobo.1031.2">The command will show that the management cluster has one control plane and one worker </span><span class="No-Break"><span class="koboSpan" id="kobo.1032.1">node created:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer135">
<span class="koboSpan" id="kobo.1033.1"><img alt="Figure 7.23 – Management cluster details" src="image/B18145_07_23.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1034.1">Figure 7.23 – Management cluster details</span></p>
<p><span class="koboSpan" id="kobo.1035.1">To create a workload cluster, we need to supply the workload cluster configuration file to the management cluster. </span><span class="koboSpan" id="kobo.1035.2">It contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.1036.1">following details:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">Cluster name</span></span></li>
<li><span class="koboSpan" id="kobo.1038.1">Cluster deployment plan (Development </span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">or Production)</span></span></li>
<li><span class="koboSpan" id="kobo.1040.1">Worker </span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1">node count</span></span></li>
<li><span class="koboSpan" id="kobo.1042.1">Worker node </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">EC2 type</span></span></li>
<li><span class="koboSpan" id="kobo.1044.1">AWS-specific configurations such as region, AZ, network, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">SSH key</span></span></li>
<li><span class="koboSpan" id="kobo.1046.1">Node </span><span class="No-Break"><span class="koboSpan" id="kobo.1047.1">operating system</span></span></li>
<li><span class="koboSpan" id="kobo.1048.1">Node health </span><span class="No-Break"><span class="koboSpan" id="kobo.1049.1">check configuration</span></span></li>
<li><span class="koboSpan" id="kobo.1050.1">Node-level </span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">auto-scaling configuration</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1052.1">We do not need</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.1053.1"> to include all the attributes in the configuration file and may specify only the required</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.1054.1"> attributes. </span><span class="koboSpan" id="kobo.1054.2">For a broader list of attributes for the configuration file, </span><span class="No-Break"><span class="koboSpan" id="kobo.1055.1">visit </span></span><a href="https://docs.vmware.com/en/VMware-Tanzu-Kubernetes-Grid/1.5/vmware-tanzu-kubernetes-grid-15/GUID-tanzu-k8s-clusters-aws.html#tanzu-kubernetes-cluster-template-0"><span class="No-Break"><span class="koboSpan" id="kobo.1056.1">https://docs.vmware.com/en/VMware-Tanzu-Kubernetes-Grid/1.5/vmware-tanzu-kubernetes-grid-15/GUID-tanzu-k8s-clusters-aws.html#tanzu-kubernetes-cluster-template-0</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1058.1">We will download a preconfigured file from this book’s GitHub repository and use it to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">workload cluster.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1060.1">Copy the workload cluster configuration file into the bootstrap machine using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">following command:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1062.1">
$ curl https://raw.githubusercontent.com/PacktPublishing/DevSecOps-in-Practice-with-VMware-Tanzu/main/chapter-07/tkg-workload-cluster-config.yaml -o $HOME/tkg-154/tkg-workload-cluster-config.yaml</span></pre></li>
<li><span class="koboSpan" id="kobo.1063.1">The config file should be available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">$HOME/tkg-154/</span></strong><span class="koboSpan" id="kobo.1065.1"> directory and be called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">tkg-workload-cluster-config.yaml</span></strong><span class="koboSpan" id="kobo.1067.1">. </span><span class="koboSpan" id="kobo.1067.2">Open the file in your choice of editor and update the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1068.1">parameter values:</span></span><ol><li><span class="koboSpan" id="kobo.1069.1">Update </span><strong class="bold"><span class="koboSpan" id="kobo.1070.1">AWS_NODE_AZ</span></strong><span class="koboSpan" id="kobo.1071.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1072.1">AWS_NODE_AZ_1</span></strong><span class="koboSpan" id="kobo.1073.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1074.1">AWS_NODE_AZ_2</span></strong><span class="koboSpan" id="kobo.1075.1"> based on the selected region if you have used any AWS region other </span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1">than </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1077.1">us-east-1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">.</span></span></li><li><span class="koboSpan" id="kobo.1079.1">Update </span><strong class="bold"><span class="koboSpan" id="kobo.1080.1">AWS_REGION</span></strong><span class="koboSpan" id="kobo.1081.1"> as per your </span><strong class="bold"><span class="koboSpan" id="kobo.1082.1">AWS_PROFILE</span></strong><span class="koboSpan" id="kobo.1083.1"> configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.1084.1">if applicable.</span></span></li><li><span class="koboSpan" id="kobo.1085.1">Update </span><strong class="bold"><span class="koboSpan" id="kobo.1086.1">AWS_SSH_KEY_NAME</span></strong><span class="koboSpan" id="kobo.1087.1"> to use the SSH key in your AWS account in the selected region. </span><span class="koboSpan" id="kobo.1087.2">This is </span><span class="No-Break"><span class="koboSpan" id="kobo.1088.1">a must-change.</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.1089.1">Run the following</span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.1090.1"> command to create the workload cluster using the configuration file we prepared in the previous step. </span><span class="koboSpan" id="kobo.1090.2">Here, we are creating the cluster with Kubernetes v1.21.11 using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">--tkr</span></strong><span class="koboSpan" id="kobo.1092.1"> option so that we can learn how to upgrade the cluster later </span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1">to v.1.22.9:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1094.1">
$ tanzu cluster create --file $HOME/tkg-154/tkg-workload-cluster-config.yaml --tkr v1.21.11---vmware.1-tkg.3</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1095.1">The workload cluster should be created in about 10 to 15 minutes if all the configuration changes are </span><span class="No-Break"><span class="koboSpan" id="kobo.1096.1">done correctly.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.1097.1">Verify the cluster’s creation status using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1098.1">following command:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1099.1">
$ tanzu cluster list</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1100.1">You should see that the cluster is running, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1101.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer136">
<span class="koboSpan" id="kobo.1102.1"><img alt="Figure 7.24 – Verifying the workload cluster’s creation" src="image/B18145_07_24.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1103.1">Figure 7.24 – Verifying the workload cluster’s creation</span></p>
<p><span class="koboSpan" id="kobo.1104.1">With that, the TKG workload cluster has been created. </span><span class="koboSpan" id="kobo.1104.2">Now, let’s access the </span><span class="No-Break"><span class="koboSpan" id="kobo.1105.1">workload cluster.</span></span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.1106.1">Run the following command to obtain </span><strong class="source-inline"><span class="koboSpan" id="kobo.1107.1">kubeconfig</span></strong><span class="koboSpan" id="kobo.1108.1"> for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1109.1">workload cluster:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1110.1">
$ tanzu cluster kubeconfig get tkg-aws-workload-cluster  --admin</span></pre></li>
<li><span class="koboSpan" id="kobo.1111.1">Run the following command to switch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">kubectl</span></strong><span class="koboSpan" id="kobo.1113.1"> context so that it points to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1114.1">workload cluster:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1115.1">
$ kubectl config use-context tkg-aws-workload-cluster-admin@tkg-aws-workload-cluster</span></pre></li>
<li><span class="koboSpan" id="kobo.1116.1">Run the following command to list the nodes of the workload cluster to </span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">ensure connectivity:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1118.1">
$ kubectl get nodes</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1119.1">You should be able</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.1120.1"> to see the list of Kubernetes nodes, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer137">
<span class="koboSpan" id="kobo.1122.1"><img alt="Figure 7.25 – Verifying the workload cluster’s connectivity" src="image/B18145_07_25.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1123.1">Figure 7.25 – Verifying the workload cluster’s connectivity</span></p>
<p><span class="koboSpan" id="kobo.1124.1">With this, we have completed all the tasks required to get started with TKG. </span><span class="koboSpan" id="kobo.1124.2">We started with the bootstrap machine’s configuration by installing all the required tools and CLIs. </span><span class="koboSpan" id="kobo.1124.3">After that, we created a TKG management cluster on AWS using the Tanzu installer UI. </span><span class="koboSpan" id="kobo.1124.4">And finally, we created a TKG workload cluster using the management cluster that we created. </span><span class="koboSpan" id="kobo.1124.5">It is worth noting that one bootstrap machine may have a reference to more than one TKG management cluster. </span><span class="koboSpan" id="kobo.1124.6">The operator may use different management clusters to manage the workload clusters under them by just switching the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1125.1">kubectl</span></strong><span class="koboSpan" id="kobo.1126.1"> context to an appropriate management cluster config, followed by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">tanzu login</span></strong><span class="koboSpan" id="kobo.1128.1"> command to get authenticated for the management cluster usage. </span><span class="koboSpan" id="kobo.1128.2">Now, in the next and the last section of this chapter, we will learn about some of the most common day-2 activities </span><span class="No-Break"><span class="koboSpan" id="kobo.1129.1">around TKG.</span></span></p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.1130.1">Common day-2 operations with Tanzu Kubernetes Grid</span></h1>
<p><span class="koboSpan" id="kobo.1131.1">Now that we have a fully configured</span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.1132.1"> and running TKG foundation on AWS, let’s learn how to perform some of the day-2 operations on it. </span><span class="koboSpan" id="kobo.1132.2">TKG makes</span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.1133.1"> these operations very trivial as they do all the heavy lifting behind </span><span class="No-Break"><span class="koboSpan" id="kobo.1134.1">the scenes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1135.1">Scale a cluster to add or </span><span class="No-Break"><span class="koboSpan" id="kobo.1136.1">remove nodes</span></span></li>
<li><span class="koboSpan" id="kobo.1137.1">Upgrade a cluster to bump up the </span><span class="No-Break"><span class="koboSpan" id="kobo.1138.1">Kubernetes version</span></span></li>
<li><span class="koboSpan" id="kobo.1139.1">Delete </span><span class="No-Break"><span class="koboSpan" id="kobo.1140.1">a cluster</span></span></li>
<li><span class="koboSpan" id="kobo.1141.1">Delete the entire </span><span class="No-Break"><span class="koboSpan" id="kobo.1142.1">TKG foundation</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1143.1">Let’s start by scaling the workload cluster so that it has three worker nodes instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.1144.1">just one.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.1145.1">Scaling a Tanzu Kubernetes Grid cluster</span></h2>
<p><span class="koboSpan" id="kobo.1146.1">Run the following</span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.1147.1"> commands to scale</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.1148.1"> the workload cluster </span><span class="No-Break"><span class="koboSpan" id="kobo.1149.1">we created:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1150.1">Switch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">kubectl</span></strong><span class="koboSpan" id="kobo.1152.1"> context so that it’s pointing to the management cluster that we previously created, which we used to create the </span><span class="No-Break"><span class="koboSpan" id="kobo.1153.1">workload cluster:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1154.1">
$ kubectl config use-context tkg-aws-mgmt-cluster-admin@tkg-aws-mgmt-cluster</span></pre></li>
<li><span class="koboSpan" id="kobo.1155.1">Ensure that the workload cluster has only one worker node by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.1156.1">following command:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1157.1">
$ tanzu cluster list</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1158.1">You should see the following output, which shows 1/1 </span><span class="No-Break"><span class="koboSpan" id="kobo.1159.1">worker nodes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer138">
<span class="koboSpan" id="kobo.1160.1"><img alt="Figure 7.26 – Ensuring the worker node count" src="image/B18145_07_26.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1161.1">Figure 7.26 – Ensuring the worker node count</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1162.1">Run the following</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.1163.1"> command to add two more</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.1164.1"> worker nodes, creating the desired total count </span><span class="No-Break"><span class="koboSpan" id="kobo.1165.1">of three:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1166.1">
$ tanzu cluster scale tkg-aws-workload-cluster -w 3</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1167.1">You should see the following message, showing that the scaling is </span><span class="No-Break"><span class="koboSpan" id="kobo.1168.1">in progress:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer139">
<span class="koboSpan" id="kobo.1169.1"><img alt="Figure 7.27 – Worker node scaling in progress" src="image/B18145_07_27.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1170.1">Figure 7.27 – Worker node scaling in progress</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.1171.1">Verify that the scaling has been done by running the following cluster </span><span class="No-Break"><span class="koboSpan" id="kobo.1172.1">listing command:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1173.1">
$ tanzu cluster list</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1174.1">You should now see 3/3 worker nodes in </span><span class="No-Break"><span class="koboSpan" id="kobo.1175.1">the output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer140">
<span class="koboSpan" id="kobo.1176.1"><img alt="Figure 7.28 – Confirming that the cluster scaling has been done" src="image/B18145_07_28.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1177.1">Figure 7.28 – Confirming that the cluster scaling has been done</span></p>
<p><span class="koboSpan" id="kobo.1178.1">These steps showed you how to scale up a TKG cluster. </span><span class="koboSpan" id="kobo.1178.2">The same procedure is also applicable to scale down a cluster. </span><span class="koboSpan" id="kobo.1178.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1179.1">-w</span></strong><span class="koboSpan" id="kobo.1180.1"> option of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">scale</span></strong><span class="koboSpan" id="kobo.1182.1"> command declares the desired count of the worker nodes. </span><span class="koboSpan" id="kobo.1182.2">And depending on the changes in the desired count, TKG adds or removes</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.1183.1"> the worker nodes. </span><span class="koboSpan" id="kobo.1183.2">The scaling</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.1184.1"> command also has options to scale the control plane nodes or the nodes of a specific node pool. </span><span class="koboSpan" id="kobo.1184.2">You can learn more about scaling by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">tanzu cluster scale --</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1186.1">help</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1187.1"> command.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.1188.1">Upgrading a Tanzu Kubernetes Grid cluster</span></h2>
<p><span class="koboSpan" id="kobo.1189.1">Now that we’ve scaled, let’s learn how</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.1190.1"> to upgrade the TKG workload cluster</span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.1191.1"> to deploy a newer version of Kubernetes. </span><span class="koboSpan" id="kobo.1191.2">TKG allows such on-demand upgrades of selected clusters under a management cluster. </span><span class="koboSpan" id="kobo.1191.3">Here, the owners of the cluster have the choice of which Kubernetes version they need so that they have enough time to prepare to upgrade their workload clusters. </span><span class="koboSpan" id="kobo.1191.4">The following steps outline the </span><span class="No-Break"><span class="koboSpan" id="kobo.1192.1">upgrade procedure:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1193.1">Switch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1194.1">kubectl</span></strong><span class="koboSpan" id="kobo.1195.1"> context so that it’s pointing to the management cluster that we previously created, which we used to create the </span><span class="No-Break"><span class="koboSpan" id="kobo.1196.1">workload cluster:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1197.1">
$ kubectl config use-context tkg-aws-mgmt-cluster-admin@tkg-aws-mgmt-cluster</span></pre></li>
<li><span class="koboSpan" id="kobo.1198.1">Ensure that the workload cluster is deployed with Kubernetes v1.21.11 by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1199.1">following command:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1200.1">
$ tanzu cluster list</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1201.1">You should see the following output, showing that the cluster has been deployed with Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">version 1.21.11:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer141">
<span class="koboSpan" id="kobo.1203.1"><img alt="Figure 7.29 – Checking the current Kubernetes version of the cluster" src="image/B18145_07_29.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1204.1">Figure 7.29 – Checking the current Kubernetes version of the cluster</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1205.1">Run the following command to check the available Kubernetes version(s) for </span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1">the upgrade:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1207.1">
$ tanzu kubernetes-release get</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1208.1">You should see the following output, which shows v1.22.9 as an option to upgrade v1.21.11, as highlighted in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1209.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer142">
<span class="koboSpan" id="kobo.1210.1"><img alt="Figure 7.30 – Checking the available version upgrade options" src="image/B18145_07_30.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1211.1">Figure 7.30 – Checking the available version upgrade options</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.1212.1">Run the following command</span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.1213.1"> to upgrade the workload</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.1214.1"> cluster to Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.1215.1">version 1.22.9:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1216.1">
$ tanzu cluster upgrade tkg-aws-workload-cluster --tkr v1.22.9---vmware.1-tkg.1</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1217.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">--tkr</span></strong><span class="koboSpan" id="kobo.1219.1"> option mentions the target version for the upgrade that we picked from the available version list in the previous step. </span><span class="koboSpan" id="kobo.1219.2">This command will upgrade the workload cluster in a rolling manner, one node at a time, to minimize workload downtime. </span><span class="koboSpan" id="kobo.1219.3">The applications running with more than one pod would not face any downtime during such rolling upgrades. </span><span class="koboSpan" id="kobo.1219.4">After firing the preceding command, you should see the following confirmation message in about 15 to </span><span class="No-Break"><span class="koboSpan" id="kobo.1220.1">20 minutes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer143">
<span class="koboSpan" id="kobo.1221.1"><img alt="Figure 7.31 – Cluster upgrade log" src="image/B18145_07_31.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1222.1">Figure 7.31 – Cluster upgrade log</span></p>
<p><span class="koboSpan" id="kobo.1223.1">The following screenshot </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.1224.1">shows the recycling of the workload cluster nodes</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.1225.1"> to create the new version on the AWS EC2 console. </span><span class="koboSpan" id="kobo.1225.2">Here, you can see that the old nodes got terminated and that the new nodes with newer versions were created to </span><span class="No-Break"><span class="koboSpan" id="kobo.1226.1">replace them:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer144">
<span class="koboSpan" id="kobo.1227.1"><img alt="Figure 7.32 – Cluster node recycling on the AWS EC2 console" src="image/B18145_07_32.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1228.1">Figure 7.32 – Cluster node recycling on the AWS EC2 console</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.1229.1">Run the following command to ensure the workload cluster is running with the newer </span><span class="No-Break"><span class="koboSpan" id="kobo.1230.1">Kubernetes version:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1231.1">
$ tanzu cluster list</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1232.1">The following screenshot shows that the workload cluster is running on Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.1233.1">version 1.22.9:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer145">
<span class="koboSpan" id="kobo.1234.1"><img alt="Figure 7.33 – Confirming the workload cluster’s upgrade" src="image/B18145_07_33.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1235.1">Figure 7.33 – Confirming the workload cluster’s upgrade</span></p>
<p><span class="koboSpan" id="kobo.1236.1">In addition to allowing the Kubernetes</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.1237.1"> release to be upgraded, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1238.1">tanzu cluster upgrade</span></strong><span class="koboSpan" id="kobo.1239.1"> command also</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.1240.1"> allows you to upgrade the cluster for a specific operating system and its versions. </span><span class="koboSpan" id="kobo.1240.2">Run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1241.1">tanzu cluster upgrade –help</span></strong><span class="koboSpan" id="kobo.1242.1"> command to learn more about it. </span><span class="koboSpan" id="kobo.1242.2">In addition to upgrading a TKG cluster for these reasons, there is also another dimension for the upgrades – upgrading the TKG version itself. </span><span class="koboSpan" id="kobo.1242.3">Upgrading a TKG version (from TKG v1.5.x to v1.5.y or from v1.4.x to v1.5.y) is beyond the scope of this book. </span><span class="koboSpan" id="kobo.1242.4">However, you</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.1243.1"> can learn more about that </span><span class="No-Break"><span class="koboSpan" id="kobo.1244.1">here: </span></span><a href="https://docs.vmware.com/en/VMware-Tanzu-Kubernetes-Grid/1.5/vmware-tanzu-kubernetes-grid-15/GUID-upgrade-tkg-index.html"><span class="No-Break"><span class="koboSpan" id="kobo.1245.1">https://docs.vmware.com/en/VMware-Tanzu-Kubernetes-Grid/1.5/vmware-tanzu-kubernetes-grid-15/GUID-upgrade-tkg-index.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1246.1">.</span></span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.1247.1">Deleting a Tanzu Kubernetes Grid workload cluster</span></h2>
<p><span class="koboSpan" id="kobo.1248.1">Destructions are always easier</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.1249.1"> than constructions. </span><span class="koboSpan" id="kobo.1249.2">This</span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.1250.1"> is the same case with TKG workload clusters. </span><span class="koboSpan" id="kobo.1250.2">The following simple steps outline the procedure to delete the TKG workload cluster that we have used so far in </span><span class="No-Break"><span class="koboSpan" id="kobo.1251.1">this chapter:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1252.1">Switch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">kubectl</span></strong><span class="koboSpan" id="kobo.1254.1"> context so that it’s pointing to the management cluster that we previously created, which we used to create the </span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">workload cluster:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1256.1">
$ kubectl config use-context tkg-aws-mgmt-cluster-admin@tkg-aws-mgmt-cluster</span></pre></li>
<li><span class="koboSpan" id="kobo.1257.1">Run the following command to delete the workload cluster, along with its resources on your </span><span class="No-Break"><span class="koboSpan" id="kobo.1258.1">AWS account:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1259.1">
$ tanzu cluster delete tkg-aws-workload-cluster</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1260.1">You should see the following confirmation message on the console for the cluster deletion </span><span class="No-Break"><span class="koboSpan" id="kobo.1261.1">in progress:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer146">
<span class="koboSpan" id="kobo.1262.1"><img alt="Figure 7.34 – Cluster deletion in progress" src="image/B18145_07_34.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1263.1">Figure 7.34 – Cluster deletion in progress</span></p>
<p><span class="koboSpan" id="kobo.1264.1">The following screenshot from the AWS EC2 console shows that all the nodes for the workload clusters have </span><span class="No-Break"><span class="koboSpan" id="kobo.1265.1">been terminated:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer147">
<span class="koboSpan" id="kobo.1266.1"><img alt="Figure 7.35 – Terminated cluster nodes on the AWS EC2 console" src="image/B18145_07_35.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1267.1">Figure 7.35 – Terminated cluster nodes on the AWS EC2 console</span></p>
<p><span class="koboSpan" id="kobo.1268.1">Along with the EC2 instances, TKG (with the help of the Cluster API) also deletes other network resources that have been created for the deleted cluster on your AWS account. </span><span class="koboSpan" id="kobo.1268.2">As you may have assumed, deleting a Kubernetes cluster is an extremely sensitive operation that could result in extended downtime for the applications running on it. </span><span class="koboSpan" id="kobo.1268.3">Extensive measures</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.1269.1"> should be taken to prevent access to such operations from environments</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.1270.1"> other than a lab. </span><span class="koboSpan" id="kobo.1270.2">Now, let’s look at an even more destructive operation: deleting the entire TKG foundation, including the </span><span class="No-Break"><span class="koboSpan" id="kobo.1271.1">management cluster.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.1272.1">Deleting a Tanzu Kubernetes Grid foundation</span></h2>
<p><span class="koboSpan" id="kobo.1273.1">You would rarely need to delete a TKG foundation</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.1274.1"> from its roots except</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.1275.1"> in such a lab environment. </span><span class="koboSpan" id="kobo.1275.2">Nevertheless, we will cover this TKG life cycle activity in this chapter. </span><span class="koboSpan" id="kobo.1275.3">To delete a TKG foundation, we just need to delete the management cluster that we created for the same. </span><span class="koboSpan" id="kobo.1275.4">And like deleting</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.1276.1"> a workload cluster, deleting a management cluster</span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.1277.1"> is also a simple but highly destructive process. </span><span class="koboSpan" id="kobo.1277.2">The following steps outline the procedure </span><span class="No-Break"><span class="koboSpan" id="kobo.1278.1">for this:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1279.1">Ensure you are pointing to the right Kubernetes cluster for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1280.1">kubectl</span></strong><span class="koboSpan" id="kobo.1281.1"> context by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.1282.1">following command:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1283.1">
$ kubectl config use-context tkg-aws-mgmt-cluster-admin@tkg-aws-mgmt-cluster</span></pre></li>
<li><span class="koboSpan" id="kobo.1284.1">Run the following command to delete the management cluster, along with its resources on your </span><span class="No-Break"><span class="koboSpan" id="kobo.1285.1">AWS account:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1286.1">
$ AWS_REGION=us-east-1 tanzu mc delete --verbose 5</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1287.1">You may need to replace the region name in the command based on the deployed region of the management cluster. </span><span class="koboSpan" id="kobo.1287.2">Upon command execution, you should see the following logs on the console for the cluster deletion in progress because of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1288.1">--verbose</span></strong><span class="koboSpan" id="kobo.1289.1"> option, followed by the logging detail level. </span><span class="koboSpan" id="kobo.1289.2">This command takes the log verbose level from 0 to 9, with 9 being the most </span><span class="No-Break"><span class="koboSpan" id="kobo.1290.1">detailed log:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer148">
<span class="koboSpan" id="kobo.1291.1"><img alt="Figure 7.36 – Management cluster deletion logs" src="image/B18145_07_36.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1292.1">Figure 7.36 – Management cluster deletion logs</span></p>
<p><span class="koboSpan" id="kobo.1293.1">You may have figured out from the logs that TKG created a kind cluster on the bootstrap machine to do all the required cleanup to delete the TKG foundation from the AWS account. </span><span class="koboSpan" id="kobo.1293.2">This is the same approach that TKG uses while creating a management cluster, as we saw earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.1294.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.1295.1">With that, we have completed</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.1296.1"> some of the important</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.1297.1"> day-2 activities around TKG clusters. </span><span class="koboSpan" id="kobo.1297.2">Now, let’s wrap up this chapter with a quick summary of what we </span><span class="No-Break"><span class="koboSpan" id="kobo.1298.1">have learned.</span></span></p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.1299.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1300.1">At the beginning of this chapter, we discussed some of the reasons why TKG could be a good choice for being a Kubernetes-based container platform. </span><span class="koboSpan" id="kobo.1300.2">As we saw during the hands-on activities, TKG makes Kubernetes platform deployment and management very easy and operationally efficient by providing a uniform interface – the Tanzu CLI. </span><span class="koboSpan" id="kobo.1300.3">All the Tanzu CLI-based operations we performed in this chapter were infrastructure-agnostic, providing the required muti-cloud ease </span><span class="No-Break"><span class="koboSpan" id="kobo.1301.1">of operations.</span></span></p>
<p><span class="koboSpan" id="kobo.1302.1">Because of the limited scope of TKG in this book, we could not install and use all the optional extensions that TKG provides, but we covered them briefly to understand their applications. </span><span class="koboSpan" id="kobo.1302.2">We saw how extensively TKG uses various cherry-picked open source tools from the CNCF ecosystem. </span><span class="koboSpan" id="kobo.1302.3">This way, TKG is a solution completely backed by the open </span><span class="No-Break"><span class="koboSpan" id="kobo.1303.1">source community.</span></span></p>
<p><span class="koboSpan" id="kobo.1304.1">Finally, we learned about the common day-1 and day-2 activities on the TKG platform, starting with installing a platform on AWS and creating a workload cluster to host actual application containers. </span><span class="koboSpan" id="kobo.1304.2">Following this, we learned how to add more capacity for that workload cluster with on-demand scaling. </span><span class="koboSpan" id="kobo.1304.3">We also learned how easily we can upgrade the cluster for different reasons and finally how to delete the cluster and the foundation </span><span class="No-Break"><span class="koboSpan" id="kobo.1305.1">if required.</span></span></p>
<p><span class="koboSpan" id="kobo.1306.1">As you may have assumed, we have not covered many topics around this subject to keep this chapter’s length concise. </span><span class="koboSpan" id="kobo.1306.2">However, we will learn about TKG clusters’ backup and restore, compliance scanning, and governance policy configurations in </span><a href=""><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1307.1">Chapter 9</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.1308.1">, Managing and Controlling Kubernetes Clusters with Tanzu Mission Control,</span></em><span class="koboSpan" id="kobo.1309.1"> for Tanzu Mission Control, a single pane of glass that controls hundreds of </span><span class="No-Break"><span class="koboSpan" id="kobo.1310.1">Kubernetes clusters.</span></span></p>
<p><span class="koboSpan" id="kobo.1311.1">TKG is a commercially available licensed software provided by VMware. </span><span class="koboSpan" id="kobo.1311.2">In the next chapter we will go deep into the Tanzu developer experience with </span><strong class="bold"><span class="koboSpan" id="kobo.1312.1">Tanzu </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1313.1">Application Platform</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1314.1">.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer150">
</div>
</div>
</body></html>