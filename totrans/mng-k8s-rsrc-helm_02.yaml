- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Preparing a Kubernetes and Helm Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Helm** is a tool that provides a variety of benefits that help users deploy
    and manage **Kubernetes** applications easier. Before users can start experiencing
    these benefits, however, they must satisfy several prerequisites. First, a user
    must have access to a Kubernetes cluster. Next, a user should have the command-line
    tools for both Kubernetes and Helm. Finally, a user should be aware of Helm’s
    basic configuration options to be productive with as little friction as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will outline the tools and concepts that are required to
    begin working with Helm. The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a local Kubernetes environment with minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up kubectl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you must install the following technologies on your local
    workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VirtualBox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kubectl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tools can be installed with a package manager or by downloading them directly
    from the source. We will provide instructions for using the `Chocolatey` package
    manager on Windows, the `Homebrew` package manager on macOS, the `apt-get` package
    manager for Debian-based Linux distributions, and the `dnf` package manager for
    RPM-based Linux distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a local Kubernetes environment with minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm won’t be able to deploy applications without access to a Kubernetes cluster.
    For this reason, let’s discuss one option where users can run a local cluster
    on their machine – **minikube**.
  prefs: []
  type: TYPE_NORMAL
- en: minikube is a community-driven tool that allows users to easily deploy a small,
    single-node Kubernetes cluster to their local machine. A cluster created with
    minikube is run inside either a container or a **virtual machine** (**VM**) so
    that it can easily be created and later discarded. minikube presents us with an
    excellent way to experiment with Kubernetes, and it can also be used to learn
    Helm alongside the examples provided throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we’ll cover how minikube can be installed and configured
    so that you have a Kubernetes cluster available while learning how to use Helm.
    For more comprehensive instructions, please refer to the *Getting Started!* page
    of the official minikube website at https://minikube.sigs.k8s.io/docs/start/.
  prefs: []
  type: TYPE_NORMAL
- en: Installing minikube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: minikube, like the other tools that will be installed within this chapter, has
    binaries compiled for the Windows, macOS, and Linux operating systems. The easiest
    way to install the latest version of minikube on Windows and macOS is via a package
    manager, such as `Chocolatey` for Windows and `Homebrew` for macOS. Linux users
    will find it easier to install the latest `minikube` binary by downloading it
    from minikube’s GitHub releases page, though this method can also be used on Windows
    and macOS as well.
  prefs: []
  type: TYPE_NORMAL
- en: The following steps describe how to install minikube based on your machine and
    installation preference. Please note that minikube version v1.22.0 was used at
    the time of writing and for developing the examples that have been used throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it via a package manager (on Windows and macOS), run one of the
    following commands based on your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For macOS, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following steps show you how to install minikube using a direct download
    link (on Windows, macOS, and Linux):'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to minikube’s *releases* page on GitHub at [https://github.com/kubernetes/minikube/releases/](B17979_02.xhtml#_idTextAnchor038).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the **Assets** section, which contains the minikube binaries for a given
    release:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.1 – A snippet of the minikube binaries from the GitHub releases
    page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.1_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – A snippet of the minikube binaries from the GitHub releases page
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `minikube`. If you are downloading the Linux binary, for example,
    you would run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To execute minikube, Linux and macOS users may need to add the executable bit
    by running the `chmod` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`minikube` should then be moved to a location that’s managed by the `PATH`
    variable so that it can be executed from any location in your command line. The
    locations that the `PATH` variable contains vary, depending on your operating
    system. For macOS and Linux users, these locations can be determined by running
    the following command in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Windows users can determine the `PATH` variable’s locations by running the
    following command in PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Move the `minikube` binary to a `PATH` location using the `mv` command. The
    following example moves `minikube` to a common `PATH` location on Linux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can verify your minikube installation by running `minikube version` and
    ensuring that the displayed version corresponds with the version that was downloaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step involves installing a container or virtual machine manager to
    run your local Kubernetes cluster. In this book, we will choose to run Kubernetes
    in a VM using VirtualBox since it is flexible and available on the Windows, macOS,
    and Linux operating systems. We will explain how to install VirtualBox next.
  prefs: []
  type: TYPE_NORMAL
- en: Installing VirtualBox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like minikube, VirtualBox can easily be installed via Chocolatey or Homebrew:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to install VirtualBox on Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following command to install VirtualBox on macOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'VirtualBox can also be installed by Linux package managers, but you need to
    download a package first from VirtualBox’s website (https://www.virtualbox.org/wiki/Linux_Downloads):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – VirtualBox package download links'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.2_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – VirtualBox package download links
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have downloaded your distribution’s package, you can install VirtualBox
    via `apt-get` or `dnf`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to install VirtualBox on Debian-based Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following command to install VirtualBox on RPM-based Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Alternative methods of installing VirtualBox can be found at its official download
    page at https://www.virtualbox.org/wiki/Downloads.
  prefs: []
  type: TYPE_NORMAL
- en: With VirtualBox installed, minikube must be configured to leverage VirtualBox
    as its default hypervisor. We will configure this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring VirtualBox as the default driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'VirtualBox can be made the default driver in minikube by specifying the `driver`
    option as `virtualbox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this command may produce the following warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This message can be safely ignored if there are no active minikube clusters
    on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change to VirtualBox can be confirmed by checking the value of the `driver`
    configuration option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If the configuration change was successful, the following output will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In addition to configuring the default driver, you can also configure the resources
    that are allocated to a minikube instance, which we will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring minikube resource allocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, minikube will allocate 2 CPUs and 2 GB of RAM to the VM, but we
    recommend increasing the memory allocation to 4 GB if your machine has the resources
    to spare. This is to prevent bumping into memory constraints as you run through
    the exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to increase the VM memory allocation to 4 GB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This change can be verified by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let’s continue exploring minikube by discussing its basic usage.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the basic usage of minikube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this book, it will be handy to understand the key commands that are
    used in a typical minikube operation. They will also be essential to understand
    while executing the examples provided throughout this book. Fortunately, minikube
    is an easy tool to get started with.
  prefs: []
  type: TYPE_NORMAL
- en: 'minikube has three key subcommands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `start` subcommand is used to create a single-node Kubernetes cluster.
    It creates a VM and bootstraps a cluster within it. The command will terminate
    once the cluster is ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `stop` subcommand is used to shut down the cluster and the VM. The state
    of the cluster and VM are saved to the disk, allowing users to run the `start`
    subcommand again to quickly begin resuming their work, rather than having to build
    a new VM from scratch. You should try to get into the habit of running `minikube
    stop` when you have finished working with a cluster that you would like to return
    to later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `delete` subcommand is used to delete a cluster and the VM. This command
    erases the state of the cluster and VM, freeing up the space on the disk that
    was previously allocated. The next time `minikube start` is executed, a fresh
    cluster and VM will be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There are more minikube subcommands available, but these are the subcommands
    that you should be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: With minikube installed and configured on a local machine, you can now install
    **kubectl**, the Kubernetes command-line tool, and satisfy the remaining prerequisite
    for working with Helm.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up kubectl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in [*Chapter 1*](B17979_01.xhtml#_idTextAnchor015), *Understanding
    Kubernetes and Helm*, Kubernetes is a system that exposes different API endpoints.
    These API endpoints are used to perform various actions on a cluster, such as
    creating, viewing, or deleting resources. To provide a simpler user experience,
    developers need a way of interacting with Kubernetes without having to manage
    the underlying API layer.
  prefs: []
  type: TYPE_NORMAL
- en: While you will predominantly use the Helm command-line tool throughout this
    book to install and manage applications, kubectl is an essential tool for common
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Read on to learn how to install kubectl on a local workstation. Note that the
    kubectl version that was used at the time of writing was v1.21.2.
  prefs: []
  type: TYPE_NORMAL
- en: Installing kubectl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: kubectl can be installed using minikube, or it can be obtained via a package
    manager or through direct download. First, let’s describe how to obtain kubectl
    using minikube.
  prefs: []
  type: TYPE_NORMAL
- en: Installing kubectl via minikube
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Installing kubectl is straightforward with minikube. minikube provides a subcommand
    called `kubectl`, which downloads the kubectl binary for you. Begin by running
    a `kubectl` command using `minikube kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This command installs kubectl to the `$HOME/.minikube/cache/linux/v1.21.2`
    directory. Note that the version of kubectl that’s included in the path will depend
    on the version of minikube that is being used. To access kubectl once it has been
    installed, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'While invoking kubectl with `minikube kubectl` works, the syntax is more unwieldy
    than that of invoking kubectl directly. This can be overcome by copying the `kubectl`
    executable from the local minikube cache into a location that’s managed by the
    `PATH` variable. Performing this action is similar on each operating system, but
    the following is an example of how it can be achieved on a Linux machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once complete, `kubectl` can be invoked as a standalone binary, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`kubectl` can also be installed without `minikube`, as we’ll see in the following
    sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing kubectl without minikube
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Kubernetes upstream documentation provides several different mechanisms
    to do so for a variety of target operating systems, as described in https://kubernetes.io/docs/tasks/tools/install-kubectl/.
  prefs: []
  type: TYPE_NORMAL
- en: Using a package manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another way that kubectl can be installed without minikube is with a native
    package manager. The following list demonstrates how this can be accomplished
    on different operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to install kubectl on Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following command to install kubectl on macOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following command to install kubectl on Debian-based Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following command to install kubectl on RPM-based Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will discuss the final kubectl installation method next.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading directly from a link
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'kubectl can also be downloaded directly from a download link. The following
    list explains how version v1.21.2 can be downloaded, which is the version of kubectl
    that will be used throughout this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Download kubectl for Windows from [https://storage.googleapis.com/kubernetes-release/release/v1.21.2/bin/windows/amd64/kubectl.exe](B17979_02.xhtml#_idTextAnchor082).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download kubectl for macOS from [https://storage.googleapis.com/kubernetes-release/release/v1.21.2/bin/darwin/amd64/kubectl](B17979_02.xhtml#_idTextAnchor081).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download kubectl for Linux from [https://storage.googleapis.com/kubernetes-release/release/v1.21.2/bin/linux/amd64/kubectl](B17979_02.xhtml#_idTextAnchor080).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The kubectl binary can then be moved to a location that’s managed by the `PATH`
    variable. On the macOS and Linux operating systems, be sure to grant the file
    executable permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The installation can be verified by running the following command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve covered how to set up kubectl, we’re ready to get into the key
    technology of this book – Helm.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once minikube and kubectl have been installed, the next logical tool to configure
    is Helm. Note that the version of Helm that was used at the time of writing this
    book was v3.6.3.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Helm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Packages for Helm exist for both `Chocolatey` and `Homebrew` to allow you to
    easily install it on Windows or macOS. On these systems, the following commands
    can be run to install Helm with the applicable package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Helm on Windows using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install Helm on macOS using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Linux users, or users who would rather install Helm from a direct downloadable
    link, can download an archive from Helm’s GitHub releases page by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the **Installation and Upgrading** section on Helm’s GitHub releases page
    at https://github.com/helm/helm/releases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.3 – The Installation and Upgrading section on the Helm GitHub releases
    page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.3_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – The Installation and Upgrading section on the Helm GitHub releases
    page
  prefs: []
  type: TYPE_NORMAL
- en: Download the archive file associated with your operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once downloaded, the file will need to be unarchived. One way that this can
    be achieved is by using the `Expand-Archive` cmdlet on PowerShell or by using
    the `tar` utility on Bash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Windows/PowerShell, use the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'For Linux, use the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For Mac, use the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `helm` binary can be found in the unarchived folder. It should be moved
    to a location that’s managed by the `PATH` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how to move the `helm` binary to the `/usr/local/bin`
    folder on a Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Regardless of the method that Helm was installed with, verification can be
    performed by running the `helm version` command. If the resulting output is similar
    to that of the following code, then Helm has been successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: With Helm installed on your machine, let’s learn about the basic Helm configuration
    topics.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm is a tool with sensible defaults that allow users to be productive without
    needing to perform a large number of tasks post-installation. With that being
    said, there are several different options users can change or enable to modify
    Helm’s behavior. We will cover these options in the following sections, beginning
    with configuring upstream repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Adding upstream repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way that users can begin to configure their Helm installation is by adding
    upstream chart repositories. In [*Chapter 1*](B17979_01.xhtml#_idTextAnchor015),
    *Understanding Kubernetes and Helm*, we described how chart repositories contain
    Helm charts that are more broadly available for consumption. Helm, being the Kubernetes
    package manager, can connect to various chart repositories to install Kubernetes
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Helm provides the `repo` subcommand to allow users to manage configured chart
    repositories. This subcommand contains additional subcommands that can be used
    to perform actions against specified repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the five `repo` subcommands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add`: To add a chart repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list`: To list chart repositories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove`: To remove a chart repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update`: To update information on available charts locally from chart repositories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index`: To generate an index file, given a directory containing packaged charts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the preceding list as a guide, adding a chart repository can be accomplished
    using the `add repo` subcommand, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Adding chart repositories is required before installing the charts contained
    within them. The specific steps to install charts from repositories will be discussed
    in detail throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can confirm whether a repository has been successfully added by leveraging
    the `list repo` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Repositories that have been added to the Helm client will appear in this output.
    The preceding example shows that a chart repository called `bitnami` was previously
    added, so it appears in the list of repositories known by the Helm client. If
    additional repositories are added, they will also appear in this output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over time, updates to charts will be published and released to these repositories.
    Repository metadata is cached locally. As a result, Helm is not automatically
    aware of when a chart is updated. You can instruct Helm to check for updates from
    each configured repository by running the `update repo` subcommand. Once this
    command has been executed, you will be able to install the latest charts from
    each repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also need to remove repositories that have been configured previously.
    This can be accomplished by using the `repo remove` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The last remaining `repo` subcommand form is `index`. This subcommand is used
    by repository and chart maintainers to publish new or updated charts. This task
    will be covered more extensively in [*Chapter 8*](B17979_08.xhtml#_idTextAnchor210),
    *Publishing to a Helm Chart Repository*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss Helm plugin configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Plugins are add-on capabilities that can be used to provide additional features
    to Helm. Most users will not need to worry about plugins and plugin management
    with Helm. Helm is a powerful tool on its own and is complete with a full set
    of included features. With that being said, the Helm community maintains a variety
    of different plugins that can be used to enhance Helm’s capabilities outside of
    the core code base. Some of the more popular Helm plugins are listed within the
    Helm documentation at https://helm.sh/docs/community/related/.
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm provides a `plugin` subcommand for managing plugins, which contain further
    subcommands, as described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Plugin Subcommand** | **Description** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `install` | Installs one or more Helm plugins | `helm plugin install $URL`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `list` | Lists installed Helm plugins | `helm plugin list` |'
  prefs: []
  type: TYPE_TB
- en: '| `uninstall` | Uninstalls one or more Helm plugins | `helm plugin uninstall
    $PLUGIN` |'
  prefs: []
  type: TYPE_TB
- en: '| `update` | Updates one or more Helm plugins | `helm plugin update $PLUGIN`
    |'
  prefs: []
  type: TYPE_TB
- en: Table 2.1 – Helm plugin subcommands
  prefs: []
  type: TYPE_NORMAL
- en: Plugins can provide a variety of different productivity enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are several examples of upstream plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Helm Diff**: Performs a diff between a deployed release and proposed Helm
    upgrade'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Helm Secrets**: Used to help conceal secrets from Helm charts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Helm Monitor**: Used to monitor a release and perform a rollback if certain
    events occur'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Helm Unittest**: Used to perform unit testing on a Helm chart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will continue discussing Helm configuration options by reviewing the different
    environment variables that can be set to change various aspects of Helm’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helm relies on the existence of environment variables to configure some of the
    low-level options. There are many variables you can configure, each of which can
    be seen in the `helm help` output.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few environment variables are used for storing Helm metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HELM_CACHE_HOME``XDG_CACHE_HOME`: Sets an alternative location for storing
    cached files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HELM_CONFIG_HOME``XDG_CONFIG_HOME`: Sets an alternative location for storing
    Helm configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HELM_DATA_HOME``XDG_DATA_HOME`: Sets an alternative location for storing Helm
    data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Helm adheres to the **XDG Base Directory Specification**, which is designed
    to provide a standardized way of defining where different files are located on
    an operating system’s filesystem. Based on the XDG specification, Helm automatically
    creates three different default directories on each operating system as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operating System** | **Cache Path** | **Configuration Path** | **Data Path**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Windows | `%TEMP%\helm` | `%APPDATA%\helm` | `%APPDATA%\helm` |'
  prefs: []
  type: TYPE_TB
- en: '| macOS | `$HOME/Library/Caches/helm` | `$HOME/Library/Preferences/helm` |
    `$HOME/Library/helm` |'
  prefs: []
  type: TYPE_TB
- en: '| Linux | `$HOME/.cache/helm` | `$HOME/.config/helm` | `$HOME/.local/share/helm`
    |'
  prefs: []
  type: TYPE_TB
- en: Table 2.2 – Default locations for Helm metadata
  prefs: []
  type: TYPE_NORMAL
- en: Helm uses the `helm repo update` command.
  prefs: []
  type: TYPE_NORMAL
- en: The **configuration path** is used to save repository information, such as the
    URL and credentials for authentication, if required. When a chart is installed
    but is not located in the local cache yet, Helm uses the configuration path to
    look up the URL of the chart repository. The chart is then downloaded from this
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: The `helm plugin install` command, the plugin itself is stored in this location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the Helm metadata paths, other environment variables are used for configuring
    regular Helm usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '`secret`, which Base64-encodes the state of a release in a Kubernetes `secret`.
    Other options include `configmap`, which stores state in a plaintext Kubernetes
    ConfigMap, `memory`, which stores the state in the local process’s memory, and
    `sql`, which stores state in a relational database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HELM_NAMESPACE` environment variable is used to set the namespace in which
    Helm operations take place. This is a convenient environment variable to use as
    it prevents you from needing to pass the `--namespace` or `-n` flag on each Helm
    invocation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KUBECONFIG` environment variable is used to set the file that’s used for authentication
    to the Kubernetes cluster. If unset, the default value will be `~/.kube/config`.
    In most cases, users won’t need to modify this value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another component of Helm that can be configured is tab completion, as discussed
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Tab completion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bash, Zsh, and Fish users can enable tab completion to simplify Helm usage.
    Tab completion allows Helm commands to be auto-completed when the *Tab* key is
    pressed, enabling users to perform tasks faster and helping prevent input mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: This process is similar to how most modern terminal emulators behave by default.
    When the *Tab* key is pressed, terminals try to guess what arguments are needed
    next by observing the state of the command and the environment. For example, the
    `cd /usr/local/b` input can be tab-completed to `cd /usr/local/bin` in a Bash
    shell. Similarly, an input such as `helm upgrade hello-` can be tab-completed
    to read `helm upgrade hello-world`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tab completion can be enabled by running one of the following commands, based
    on your shell of choice:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Bash users, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Zsh users, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Fish users, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that auto-completion will only exist in terminal windows that execute one
    of the preceding commands, so other open windows will need to run this command
    as well to experience the auto-completion feature.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helm needs to be able to authenticate with a Kubernetes cluster to deploy and
    manage applications. It authenticates by referencing a `kubeconfig` file, which
    specifies different Kubernetes clusters and how to interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using minikube, you will not need to configure authentication as
    minikube automatically configures a `kubeconfig` file each time a new cluster
    is created. If you are not running minikube, you will likely need to create a
    `kubeconfig` file or have one provided, depending on the Kubernetes distribution
    you are using. A `kubeconfig` file is comprised of three primary components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**clusters**: Hostnames or IP addresses, along with a certificate authority'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**users**: Authentication details'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**contexts**: Binding between a cluster, users, and an active namespace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `kubeconfig` file, along with these three primary components, can be created
    by leveraging three different `kubectl` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command is `set-cluster`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `set-cluster` command will define a `cluster` entry in the `kubeconfig`
    file. `set-context` is used to associate a credential with a cluster. Once an
    association between a credential and a cluster has been established, you will
    be able to authenticate to the specified cluster using the credential’s authentication
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command is `set-credentials`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `set-credentials` command will define the name of a user, along with its
    authentication method and details. This command can configure a username and password
    pair, client certificate, bearer token, or authentication provider to allow users
    and administrators to specify varying different methods of authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have the `set-context` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `set-context` command, as mentioned previously, specifies a name mapping
    between a `cluster`, `credential`, (user), and an active namespace. All invocations
    referencing a `kubeconfig` file target a specific context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `kubectl config view` command can be used to view the `kubeconfig` file.
    Notice how the `clusters`, `contexts`, and `user` stanzas of `kubeconfig` correspond
    to the previously described commands, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Starting the minikube instance will automatically populate the contents of the
    `kubeconfig` file. Once this file is present, kubectl and Helm will be able to
    interact with a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss how authorization is handled against a
    Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization/RBAC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While authentication is a means of confirming identity, authorization defines
    the actions that an authenticated user is allowed to perform. Kubernetes uses
    **role-based access control** (**RBAC**) to perform authorization on Kubernetes.
    RBAC is a system for designing roles and privileges that can be assigned to a
    given user or group of users. The actions a user is permitted to perform on Kubernetes
    depends on the roles that the user has been assigned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes provides many different roles on the platform. Three common roles
    are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cluster-admin`: This allows a user to perform any action against any resource
    throughout the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`edit`: This allows a user to read and write to most resources within a namespace
    or a logical grouping of Kubernetes resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`view`: This prevents a user from modifying existing resources. It only allows
    users to read resources within a namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Helm authenticates to Kubernetes using the credentials defined in the
    `kubeconfig` file, Helm is given the same level of access. If `edit` access is
    allowed, Helm can be assumed to have sufficient permission to install applications,
    in most cases. With view access, Helm will not be able to install applications,
    as this level of access is read-only. It may also be unable to list details related
    to installed releases since `secrets` are used as the default storage driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users that run minikube are given `cluster-admin` by default after instance
    creation. While this level of access would not be a best practice in a production
    environment, it is acceptable for learning and experimenting. If you are running
    Minikube, you will not have to worry about configuring authorization to follow
    along with both the concepts and examples provided in this book. If you are working
    with Kubernetes users that aren’t using minikube, you will need to make sure they
    are given at least the `edit` role to be able to deploy applications with Helm.
    This can be accomplished by asking an administrator to run the following command
    (where `$USER` is your Kubernetes user):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Best practices around RBAC will be discussed in [*Chapter 12*](B17979_12.xhtml#_idTextAnchor270),
    *Helm Security Considerations*, when we discuss, in greater detail, the concepts
    related to security, including how to appropriately apply roles to prevent mistakes
    and actions of malicious intent in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a variety of different components you need to have available to start
    using Helm. In this chapter, you learned how to install minikube to provide a
    local Kubernetes cluster that can be used throughout this book. You also learned
    how to install kubectl, which is the official tool for interacting with the Kubernetes
    API. Finally, you learned how to install the Helm client and explored the various
    ways that Helm can be configured, including adding repositories and plugins, modifying
    environment variables, enabling tab completion, and configuring authentication
    and authorization against a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the prerequisite tooling installed, you can begin learning
    how to deploy your first application with Helm. In the next chapter, you will
    install a Helm chart from an upstream chart repository, as well as learn about
    life cycle management and application configuration. After finishing that chapter,
    you will have an understanding of how Helm acts as the package manager for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following links to learn more about the installation options
    that are available for minikube, kubectl, and Helm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Minikube: https://kubernetes.io/docs/tasks/tools/install-minikube/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'kubectl: https://kubernetes.io/docs/tasks/tools/install-kubectl/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Helm: [https://helm.sh/docs/intro/install/](B17979_02.xhtml#_idTextAnchor076)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We covered various ways of configuring Helm post-installation. Check out the
    following links to learn more about these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Repository management: [https://helm.sh/docs/intro/quickstart/#initialize-a-helm-chart-repository](B17979_02.xhtml#_idTextAnchor074)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plugin management: https://helm.sh/docs/topics/plugins/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Environment variables and the `helm help` output: [https://helm.sh/docs/helm/helm/](B17979_02.xhtml#_idTextAnchor072)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tab completion: [https://helm.sh/docs/helm/helm_completion/](B17979_02.xhtml#_idTextAnchor070)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Authentication and authorization via the `kubeconfig` file: https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How does Helm authenticate to a Kubernetes cluster?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What mechanism is in place to provide authorization to the Helm client? How
    can an administrator manage these privileges?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `helm repo add` command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three file paths that are used for storing Helm metadata? What
    does each path contain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Helm manage the state? What options are available to change how the
    state is stored?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
