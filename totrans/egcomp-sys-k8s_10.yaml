- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL and NoSQL Databases at the Edge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you have to create an edge system, a critical task is storing your data.
    For this, you have to take into consideration the resources that you have, the
    processor that your devices are using, and the type of data that you want to store.
    CAP theorem states that distributed data stores only provide two of the following
    guarantees: consistency, availability, and partition tolerance. So, this theorem
    can help you to decide which type of database is best according to your system
    needs. In this chapter, we are going to learn how to deploy different database
    types to run on edge systems using K3s and ARM devices. These examples include
    different techniques such as using ConfigMaps and Secrets to deploy your databases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: CAP theorem for SQL and NoSQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a volume to persist your data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using MySQL and MariaDB SQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Redis key-value NoSQL database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a MongoDB document-oriented NoSQL database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a PostgreSQL object-relational SQL database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Neo4j graph NoSQL database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To deploy the databases in this chapter, you need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A single- or multi-node K3s cluster using ARM devices with MetalLB, and Longhorn
    storage installed. If you are using Raspberry Pi devices, you will need at least
    4 GB of RAM and at least the 4B model. Each node must have the Ubuntu ARM64 operating
    system in order to support the ARMv8 architecture, necessary for some deployments
    in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl` configured to be used on your local machine, to avoid using the `--kubeconfig`
    parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clone the repository at [https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch10](https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch10)
    if you want to run the YAML configuration by using `kubectl apply` instead of
    copying the code from the book. Take a look at the directory `yaml` for the YAML
    examples inside the `ch10` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, you can deploy the databases explained in this chapter. So, let’s
    get started learning about CAP theorem first, to choose the right database for
    your specific use case.
  prefs: []
  type: TYPE_NORMAL
- en: CAP theorem for SQL and NoSQL databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CAP theorem was defined by Eric Brewer in 1999 and presented at the 19th Annual
    ACM Symposium on **Principles of Distributed Computing** (**PODC**) in 2000\.
    This theorem states that a distributed data store can only provide two of the
    following guarantees:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistency**: This means when reading information, the data store returns
    the most recent written data or returns an error if it fails. This refers to regular
    SQL databases that use atomic operations to guarantee that data is written. If
    not, the system automatically rolls back to a previous data state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability**: This means that all reads contain data, but it might not
    be the most recent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partition tolerance**: This is the most desired feature in a distributed
    system. It means that data is distributed in several nodes, helping to reduce
    downtime for the database. This means that if a node is down, just a small portion
    of data will be inaccessible:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.1 – CAP theorem diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_10_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – CAP theorem diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'This theorem is commonly used as a point of reference to design strong distributed
    systems in the context of data. Now, in the CAP theorem diagram (*Figure 10.1*),
    represented as a triangle, you can see the different sides, and how each side
    has a relationship with the other sides. Let’s explore these sides and give examples
    of databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CA**: On this side, we can classify databases that have consistency and availability.
    Here, we can find SQLite, which is a very simple database. MySQL and PostgreSQL
    are very popular open source databases. SQL Server is a proprietary database from
    Microsoft and Neo4j is a graph database. Each of these databases tries to guarantee
    consistency and availability. These guarantees can be found on **relational database
    management system** (**RDBMS**)-based databases. But as we have mentioned, Neo4j
    is classified on this side of the triangle. Something important on this side is
    that the database will fail if the network is down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CP**: On this side, you can find databases that provide consistency and partition
    tolerance. This means that databases such as Mongo and Redis use algorithms to
    write information that guarantee the consistency of data. For example, MongoDB
    uses the reader-writer algorithm to write in the database. Redis uses a similar
    algorithm to write data. Talking about partition tolerance, MongoDB can distribute
    information across nodes. This gives MongoDB the ability to partition the data.
    This is sharding, which provides the partition tolerance feature to MongoDB. Other
    databases based on Bigtable work similarly. Those Bigtable-based databases usually
    read data from distributed buckets of information across the cloud. The problem
    in CP is the risk that some data will become unavailable when a node or source
    of data is down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AP**: On this side, databases look for availability and partition tolerance.
    Here, we can find databases such as Cassandra, CouchDB, Riak, DynamoDB, and databases
    based on Cassandra. For example, Cassandra has high availability, using its masterless
    technique to scale servers, but it doesn’t guarantee the consistency of data.
    That’s a common issue in some NoSQL databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before deciding which database is right for you, let’s explore what a relational
    and no-relational database is. A **relational database** is a database where the
    data is structured. This means that data is organized in tables, rows, and columns.
    These tables have relationships and dependencies. These databases use **Structured
    Query Language** (**SQL**) to manage the information. Relational databases are
    also called **SQL databases**. They also use ACID operations. This stands for
    atomicity, consistency, isolation, and durability; these properties in data guarantee
    data integrity when errors and failures happen. Some examples are MySQL, PostgreSQL,
    and SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **non-relational database** is not structured. It doesn’t use a table, row,
    and column data schema. Instead, it uses a storage model optimized for specific
    requirements of the type of data being stored. Some of these types of data could
    be JSON documents, key values, and so on. These databases are also called **NoSQL
    databases**. These databases don’t use ACID operations. They look for availability
    and partition tolerance for data. Some examples are MongoDB, Redis, Neo4j, and
    Cassandra. When choosing the right database, you can evaluate some of these questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the guarantees of consistency, partition tolerance, and availability
    does my system need? According to this, which database fits my system needs best?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does my database need to support the SQL language to query information?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do I need a database that supports the SQL language?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is my data not structured as JSON documents or do I need something structured
    as tables?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What type of data am I storing? Do I need a SQL or NoSQL database?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do I need consistency, availability, or partition tolerance? Which of these
    components is important for my system?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many resources is my database going to use? How many simultaneous connections
    is my system expected to handle?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do I need to replicate information, implement rate limits, or have any other
    specific features in my database?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How fast is my database at writing and reading data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I do replication or scaling on my database?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These and other questions could be important when choosing the right database.
    So, this chapter focuses on giving you a quick start when choosing the right database,
    using CAP theorem and some examples of how to deploy some SQL and NoSQL databases
    mentioned in the CAP theorem description. These SQL and NoSQL databases will be
    deployed at the edge in a K3s cluster using containers.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find in the *Further reading* section some links to learn more about
    SQL and NoSQL databases, the official web links for the databases explained in
    this chapter, and complementary links to evaluate which database is best for your
    use case. A complementary theorem that you can use is the PACELC theorem. This
    looks for the trade-offs between latency and consistency when data is replicated.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s move on to create a volume to persist your data before performing
    the deployment of your selected database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a volume to persist your data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start deploying our databases, let’s create a volume to store data
    first. For this, we have two options. One is to use a directory inside the server.
    This means that in order to not lose data, your Pods have to be provisioned in
    the same node as where your volume was created the first time. If you don’t want
    to depend on which node your pods are running, you have to choose a second option,
    which is to use a storage driver. If that’s your case, we are going to use Longhorn
    as our storage driver option. Now, let’s create our storage first, using a local
    directory. For this, follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `/mnt/data` directory in the node to store data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a **PersistentVolumeClaim** using 5 GB of storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to use Longhorn as your storage, follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a PersistentVolumeClaim with 5 GB of storage, this time, using Longhorn:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a critical step to persist and avoid losing your data. In the next sections,
    we are going to start deploying our databases, starting with basic configuration
    and adding more complex configurations such as using **ConfigMaps** and **Secrets**
    to perform more production-ready deployments. But first, let’s start with MySQL
    and MariaDB, very popular databases used across the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Using MySQL and MariaDB SQL databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MySQL is a relational database that uses the SQL language to read and write
    information. It’s one of the most used databases on the internet. MariaDB is a
    fork of MySQL and the version used in this example is fully compatible with MySQL.
    It’s a very fast SQL database and it’s simple to use. After this brief introduction
    to MySQL, let’s get started deploying this database by following the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the MySQL deployment creating a PersistentVolumeClaim called `db-pv-claim`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using MySQL, you can use MariaDB, which is fully compatible with
    MySQL version 5.6\. To do this, change the `mysql:8.0.28-oracle` image to `arm64v8/mariadb:latest`
    and the `MYSQL_ROOT_PASSWORD` variable to `MARIADB_ROOT_PASSWORD`. You can also
    check for other image versions in [https://hub.docker.com](https://hub.docker.com)
    for MySQL and MariaDB images. For this deployment, the password is `password`.
    The images used for the deployment are both designed to run on ARM devices. In
    the case of MySQL reinstallation using local storage, you have to delete the content
    inside the `/mnt/data` directory using the `rm -R /mnt/data` command to avoid
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s create our service to access MySQL using a service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To test whether your MySQL deployment works, you can access your deployment
    pod by running this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the pod, run the following command to connect to your database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the prompt will change to `mysql>`. Let’s create a simple database, `EXAMPLE`,
    with the `VALUE_TABLE` table, and insert and list some records. To do this, run
    the following commands and you will see output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, delete the table and database with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now you have learned how to use MySQL with this basic deployment and example.
    Now let’s move on to learn how Redis works.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Redis key-value NoSQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it’s time to use Redis as our key-value database. Redis is a nice key-value
    database that doesn’t consume many resources. All its data is stored in memory.
    It has very interesting types of data such as hash keys, lists, and sets. It also
    implements publisher-subscriber and streaming features to implement channels of
    communication and simple broker functionalities. For our Redis deployment, we
    are going to use a custom configuration to set the password for Redis, and a storage
    volume to prevent losing data. To use Redis in your cluster, follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `K3s123-` and the `/data` directory to store Redis data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the deployment for Redis using the previous ConfigMap called `redis-configmap`
    and mounted as the `redis.conf` file. We also use the PersistentVolumeClaim called
    `db-pv-claim`, and some resource limits for the deployment, setting the CPU and
    memory. Let’s create the deployment by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create the `redis`, which points to port `6379` in our `redis` deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This service creates a DNS record inside the cluster called `redis` that points
    to our `redis` deployment. This DNS record is accessible to other deployments
    in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s access our Redis pods to test some basic commands to store a value in
    our database. To do this, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The prompt will look like this: `127.0.0.1:6379>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, authenticate to the Redis database using the `AUTH` command, and then
    use `set` and `get` to create the `a` key with the value `1`. Finally, exit using
    the `exit` command. This simple test will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this, you stored the `a` key with the value `1`. Now you have used Redis
    to store simple values. After running `exit`, you will exit to the Redis pod.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have learned how to deploy a simple Redis deployment, it’s time to deploy
    MongoDB in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using a MongoDB document-oriented NoSQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MongoDB is a document-oriented NoSQL database. It stores its data as JSON documents.
    It also implements sharding techniques to distribute data across its nodes and
    uses the MapReduce technique for data aggregation. It’s easy to use and uses low
    resources for single node scenarios. For our MongoDB deployment, we are going
    to use a ConfigMap to store custom configurations. In this case, our MongoDB configuration
    is set to expose its port across the network, but for the moment we are not using
    Secrets to simplify the deployment. In the *Using a PostgreSQL object-relational
    and SQL database* section, we are going to explore the use of secrets, but before
    that, let’s follow the next steps to deploy MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploy your custom configuration to enable clients to connect to MongoDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This exposes MongoDB to listen on port `27017` across the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the deployment using the ConfigMap called `mongo-configmap`, the PersistentVolumeClaim,
    and the `MONGO_INITDB_ROOT_USERNAME`, `MONGO_INITDB_ROOT_PASSWORD`, and `MONGO_INITDB_DATABASE`
    variables, which set the initial root, user, and the password to connect to MongoDB
    as root or with your defined user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that if you want to use a version of MongoDB greater than 5.0, you
    need a device with ARMv8.2-A or higher in order to use it. That’s the reason to
    use MongoDB 4.4 for this example. MongoDB 4.4 is supported to run on ARMv8 processors
    such as a Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create the service that exposes your MongoDB deployment as a service accessible
    inside the cluster (MongoDB uses port `27017` to connect):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the pod that contains MongoDB to test whether you are able to write
    some data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you are inside the pod, change into `mydatabase` and insert the `{"a":1}`
    document in the `mycollection` collection using `db.mycolletion.insert`. Then,
    list the inserted document using `db.mycollection.find`. Finally, execute `exit`
    to finish the Mongo session. The commands and output of this execution will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These are some basic commands to use MongoDB, to have a quick start with Mongo.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to deploy a simple MongoDB database in K3s, let’s move on to
    learn how to use Postgres in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using a PostgreSQL object-relational and SQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PostgreSQL is an object-relational database, used because of its strong reputation
    for reliability, feature robustness, and performance. It uses SQL to query its
    data. It’s also commonly used for storing files or to store data used to create
    machine learning models. So, let’s learn how to deploy PostgreSQL in a very simple
    way. To do this, follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, let’s use Kubernetes Secrets, and let’s create the password
    as `YOUR_PASSWORD` to give an example of how to hide sensible information as passwords.
    For this, let’s generate a Base64 encoding for your password with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the previous output to create your Secret object using a YAML file. You
    can create the `db-password` Secret with this value using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create the Postgres deployment with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create the `postgres` service by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the pod that contains Postgres to test whether you can write some data.
    To do this, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The prompt will look like `postgres=#`. Next, you will find some example commands
    and their output. This commands will be used to test whether our database works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, create the `VALUE_TABLE` table with the `ID` and `VALUE` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then insert a record with `ID`=`1` and `VALUE`=`123`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Show the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Exit from Postgres:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now you’ve learned how to install and run basic commands with Postgres to store
    your data in this database, let’s move on to learn about Neo4j, a graph NoSQL
    database, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Neo4j graph NoSQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Neo4j is a graph database that can be used to store relationships between objects.
    Neo4j uses **Cypher Query Language** (**CQL**), which is the equivalent of SQL
    for relational databases. Neo4j also represents data using nodes, relationships,
    properties, and labels in a visual way. It supports ACID operations and native
    graph storage and processing. It has great scalability and enterprise support.
    Because of the way it stores data, it can be used for IoT applications to query
    relationships between data. So now, let’s install Neo4j by following the next
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the deployment for Neo4j:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this deployment, we are using the `NEO4J_AUTH` variable with its value set
    to `none`, to use the non-authentication method, just to simplify this example.
    You can also explore how to use secrets and other options by modifying this configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If you delete the `NEO4J_AUTH` variable, Neo4j by default sets the user name
    and password to `neo4j`. Then, after logging in, a dialog box will ask you to
    change this password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the service to expose the `bolt`, `http`, and `https` ports that Neo4j
    uses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expose the `http` and `bolt` ports, before connecting to Neo4j with the browser.
    To do this, run the following commands in different terminals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open your browser at the page `http://localhost:7474`, choose **Authentication
    type**: **No authentication**, then click on the **Connect** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Neo4j login page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_10_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Neo4j login page
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you will see the Neo4j UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Neo4j main page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_10_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Neo4j main page
  prefs: []
  type: TYPE_NORMAL
- en: 'Run a simple example in the Neo4j terminal located at the top of the browser
    as `neo4j$`. To do this, add the next commands and run them by clicking on the
    blue triangle button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see that Neo4j visualizes the relationship between the Marvel characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Neo4j graph visualization'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_10_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Neo4j graph visualization
  prefs: []
  type: TYPE_NORMAL
- en: Now you have learned how to use Neo4j with this basic example, let’s move on
    to the summary of this chapter, about what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use CAP theorem to choose the right database
    to store data. This theorem helped us to take into consideration important guarantees
    when designing distributed data storage in a distributed system at the edge. In
    this chapter, we also learned about different relational and non-relational databases.
    We gained practical knowledge on how to set up and deploy various database paradigms
    such as relational, key-value, document-oriented, and graph databases. In the
    next chapter, we are going to focus on the time series database Prometheus, which
    stores data in the form of values and time and can be used to implement useful
    monitoring dashboards for devices at the edge.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few questions to validate your new knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: How can CAP theorem help you to decide which database to use according to your
    use case?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you deploy MySQL in K3s?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you deploy Redis in K3s?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you deploy MongoDB in K3s?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you deploy PostgreSQL on K3s?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you deploy Neo4j on K3s?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you use PersistentVolumeClaims to deploy a database on K3s?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you use ConfigMaps and Secrets to deploy a database on K3s?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following references for more information on the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Databases and Quick Overview of SQLite*: [https://medium.com/aiadventures/databases-and-quick-overview-of-sqlite-5b7d4f8f6174](https://medium.com/aiadventures/databases-and-quick-overview-of-sqlite-5b7d4f8f6174)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CAP Theorem for Databases: Consistency, Availability & Partition Tolerance*:
    [https://www.bmc.com/blogs/cap-theorem](https://www.bmc.com/blogs/cap-theorem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-relational data and NoSQL: [https://aloa.co/blog/relational-vs-non-relational-database-pros-cons](https://aloa.co/blog/relational-vs-non-relational-database-pros-cons)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CAP theorem: [https://devopedia.org/cap-theorem](https://devopedia.org/cap-theorem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*System design fundamentals: What is the CAP theorem?*: [https://www.educative.io/blog/what-is-cap-theorem](https://www.educative.io/blog/what-is-cap-theorem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What are the ACID properties of transactions and why do they matter in data
    engineering?*: [https://www.keboola.com/blog/acid-transactions](https://www.keboola.com/blog/acid-transactions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SQL vs NoSQL Databases: What’s The Difference?*: [https://www.bmc.com/blogs/sql-vs-nosql](https://www.bmc.com/blogs/sql-vs-nosql)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Traditional RDBMS to NoSQL database: New era of databases for big data*: [https://www.researchgate.net/publication/324922396_TRADITIONAL_RDBMS_TO_NOSQL_DATABASE_NEW_ERA_OF_DATABASES_FOR_BIG_DATA](https://www.researchgate.net/publication/324922396_TRADITIONAL_RDBMS_TO_NOSQL_DATABASE_NEW_ERA_OF_DATABASES_FOR_BIG_DATA)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MySQL client K8s: [https://gist.github.com/vishnuhd/b8686197f855c00fa734bc5f1fedf078](https://gist.github.com/vishnuhd/b8686197f855c00fa734bc5f1fedf078)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Run a Single-Instance Stateful Application*: [https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application](https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*MySQL 8 Administrator’s Guide*: [https://www.packtpub.com/product/mysql-8-administrator-s-guide/9781788395199](https://www.packtpub.com/product/mysql-8-administrator-s-guide/9781788395199)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Configuring Redis using a ConfigMap*: [https://kubernetes.io/docs/tutorials/configuration/configure-redis-using-configmap](https://kubernetes.io/docs/tutorials/configuration/configure-redis-using-configmap)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Redis Essentials*: [https://www.packtpub.com/product/redis-essentials/9781784392451](https://www.packtpub.com/product/redis-essentials/9781784392451)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kubernetes secrets: [https://kubernetes.io/fr/docs/concepts/configuration/secret](https://kubernetes.io/fr/docs/concepts/configuration/secret)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Seven NoSQL Databases in a Week*: [https://www.packtpub.com/product/seven-nosql-databases-in-a-week/9781787288867](https://www.packtpub.com/product/seven-nosql-databases-in-a-week/9781787288867)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to use Kubernetes to deploy Postgres*: [https://www.sumologic.com/blog/kubernetes-deploy-postgres](https://www.sumologic.com/blog/kubernetes-deploy-postgres)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PostgreSQL 14 Administration Cookbook*: [https://www.packtpub.com/product/postgresql-14-administration-cookbook/9781803248974](https://www.packtpub.com/product/postgresql-14-administration-cookbook/9781803248974)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Internet of Things and Data: A Powerful Connection*: [https://neo4j.com/news/internet-things-data-powerful-connection](https://neo4j.com/news/internet-things-data-powerful-connection)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Why not SQLite: [https://stackoverflow.com/questions/66950385/how-to-use-sqlite3-database-with-django-on-kuberenets-pod](https://stackoverflow.com/questions/66950385/how-to-use-sqlite3-database-with-django-on-kuberenets-pod)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a Graph Application with Python, Neo4j, Gephi, and Linkurious.js*:
    [https://linkurious.com/blog/creating-a-graph-application-with-python-neo4j-gephi-and-linkurious-js](https://linkurious.com/blog/creating-a-graph-application-with-python-neo4j-gephi-and-linkurious-js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Edge Computing Use Cases in Practice'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will learn how to use k3s and k3OS for different use cases,
    exploring complementary software and best practices for building an edge computing
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of the book comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B16945_11_Final_PG.xhtml#_idTextAnchor213), *Monitoring the
    Edge with Prometheus and Grafana*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B16945_12_Final_PG.xhtml#_idTextAnchor227), *Communicating with
    Edge Devices across Long Distances Using LoRa*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B16945_13_Final_PG.xhtml#_idTextAnchor246), *Geolocalization
    Applications Using GPS, NoSQL, and K3s Clusters*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B16945_14_Final_PG.xhtml#_idTextAnchor267), *Computer Vision
    with Python and K3s Clusters*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B16945_15_Final_PG.xhtml#_idTextAnchor285), *Designing Your
    Own Edge Computing System*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
