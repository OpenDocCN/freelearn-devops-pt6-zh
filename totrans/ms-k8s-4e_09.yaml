- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packaging Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to look into Helm, the popular Kubernetes package
    manager. Every successful and non-trivial platform must have a good packaging
    system. Helm was developed by Deis (acquired by Microsoft in April 2017) and later
    contributed to the Kubernetes project directly. It became a CNCF project in 2018\.
    We will start by understanding the motivation for Helm, its architecture, and
    its components. Then, we’ll get hands-on and see how to use Helm and its charts
    within Kubernetes. That includes finding, installing, customizing, deleting, and
    managing charts. Last but not least, we’ll cover how to create your own charts
    and handle versioning, dependencies, and templating.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm alternatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes provides many ways to organize and orchestrate your containers at
    runtime, but it lacks a higher-level organization of grouping sets of images together.
    This is where Helm comes in. In this section, we’ll go over the motivation for
    Helm, its architecture, and its components. We will discuss Helm 3\. You might
    still find Helm 2 in the wild, but its end of life was at the end of 2020.
  prefs: []
  type: TYPE_NORMAL
- en: As you might recall, Kubernetes means helmsman or navigator in Greek. The Helm
    project took the nautical theme very seriously, as the project’s name implies.
    The main Helm concept is the chart. Just as nautical charts describe in detail
    an area in the sea or a coastal region, a Helm chart describes in detail all the
    parts of an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm is designed to perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Build charts from the ground up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundle charts into archive files (`.tgz`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interact with repositories containing charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy and remove charts in an existing Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle the lifecycle of installed charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The motivation for Helm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Helm provides support for several important use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy upgrades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple sharing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safe rollbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Charts can define even the most intricate applications, offer consistent application
    installation, and act as a central source of authority. In-place upgrades and
    custom hooks allow for easy updates. It’s simple to share charts that can be versioned
    and hosted on public or private servers. When you need to roll back recent upgrades,
    Helm provides a single command to roll back a cohesive set of changes to your
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The Helm 3 architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Helm 3 architecture relies fully on client-side tooling and keeps its state
    as Kubernetes secrets. Helm 3 has several components: release secrets, client,
    and library.'
  prefs: []
  type: TYPE_NORMAL
- en: The client is the command-line interface, and often a CI/CD pipeline is used
    to package and install applications. The client utilizes the Helm library to perform
    the requested operations, and the state of each deployed application is stored
    in a release secret.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review the components.
  prefs: []
  type: TYPE_NORMAL
- en: Helm release secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Helm stores its releases as Kubernetes secrets in the target namespace. This
    means you can have multiple releases with the same name as long they are stored
    in different namespaces. Here is what a release secret looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The data is Base64-encoded twice and then GZIP-compressed.
  prefs: []
  type: TYPE_NORMAL
- en: The Helm client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You install the Helm client on your machine. Helm carries out the following
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Facilitating local chart development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overseeing releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interacting with the Helm library for:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment of new releases
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrade of existing releases
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of existing releases
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Helm library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Helm library is the component at the heart of Helm and is responsible for
    performing all the heavy lifting. The Helm library communicates with the Kubernetes
    API server and provides the following capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Combining Helm charts, templates, and values files to build a release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the releases into Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a release object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading and uninstalling charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm 2 vs Helm 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helm 2 was great and played a very important role in the Kubernetes ecosystem.
    But, there was a lot of criticism about Tiller, its server-side component. Helm
    2 was designed and implemented before RBAC became the official access-control
    method. In the interest of usability, Tiller is installed by default with a very
    open set of permissions. It wasn’t easy to lock it down for production usage.
    This is especially challenging in multi-tenant clusters.
  prefs: []
  type: TYPE_NORMAL
- en: The Helm team listened to the criticisms and came up with the Helm 3 design.
    Instead of the Tiller in-cluster component, Helm 3 utilizes the Kubernetes API
    server itself via CRDs to manage the state of releases. The bottom line is that
    Helm 3 is a client-only program. It can still manage releases and perform the
    same tasks as Helm 2, but without installing a server-side component.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is more Kubernetes-native and less complicated, and the security
    concerns are gone. Helm users can perform via Helm only as much as their kube
    config allows.
  prefs: []
  type: TYPE_NORMAL
- en: Using Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm is a rich package management system that lets you perform all the necessary
    steps to manage the applications installed on your cluster. Let’s roll up our
    sleeves and get going. We’ll look at installing both Helm 2 and Helm 3, but we
    will use Helm 3 for all of our hands-on experiments and demonstrations.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Helm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing Helm involves installing the client and the server. Helm is implemented
    in Go. The Helm 2 executable can serve as either the client or server. Helm 3,
    as mentioned before, is a client-only program.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Helm client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You must have Kubectl configured properly to talk to your Kubernetes cluster
    because the Helm client uses the Kubectl configuration to talk to the Kubernetes
    API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm provides binary releases for all platforms here: [https://github.com/helm/helm/releases](https://github.com/helm/helm/releases).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, the Chocolatey ([https://chocolatey.org](https://chocolatey.org))
    package manager is the best option (usually up to date):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For macOS and Linux, you can install the client from a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On macOS, you can also use Homebrew ([https://brew.sh](https://brew.sh)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finding charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install useful applications and software with Helm, you need to find their
    charts first. Helm was designed to work with multiple repositories of charts.
    Helm 2 was configured to search the stable repository by default, but you could
    add additional repositories. Helm 3 comes with no default, but you can search
    the Helm Hub ([https://artifacthub.io](https://artifacthub.io)) or specific repositories.
    The Helm Hub was launched in December 2018 and it was designed to make it easy
    to discover charts and repositories hosted outside the stable or incubator repositories.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the `helm search` command comes in. Helm can search the Helm Hub
    for a specific repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hub contains 9,053 charts at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can search the hub for a specific keyword like `mariadb`. Here are the first
    10 charts (there are 38):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are several charts that match the keyword `mariadb`. You
    can investigate those further and find the best one for your use case.
  prefs: []
  type: TYPE_NORMAL
- en: Adding repositories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, Helm 3 comes with no repositories set up, so you can search only
    the hub. In the past, the `stable` repo hosted by the CNCF was a good option to
    look for charts. But, CNCF didn’t want to pay for hosting it, so now it just contains
    a lot of deprecated charts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, you can either install charts from the hub or do some research and
    add individual repositories. For example, for Prometheus, there is the `prometheus-community`
    Helm repository. Let’s add it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can search the `prometheus` repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are quite a few charts there. To get more information about a specific
    chart, we can use the `show` command (you can use the `inspectalias` command too).
    Let’s check out `prometheus-community/prometheus`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can also ask Helm to show you the `README` file, the values, or all the
    information associated with a chart. This can be overwhelming at times.
  prefs: []
  type: TYPE_NORMAL
- en: Installing packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OK. You’ve found the package of your dreams. Now, you probably want to install
    it on your Kubernetes cluster. When you install a package, Helm creates a release
    that you can use to keep track of the installation progress. We install `prometheus`
    using the `helm install` command in the monitoring namespace and instruct Helm
    to create the namespace for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s go over the output. The first part of the output lists the name of the
    release that we provided, `prometheus`, when it was deployed, the namespace, and
    the revision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part is custom notes, which can be pretty wordy. There is a lot of
    good information here about how to connect to the Prometheus server, the alert
    manager, and the `Pushgateway`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Checking the installation status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Helm doesn’t wait for the installation to complete because it may take a while.
    The `helm status` command displays the latest information on a release in the
    same format as the output of the initial `helm install` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you just care about the status without all the extra information, you can
    just `grep` for the `STATUS` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s list all the Helm releases in the `monitoring` namespace and verify that
    `prometheus` is listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you recall, Helm stores the release information in a secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to find all the Helm releases across all namespaces, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to go low-level, you can list all the secrets that have the `owner=helm`
    label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To actually extract the release data from a secret, you need to jump through
    some hoops as it is Base64-encoded twice (why?) and GZIP-compressed. The final
    result is JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also be interested in extracting just the manifests using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Customizing a chart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Very often as a user, you want to customize or configure the charts you install.
    Helm fully supports customization via config files. To learn about possible customizations,
    you can use the `helm show` command again, but this time, focus on the values.
    For a complex project like Prometheus, the `values` file can be pretty large:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a partial output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Commented-out lines often contain default values like the name of the `imagePullSecrets`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to customize any part of the Prometheus installation, then save
    the values to a file, make any modifications you like, and then install Prometheus
    using the custom values file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also set individual values on the command line with `--set`. If both
    `-f` and `--set` try to set the same values, then `--set` takes precedence. You
    can specify multiple values using comma-separated lists: `--set a=1,b=2`. Nested
    values can be set as `--set outer.inner=value`.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional installation options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `helm install` command can work with a variety of sources:'
  prefs: []
  type: TYPE_NORMAL
- en: A chart repository (as demonstrated)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A local chart archive (`helm install foo-0.1.1.tgz`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An extracted chart directory (`helm install path/to/foo`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete URL (`helm install https://example.com/charts/foo-1.2.3.tgz`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading and rolling back a release
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may want to upgrade a package you installed to the latest and greatest
    version. Helm provides the `upgrade` command, which operates intelligently and
    only updates things that have changed. For example, let’s check the current values
    of our `prometheus` installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we haven’t provided any user values. As part of the default installation,
    `prometheus` installed an alert manager component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s disable the alert manager by upgrading and passing a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The upgrade completed successfully. We can see that the output doesn’t mention
    how to get the URL of the alert manager anymore. Let’s verify that the alert manager
    deployment was removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we check the custom values, we can see our modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we decide that alerts are kind of important and, actually, we want
    to have the Prometheus alert manager. No problem, we can roll back to our original
    installation. The `helm history` command shows us all the available revisions
    we can roll back to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s roll back to revision 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the rollback actually created a new revision number 3\. Revision
    2 is still there in case we want to go back to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s verify that our changes were rolled back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Yep. The alert manager is back.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a release
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can, of course, uninstall a release too by using the `helm uninstall` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s examine the list of releases. We have only the `prometheus` release
    in the monitoring namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s uninstall it. You can use any of the following equivalent commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`uninstall`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`un`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`del`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here we are using the `uninstall` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, there are no more releases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Helm can keep track of uninstalled releases too. If you provide `--keep-history`
    when you uninstall, then you’ll be able to see uninstalled releases by adding
    the `--all` or `--uninstalled` flags to `helm list`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the monitoring namespace remained even though it was created by Helm
    as part of installing Prometheus, but it is empty now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Working with repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helm stores charts in repositories that are simple HTTP servers. Any standard
    HTTP server can host a Helm repository. In the cloud, the Helm team verified that
    AWS S3 and Google Cloud Storage can both serve as Helm repositories in web-enabled
    mode. You can even store Helm repositories on GitHub pages.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Helm doesn’t provide tools for uploading charts to remote repositories
    because that would require the remote server to understand Helm, know where to
    put the chart, and know how to update the `index.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Helm recently added experimental support for storing Helm charts in
    OCI registries. Check out [https://helm.sh/docs/topics/registries/](https://helm.sh/docs/topics/registries/)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client side, the `helm repo` command lets you list, add, remove, index,
    and update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We already used the `helm repo add` and `helm repo list` commands earlier. Let’s
    see how to create our own charts and manage them.
  prefs: []
  type: TYPE_NORMAL
- en: Managing charts with Helm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helm provides several commands to manage charts.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can create a new chart for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Helm will create the following files and directories under `cool-chart`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have edited your chart, you can package it into a `tar.gz` archive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Helm will create an archive called `cool-chart-0.1.0.tgz` and store it in the
    local directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `helm lint` to help you find issues with your chart’s formatting
    or information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Taking advantage of starter packs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `helm create` command offers an optional `--starter` flag, allowing you
    to specify a starter chart. Starters are regular charts located in `$XDG_DATA_HOME/helm/starters`.
    As a chart developer, you can create charts explicitly intended to serve as starter
    templates for creating new charts. When developing such charts, please keep the
    following considerations in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: The YAML content within a starter chart will be overwritten by the generator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users will typically modify the contents of a starter chart, so it is crucial
    to provide clear documentation explaining how users can make modifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presently, there is no built-in mechanism for installing starter charts. The
    only way to add a chart to `$XDG_DATA_HOME/helm/starters` is through manual copying.
    If you create starter pack charts, ensure that your chart’s documentation explicitly
    mentions this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A chart represents a group of files that define a cohesive set of Kubernetes
    resources. It can range from a simple deployment of a Memcached pod to a complex
    configuration of a complete web application stack, including HTTP servers, databases,
    caches, queues, and more.
  prefs: []
  type: TYPE_NORMAL
- en: To organize a chart, its files are structured within a specific directory tree.
    These files can then be bundled into versioned archives, which can be easily deployed
    and managed. The key file is `Chart.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: The Chart.yaml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Chart.yaml` file is the main file of a Helm chart. It requires a name
    and version fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apiVersion`: The API version of the chart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: The name of the chart, which should match the directory name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: The version of the chart using the `SemVer` 2 format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there are several optional fields that can be included in the
    `Chart.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubeVersion`: A range of compatible Kubernetes versions specified in `SemVer`
    format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: A brief description of the project in a single sentence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keywords`: A list of keywords associated with the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`home`: The URL of the project’s homepage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sources`: A list of URLs to the project’s source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dependencies`: A list of dependencies for the chart, including the name, version,
    repository, condition, tags, and alias.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maintainers`: A list of maintainers for the chart, including the name, email,
    and URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`icon`: The URL to an SVG or PNG image that can be used as an icon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`appVersion`: The version of the application contained within the chart. It
    does not have to follow `SemVer`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deprecated`: A boolean value indicating whether the chart is deprecated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`annotations`: Additional key-value pairs that provide extra information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning charts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `version` field in the `Chart.yaml` file plays a crucial role for various
    Helm tools. It is used by the `helm package` command when creating a package,
    as it constructs the package name based on the version specified in the `Chart.yaml`.
    It is important to ensure that the version number in the package name matches
    the version number in the `Chart.yaml` file. Deviating from this expectation can
    result in an error, as the system assumes the consistency of these version numbers.
    Therefore, it is essential to maintain the coherence between the version field
    in the `Chart.yaml` file and the generated package name to avoid any issues.
  prefs: []
  type: TYPE_NORMAL
- en: The appVersion field
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The optional `appVersion` field is not related to the `version` field. It is
    not used by Helm and serves as metadata or documentation for users that want to
    understand what they are deploying. Helm ignores it.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecating charts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From time to time, you may want to deprecate a chart. You can mark a chart
    as deprecated by setting the optional `deprecated` field in `Chart.yaml` to `true`.
    It’s enough to deprecate the latest version of a chart. You can later reuse the
    chart name and publish a newer version that is not deprecated. The workflow for
    deprecating charts typically involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Update the Chart.yaml file**: Modify the `Chart.yaml` file of the chart to
    indicate that it is deprecated. This can be done by adding a `deprecated` field
    and setting it to `true`. Additionally, it is common practice to bump the version
    of the chart to indicate that a new version with deprecation information has been
    released.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Release the new version**: Package and release the updated chart with the
    deprecation information to the chart repository. This ensures that users are aware
    of the deprecation when they try to install or upgrade the chart.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Communicate the deprecation**: It is important to communicate the deprecation
    to users and provide information on alternative options or recommended migration
    paths. This can be done through documentation, release notes, or other channels
    to ensure that users are informed about the deprecation and can plan accordingly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Remove the chart from the source repository**: Once the deprecated chart
    has been released and communicated to users, it is recommended to remove the chart
    from the source repository, such as a Git repository, to avoid confusion and ensure
    that users are directed to the latest version in the chart repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By following these steps, you can effectively deprecate a chart and provide
    a clear process for users to transition to newer versions or alternative solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Chart metadata files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Charts can include several metadata files, such as `README.md`, `LICENSE`,
    and `NOTES.txt`, which provide important information about the chart. The `README.md`
    file, formatted as markdown, is particularly crucial and should contain the following
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application or service description**: Provide a clear and concise description
    of the application or service that the chart represents. This description should
    help users understand the purpose and functionality of the chart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prerequisites and requirements**: Specify any prerequisites or requirements
    that need to be met before using the chart. This could include specific versions
    of Kubernetes, required dependencies, or other conditions that must be satisfied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YAML options and default values**: Document the available options that users
    can configure in the chart’s YAML files. Describe each option, its purpose, accepted
    values or format, and the default values. This information empowers users to customize
    the chart according to their needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Installation and configuration instructions**: Provide clear instructions
    on how to install and configure the chart. This may involve specifying the command-line
    options or Helm commands to deploy the chart and any additional steps or considerations
    during the configuration process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional information**: Include any other relevant information that may
    assist users during the installation or configuration of the chart. This could
    involve best practices, troubleshooting tips, or known limitations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By including these details in the `README.md` file, chart users can easily understand
    the chart’s purpose, requirements, and how to effectively install and configure
    it for their specific use case.
  prefs: []
  type: TYPE_NORMAL
- en: If the chart contains a template or `NOTES.txt` file, then the file will be
    displayed, printed out after installation and when viewing the release status,
    or upgraded. The notes should be concise to avoid clutter and point to the `README.md`
    file for detailed explanations. It’s common to put usage notes and next steps
    in `NOTES.txt`. Remember that the file is evaluated as a template. The notes are
    printed on the screen when you run `helm install` as well as `helm status`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing chart dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Helm, a chart may depend on other charts. These dependencies are expressed
    explicitly by listing them in the `dependencies` field of the `Chart.yaml` file
    or copied directly to the `charts/` subdirectory. This provides a great way to
    benefit from and reuse the knowledge and work of others. A dependency in Helm
    can take the form of either a chart archive (e.g., `foo-1.2.3.tgz`) or an unpacked
    chart directory. However, it’s important to note that the name of a dependency
    should not begin with an underscore (`_`) or a period (`.`), as these files are
    ignored by the chart loader. Therefore, it’s recommended to avoid starting dependency
    names with these characters to ensure they are properly recognized and loaded
    by Helm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add `kube-state-metrics` from the `prometheus-community` repo as a dependency
    to our `cool-chart`''s `Chart.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `name` field represents the desired name of the chart you want to install.
    It should match the name of the chart as it is defined in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: The `version` field specifies the specific version of the chart you want to
    install. It helps to ensure that you get the desired version of the chart.
  prefs: []
  type: TYPE_NORMAL
- en: The `repository` field contains the complete URL of the chart repository that
    the chart will be fetched from. It points to the location where the chart and
    its versions are stored and can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: The `condition` field is discussed in the subsequent section.
  prefs: []
  type: TYPE_NORMAL
- en: If the repository is not added yet use `helm repo` to add it locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your dependencies are defined, you can run the `helm dependency update`
    command. Helm will download all of the specified charts into the charts subdirectory
    for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Helm stores the dependency charts as archives in the `charts/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Managing charts and their dependencies in the `Chart.yaml` dependencies field
    (as opposed to just copying charts into the `charts/` subdirectory) is a best
    practice. It explicitly documents dependencies, facilitates sharing across the
    team, and supports automated pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing additional subfields of the dependencies field
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each entry in the `requirements.yaml` file’s `requirements` entry may include
    optional fields such as `tags` and `condition`.
  prefs: []
  type: TYPE_NORMAL
- en: These fields can be used to dynamically control the loading of charts (if not
    specified all charts will be loaded). If `tags` or `condition` fields are present,
    Helm will evaluate them and determine if the target chart should be loaded or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: The `condition` field in chart dependencies holds one or more comma-delimited
    YAML paths. These paths refer to values in the top parent’s values file. If a
    path exists and evaluates to a Boolean value, it determines whether the chart
    will be enabled or disabled. If multiple paths are provided, only the first valid
    path encountered is evaluated. If no paths exist, the condition has no effect,
    and the chart will be loaded regardless.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tags` field allows you to associate labels with the chart. It is a YAML
    list where you can specify one or more tags. In the top parent’s values file,
    you can enable or disable all charts with specific tags by specifying the tag
    and a corresponding Boolean value. This provides a convenient way to manage and
    control charts based on their associated tags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example `dependencies` field and a `values.yaml` that makes good
    use of conditions and tags to enable and disable the installation of dependencies.
    The `dependencies` field defines two conditions for installing its dependencies
    based on the value of the global enabled field and the specific subchart’s enabled
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `values.yaml` file assigns values to some of the `condition` variables.
    The `subchart2` tag doesn’t get a value, so it is enabled automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set `tags` and `condition` values from the command line too when installing
    a chart, and they’ll take precedence over the `values.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The resolution of tags and conditions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Conditions that are set in values override tags. The first `condition` path
    that exists per chart takes effect, and other conditions are ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of the tags associated with a chart are set to `true` in the top parent’s
    values, the chart is considered enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tags` and `condition` values must be set at the top level of the values
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested tags tables or tags within global configurations are not currently supported.
    This means that the tags should be directly under the top parent’s values and
    not nested within other structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using templates and values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any non-trivial application will require configuration and adaptation to the
    specific use case. Helm charts are templates that use the Go template language
    to populate placeholders. Helm supports additional functions from the Sprig library,
    which contains a lot of useful helpers as well as several other specialized functions.
    The template files are stored in the `templates/` subdirectory of the chart. Helm
    will use the template engine to render all files in this directory and apply the
    provided value files.
  prefs: []
  type: TYPE_NORMAL
- en: Writing template files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Template files are just text files that follow the Go template language rules.
    They can generate Kubernetes configuration files as well as any other file. Here
    is the service template file of the Prometheus server’s `service.yaml` template
    from the `prometheus-community` repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'It is available here: [https://github.com/prometheus-community/helm-charts/blob/main/charts/prometheus/templates/service.yaml](https://github.com/prometheus-community/helm-charts/blob/main/charts/prometheus/templates/service.yaml).'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if it looks confusing. The basic idea is that you have a simple
    text file with placeholders for values that can be populated later in various
    ways as well as conditions, some functions, and pipelines that can be applied
    to those values.
  prefs: []
  type: TYPE_NORMAL
- en: Using pipelines and functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Helm allows rich and sophisticated syntax in the template files via the built-in
    Go template functions, Sprig functions, and pipelines. Here is an example template
    that takes advantage of these capabilities. It uses the `repeat`, `quote`, and
    `upper` functions for the `food` and `drink` keys, and it uses pipelines to chain
    multiple functions together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add a `values.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Testing and troubleshooting your charts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we can use the `helm template` command to see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our templating worked. The drink `coffee` was repeated 3 times
    and quoted. The food `pizza` became uppercase `PIZZA` (unquoted).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another good way of debugging is to run `install` with the `--dry-run` flag.
    It provides additional information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also override values on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The ultimate test is, of course, to install your chart into your cluster. You
    don’t need to upload your chart to a chart repository for testing; just run `helm
    install` locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'There is now a Helm release called `food`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Most importantly, the `food-configmap` config map was created with the correct
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Embedding built-in objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Helm provides some built-in objects you can use in your templates. In the Prometheus
    chart template above, `Release.Name`, `Release.Service`, `Chart.Name`, and `Chart.Version`
    are examples of Helm predefined values. Other objects are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Values`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chart`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Template`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Files`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Capabilities`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Values` object contains all the values defined in the `values` file or
    on the command line. The `Chart` object is the content of `Chart.yaml`. The `Template`
    object contains information about the current template. `Files` and `Capabilities`
    are map-like objects that allow access via various functions to the non-specialized
    files and general information about the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Note that unknown fields in `Chart.yaml` are ignored by the template engine
    and cannot be used to pass arbitrary structured data to templates.
  prefs: []
  type: TYPE_NORMAL
- en: Feeding values from a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is part of the Prometheus server’s default `values` file. The values from
    this file are used to populate multiple templates. The values represent defaults
    that you can override by copying the file and modifying it to fit your needs.
    Note the useful comments that explain the purpose and various options for each
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: That was a deep dive into creating your own charts with Helm. Well, Helm is
    used widely and extensively to package and deploy Kubernetes applications. However,
    Helm is not the only game in town. There are several good alternatives that you
    may prefer. In the next section, we will review some of the most promising Helm
    alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Helm alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm is battle tested and very common in the Kubernetes world, but it has its
    downsides and critics, especially when you develop your own charts. A lot of the
    criticism was about Helm 2 and its server-side component, Tiller. However, Helm
    3 is not a panacea either. On a large scale, when you develop your own charts
    and complex templates with lots of conditional logic and massive `values` files,
    it can become very challenging to manage.
  prefs: []
  type: TYPE_NORMAL
- en: If you feel the pain, you may want to investigate some alternatives. Note that
    most of these projects focus on the deployment aspect. Helm’s dependency management
    is still a strength. Let’s look at some interesting projects that you may want
    to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Kustomize
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kustomize is an alternative to YAML templating by using the concept of overlays
    on top of raw YAML files. It was added to kubectl in Kubernetes 1.14.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://github.com/kubernetes-sigs/kustomize](https://github.com/kubernetes-sigs/kustomize).
  prefs: []
  type: TYPE_NORMAL
- en: Cue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cue is a very interesting project. Its data validation language and inference
    were strongly inspired by logic programming. It is not a general-purpose programming
    language. It is focused on data validation, data templating, configuration, querying,
    and code generation, but has some scripting too. The main concept of Cue is the
    unification of types and data. That gives Cue a lot of expressive power and obviates
    the need for constructs like enums and generics.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://cuelang.org](https://cuelang.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'See the specific discussion about replacing Helm with Cue here: [https://github.com/cue-lang/cue/discussions/1159](https://github.com/cue-lang/cue/discussions/1159).'
  prefs: []
  type: TYPE_NORMAL
- en: kapp-controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: kapp-controller provides continuous delivery and package management capabilities
    for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Its declarative APIs and layered approach allow you to build, deploy, and manage
    your applications effectively. With Kapp-controller, you can package your software
    into distributable packages and empower users to discover, configure, and install
    these packages on a Kubernetes cluster seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://carvel.dev/kapp-controller/](https://carvel.dev/kapp-controller/).
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our quick review of Helm alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at Helm, a popular Kubernetes package manager.
    Helm gives Kubernetes the ability to manage complicated software composed of many
    Kubernetes resources with inter-dependencies. It serves the same purpose as an
    OS package manager. It organizes packages and lets you search charts, install
    and upgrade charts, and share charts with collaborators. You can develop your
    own charts and store them in repositories. Helm 3 is a client-side-only solution
    that uses Kubernetes secrets to manage the state of releases in your cluster.
    We also looked at some Helm alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should understand the important role that Helm serves in
    the Kubernetes ecosystem and community. You should be able to use it productively
    and even develop and share your own charts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how Kubernetes does networking at a pretty
    low level.
  prefs: []
  type: TYPE_NORMAL
