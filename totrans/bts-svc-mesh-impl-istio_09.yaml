- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Extending Istio Data Plane
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Istio数据平面
- en: Istio provides various APIs to manage data plane traffic. There is one API called
    `EnvoyFilter` that we have not yet used. The `EnvoyFilter` API provides a means
    to customize the istio-proxy configuration generated by the Istio control plane.
    Using the `EnvoyFilter` API, you can directly use Envoy filters even if they are
    not directly supported by Istio APIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Istio提供了多种API来管理数据平面流量。有一个名为`EnvoyFilter`的API我们尚未使用。`EnvoyFilter` API提供了一种定制Istio控制平面生成的istio-proxy配置的方式。使用`EnvoyFilter`
    API，您可以直接使用Envoy过滤器，即使它们没有被Istio API直接支持。
- en: There is another API called `WasmPlugins`, which is another mechanism to extend
    the istio-proxy functionality **WebAssembly** (**Wasm**) support is becoming common
    for proxies such as Envoy to enable developers to build extensions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个API叫做`WasmPlugins`，它是扩展istio-proxy功能的另一种机制，**WebAssembly**（**Wasm**）支持在Envoy等代理中变得越来越常见，以便开发人员构建扩展。
- en: In this chapter, we will discuss these two topics; however, the content on `EnvoyFilter`
    will be brief, as you have already learned about filters and plugins for Envoy
    in *Chapter 3*. Rather, we will focus on how to invoke Envoy plugins from Istio
    configurations. However, we will delve deeper into Wasm with hands-on activities
    as usual.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论这两个主题；然而，关于`EnvoyFilter`的内容会简要介绍，因为您已经在*第3章*中学习了Envoy的过滤器和插件。我们将重点讲解如何从Istio配置中调用Envoy插件。但我们会像往常一样通过动手活动深入探讨Wasm。
- en: 'In this chapter we will be covering the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Why extensibility?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要可扩展性？
- en: Customizing the data plane using EnvoyFilter
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用EnvoyFilter定制数据平面
- en: Understanding the fundamentals of Wasm
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Wasm的基本原理
- en: Extending the Istio data plane using Wasm
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Wasm扩展Istio数据平面
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To keep it simple, we will be using minikube to perform the hands-on exercises
    in this chapter. By now, you must be familiar with installing and configuring
    minikube, and if not, please refer to the *Technical requirements* section of
    *Chapter 4*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化操作，我们将使用minikube来进行本章的动手练习。到目前为止，您应该已经熟悉了安装和配置minikube的步骤，如果还不熟悉，请参阅*第4章*的*技术要求*部分。
- en: 'In addition to minikube, it is good to have Go and TinyGo installed on your
    workstation. If you are new to Go, then follow the instructions at [https://go.dev/doc/install](https://go.dev/doc/install)
    to install it. Install TinyGo for your host OS by following the instructions at
    [https://tinygo.org/getting-started/install/macos/](https://tinygo.org/getting-started/install/macos/).
    Then validate the installation by using the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了minikube外，最好在工作站上安装Go和TinyGo。如果您是Go的新手，请按照[https://go.dev/doc/install](https://go.dev/doc/install)中的说明进行安装。根据[https://tinygo.org/getting-started/install/macos/](https://tinygo.org/getting-started/install/macos/)的说明为您的主机操作系统安装TinyGo。然后，通过以下命令验证安装是否成功：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Why extensibility
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要可扩展性？
- en: 'As with any good architecture, **extensibility** is very important because
    there is no *one size fits all* approach to technology that can adapt to every
    application. Extensibility is important in Istio as it provides options to users
    to build corner cases and extend Istio as per their individual needs. In the early
    days of Istio and Envoy, the projects took different approaches to build extensibility.
    Istio took the approach of building a generic out-of-process extension model called
    **Mixer** ([https://istio.io/v1.6/docs/reference/config/policy-and-telemetry/mixer-overview/](https://istio.io/v1.6/docs/reference/config/policy-and-telemetry/mixer-overview/)),
    whereas Envoy focused on in-proxy extensions ([https://www.envoyproxy.io/docs/envoy/latest/extending/extending](https://www.envoyproxy.io/docs/envoy/latest/extending/extending)).
    Mixer is now deprecated; it was a plugin-based implementation used for building
    extensions (also called adaptors) for various infrastructure backends. Some examples
    of adapters are Bluemix, AWS, Prometheus, Datadog, and SolarWinds. These adapters
    allowed Istio to interface with various kinds of backend systems for logging,
    monitoring, and telemetry, but the adapter-based extension model suffered from
    significant resource inefficiencies that impacted tail latencies and resource
    utilization. This model was also intrinsically limited and had limited application.
    The Envoy extension approach required users to write filters in C++, which is
    also Envoy’s native language. Extensions written in C++ are then packaged along
    with Envoy’s code base, compiled, and tested to make sure that they are working
    as expected. The in-proxy extension approach for Envoy imposed a constraint of
    writing extensions in C++ followed by a monolithic build process and the fact
    that you must now maintain the Envoy code base yourself. Some bigger organizations
    were able to manage their own copy of the Envoy code base, but most of the Envoy
    community found this approach impractical. So, Envoy adopted other approaches
    for building extensions, one being **Lua-based filters** and the other being Wasm
    extensions. In Lua-based extensions, users can write inline Lua code in an existing
    Envoy HTTP Lua filter. The following is an example of a Lua filter; the Lua script
    has been highlighted:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何好的架构一样，**可扩展性**非常重要，因为没有 *一刀切* 的技术方法能够适应每个应用程序的需求。可扩展性在 Istio 中尤为重要，因为它为用户提供了构建特殊情况和根据个人需求扩展
    Istio 的选项。在 Istio 和 Envoy 的早期，两个项目采取了不同的方式来构建可扩展性。Istio 采用了构建通用的进程外扩展模型——**Mixer**（[https://istio.io/v1.6/docs/reference/config/policy-and-telemetry/mixer-overview/](https://istio.io/v1.6/docs/reference/config/policy-and-telemetry/mixer-overview/)），而
    Envoy 则专注于代理内扩展（[https://www.envoyproxy.io/docs/envoy/latest/extending/extending](https://www.envoyproxy.io/docs/envoy/latest/extending/extending)）。Mixer
    现在已被弃用；它是一种基于插件的实现，用于构建各种基础设施后端的扩展（也称为适配器）。一些适配器的例子包括 Bluemix、AWS、Prometheus、Datadog
    和 SolarWinds。这些适配器使 Istio 能够与各种后端系统进行接口，以进行日志记录、监控和遥测，但基于适配器的扩展模型存在显著的资源低效问题，影响了尾延迟和资源利用率。这个模型本身也有局限性，应用场景有限。Envoy
    的扩展方法要求用户用 C++ 编写过滤器，而 C++ 也是 Envoy 的本地语言。用 C++ 编写的扩展会与 Envoy 的代码一起打包、编译并进行测试，确保它们按预期工作。Envoy
    的代理内扩展方法要求在 C++ 中编写扩展，随后进行单体构建过程，并且你必须自己维护 Envoy 的代码库。一些大型组织能够管理自己版本的 Envoy 代码库，但大多数
    Envoy 社区成员认为这种方法不可行。因此，Envoy 采取了其他构建扩展的方法，其中一个是 **基于 Lua 的过滤器**，另一个是 Wasm 扩展。在基于
    Lua 的扩展中，用户可以在现有的 Envoy HTTP Lua 过滤器中编写内联 Lua 代码。以下是一个 Lua 过滤器的示例；Lua 脚本已被突出显示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, we are using the `envoy_on_request` and/or `envoy_on_response`
    functions, which are then executed as coroutines on the request and response cycles,
    respectively. You can write Lua code in these functions to perform the following
    during request/response processing:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了 `envoy_on_request` 和/或 `envoy_on_response` 函数，这些函数分别在请求和响应周期上作为协程执行。你可以在这些函数中编写
    Lua 代码，以在请求/响应处理过程中执行以下操作：
- en: Inspection and modification of headers, body, and trailers of request and response
    flows
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查和修改请求和响应流的头部、主体和尾部
- en: Asynchronous HTTP invocation of upstream systems
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步 HTTP 调用上游系统
- en: Performing direct response and skipping further filter iteration
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行直接响应并跳过进一步的过滤器迭代
- en: You can read more about Envoy HTTP Lua filters at [https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/lua_filter.html?highlight=lua%20filter](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/lua_filter.html?highlight=lua%20filter).
    This approach is great for simple logic, but when writing complex processing instructions
    then writing inline Lua code is not practical. Inline code cannot be easily shared
    with other developers or easily aligned with best practices of software programming.
    The other drawback is the lack of flexibility, as developers are obliged to only
    use Lua, which inhibits non-Lua developers from writing these extensions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/lua_filter.html?highlight=lua%20filter](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/lua_filter.html?highlight=lua%20filter)
    阅读更多关于 Envoy HTTP Lua 过滤器的内容。这种方法适合简单的逻辑，但当编写复杂的处理指令时，编写内联 Lua 代码就不太实际。内联代码不容易与其他开发人员共享，也不容易与软件编程的最佳实践对齐。另一个缺点是缺乏灵活性，因为开发人员只能使用
    Lua，这限制了非 Lua 开发人员编写这些扩展的能力。
- en: To provide extensibility to Istio, an approach that imposed fewer tradeoffs
    was needed. As Istio’s data plane comprises Envoy, it made sense to converge on
    a common approach for extensibility for Envoy and Istio. This can decouple Envoy
    releases from their extension ecosystem, enables Istio consumers to build data
    plane extensions using their languages of choice, using best-of-breed programming
    languages and practices, and then deploy these extensions without causing any
    downtime risk to their Istio deployments in production. Based on this common effort,
    Wasm support for Istio was introduced. In the upcoming sections, we will discuss
    Wasm. But before that, let’s quickly touch on Istio support for running Envoy
    filters in the next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给 Istio 提供可扩展性，需要一种带来更少权衡的方案。由于 Istio 的数据平面由 Envoy 组成，因此将 Envoy 和 Istio 的扩展性统一起来是有意义的。这可以将
    Envoy 的发布与其扩展生态系统解耦，使 Istio 用户能够使用自己选择的语言构建数据平面扩展，利用最佳的编程语言和实践，然后部署这些扩展，而不会对生产环境中的
    Istio 部署造成任何停机风险。在这个共同努力的基础上，Wasm 支持已被引入 Istio。在接下来的部分中，我们将讨论 Wasm。但在那之前，让我们快速回顾一下
    Istio 对运行 Envoy 过滤器的支持。
- en: Customizing the data plane using Envoy Filter
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Envoy Filter 自定义数据平面
- en: Istio provides an `EnvoyFilter` API, which provides options to modify configurations
    created via other Istio `EnvoyFilter` CRD, you can change those low-level configurations
    directly. This is a very powerful feature but also should be used cautiously as
    it has the potential to make things worse if not used correctly. Using `EnvoyFilter`,
    you can apply configurations that are not directly available in Istio CRDs and
    perform more advanced Envoy functions. The filter can be applied at the namespace
    level as well as selective workload levels identified by labels.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 提供了 `EnvoyFilter` API，允许修改通过其他 Istio `EnvoyFilter` CRD 创建的配置，你可以直接更改这些低级配置。这是一个非常强大的功能，但也应该小心使用，因为如果使用不当，可能会导致更糟的结果。通过使用
    `EnvoyFilter`，你可以应用 Istio CRD 中没有直接提供的配置，并执行更高级的 Envoy 功能。该过滤器可以在命名空间级别以及通过标签标识的特定工作负载级别上应用。
- en: Let’s try to understand this further via an example.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来进一步理解这个问题。
- en: 'We will pick one of the hands-on exercises we performed in *Chapter 7* to route
    a request to `hhtppbin.org`. Do not forget to create the `Chapter09` folder and
    turn on `istio-injection`. The following commands will deploy the `httpbin` Pod
    as described in `Chapter09/01-httpbin-deployment.yaml`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选取在 *第7章* 中执行的一个实际操作来将请求路由到 `httpbin.org`。不要忘记创建 `Chapter09` 文件夹并开启 `istio-injection`。以下命令将按照
    `Chapter09/01-httpbin-deployment.yaml` 中的描述部署 `httpbin` Pod：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Carefully check all the response fields containing all the headers passed in
    the request.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查所有响应字段，确保包含请求中传递的所有头部信息。
- en: Using `EnvoyFilter`, we will add a custom header to the request before sending
    it to the `httpbin` Pod. For this example, let’s pick the `ChapterName` header
    name and set its value to `ExtendingIstioDataPlane`. The configuration in `Chapter09/02-httpbinenvoyfilter-httpbin.yaml`
    adds the custom header to the request.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `EnvoyFilter`，我们将在请求发送到 `httpbin` Pod 之前添加一个自定义头部。对于这个示例，我们选择 `ChapterName`
    作为头部名称，并将其值设置为 `ExtendingIstioDataPlane`。`Chapter09/02-httpbinenvoyfilter-httpbin.yaml`
    中的配置会将自定义头部添加到请求中。
- en: 'Apply the following configuration using `EnvoyFilter`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `EnvoyFilter` 应用以下配置：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s go through `Chapter09/02-httpbinenvoyfilter-httpbin.yaml` in two parts:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分两部分来讲解`Chapter09/02-httpbinenvoyfilter-httpbin.yaml`：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this part, we will create an EnvoyFilter named `updateheaderforhttpbin` in
    the `chapter09` namespace, which will be applied to the workload which has the
    `app` label with a `httpbin` value. For that configuration, we are applying a
    configuration patch to all inbound traffic to the Istio sidecar aka istio-proxy
    aka Envoy for port `80` of the `httpbin` Pod. The configuration patch is applied
    to `HTTP_FILTER` and, in particular, to the HTTP router filter of the `http_connection_manager`
    network filter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将在 `chapter09` 命名空间中创建一个名为 `updateheaderforhttpbin` 的 EnvoyFilter，它将应用于具有
    `app` 标签且值为 `httpbin` 的工作负载。对于该配置，我们正在为 `httpbin` Pod 的端口 `80` 上的所有传入流量应用配置补丁，该流量会传递到
    Istio 侧车即 istio-proxy 即 Envoy。该配置补丁应用于 `HTTP_FILTER`，特别是应用于 `http_connection_manager`
    网络过滤器的 HTTP 路由过滤器。
- en: 'In the next part of the EnvoyFilter configuration, we apply configuration before
    the existing route configuration and, in particular, we are appending a Lua filter
    with inline code as specified in the `inlineCode` section. The Lua code runs during
    the `envoy_on_request` phase and adds a request header with the `X-ChapterName`
    name and the `ExtendingIstioDataPlane` value:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EnvoyFilter 配置的下一部分，我们在现有路由配置之前应用配置，特别是我们正在附加一个包含内联代码的 Lua 过滤器，正如 `inlineCode`
    部分所指定的那样。Lua 代码在 `envoy_on_request` 阶段运行，并添加一个请求头，名称为 `X-ChapterName`，值为 `ExtendingIstioDataPlane`：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, go ahead and test the endpoint using the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续使用以下命令测试端点：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You will receive the added headers in the response.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在响应中收到已添加的头部信息。
- en: 'You can see the final Envoy config applied using the following commands. To
    find the exact name of the `httpbin` Pod, you can make use of `proxy-status`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令查看应用的最终 Envoy 配置。要找到 `httpbin` Pod 的确切名称，可以使用 `proxy-status`：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is followed by the `proxy-config` details for listeners:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是监听器的 `proxy-config` 详细信息：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the output, look for `envoy.lua`, which is the name of the patch and the
    filter we applied via the config. In the output, look for `filterChainMatch` and
    for `destinationPort` set to `80`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，查找 `envoy.lua`，这是我们通过配置应用的补丁和过滤器的名称。在输出中，查找 `filterChainMatch` 和设置为 `80`
    的 `destinationPort`：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We applied the config via EnvoyFilter:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 EnvoyFilter 应用了该配置：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Hopefully, that gave you an idea of EnvoyFilter and how the overall mechanism
    works. In the hands-on exercise for this chapter, another example applies the
    same changes but at the Ingress gateway level. You can find the example at `Chapter09/03-httpbinenvoyfilter-httpbiningress.yaml`.
    Make sure that you delete the `Chapter09/02-httpbinenvoyfilter-httpbin.yaml` file
    before applying the Ingress gateway changes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这给了你一些关于 EnvoyFilter 以及整体机制如何工作的想法。在本章的动手练习中，另一个示例应用相同的更改，但在 Ingress 网关层级。你可以在
    `Chapter09/03-httpbinenvoyfilter-httpbiningress.yaml` 文件中找到该示例。在应用 Ingress 网关更改之前，请确保删除
    `Chapter09/02-httpbinenvoyfilter-httpbin.yaml` 文件。
- en: For more details about the various configurations of EnvoyFilter, please refer
    to the Istio documentation at [https://istio.io/latest/docs/reference/config/networking/envoy-filter/#EnvoyFilter-EnvoyConfigObjectPatch](https://istio.io/latest/docs/reference/config/networking/envoy-filter/#EnvoyFilter-EnvoyConfigObjectPatch).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多有关 EnvoyFilter 各种配置的详细信息，请参考 Istio 文档：[https://istio.io/latest/docs/reference/config/networking/envoy-filter/#EnvoyFilter-EnvoyConfigObjectPatch](https://istio.io/latest/docs/reference/config/networking/envoy-filter/#EnvoyFilter-EnvoyConfigObjectPatch)。
- en: Important note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'For cleanup, use this command: `kubectl delete` `ns chapter09`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 清理时，请使用此命令：`kubectl delete` `ns chapter09`。
- en: In the next section, we will read about Wasm fundamentals, followed by how to
    use Wasm to extend the Istio data plane.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将学习 Wasm 基础知识，然后了解如何使用 Wasm 扩展 Istio 数据平面。
- en: Understanding the fundamentals of Wasm
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Wasm 基础知识
- en: Wasm is a portable binary format designed to run on **virtual machines** (**VMs**),
    allowing it to run on various computer hardware and digital devices, and is very
    actively used to improve the performance of web applications. It is a virtual
    **instruction set architecture** (**ISA**) for a stack machine designed to be
    portable, compact, and secure with a smaller binary file size to reduce download
    times when executed on web browsers. A modern browser’s JavaScript engines can
    parse and download the Wasm binary format in order of magnitude faster than JavaScript.
    All major browser vendors have adopted Wasm, and as per the Mozilla Foundation,
    Wasm code runs between 10% and 800% faster than the equivalent JavaScript code.
    It provides faster startup time and higher peak performance without memory bloat.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Wasm是一种便携式二进制格式，旨在运行在**虚拟机**（**VMs**）上，使其能够在各种计算机硬件和数字设备上运行，并且在提升Web应用性能方面被广泛应用。它是为堆栈机设计的虚拟**指令集架构**（**ISA**），旨在便携、紧凑且安全，具有较小的二进制文件大小，能够减少在Web浏览器执行时的下载时间。现代浏览器的JavaScript引擎能够比JavaScript解析和下载Wasm二进制格式快几个数量级。所有主要浏览器厂商都已支持Wasm，Mozilla基金会表示，Wasm代码运行速度比等效的JavaScript代码快10%到800%。它提供了更快的启动时间和更高的峰值性能，且不会造成内存膨胀。
- en: 'Wasm is also a preferred and practical choice for building extensions for Envoy
    for the following reasons:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Wasm也是构建Envoy扩展的首选且实用的选择，原因如下：
- en: Wasm extensions can be delivered at runtime without needing to restart istio-proxy.
    Furthermore, the extension can be loaded to istio-proxy through various means
    without needing any changes to istio-proxy. This allows the delivery of changes
    to the extension and changes to proxy behavior in the form of extensions without
    any outages.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wasm扩展可以在运行时交付，而无需重新启动istio-proxy。此外，扩展可以通过多种方式加载到istio-proxy，而无需对istio-proxy进行任何更改。这使得能够以扩展的形式交付对扩展和代理行为的更改，而无需任何停机。
- en: Isolated from the host and executed in a sandbox/VM environment, Wasm communicates
    with the host machine via an **application binary interface** (**ABI**). Through
    ABIs, we can control what can and cannot be modified and what is visible to the
    extension.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wasm与宿主机隔离，并在沙箱/虚拟机环境中执行，通过**应用程序二进制接口**（**ABI**）与宿主机通信。通过ABI，我们可以控制哪些内容可以或不能修改，以及哪些内容对扩展可见。
- en: Another benefit of running Wasm in a sandbox environment is the isolation and
    defined fault boundaries. If anything goes wrong with Wasm execution, then the
    scope of disruption is limited to the sandbox and won’t spread to the host process.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在沙箱环境中运行Wasm的另一个好处是隔离性和定义的故障边界。如果Wasm执行出现问题，干扰的范围将仅限于沙箱内，不会扩展到宿主进程。
- en: '![Figure 9.1 – An overview of Wasm](img/B17989_09_01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – Wasm概述](img/B17989_09_01.jpg)'
- en: Figure 9.1 – An overview of Wasm
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – Wasm概述
- en: There are over thirty programming languages that support compilation to Wasm
    modules. Some examples are C, Java, Go, Rust, C++, and TypeScript. This allows
    most developers to build Istio extensions using the programming language of their
    choice.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 超过三十种编程语言支持编译为Wasm模块。一些示例包括C、Java、Go、Rust、C++和TypeScript。这使得大多数开发人员能够使用他们选择的编程语言来构建Istio扩展。
- en: To get familiar with Wasm, we will build a sample application using Go. The
    source code is available in the `Chapter09/go-Wasm-example` folder.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉Wasm，我们将使用Go构建一个示例应用程序。源代码位于`Chapter09/go-Wasm-example`文件夹中。
- en: 'The problem statement is to build an HTML page that takes a string in lowercase
    and provides the output in uppercase. We assume that you have some experience
    working with Go and that it is installed in your hands-on environment. If you
    don’t want to use Go, then try implementing the example using the language of
    your choice:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 问题陈述是构建一个HTML页面，该页面接受一个小写字符串，并提供大写输出。我们假设你已经有一些Go的工作经验，并且Go已安装在你的实践环境中。如果你不想使用Go，可以尝试使用你选择的语言实现该示例：
- en: 'Copy the code from `Chapter09/go-Wasm-example` and reinitialize the Go module:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Chapter09/go-Wasm-example`复制代码，并重新初始化Go模块：
- en: '[PRE11]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'First, let’s check `Chapter09/go-Wasm-example/cmd/Wasm/main.go`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检查`Chapter09/go-Wasm-example/cmd/Wasm/main.go`：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`done := make(chan struct{}, 0)` and `<-done` is a Go channel. A Go channel
    is used for communication between concurrent functions.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`done := make(chan struct{}, 0)`和`<-done`是Go通道。Go通道用于并发函数之间的通信。'
- en: '`js.Global().Set("WasmHash", hash)` exposes the Go hash function to JavaScript.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`js.Global().Set("WasmHash", hash)`将Go哈希函数暴露给JavaScript。'
- en: The `convertToUpper` function takes a string as an argument, which is then typecasted
    using the `.String()` function from the `syscall/js` package. The `strings.ToUpper(args[0].String())`
    line converts all arguments provided by JavaScript into an uppercase string and
    returns it as output of the function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`convertToUpper`函数将一个字符串作为参数传入，参数随后使用`syscall/js`包中的`.String()`函数进行类型转换。`strings.ToUpper(args[0].String())`这一行将JavaScript提供的所有参数转换为大写字符串，并将其作为函数的输出返回。'
- en: 'The next step is to compile `Chapter09/go-Wasm-example/cmd/Wasm/main.go` using
    the following command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用以下命令编译`Chapter09/go-Wasm-example/cmd/Wasm/main.go`：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The secret recipe here is `GOOS=js GOARCH=Wasm`, which tells the Go compiler
    to compile for JavaScript as the target host and Wasm as the target architecture.
    Without this, the Go compiler will compile for the target OS and architecture
    as per your workstation specifications. You can find more about the possible values
    of `GOOS` and `GOARCH` at [https://gist.github.com/asukakenji/f15ba7e588ac42795f421b48b8aede63](https://gist.github.com/asukakenji/f15ba7e588ac42795f421b48b8aede63).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的秘密配方是`GOOS=js GOARCH=Wasm`，它告诉Go编译器将目标主机设为JavaScript，目标架构设为Wasm。如果没有这一步，Go编译器将根据你的工作站规格编译成目标操作系统和架构。你可以在[https://gist.github.com/asukakenji/f15ba7e588ac42795f421b48b8aede63](https://gist.github.com/asukakenji/f15ba7e588ac42795f421b48b8aede63)查看有关`GOOS`和`GOARCH`的更多信息。
- en: The command will then produce the Wasm file with the `main.Wasm` name in the
    static folder.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，命令将在静态文件夹中生成名为`main.Wasm`的Wasm文件。
- en: We also need to fetch and execute Wasm in the browser. Luckily, Go makes that
    possible with `Wasm_exec.js`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在浏览器中获取并执行Wasm。幸运的是，Go通过`Wasm_exec.js`实现了这一功能。
- en: 'The JavaScript file can be found in the `GOROOT` folder. To copy it to the
    static directory, use the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript文件可以在`GOROOT`文件夹中找到。要将其复制到静态目录，请使用以下命令：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have Wasm and JavaScript to load and execute Wasm in the browser. We need
    to create an HTML page and then load JavaScript from there. You will find the
    sample HTML page at `Chapter09/go-Wasm-example/static/index.html`. You will find
    the following snippet in the HTML to load JavaScript and instantiate Wasm:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有Wasm和JavaScript来加载并在浏览器中执行Wasm。我们需要创建一个HTML页面并从中加载JavaScript。你将在`Chapter09/go-Wasm-example/static/index.html`中找到示例HTML页面。在HTML中你会看到以下代码片段来加载JavaScript并实例化Wasm：
- en: '[PRE15]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As the last step, we need a web server. You can use `nginx` or a sample HTTP
    server package with the sample code at `Chapter09/go-Wasm-example/cmd/webserver/main.go`.
    Run the server using the following command:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步，我们需要一个Web服务器。你可以使用`nginx`或使用`Chapter09/go-Wasm-example/cmd/webserver/main.go`中的示例HTTP服务器包。使用以下命令运行服务器：
- en: '[PRE16]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Open [http://localhost:3000/index.html](http://localhost:3000/index.html) in
    a browser and test that whatever lowercase letters you type in the text box are
    converted to uppercase:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开[http://localhost:3000/index.html](http://localhost:3000/index.html)，并测试在文本框中输入的小写字母是否会被转换为大写字母：
- en: "![Figure 9.2 – \uFEFFGo used to create Wasm](img/B17989_09_02.jpg)"
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 使用Go创建Wasm](img/B17989_09_02.jpg)'
- en: Figure 9.2 – Go used to create Wasm
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 使用Go创建Wasm
- en: This concludes the introduction to Wasm, and I hope you have acquired a basic
    understanding of Wasm after reading this section. In the next section, we will
    learn about how Wasm helps to extend the Istio data plane.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了Wasm的基本知识，希望你在阅读后已经对Wasm有了初步的了解。在下一节中，我们将学习Wasm如何帮助扩展Istio数据平面。
- en: Extending the Istio data plane using Wasm
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Wasm扩展Istio数据平面
- en: The main goal for Wasm was to enable high-performance applications on web pages,
    and hence Wasm was originally designed for execution in web browsers. There is
    a **World Wide Web Consortium** (**W3C**) working group for Wasm, whose details
    are available at [https://www.w3.org/Wasm/](https://www.w3.org/Wasm/). The working
    group manages the Wasm specification available at [https://www.w3.org/TR/Wasm-core-1/](https://www.w3.org/TR/Wasm-core-1/)
    and [https://www.w3.org/TR/Wasm-core-2/](https://www.w3.org/TR/Wasm-core-2/).
    Most internet browsers have implemented the specification, and you can find details
    for Google Chrome at [https://chromestatus.com/feature/5453022515691520](https://chromestatus.com/feature/5453022515691520).
    Mozilla Foundation also maintains browser compatibility at [https://developer.mozilla.org/en-US/docs/WebAssembly#browser_compatibility](https://developer.mozilla.org/en-US/docs/WebAssembly#browser_compatibility).
    When it comes to supporting the execution of Wasm on layer 4 and 7 proxies, most
    of the effort is recent. When executing Wasm on proxies, we need a way to communicate
    with the host environment. Similar to how web browsers are developed, Wasm should
    be written once, after which it should be able to run on any proxy.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Wasm的主要目标是实现高性能的网页应用，因此Wasm最初是为在网页浏览器中执行而设计的。Wasm有一个**万维网联盟**（**W3C**）工作组，详情可以在[https://www.w3.org/Wasm/](https://www.w3.org/Wasm/)查看。该工作组管理Wasm规范，具体内容可见[https://www.w3.org/TR/Wasm-core-1/](https://www.w3.org/TR/Wasm-core-1/)和[https://www.w3.org/TR/Wasm-core-2/](https://www.w3.org/TR/Wasm-core-2/)。大多数互联网浏览器已经实现了该规范，Google
    Chrome的相关信息可以在[https://chromestatus.com/feature/5453022515691520](https://chromestatus.com/feature/5453022515691520)找到。Mozilla基金会还维护浏览器兼容性，详情请参见[https://developer.mozilla.org/en-US/docs/WebAssembly#browser_compatibility](https://developer.mozilla.org/en-US/docs/WebAssembly#browser_compatibility)。关于在第四层和第七层代理上支持Wasm执行的工作，大多数工作是最近才开始的。在代理上执行Wasm时，我们需要与主机环境进行通信的方式。与网页浏览器的开发类似，Wasm应该只编写一次，之后可以在任何代理上运行。
- en: Introducing Proxy-Wasm
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Proxy-Wasm
- en: For Wasm to communicate with the host environment and the development of Wasm
    to be agnostic of the underlying host environment, there is a `Proxy-Wasm` specification,
    also known as Wasm for proxies. The specification is made up of `Proxy-Wasm` ABIs,
    which are low-level. The specification is then abstracted in high-level languages,
    called `Proxy-Wasm` `Proxy-Wasm` ABI specification in the form of the `Proxy-Wasm`
    modules.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Wasm能够与主机环境通信，并使Wasm的开发与底层主机环境无关，存在一个`Proxy-Wasm`规范，也称为代理用Wasm。该规范由`Proxy-Wasm`
    ABI组成，属于低级别接口。然后，这些规范会在高级语言中抽象出来，形成`Proxy-Wasm`模块，即`Proxy-Wasm` ABI规范。
- en: The concepts of `Proxy-Wasm` can be difficult to understand. To make it easy
    to digest them, let’s break them down into the following sections and go through
    them one by one.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Proxy-Wasm`的概念可能很难理解。为了让它们更易于消化，我们将其分解成以下几个部分，并逐一讲解。'
- en: Proxy-Wasm ABI
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Proxy-Wasm ABI
- en: 'ABI is a low-level interface specification that describes how Wasm communicates
    with the VM and host. The specification details are available at [https://github.com/proxy-Wasm/spec/blob/master/abi-versions/vNEXT/README.md](https://github.com/proxy-Wasm/spec/blob/master/abi-versions/vNEXT/README.md),
    and the specification itself is available at [https://github.com/proxy-Wasm/spec](https://github.com/proxy-Wasm/spec).
    To understand the API, it is best to go through some of the most commonly used
    methods of the ABI specification to appreciate what it does:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ABI是一种低级接口规范，描述了Wasm如何与虚拟机和主机进行通信。规范的详细信息可以在[https://github.com/proxy-Wasm/spec/blob/master/abi-versions/vNEXT/README.md](https://github.com/proxy-Wasm/spec/blob/master/abi-versions/vNEXT/README.md)找到，规范本身可以在[https://github.com/proxy-Wasm/spec](https://github.com/proxy-Wasm/spec)查看。为了理解API，最好先了解ABI规范中一些最常用的方法，从而理解它的作用：
- en: '`_start`: This function needs to be implemented on Wasm and will be called
    when Wasm is loaded and initialized.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_start`：此函数需要在Wasm中实现，并且在Wasm加载和初始化时会被调用。'
- en: '`proxy_on_vm_start`: This is called when the host machine starts the Wasm VM.
    Wasm can use this method to retrieve any configuration details of the VM.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_on_vm_start`：当主机机器启动Wasm虚拟机时调用此方法。Wasm可以使用此方法来检索虚拟机的任何配置详情。'
- en: '`proxy_on_configure`: This is called when the host environment starts the plugin,
    which loads Wasm. Using this method, Wasm can retrieve any plugin-related configuration.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_on_configure`：当主机环境启动插件并加载Wasm时调用此方法。通过此方法，Wasm可以检索与插件相关的任何配置。'
- en: '`proxy_on_new_connection`: This is a level 4 extension that is called when
    a TCP connection is established between the proxy and the client.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_on_new_connection`: 这是一个级别为4的扩展，当代理与客户端之间建立TCP连接时调用。'
- en: '`proxy_on_downstream_data`: This is a level 4 extension that is called for
    each data chunk received from the client.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_on_downstream_data`: 这是一个级别为4的扩展，当从客户端接收到每个数据块时调用。'
- en: '`proxy_on_downstream_close`: This is a level 4 extension that is called when
    the connection with downstream is closed.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_on_downstream_close`: 这是一个级别为4的扩展，当与下游的连接关闭时调用。'
- en: '`proxy_on_upstream_data`: This is a level 4 extension that is called for each
    data chunk received from upstream.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_on_upstream_data`: 这是一个级别为4的扩展，当从上游接收到每个数据块时调用。'
- en: '`proxy_on_upstream_close`: This is a level 4 extension that is called when
    the connection with upstream is closed.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_on_upstream_close`: 这是一个级别为4的扩展，当与上游的连接关闭时调用。'
- en: '`proxy_on_http_request_headers`: This is a level 7 extension that is called
    when HTTP request headers are received from the client.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_on_http_request_headers`: 这是一个级别为7的扩展，在从客户端接收到HTTP请求头时调用。'
- en: '`proxy_on_http_request_body`: This is a level 7 extension that is called when
    the HTTP request body is received from the client.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_on_http_request_body`: 这是一个级别为7的扩展，在从客户端接收到HTTP请求体时调用。'
- en: '`proxy_on_http_response_headers`: This is a level 7 extension that is called
    when HTTP response headers are received from upstream.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_on_http_response_headers`: 这是一个级别为7的扩展，在从上游接收到HTTP响应头时调用。'
- en: '`proxy_on_http_response_body`: This is a level 7 extension that is called when
    the HTTP response body is received from upstream.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_on_http_response_body`: 这是一个级别为7的扩展，在从上游接收到HTTP响应体时调用。'
- en: '`proxy_send_http_response`: This is also a level 7 extension that is implemented
    in the host environment, Envoy. Using this method, Wasm can instruct Envoy to
    send an HTTP response without actually calling the upstream services.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_send_http_response`: 这也是一个级别为7的扩展，在主机环境Envoy中实现。使用这种方法，Wasm可以指示Envoy在不实际调用上游服务的情况下发送HTTP响应。'
- en: 'This list doesn’t cover all methods in the ABI, but we hope it gave you a good
    understanding of what the ABI is used for. The following diagram illustrates what
    we covered in this section:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表并未涵盖ABI中的所有方法，但我们希望它能让您对ABI的用途有所了解。以下图表说明了我们在本节中涵盖的内容：
- en: '![Figure 9.3 – Proxy-wasm ABI](img/B17989_09_03.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 代理Wasm ABI](img/B17989_09_03.jpg)'
- en: Figure 9.3 – Proxy-wasm ABI
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 代理Wasm ABI
- en: 'If we analyze this diagram in the context of Envoy, we arrive at the following
    interpretation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Envoy的背景下分析这个图表，我们可以得出以下解释：
- en: Native extensions execute in the order specified in the configuration.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地扩展按照配置文件中指定的顺序执行。
- en: There is also a native extension in Envoy for loading Wasm, specified at [https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/Wasm/v3/Wasm.proto](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/Wasm/v3/Wasm.proto).
    The extension is responsible for loading and asking Envoy to execute Wasm.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Envoy还为加载Wasm提供了一个本地扩展，详见[https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/Wasm/v3/Wasm.proto](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/Wasm/v3/Wasm.proto)。该扩展负责加载并请求Envoy执行Wasm。
- en: Envoy executes Wasm on a VM.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Envoy在虚拟机上执行Wasm。
- en: During execution, Wasm can interact with the request, VM, and Envoy via the
    `Proxy-Wasm` ABI, and we saw some of those interaction points earlier in the section.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行过程中，通过`Proxy-Wasm` ABI，Wasm可以与请求、虚拟机和Envoy进行交互，我们在本节的早些时候看到了一些这些交互点。
- en: Once Wasm completes execution, the execution flows back to other native extensions
    defined in the configuration file.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦Wasm执行完成，执行流程将返回到配置文件中定义的其他本地扩展。
- en: While ABIs are elaborate, they are also very low-level and not programmer-friendly,
    who usually prefer writing code in high-level programming languages. In the following
    section, we will read about how the Proxy-Wasm SDK can solve this problem.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ABI很复杂，但它们也非常低级且不适合程序员使用，通常他们更喜欢在高级编程语言中编写代码。在下一节中，我们将了解代理Wasm SDK如何解决这个问题。
- en: Proxy-Wasm SDK
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代理Wasm SDK
- en: Proxy-Wasm SDK is a higher-level abstraction of the Proxy-Wasm ABI and is implemented
    in various programming languages. Proxy-Wasm SDK complies with the ABI so that
    when creating Wasm, you don’t need to know about the Proxy-Wasm ABI. At the time
    of writing this chapter, there are SDKs of the Proxy-Wasm API in Go with TinyGo
    compiler, Rust, C++, and AssemblyScript. Similar to what we did for ABIs, we will
    pick SDKs for one of the languages and go through it to understand the correlation
    between the ABI and the SDK. So, let’s go through some of the functions in the
    Proxy-Wasm Go SDK to get a feel of them; the SDK is available at [https://pkg.go.dev/github.com/tetratelabs/proxy-Wasm-go-SDK/proxyWasm](https://pkg.go.dev/github.com/tetratelabs/proxy-Wasm-go-SDK/proxyWasm).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Proxy-Wasm SDK 是 Proxy-Wasm ABI 的高级抽象，已在多种编程语言中实现。Proxy-Wasm SDK 遵循 ABI，这样在创建
    Wasm 时，你不需要了解 Proxy-Wasm ABI。撰写本章时，Proxy-Wasm API 的 SDK 已在 Go（使用 TinyGo 编译器）、Rust、C++
    和 AssemblyScript 中提供。与我们对 ABI 所做的类似，我们将选择其中一种语言的 SDK，并进行分析，以了解 ABI 与 SDK 之间的关系。因此，让我们通过一些
    Proxy-Wasm Go SDK 中的函数来感受它；该 SDK 可以在 [https://pkg.go.dev/github.com/tetratelabs/proxy-Wasm-go-SDK/proxyWasm](https://pkg.go.dev/github.com/tetratelabs/proxy-Wasm-go-SDK/proxyWasm)
    找到。
- en: 'First, you need to understand the various types defined in the SDK, so we have
    provided the following list of the fundamental ones:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要了解 SDK 中定义的各种类型，因此我们提供了以下基础类型的列表：
- en: '`VMContext`: This corresponds to each Wasm VM. For every Wasm VM, there is
    one and only one `VMContext`. `VMContext` has the following methods:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VMContext`：对应于每个 Wasm 虚拟机（VM）。对于每个 Wasm 虚拟机，只有一个 `VMContext`。`VMContext` 具有以下方法：'
- en: '`OnVMStart(vmConfigurationSize int) OnVMStartStatus`: This method is called
    when the VM is created. From within this method, Wasm can retrieve the VM configuration.'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnVMStart(vmConfigurationSize int) OnVMStartStatus`：当虚拟机创建时会调用此方法。在此方法内部，Wasm
    可以检索虚拟机配置。'
- en: '`NewPluginContext(contextID uint32) PluginContext`: This creates a plugin context
    for each plugin configuration.'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewPluginContext(contextID uint32) PluginContext`：为每个插件配置创建一个插件上下文。'
- en: '`PluginContext`: This corresponds to each plugin configuration in the host.
    Plugins are configured at HTTP or network filters for listeners. Some of the methods
    in `PluginContext` are as follows:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PluginContext`：对应于宿主中每个插件的配置。插件在 HTTP 或网络过滤器中为监听器配置。`PluginContext` 中的一些方法如下：'
- en: '`OnPluginStart(pluginConfigurationSize int) OnPluginStartStatus`: This is called
    for all plugins configured. Once the VM has been created, Wasm can retrieve the
    plugin configuration using this method.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnPluginStart(pluginConfigurationSize int) OnPluginStartStatus`：此方法会为所有已配置的插件调用。一旦虚拟机（VM）创建完成，Wasm
    可以通过此方法检索插件配置。'
- en: '`OnPluginDone() bool`: This is called when the host deletes `PluginContext`.
    If this method returns `true`, it signals to the host that `PluginContext` can
    be deleted, and `false` means that the plugin is in a pending state and cannot
    yet be deleted.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnPluginDone() bool`：当宿主删除 `PluginContext` 时会调用此方法。如果此方法返回 `true`，则表示可以删除
    `PluginContext`，而 `false` 表示插件处于待处理状态，尚不能删除。'
- en: '`NewTcpContext(contextID uint32) TcpContext`: This method creates `TCPContext`,
    corresponding to every TCP request.'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewTcpContext(contextID uint32) TcpContext`：此方法创建 `TCPContext`，对应于每个 TCP 请求。'
- en: '`NewHttpContext(contextID uint32) HttpContext`: This method creates `HTTPContext`,
    corresponding to every HTTP request.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewHttpContext(contextID uint32) HttpContext`：此方法创建 `HTTPContext`，对应于每个 HTTP
    请求。'
- en: '`HTTPContext`: This method is created by `PluginContext` for every HTTP stream.
    The following are some of the methods available in this interface:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTPContext`：此方法由 `PluginContext` 为每个 HTTP 流创建。以下是该接口中的一些可用方法：'
- en: '`OnHttpRequestHeaders(numHeaders int, endOfStream bool) Action`: This method
    provides access to HTTP headers as part of the request stream.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnHttpRequestHeaders(numHeaders int, endOfStream bool) Action`：此方法提供访问作为请求流一部分的
    HTTP 头部的功能。'
- en: '`OnHttpRequestBody(bodySize int, endOfStream bool) Action`: This method provides
    access to data frames of the request body. It is called multiple times for every
    individual data frame in the request body.'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnHttpRequestBody(bodySize int, endOfStream bool) Action`：此方法提供访问请求体数据帧的功能。它会为请求体中的每个数据帧多次调用。'
- en: '`OnHttpResponseHeaders(numHeaders int, endOfStream bool) Action`: This method
    provides access to response headers.'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnHttpResponseHeaders(numHeaders int, endOfStream bool) Action`：此方法提供访问响应头的功能。'
- en: '`OnHttpResponseBody(bodySize int, endOfStream bool) Action`: This method provides
    access to response body frames.'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnHttpResponseBody(bodySize int, endOfStream bool) Action`：此方法提供访问响应体帧的功能。'
- en: '`OnHttpStreamDone()`: This method is called before the deletion of `HTTPContext`.
    From this method, Wasm can access all information about the request and response
    phases of the HTTP connection.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnHttpStreamDone()`：该方法在`HTTPContext`删除之前被调用。在此方法中，Wasm可以访问HTTP连接的请求和响应阶段的所有信息。'
- en: Among other types to read about is `TCPContext`. We have not covered all methods
    and types available in the SDK; you can find the complete list along with details
    at [https://pkg.go.dev/github.com/tetratelabs/proxy-Wasm-go-SDK@v0.20.0/proxyWasm/types#pkg-types](https://pkg.go.dev/github.com/tetratelabs/proxy-Wasm-go-SDK@v0.20.0/proxyWasm/types#pkg-types).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型包括`TCPContext`，我们没有涵盖SDK中的所有方法和类型；你可以在[https://pkg.go.dev/github.com/tetratelabs/proxy-Wasm-go-SDK@v0.20.0/proxyWasm/types#pkg-types](https://pkg.go.dev/github.com/tetratelabs/proxy-Wasm-go-SDK@v0.20.0/proxyWasm/types#pkg-types)中找到完整的列表和详细信息。
- en: With this overview in mind, let’s write a Wasm to inject a custom header in
    the response of the `envoydummy` Pod. Please note that in the *Customizing the
    data plane using the Envoy filter* section, we used EnvoyFilter to patch Istio
    and applied a Lua filter with inline code to inject headers to requests bound
    for the `httpbin` Pod.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了这些概述后，我们开始编写一个Wasm，将自定义头信息注入到`envoydummy` Pod的响应中。请注意，在*使用Envoy过滤器自定义数据平面*一节中，我们使用EnvoyFilter来修补Istio，并应用了一个包含内联代码的Lua过滤器，将头信息注入到发送到`httpbin`
    Pod的请求中。
- en: 'Create the `chapter09-temp` namespace with `istio-injection` disabled:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`chapter09-temp`命名空间，并禁用`istio-injection`：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run `envoydummy` to check that it is working as expected:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`envoydummy`，检查其是否按预期工作：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Forward the ports so that you can test locally:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 转发端口以便你可以在本地进行测试：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, test the endpoint:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试端点：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So, we have verified that `envoydummy` is working. The next step is to create
    Wasm to inject headers into the response. You will find the source code at [Chapter09/go_Wasm_example_for_envoy](http://Chapter09/go_Wasm_example_for_envoy).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经验证了`envoydummy`正在正常工作。下一步是创建Wasm，将头信息注入响应中。你可以在[Chapter09/go_Wasm_example_for_envoy](http://Chapter09/go_Wasm_example_for_envoy)找到源代码。
- en: 'There is only one `main.go` file in the Go module, and the following are the
    key parts of the code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Go模块中只有一个`main.go`文件，以下是代码的关键部分：
- en: 'The entry point in the Go module is the `main` method. In the `main` method,
    we are setting up the Wasm VM by calling `SetVMContext`. The method is described
    in the `Entrypoint.go` file at [https://github.com/tetratelabs/proxy-wasm-go-sdk/tree/main/proxywasm](https://github.com/tetratelabs/proxy-wasm-go-sdk/tree/main/proxywasm).
    The following code snippet shows the `main` method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Go模块的入口点是`main`方法。在`main`方法中，我们通过调用`SetVMContext`来设置Wasm虚拟机。该方法在[https://github.com/tetratelabs/proxy-wasm-go-sdk/tree/main/proxywasm](https://github.com/tetratelabs/proxy-wasm-go-sdk/tree/main/proxywasm)中的`Entrypoint.go`文件中有描述。以下代码片段展示了`main`方法：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following method injects a header into the response headers:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法将一个头信息注入到响应头中：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Also, notice `AddHttpResponseHeader`, which is defined at [https://github.com/tetratelabs/proxy-Wasm-go-SDK/blob/v0.20.0/proxyWasm/hostcall.go#L395](https://github.com/tetratelabs/proxy-Wasm-go-SDK/blob/v0.20.0/proxyWasm/hostcall.go#L395).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意`AddHttpResponseHeader`，该方法定义在[https://github.com/tetratelabs/proxy-Wasm-go-SDK/blob/v0.20.0/proxyWasm/hostcall.go#L395](https://github.com/tetratelabs/proxy-Wasm-go-SDK/blob/v0.20.0/proxyWasm/hostcall.go#L395)。
- en: The next step is to compile the Go module for Wasm, for which we will need to
    use TinyGo. Please note that we cannot use the standard Go compiler due to a lack
    of support for the Proxy-Wasm Go SDK.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为Wasm编译Go模块，我们需要使用TinyGo。请注意，由于Proxy-Wasm Go SDK不支持标准Go编译器，因此我们无法使用标准Go编译器。
- en: Install TinyGo for your host OS by following the instructions at [https://tinygo.org/getting-started/install/macos/](https://tinygo.org/getting-started/install/macos/).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[https://tinygo.org/getting-started/install/macos/](https://tinygo.org/getting-started/install/macos/)中的说明，为你的主机操作系统安装TinyGo。
- en: 'Using TinyGo, compile the Go module with Wasm using the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TinyGo，使用以下命令编译Go模块和Wasm：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the Wasm file is created, we need to load the Wasm file into `configmap`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Wasm文件创建完成，我们需要将Wasm文件加载到`configmap`中：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Modify the `envoy.yaml` file to apply Wasm filters and load Wasm from `configmap`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`envoy.yaml`文件，以应用Wasm过滤器并从`configmap`加载Wasm：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We specify `envoy` in the config to use the `v8` runtime for running Wasm.
    The changes are also available at `Chapter09/02-envoy-dummy.yaml`. Apply the changes,
    as shown here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在配置文件中指定`envoy`，以使用`v8`运行时来运行Wasm。相关更改也可以在`Chapter09/02-envoy-dummy.yaml`找到。按照如下方式应用更改：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Forward the port `80` to `18000`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将端口`80`转发到`18000`：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Test the endpoint to check whether Wasm injected the response header:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 测试端点，检查Wasm是否成功注入了响应头：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Hopefully, this section gave you confidence on how to create Wasm that is compliant
    with Proxy-Wasm and how to apply it to Envoy. We suggest you do more hands-on
    exercises by looking at examples available at [https://github.com/tetratelabs/proxy-Wasm-go-SDK/tree/main/examples](https://github.com/tetratelabs/proxy-Wasm-go-SDK/tree/main/examples).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这一节让您对如何创建符合Proxy-Wasm的Wasm并将其应用于Envoy有了信心。我们建议您通过查看[https://github.com/tetratelabs/proxy-Wasm-go-SDK/tree/main/examples](https://github.com/tetratelabs/proxy-Wasm-go-SDK/tree/main/examples)上的示例，进行更多实践。
- en: 'Before we conclude this section, let’s also check how Wasm is compliant with
    the Proxy-Wasm ABI. For that, we will install the `brew`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一节之前，让我们检查一下Wasm如何符合Proxy-Wasm ABI。为此，我们将安装`brew`：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'WABT provides various methods to manipulate and introspect Wasm. One such tool,
    `Wasm-objdump`, prints information about a Wasm binary. Using the following command,
    you can print a list of all functions that become accessible to the host environment
    once Wasm has been instantiated:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: WABT提供了多种操作和检查Wasm的方法。其中一个工具，`Wasm-objdump`，可以打印Wasm二进制文件的信息。使用以下命令，您可以打印出所有在Wasm实例化后能访问到的主机环境函数列表：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You will notice the output is a list of functions that are defined in the Proxy-Wasm
    ABI.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到输出是一个函数列表，这些函数在Proxy-Wasm ABI中有定义。
- en: Important note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: 'To do the cleanup, you can use the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行清理，您可以使用以下命令：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That completes the section on Proxy-Wasm, and we hope you now understand how
    to create Proxy-Wasm-compliant Wasm using the Go SDK. In the next section, we
    will deploy Wasm in Istio.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分已完成关于Proxy-Wasm的内容，希望您现在理解了如何使用Go SDK创建符合Proxy-Wasm标准的Wasm。在下一节中，我们将部署Istio中的Wasm。
- en: Wasm with Istio
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与Istio一起使用Wasm
- en: 'In this section, we will extend the Istio data plane using Wasm that we built
    in the previous section. We will be using Istio’s `httpbin` application:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将扩展我们在前一节中构建的Istio数据平面Wasm。我们将使用Istio的`httpbin`应用程序：
- en: The first step is to upload `main.Wasm` created in the Go module available at
    `Chapter09/go_Wasm_example_for_envoy` to an HTTPS location. You can make use of
    AWS S3 or something similar for that purpose; another option is to use an OCI
    registry such as `main.Wasm` to AWS S3\. The HTTPS location of the S3 bucket hosting
    the file is `https://anand-temp.s3.amazonaws.com/main.Wasm`. Please note that
    for security reasons, the link might not be accessible to you while reading this
    book, but I am sure you can manage to create your own S3 buckets or Docker registry.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是将Go模块中创建的`main.Wasm`上传到HTTPS位置，模块位置在`Chapter09/go_Wasm_example_for_envoy`。您可以使用AWS
    S3或类似服务来实现；另一种选择是使用OCI注册表，如`main.Wasm`到AWS S3。托管该文件的S3存储桶HTTPS位置为`https://anand-temp.s3.amazonaws.com/main.Wasm`。请注意，出于安全原因，您在阅读本书时可能无法访问该链接，但我相信您可以自己创建S3存储桶或Docker注册表。
- en: 'The second step is to deploy the `httpbin` application, which is already available
    at `Chapter09/01-httpbin-deployment.yaml`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是部署`httpbin`应用程序，相关文件已在`Chapter09/01-httpbin-deployment.yaml`中提供：
- en: '[PRE32]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Check the response of the following commands and observe the headers added
    during the request:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下命令的响应，并观察请求过程中添加的头信息：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After this, we will apply the following changes using `WasmPlugin`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将使用`WasmPlugin`应用以下更改：
- en: '[PRE34]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Apply `WasmPlugin` using the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令应用`WasmPlugin`：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We will read more about `WasmPlugin` after *step 5*. For now, let’s check the
    response headers from `httpbin`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第5步*之后进一步了解`WasmPlugin`。现在，让我们查看`httpbin`的响应头：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You will notice that, as expected, we have `x-chaptername: ExtendingEnvoy`
    in the response.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '您会注意到，正如预期的那样，响应中有`x-chaptername: ExtendingEnvoy`。'
- en: 'Let’s create another Wasm to add a custom header to `request` so that we can
    see it in the response of the `httpbin` payload. There is a Wasm already created
    in `Chapter09/go_Wasm_example_for_istio` for this purpose. Notice the `OnHTTPRequestHeaders`
    function in `main.go`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个Wasm，向`request`添加自定义头信息，以便我们可以在`httpbin`负载的响应中看到它。为了这个目的，`Chapter09/go_Wasm_example_for_istio`中已经创建了一个Wasm。请注意`main.go`中的`OnHTTPRequestHeaders`函数：
- en: '[PRE37]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Compile that into Wasm and copy it to the S3 location. There is also another
    Istio config file available at `Chapter09/02-Wasmplugin.yaml`, which deploys this
    Wasm:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将其编译成Wasm并复制到S3位置。另一个Istio配置文件`Chapter09/02-Wasmplugin.yaml`也可以用于部署此Wasm：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After applying the changes, test the endpoints, and you will find that both
    Wasm have executed, adding a header in the response as well as one in the request,
    which is reflected in the `httpbin` response. The following is a shortened version
    of the response:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用更改后，测试端点，你会发现两个Wasm都已执行，在响应中添加了一个头部，同时在请求中也添加了一个头部，这在`httpbin`响应中得到了反映。以下是响应的简短版本：
- en: '[PRE39]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In *steps 3* and *4*, we used `WasmPlugin` to apply Wasm on the Istio data
    plane. The following are the parameters we configured in `WasmPlugin`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*和*步骤4*中，我们使用`WasmPlugin`在Istio数据平面上应用Wasm。以下是我们在`WasmPlugin`中配置的参数：
- en: '`selector`: Specify the resource on which the Wasm should be applied in the
    `selector` field. It can be the Istio gateway and Kubernetes Pods. You provide
    labels that must match the workload on whose Envoy sidecar the Wasm configuration
    will be applied. In the examples we implemented, we applied the `app:httpbin`
    label, which corresponds to the `httpbin` Pod.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selector`：在`selector`字段中指定Wasm应应用的资源。它可以是Istio网关和Kubernetes Pod。你需要提供标签，标签必须与应用Wasm配置的Envoy
    sidecar的工作负载匹配。在我们实现的示例中，我们应用了`app:httpbin`标签，这对应于`httpbin` Pod。'
- en: '`url`: This is the location where the Wasm file is available to download. We
    provided the HTTP location, but OCI locations are also supported. The default
    value is `oci://`, used for referencing OCI images. To reference file-based locations,
    use `file://`, which is used for referencing Wasm files present locally within
    the proxy container.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`：这是可以下载Wasm文件的位置。我们提供了HTTP位置，但也支持OCI位置。默认值是`oci://`，用于引用OCI镜像。要引用基于文件的位置，请使用`file://`，它用于引用在代理容器内本地存在的Wasm文件。'
- en: '`imagePullPolicy`: The possible values for this are the following:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagePullPolicy`：此字段的可选值如下：'
- en: '`UNSPECIFIED_POLICY`: This is the same as `IfNotPresent` unless the URL points
    to an OCI image with the latest tag. In that case, this field will default to
    `Always`.'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNSPECIFIED_POLICY`：除非URL指向带有最新标签的OCI镜像，否则与`IfNotPresent`相同。在这种情况下，字段将默认为`Always`。'
- en: '`Always`: We will always pull the latest version of an image from the location
    specified in the URL.'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Always`：我们将始终从URL指定的位置拉取最新版本的镜像。'
- en: '`IfNotPresent`: Use this to pull Wasm only if the requested version is unavailable
    locally.'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IfNotPresent`：仅当请求的版本在本地不可用时，才拉取Wasm。'
- en: '`phase`: The possible values for this are the following:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phase`：此字段的可选值如下：'
- en: '`UNSPECIFIED_PHASE`: This means the Wasm filter will be inserted at the end
    of the filter chain.'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNSPECIFIED_PHASE`：这意味着Wasm过滤器将被插入到过滤器链的末尾。'
- en: '`AUTHN`: This inserts the plugin before the Istio authentication filters.'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTHN`：这将在Istio认证过滤器之前插入插件。'
- en: '`AUTHZ`: This inserts the plugin between the authentication and authorization
    filters.'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTHZ`：这将在认证和授权过滤器之间插入插件。'
- en: '`STATS`: This inserts the plugin after the authorization filter but before
    the stats filter.'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATS`：这将在授权过滤器后、统计过滤器前插入插件。'
- en: We have described the values we used in the example, but various fields can
    be configured in `WasmPlugin`; you can find the detailed list at [https://istio.io/latest/docs/reference/config/proxy_extensions/Wasm-plugin/#WasmPlugin](https://istio.io/latest/docs/reference/config/proxy_extensions/Wasm-plugin/#WasmPlugin).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了在示例中使用的值，但可以在`WasmPlugin`中配置各种字段；你可以在[https://istio.io/latest/docs/reference/config/proxy_extensions/Wasm-plugin/#WasmPlugin](https://istio.io/latest/docs/reference/config/proxy_extensions/Wasm-plugin/#WasmPlugin)中找到详细列表。
- en: For production deployment, we definitely suggest you use the `sha256` field
    to ensure the integrity of the Wasm modules.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产部署，我们强烈建议使用`sha256`字段来确保Wasm模块的完整性。
- en: Istio provides a reliable, out-of-the-box distribution mechanism for Wasm by
    leveraging the xDS proxy inside istio-agent and Envoy’s **Extension Configuration
    Discovery Service** (**ECDS**). Details about ECDS are available at [https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/extension](https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/extension).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Istio通过利用istio-agent内的xDS代理和Envoy的**扩展配置发现服务**（**ECDS**）为Wasm提供了可靠的开箱即用分发机制。有关ECDS的详细信息，请访问[https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/extension](https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/extension)。
- en: 'After applying `WasmPlugin`, you can check the `istiod` logs for ECDS entries:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 应用`WasmPlugin`后，你可以检查`istiod`日志中的ECDS条目：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You will find log entries similar to the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你会找到类似如下的日志条目：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Istio makes an ECDS call to istio-proxy about applying the `WasmPlugin`. The
    following diagram describes the process of applying Wasm via the ECDS API:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Istio向istio-proxy发出ECDS调用，应用`WasmPlugin`。以下图示描述了通过ECDS API应用Wasm的过程：
- en: '![Figure 9.4 – Distributing Wasm to the Istio data plane](img/B17989_09_04.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 向Istio数据平面分发Wasm](img/B17989_09_04.jpg)'
- en: Figure 9.4 – Distributing Wasm to the Istio data plane
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 向Istio数据平面分发Wasm
- en: The istio-agent deployed alongside Envoy intercepts the ECDS call from `istiod`.
    It then downloads the Wasm module, saves it locally, and updates the ECDS configuration
    with the path of the downloaded Wasm module. If the WASM modules are not accessible
    to Istio-agent, it will reject the ECDS update. You will be able to see ECDS update
    failure in the `istiod` logs.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 部署在Envoy旁边的istio-agent拦截来自`istiod`的ECDS调用。然后它下载Wasm模块，保存到本地，并更新ECDS配置，指定下载的Wasm模块的路径。如果WASM模块无法访问Istio-agent，它将拒绝ECDS更新。你可以在`istiod`日志中看到ECDS更新失败。
- en: This concludes this section, and I hope it arms you with enough knowledge to
    start applying Wasm to your production workload.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本节到此结束，希望它能为你提供足够的知识，帮助你开始将Wasm应用到生产工作负载中。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we read about Wasm and its use. We learned about how Wasm is
    used on the web due to its high performance, and we also familiarized ourselves
    with how to build Wasm using Go and use it from a web browser using JavaScript.
    Wasm is also becoming a popular choice on the server side, especially among network
    proxies such as Envoy.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Wasm及其用途。我们学习了Wasm如何因其高性能而在网页上使用，并且我们也熟悉了如何使用Go构建Wasm，并通过JavaScript从浏览器中使用它。Wasm也正逐渐成为服务器端的热门选择，尤其是在网络代理（如Envoy）中。
- en: To get a standardized interface for implementing Wasm for proxies, there are
    the Proxy-Wasm ABI specifications which are low-level specifications describing
    the interface between Wasm and the proxy hosting the Wasm. Wasm for Envoy needs
    to be Proxy-Wasm compliant, but the Proxy-Wasm ABIs are difficult to work with;
    the Proxy-Wasm SDKs are much easier to work with. At the time of writing this
    chapter, there are many programming languages in which Proxy-Wasm SDK implementations
    are available, of which Rust, Go, C++, and AssemblyScript are among the most popular.
    We made use of the Envoy Wasm filter to configure a Wasm on an Envoy HTTP filter
    chain. We then built a few simple Wasm examples to manipulate request and response
    headers and deployed them on Istio using `WasmPlugin`. Wasm is not the only option
    to extend the Istio data plane, and there is another filter called EnvoyFilter,
    which can be used to apply the Envoy configuration as a patch on top of the Envoy
    configuration created by `Istiod`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得一个标准化的接口来实现代理的Wasm，有Proxy-Wasm ABI规范，这些是低级规范，描述了Wasm和托管Wasm的代理之间的接口。Envoy的Wasm需要符合Proxy-Wasm规范，但Proxy-Wasm
    ABI很难使用；相比之下，Proxy-Wasm SDK更易于使用。在写这章时，有许多编程语言中都有Proxy-Wasm SDK的实现，其中Rust、Go、C++和AssemblyScript是最受欢迎的几种。我们利用Envoy
    Wasm过滤器，在Envoy HTTP过滤器链上配置Wasm。然后，我们构建了一些简单的Wasm示例来操作请求和响应头，并通过`WasmPlugin`将它们部署到Istio上。Wasm并不是扩展Istio数据平面的唯一选项，还有一个名为EnvoyFilter的过滤器，可以将Envoy配置作为补丁应用到由`Istiod`创建的Envoy配置上。
- en: The next chapter is very interesting as we will learn about how to deploy an
    Istio Service Mesh for non-Kubernetes workloads.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章非常有趣，因为我们将学习如何为非Kubernetes工作负载部署Istio服务网格。
