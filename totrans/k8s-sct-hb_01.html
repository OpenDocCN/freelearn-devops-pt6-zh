<html><head></head><body>
<div id="_idContainer015">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.2.1">Understanding Kubernetes Secrets Management</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This chapter will provide you with a refresher about containers, as well as a comprehensive overview of Kubernetes and its Secrets management implementation. </span><span class="koboSpan" id="kobo.3.2">By the end of this first walk-through, all personas (developers, platform, and security engineers) will know how to design and implement these topics with a set of hands-on examples. </span><span class="koboSpan" id="kobo.3.3">While going through these examples, we will highlight the respective security concerns that this book will address by covering a series of use cases that will lead to a production-grade solution for hybrid multi-cloud scenarios, including the business </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">continuity perspective.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Understanding Kubernetes’ origins and </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">design principles</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Setting up our first Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">testing environment</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Exploring Kubernetes </span><strong class="source-inline"><span class="koboSpan" id="kobo.12.1">Secret</span></strong><span class="koboSpan" id="kobo.13.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">ConfigMap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.15.1"> objects</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Analyzing why Kubernetes Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">are important</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Unveiling the challenges and risks associated with Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Secrets management</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Mapping the objectives and scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">this book</span></span></li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.22.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.23.1">To complete the hands-on parts of this chapter, we will be leveraging a series of tools and platforms that are commonly used to interact with containers, Kubernetes, and Secrets management. </span><span class="koboSpan" id="kobo.23.2">For this first chapter, we will be setting up this environment together and ramping up with a friendly desktop graphical solution for the first set of examples. </span><span class="koboSpan" id="kobo.23.3">Don’t worry – we have you covered with our Code in Action and GitHub repository, which contains the macOS installation example. </span><span class="koboSpan" id="kobo.23.4">Here is the list of </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">required tools:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.25.1">Docker</span></strong><span class="koboSpan" id="kobo.26.1"> (</span><a href="https://docker.com"><span class="koboSpan" id="kobo.27.1">https://docker.com</span></a><span class="koboSpan" id="kobo.28.1">) or Podman (</span><a href="https://podman.io"><span class="koboSpan" id="kobo.29.1">https://podman.io</span></a><span class="koboSpan" id="kobo.30.1">) as a container engine. </span><span class="koboSpan" id="kobo.30.2">Both</span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.31.1"> are OK, although I do have a personal preference for Podman as it offers benefits such as being daemonless for easy installation, rootless for added security, fully </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">Open Container Initiative</span></strong><span class="koboSpan" id="kobo.33.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.34.1">OCI</span></strong><span class="koboSpan" id="kobo.35.1">)-compliant, Kubernetes ready, and has the ability to integrate with </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">systemd</span></strong><span class="koboSpan" id="kobo.37.1"> at the user level to </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">autostart containers/Pods.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.39.1">Podman Desktop</span></strong><span class="koboSpan" id="kobo.40.1"> (</span><a href="https://podman-desktop.io"><span class="koboSpan" id="kobo.41.1">https://podman-desktop.io</span></a><span class="koboSpan" id="kobo.42.1">) is an open source software that provides a</span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.43.1"> graphical user interface for building, starting, and debugging containers, running local Kubernetes instances, easing the migration from containers to Pods, and even connecting with remote platforms such as Red Hat OpenShift, Azure Kubernetes Engine, </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">and more.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.45.1">Golang</span></strong><span class="koboSpan" id="kobo.46.1"> (</span><a href="https://go.dev"><span class="koboSpan" id="kobo.47.1">https://go.dev</span></a><span class="koboSpan" id="kobo.48.1">) or Go is</span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.49.1"> a programming language that will be used within our examples. </span><span class="koboSpan" id="kobo.49.2">Note that Kubernetes and most of its third-party components are written </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">in Go.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.51.1">Git</span></strong><span class="koboSpan" id="kobo.52.1"> (</span><a href="https://git-scm.com"><span class="koboSpan" id="kobo.53.1">https://git-scm.com</span></a><span class="koboSpan" id="kobo.54.1">) is a</span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.55.1"> version control system that we will be using to cover this book’s examples but will also leverage in our discovery of Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">management solutions.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.57.1">This book’s GitHub repository contains the digital material linked to this </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">book: </span></span><a href="https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook"><span class="No-Break"><span class="koboSpan" id="kobo.59.1">https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.60.1">.</span></span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.61.1">Understanding Kubernetes’ origins and design principles</span></h1>
<p><span class="koboSpan" id="kobo.62.1">While the evolution from one platform to another might be obvious, the compelling event and inner mechanics might not be. </span><span class="koboSpan" id="kobo.62.2">To safely handle sensitive data within Kubernetes, we have to understand both its historical and architectural evolutions. </span><span class="koboSpan" id="kobo.62.3">This will help us implement a secure production-grade environment for our critical </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">business applications.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">The next few sections will describe a series of concepts, explore and practice them with a simple container runtime and Kubernetes cluster, and establish their direct relationships with security concerns that this handbook </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">will address.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.66.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.67.1">While we expect you to perform the hands-on examples while reading along, we understand that you might not have the opportunity to do so. </span><span class="koboSpan" id="kobo.67.2">As such, we have provided briefings and debriefings for each </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">hands-on example.</span></span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.69.1">From bare metal to containers</span></h2>
<p><span class="koboSpan" id="kobo.70.1">Four decades ago, deploying</span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.71.1"> applications was done on a physical server, usually referred to as a </span><em class="italic"><span class="koboSpan" id="kobo.72.1">bare metal</span></em><span class="koboSpan" id="kobo.73.1"> installation. </span><span class="koboSpan" id="kobo.73.2">This approach allowed workloads to have direct access to physical resources with the best native performance possible. </span><span class="koboSpan" id="kobo.73.3">Due to out-of-the-box limitations for resource management from a software perspective, deploying more than one application on a physical server has always been an operational challenge that has resulted in a suboptimal model with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">root causes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.75.1">Physical resource utilization</span></strong><span class="koboSpan" id="kobo.76.1">: A reduced set of applications is deployed on a physical machine to limit the potential degradation of services due to the lack of proper resource management capabilities that would have helped address applications hogging all the </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">compute resources.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.78.1">Scalability, flexibility, and time to market</span></strong><span class="koboSpan" id="kobo.79.1">: The lead time in weeks or even months to procure, rack and stack, provision the physical machine, and have the application installed, which impacts </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">business growth.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.81.1">The total cost of ownership</span></strong><span class="koboSpan" id="kobo.82.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.83.1">TCO</span></strong><span class="koboSpan" id="kobo.84.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.85.1">versus innovation</span></strong><span class="koboSpan" id="kobo.86.1">: The procurement, integration, operations, and life cycle of physical servers, along with underutilized resources with limited prototyping due to high costs and lead time, slows down the organization’s </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">innovation capabilities.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.88.1">Then, in the early 2000s, virtualization or </span><em class="italic"><span class="koboSpan" id="kobo.89.1">hypervisors</span></em><span class="koboSpan" id="kobo.90.1"> became available for commoditized open </span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.91.1">systems. </span><span class="koboSpan" id="kobo.91.2">A hypervisor is a piece of software that’s merged into the operating system, installed on bare metal, that allows the IT department to create virtual machines. </span><span class="koboSpan" id="kobo.91.3">With this, operations teams were able to create and tailor these virtual machines to the application’s precise requirements with the ability to adapt the compute resources during the application’s life cycle and their usage by the business. </span><span class="koboSpan" id="kobo.91.4">Thanks to proper resource management and isolation, multiple virtual machines could run on a single server without having noisy neighbors causing potential </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">service degradations.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">This model provided tremendous optimizations that helped accelerate the digitalization of services and introduce a new market aside from the traditional data center business – cloud computing. </span><span class="koboSpan" id="kobo.93.2">However, the virtualization model created a new set </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">of challenges:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.95.1">The never-ending increase of virtual machines thanks to continuous innovation. </span><span class="koboSpan" id="kobo.95.2">This exponential growth of assets amplifies the operational burden to maintain and secure operating systems, libraries, </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">and applications.</span></span></li>
<li><span class="koboSpan" id="kobo.97.1">The increasing need for automation to perform daily </span><strong class="bold"><span class="koboSpan" id="kobo.98.1">Create, Read, Update, and Delete</span></strong><span class="koboSpan" id="kobo.99.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.100.1">CRUD</span></strong><span class="koboSpan" id="kobo.101.1">) operations </span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.102.1">at a large scale involving complex infrastructure and </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">security components.</span></span></li>
<li><span class="koboSpan" id="kobo.104.1">The need for a well-thought governance that’s enforced to address the life cycle, security, and business continuity for thousands of services to support the business continuity of the organization’s </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">critical applications.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.106.1">Finally, containers made </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.107.1">their way as the next layer of optimization. </span><span class="koboSpan" id="kobo.107.2">Although the construct of containers was not new, as with virtualization, it required a major player to invest in the commoditized open systems to organically make it the </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">next (r)evolution.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">Let’s think about a container as a lightweight virtual machine but without the need for a full operating system, which reduces the overall footprint and operational burden related to the software development life cycle and security management. </span><span class="koboSpan" id="kobo.109.2">Instead, multiple applications, as containers, share the underlying physical host from a software and hardware level without the overhead of the hypervisor benefiting from nearly machine-native performance. </span><span class="koboSpan" id="kobo.109.3">The </span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.110.1">container provides you with the </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">following benefits:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.112.1">A well-defined standard by the OCI (</span><a href="https://opencontainers.org"><span class="koboSpan" id="kobo.113.1">https://opencontainers.org</span></a><span class="koboSpan" id="kobo.114.1">) to ease with building, (re)distributing, and deploying containers to any platform that’s compliant with the specifications of </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">the OCI</span></span></li>
<li><span class="koboSpan" id="kobo.116.1">A highly efficient, predictable, and immutable medium that’s application-centric and only includes the necessary libraries and the </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">application runtime</span></span></li>
<li><span class="koboSpan" id="kobo.118.1">Application portability thanks to an infrastructure and </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">platform-agnostic solution</span></span></li>
<li><span class="koboSpan" id="kobo.120.1">An </span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.121.1">organic separation of concerns between the developers and platform engineers as there is no need to access the physical or virtual host operating system to develop, build, test, and </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">deploy applications</span></span></li>
<li><span class="koboSpan" id="kobo.123.1">Embracing an automation-first approach and DevOps practices to address the infrastructure, application, and </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">security management</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.125.1">Not mentioning a few challenges would be wrong, so here </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">are some:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.127.1">Most IT organizations have difficulties embracing a new paradigm from both an architectural and </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">management perspective</span></span></li>
<li><span class="koboSpan" id="kobo.129.1">Considering the organic serparation of concerns between the developers and platform engineers as a support </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">to silos</span></span></li>
<li><span class="koboSpan" id="kobo.131.1">There’s an overhype around microservices, which leads to potential suboptimal application architecture with no performance optimization but </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">added complexity</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.133.1">The following diagram shows the bottom-up stack, which shows the potential application density per physical server with their respective </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">deployment type:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.135.1"><img alt="Figure 1.1 – Layer comparison between bare metal, virtual machines, and containers" src="image/B20970_01_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.136.1">Figure 1.1 – Layer comparison between bare metal, virtual machines, and containers</span></p>
<p><span class="koboSpan" id="kobo.137.1">We’ve already cited a series of benefits, and yet, we should emphasize additional ones that help with rapid prototyping, faster deployment, easy live functional testing, and </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">so on:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.139.1">A smaller code base to maintain and enrich per microservice with </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">easier rollout/rollback</span></span></li>
<li><span class="koboSpan" id="kobo.141.1">The capability to run in a degraded mode when one of the microservices fails but not </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">the others</span></span></li>
<li><span class="koboSpan" id="kobo.143.1">The ability to troubleshoot misbehaving microservices without impacting the </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">entire application</span></span></li>
<li><span class="koboSpan" id="kobo.145.1">It’s faster to recover from failure as only the related microservice must </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">be rescheduled</span></span></li>
<li><span class="koboSpan" id="kobo.147.1">Granular compute resource allocation </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">and scalability</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.149.1">Not only do microservices help decouple large monolithic applications but they also introduce new design patterns to </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">accelerate innovation.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">This sounds fantastic, doesn’t it? </span><span class="koboSpan" id="kobo.151.2">It does, but we still have a major missing element here: container runtimes such as D</span><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.152.1">ocker or Podman do not provide any resiliency in case of failures. </span><span class="koboSpan" id="kobo.152.2">To do so, a container runtime requires an additional software layer providing the applications with high availability capabilities. </span><span class="koboSpan" id="kobo.152.3">Managing hundreds of microservices at scale demands a robust and highly resilient orchestrator to ensure the business continuity of the applications while guaranteeing a high level of automation and abstraction toward the underlying infrastructure. </span><span class="koboSpan" id="kobo.152.4">This will lead to frictionless build, deploy, and run operations, improving the day-to-day responsibilities of the IT staff involved with the workloads that are deployed on the </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">application platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">This is a big ask and a challenge that many IT departments are facing and trying to solve, even more so with legacy patterns. </span><span class="koboSpan" id="kobo.154.2">The answer to this complex equation is Kubernetes, a container platform or, as we should call it, an </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">application platform.</span></span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.156.1">Kubernetes overview</span></h2>
<p><span class="koboSpan" id="kobo.157.1">There are</span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.158.1"> no better words to describe what Kubernetes is all about than the words from the Kubernetes project maintainers: “</span><em class="italic"><span class="koboSpan" id="kobo.159.1">Containers are a good way to bundle and run your applications. </span><span class="koboSpan" id="kobo.159.2">In a production environment, you need to manage the containers that run the applications and ensure that there is no downtime. </span><span class="koboSpan" id="kobo.159.3">For example, if a container goes down, another container needs to start. </span><span class="koboSpan" id="kobo.159.4">Wouldn’t it be easier if this behavior was handled by </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.160.1">a system?</span></em></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.161.1">That’s how Kubernetes comes to the rescue! </span><span class="koboSpan" id="kobo.161.2">Kubernetes provides you with a framework to run distributed systems resiliently. </span><span class="koboSpan" id="kobo.161.3">It takes care of scaling and failover for your application, provides deployment patterns, and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.162.1">more.</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">” (</span></span><a href="https://kubernetes.io/docs/concepts/overview/#why-you-need-kubernetes-and-what-can-it-do"><span class="No-Break"><span class="koboSpan" id="kobo.164.1">https://kubernetes.io/docs/concepts/overview/#why-you-need-kubernetes-and-what-can-it-do</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.165.1">)</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">The same page lists the following benefits </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">of Kubernetes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.168.1">Service discovery and </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">load balancing</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.170.1">Storage orchestration</span></span></li>
<li><span class="koboSpan" id="kobo.171.1">Automated rollouts </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">and rollbacks</span></span></li>
<li><span class="koboSpan" id="kobo.173.1">Automatic </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">bin packing</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.175.1">Self-healing</span></span></li>
<li><span class="koboSpan" id="kobo.176.1">Secret and </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">configuration management</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.178.1">While reading</span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.179.1"> through this handbook, we will explore and practice all of these benefits while designing a production-grade Secrets management solution for </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">critical workloads.</span></span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.181.1">Kubernetes design principles</span></h2>
<p><span class="koboSpan" id="kobo.182.1">We have</span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.183.1"> established the context regarding the evolution and adoption of containers with the need for Kubernetes to support our applications with resiliency, scalability, and deployment patterns in mind. </span><span class="koboSpan" id="kobo.183.2">But how is Kubernetes capable of such a </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">frictionless experience?</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">Here is my attempt to answer this question based on having experience as a former cloud architect within the Red Hat Professional </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">Services organization:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.187.1">From a workload perspective, every infrastructure requirement that an application will consume is simply defined in a declarative way without the need for there to be a domain specialist in networking, storage, security, and so on. </span><span class="koboSpan" id="kobo.187.2">The YAML manifest describing the desired state of </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">Pod</span></strong><span class="koboSpan" id="kobo.189.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">Service</span></strong><span class="koboSpan" id="kobo.191.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">Deployment</span></strong><span class="koboSpan" id="kobo.193.1"> objects is then handled by Kubernetes as a service broker for every specific vendor who has a Kubernetes integration. </span><span class="koboSpan" id="kobo.193.2">In other words, application teams can safely write a manifest that is agnostic of the environment and Kubernetes distribution on which they will deploy </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">the workloads.</span></span></li>
<li><span class="koboSpan" id="kobo.195.1">From an infrastructure perspective, every component of the stack has a corresponding Kubernetes API object. </span><span class="koboSpan" id="kobo.195.2">If not, the vendor can introduce their own with the standard Kubernetes API object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">CustomResourceDefinition</span></strong><span class="koboSpan" id="kobo.197.1">, also</span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.198.1"> known as </span><strong class="bold"><span class="koboSpan" id="kobo.199.1">CRD</span></strong><span class="koboSpan" id="kobo.200.1">. </span><span class="koboSpan" id="kobo.200.2">This guarantees a common standard, even when interacting with third-party software, hardware, or </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">cloud vendors.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.202.1">When </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.203.1">Kubernetes receives a request with a valid object definition, the orchestrator will apply the related CRUD operation. </span><span class="koboSpan" id="kobo.203.2">In other words, Kubernetes introduces native automation and orchestration. </span><span class="koboSpan" id="kobo.203.3">The same principles should apply to every Kubernetes component running as a container so that they benefit from self-healing, resiliency, and scalability while being agnostic of the underlying software, hardware, or </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">cloud provider.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">This approach supports the portability not only of containerized applications but of the entire application platform while reducing the need for technology domain specialists to be involved when deploying an application, maintaining the platform, and even enriching the Kubernetes project with new features </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">or components.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">The concept of a YAML manifest to define a Kubernetes API object has been floating around for a while. </span><span class="koboSpan" id="kobo.207.2">It is time to look at a simple example that shows the desired state of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">Pod</span></strong><span class="koboSpan" id="kobo.209.1"> object (a logical grouping for one or </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">multiple containers):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.211.1">
apiVersion: v1
 kind: Pod
 metadata:
   name: hello-app
 spec:
   containers:
   - name: hello-world
     image: hello-path:0.1
     ports:
     - containerPort: 8080</span></pre> <p><span class="koboSpan" id="kobo.212.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">Pod</span></strong><span class="koboSpan" id="kobo.214.1"> object’s</span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.215.1"> definition provides the necessary information for Kubernetes to do </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.217.1">Define the desired state for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">Pod</span></strong><span class="koboSpan" id="kobo.219.1"> object with the </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">name </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">hello-app</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.223.1">Specify that there are </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">containers</span></strong><span class="koboSpan" id="kobo.225.1"> and that one of them is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">hello-world</span></strong><span class="koboSpan" id="kobo.227.1"> and uses a container image of </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">hello-path</span></strong><span class="koboSpan" id="kobo.229.1">. </span><span class="koboSpan" id="kobo.229.2">For this, we want version </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">0.1</span></strong><span class="koboSpan" id="kobo.231.1"> to be pulled from a </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">container registry.</span></span></li>
<li><span class="koboSpan" id="kobo.233.1">Accept incoming traffic to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">hello-world</span></strong><span class="koboSpan" id="kobo.235.1"> application, using port </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">8080</span></strong><span class="koboSpan" id="kobo.237.1"> at the </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">container level.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.239.1">That’s it! </span><span class="koboSpan" id="kobo.239.2">This is our first </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">Pod</span></strong><span class="koboSpan" id="kobo.241.1"> definition. </span><span class="koboSpan" id="kobo.241.2">It allows us to deploy a simple containerized application with no fuzz and zero knowledge of the </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">underlying infrastructure.</span></span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.243.1">Kubernetes architecture</span></h2>
<p><span class="koboSpan" id="kobo.244.1">There is </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.245.1">not much magic behind this orchestration but the work of multiple components provides a fantastic level of resilience and abstraction, as well as a frictionless experience. </span><span class="koboSpan" id="kobo.245.2">The following diagram provides an overview of the components that run within a </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">Kubernetes instance:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.247.1"><img alt="Figure 1.2 – Kubernetes components" src="image/B20970_01_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.248.1">Figure 1.2 – Kubernetes components</span></p>
<p><span class="koboSpan" id="kobo.249.1">A </span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.250.1">Kubernetes cluster can </span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.251.1">be divided into two logical groups – the </span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.252.1">control plane (some distributions refer to this as the master node) and the (worker) nodes. </span><span class="koboSpan" id="kobo.252.2">Let’s drill down into each logical group and discover their </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">respective components:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.254.1">Control plane:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">kube-apiserver</span></strong><span class="koboSpan" id="kobo.256.1">: This </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.257.1">component is responsible for exposing the Kubernetes API and enabling CRUD operations regarding the object definitions and their state </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">within </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">etcd</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">etcd</span></strong><span class="koboSpan" id="kobo.262.1">: This component is a key value store and serves as the asset management service. </span><span class="koboSpan" id="kobo.262.2">A corrupted </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">etcd</span></strong><span class="koboSpan" id="kobo.264.1"> results in a full </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">disaster scenario.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">kube-scheduler</span></strong><span class="koboSpan" id="kobo.267.1">: This component tracks the desired state of </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">Pod</span></strong><span class="koboSpan" id="kobo.269.1"> and will address any potential drift within the cluster. </span><span class="koboSpan" id="kobo.269.2">As an example, if a </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">Pod</span></strong><span class="koboSpan" id="kobo.271.1"> object definition is created or modified, </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">kube-scheduler</span></strong><span class="koboSpan" id="kobo.273.1"> will adjust its state so that the containers only run on a </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">healthy node.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">kube-controller-manager</span></strong><span class="koboSpan" id="kobo.276.1">: This component runs a series of controllers that are responsible for handling the desired state of the nodes, jobs, endpoints, and service accounts. </span><span class="koboSpan" id="kobo.276.2">Controllers are reconciliation loops that track the</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.277.1"> difference between the desired and current state of an object and adjust the latter so that it matches the latest </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">object definition.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">cloud-controller-manager</span></strong><span class="koboSpan" id="kobo.280.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.281.1">optional</span></em><span class="koboSpan" id="kobo.282.1">): Similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">kube-controller-manager</span></strong><span class="koboSpan" id="kobo.284.1">, this component, when deploying Kubernetes in the cloud, enriches the cluster with additional abstractions to interact with the related cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">provider services.</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.286.1">Nodes (and the control </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">plane too!):</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">kubelet</span></strong><span class="koboSpan" id="kobo.289.1">: This</span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.290.1"> component interacts with </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">kube-apiserver</span></strong><span class="koboSpan" id="kobo.292.1"> to verify and adjust the desired states of Pods bound to </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">the node</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">kubeproxy</span></strong><span class="koboSpan" id="kobo.295.1">: This component provides the basic network plumbing on each node while maintaining the networking rules to allow (or not) the internal and external network traffic </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">to Pods</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">container runtime</span></strong><span class="koboSpan" id="kobo.298.1">: This component runs </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">the containers</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.300.1">There are additional components that should be considered as add-ons due to their direct dependency on the Kubernetes distribution. </span><span class="koboSpan" id="kobo.300.2">These add-ons would be responsible for handling services such as DNS, logging, metrics, the user interface, </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">and more.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.302.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.303.1">In a dev/test environment, a single node might be deployed to act both as a control plane and a worker node on which Pods will be scheduled. </span><span class="koboSpan" id="kobo.303.2">However, for resiliency purposes, a production-grade environment should consider a minimum of three control planes with dedicated worker nodes to improve resilience and separation of concerns, as well as dedicate compute resources for </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">the applications.</span></span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.305.1">Getting hands-on – from a local container to a Kubernetes Pod</span></h2>
<p><span class="koboSpan" id="kobo.306.1">The main benefits of </span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.307.1">containers are their portability and being platform agnostic. </span><span class="koboSpan" id="kobo.307.2">Deploying the famous </span><em class="italic"><span class="koboSpan" id="kobo.308.1">Hello World</span></em><span class="koboSpan" id="kobo.309.1"> application within a container using Docker, Podman, or Kubernetes should not require us to modify the application code. </span><span class="koboSpan" id="kobo.309.2">I will even go a step further and say that we should not care about the underlying infrastructure. </span><span class="koboSpan" id="kobo.309.3">On the other hand, there would be a large umbrella of constraints to deal with when deploying an application with a bare metal or </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">virtualization approach.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">Before we start, we assume that you have </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.313.1">All the technical requirements mentioned at the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">this chapter</span></span></li>
<li><span class="koboSpan" id="kobo.315.1">Access to this book’s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">repository (</span></span><a href="https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook"><span class="No-Break"><span class="koboSpan" id="kobo.317.1">https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.318.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.319.1">This example at hand; it is available in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">ch01/example01</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.321.1"> folder</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.322.1">Let’s have a look at a simple example illustrating a basic software </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">supply chain:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.324.1">Building the application binary</span></strong><span class="koboSpan" id="kobo.325.1">: The example is a simple Go application showcasing an HTTP service and console </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">logging capabilities</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.327.1">Building the container image, including the application binary</span></strong><span class="koboSpan" id="kobo.328.1">: The application will be built using a Golang toolset container image; a second small footprint container image will be used to carry the </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">application binary</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.330.1">Running the containerized application using Podman</span></strong><span class="koboSpan" id="kobo.331.1">: This first run will leverage the graphical interface of Podman Desktop to illustrate the rather simple process of running </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">a container</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.333.1">Deploying the containerized application using Kubernetes</span></strong><span class="koboSpan" id="kobo.334.1">: This first deployment will leverage the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">kubectl</span></strong><span class="koboSpan" id="kobo.336.1"> command line to showcase how to process our first YAML manifest to create a Kubernetes </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">Pod</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.338.1"> object</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.339.1">Note that this example is agnostic of the CPU architecture on which the overall process will take place. </span><span class="koboSpan" id="kobo.339.2">This means that you can safely perform the same exercise on different CPU targets without the need to rewrite code or change any of the </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">configuration files.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">It is interesting to note that a container runtime such as Docker or Podman is used to build the application and the container image containing our application binary. </span><span class="koboSpan" id="kobo.341.2">This is done via a text </span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.342.1">file called a Dockerfile, which defines all the necessary steps to build our </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">container image:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.344.1">
FROM registry.access.redhat.com/ubi8/go-toolset@sha256:168ac23af41e6c5a6fc75490ea2ff9ffde59702c6ee15d 8c005b3e3a3634fcc2 AS build
COPY ./hello/* .
</span><span class="koboSpan" id="kobo.344.2">RUN go mod init hello
RUN go mod tidy
RUN go build .
</span><span class="koboSpan" id="kobo.344.3">FROM registry.access.redhat.com/ubi8/ubi-micro@sha256:6a56010de933f172b195a1a575855d37b70a4968be8edb 35157f6ca193969ad2
LABEL org.opencontainers.image.title "Hello from Path"
LABEL org.opencontainers.inage.description "Kubernetes Secrets Handbook - Chapter 01 - Containter Build Example"
COPY --from=build ./opt/app-root/src/hello .
</span><span class="koboSpan" id="kobo.344.4">EXPOSE 8080
ENTRYPOINT ["./hello"]</span></pre> <p><span class="koboSpan" id="kobo.345.1">The Dockerfile build steps are </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.347.1">Fetch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">go-toolset</span></strong><span class="koboSpan" id="kobo.349.1"> image for </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">the build.</span></span></li>
<li><span class="koboSpan" id="kobo.351.1">Get all the application content in </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">that image.</span></span></li>
<li><span class="koboSpan" id="kobo.353.1">Run the Go </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">build process.</span></span></li>
<li><span class="koboSpan" id="kobo.355.1">Fetch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">ubi-micro</span></strong><span class="koboSpan" id="kobo.357.1"> image as the </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">target container.</span></span></li>
<li><span class="koboSpan" id="kobo.359.1">Set some container </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">image metadata.</span></span></li>
<li><span class="koboSpan" id="kobo.361.1">Copy the binary from the build image to the </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">target image.</span></span></li>
<li><span class="koboSpan" id="kobo.363.1">Set a port exposure for the application. </span><span class="koboSpan" id="kobo.363.2">Here, this </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">8080</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.367.1">Run the </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">application binary.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.369.1">That’s it! </span><span class="koboSpan" id="kobo.369.2">Once the </span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.370.1">application has been built and the container image has been successfully created and pushed to the registry, the container image will be available in the localhost container registry, after which the container can be started using either Docker or Podman. </span><span class="koboSpan" id="kobo.370.2">This can be done through one simple command line with a few parameters, though you can leverage the Podman Desktop </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">graphical interface.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">On the other hand, running this container on an application platform such as Kubernetes requires a different approach – that is, declaratively using a YAML manifest. </span><span class="koboSpan" id="kobo.372.2">An example was supplied earlier in this chapter and can be found in this book’s GitHub repository. </span><span class="koboSpan" id="kobo.372.3">This YAML manifest is submitted to </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">kube-apiserver</span></strong><span class="koboSpan" id="kobo.374.1"> via a tool such </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">kubectl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">Here is a transactional overview of a Kubernetes </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">Pod</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.380.1">object’s creation:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.381.1"><img alt="Figure 1.3 – Kubernetes Pod creation" src="image/B20970_01_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.382.1">Figure 1.3 – Kubernetes Pod creation</span></p>
<p><span class="koboSpan" id="kobo.383.1">As we can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">etcd</span></strong><span class="koboSpan" id="kobo.385.1"> record</span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.386.1"> is continuously updated during the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">Pod</span></strong><span class="koboSpan" id="kobo.388.1"> object’s creation. </span><span class="koboSpan" id="kobo.388.2">The desired state is saved; the current status of every component involved in the process is also saved, which generates a sort of audit trail. </span><span class="koboSpan" id="kobo.388.3">Such a design allows for easier debugging when the desired outcome is </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">not achieved.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">As soon as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">Pod</span></strong><span class="koboSpan" id="kobo.392.1"> object is registered within </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">etcd</span></strong><span class="koboSpan" id="kobo.394.1">, all the Kubernetes components are on a mission to converge toward the desired state, regardless of potential issues such as network partitioning, node</span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.395.1"> failure, and more. </span><span class="koboSpan" id="kobo.395.2">This is the difference between running containers on a single machine with a local container runtime such as Docker or Podman and orchestrating containers at scale with a container platform such </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">as Kubernetes.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">Here’s some food </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">for thought:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.399.1">I wrote “</span><em class="italic"><span class="koboSpan" id="kobo.400.1">running the containerized applications</span></em><span class="koboSpan" id="kobo.401.1">” and “</span><em class="italic"><span class="koboSpan" id="kobo.402.1">deploying the containerized application</span></em><span class="koboSpan" id="kobo.403.1">” to illustrate the difference between a container runtime such as Docker or Podman running a containerized application and Kubernetes scheduling containers and orchestrating other resources such as networking, storage, Secrets, and more. </span><span class="koboSpan" id="kobo.403.2">Note that there is a Kubernetes object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Deployment</span></strong><span class="koboSpan" id="kobo.405.1"> that addresses release management and scalability capabilities. </span><span class="koboSpan" id="kobo.405.2">For more details, </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">see </span></span><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/"><span class="No-Break"><span class="koboSpan" id="kobo.407.1">https://kubernetes.io/docs/concepts/workloads/controllers/deployment/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.408.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.409.1">Performing such an exercise even in a non-production environment using virtual machines could take days, </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">even weeks.</span></span></li>
<li><span class="koboSpan" id="kobo.411.1">Developing applications using containers, for both monolithic or microservice application architecture, allows for a truly agile development cycle calling for everything to be continuous (development, integration, improvement, </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">and deployment).</span></span></li>
<li><span class="koboSpan" id="kobo.413.1">Using YAML manifests to deploy applications will trigger an organic usage of Git repositories that will spark another practice – GitOps. </span><span class="koboSpan" id="kobo.413.2">In short, every desired state definition of an application and its infrastructure management lands in a Git repository, providing the </span><em class="italic"><span class="koboSpan" id="kobo.414.1">application</span></em><span class="koboSpan" id="kobo.415.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.416.1">infrastructure</span></em><span class="koboSpan" id="kobo.417.1"> teams with a central point of configuration management, including, by default, authorization, peer review, </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">and organization.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.419.1">With that, we’ve transitioned from running the target application through a local container to running it through a Kubernetes Pod. </span><span class="koboSpan" id="kobo.419.2">By doing so, we acquired an understanding of how a Pod is created, which Kubernetes components are involved, the interactions that are involved, </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">and more.</span></span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.421.1">Secrets within Kubernetes</span></h2>
<p><span class="koboSpan" id="kobo.422.1">In this section, we</span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.423.1"> had a refresher on containers and Kubernetes, and </span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.424.1">we also proceeded with a hands-on example that helped us establish key concepts, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.426.1">The evolution of application deployment through times </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">and technologies</span></span></li>
<li><span class="koboSpan" id="kobo.428.1">Why containers </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">and Kubernetes</span></span></li>
<li><span class="koboSpan" id="kobo.430.1">The architecture and principles </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">of Kubernetes</span></span></li>
<li><span class="koboSpan" id="kobo.432.1">Building and running containers using Podman Desktop </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">and Kubernetes</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.434.1">With the knowledge we’ve acquired, we can start looking at the more advanced concept of Secrets within Kubernetes. </span><span class="koboSpan" id="kobo.434.2">We will dive into the details of how Secrets are stored on Kubernetes, how they are injected into a Pod, which is the smallest execution unit, and the security concerns that we have </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">to tackle.</span></span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.436.1">Secrets concepts</span></h2>
<p><span class="koboSpan" id="kobo.437.1">Interestingly enough, during my time designing and deploying Red Hat OpenShift, this topic was always considered irrelevant to the customer and partner teams that I was working with. </span><span class="koboSpan" id="kobo.437.2">Reflecting, I concluded that this is linked to the legacy patterns we have been working with for the last two or </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">three decades.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">In a traditional environment, both with physical and virtual machines, there is a clear outcome from the separation of concerns principle. </span><span class="koboSpan" id="kobo.439.2">The infrastructure teams care about the infrastructure and the application teams care about applications. </span><span class="koboSpan" id="kobo.439.3">This includes managing Secrets such as credentials, tokens, license keys, certificates, and more. </span><span class="koboSpan" id="kobo.439.4">No one from the application teams will share credentials for a MySQL database with the </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">infrastructure teams.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">When it comes to Kubernetes, these concerns are, by design, merged into a point of entry: the application platform. </span><span class="koboSpan" id="kobo.441.2">Despite the separation of concerns, the Kubernetes integration with external API-driven services requires credentials, tokens, or certificates to authenticate and trust themselves. </span><span class="koboSpan" id="kobo.441.3">These Secrets have to stay within the platform to ensure resiliency, scalability, and orchestration for both the cluster </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">and applications.</span></span></p>
<p><span class="koboSpan" id="kobo.443.1">When it comes to</span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.444.1"> the container image’s design, Secrets cannot be hardcoded or included in the container image. </span><span class="koboSpan" id="kobo.444.2">By hardcoding Secrets, they become available to all internal and external stakeholders with access to the container image registry. </span><span class="koboSpan" id="kobo.444.3">If the container image is pushed to a public registry, which is common to ease with redistribution, it will make the Secrets available to an even </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">wider audience.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">This is </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.447.1">the reason why Kubernetes has a Secrets management framework built into it with a dedicated API object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">Secret</span></strong><span class="koboSpan" id="kobo.449.1">. </span><span class="koboSpan" id="kobo.449.2">Here is an overview of what a </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">Secret</span></strong><span class="koboSpan" id="kobo.451.1"> object definition would </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">look like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.453.1">
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4K
  password: UGFja3QxMjMhCg==</span></pre> <p><span class="koboSpan" id="kobo.454.1">Let’s go through </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">the manifest:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.456.1">We informed Kubernetes that we wanted to create a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">Secret</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.458.1"> object</span></span></li>
<li><span class="koboSpan" id="kobo.459.1">The name for this object is </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">mysecret</span></strong><span class="koboSpan" id="kobo.461.1"> and we defined a type called </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">Opaque</span></strong><span class="koboSpan" id="kobo.463.1">, which means that we are defining the container of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">data</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.465.1">field ourselves</span></span></li>
<li><span class="koboSpan" id="kobo.466.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">data</span></strong><span class="koboSpan" id="kobo.468.1"> field is composed of two </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">key-value pairs</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.470.1">Now, let’s have a closer look at these key-value pairs. </span><span class="koboSpan" id="kobo.470.2">What seems to be a random set of characters is data being encoded </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">base64</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.474.1">Why </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">base64</span></strong><span class="koboSpan" id="kobo.476.1">? </span><span class="koboSpan" id="kobo.476.2">While we could assume the need to encrypt sensitive data such as credentials, the usage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">base64</span></strong><span class="koboSpan" id="kobo.478.1"> is only to ease the processing that’s done through the command line, the network, and by </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">kube-apiserver</span></strong><span class="koboSpan" id="kobo.480.1"> to avoid us processing a truncated payload due to </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">special characters.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">These two entries can be decoded on every operating system or website offering a </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">base64</span></strong><span class="koboSpan" id="kobo.484.1"> encoding/decoding tool. </span><span class="koboSpan" id="kobo.484.2">So, should we assume that </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">kube-apiserver</span></strong><span class="koboSpan" id="kobo.486.1">, when saving the payload within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">etcd</span></strong><span class="koboSpan" id="kobo.488.1"> key store, will encrypt the data? </span><span class="koboSpan" id="kobo.488.2">Well, this handbook has already given you a good hint that </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">it doesn’t!</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">Another API object </span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.491.1">has a similar data field that can be used to share sensitive data with an application: </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.493.1">. </span><span class="koboSpan" id="kobo.493.2">While </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.495.1"> was designed to carry out environment variables and application arguments, its usage has been rapidly adopted by developers to also include advanced application configuration, similar to a license key file. </span><span class="koboSpan" id="kobo.495.2">This object’s content could be leveraged by a malicious hacker to access containers, gain access</span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.496.1"> to other workloads either inside or outside the platform, and even gain control of the Kubernetes cluster. </span><span class="koboSpan" id="kobo.496.2">As such, </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.498.1"> should be carefully handled, just like </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">Secret</span></strong><span class="koboSpan" id="kobo.500.1"> objects. </span><span class="koboSpan" id="kobo.500.2">Here is an overview of a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">ConfigMap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.502.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.503.1">
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-environment
data:
  appversion1: dev</span></pre> <p><span class="koboSpan" id="kobo.504.1">As you can see, there is a major difference between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">data</span></strong><span class="koboSpan" id="kobo.506.1"> field of </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">Secret</span></strong><span class="koboSpan" id="kobo.508.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">data</span></strong><span class="koboSpan" id="kobo.510.1"> field of </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.512.1"> – the encoding part. </span><span class="koboSpan" id="kobo.512.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">data</span></strong><span class="koboSpan" id="kobo.514.1"> field specification of </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.516.1"> expects UTF-8 strings while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">Secret</span></strong><span class="koboSpan" id="kobo.518.1"> one expects key-value pairs with the value encoded in </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">base64</span></strong><span class="koboSpan" id="kobo.520.1">. </span><span class="koboSpan" id="kobo.520.2">This example shows a way to set an application to </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">dev</span></strong><span class="koboSpan" id="kobo.522.1"> mode, thus enabling extra instrumentation for </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">debugging purposes.</span></span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.524.1">Storing Secrets on Kubernetes</span></h2>
<p><span class="koboSpan" id="kobo.525.1">Now is a </span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.526.1">good time for a second hands-on example so that we can understand the differences between </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.527.1">Secrets and the other Kubernetes objects, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.529.1">. </span><span class="koboSpan" id="kobo.529.2">Before we start, we assume that you have </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.531.1">All the technical requirements mentioned at the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">this chapter</span></span></li>
<li><span class="koboSpan" id="kobo.533.1">Access to this book’s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">repository: </span></span><a href="https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook"><span class="No-Break"><span class="koboSpan" id="kobo.535.1">https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook</span></span></a></li>
<li><span class="koboSpan" id="kobo.536.1">The example at hand; it is available in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">ch01/example02</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.538.1"> folder</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.539.1">Let’s have a look</span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.540.1"> at what we are accomplishing with </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">this example:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.542.1">First, we are creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">Secret</span></strong><span class="koboSpan" id="kobo.544.1"> object using the provided YAML manifest, a secret definition similar to the one we created for </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">mysecret</span></strong><span class="koboSpan" id="kobo.546.1"> earlier. </span><span class="koboSpan" id="kobo.546.2">We are also checking its status and how to recover its definition from Kubernetes. </span><span class="koboSpan" id="kobo.546.3">This is always handy when we want to recover the current state of an object so that we can create it again later. </span><span class="koboSpan" id="kobo.546.4">We are also decoding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">base64</span></strong><span class="koboSpan" id="kobo.548.1"> payload to reveal the </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">key-value pairs.</span></span></li>
<li><span class="koboSpan" id="kobo.550.1">Then, we</span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.551.1"> are recovering the YAML manifest from Kubernetes to show a very simple way to get back our </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">Secret</span></strong><span class="koboSpan" id="kobo.553.1"> object and its sensitive data. </span><span class="koboSpan" id="kobo.553.2">In other words, if malicious hackers succeed in interacting with </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">kube-apiserver</span></strong><span class="koboSpan" id="kobo.555.1">, then they can extract some or all </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">Secret</span></strong><span class="koboSpan" id="kobo.557.1"> objects from a </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">Kubernetes cluster.</span></span></li>
<li><span class="koboSpan" id="kobo.559.1">Next, we are creating a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">Secret</span></strong><span class="koboSpan" id="kobo.561.1"> object from scratch by encoding the key-value pairs in </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">base64</span></strong><span class="koboSpan" id="kobo.563.1">, writing the YAML manifest, and pushing it via the command line. </span><span class="koboSpan" id="kobo.563.2">Here is a transactional overview of a Kubernetes </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">Secret</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.565.1">object’s creation:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.566.1"><img alt="Figure 1.4 – Secret creation" src="image/B20970_01_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.567.1">Figure 1.4 – Secret creation</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.568.1">The next step is to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">Secret</span></strong><span class="koboSpan" id="kobo.570.1"> payload from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">Pod</span></strong><span class="koboSpan" id="kobo.572.1"> object. </span><span class="koboSpan" id="kobo.572.2">In this example, we are </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.573.1">using a special type of container called </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">busybox</span></strong><span class="koboSpan" id="kobo.575.1"> that provides a small footprint environment that’s ideal for performing testing/debugging. </span><span class="koboSpan" id="kobo.575.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">Pod</span></strong><span class="koboSpan" id="kobo.577.1"> manifest includes the reference to our newly created </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">Secret</span></strong><span class="koboSpan" id="kobo.579.1"> object and assigns</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.580.1"> the value to an environment variable that we will </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">echo</span></strong><span class="koboSpan" id="kobo.582.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">busybox</span></strong><span class="koboSpan" id="kobo.584.1">. </span><span class="koboSpan" id="kobo.584.2">This will appear within container logs. </span><span class="koboSpan" id="kobo.584.3">Here is a transactional overview of a Kubernetes </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">Pod</span></strong><span class="koboSpan" id="kobo.586.1"> object being created, including the </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">Secret</span></strong><span class="koboSpan" id="kobo.588.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">being injected:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.590.1"><img alt="Figure 1.5 – Injecting Secret into Pod" src="image/B20970_01_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.591.1">Figure 1.5 – Injecting Secret into Pod</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.592.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">kubelet</span></strong><span class="koboSpan" id="kobo.594.1"> component will be responsible for decoding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">base64</span></strong><span class="koboSpan" id="kobo.596.1"> payload. </span><span class="koboSpan" id="kobo.596.2">This is to ensure that the payload is transported between the different components and across </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">the wire.</span></span></li>
<li><span class="koboSpan" id="kobo.598.1">Then, we access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">etcd</span></strong><span class="koboSpan" id="kobo.600.1"> key store via its API. </span><span class="koboSpan" id="kobo.600.2">This shows that the data that’s retrieved via such a method is not encrypted nor </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">base64</span></strong><span class="koboSpan" id="kobo.602.1"> encoded! </span><span class="koboSpan" id="kobo.602.2">At this stage, malicious hackers who have successfully breached the </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">etcd</span></strong><span class="koboSpan" id="kobo.604.1"> Pod have full access to Kubernetes asset management and can control the entire destiny of the application platform up to a cloud provider account if it’s deployed in such </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">a setup.</span></span></li>
<li><span class="koboSpan" id="kobo.606.1">Finally, we are </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.607.1">going one step further by extracting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">etcd</span></strong><span class="koboSpan" id="kobo.609.1"> file locally and examining it to retrieve our last created </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">Secret</span></strong><span class="koboSpan" id="kobo.611.1"> object. </span><span class="koboSpan" id="kobo.611.2">This seems to be a far-fetched scenario but think about filesystem access or backups taken of the Kubernetes cluster, which includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">etcd</span></strong><span class="koboSpan" id="kobo.613.1"> file. </span><span class="koboSpan" id="kobo.613.2">Even if the Kubernetes cluster is well-hardened with limited security exposure, malicious hackers who breach the storage and/or backup system(s) can retrieve all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">Secret</span></strong><span class="koboSpan" id="kobo.615.1"> objects from </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">such files.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.617.1">Compared to </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.618.1">the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">Pod</span></strong><span class="koboSpan" id="kobo.620.1"> creation workflow, we can establish the relatively low impact from a transaction perspective on the overall process. </span><span class="koboSpan" id="kobo.620.2">Note that our first example shows how to load the </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">Secret</span></strong><span class="koboSpan" id="kobo.622.1"> key-value pairs as environment variables. </span><span class="koboSpan" id="kobo.622.2">However, other options also exist; we will be exploring their potential mitigations later in </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">this book.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.624.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.625.1">Only the container that has the environment variable defined within its </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">Pod</span></strong><span class="koboSpan" id="kobo.627.1"> specs will have access to the key-value pairs. </span><span class="koboSpan" id="kobo.627.2">However, containers running with </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">privileged: true</span></strong><span class="koboSpan" id="kobo.629.1"> will have access to all Secrets from the node on which it runs, resulting in a major </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">security exposure.</span></span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.631.1">Why should we care?</span></h2>
<p><span class="koboSpan" id="kobo.632.1">While Kubernetes provides </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.633.1">a frictionless experience for both the platform and application teams, it does not provide you with a </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">hardened solution.</span></span></p>
<p><span class="koboSpan" id="kobo.635.1">The first approach to tackle this security concern would be to leverage a vault solution (the likes of HashiCorp Vault, CyberArk Conjure, or Azure Key Vault). </span><span class="koboSpan" id="kobo.635.2">However, this would only secure the application side. </span><span class="koboSpan" id="kobo.635.3">We are still exposed to taking into account the usage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.637.1"> or multi-cluster services such as application interconnect, which involves leveraging mutual authentication with certificates generated and deployed within the </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">application platform.</span></span></p>
<p><span class="koboSpan" id="kobo.639.1">So, let’s rethink the requirements into </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">simple layers:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.641.1">The platform</span></strong><span class="koboSpan" id="kobo.642.1">: When Kubernetes is deployed, a series of </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">Secret</span></strong><span class="koboSpan" id="kobo.644.1"> objects are created to allow internal components to interact with others (storage, networking, execution units, controllers, and so on). </span><span class="koboSpan" id="kobo.644.2">Third-party components being deployed later on to enrich the platform’s capabilities will follow the same model. </span><span class="koboSpan" id="kobo.644.3">These </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">Secret</span></strong><span class="koboSpan" id="kobo.646.1"> objects should not be offloaded to a vault solution for resilience purposes. </span><span class="koboSpan" id="kobo.646.2">If there is any type of partitioning with the external Vault solution, the Kubernetes cluster will start collapsing, along with all </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">the workloads.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.648.1">The application</span></strong><span class="koboSpan" id="kobo.649.1">: While accessing internal or external services (such as a database, S3 bucket, and so on) requires Secrets, these could be offloaded into an external Vault or similar solutions. </span><span class="koboSpan" id="kobo.649.2">However, applications might require a </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.651.1"> object, an encryption key for their volumes, TLS certificates, and </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">so on.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.653.1">Similar to the observation about platform-related </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">Secret</span></strong><span class="koboSpan" id="kobo.655.1"> objects, these should be stored within Kubernetes to ensure the scheduling, self-healing, and operability capabilities of the </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">application platform.</span></span></p></li>
</ul>
<p><span class="koboSpan" id="kobo.657.1">By design, Kubernetes </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.658.1">will not become a storage system or an encrypted Vault to protect sensitive data. </span><span class="koboSpan" id="kobo.658.2">Instead, Kubernetes will provide the necessary framework to interconnect and leverage the expertise of third-party solutions addressing each domain’s </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">specific needs.</span></span></p>
<p><span class="koboSpan" id="kobo.660.1">Considering these aspects, addressing the security concerns for Secrets Management in Kubernetes is not as simple as ticking </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">a box.</span></span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.662.1">Security exposures</span></h2>
<p><span class="koboSpan" id="kobo.663.1">In this chapter, we</span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.664.1"> have established the benefits of containerized </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.665.1">applications running on Kubernetes but also the security challenges of Secrets Management on such </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">application platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.667.1">Through our hands-on examples, we have acknowledged how unsafe our sensitive data is within </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">Secret</span></strong><span class="koboSpan" id="kobo.669.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.671.1"> objects. </span><span class="koboSpan" id="kobo.671.2">We can also list a series of security exposures to be exploited to compromise the application platform, including </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">external services:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.673.1">kube-apiserver</span></strong><span class="koboSpan" id="kobo.674.1">: This </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.675.1">is the main component of Kubernetes and malicious hackers can leverage this first point of entry to the </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">application platform</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.677.1">etcd</span></strong><span class="koboSpan" id="kobo.678.1">: This</span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.679.1"> manages Kubernetes assets and has multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">security exposures:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.681.1">The database file</span></strong><span class="koboSpan" id="kobo.682.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">etcd</span></strong><span class="koboSpan" id="kobo.684.1"> does not </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.685.1">provide any encryption capabilities. </span><span class="koboSpan" id="kobo.685.2">The database file is a binary file that can be </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">easily read.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.687.1">The API service</span></strong><span class="koboSpan" id="kobo.688.1">: As for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">kube-apiserver</span></strong><span class="koboSpan" id="kobo.690.1"> component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">etcd</span></strong><span class="koboSpan" id="kobo.692.1"> is an API-driven service </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.693.1">and any access or network trace can expose </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">the data.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.695.1">Pod</span></strong><span class="koboSpan" id="kobo.696.1">: Accessing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">Pod</span></strong><span class="koboSpan" id="kobo.698.1"> object </span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.699.1">means accessing the filesystem on which the database file </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">is written.</span></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.701.1">The </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.702.1">Kubernetes nodes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.704.1">The</span></strong><strong class="bold"><a id="_idIndexMarker051"/></strong><strong class="bold"><span class="koboSpan" id="kobo.705.1"> node filesystem</span></strong><span class="koboSpan" id="kobo.706.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">etcd</span></strong><span class="koboSpan" id="kobo.708.1"> Pod has its filesystem hosted on a volume to provide persistent storage. </span><span class="koboSpan" id="kobo.708.2">This volume is attached to the node, and by accessing the node, the data can also be accessed through the </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">attached volume.</span></span></li></ul></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.710.1">Backups</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">:</span></span><ul><li><span class="koboSpan" id="kobo.712.1">The Kubernetes</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.713.1"> cluster backups include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">etcd</span></strong><span class="koboSpan" id="kobo.715.1"> file. </span><span class="koboSpan" id="kobo.715.2">Accessing the backup can expose </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">the data.</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.717.1">There</span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.718.1"> are</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.719.1"> various ways that Secrets can be exposed. </span><span class="koboSpan" id="kobo.719.2">For example, you can interact with Kubernetes components such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">kube-apiserver</span></strong><span class="koboSpan" id="kobo.721.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">etcd</span></strong><span class="koboSpan" id="kobo.723.1"> to do this or go through a physical level such as direct node access or access </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">to backups.</span></span></p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.725.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.726.1">In this chapter, we introduced containers, Kubernetes, and Secrets. </span><span class="koboSpan" id="kobo.726.2">We provided an overview of the history so far, going through the concepts of bare metal, virtual machine, and container-based deployments. </span><span class="koboSpan" id="kobo.726.3">We had the opportunity to understand the benefits of containerization and introduce container orchestration engines. </span><span class="koboSpan" id="kobo.726.4">We learned more about Kubernetes and its components, which made it possible for us to run our first Kubernetes secret example and also have a deep dive into the Kubernetes components involved to facilitate secret usage. </span><span class="koboSpan" id="kobo.726.5">This helped us identify the security and robustness concerns that come with the usage of </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">Kubernetes Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.728.1">In the next chapter, we will focus on the different types of Kubernetes Secrets, their usages, and the cross-cutting concerns that Secrets come with, such as auditing and </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">access permissions.</span></span></p>
</div>
</body></html>