["```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: PersistentVolumeClaim\n    metadata:\n      name: db-pv-claim\n    spec:\n      accessModes:\n        - ReadWriteOnce\n      resources:\n        requests:\n          storage: 5Gi\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      name: redis-configmap\n    data:\n      redis-config: |\n        dir /data\n        requirepass YOUR_PASSWORD\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: redis\n      name: redis\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: redis\n      strategy: {}\n      template:\n        metadata:\n          creationTimestamp: null\n          labels:\n            app: redis\n    spec: \n    containers: \n          - name: redis\n    image: redis:6.2 \n    command: \n    - redis-server \n    - /redisconf/redis.conf \n    ports: \n    - containerPort: 6379 \n    resources: \n    limits: \n                cpu: \"0.2\"\n    memory: \"128Mi\" \n    volumeMounts: \n    - mountPath: \"/data\" \n    name: redis-storage \n    - mountPath: /redisconf \n              name: config\n          volumes:\n    - name: config \n    configMap: \n    name: redis-configmap \n    items: \n    - key: redis-config \n    path: redis.conf \n            - name: redis-storage\n    persistentVolumeClaim: \n                claimName: db-pv-claim-1\n    status: {}\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      labels:\n        app: redis\n      name: redis\n    spec:\n      ports:\n      - port: 6379\n        protocol: TCP\n        targetPort: 6379\n      selector:\n        app: redis\n      type: ClusterIP\n    EOF\n    ```", "```\n    cgroup_memory=1 cgroup_enable=memory\n    ```", "```\n    $ ifconfig wlan0\n    ```", "```\n    $ MASTER_IP=YOUR_PRIVATE_IP\n    $ curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC=\"--write-kubeconfig-mode 644\" sh -s -\n    ```", "```\n    $ kubectl get nodes\n    ```", "```\nimport pandas as pd\nfrom sklearn import tree\nfrom joblib import dump\ndf = pd.read_csv(\"safety_rules.csv\",sep=',', header='infer', encoding='latin-1')\ndf = df.drop(['object'], axis=1)\ndf.head()\nfeature_cols = [\"n\"]\nX = df.loc[:, feature_cols]\ny = df.warning_level\nclf = tree.DecisionTreeRegressor()\nmodel = clf.fit(X, y)\ndump(clf, 'safety_rules.model')\n```", "```\n<Import Flask and Scikit Learn libraries>\ndef loadModel():\n    <Load the model safety_rules.model>\n    <Assign the loaded model to the variable clf>\n@app.route('/predict', methods=[\"POST\"])\ndef predict():\n    <Use clf variable to call the prediction method>\n    <Return the prediction using JSON format>\n<Inference service initialization on port 3000 by default>\n```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: inference\n      name: inference\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: inference\n      strategy: {}\n      template:\n        metadata:\n          creationTimestamp: null\n          labels:\n            app: inference\n        spec:\n          containers:\n          - image: sergioarmgpl/inference\n            name: inference\n            imagePullPolicy: Always\n            resources: {}\n    status: {}\n    EOF\n    ```", "```\n    $ kubectl port-forward --address 0.0.0.0 deploy/inference 3000:3000\n    ```", "```\n    $ curl --header \"Content-Type: application/json\" \\\n    --request POST --data '{\"data\":[6]}' \\\n    http://localhost:3000/predict\n    ```", "```\n{\n  \"prediction\": 3.0\n}\n```", "```\n<Import necessary Python libraries to read the GPS module>\n\n<cid variable to set a unique client id for these coordinates>\n<device variable to set where the GPS module will be read in /dev>\n<ser variable to configure the serial communication with the GPS module>\n\n<Initializing the device to read information>\n\nwhile True:\n   <Read the Coordinate and store it into /tmp/gps>\n```", "```\n{'lat': <LATITUDE_VALUE>,'lng':<LONGITUDE_VALUE>,'cid':<CLIENT_ID>}\n```", "```\n<Import the necessary Python libraries to run this code> \n<Set traffic_events variable to accumulate detected objects for a time period>\n<Flask and CORS configuration>\n\n@app.route(\"/gps\", methods=[\"GET\"])\ndef getGPSCoordinate():\n  <Read coordinate form /tmp/gps>\n  <Return the GPS coordinate as JSON as \n  {'lat': <LATITUDE_VALUE>,'lng':<LONGITUDE_VALUE>\n  ,'cid':<CLIENT_ID>} \n  >\n\n@app.route(\"/traffic/event\", methods=[\"POST\"])\ndef registerTrafficEvent():\n   <Read last GPS coordinate from /tmp/gps>\n   <Get object type and warning classification\n    from the computer vision service>\n   <Generate the Timestamp value for the new detected object>\n   <Assign to a variable the warning, Latitude, Longitude \n    and timestamp information for the object>\n   <Add this information to the traffic_events array \n    to store it temporary the value>\n   <Return the object ide and that the request was processed>\n\n@app.route(\"/traffic\", methods=[\"GET\"])\ndef syncTrafficEvents():\n   <Filter similar objects stored in the \n    traffic_events array>\n   <Send the filtered array using JSON format to the\n    endpoint http://<TRAFFIC_MANAGER:5000>/traffic/1\n    to store this information and get it locally and\n    public by calling the endpoint\n    http://<TRAFFIC_MANAGER:5000>/traffic>\n    <Return that the information syncTrafficEvents\n     was processed>\n\n<GPS Queue service initialization on port 3000 by default>\n```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      labels:\n        app: gps-queue\n      name: gps-queue\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: gps-queue\n      template:\n        metadata:\n          labels:\n            app: gps-queue\n        spec:\n          initContainers:\n          - image: busybox:1.34\n            name: init-gps-queue\n            command: ['sh', '-c', \"echo '-1' >> /tmp/gps\"]\n            securityContext:\n              runAsUser: 1\n            volumeMounts:\n            - name: tmp\n              mountPath: /tmp\n          containers:\n          - image: sergioarmgpl/gps_queue\n            name: gps-queue\n            imagePullPolicy: Always\n            env:\n            - name: DEVICE\n              value: \"/dev/ttyACM0\"\n            securityContext:\n              privileged: true\n              capabilities:\n                add: [\"SYS_ADMIN\"]\n            volumeMounts:\n            - mountPath: /dev\n              name: dev-volume\n            - name: tmp\n              mountPath: /tmp\n          - image: sergioarmgpl/gps_api\n            name: gps-api\n            ports:\n            - containerPort: 3000\n            imagePullPolicy: Always\n            env:\n            - name: ENDPOINT\n              value: \"http://<TRAFFIC_MANAGER_IP>:5000\"\n            securityContext:\n              runAsUser: 1\n            volumeMounts:\n            - name: tmp\n              mountPath: /tmp\n          - image: curlimages/curl\n            name: sync-traffic-events\n            env:\n            - name: URL\n              value: \"http://localhost:3000/traffic\"\n            - name: DELAY\n              value: \"30\"\n            command: [ \"sh\", \"-c\"]\n            args:\n            - while :; do\n                curl ${URL};\n                sleep ${DELAY};\n              done;\n          volumes:\n          - name: dev-volume\n            hostPath:\n              path: /dev\n              type: Directory\n          - name: tmp\n            emptyDir: {}\n    status: {}\n    ```", "```\n    $ kubectl port-forward --address 0.0.0.0 deploy/gps-queue 3001:3000\n    ```", "```\n$ curl http://localhost:3001/gps\n```", "```\n{'lat': <LATITUDE_VALUE>,'lng':<LONGITUDE_VALUE>\n  ,'cid':<CLIENT_ID>}\n```", "```\n<Import the necessary Python libraries to run this code> \n\n<Flask and CORS configuration> \n\n<Set time to expire the traffic and objects by setting the values of the variables ttl_trf, ttl_obj>\n\ndef redisCon():\n   <Set and return the Redis connection>\n\n@app.route(\"/traffic/1\", methods=[\"POST\"])\ndef setBulkTrafficObjects():\n   <Get the Redis connection calling redisCon()>\n   <Get detected objects from the POST request>\n   <Omit to store similar detected objects in a \n   5 meters radius>\n   <Set a hash value to store type and warning \n    level for each object>\n   <Set expiring time for each hash stored>\n   <Return that the operation was successful {\"setTrafficObject\":\"done\"}>\n\n@app.route(\"/traffic/unit/<unit>/r/<radius>\"+\n\"/lat/<lat>/lng/<lng>\", methods=[\"GET\"])\ndef getTrafficObjects(unit,radius,lat,lng):\n   <Get the Redis connection calling redisCon()>\n   <Get the objects detected and its metadata\n   from the previous stored hash\n   in the radius configured in the request>\n   <Return that the operation was successful and \n   the objects found\n   in the next format:\n   {\"getTrafficObjects\":\"done\",\n    \"objects\":data\n   }>\n\n<Service initialization on port 3000 by default>\n```", "```\n<Import all the necessary libraries>\n<Set Redis connection in an r variable>\n\nwhile True:\n    <Get all the objects inside the traffic sorted set>\n    <Check if each member of the set has its hash value>\n    <If not remove the member of the sorted set>\n    <Wait until the configured delay ends to\n    Update the set again>\n```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: traffic-manager\n      name: traffic-manager\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: traffic-manager\n      strategy: {}\n      template:\n        metadata:\n          creationTimestamp: null\n          labels:\n            app: traffic-manager\n        spec:\n          containers:\n          - image: sergioarmgpl/autoexpire\n            name: autoexpire\n            imagePullPolicy: Always\n            env:\n            - name: REDIS_HOST\n              value: \"redis\"\n            - name: REDIS_AUTH\n              value: \"YOUR_PASSWORD\"\n            - name: DELAY\n              value: \"30\"\n          - image: sergioarmgpl/traffic_manager\n            name: traffic-manager\n            imagePullPolicy: Always\n            env:\n            - name: REDIS_HOST\n              value: \"redis\"\n            - name: REDIS_AUTH\n              value: \"YOUR_PASSWORD\"\n            - name: TTL_TRAFFIC\n              value: \"900\"\n            - name: TTL_OBJECT\n              value: \"180\"\n            resources: {}\n    status: {}\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      labels:\n        app: traffic-manager\n      name: traffic-manager-lb\n    spec:\n      ports:\n      - port: 5000\n        protocol: TCP\n        targetPort: 3000\n      selector:\n        app: traffic-manager\n      type: LoadBalancer\n    EOF\n    ```", "```\n    $ TRAFFIC_MANAGER_IP=\"$(kubectl get svc traffic-manager-lb  -o=jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\n    ```", "```\n$ echo $TRAFFIC_MANAGER_IP\n```", "```\n$ kubectl get svc traffic-manager-lb\n```", "```\n    $ curl -X POST -H \"Accept: application/json\" \\\n    -H \"Content-Type: application/json\" \\\n    --data '{\n        \"object\":\"person\",\n        \"warning\":1,\n        \"position\":{\"lat\":1.633518,\"lng\": -90.591706}\n    }' http://$TRAFFIC_MANAGER_IP:3000/traffic/1\n    ```", "```\n{\n  \"setTrafficObject\": \"done\"\n}\n```", "```\n    $ curl -X GET -H \"Accept: application/json\" \\\n    http://$TRAFFIC_MANAGER_IP:3000/traffic/objects/unit/km/r/0.1/lat/1.633518/lng/-90.5917\n    ```", "```\n{\n  \"getTrafficObjects\": [\n    \"person\"\n  ]\n}\n```", "```\nfrom flask import Flask,request,redirect,Response\nimport os\nimport requests\napp = Flask(__name__)\nurl = os.environ['URL']\n\n@app.route('/<path:path>',methods=['GET'])\ndef proxy(path):\n   global url\n   r = requests.get(f'{url}/{path}')\n   excluded_headers = ['content-encoding'\n   , 'content-length', 'transfer-encoding'\n   , 'connection']\n   headers = [(name, value) for (name, value) in \n   r.raw.headers.items() if name.lower() not in \n   excluded_headers]\n   response = Response(r.content, r.status_code, headers)\n   return response\n\nif __name__ == '__main__':\n   app.run(debug = False,port=5000)\n```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: proxy\n      name: proxy\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: proxy\n      strategy: {}\n      template:\n        metadata:\n          creationTimestamp: null\n          labels:\n            app: proxy\n        spec:\n          containers:\n          - image: sergioarmgpl/proxy\n            name: proxy\n            imagePullPolicy: Always\n            env:\n            - name: URL\n              value: \"http://<TRAFFIC_MANAGER_IP>:5000\"\n            resources: {}\n    status: {}\n    EOF\n    ```", "```\n    $ curl http://localhost:5000/<REMOTE_PATH>\n    ```", "```\n<imported libraries>\n<app_initialization>\n<CORS configuration>\n@app.route(\"/\")\ndef map():\n   return render_template(<Render map.html\n                           Using environment variables\n                           GPS_QUEUE,TRAFFIC_MANAGER,\n                           LATITUDE and LONGITUDE>) \n<Starting the web application on port 3000>\n```", "```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<Load Javascript libraries>\n<Load page styles>\n<body>\n    <div id='map'></div>\n<script>\n    <Load Map in an initial GPS position>\n    var marker\n    var markers = []\n    var osm = L.tileLayer(\n    'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n    {  \n        <Set Open Street Map Initial\n        Configuration using Leaflet>\n    });   \n    osm.addTo(map);      \n    setInterval(() => {\n        $.getJSON(\"http://{{ GPS_QUEUE }}:3001/gps\", \n        function(gps) {   \n            <Delete current markers>\n            <Get current position of your device \n             and show it in the map>\n                $.getJSON(\n                  \"http://{{ TRAFFIC_MANAGER }}:5000\"+\n                  \"/traffic/unit/km/r/0.5/lat/<LATITUDE>\"\n                  \"/lng/<LONGITUDE>\", function(pos) {\n                <This gets all the detected objects \n                in a radius of 0.5 km>\n                <For each object returned show it in \n                the map using \n                markPosition(object,lat,lng,o_type,warning)\n                function>\n                });\n        });\n    }, 5000);\n\n    <Configure the icons to visualize if an object is a\n    person, car or a truck>\n    function markPosition(object,lat,lng,o_type,warning)\n    {\n        <Create a maker with the appropriate Icon showing\n        the object name, latitude, longitude, type of object\n        and warning level>\n    }  \n</script>  \n</body>\n</html>\n```", "```\n    $ cat <<EOF | kubectl apply -f - \n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: traffic-map\n      name: traffic-map\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: traffic-map\n      strategy: {}\n      template:\n        metadata:\n          creationTimestamp: null\n          labels:\n            app: traffic-map\n        spec:\n          containers:\n          - image: sergioarmgpl/traffic_map\n            name: traffic-map\n            imagePullPolicy: Always\n            env:\n            - name: LATITUDE\n              value: \"<YOUR_LATITUDE_COORDINATE>\"\n            - name: LONGITUDE\n              value: \"<YOUR_LONGITUDE_COORDINATE>\"\n            - name: GPS_QUEUE\n              value: \"localhost\" #<GPS_QUEUE_IP>\n            - name: TRAFFIC_MANAGER\n              value: \"<TRAFFIC_MANAGER_IP>\"\n            resources: {}\n    status: {}\n    EOF\n    ```", "```\n<Imported libraries to run OpenCV in TensorFlow Lite>\n\n#Array to map detected objects\nobj_values = {\"car\":1,\"cat\":2,\"person\":3\n,\"dog\":4,\"semaphore\":5,\"truck\":6,\"other\":1000}\n\ndef run():\n  <Initialize Video Capture for the camera>\n  <Set screen size to capture>\n  <Initialize the object detection model>\n  #Array to store detected objects\n  items = []\n  while Camera is Opened:\n    detection_result = detector.detect(input_tensor)\n    items.clear()\n    <store detected objects in the items arrays>\n    <Show the FPS evaluated>\n    <Count objects detected per type of object>\n    <Get the classification of each object calling\n    /predict endpoint from the gps-api>\n    if the warning count of the group <= 2:\n        <A real warning is detected\n        we push this information calling\n        /traffic/event and warning is incremented>\n    if warning:\n       <show unique objects found\n       warning is set to zero>\n    else:\n       <show No warnings>\n\n    if <ESC key is pressed>:\n      <break the cycle>\n    <Set cv2 window size to show the capture>\n  <Close the Camera Capture>\n  <Destroy all windows>\n\ndef main():\n  <Parse parameters to run the program>\n  <Call run() function to start analyzing video capture>\n\nif __name__ == '__main__':\n  <call the main() function of the program>\n```", "```\nobj_values = {\"car\":1,..,\"other_object\":7,...\"other\":1000}\n```", "```\n    $ ssh your_user@<EDGE_DEVICE_IP>\n    ```", "```\n$ ifconfig wlan0\n```", "```\n    $ git clone https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes\n    $ cd Edge-Computing-Systems-with-Kubernetes/ch14/code/python/object_detection\n    ```", "```\n    $ /bin/bash install_deps.sh\n    ```", "```\n    $ /bin/bash setup.sh\n    ```", "```\n    $ /bin/bash install_shortcuts.sh\n    ```", "```\n    $ sudo rm –rf LCD-show\n    $ git clone https://github.com/goodtft/LCD-show.git\n    $ chmod –R 755 LCD-show\n    $ cd LCD-show\n    $ sudo ./MPI4008-show\n    ```", "```\n    $ sudo restart\n    ```", "```\n    $ cat <<EOF | kubectl apply -f - \n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: traffic-map-public\n      name: traffic-map-public\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: traffic-map-public\n      strategy: {}\n      template:\n        metadata:\n          creationTimestamp: null\n          labels:\n            app: traffic-map-public\n        spec:\n          containers:\n          - image: sergioarmgpl/traffic_map_public\n            name: traffic-map-public\n            imagePullPolicy: Always\n            env:\n            - name: LATITUDE\n              value: \"<YOUR_LATITUDE_COORDINATE>\"\n            - name: LONGITUDE\n              value: \"<YOUR_LONGITUDE_COORDINATE>\"        \n            - name: TRAFFIC_MANAGER\n              value: \"<TRAFFIC_MANAGER_IP>\"\n            resources: {}\n    status: {}\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: traffic-map-public\n      name: traffic-map-public-lb\n    spec:\n      ports:\n      - port: 3000\n        protocol: TCP\n        targetPort: 3000\n      selector:\n        app: traffic-map-public\n      type: LoadBalancer\n    status:\n      loadBalancer: {}\n    EOF\n    ```", "```\n    $ TRAFFIC_MAP_PUBLIC=\"$(kubectl get svc traffic-map-public -o=jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\n    ```", "```\n$ echo $TRAFFIC_MAP_PUBLIC\n```", "```\n$ kubectl get svc traffic-map-public-lb\n```"]