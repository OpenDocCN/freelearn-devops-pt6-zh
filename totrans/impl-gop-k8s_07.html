<html><head></head><body>
		<div id="_idContainer089">
			<h1 class="chapter-number" id="_idParaDest-143"><a id="_idTextAnchor146"/>7</h1>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor147"/>Cultural Transformation in IT for Embracing GitOps</h1>
			<p>In the rapidly evolving landscape of information technology, the adoption of <strong class="bold">GitOps</strong> marks a significant paradigm shift, heralding not just a technological transformation but also a profound <strong class="bold">cultural</strong> metamorphosis within IT departments. This chapter delves into the multifaceted layers of this change, highlighting how GitOps fundamentally redefines operational processes <span class="No-Break">and methodologies.</span></p>
			<p>At its core, GitOps represents a fusion of software development and IT operations, driven by the principles of version control and collaboration, which are intrinsic to Git. It’s a methodology where infrastructure and application deployment are treated as code, enabling a high degree of <strong class="bold">automation</strong> and precision in IT operations. This approach ensures that the same rigor that’s applied to application development is now extended to the management of infrastructure, particularly within <span class="No-Break">Kubernetes environments.</span></p>
			<p>One of the most transformative aspects of GitOps is the establishment of an <strong class="bold">immutable infrastructure</strong>. Using reconciling and synchronization loops, GitOps automates the process of aligning the actual state of the infrastructure with the desired state defined in a Git repository. This alignment minimizes the need for manual interventions, reducing the potential for human error and improving the overall reliability and security of the <span class="No-Break">IT systems.</span></p>
			<p>A significant part of this chapter is dedicated to understanding the impact of GitOps on IT performance. We’ll explore this through the lens of the <strong class="bold">DevOps Research and Assessment</strong> (<strong class="bold">DORA</strong>) metrics, a widely recognized set of indicators used to measure the effectiveness of DevOps practices. By applying these metrics to GitOps, organizations can quantitatively assess improvements in areas such as deployment frequency, change lead time, change failure rate, and mean time <span class="No-Break">to recovery.</span></p>
			<p>However, the journey of adopting GitOps extends beyond the implementation of tools such as Argo CD. It necessitates a continuous engagement with evolving GitOps trends and practices. As with any emerging technology, GitOps comes with its own set of challenges. These include the need for upskilling teams, adapting existing workflows, and <strong class="bold">continuously optimizing</strong> processes to align with best practices <span class="No-Break">in GitOps.</span></p>
			<p>The final section of this chapter addresses the broader organizational impact of implementing GitOps. Adopting GitOps is not just a technical upgrade; it’s a catalyst for a cultural shift that permeates various departments within an organization. We’ll share insights and experiences from multiple projects across diverse companies, illustrating how GitOps can drive a more collaborative, transparent, and efficient IT culture. These real-world examples provide valuable lessons on the challenges, strategies, and successes of integrating GitOps into the fabric of <span class="No-Break">an organization.</span></p>
			<p>This comprehensive examination of GitOps, from its technical foundations to its cultural implications, aims to provide you with a clear understanding of the transformative power of this methodology. It’s a journey that transcends mere technology adoption, charting a path toward a more agile, responsive, and innovative <span class="No-Break">IT culture.</span></p>
			<p>We will cover the following main topics in <span class="No-Break">the chapter:</span></p>
			<ul>
				<li>Treating infrastructure as <span class="No-Break">an application</span></li>
				<li>The principles of <span class="No-Break">immutable infrastructure</span></li>
				<li>An introduction to <span class="No-Break">DORA metrics</span></li>
				<li>Understanding the need for continual improvement <span class="No-Break">in GitOps</span></li>
				<li>Overcoming cultural barriers to <span class="No-Break">adopt GitOps</span></li>
			</ul>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor148"/>Treating infrastructure as an application</h1>
			<p>In the <a id="_idIndexMarker559"/>evolving landscape of <strong class="bold">DevOps</strong>, the concept of treating infrastructure as applications – commonly known as <strong class="bold">infra-as-apps</strong> – is <a id="_idIndexMarker560"/>gaining momentum, especially in the context of GitOps. To understand this, we need to get a quick overview of <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>). IaC will be covered in<a id="_idIndexMarker561"/> detail in <a href="B22100_10.xhtml#_idTextAnchor190"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>. This is a crucial component that’s laid out, for example, by Terraform with its declarative approach, allowing infrastructure to be treated like <span class="No-Break">an application.</span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor149"/>Understanding IaC</h2>
			<p>IaC is a modern <a id="_idIndexMarker562"/>approach for managing and provisioning IT infrastructure using code instead of traditional manual processes. This method allows you to automate the setup, management, and configuration of computing resources such as servers, storage, networks, and applications. Treating your infrastructure as if it were software, IaC applies software development practices such as version control and testing to <span class="No-Break">infrastructure management.</span></p>
			<p>The main aim of IaC is to enhance efficiency, reliability, and consistency in infrastructure deployment and management. By using code to define infrastructure, manual intervention is reduced, decreasing human error, and speeding up deployment. IaC enables a more consistent and repeatable process for provisioning and configuring resources, simplifying the scaling and management of infrastructure <span class="No-Break">over time.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="bold">Imperative</strong>: Directly <a id="_idIndexMarker563"/>use kubectl commands to create, update, or delete Kubernetes resources, offering quick, on-the-fly adjustments suitable for development <span class="No-Break">and experimentation.</span></p>
			<p class="callout"><strong class="bold">Declarative</strong>: Define<a id="_idIndexMarker564"/> the desired state in YAML manifests and apply them, letting Kubernetes ensure the actual state aligns with the declared one. This is ideal for production with benefits such as version control <span class="No-Break">and reproducibility.</span></p>
			<p>IaC typically employs a <strong class="bold">declarative</strong> or <strong class="bold">imperative</strong> approach to define the infrastructure’s desired state. This specification allows the IaC tool to make necessary changes automatically, leading to a more agile, efficient, and reliable IT environment that better supports modern <span class="No-Break">business demands.</span></p>
			<h3>The importance of IaC</h3>
			<p>The <a id="_idIndexMarker565"/>rise of cloud computing has been a significant driver behind IaC’s growing adoption. Organizations face the challenge of managing and deploying resources across multiple environments, such as public, private, and hybrid clouds. IaC automates the deployment and management of these resources, easing the management of <span class="No-Break">complex environments.</span></p>
			<p>Additionally, the need for businesses to deliver applications and services swiftly and efficiently has made IaC increasingly important. In today’s fast-paced digital world, organizations <a id="_idIndexMarker566"/>must rapidly adapt to market and customer demands. IaC streamlines IT operations, enabling quicker and more <span class="No-Break">adaptable scaling.</span></p>
			<p>Furthermore, IaC supports <strong class="bold">DevOps principles</strong>, bridging<a id="_idIndexMarker567"/> the gap between software development and IT operations. Treating infrastructure as code allows organizations to apply software development methodologies to infrastructure, enhancing collaboration and communication between development and <span class="No-Break">operations teams.</span></p>
			<h3>How IaC works</h3>
			<p>The<a id="_idIndexMarker568"/> fundamental concept of IaC is treating infrastructure like software. This includes employing rigorous software development practices such as version control, infrastructure code testing, and continuous integration and deployment. This approach ensures infrastructure consistency, reducing downtime and <span class="No-Break">maintenance time.</span></p>
			<p>The IaC process starts with writing scripts that describe the infrastructure’s desired state using declarative language. These scripts, stored in a version control system like any software, allow for versioning, auditing, and rollbacks. An IaC tool then applies these scripts to the actual infrastructure, ensuring it matches the desired state. This repeatability ensures consistency and reduces <span class="No-Break">manual errors.</span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor150"/>Understanding infrastructure as applications in Argo CD’s GitOps framework</h2>
			<p>In the realm of Argo CD, the<a id="_idIndexMarker569"/> concept of an application extends beyond its traditional definition [<em class="italic">1</em>]. Here, an application encompasses<a id="_idIndexMarker570"/> not just the software but also its desired state configuration, the targeted deployment environment, and the policies governing how these resources are synced and managed. This approach marks a significant shift from the conventional understanding <span class="No-Break">of applications.</span></p>
			<p>Typically, engineering teams have viewed applications as software layers that run on a separate infrastructure. The standard process involves setting up the infrastructure first, often manually or using tools<a id="_idIndexMarker571"/> such as <strong class="bold">Terraform</strong> or <strong class="bold">Cloud Formation</strong> templates. Once this groundwork is laid, another team deploys their <a id="_idIndexMarker572"/>applications onto this prepared infrastructure. However, Argo CD introduces a more integrated perspective. In this GitOps-driven environment, an application’s deployment is continuously monitored. Argo CD vigilantly compares the real-time state of the application<a id="_idIndexMarker573"/> against its predefined desired state. This constant comparison is crucial for maintaining consistency and reliability. The divergence between the<a id="_idIndexMarker574"/> actual state and the desired state can occur due to two primary reasons. First, there could be a drift in the actual state, which refers to unanticipated changes or modifications in the environment. Secondly, the desired state itself might be updated, necessitating a change in <span class="No-Break">the deployment.</span></p>
			<p>Whenever such divergences occur, Argo CD steps in to reconcile these differences. This act of reconciliation is at the heart of the GitOps style of deployment, which Argo CD upholds. This method aligns with the principles set by the <strong class="bold">OpenGitOps standards</strong>, ensuring<a id="_idIndexMarker575"/> a systematic and standardized approach to deployment and <span class="No-Break">infrastructure management.</span></p>
			<p>This paradigm shift, where infrastructure is treated akin to applications, brings about a more seamless and integrated workflow. It emphasizes the importance of treating infrastructure management with the same level of detail and care as application development, underscoring a holistic approach to system deployment <span class="No-Break">and management.</span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor151"/>Embracing infra-as-apps – bridging GitOps and infrastructure management</h2>
			<p>Traditionally, creating<a id="_idIndexMarker576"/> and managing infrastructure through declarative configurations has been a challenge, despite the<a id="_idIndexMarker577"/> popularity of tools<a id="_idIndexMarker578"/> such as <strong class="bold">Terraform</strong>, <strong class="bold">Cloud Formation</strong> templates, <strong class="bold">Pulumi</strong>, <strong class="bold">Cloud Development Kit for Terraform</strong> (<strong class="bold">CDKTF</strong>), and <a id="_idIndexMarker579"/>others. These tools offer a one-time or <a id="_idIndexMarker580"/>change-triggered <a id="_idIndexMarker581"/>application of the desired state, typically via <strong class="bold">CI/CD pipelines</strong>. However, this method falls short in one critical aspect of GitOps: ongoing <span class="No-Break">state monitoring.</span></p>
			<p>The gap lies in the fact that CI/CD pipelines, while efficient in deploying new plans or updates, do not continuously monitor for state drift. For instance, if a Terraform plan is executed and the actual state is altered externally later, the CI/CD system remains oblivious to these changes. This is where a GitOps operator such as Argo CD becomes indispensable. Argo CD’s role is to relentlessly monitor the actual state of the infrastructure and ensure it aligns with the desired state, thereby <span class="No-Break">preventing drift.</span></p>
			<p>Adopting this <em class="italic">no-drift-allowed approach</em> has<a id="_idIndexMarker582"/> proven beneficial for teams, not only in managing their applications more efficiently but also in enhancing their ability to recover from failures rapidly. In this model, rolling back to a previous state is as simple as performing <span class="No-Break"><strong class="source-inline">git revert</strong></span><span class="No-Break">.</span></p>
			<p>The <a id="_idIndexMarker583"/>benefits that teams have experienced in managing applications can now be extended to infrastructure management, thanks to this paradigm shift. Our focus, however, will be on Crossplane. As an open source CNCF project, Crossplane enables users to provision and manage diverse cloud resources through the Kubernetes API. When integrated with a GitOps operator such as Argo CD, Crossplane allows for the deployment of applications representing a variety of cloud<a id="_idIndexMarker584"/> resources such as <strong class="bold">Azure Key Vault</strong>, <strong class="bold">databases</strong>, <strong class="bold">Kubernetes clusters</strong>, and load balancers <a id="_idIndexMarker585"/>across <strong class="bold">Azure</strong>, <strong class="bold">AWS</strong>, and other cloud platforms. This integration heralds a new era in infrastructure management, blending the robustness of GitOps with the versatility of modern <span class="No-Break">cloud resources.</span></p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor152"/>How IaC can be used to deploy infrastructure</h2>
			<p>Now <a id="_idIndexMarker586"/>that we have all the necessary background information and hopefully a sufficient understanding of the difference between the GitOps approach and using Terraform in terms of treating your infrastructure as an application, let’s clarify this in practice by examining three <span class="No-Break">use cases.</span></p>
			<p>Before we begin, let’s briefly explain the selected tools for this setup and why they were chosen. Starting <span class="No-Break">with Azure:</span></p>
			<ul>
				<li><strong class="bold">Azure Kubernetes Service (AKS)</strong>: This <a id="_idIndexMarker587"/>service offers a managed Kubernetes environment that simplifies how containerized applications are deployed, managed, and scaled with the robustness of <span class="No-Break">Azure’s infrastructure.</span></li>
				<li><strong class="bold">Container Registries</strong>: This <a id="_idIndexMarker588"/>service provides a secure, scalable, and private registry for Docker container images, enhancing the management and deployment of <span class="No-Break">containerized applications.</span></li>
				<li><strong class="bold">PostgreSQL Server on Azure</strong>: This service offers a reliable and scalable cloud <a id="_idIndexMarker589"/>database service, ensuring efficient management and storage of <span class="No-Break">application data.</span></li>
				<li><strong class="bold">Azure Key Vault</strong>: This<a id="_idIndexMarker590"/> is a tool for securely storing and accessing secrets, keys, and certificates. It’s crucial for managing sensitive information and enhancing <span class="No-Break">overall security.</span></li>
			</ul>
			<p>For Kubernetes, we have <a id="_idIndexMarker591"/><span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Argo CD</strong>: A<a id="_idIndexMarker592"/> declarative, GitOps continuous delivery tool for Kubernetes, enabling automated deployment and management <span class="No-Break">of applications</span></li>
				<li><strong class="bold">External-DNS</strong>: This <a id="_idIndexMarker593"/>tool automates the management of DNS records, streamlining the process of connecting Kubernetes services with external <span class="No-Break">DNS names</span></li>
				<li><strong class="bold">Cert-Manager</strong>: This<a id="_idIndexMarker594"/> tool manages SSL/TLS certificates for Kubernetes, automating certificate issuance and <span class="No-Break">renewal processes</span></li>
				<li><strong class="bold">External-Secrets Operator</strong>: This tool <a id="_idIndexMarker595"/>integrates with systems such as Azure Key Vault to securely inject secrets into Kubernetes, enhancing secure access to <span class="No-Break">sensitive data</span></li>
			</ul>
			<p>For deployments for the IaC part, we have <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Terraform modules</strong>: These <a id="_idIndexMarker596"/>are components within Terraform, an IaC tool, that are designed to enable modular and reusable infrastructure definitions. They facilitate a declarative approach by allowing users to define the desired state of their infrastructure in code, which Terraform then executes to create and manage the actual infrastructure, ensuring it matches the <span class="No-Break">specified state.</span></li>
				<li><strong class="bold">Crossplane</strong>: This is<a id="_idIndexMarker597"/> an IaC tool that integrates with the Kubernetes ecosystem, allowing for external resources, such as cloud services, to be managed through Kubernetes <strong class="bold">custom resource definitions</strong> (<strong class="bold">CRDs</strong>). It<a id="_idIndexMarker598"/> adopts a declarative model where users define their infrastructure requirements in a Kubernetes-native way, enabling consistent and unified management of both Kubernetes internal resources and external <span class="No-Break">cloud infrastructure.</span></li>
			</ul>
			<p>In combination, these<a id="_idIndexMarker599"/> tools form a comprehensive ecosystem. Azure’s services provide a secure and scalable cloud platform, while Kubernetes tools such as Argo CD and Cert-Manager ensure efficient and secure application deployment and management. The integration between Azure Key Vault and the External-Secrets Operator in Kubernetes exemplifies how cloud infrastructure and Kubernetes can work seamlessly together for enhanced security and operational efficiency. Now, let’s look at the <span class="No-Break">use cases.</span></p>
			<h3>Use case 1 – deploy everything over Terraform</h3>
			<p>In the first <a id="_idIndexMarker600"/>use case, as illustrated in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.1</em>, everything is <a id="_idIndexMarker601"/>deployed via Terraform. This means that initially, the required cloud infrastructure is deployed <span class="No-Break">using Terraform:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer085">
					<img alt="Figure 7.1 – Use case 1 – deploy everything over Terraform" src="image/B22100_07_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Use case 1 – deploy everything over Terraform</p>
			<p>To simplify <a id="_idIndexMarker602"/>this example, we’ve removed any unnecessary complexity, such as CI/CD pipelines. In a production setup, you would hopefully not execute this manually as a user, unless it’s for initial bootstrapping or solving the chicken-and-egg problem. Once the infrastructure is deployed, additional Terraform modules are used to deploy further infrastructure in a <span class="No-Break">Kubernetes context.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">It’s worth noting that there are native approaches available for integrating Terraform with GitOps, such as<a id="_idIndexMarker603"/> the <strong class="bold">Terraform Controller</strong>. This tool enables a variety of GitOps models tailored for Terraform resources, including full automation, hybrid automation for partial infrastructure management, state enforcement, and drift detection, all within a native framework. However, this chapter focuses more on the native use <span class="No-Break">of tools.</span></p>
			<p>This approach is <a id="_idIndexMarker604"/>sound and was even standard a few years ago. Here, the infrastructure is treated and deployed as an application through the declarative <span class="No-Break">module approach.</span></p>
			<p>However, there are some drawbacks to <span class="No-Break">this method:</span></p>
			<ul>
				<li><strong class="bold">Lack of continuous monitoring</strong>: This approach does not continuously monitor the infrastructure state for any drift, which is a key component <span class="No-Break">in GitOps</span></li>
				<li><strong class="bold">Complexity in scalability</strong>: As the infrastructure grows, managing it through Terraform alone can become increasingly complex, especially in terms of state management, multiple stages, and <span class="No-Break">module dependencies</span></li>
				<li><strong class="bold">Limited dynamic response</strong>: The approach lacks the dynamic response to changes that a GitOps workflow offers, where real-time adjustments to the infrastructure can be managed <span class="No-Break">more seamlessly</span></li>
				<li><strong class="bold">Overhead in managing modules</strong>: Relying heavily on Terraform modules for every aspect of deployment can lead to overhead in module management and <span class="No-Break">version control</span></li>
				<li><strong class="bold">Potential for configuration drift</strong>: Without continuous reconciliation, there’s a higher <a id="_idIndexMarker605"/>risk of configuration drift over time as manual updates may not be tracked or <span class="No-Break">recorded consistently</span></li>
			</ul>
			<h3>Use case 2 – integrating Terraform and Argo CD for deployment processes</h3>
			<p>The next <a id="_idIndexMarker606"/>approach, illustrated in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.2,</em> combines <a id="_idIndexMarker607"/>the first method and then delegates the task to Argo CD. This approach is common in practice and often encountered in various projects with different clients. In this method, the Azure infrastructure is initially rolled out using Terraform modules. Subsequently, Argo CD is deployed as the initial instance using Terraform modules. Afterward, Argo CD takes over the GitOps part and deploys the Kubernetes context-related infrastructure. In this approach, a declarative method is best. Terraform modules are laid out declaratively, and the infrastructure, such as <strong class="bold">Cert-Manager</strong>, is<a id="_idIndexMarker608"/> also presented declaratively as <em class="italic">Applications</em> or <em class="italic">ApplicationSets</em>, as described in <span class="No-Break">previous chapters:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer086">
					<img alt="Figure 7.2 – Use case 2 – integrating Terraform and Argo CD for deployment processes" src="image/B22100_07_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Use case 2 – integrating Terraform and Argo CD for deployment processes</p>
			<p>While this <a id="_idIndexMarker609"/>approach has its advantages, there are potential drawbacks <span class="No-Break">to consider:</span></p>
			<ul>
				<li><strong class="bold">Complexity of integration</strong>: Combining Terraform with Argo CD can add complexity, requiring a solid understanding of <span class="No-Break">both tools</span></li>
				<li><strong class="bold">Initial learning curve</strong>: For teams new to either Terraform or Argo CD, the learning curve might be steep due to the integration of these two <span class="No-Break">different paradigms</span></li>
				<li><strong class="bold">Overhead in maintenance</strong>: The combined approach might require more maintenance effort as it involves managing two systems rather <span class="No-Break">than one</span></li>
				<li><strong class="bold">Risk of misconfiguration</strong>: With two powerful tools at play, there’s an increased risk of misconfiguration, which can lead to deployment issues or <span class="No-Break">security vulnerabilities</span></li>
				<li><strong class="bold">Update coordination</strong>: Coordinating updates between the infrastructure managed by<a id="_idIndexMarker610"/> Terraform and applications managed by Argo CD requires careful planning to avoid conflicts and ensure <span class="No-Break">smooth operations</span></li>
			</ul>
			<h3>Use case 3 – unified management on Kubernetes – full-scale orchestration with CRs and Crossplane</h3>
			<p>The<a id="_idIndexMarker611"/> next approach, depicted in <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.3</em>, fully utilizes the Kubernetes API while <a id="_idIndexMarker612"/>focusing on <strong class="bold">CRDs</strong> and <strong class="bold">custom resources</strong> (<strong class="bold">CRs</strong>), which <a id="_idIndexMarker613"/>allows users to define their resource types and instantiate these types for custom configurations and functionality.  This approach uses Crossplane for provisioning cloud infrastructure and deploying third-party tools necessary for Kubernetes infrastructure, such as Cert-Manager. It treats infrastructure as applications through the declarative nature of CRs, providing a fully trackable solution that leverages the Kubernetes ecosystem as an orchestration platform to keep resources in sync. This concept can be expanded so that virtually all cloud infrastructure is provisioned through Argo CD in combination with Crossplane. Everything is maintained within the cluster, requiring only an understanding of Kubernetes manifests – in this case, CRDs <span class="No-Break">and CRs:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer087">
					<img alt="Figure 7.3 – Use case 3 – unified management on Kubernetes – full-scale orchestration with CRs and Crossplane" src="image/B22100_07_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Use case 3 – unified management on Kubernetes – full-scale orchestration with CRs and Crossplane</p>
			<p>For a better<a id="_idIndexMarker614"/> understanding of how to create a resource in Azure with Crosslplane, CR, and Argo CD, here is a small example using the CR <strong class="source-inline">VirtualNetwork</strong> type. The requirement for this is that Kubernetes is installed and that the Azure provider is installed and <span class="No-Break">configured [</span><span class="No-Break"><em class="italic">3</em></span><span class="No-Break">].</span></p>
			<p>Once the preparation is complete and the network provider is installed, we can create a <a id="_idIndexMarker615"/>managed resource of the <strong class="source-inline">VirtualNetwork</strong> type that can be used for AKS, <span class="No-Break">for example.</span></p>
			<p>First, create a CR, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
apiVersion: network.azure.upbound.io/v1beta1
kind: VirtualNetwork
metadata:
  name: crossplane-quickstart-network
spec:
  forProvider:
    addressSpace:
      - 10.0.0.0/16
    location: "West Europe"
    resourceGroupName: docs</pre>			<p>Then, push<a id="_idIndexMarker616"/> the CR to your Git repository that will be managed by Argo CD. The CD part should now happen over GitOps with Argo CD and you should see the created managed Azure network resource in <span class="No-Break">the portal.</span></p>
			<p>However, this setup assumes the existence of a managed cluster where the necessary tools are deployed and configured. It comes with the following <span class="No-Break">potential weaknesses:</span></p>
			<ul>
				<li><strong class="bold">The complexity of a Kubernetes ecosystem</strong>: It requires a thorough understanding of Kubernetes, including CRDs and CRs, which might be challenging for teams less familiar with <span class="No-Break">these concepts</span></li>
				<li><strong class="bold">Dependency on a managed cluster</strong>: The approach is contingent on a managed Kubernetes cluster, limiting its applicability in environments where such a setup is <span class="No-Break">not available</span></li>
				<li><strong class="bold">Resource intensiveness</strong>: The approach might be resource-intensive, requiring more compute power and memory within <span class="No-Break">the cluster</span></li>
				<li><strong class="bold">Configuration and maintenance</strong>: Managing and maintaining the configurations of CRDs and CRs can be cumbersome and error-prone, especially in large-scale deployments and <span class="No-Break">version upgrades</span></li>
			</ul>
			<p>As you can see, there<a id="_idIndexMarker617"/> is no one-size-fits-all approach that meets all requirements. The right approach for a team depends greatly on the company’s specific needs, the size of the teams, the team’s skill set in various areas, and more. However, we should still take a moment to revisit why treating infra-as-apps is <span class="No-Break">a game-changer.</span></p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor153"/>Why infra-as-apps is a game-changer?</h2>
			<p>To summarize, here’s a<a id="_idIndexMarker618"/> list of the benefits of infra-as-apps that makes it <span class="No-Break">a game-changer:</span></p>
			<ul>
				<li><strong class="bold">Security</strong>: By centralizing key management and shifting from direct cloud access to change management via Git, infra-as-apps enhances security. This approach minimizes risks associated with direct cloud access and improves audit trails by tracking changes through <span class="No-Break">version control.</span></li>
				<li><strong class="bold">Efficient resource management</strong>: This model streamlines the provisioning of new resources and the upgrading of existing ones. It allows for more agile and responsive infrastructure management, reducing the time and effort required for resource allocation <span class="No-Break">and updates.</span></li>
				<li><strong class="bold">Improved CI/CD for pull requests</strong>: Infra-as-apps focuses on enhancing pull requests within CI/CD pipelines, offering automated rollbacks and more thorough testing. This leads to more robust and reliable deployment processes, ensuring higher quality and stability in <span class="No-Break">production environments.</span></li>
				<li><strong class="bold">Easier multi-cloud provisioning</strong>: With tools such as Crossplane, infra-as-apps facilitates provisioning across various cloud environments. This capability simplifies the implementation of multi-cloud strategies, making it easier to manage and deploy resources across different cloud <span class="No-Break">platforms efficiently.</span></li>
				<li><strong class="bold">Simplified infrastructure management</strong>: This approach significantly streamlines the process of managing infrastructure, making it more efficient and less prone to <span class="No-Break">human error.</span></li>
				<li><strong class="bold">Ease of onboarding and resource provisioning for developers</strong>: It simplifies the process for developers to get started and manage resources, reducing <a id="_idIndexMarker619"/>the time and complexity involved in setting up and <span class="No-Break">deploying applications.</span></li>
				<li><strong class="bold">Faster mean time to recover (MTTR)</strong>: It improves the speed of recovery <span class="No-Break">from failures.</span></li>
				<li><strong class="bold">Solid auditability</strong>: It provides comprehensive audit trails and clear accountability, making it easier to track changes and maintain compliance with <span class="No-Break">regulatory standards.</span></li>
			</ul>
			<p>There are numerous companies, such as CERN, Splash, Grafana Labs, IBM, and SAP, that have already adopted Crossplane for a variety of use cases. A prime example of infra-as-apps in action can be seen at CERN, as presented by Ricardo Rocha at GitOpsCon US 2021, <em class="italic">A Multi-Cluster, Multi-Cloud Infrastructure with GitOps at CERN</em> [<em class="italic">2</em>]. CERN, renowned for operating the Large Hadron Collider, leverages infra-as-apps to manage an extensive infrastructure, including over 600 clusters, 3,000 nodes, 13,000 cores, 30 TBs of RAM, and 160 TBs of raw storage, to process vast amounts of data from experiments. They manage a massive array of clusters and computing resources using Kubernetes. CERN’s implementation involves Helm charts with Crossplane configurations for cluster and resource management, allowing rapid scaling and multi-cloud <span class="No-Break">resource allocation.</span></p>
			<p>As a second example, IBM’s use of Crossplane and GitOps to manage the infrastructure life cycle and application deployments is noteworthy. In <em class="italic">GitOpsify Everything: When Crossplane Meets Argo CD</em> [<em class="italic">4</em>], presented by Ken Murray, a CI/CD engineer at IBM, and Ying Mo, a software engineer, they explore the integration of Crossplane with Argo CD in various IT environments. IBM’s approach involves using Crossplane as an abstraction layer for infrastructure provisioning and cluster management, enabling them to maintain a pool of Kubernetes clusters efficiently. This method leverages Helm templates for defining resource configurations and simplifies cluster management by allowing users to interact with simple resource types while Crossplane handles communication with <span class="No-Break">cloud providers.</span></p>
			<p>Infra-as-apps distinguishes itself from traditional <strong class="bold">infra-as-code</strong> by fully embracing GitOps at all levels. This approach treats manual changes to infrastructure as deviations from the Git-defined desired state, enhancing security and predictability in infrastructure management. It represents a significant shift in how infrastructure is managed, aligning it more closely with the dynamic and automated nature of application development <span class="No-Break">and deployment.</span></p>
			<p>GitOps has changed a lot, creating an immutable infrastructure that also has an impact on a company’s culture. In the next section, we will look at <span class="No-Break">immutable infrastructure.</span></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor154"/>Understanding the principles of immutable infrastructure</h1>
			<p>The <strong class="bold">principles of immutable infrastructure</strong>, combined with the GitOps approach, offer a <a id="_idIndexMarker620"/>transformative way of managing infrastructure and deployments in modern software development environments. Immutable infrastructure refers to a model where servers, once deployed, are never directly modified. Instead, changes require the server to be replaced with a new instance. This model drastically reduces issues caused by configuration drift and enhances the reliability of systems by treating servers as disposable units that can be replaced quickly, offering greater scalability and efficiency in <span class="No-Break">deployment processes.</span></p>
			<p>Incorporating GitOps into this model amplifies these benefits. GitOps leverages Git as the central source of truth for managing both software applications and infrastructure. It applies cloud-native patterns to deployments, often associated with Kubernetes but also applicable to various platforms. The core principles of GitOps include treating infrastructure as code, ensuring versioned and immutable deployments, automatic pulling of the desired state, and continuous reconciliation between the desired and <span class="No-Break">actual states.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor155"/>The essence of immutable infrastructure</h2>
			<p>Immutable infrastructure<a id="_idIndexMarker621"/> is a concept where servers, once deployed, are never modified; if a change is needed, a new instance is created and replaced. This approach is fundamentally different from traditional mutable infrastructure, where servers are continually updated and modified. The immutable model brings several <span class="No-Break">key advantages.</span></p>
			<p>The<a id="_idIndexMarker622"/> advantages of immutable infrastructure are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Consistency and reliability</strong>: Immutable servers remain in a known, stable state, significantly reducing the risk of unexpected issues due to environmental drift <span class="No-Break">or inconsistencies</span></li>
				<li><strong class="bold">Enhanced security</strong>: With servers not being modified post-deployment, the attack surface remains constant, simplifying security management and <span class="No-Break">anomaly detection</span></li>
				<li><strong class="bold">Simplified management and debugging</strong>: Troubleshooting becomes more straightforward as the infrastructure stays in a <span class="No-Break">predictable state</span></li>
				<li><strong class="bold">Scalability and performance</strong>: New instances can be spun up and down efficiently to meet demand, maintaining a consistent <span class="No-Break">performance level</span></li>
			</ul>
			<p>However, this approach isn’t without <a id="_idIndexMarker623"/><span class="No-Break">its challenges:</span></p>
			<ul>
				<li><strong class="bold">Increased storage and resource needs</strong>: Immutable infrastructure can require more storage since each change involves creating a <span class="No-Break">new instance</span></li>
				<li><strong class="bold">Potential deployment overhead</strong>: Setting up an entirely new instance for every change can be more resource-intensive than updating an <span class="No-Break">existing one</span></li>
				<li><strong class="bold">Complexity in configuration management</strong>: Managing numerous server instances can become complex, particularly in <span class="No-Break">large-scale environments</span></li>
			</ul>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor156"/>Integrating immutable infrastructure with GitOps</h2>
			<p>Incorporating GitOps <a id="_idIndexMarker624"/>into immutable infrastructure leverages Git’s core principles – version control, collaboration, and automation – to operational management, enabling a system where infrastructure is treated as code, with all configurations and states meticulously maintained in Git repositories for enhanced consistency <span class="No-Break">and traceability.</span></p>
			<p>The advantages of <a id="_idIndexMarker625"/>GitOps are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Single source of truth</strong>: Having a single repository for both application and infrastructure code ensures consistency <span class="No-Break">and traceability</span></li>
				<li><strong class="bold">Automated, reliable deployments</strong>: Continuous deployment via GitOps operators automates and simplifies the <span class="No-Break">deployment process</span></li>
				<li><strong class="bold">Enhanced collaboration and transparency</strong>: Pull request workflows enhance collaboration, providing clear audit trails and ensuring accountability <span class="No-Break">in changes</span></li>
				<li><strong class="bold">Improved security and compliance</strong>: Git’s inherent features facilitate robust access control, encryption, and <span class="No-Break">compliance adherence</span></li>
			</ul>
			<p>Despite these benefits, GitOps is not without<a id="_idIndexMarker626"/> <span class="No-Break">its drawbacks:</span></p>
			<ul>
				<li><strong class="bold">Complexity in scaling</strong>: Managing multiple repositories and dealing with the complexity of large-scale deployments can <span class="No-Break">be challenging.</span></li>
				<li><strong class="bold">Git limitations for operational tasks</strong>: Git, primarily designed for code version control, may not be the best fit for operational updates, leading to <span class="No-Break">potential conflicts.</span></li>
				<li><strong class="bold">Learning curve and adoption resistance</strong>: Teams may face a steep learning curve or resistance to adopting new workflows, tools, and mindsets. I will cover this <span class="No-Break">part later.</span></li>
			</ul>
			<h3>Synergy and challenges</h3>
			<p>When immutable<a id="_idIndexMarker627"/> infrastructure and GitOps are combined, they create a <span class="No-Break">powerful synergy:</span></p>
			<ul>
				<li><strong class="bold">Infrastructure as a dynamic, version-controlled entity</strong>: Infrastructure is treated similarly to application code, with changes tracked, reviewed, and deployed using <span class="No-Break">GitOps methodologies</span></li>
				<li><strong class="bold">Rapid recovery and rollback capabilities</strong>: The combination allows for quick recovery from failures and easy rollbacks to previous <span class="No-Break">stable states</span></li>
				<li><strong class="bold">Streamlined operations</strong>: This approach reduces the need for manual intervention, minimizing human error and <span class="No-Break">streamlining operations</span></li>
			</ul>
			<p>However, this integration<a id="_idIndexMarker628"/> also presents <span class="No-Break">unique challenges:</span></p>
			<ul>
				<li><strong class="bold">Complex workflow management</strong>: Balancing the immutable aspects of infrastructure with the dynamic nature of GitOps workflows requires careful planning <span class="No-Break">and execution</span></li>
				<li><strong class="bold">Dependency on tooling and processes</strong>: The effectiveness of this approach is heavily reliant on the right tooling and <span class="No-Break">well-defined processes</span></li>
				<li><strong class="bold">Balancing security and agility</strong>: Ensuring security in a rapidly changing environment necessitates a fine balance between rigid controls and <span class="No-Break">operational flexibility</span></li>
			</ul>
			<h3>Achieving an effective production environment using immutable infrastructure</h3>
			<p>The <a id="_idIndexMarker629"/>optimal immutable infrastructure for production environments can be conceptualized by integrating several key practices, refined through experience. Here’s how an effective production environment might look <span class="No-Break">and why:</span></p>
			<ul>
				<li><strong class="bold">Read-only access to a Kubernetes prod cluster</strong>: In a productive environment, a Kubernetes cluster should be treated like a managed service or a <em class="italic">black box</em> from a developer’s perspective. This means that access to the cluster should be primarily read-only. Developers should not be permitted to make manual changes to the cluster, ensuring a controlled and <span class="No-Break">stable environment.</span></li>
				<li><strong class="bold">Only create and delete resources through GitOps</strong>: This principle dictates that all resources entering the cluster should be managed exclusively through GitOps. This includes the entire creation process, covering elements such as namespaces, deployments, services, ingress, service accounts, and more. This approach ensures that changes are <strong class="bold">traceable</strong>, <strong class="bold">reversible</strong>, and <strong class="bold">consistent</strong> with the source of truth in the <span class="No-Break">Git repository.</span></li>
				<li><strong class="bold">Do not create namespaces over applications</strong>: In the context of Argo CD and its<a id="_idIndexMarker630"/> concept of application, an application mustn’t be able to create namespaces. This is because Argo CD does not support the deletion of namespaces created by an application <em class="italic">[5]</em>. This restriction is in place to prevent uncontrolled namespace creation, which could lead to conflicts and management issues in shared environments. In the following example, I will clarify the situation for you by illustrating the practical implications and potential risks associated with managing namespaces in a shared environment using <span class="No-Break">Argo CD.</span><p class="list-inset">Consider a scenario where five teams share a single Kubernetes namespace. Each team creates its own Argo CD application to deploy its service components, contributing to the overall microservices architecture. Suppose Team A decides to decommission its service. They proceed to delete their application and the associated deployed service, and they also attempt to delete the shared namespace through their application. However, Argo CD applications do not inherently have knowledge of or connections to other applications or unlinked resources within the same namespace. Consequently, if such a deletion were permitted, it would inadvertently result in the removal of the namespace and all other services deployed by the different teams within it. Fortunately, this scenario is not feasible in practice, as the Argo project team does not implement such a feature to avoid these kinds of disruptive and <span class="No-Break">unintended consequences.</span></p></li>
				<li><strong class="bold">Use the right tools, such as PR-Generator</strong>: Integrating tools such as PR-Generator in a GitOps workflow with Argo CD can greatly enhance the testing and deployment processes. PR-Generator can create resources with a specific prefix as soon as a PR is initiated, ensuring that resources are correctly created and cleaned up, respecting the <em class="italic">do not create namespaces over </em><span class="No-Break"><em class="italic">application</em></span><span class="No-Break"> principle.</span></li>
			</ul>
			<p>By adhering to these practices, several benefits can <span class="No-Break">be realized:</span></p>
			<ul>
				<li>Every change is made through Git, ensuring a centralized and version-controlled change <span class="No-Break">management process</span></li>
				<li>Changes are recorded in the Git history, providing a transparent and traceable record of <span class="No-Break">all modifications</span></li>
				<li>Resources are cleanly managed, with no residual “orphaned” resources left in <span class="No-Break">the cluster</span></li>
				<li>Clean and efficient workflow management using PRs and Git, facilitated by tools such <span class="No-Break">as PR-Generator</span></li>
				<li>It establishes a standard and commitment within the organization, allowing these practices to be replicated across <span class="No-Break">different projects</span></li>
			</ul>
			<p>Implementing these principles in a <a id="_idIndexMarker631"/>production environment creates a robust, secure, and manageable infrastructure that leverages the benefits of both immutable infrastructure and <span class="No-Break">GitOps methodologies.</span></p>
			<p>A potential folder structure for an application that <a id="_idIndexMarker632"/>utilizes both <strong class="bold">Kustomize</strong> and Argo CD might be structured <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
.
├── base
│   ├── kustomization.yaml
│   ├── namespace.yaml
│   ├── role.yaml
│   ├── rolebinding.yaml
│   ├── service.yaml
│   ├── serviceaccount.yaml
│   ├── statefulset.yaml
│   ├── templates
│   │   └── statefulset_template.yaml
│   └── values.yaml
└── overlays
    ├── production
    │   ├── kustomization.yaml
    │   ├── namespace.yaml
    │   └── statefulset.yaml
    └── staging
        ├── kustomization.yaml
        ├── namespace.yaml
        └── statefulset.yaml</pre>			<p>This structure <a id="_idIndexMarker633"/>ensures that all resources can be deployed and cleaned up through Argo CD and the GitOps approach, eliminating the need to set the <strong class="source-inline">AUTO-CREATE NAMESPACE</strong> option in the Application Sync Options for <span class="No-Break">namespace creation.</span></p>
			<h3>Application configuration for immutable infrastructure</h3>
			<p>Next, we<a id="_idIndexMarker634"/> will examine a potential application configuration that contributes to an immutable <span class="No-Break">infrastructure setup:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer088">
					<img alt="Figure 7.4 – Example of an application sync policy configuration" src="image/B22100_07_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Example of an application sync policy configuration</p>
			<p>The following flags <a id="_idIndexMarker635"/>should be set if you want to get the most immutable <span class="No-Break">infrastructure setup:</span></p>
			<ul>
				<li><strong class="bold">PRUNE RESOURCES</strong>: Enable this option to allow Argo CD to automatically delete resources that are present in the cluster but no longer defined in the Git repository. This ensures that all resources in the cluster are managed through the <span class="No-Break">GitOps approach.</span></li>
				<li><strong class="bold">SELF HEAL</strong>: Enable this option. It ensures that any changes made directly in the cluster that deviate from the Git repository are automatically corrected by Argo CD, maintaining the desired state as defined <span class="No-Break">in Git.</span></li>
				<li><strong class="bold">SET DELETION FINALIZER</strong>: Enable this option to ensure that resources are only deleted from the cluster when they are removed from the Git repository. This prevents premature deletion and ensures resources are cleaned up only after their removal <span class="No-Break">from Git.</span></li>
				<li><strong class="bold">RESPECT IGNORE DIFFERENCES</strong>: Enable this to instruct Argo CD to ignore specific differences it doesn’t recognize. You can define in the Argo CD configuration what specific differences <span class="No-Break">to ignore.</span></li>
				<li><strong class="bold">AUTO-CREATE NAMESPACE</strong>: Ensure this option is disabled to prevent Argo CD from automatically creating namespaces. Namespaces should be explicitly defined as resources in your <span class="No-Break">Git repository.</span></li>
			</ul>
			<p>By setting<a id="_idIndexMarker636"/> these policies, you ensure that resource creation, deletion, and synchronization are all managed through changes in your Git repository while adhering to the principles of GitOps. This approach ensures a tight coupling between the declared state in Git and the actual state in <span class="No-Break">the cluster.</span></p>
			<p>The combination of immutable infrastructure and GitOps represents a modern approach to IT operations and development. It brings together the best of stability, security, and dynamic, automated workflows. While it offers significant advantages in terms of reliability, security, and efficiency, it also poses challenges in terms of complexity, resource demands, and dependency on specific tools and practices. As with any IT methodology, success in implementing these concepts depends on a clear understanding of their benefits and limitations, careful planning, and an adaptive approach to evolving <span class="No-Break">IT landscapes.</span></p>
			<p>So far, we’ve looked at various aspects of transformation that come with GitOps. But what’s the point of all this if you can’t get or measure any added value from it? That’s why, in the next section, we’ll look at specific metrics that make product <span class="No-Break">quality measurable.</span></p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor157"/>Introducing DORA metrics</h1>
			<p>In this section, we’ll <a id="_idIndexMarker637"/>introduce you to DORA metrics and delve into a set of key performance indicators developed by the DORA team. These metrics are pivotal in evaluating and improving software delivery and operational performance within IT teams. The four principal DORA metrics are <strong class="bold">Deployment Frequency</strong>, <strong class="bold">Lead Time for Changes</strong>, <strong class="bold">Change Failure Rate</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="bold">MTTR</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Deployment Frequency</strong>: This<a id="_idIndexMarker638"/> assesses how often a team successfully deploys code to production. Frequent deployments are indicative of an efficient and responsive development process, allowing for quicker feedback and <strong class="bold">continuous improvement</strong>. To increase the frequency of deployments, adopt CI/CD practices. Automate your build and deployment pipelines using tools such as <strong class="bold">Jenkins</strong>, <strong class="bold">GitHub Actions</strong>, or <strong class="bold">GitLab CI</strong>. Regular, smaller<a id="_idIndexMarker639"/> deployments reduce<a id="_idIndexMarker640"/> risks <a id="_idIndexMarker641"/>and facilitate quicker feedback. Additionally, feature flags can be used to manage deployments and gradually roll out <span class="No-Break">new features.</span></li>
				<li><strong class="bold">Lead Time for Changes</strong>: This <a id="_idIndexMarker642"/>measures the duration from code commit to code deployment in production. This metric indicates the speed and agility of the development process. Shorter lead times often result in faster feedback from users and the ability to adapt and improve the software swiftly. Improve lead time by optimizing your development processes. This includes adopting Agile methodologies, increasing collaboration between teams, and integrating code review and testing into the development process. Utilize automated testing<a id="_idIndexMarker643"/> and <strong class="bold">continuous integration</strong> tools to ensure that code changes are tested and integrated quickly. Tracking tools can be used to monitor the time from code commit to deployment, helping <span class="No-Break">identify bottlenecks.</span></li>
				<li><strong class="bold">Change Failure Rate</strong>: This<a id="_idIndexMarker644"/> focuses on the percentage of deployments that result in a production failure. This metric is essential for understanding the reliability and stability of the software development process. A lower change failure rate signifies higher quality and reliability in software deployments. To reduce the change failure rate, focus on enhancing the <strong class="bold">quality of code</strong> and the reliability of deployments. Implement automated testing, including unit tests, integration tests, and end-to-end tests, to catch issues early. Employ static code analysis tools and conduct thorough code reviews. Practice continuous deployment with automated rollbacks, and use <strong class="bold">canary releases</strong> or <strong class="bold">blue-green deployments</strong> to minimize the impact of <span class="No-Break">failed deployments.</span></li>
				<li><strong class="bold">MTTR</strong>: This is the<a id="_idIndexMarker645"/> average time taken to recover from a failure in the production environment. This metric is crucial as it reflects the team’s ability to quickly rectify issues, thereby minimizing downtime and maintaining service quality. Reducing MTTR involves improving incident response and recovery processes. Implement monitoring and alerting tools such as <a id="_idIndexMarker646"/>Prometheus, Grafana, or New Relic to quickly detect issues. Establish clear incident management protocols and on-call rotations. Use IaC tools such as Terraform to enable fast and consistent environment recovery. Regularly practice incident response drills to ensure the team is prepared for <span class="No-Break">quick recovery.</span></li>
			</ul>
			<p>These metrics align well with the GitOps approach, which emphasizes automation, monitoring, and quick feedback. GitOps can enhance Deployment Frequency and Lead Time for Changes through automated pipelines. It also helps in reducing the Change Failure Rate and MTTR by enabling quicker rollbacks and promoting more reliable deployments through practices like continuous integration <span class="No-Break">and delivery.</span></p>
			<p>However, while DORA metrics provide valuable insights, they come with challenges. Implementing these metrics requires a mature DevOps team and established CI/CD processes. Data collection and tagging need to be precise and actionable. The metrics must be adapted to the unique cadences and processes of different teams <span class="No-Break">and products.</span></p>
			<p>In terms of measuring these metrics independently from specific Git <strong class="bold">Source Version Controls</strong> (<strong class="bold">SVCs</strong>) such <a id="_idIndexMarker647"/>as DevOps, GitHub, or GitLab, organizations can look toward integrating various tools that provide necessary data visualizations and dashboards. Teams can leverage APIs from different tools to gather relevant data points for calculating these metrics. For example, Deployment Frequency can be monitored using tools that track code deployments, while Lead Time for Changes can be calculated by extracting timestamps for code commits and deployments from version <span class="No-Break">control systems.</span></p>
			<p>Organizations can choose to implement DORA metrics either by developing logic tailored to their environments or by utilizing established tools such as <strong class="bold">GitLab’s Value Stream Analytics Dashboard</strong>. GitLab’s dashboard [<em class="italic">6</em>] effectively visualizes the software<a id="_idIndexMarker648"/> development life cycle and computes DORA metrics. It provides an interactive interface for tracing essential phases of the software delivery process and enables teams to customize the dashboard to align with their specific workflow, enhancing the understanding of lead time, cycle time, and other vital metrics. This feature aids in identifying bottlenecks and areas needing improvement, thus boosting deployment frequency and overall <span class="No-Break">DevOps performance.</span></p>
			<p>Similarly, <strong class="bold">SquaredUp</strong> specializes<a id="_idIndexMarker649"/> in Azure DevOps integration [<em class="italic">7</em>] and offers a DORA metrics dashboard designed specifically for DevOps teams. This dashboard presents a comprehensive view of crucial performance indicators, including Deployment Frequency, Lead Time for Changes, Change Failure Rate, and MTTR. It supports teams in monitoring and analyzing their software delivery process, facilitating the identification of areas for enhancement. SquaredUp’s solution emphasizes data-driven decision-making in software development, showcasing the importance of metrics in optimizing <span class="No-Break">DevOps workflows.</span></p>
			<p>The key to successfully utilizing DORA metrics lies in understanding the context of these measurements, interpreting them collectively rather than in isolation, and adapting them to suit the unique requirements of individual teams <span class="No-Break">and projects.</span></p>
			<p>In conclusion, DORA metrics provide a structured and quantifiable approach to assessing and improving DevOps performance. They offer a comprehensive view of the software delivery process, highlighting areas for improvement and fostering a <strong class="bold">culture of continuous development</strong> and <span class="No-Break">operational efficiency.</span></p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor158"/>Understanding the need for continual improvement in GitOps</h1>
			<p>In the<a id="_idIndexMarker650"/> ever-evolving landscape of software development, the adoption of GitOps marks a significant transition in collaborative approaches and operational efficiencies. GitOps, a methodology that combines Git with Kubernetes’ operational workflows, is more than just a set of practices – it<a id="_idIndexMarker651"/> represents a continuous journey of improvement and adaptation. This section explores how GitOps necessitates and facilitates <strong class="bold">continual improvement</strong> across various domains such as security, development, platform engineering, and <span class="No-Break">financial operations:</span></p>
			<ul>
				<li><strong class="bold">Evolving security practices with GitOps</strong>: Security in the GitOps realm is dynamic and <strong class="bold">continuously evolving</strong>. Teams <a id="_idIndexMarker652"/>deploy policies using tools such as <strong class="bold">Kyverno</strong>, adjusting to the rapidly changing landscape of security threats. The emergence of new vulnerabilities and attack vectors demands a proactive and adaptive approach. GitOps supports this by allowing for quick iteration and deployment of <strong class="bold">security policies</strong>. However, the approach to managing secrets has seen shifts – from using tools such as Sealed Secrets to adopting External-Secrets Operators. This transition underscores the need for teams to<a id="_idIndexMarker653"/> constantly evolve their tools and practices, staying ahead in a domain where stagnation equates <span class="No-Break">to vulnerability.</span></li>
				<li><strong class="bold">Developers’ continuous innovation through GitOps</strong>: For developers, GitOps is not just<a id="_idIndexMarker654"/> a method of deployment but a catalyst for <strong class="bold">continuous innovation</strong>. Techniques such as <strong class="bold">blue-green</strong> and <strong class="bold">canary deployments</strong> become <a id="_idIndexMarker655"/>more <a id="_idIndexMarker656"/>streamlined, while <a id="_idIndexMarker657"/>new tools such as PR-Generators enhance the deployment processes. These innovations are vital in a landscape where deployment strategies and tools are in a constant state of change. GitOps empowers developers to rapidly deploy, experiment, and iterate, thereby fostering a culture of continual improvement and agile responsiveness to market and <span class="No-Break">technological changes.</span></li>
				<li><strong class="bold">Platform engineering and scalable infrastructure</strong>: Platform engineering teams find GitOps an ally for managing infrastructure with efficiency and scalability. Patterns such as <em class="italic">App of Apps</em> and <em class="italic">ApplicationSets with Cluster Generator</em> in Argo CD demonstrate the evolving nature of infrastructure management. Tools such as Crossplane and Cluster API extend the capabilities of GitOps from mere application deployment to managing and provisioning diverse cloud resources. This evolution highlights the necessity for teams to continually adapt and enhance their skills and tools to manage increasingly complex and distributed <span class="No-Break">systems effectively.</span></li>
				<li><strong class="bold">FinOps – financial optimization in the age of GitOps</strong>: In the FinOps domain, GitOps <a id="_idIndexMarker658"/>introduces tools <a id="_idIndexMarker659"/>such as <strong class="bold">OpenCost</strong>, enabling detailed cost tracking and allocation down to the namespace level. Such granularity in cost allocation and the ability to adjust resource availability based on usage patterns represent a significant shift in managing cloud costs. It also illustrates the ongoing need for financial operations teams to integrate new tools and strategies to optimize costs continually. The use of tools<a id="_idIndexMarker660"/> such as <strong class="bold">Kubegreen</strong>, which adjusts resources based on demand, is a testament to the evolving nature of financial operations in <span class="No-Break">cloud environments.</span></li>
			</ul>
			<p>The journey <a id="_idIndexMarker661"/>with GitOps is ongoing and<a id="_idIndexMarker662"/> multifaceted. Teams across different domains – from security to development and platform engineering to FinOps – must not only adopt GitOps but also embrace its ethos of continual improvement. This involves regular evaluations, a willingness to adopt new tools and practices, and a commitment to learning <span class="No-Break">and adaptation.</span></p>
			<p>In the final section of this chapter, we will explore overcoming <strong class="bold">cultural barriers</strong>, adopting GitOps, and how different teams are currently working with <span class="No-Break">varying approaches.</span></p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor159"/>Overcoming cultural barriers to adopt GitOps</h1>
			<p>Adopting GitOps<a id="_idIndexMarker663"/> goes beyond just tool implementation; it involves a cultural shift within organizations.  This transition involves breaking down traditional departmental barriers, nurturing collaboration, and uniting teams toward shared goals. GitOps acts as a unifying force, streamlining operations and development toward a more efficient IT environment. Continual improvement in GitOps is essential in the dynamic world of software development. This journey focuses on learning, adapting, and <span class="No-Break">evolving practices.</span></p>
			<p>When <a id="_idIndexMarker664"/>examining different definitions or contrasting GitOps with DevOps, the technical aspects can be summarized via the Weaveworks blog on GitOps culture, which elaborates on how GitOps extends beyond a set of tools or practices to encompass a broader cultural shift within organizations. This approach integrates Git at the heart of both operational and developmental processes, emphasizing transparency, accountability, and collaboration. GitOps culture is characterized by the centralization of Git in managing infrastructure, applications, and CI/CD processes, enhancing automation, stability, and consistency. It fosters an environment where team members are engaged in a continuous cycle of improvement, enabled by the visibility and control offered by <span class="No-Break">Git-based workflows.</span></p>
			<p>It might be right about the GitOps approach and the associated technical challenges, as well as the responsibility, collaboration, and more. I’m not saying it’s wrong, because it isn’t. However, I want to shift the focus to a perspective that also considers the daily<a id="_idIndexMarker665"/> work in various industries. Not every company is a software company <span class="No-Break">like Weaveworks.</span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor160"/>A project’s story – exchange, experiences, and learnings</h2>
			<p>From my <a id="_idIndexMarker666"/>experience and <a id="_idIndexMarker667"/>discussions with <strong class="bold">DevOps professionals</strong>, <strong class="bold">CTOs</strong>, and <strong class="bold">platform engineers</strong>, it’s clear that tool and approach changes are more straightforward than altering a team or company mindset, which requires time <span class="No-Break">for transformation.</span></p>
			<p>Some companies handle this <span class="No-Break">like so:</span></p>
			<ul>
				<li>In our use of GitOps with Argo CD for infrastructure and application services, we’ve noticed significant improvements. For instance, we can easily identify drifts in our staging and production environments, which are monitored closely. For development and ephemeral environments, we use Helm and CD pipelines without <span class="No-Break">tracking changes.</span></li>
				<li>Weaveworks on GitOps culture highlights how GitOps, particularly through Weave GitOps, fosters a strong team culture characterized by <strong class="bold">excellent communication</strong>, <strong class="bold">coordination</strong>, and <strong class="bold">collaboration</strong>. The clarity in <strong class="bold">roles</strong> and <strong class="bold">responsibilities</strong> provided by GitOps allows teams to <strong class="bold">maintain autonomy</strong>, supported by Kubernetes namespaces for organizing and isolating workloads. Additionally, Weave’s acquisition of Magalix emphasizes security policies in GitOps, enabling admins to set and enforce policies throughout the GitOps process. This approach underscores the operational nature of GitOps culture, distinct from the aspirational culture of DevOps, focusing on precision <span class="No-Break">and accountability.</span></li>
			</ul>
			<p>And I believe Weaveworks hits the nail on the head when you look beyond the technical aspects and read closely. The dialog suggests that the GitOps approach fosters a new culture among different teams, who should master the same tool but for different use cases. The teams can work autonomously, but this requires excellent communication, coordination, and collaboration. Additionally, it involves defining roles and responsibilities. Every change or initiative should be clearly and transparently communicated to the other teams. This all sounds great, but how does it look in real projects with different teams? I will try to illustrate this with an example from one of <span class="No-Break">my projects.</span></p>
			<p>In the <a id="_idIndexMarker668"/>project, there’s a platform team, several developer teams, and a security team. The security team’s role is to ensure not only that security guidelines are adhered to within the organization, but also IT governance and compliance. Therefore, it feels responsible for using all possible means to protect the company and enforce policies throughout the <span class="No-Break">GitOps process.</span></p>
			<p>The platform team provides the necessary Kubernetes clusters and context for the developers, so they only need to focus on their applications and, at most, third-party tools. They see their role as enablers for the developers, who purchase and use the platform as customers, with maximum emphasis on <strong class="bold">self-service</strong>, <strong class="bold">availability</strong>, and <strong class="bold">performance</strong>. The developer teams consume Kubernetes as a product and develop their applications. Let’s see how one team’s reasonable decision can unintentionally harm <span class="No-Break">another team:</span></p>
			<ul>
				<li>The security team enforces a policy that no application can run with elevated privileges, and some applications, both in the platform context and those self-developed, stop working. This results in application downtime and <span class="No-Break">software failure.</span><p class="list-inset">The <em class="italic">rationale</em> for this action is to ensure that the company is protected. </p></li>
				<li>The platform team carried out a Kubernetes upgrade from 1.24 to 1.25 as support for the previous version ended. As a result, the third-party tools used by the security team no longer work. Some of the developers’applications also stop functioning. The change did not consider that the upgrade replaced <em class="italic">PodSecurityPolicies</em> <span class="No-Break">with </span><span class="No-Break"><em class="italic">PodSecurityStandards</em></span><span class="No-Break">.</span><p class="list-inset">The <em class="italic">rationale</em> for this action is to ensure that a supported version is available and that the platform remains up to date as required by the security team. This responsibility includes ensuring that performance is optimized and reliable while maintaining adherence to the latest security protocols and compliance standards associated with the <span class="No-Break">Kubernetes ecosystem.</span></p></li>
				<li>The developers use their autonomy and open a <em class="italic">NodePort</em> on a node with an external IP address for testing purposes. The application becomes externally accessible. The debugging works, but testing takes longer. Fortunately, the application uses <strong class="bold">Log4j</strong> version 2.10 for logging, simplifying the <span class="No-Break">debugging process.</span><p class="list-inset">The <em class="italic">rationale</em> for this action is to increase the performance of testing and debugging. The developers were under pressure to meet deadlines and chose a quick solution to test their applications, prioritizing immediate functionality over long-term security and <span class="No-Break">compliance considerations.</span></p></li>
			</ul>
			<p>Possible causes<a id="_idIndexMarker669"/> that arise from the different actions are that customers are frustrated, the company loses money per minute, and the reputation of the company declines. These are modified use cases and fortunately, my projects were not affected by the Log4J incident. But the point here is not what happened but that these cases occur and are justifiable from the team’s point <span class="No-Break">of view.</span></p>
			<p>Reflecting on the causes of recent challenges, it seems that the varying explanations provided by the different teams are all valid. For example, when examining the changes made by the security and platform teams, they took accountability from their perspective, ensuring that the company was adequately protected and represented. However, they did not consider themselves responsible for application outages or customer loss, believing their actions were justified. This situation could have been potentially avoided with simple communication and transparency about the impending changes <span class="No-Break">between teams.</span></p>
			<p>From the developers’ viewpoint, they were under pressure to meet a deadline to prevent further delays for a feature, which is already behind schedule, causing frustration among customers. Debugging was activated only in the development environment, and they assumed it was unnecessary to inform the security or platform teams, believing that these teams wouldn’t understand the change and would impede it without reason. The developers felt they were acting in the company’s best interest and aiming to satisfy <span class="No-Break">their customers.</span></p>
			<p>From the developers’ viewpoint, they felt a strong sense of accountability to meet a deadline. However, they overlooked the importance of simple communication and transparency with the security or platform teams, assuming these teams wouldn’t comprehend the change and might unnecessarily impede it. In their pursuit to act in the company’s best interest and satisfy customers, they missed an opportunity for collaboration that could have harmonized their efforts with the broader <span class="No-Break">organizational goals.</span></p>
			<h3>The learnings</h3>
			<p>The learnings from these incidents led to the creation of a guild, with representatives from each team attending meetings. This allowed for changes and their impacts to be discussed and made visible, fostering clear communication and collaboration between teams. Additionally, it helped different teams understand each other’s perspectives, needs, and reasons, enhancing transparency. While not all decisions were discussed, and changes were sometimes made rapidly due to time constraints or urgency, such as in the case of critical security vulnerabilities, the overall situation improved. The increased transparency helped in better understanding the impact of changes, reducing the blast radius of these changes. Empathy among team members increased, and the culture of blaming <span class="No-Break">significantly decreased.</span></p>
			<p>Did things overall <span class="No-Break">improve? </span><span class="No-Break"><em class="italic">Yes</em></span><span class="No-Break">!</span></p>
			<p>Were all decisions discussed and changes made only after consultation? <em class="italic">No</em>, as time constraints and urgency often lead to decisions being <span class="No-Break">made quickly.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor161"/>Essential Q&amp;A from another recent project</h2>
			<p>In this section, we’ll focus on specific questions and answers from a company, and various projects, that are still in the process of transformation, having started with the DevOps approach and now shifted to platform engineering, including their honest reasoning for <span class="No-Break">this change:</span></p>
			<ul>
				<li>Q1: How did GitOps restructure your <span class="No-Break">team organization?</span><p class="list-inset">A1: Initially, we had separate DevOps teams per project. GitOps led to the creation of a central platform team to manage Kubernetes <span class="No-Break">clusters efficiently.</span></p></li>
				<li>Q2: What were the challenges in transitioning <span class="No-Break">to GitOps?</span><p class="list-inset">A2: Our main challenge was adapting to the <strong class="bold">immutable infrastructure</strong> GitOps offers, especially understanding that all changes need to flow through <span class="No-Break">Git commits.</span></p></li>
				<li>Q3: What benefits have you realized <span class="No-Break">with GitOps?</span><p class="list-inset">A3: GitOps has brought us a clear, traceable workflow. Every change, big or small, is now meticulously tracked <span class="No-Break">via Git.</span></p></li>
				<li>Q4: How has GitOps affected <span class="No-Break">team communication?</span><p class="list-inset">A4: Communication has significantly improved. Our platform team has developed a <strong class="bold">deeper understanding</strong> of the developers’ needs, leading to more <span class="No-Break"><strong class="bold">empathetic collaboration</strong></span><span class="No-Break">.</span></p></li>
				<li>Q5: Can you share any successful <span class="No-Break">cultural transformations?</span><p class="list-inset">A5: Definitely. We’ve developed a <strong class="bold">proactive error culture</strong>, focusing on automation and <strong class="bold">continuous learning</strong>, which has fundamentally changed our <span class="No-Break">problem-solving approach.</span></p></li>
				<li>Q6: How has daily work evolved for your teams <span class="No-Break">with GitOps?</span><p class="list-inset">A6: There’s a noticeable increase in <strong class="bold">motivation</strong> and <strong class="bold">responsibility</strong> among team members, with a greater sense of <strong class="bold">autonomy</strong> in <span class="No-Break">their roles.</span></p></li>
				<li>Q7: How did your team adapt <span class="No-Break">to GitOps?</span><p class="list-inset">A7: Surprisingly, there was a little resistance. The team understood the necessity of this transformation and was quite receptive <span class="No-Break">to it.</span></p></li>
				<li>Q8: How do you measure the success of <span class="No-Break">this transition?</span><p class="list-inset">A8: While we don’t have precise metrics yet, the reduction in <strong class="bold">manual interventions</strong> and the increase in <strong class="bold">Git activities</strong> are strong indicators <span class="No-Break">of success.</span></p></li>
				<li>Q9: What is your <span class="No-Break">team size?</span><p class="list-inset">A9: Our team consists of around 20 developers and three <span class="No-Break">platform engineers.</span></p></li>
			</ul>
			<p>This conversation format allows for a clear understanding of how GitOps has transformed team dynamics, challenges, and <span class="No-Break">workflow efficiency.</span></p>
			<p>Adopting GitOps is more than implementing a set of tools; it involves cultural shifts within organizations. Overcoming traditional silos between departments, fostering a culture of collaboration and continuous learning, and aligning diverse teams toward common operational goals are essential steps in this journey. Thus, the adoption of GitOps becomes a unifying force, aligning varied operational and developmental efforts toward a more efficient, transparent, and responsive <span class="No-Break">IT environment.</span></p>
			<p>In conclusion, the necessity for continual improvement in GitOps is not just a recommendation; it is a requirement in the fast-paced and ever-changing world of software development and IT operations. As teams navigate this journey, the focus should remain on learning, adapting, and evolving practices to stay ahead in an environment where change is the only constant. So, GitOps is less of a destination and more of a path toward operational excellence and <span class="No-Break">continual improvement.</span></p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor162"/>Summary</h1>
			<p>This chapter provided a compelling view of the cultural revolution in IT, brought about by the adoption of GitOps. It started by establishing GitOps as not just a technological shift but a profound cultural metamorphosis within IT departments. This approach, merging software development with IT operations through Git, transforms operational processes and methodologies, treating infrastructure as an application. It enables automation and precision and extends rigorous development practices to <span class="No-Break">infrastructure management.</span></p>
			<p>A key transformation brought about by GitOps is the establishment of immutable infrastructure, automating the alignment of the infrastructure’s actual state with its desired state, and reducing manual interventions and errors. This chapter also explored the impact of GitOps on IT performance through DORA metrics, offering a quantitative assessment of improvements in deployment frequency, change lead time, failure rate, and recovery time. This chapter also addressed the broader organizational implications of GitOps adoption. This goes beyond mere tool implementation; it’s a catalyst for a far-reaching cultural shift, fostering a collaborative, transparent, and efficient IT culture. Real-world examples from various organizations illustrated how GitOps drives <span class="No-Break">these changes.</span></p>
			<p>All in all, this chapter revealed the transformative power of GitOps, transcending technology to chart a path toward a more agile and innovative <span class="No-Break">IT culture.</span></p>
			<p>In the next chapter, we’ll explore the application of GitOps in conjunction with OpenShift, a Kubernetes downstream distribution from Red Hat, and examine how its <span class="No-Break">management differs.</span></p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor163"/>References</h1>
			<ul>
				<li>[<span class="No-Break"><em class="italic">1</em></span><span class="No-Break">] </span><a href="https://codefresh.io/blog/infrastructure-as-apps-the-gitops-future-of-infra-as-code/"><span class="No-Break">https://codefresh.io/blog/infrastructure-as-apps-the-gitops-future-of-infra-as-code/</span></a></li>
				<li>[<span class="No-Break"><em class="italic">2</em></span><span class="No-Break">] </span><a href="https://www.youtube.com/watch?v=h6xDWc6fXao"><span class="No-Break">https://www.youtube.com/watch?v=h6xDWc6fXao</span></a></li>
				<li>[<span class="No-Break"><em class="italic">3</em></span><span class="No-Break">] </span><a href="https://docs.crossplane.io/latest/getting-started/provider-azure/"><span class="No-Break">https://docs.crossplane.io/latest/getting-started/provider-azure/</span></a></li>
				<li>[<span class="No-Break"><em class="italic">4</em></span><span class="No-Break">] </span><a href="https://www.youtube.com/watch?v=9odjdVqJkws"><span class="No-Break">https://www.youtube.com/watch?v=9odjdVqJkws</span></a></li>
				<li>[<span class="No-Break"><em class="italic">5</em></span><span class="No-Break">] </span><a href="https://github.com/argoproj/argo-cd/issues/7875"><span class="No-Break">https://github.com/argoproj/argo-cd/issues/7875</span></a></li>
				<li>[<span class="No-Break"><em class="italic">6</em></span><span class="No-Break">] </span><a href="https://docs.gitlab.com/ee/user/analytics/value_streams_dashboard.html"><span class="No-Break">https://docs.gitlab.com/ee/user/analytics/value_streams_dashboard.html</span></a></li>
				<li>[<span class="No-Break"><em class="italic">7</em></span><span class="No-Break">] </span><a href="https://squaredup.com/dashboard-gallery/dora-metrics-dashboard-devops-team/"><span class="No-Break">https://squaredup.com/dashboard-gallery/dora-metrics-dashboard-devops-team/</span></a></li>
			</ul>
		</div>
	

		<div class="Content" id="_idContainer090">
			<h1 id="_idParaDest-161" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor164"/>Part 3: Hands-on Automating Infrastructure and CI/CD with GitOps</h1>
			<p>In this part, you will get hands-on experience with automating infrastructure and CI/CD processes using GitOps. You will explore specific implementations on platforms such as OpenShift, Azure, and AWS, and integrate tools such as Terraform and Flux CD for enhanced automation. This practical section is designed to equip you with the necessary skills to apply GitOps in diverse environments, ensuring you can manage infrastructure and CI/CD pipelines effectively <span class="No-Break">and efficiently.</span></p>
			<p>This part includes the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B22100_08.xhtml#_idTextAnchor165"><em class="italic">Chapter 8</em></a>, GitOps for OpenShift</li>
				<li><a href="B22100_09.xhtml#_idTextAnchor176"><em class="italic">Chapter 9</em></a>, GitOps for Azure and AWS Deployments</li>
				<li><a href="B22100_10.xhtml#_idTextAnchor190"><em class="italic">Chapter 10</em></a>, GitOps for Infrastructure Automation – Terraform and Flux CD</li>
				<li><a href="B22100_11.xhtml#_idTextAnchor209"><em class="italic">Chapter 11</em></a>, Deploying Real-World Projects with GitOps on Kubernetes</li>
			</ul>
		</div>
		<div>
			<div id="_idContainer091">
			</div>
		</div>
		<div>
			<div class="Basic-Graphics-Frame" id="_idContainer092">
			</div>
		</div>
	</body></html>