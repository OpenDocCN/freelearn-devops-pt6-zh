["```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: PersistentVolumeClaim\n    metadata:\n      name: db-pv-claim\n    spec:\n      accessModes:\n        - ReadWriteOnce\n      resources:\n        requests:\n          storage: 5Gi\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      name: mysql\n    spec:\n      selector:\n        matchLabels:\n          app: mysql\n      strategy:\n        type: Recreate\n      template:\n        metadata:\n          labels:\n            app: mysql\n        spec:\n          containers:\n          - image: mysql:8.0.28-oracle\n            name: mysql\n            env:\n            - name: MYSQL_DATABASE\n              value: sensor_data\n            - name: MYSQL_USER\n              value: lora_mysql\n            - name: MYSQL_PASSWORD\n              value: lora123-\n            - name: MYSQL_ROOT_PASSWORD\n              value: lora123-\n            ports:\n            - containerPort: 3306\n              name: mysql\n            volumeMounts:\n            - name: mysql-persistent-storage\n              mountPath: /var/lib/mysql\n          volumes:\n          - name: mysql-persistent-storage\n            persistentVolumeClaim:\n              claimName: db-pv-claim\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      creationTimestamp: null\n      name: mysql\n    spec:\n      ports:\n      - port: 3306\n        protocol: TCP\n        targetPort: 3306\n      selector:\n        app: mysql\n      type: ClusterIP\n    status:\n      loadBalancer: {}\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      creationTimestamp: null\n      name: mysql-lb\n    spec:\n      ports:\n      - port: 3306\n        protocol: TCP\n        targetPort: 3306\n      selector:\n        app: mysql\n      type: LoadBalancer\n    status:\n      loadBalancer: {}\n    EOF\n    ```", "```\n    $ kubectl run client -it --rm --image=mysql:8.0.28-oracle -- bash\n    ```", "```\n$ mysql -u lora_mysql -h mysql -p\n```", "```\n    use sensor_data;\n    CREATE TABLE metric (device INT NOT NULL,temperature_c DECIMAL(4,2),temperature_f DECIMAL(4,2) NOT NULL,humidity DECIMAL(4,2) NOT NULL, time DATETIME NOT NULL);\n    ```", "```\n    $ MYSQL_IP=\"$(kubectl get svc mysql-lb -o=jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\n    $ echo $MYSQL_IP\n    ```", "```\nfrom flask import Flask, request\nimport mysql.connector\nimport os\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n    return 'It works'\n\ndef insert(data):\n    conn = mysql.connector.connect(\n     host=os.environ['HOST'],\n     user=os.environ['MYSQL_USER'],\n     password=os.environ['MYSQL_PASSWORD'],\n     database=os.environ['MYSQL_DATABASE']\n    )\n    cursor = conn.cursor()\n    sql = \"INSERT INTO metric \"+\\\n          \"(device,temperature_c,\"+\\\n          \"temperature_f,humidity,time) \"+\\\n          \"VALUES (%s,%s,%s,%s,now());\"\n    val = (data[\"d\"],data[\"t\"],data[\"t_f\"],data[\"h\"])\n    cursor.execute(sql,val)\n    conn.commit()\n    cursor.close()\n    conn.close()\n\n@app.route('/device',methods = ['POST'])\ndef device():\n    data = request.json\n    print(data)\n    #Process data in some way\n    t_farenheit = float(data[\"t\"])*(9/5)+32\n    data[\"t_f\"] = t_farenheit\n    insert(data)\n    return \"processed\"\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=3000, debug=True)\n```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: metrics\n      name: metrics\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: metrics\n      strategy: {}\n      template:\n    metadata: \n          creationTimestamp: null\n          labels:\n            app: metrics\n        spec:\n          containers:\n          - image: sergioarmgpl/metric\n    name: metric \n            env:\n            - name: HOST\n              value: \"192.168.0.240\"\n            - name: MYSQL_USER\n              value: \"lora_mysql\"\n            - name: MYSQL_PASSWORD\n              value: \"lora123-\"\n            - name: MYSQL_DATABASE\n              value: \"sensor_data\"\n    resources: {} \n    status: {} \n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      creationTimestamp: null\n      name: metrics\n    spec:\n      ports:\n      - port: 3000\n        protocol: TCP\n        targetPort: 3000\n      selector:\n        app: metrics\n      type: LoadBalancer\n    status:\n      loadBalancer: {}\n    EOF\n    ```", "```\n    $ METRICS_IP=\"$(kubectl get svc metrics -o=jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\n    $ echo METRICS_IP\n    ```", "```\n$ ls /dev | grep cu | grep 'usbserial\\|UART'\n```", "```\ncu.SLAB_USBtoUART\ncu.usbserial-0001\n```", "```\n    $ cp /Users/<YOUR_USER>/Library/Arduino15/packages/Heltec-esp32/hardware/esp32/<X.X.X> /tools/esptool.py /Users/ <YOUR_USER> /Library/Arduino15/packages/Heltec-esp32/tools/esptool_py/<X.X.X>/\n    ```", "```\n    $ chmod +x esptool.py\n    ```", "```\n$ ./esptool.py\n```", "```\n    $ wget https://github.com/pyserial/pyserial/archive/refs/tags/v3.4.zip\n    $ sudo python setup.py install\n    ```", "```\n    $ sudo pip install pyserial or\n    $ sudo pip3 install pyserial\n    ```", "```\n    $ sudo easy_install pyserial\n    ```", "```\n    $ cd /Applications/Arduino.app/Contents/Java/libraries\n    $ mv libraries/WiFi\n    ```", "```\nvoid setup() {\n  // put your setup code here, to run once: \n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n}\n```", "```\n#include \"heltec.h\"\n#define BAND    915E6\n\n#include \"DHT.h\"\n#define DHTPIN 17\n#define DHTTYPE DHT11\nDHT dht(DHTPIN, DHTTYPE);\n\n#define DEVICE 1\n#define DELAY 3000\n\nvoid setup()\n{\n  Heltec.begin(false,true,true,true,BAND);\n  Serial.begin(9600);\n  LoRa.setSyncWord(0xF3);\n  Serial.println(\"LoRa started\");\n  dht.begin();\n}\n\nvoid sendTH()\n{\n  String values = \"\";\n  LoRa.beginPacket();\n  float h = dht.readHumidity();\n  float t = dht.readTemperature();\n  if (isnan(h) || isnan(t)) {\n    Serial.println(F(\"Failed to get data from sensor\"));\n    return;\n  } \n  String hS = (String)h;\n  String tS = (String)t;\n  String dS = (String)DEVICE;\n  values = \"{\\\"t\\\":\"+tS+\",\\\"h\\\":\"+hS+\",\\\"d\\\":\"+dS+\"}\";\n  Serial.println(values);\n  LoRa.print(values);\n  LoRa.endPacket();\n}\n\nvoid loop()\n{\n  delay(DELAY);\n  sendTH();\n}\n```", "```\n#include \"heltec.h\"\n#include \"WiFi.h\"\n#include <HTTPClient.h>\n#define BAND    915E6\n#define METRICS_IP \"192.168.0.241\"\nvoid setup()\n{\n  Heltec.begin(false, true, true, true, BAND);\n  Serial.begin(9600);\n  LoRa.setSyncWord(0xF3);\n  Serial.println(\"LoRa started\");\n  WIFISetUp();\n}\n\nvoid WIFISetUp(void)\n{\n  WiFi.disconnect(true);\n  delay(100);\n  WiFi.mode(WIFI_STA);\n  WiFi.setAutoConnect(true);\n  WiFi.begin(\"NET_NAME\",\"PASSWORD\");\n  delay(100);\n\n  byte count = 0;\n  while(WiFi.status() != WL_CONNECTED && count < 10)\n  {\n    count ++;\n    delay(500);\n    Serial.println(\"Connecting...\");\n  }\n  if(WiFi.status() == WL_CONNECTED)\n    Serial.println(\"Connected OK\");\n  else\n    Serial.println(\"Failed\");\n}\nvoid callURL(String data)\n{\n  String postData = data;\n  Serial.println(\"Sending: \" + postData);\n  WiFiClient client;\n  HTTPClient http;\n  http.begin(client, \"http://\"+((String)METRICS_IP)+\":3000/device\");\n  http.addHeader(\"Content-Type\",\"application/json\");\n  int httpResponseCode = http.POST(postData);\n  Serial.println(\"HTTP Response code xyz: \"+(String)httpResponseCode);\n  http.end();\n}\n\nvoid loop()\n{\n  onReceive(LoRa.parsePacket());\n}\n\nvoid onReceive(int packetSize)\n{\n  String incoming = \"\";\n  if (packetSize == 0) return;\n\n  while (LoRa.available())\n    incoming += (char)LoRa.read();\n\n  Serial.println(\"Received: \" + incoming);\n  callURL(incoming);\n}\n```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Namespace\n    metadata:\n      creationTimestamp: null\n      name: monitoring\n    spec: {}\n    status: {}\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      name: grafana-datasources\n      namespace: monitoring\n      labels:\n        grafana_datasource: \"true\"\n    data:\n      datasource.yaml: |-\n        apiVersion: 1\n        datasources:\n          - name: sensor_data\n            type: mysql\n            url: mysql.default.svc\n            access: proxy\n            database: sensor_data\n            user: lora_mysql\n            secureJsonData:\n              password: lora123-\n            isDefault: true\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      name: grafana\n      namespace: monitoring\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: grafana\n      template:\n        metadata:\n          name: grafana\n          labels:\n            app: grafana\n        spec:\n          containers:\n          - name: grafana\n            image: grafana/grafana:8.4.4\n            ports:\n            - name: grafana\n              containerPort: 3000\n            resources:\n              limits:\n                memory: \"1Gi\"\n                cpu: \"1000m\"\n    requests: \n                memory: 500M\n                cpu: \"500m\"\n            volumeMounts:\n              - mountPath: /var/lib/grafana\n                name: grafana-storage\n              - mountPath: /etc/grafana/provisioning/datasources\n                name: grafana-datasources\n                readOnly: false\n          volumes:\n            - name: grafana-storage\n              emptyDir: {}\n            - name: grafana-datasources\n              configMap:\n                  defaultMode: 420\n                  name: grafana-datasources\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: grafana\n      name: grafana\n      namespace: monitoring\n    spec:\n      ports:\n      - port: 3000\n        protocol: TCP\n        targetPort: 3000\n      selector:\n        app: grafana\n      type: ClusterIP\n    EOF\n    ```", "```\n    $ kubectl port-forward svc/grafana 3000 -n monitoring --address 0.0.0.0\n    ```", "```\n    SELECT \n    UNIX_TIMESTAMP(time) AS \"time\", \n    temperature_c AS \"Temperature(Celcius)\", \n    temperature_f AS \"Temperature(Farenheit)\", \n    humidity AS \"Humidity(%)\" \n    FROM metric \n    WHERE \n    $__timeFilter(time) \n    and device=1 \n    ORDER BY time\n    ```"]