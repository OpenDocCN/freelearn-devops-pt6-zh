<html><head></head><body>
		<div>
			<div id="_idContainer166" class="Content">
			</div>
		</div>
		<div id="_idContainer167" class="Content">
			<h1 id="_idParaDest-73">6. <a id="_idTextAnchor074"/>Securing your application with HTTPS</h1>
		</div>
		<div id="_idContainer182" class="Content">
			<p>HTTPS has become a necessity for any public-facing website. Not only does it improve the security of your website, but it is also becoming a requirement for new browser functionalities. HTTPS is a secure version of the HTTP protocol. HTTPS makes use of <strong class="bold">Transport Layer Security</strong> (<strong class="bold">TLS</strong>) certificates to encrypt traffic between an end user and a server, or between two servers. TLS is the successor to the <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>). The terms <em class="italics">TLS</em> and <em class="italics">SSL</em> are often used interchangeably.</p>
			<p>In the past, you needed to buy certificates from a <strong class="bold">certificate authority</strong> (<strong class="bold">CA</strong>), then set them up on your web server and renew them periodically. While that is still possible today, the <strong class="bold">Let's Encrypt</strong> service and helpers in Kubernetes make it very easy to set up verified TLS certificates in your cluster. Let's Encrypt is a non-profit organization run by the <strong class="bold">Internet Security Research Group</strong> and backed by multiple companies. It is a free service that offers verified TLS certificates in an automated manner. Automation is a key benefit of the Let's Encrypt service.</p>
			<p>In terms of Kubernetes helpers, you will learn about a new object called an <strong class="bold">Ingress</strong> and use a Kubernetes add-on called <strong class="bold">cert-manager</strong>. An ingress is an object within Kubernetes that manages external access to services, commonly used for HTTP services. An ingress adds additional functionality on top of the service object we explained in <em class="italics">Chapter 3</em>, <em class="italics">Application deployment on AKS</em>. It can be configured to handle HTTPS traffic. It can also be configured to route traffic to different back-end services based on the hostname, which is assigned by the <strong class="bold">Domain Name System</strong> (<strong class="bold">DNS</strong>) that is used to connect.</p>
			<p><strong class="inline">cert-manager</strong> is a Kubernetes add-on that helps in automating the creation of TLS certificates. It also helps in the rotation of certificates when they are close to expiring. <strong class="inline">cert-manager</strong> can interface with Let's Encrypt to request certificates automatically.</p>
			<p>In this chapter, you will see how to set up Azure Application Gateway as a Kubernetes ingress, and <strong class="inline">cert-manager</strong> to interface with Let's Encrypt.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Setting up Azure Application Gateway as a Kubernetes ingress</li>
				<li>Setting up an ingress in front of a service</li>
				<li>Adding TLS support to an ingress</li>
			</ul>
			<p>Let's start with setting up Azure Application Gateway as an ingress for AKS.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/>Setting up Azure Application Gateway as a Kubernetes ingress</h2>
			<p>An ingress in Kubernetes is an object that is used to route HTTP and HTTPS traffic from outside the cluster to services in a cluster. Exposing services using an ingress rather than exposing them directly, as you've done up to this point—has a number of advantages. These advantages include the ability to route multiple hostnames to the same public IP address and offloading TLS termination from the actual application to the ingress.</p>
			<p>To create an ingress in Kubernetes, you need to install an ingress controller. An ingress controller is software that can create, configure, and manage ingresses in Kubernetes. Kubernetes does not come with a preinstalled ingress controller. There are multiple implementations of ingress controllers, and a full list is available at this URL: <a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/</a></p>
			<p>In Azure, application gateway is a Layer 7 load balancer, which can be used as an ingress for Kubernetes by using the <strong class="bold">Application Gateway Ingress Controller (AGIC)</strong>. A layer 7 load balancer is a load balancer that works at the application layer, which is the seventh and highest layer in the OSI networking reference model. Azure Application Gateway has a number of advanced features such as autoscaling and <strong class="bold">Web Application Firewall (WAF)</strong>. </p>
			<p>There are two ways of configuring the AGIC, either using Helm or as an <strong class="bold">Azure Kubernetes Service</strong> (<strong class="bold">AKS</strong>) add-on. Installing AGIC using the AKS add-on functionality will result in a Microsoft-supported configuration. Additionally, the add-on method of deployment will be automatically updated by Microsoft, ensuring that your environment is always up to date.</p>
			<p>In this section, you will create a new application gateway instance, set up AGIC using the add-on method, and finally, deploy an ingress resource to expose an application. Later in this chapter, you will extend this setup to also include TSL using a Let's Encrypt certificate.</p>
			<h3 id="_idParaDest-75"><a id="_idTextAnchor076"/>Creating a new application gateway</h3>
			<p>In this section, you will use the Azure CLI to create a new application gateway. You will then use this application gateway in the next section to integrate with AGIC. The different steps in this section are summarized in the code samples for this chapter in the <strong class="inline">setup-appgw.sh</strong> file that is part of the code samples that come with this book.</p>
			<ol>
				<li>To organize the resources created in this chapter, it is recommended that you create a new resource group. Make sure to create the new resource group in the same location you deployed your AKS cluster in. You can do this using the following command in the Azure CLI:<p class="snippet">az group create -n agic -l westus2</p></li>
				<li>Next, you will need to create the networking components required for your application gateway. These are a public IP with a DNS name and a new virtual network. You can do this using the following commands:<p class="snippet">az network public-ip create -n agic-pip \</p><p class="snippet">   -g agic --allocation-method Static --sku Standard \</p><p class="snippet">   --dns-name "&lt;your unique DNS name&gt;"</p><p class="snippet">az network vnet create -n agic-vnet -g agic \</p><p class="snippet">  --address-prefix 192.168.0.0/24 --subnet-name agic-subnet \</p><p class="snippet">  --subnet-prefix 192.168.0.0/24</p><h4>Note</h4><p class="callout">The az network public-ip create command might show you a warning message <strong class="inline">[Coming breaking change] In the coming release, the default behavior will be changed as follows when sku is Standard and zone is not provided: For zonal regions, you will get a zone-redundant IP indicated by zones:["1","2","3"]; For non-zonal regions, you will get a non zone-redundant IP indicated by zones:[].</strong></p></li>
				<li>Finally, you can create the application gateway. This command will take a few minutes to execute<p class="snippet">az network application-gateway create -n agic -l westus2 \</p><p class="snippet">  -g agic --sku Standard_v2 --public-ip-address agic-pip \</p><p class="snippet">  --vnet-name agic-vnet --subnet agic-subnet</p></li>
				<li>It will take a couple of minutes for the application gateway to deploy. Once it is created, you can see the resource in the Azure portal. To find this, look for <strong class="inline">agic</strong> (or the name you gave your application gateway) in the Azure search bar, and select your application gateway. <div id="_idContainer168" class="IMG---Figure"><img src="image/B17338_06_01.jpg" alt="Searching for Application Gateway using the Azure portal search bar"/></div><p class="figure">Figure 6.1: Looking for the application gateway in the Azure search bar</p></li>
				<li>This will show you your application gateway in the Azure portal, as shown in <em class="italics">Figure 6.2</em>:<div id="_idContainer169" class="IMG---Figure"><img src="image/B17338_06_02.jpg" alt="An overview of the Application Gateway pane in the Azure portal"/></div><p class="figure">Figure 6.2: The application gateway in the Azure portal</p></li>
				<li>To verify that it has been created successfully, browse to the DNS name you configured for the public IP address. This will show you an output similar to <em class="italics">Figure 6.3</em>. Note that the error message shown is expected since you haven't configured any applications yet behind the application gateway. You will configure applications behind the application gateway using AGIC in the <em class="italics">Adding an ingress rule for the guestbook application</em> section.</li>
			</ol>
			<div>
				<div id="_idContainer170" class="IMG---Figure">
					<img src="image/B17338_06_03.jpg" alt="Browsing to the DNS name configured for the public IP address to verify if we can connect to the Application Gateway"/>
				</div>
			</div>
			<p class="figure">Figure 6.3: Verify that you can connect to the application gateway </p>
			<p>Now that you've created a new application gateway and were able to connect to it, we will move on to integrating this application gateway with your existing Kubernetes cluster.</p>
			<h3 id="_idParaDest-76"><a id="_idTextAnchor077"/>Setting up the AGIC</h3>
			<p>In this section, you will integrate the application gateway with your Kubernetes cluster using the AGIC AKS add-on. You will also set up virtual network peering so the application gateway can send traffic to your Kubernetes cluster.</p>
			<ol>
				<li value="1">To enable integration between your cluster and your application gateway, use the following command:<p class="snippet">appgwId=$(az network application-gateway \</p><p class="snippet">  show -n agic -g agic -o tsv --query "id") </p><p class="snippet">az aks enable-addons -n handsonaks \</p><p class="snippet">  -g rg-handsonaks -a ingress-appgw \</p><p class="snippet">  --appgw-id $appgwId</p></li>
				<li>Next, you will need to peer the application gateway network with the AKS network. To peer both networks, you can use the following code:<p class="snippet">nodeResourceGroup=$(az aks show -n handsonaks \</p><p class="snippet">  -g rg-handsonaks -o tsv --query "nodeResourceGroup")</p><p class="snippet">aksVnetName=$(az network vnet list \</p><p class="snippet">  -g $nodeResourceGroup -o tsv --query "[0].name")</p><p class="snippet">aksVnetId=$(az network vnet show -n $aksVnetName \</p><p class="snippet">  -g $nodeResourceGroup -o tsv --query "id")</p><p class="snippet">az network vnet peering create \</p><p class="snippet">  -n AppGWtoAKSVnetPeering -g agic \</p><p class="snippet">  --vnet-name agic-vnet --remote-vnet $aksVnetId \</p><p class="snippet">  --allow-vnet-access</p><p class="snippet">appGWVnetId=$(az network vnet show -n agic-vnet \</p><p class="snippet">  -g agic -o tsv --query "id")</p><p class="snippet">az network vnet peering create \</p><p class="snippet">  -n AKStoAppGWVnetPeering -g $nodeResourceGroup \</p><p class="snippet">  --vnet-name $aksVnetName --remote-vnet $appGWVnetId --allow-vnet-access</p></li>
			</ol>
			<p>This concludes the integration between the application gateway and your AKS cluster. You've enabled the AGIC add-on, and connected both the networks together. In the next section, you will use this AGIC integration to create an ingress for a demo application.</p>
			<h3 id="_idParaDest-77"><a id="_idTextAnchor078"/>Adding an ingress rule for the guestbook application</h3>
			<p>Up to this point, you have created a new application gateway and integrated it with your Kubernetes cluster. In this section, you will deploy the guestbook application and then expose it using an ingress. </p>
			<ol>
				<li value="1">To launch the guestbook application, type in the following command:<p class="snippet">kubectl create -f guestbook-all-in-one.yaml</p><p>This will create the guestbook application you've used in the previous chapters. You should see the objects being created as shown in <em class="italics">Figure 6.4</em>:</p><div id="_idContainer171" class="IMG---Figure"><img src="image/B17338_06_04.jpg" alt="Creating the guestbook application that we’ve used in the previous chapters"/></div><p class="figure">Figure 6.4: Creating the guestbook application</p></li>
				<li>You can then use the following YAML file to expose the front-end service via the ingress. This is provided as <strong class="inline">simple-frontend-ingress.yaml</strong> in the source code for this chapter:<p class="snippet">1   apiVersion: networking.k8s.io/v1</p><p class="snippet">2   kind: Ingress</p><p class="snippet">3   metadata:</p><p class="snippet">4     name: simple-frontend-ingress</p><p class="snippet">5     annotations:</p><p class="snippet">6       kubernetes.io/ingress.class: azure/application-gateway</p><p class="snippet">7   spec:</p><p class="snippet">8     rules:</p><p class="snippet">9     - http:</p><p class="snippet">10        paths:</p><p class="snippet">11        - path: /</p><p class="snippet">12          pathType: Prefix</p><p class="snippet">13          backend:</p><p class="snippet">14            service:</p><p class="snippet">15              name: frontend</p><p class="snippet">16              port:</p><p class="snippet">17                number: 80</p><p>Let's have a look at what is defined in this YAML file:</p><ul><li><strong class="bold">Line 1</strong>: You specify the Kubernetes API version for the object you are creating.</li><li><strong class="bold">Line 2</strong>: You define that you are creating an <strong class="inline">Ingress</strong> object.</li><li><strong class="bold">Lines 5-6</strong>: Here, you're telling Kubernetes that you want to create an ingress of the class <strong class="inline">azure/application-gateway</strong>.</li></ul><p>The following lines define the actual ingress:</p><ul><li><strong class="bold">Lines 8-12</strong>: Here, you define the path this ingress is listening on. In our case, this is the top-level path. In more advanced cases, you can have different paths pointing to different services.</li><li><strong class="bold">Lines 13-17</strong>: These lines define the actual service this traffic should be pointed to.</li></ul><p>You can use the following command to create this ingress:</p><p class="snippet">kubectl apply -f simple-frontend-ingress.yaml</p></li>
				<li>If you now go to http://dns-name/, which you created in the <em class="italics">Creating a new application gateway</em> section, you should get an output as shown in <em class="italics">Figure 6.5</em>:<div id="_idContainer172" class="IMG---Figure"><img src="image/B17338_06_05.jpg" alt="Accessing the guestbook application via the ingress"/></div><p class="figure">Figure 6.5: Accessing the guestbook application via the ingress</p><h4>Note</h4><p class="callout">You didn't have to publicly expose the front-end service as you have done in the preceding chapters. You have added the ingress as the exposed service, and the front-end service remains private to the cluster.</p><div id="_idContainer173" class="IMG---Figure"><img src="image/B17338_06_06.jpg" alt="Flowchart displaying a publicly accessible ingress"/></div><p class="figure">Figure 6.6: Flowchart displaying publicly accessible ingress</p></li>
				<li>You can verify this by running the following command:<p class="snippet">kubectl get service</p></li>
				<li>This should show you that you have no public services, as seen by the lack of <strong class="inline">EXTERNAL-IP</strong> in <em class="italics">Figure 6.7</em>:</li>
			</ol>
			<div>
				<div id="_idContainer174" class="IMG---Figure">
					<img src="image/B17338_06_07.jpg" alt="Output confirming that the front-end service remains private to the cluster"/>
				</div>
			</div>
			<p class="figure">Figure 6.7: Output shows that you have no public services</p>
			<p>In this section, you launched an instance of the guestbook application. You then exposed it publicly by creating an ingress, which in turn configured the application gateway that you created earlier. Only the ingress was publicly accessible. </p>
			<p>Next, you'll extend the functionality of AGIC and learn how to secure traffic using a Certificate from Let's Encrypt.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor079"/>Adding TLS to an ingress</h2>
			<p>You will now add HTTPS support to your application. To do this, you need a TLS certificate. You will be using the <strong class="inline">cert-manager</strong> Kubernetes add-on to request a certificate from Let's Encrypt. </p>
			<h4>Note</h4>
			<p class="callout">Although this section focuses on using an automated service such as Let's Encrypt, you can still pursue the traditional path of buying a certificate from an existing CA and importing it into Kubernetes. Please refer to the Kubernetes documentation for more information on how to do this: <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/#tls ">https://kubernetes.io/docs/concepts/services-networking/ingress/#tls</a></p>
			<p>There are a couple of steps involved. The process of adding HTTPS to the application involves the following:</p>
			<ol>
				<li value="1">Install <strong class="inline">cert-manager</strong>, which interfaces with the Let's Encrypt API to request a certificate for the domain name you specify.</li>
				<li>Install the certificate issuer, which will get the certificate from Let's Encrypt.</li>
				<li>Create an SSL certificate for a given <strong class="bold">Fully Qualified Domain Name</strong> (<strong class="bold">FQDN</strong>). An FQDN is a fully qualified DNS record that includes the top-level domain name (such as .org or .com). You created an FQDN linked to your public IP in <em class="italics">step 2</em> in the section <em class="italics">Creating a new application gateway</em>. </li>
				<li>Secure the front-end service by creating an ingress to the service with the certificate created in <em class="italics">step 3</em>. In the example in this section, you will not be executing this step as an individual step. You will, however, reconfigure the ingress to automatically pick up the certificate created in <em class="italics">step 3</em>.</li>
			</ol>
			<p>Let's start with the first step by installing <strong class="inline">cert-manager</strong> in the cluster.</p>
			<h3 id="_idParaDest-79"><a id="_idTextAnchor080"/>Installing cert-manager</h3>
			<p><strong class="inline">cert-manager</strong> (<a href="https://github.com/jetstack/cert-manager">https://github.com/jetstack/cert-manager</a>) is a Kubernetes add-on that automates the management and issuance of TLS certificates from various issuing sources. It is responsible for renewing certificates and ensuring they are updated periodically.</p>
			<h4>Note</h4>
			<p class="callout">The <strong class="inline">cert-manager</strong> project is not managed or maintained by Microsoft. It is an open-source solution previously managed by the company <strong class="bold">Jetstack</strong>, which recently donated it to the Cloud Native Computing Foundation. </p>
			<p>The following commands install <strong class="inline">cert-manager</strong> in your cluster:</p>
			<p class="snippet">kubectl apply -f <a href="https://github.com/jetstack/cert-manager/releases/download/v1.2.0/cert-manager.yaml">https://github.com/jetstack/cert-manager/releases/download/v1.2.0/cert-manager.yaml</a></p>
			<p>This will install a number of components in your cluster as shown in <em class="italics">Figure 6.8</em>. A detailed explanation of these components can be found in the <strong class="inline">cert-manager</strong> documentation at <a href="https://cert-manager.io/docs/installation/kubernetes/">https://cert-manager.io/docs/installation/kubernetes/</a>.</p>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="image/B17338_06_08.jpg" alt="Installing cert-manager on the cluster"/>
				</div>
			</div>
			<p class="figure">Figure 6.8: Installing cert-manager in your cluster</p>
			<p><strong class="inline">cert-manager</strong> makes use of a Kubernetes functionality called <strong class="bold">CustomResourceDefinition </strong>(<strong class="bold">CRD</strong>). CRD is a functionality used to extend the Kubernetes API server to create custom resources. In the case of <strong class="inline">cert-manager</strong>, there are six CRDs that are created, some of which you will use later in this chapter.</p>
			<p>Now that you have installed <strong class="inline">cert-manager</strong>, you can move on to the next step: setting up a certificate issuer.</p>
			<h3 id="_idParaDest-80"><a id="_idTextAnchor081"/>Installing the certificate issuer</h3>
			<p>In this section, you will install the Let's Encrypt staging certificate issuer. A certificate can be issued by multiple issuers. <strong class="inline">letsencrypt-staging</strong>, for example, is for testing purposes. As you are building tests, you'll use the staging server. The code for the certificate issuer has been provided in the source code for this chapter in the <strong class="inline">certificate-issuer.yaml</strong> file. As usual, use <strong class="inline">kubectl create -f certificate-issuer.yaml</strong>; the YAML file has the following contents:</p>
			<p class="snippet">1   apiVersion: cert-manager.io/v1</p>
			<p class="snippet">2   kind: Issuer</p>
			<p class="snippet">3   metadata:</p>
			<p class="snippet">4     name: letsencrypt-staging</p>
			<p class="snippet">5   spec:</p>
			<p class="snippet">6     acme:</p>
			<p class="snippet">7       server: https://acme-staging-v02.api.letsencrypt.org/directory</p>
			<p class="snippet">8       email: &lt;your e-mail address&gt;</p>
			<p class="snippet">9       privateKeySecretRef:</p>
			<p class="snippet">10        name: letsencrypt-staging</p>
			<p class="snippet">11      solvers:</p>
			<p class="snippet">12      - http01:</p>
			<p class="snippet">13          ingress:</p>
			<p class="snippet">14            class: azure/application-gateway</p>
			<p>Let's look at what we have defined here:</p>
			<ul>
				<li><strong class="bold">Lines 1-2</strong>: Here, you point to one of the CRDs that <strong class="inline">cert-manager</strong> created. In this case, specifically, you point to the <strong class="inline">Issuer</strong> object. An issuer is a link between your Kubernetes cluster and the actual certificate authority creating the certificate, which is Let's Encrypt in this case.</li>
				<li><strong class="bold">Lines 6-10</strong>: Here you provide the configuration for Let's Encrypt and point to the staging server.</li>
				<li><strong class="bold">Lines 11-14</strong>: This is additional configuration for the ACME client to certify domain ownership. You point Let's Encrypt to the Azure Application Gateway ingress to verify that you own the domain you will request a certificate for later.</li>
			</ul>
			<p>With the certificate issuer installed, you can now move on to the next step: creating the TLS certificate on the ingress.</p>
			<h3 id="_idParaDest-81"><a id="_idTextAnchor082"/>Creating the TLS certificate and securing the ingress</h3>
			<p>In this section, you will create a TLS certificate. There are two ways you can configure <strong class="inline">cert-manager</strong> to create certificates. You can either manually create a certificate and link it to the ingress, or you can configure your ingress controller, so <strong class="inline">cert-manager</strong> automatically creates the certificate.</p>
			<p>In this example, you will configure your ingress using the latter method. </p>
			<ol>
				<li value="1">To start, edit the ingress to look like the following YAML code. This file is present in the source code on GitHub as <strong class="inline">ingress-with-tls.yaml</strong>:<p class="snippet">1   apiVersion: networking.k8s.io/v1</p><p class="snippet">2   kind: Ingress</p><p class="snippet">3   metadata:</p><p class="snippet">4     name: simple-frontend-ingress</p><p class="snippet">5     annotations:</p><p class="snippet">6       kubernetes.io/ingress.class: azure/application-gateway</p><p class="snippet">7       cert-manager.io/issuer: letsencrypt-staging</p><p class="snippet">8       cert-manager.io/acme-challenge-type: http01</p><p class="snippet">9   spec:</p><p class="snippet">10    rules:</p><p class="snippet">11    - http:</p><p class="snippet">12        paths:</p><p class="snippet">13        - path: /</p><p class="snippet">14          pathType: Prefix</p><p class="snippet">15          backend:</p><p class="snippet">16            service:</p><p class="snippet">17              name: frontend</p><p class="snippet">18              port:</p><p class="snippet">19                number: 80</p><p class="snippet">20      host: &lt;your dns-name&gt;.&lt;your azure region&gt;.cloudapp.azure.com</p><p class="snippet">21    tls:</p><p class="snippet">22      - hosts:</p><p class="snippet">23        - &lt;your dns-name&gt;.&lt;your azure region&gt;.cloudapp.azure.com </p><p class="snippet">24        secretName: frontend-tls </p><p>You should make the following changes to the original ingress:</p><ul><li><strong class="bold">Lines 7-8</strong>: You add two additional annotations to the ingress that points to a certificate issuer and <strong class="inline">acme-challenge</strong> to prove domain ownership.</li><li><strong class="bold">Line 20</strong>: The domain name for the ingress is added here. This is required because Let's Encrypt only issues certificates for domains.</li><li><strong class="bold">Line 21-24</strong>: This is the TLS configuration of the ingress. It contains the hostname as well as the name of the secret that will be created to store the certificate.</li></ul></li>
				<li>You can update the ingress you created earlier with the following command:<p class="snippet">kubectl apply -f ingress-with-tls.yaml</p><p>It takes <strong class="inline">cert-manager</strong> about a minute to request a certificate and configure the ingress to use that certificate. While you are waiting for that, let's have a look at the intermediate resources that <strong class="inline">cert-manager</strong> created on your behalf.</p></li>
				<li>First off, <strong class="inline">cert-manager</strong> created a <strong class="inline">certificate</strong> object for you. You can look at the status of that object using the following:<p class="snippet">kubectl get certificate</p><p>This command will generate an output as shown in <em class="italics">Figure 6.9</em>:</p><div id="_idContainer176" class="IMG---Figure"><img src="image/B17338_06_09.jpg" alt="Output displaying the status of the certificate object  with ready as false"/></div><p class="figure">Figure 6.9: The status of the certificate object</p></li>
				<li>As you can see, the certificate isn't ready yet. There is another object that <strong class="inline">cert-manager</strong> created to actually get the certificate. This object is <strong class="inline">certificaterequest</strong>. You can get its status by using the following command:<p class="snippet">kubectl get certificaterequest</p><p>This will generate the output shown in <em class="italics">Figure 6.10</em>:</p><div id="_idContainer177" class="IMG---Figure"><img src="image/B17338_06_10.jpg" alt="Output displaying the status of the certificaterequest object as False"/></div><p class="figure">Figure 6.10: The status of the certificaterequest obiect</p><p>You can also get more details about the request by issuing a <strong class="inline">describe</strong> command against the <strong class="inline">certificaterequest</strong> object:</p><p class="snippet">kubectl describe certificaterequest</p><p>While you're waiting for the certificate to be issued, the status will look similar to <em class="italics">Figure 6.11</em>:</p><div id="_idContainer178" class="IMG---Figure"><img src="image/B17338_06_11.jpg" alt="Output displaying additional details about the certificaterequest object  showing that cert-manager is waiting on certificate issuance"/></div><p class="figure">Figure 6.11: Using the kubectl describe command to obtain details of the certificaterequest object</p><p>As you can see, the <strong class="inline">certificaterequest</strong> object shows you that the order has been created and that it is pending.</p></li>
				<li>After a couple of additional seconds, the <strong class="inline">describe</strong> command should return a successful certificate creation message. Run the following command to get the updated status:<p class="snippet">kubectl describe certificaterequest</p><p>The output of this command is shown in <em class="italics">Figure 6.12</em>:</p><div id="_idContainer179" class="IMG---Figure"><img src="image/B17338_06_12.jpg" alt="Output displaying the successful certificate creation message"/></div><p class="figure">Figure 6.12: The issued certificate</p><p>This should now enable the front-end ingress to be served over HTTPS.</p></li>
				<li>Let's try this out in a browser by browsing to the DNS name you created in the <em class="italics">Creating a new application gateway</em> section. Depending on your browser's cache, you might need to add <strong class="inline">https://</strong> in front of the URL.</li>
				<li>Once you reach the ingress, it will indicate an error in the browser, showing you that the certificate isn't valid, similar to <em class="italics">Figure 6.13</em>. This is to be expected since you are using the Let's Encrypt staging server:</li>
			</ol>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="image/B17338_06_13.jpg" alt="Using the Let's Encrypt staging server, the certificate isn't trusted by default"/>
				</div>
			</div>
			<p class="figure">Figure 6.13: Using the Let's Encrypt staging server, the certificate isn't trusted by default</p>
			<p>You can browse to your application by clicking <strong class="bold">Advanced</strong> and selecting <strong class="bold">Continue</strong>.</p>
			<p>In this section, you successfully added a TLS certificate to your ingress to secure traffic to it. Since you were able to complete the test with the staging certificate, you can now move on to a production system.</p>
			<h3>Switching from staging to production</h3>
			<p>In this section, you will switch from a staging certificate to a production-level certificate. To do this, you can redo the previous exercise by creating a new issuer in your cluster, like the following (provided in <strong class="inline">certificate-issuer-prod.yaml</strong> as part of the code samples with this book). Don't forget to change your email address in the file. The following code is contained in that file:</p>
			<p class="snippet">1   apiVersion: cert-manager.io/v1alpha2</p>
			<p class="snippet">2   kind: Issuer</p>
			<p class="snippet">3   metadata:</p>
			<p class="snippet">4     name: letsencrypt-prod</p>
			<p class="snippet">5   spec:</p>
			<p class="snippet">6     acme:</p>
			<p class="snippet">7       server: https://acme-v02.api.letsencrypt.org/directory</p>
			<p class="snippet">8       email: &lt;your e-mail&gt;</p>
			<p class="snippet">9       privateKeySecretRef:</p>
			<p class="snippet">10        name: letsencrypt-prod</p>
			<p class="snippet">11      solvers:</p>
			<p class="snippet">12      - http01:</p>
			<p class="snippet">13          ingress:</p>
			<p class="snippet">14            class: azure/application-gateway </p>
			<p>Then, replace the reference to the issuer in the <strong class="inline">ingress-with-tls.yaml</strong> file with <strong class="inline">letsencrypt-prod</strong> as shown (provided in the <strong class="inline">ingress-with-tls-prod.yaml</strong> file):</p>
			<p class="snippet">1   apiVersion: networking.k8s.io/v1</p>
			<p class="snippet">2   kind: Ingress</p>
			<p class="snippet">3   metadata:</p>
			<p class="snippet">4     name: simple-frontend-ingress</p>
			<p class="snippet">5     annotations:</p>
			<p class="snippet">6       kubernetes.io/ingress.class: azure/application-gateway</p>
			<p class="snippet">7       cert-manager.io/issuer: letsencrypt-prod</p>
			<p class="snippet">8       cert-manager.io/acme-challenge-type: http01</p>
			<p class="snippet">9   spec:</p>
			<p class="snippet">10    rules:</p>
			<p class="snippet">11    - http:</p>
			<p class="snippet">12        paths:</p>
			<p class="snippet">13        - path: /</p>
			<p class="snippet">14          pathType: Prefix</p>
			<p class="snippet">15          backend:</p>
			<p class="snippet">16            service:</p>
			<p class="snippet">17              name: frontend</p>
			<p class="snippet">18              port:</p>
			<p class="snippet">19                number: 80</p>
			<p class="snippet">20      host: &lt;your dns-name&gt;.&lt;your azure region&gt;.cloudapp.azure.com</p>
			<p class="snippet">21    tls:</p>
			<p class="snippet">22      - hosts:</p>
			<p class="snippet">23        - &lt;your dns-name&gt;.&lt;your azure region&gt;.cloudapp.azure.com</p>
			<p class="snippet">24        secretName: frontend-prod-tls </p>
			<p>To apply these changes, execute the following commands:</p>
			<p class="snippet">kubectl create -f certificate-issuer-prod.yaml</p>
			<p class="snippet">kubectl apply -f ingress-with-tls-prod.yaml</p>
			<p>It will again take about a minute for the certificate to become active. Once the new certificate is issued, you can browse to your DNS name again and shouldn't see any more warnings regarding invalid certificates. If you click the padlock icon in the browser, you should see that your connection is secure and uses a valid certificate:</p>
			<div>
				<div id="_idContainer181" class="IMG---Figure">
					<img src="image/B17338_06_14.jpg" alt="The web page displaying a valid certificate"/>
				</div>
			</div>
			<p class="figure">Figure 6.14: The web page displaying a valid certificate</p>
			<p>In this section, you have learned how to add TLS support to an ingress. You did this by installing the <strong class="inline">cert-manager</strong> Kubernetes add-on. <strong class="inline">cert-manager</strong> got a free certificate from Let's Encrypt and added this to the existing ingress deployed on the application gateway. The process that was described here is not specific to Azure and Azure Application Gateway. This process of adding TLS to an ingress works with other ingress controllers as well. </p>
			<p>Let's delete the resources you created during this chapter:</p>
			<p class="snippet">kubectl delete -f <a href="https://github.com/jetstack/cert-manager/releases/download/v1.1.0/cert-manager.yaml">https://github.com/jetstack/cert-manager/releases/download/v1.1.0/cert-manager.yaml</a></p>
			<p class="snippet">az aks disable-addons -n handsonaks \</p>
			<p class="snippet">  -g rg-handsonaks -a ingress-appgw </p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor083"/>Summary</h2>
			<p>In this chapter, you added HTTPS security to the guestbook application without actually changing the source code. You started by setting up a new application gateway and configured AGIC on AKS. This gives you the ability to create Kubernetes ingresses that can be configured on the application gateway.</p>
			<p>Then, you installed a certificate manager that interfaces with the Let's Encrypt API to request a certificate for the domain name we subsequently specified. You leveraged a certificate issuer to get the certificate from Let's Encrypt. You then reconfigured the ingress to request a certificate from this issuer in the cluster. Using these capabilities of both the certificate manager as well as the ingress, you are now able to secure your websites using TLS.</p>
			<p>In the next chapter, you will learn how to monitor your deployments and set up alerts. You will also learn how to quickly identify root causes when errors do occur, and how to debug applications running on AKS. At the same time, you'll learn how to perform the correct fixes once you have identified the root causes.</p>
		</div>
	</body></html>