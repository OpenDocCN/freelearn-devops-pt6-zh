<html><head></head><body>
		<div id="_idContainer109">
			<h1 id="_idParaDest-194" class="chapter-number"><a id="_idTextAnchor241"/>10</h1>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor242"/>Automating Helm with CD and GitOps</h1>
			<p>Throughout this book, we have demonstrated how to use different Helm commands to manage Kubernetes resources and applications. While these commands (namely <strong class="source-inline">install</strong>, <strong class="source-inline">upgrade</strong>, <strong class="source-inline">rollback</strong>, and <strong class="source-inline">uninstall</strong>) are effective in carrying out their respective tasks, we have been invoking them manually from the command line. Manual invocation can serve as a pain point when managing multiple different applications and can make it difficult for enterprises to scale. As a result, we should explore opportunities to automate our Helm deployments.</p>
			<p>In this chapter, we will investigate concepts relating to <strong class="bold">continuous delivery</strong> (<strong class="bold">CD</strong>) and <strong class="bold">GitOps</strong>. These are methodologies that involve automatically invoking the Helm <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) to perform automated chart installations based on the contents of a Git repository. By implementing the CD and GitOps concepts, you can further increase your efficiency with Helm.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding CI/CD and GitOps</li>
				<li>Setting up your environment</li>
				<li>Installing Argo CD</li>
				<li>Deploying a Helm chart from a Git repository</li>
				<li>Deploying a Helm chart from a remote Helm chart repository</li>
				<li>Deploying a Helm chart to multiple environments</li>
				<li>Cleaning up</li>
			</ul>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor243"/>Technical requirements</h1>
			<p>This chapter requires that you have the following technologies installed on your local machine:</p>
			<ul>
				<li>minikube</li>
				<li>Helm</li>
				<li>kubectl</li>
				<li>Git</li>
			</ul>
			<p>In addition to these tools, you can find the Packt repository that contains the resources associated with the examples in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm">https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm</a>. This repository will be referenced throughout this chapter.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor244"/>Understanding CI/CD and GitOps</h1>
			<p>So far, we have addressed manually invoking the Helm CLI to install and manage Helm charts. While this is <a id="_idIndexMarker557"/>acceptable when getting started with Helm, as you look to manage a chart in a production-like <a id="_idIndexMarker558"/>environment, there are questions that you need to consider, including the following:</p>
			<ul>
				<li>How can I be sure that the best practices for Helm chart deployments are enforced?</li>
				<li>What are the implications for collaborators participating in the deployment process?</li>
			</ul>
			<p>You may be familiar with the best practices and processes around deploying Helm charts; however, any new collaborators or team members may not have the same level of knowledge or expertise. Not to mention, you may become limited in the level of support that you can provide to others as your responsibilities among the number of applications you manage increases. Through the use of automation and repeatable processes, we can address these challenges.</p>
			<p>While this chapter will focus primarily on CD and GitOps, we would be remiss if we were to avoid introducing <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>), which is commonly paired with CD. We will discuss <strong class="bold">continuous integration/continuous delivery</strong> (<strong class="bold">CI/CD</strong>) and GitOps in the next section.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor245"/>CI/CD</h2>
			<p>As enterprises sought to accelerate the software development life cycle over the years, the need for an automated development process arose, leading to the creation of CI. CI is enabled by <a id="_idIndexMarker559"/>using an orchestrator to automatically build and test application code. As new commits are pushed to a Git repository, the orchestrator automatically retrieves the source code and undergoes a predetermined set of steps to build the application (among other tasks, such as code quality scanning, vulnerability scanning, and so on). By performing automatic builds when new commits are added, regressions and breaking changes can be spotted early on in the software development life cycle. CI also helps address the challenges embodied by the phrase <em class="italic">it works on my machine</em> by providing a common build environment.</p>
			<p>The ability to apply many of CI’s concepts throughout the software development life cycle as an application moves toward production led to the creation of CD. CD is a set of defined steps provided to progress software through a release process. CD has gained acceptance and popularity among many organizations where proper change control is enforced, and approvals are required for the software to progress to the next stage. As many of the concepts around CI/CD are automated in a repeatable fashion, teams can look to fully eliminate the need for manual approval steps once they are confident that they have a reliable framework in place.</p>
			<p>The process of implementing a fully automated build, test, deployment, and release process without human intervention is known as continuous deployment. While many software projects may never fully achieve continuous deployment, teams that can implement the concepts emphasized by CI/CD can produce real business value faster than less automated methods.</p>
			<p>In the next section, we will introduce GitOps as a mechanism to improve how applications and their configuration are managed.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor246"/>Taking CI/CD to the next level using GitOps</h2>
			<p>Kubernetes is a platform <a id="_idIndexMarker560"/>that embraces the use of declarative configurations. While applications can be managed using imperative <strong class="source-inline">kubectl</strong> commands, the preferred approach, which we <a id="_idIndexMarker561"/>covered in <a href="B17979_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Understanding Kubernetes and Helm</em>, is to declaratively state the resources through the use of manifests. In the same way that an application traverses its way through a CI/CD pipeline, Kubernetes manifests can implement many of the same CI/CD patterns. Like application code, Kubernetes manifests should also be stored in a source code repository, such as Git, and can undergo the same type of build, test, and deployment practices.</p>
			<p>The rise in popularity of managing the life cycle of Kubernetes applications and cluster configuration within Git repositories led to the concept of GitOps. First introduced by the software company <em class="italic">WeaveWorks</em> in 2017, GitOps has increased in popularity as a way to manage Kubernetes configurations. While GitOps is best known in the context of Kubernetes, its principles can be applied to any type of environment.</p>
			<p>Similar to CI/CD, tools <a id="_idIndexMarker562"/>have been developed to manage the GitOps process. These include <strong class="bold">Argo CD</strong> from Intuit and <strong class="bold">Flux</strong> from WeaveWorks. However, you do not need to use <a id="_idIndexMarker563"/>a tool specifically designed for GitOps as any automation utility or CI/CD orchestrator can be used. The key differentiator between a traditional CI/CD tool and a tool designed for GitOps is a GitOps tool’s ability to constantly observe the state of the target environment and apply desired configurations when the live state does not match the desired state, as defined in the manifests stored in Git. In the context of Kubernetes, these tools make use of the controller pattern, which is fundamental to Kubernetes itself.</p>
			<p>Since Helm charts are ultimately rendered as Kubernetes resources, they, too, can be used to participate in the GitOps process. In this chapter, we will leverage Argo CD to deploy Helm chart resources to Kubernetes in a GitOps fashion. Note that this is not intended to be a comprehensive overview of Argo CD, but it will give you an idea of how it can be integrated with Helm to provide a GitOps approach toward Helm deployments.</p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor247"/>Setting up your environment</h1>
			<p>In this chapter, we <a id="_idIndexMarker564"/>will create several namespaces to install Argo CD and deploy an example Helm chart across different namespaces.</p>
			<p>Run the following commands to prepare your environment:</p>
			<ol>
				<li>Start <strong class="source-inline">minikube</strong> by running the <strong class="source-inline">minikube start</strong> command:<p class="source-code"><strong class="bold">$ minikube start</strong></p></li>
				<li>Then, create a new namespace called <strong class="source-inline">argo</strong>, where we will later install Argo CD:<p class="source-code"><strong class="bold">$ kubectl create namespace argo</strong></p></li>
				<li>Next, create a namespace called <strong class="source-inline">chapter10</strong>, where we will deploy an example Helm chart from Argo CD:<p class="source-code"><strong class="bold">$ kubectl create namespace chapter10</strong></p></li>
				<li>Finally, create two namespaces called <strong class="source-inline">chapter10-dev</strong> and <strong class="source-inline">chapter10-prod</strong>. We will use these namespaces to demonstrate deploying a Helm chart across multiple environments using Argo CD:<p class="source-code"><strong class="bold">$ kubectl create namespace chapter10-dev</strong></p><p class="source-code"><strong class="bold">$ kubectl create namespace chapter10-prod</strong></p></li>
			</ol>
			<p>With your <strong class="source-inline">minikube</strong> environment ready and your namespaces created, let’s begin by deploying Argo CD. Then, we will walk through examples of using Argo CD to deploy an application to Kubernetes with Helm.</p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor248"/>Installing Argo CD</h1>
			<p>Argo CD can <a id="_idIndexMarker565"/>be installed in Kubernetes by using a set of manifest files or by installing a Helm chart. Of course, we will choose to install Argo CD using the community-provided Helm chart.</p>
			<p>The repository URL for <a id="_idIndexMarker566"/>the Argo CD Helm chart is <a href="https://argoproj.github.io/argo-helm">https://argoproj.github.io/argo-helm</a> (which can be found in Artifact Hub, a process described in <a href="B17979_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>, <em class="italic">Installing Your First App with Helm</em>). </p>
			<p>Let’s add this repository using the Helm CLI:</p>
			<p class="source-code">$ helm repo add argo https://argoproj.github.io/argo-helm</p>
			<p>Once the repository has been added, you can install it. We have provided a <strong class="source-inline">values</strong> file you can use for the installation in the Packt repository at <a href="https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/argo-values/values.yaml">https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/argo-values/values.yaml</a>. The provided <strong class="source-inline">values</strong> file disables Dex (an OpenID Connect provider), along with Argo’s notification system, since we will not be using these components in this chapter.</p>
			<p>Let’s install Argo <a id="_idIndexMarker567"/>CD in the <strong class="source-inline">argo</strong> namespace by running the following command:</p>
			<p class="source-code">$ helm install argo argo/argo-cd –-version 4.5.0 --values chapter10/argo-values/values.yaml -n argo</p>
			<p>The Helm chart installs the following components in the <strong class="source-inline">argo</strong> namespace:</p>
			<ul>
				<li><strong class="bold">Argo CD Application Controller</strong>, a controller that watches for <strong class="source-inline">Application</strong> custom <a id="_idIndexMarker568"/>resources. When an <strong class="source-inline">Application</strong> resource is created, Argo CD creates resources to the desired destination cluster and namespace.</li>
				<li><strong class="bold">Argo CD ApplicationSet Controller</strong>, a controller that watches for <strong class="source-inline">ApplicationSet</strong> custom resources. <strong class="source-inline">ApplicationSet</strong> provides a convenient way to deploy multiple different yet related <strong class="source-inline">Application</strong> resources. We will work with ApplicationSets when we demonstrate how to deploy a Helm chart to multiple different environments or namespaces.</li>
				<li><strong class="bold">Redis</strong>, which is used <a id="_idIndexMarker569"/>for caching backend data.</li>
				<li><strong class="bold">Argo CD Repo Server</strong>, which <a id="_idIndexMarker570"/>provides a local instance of cloned Git repositories.</li>
				<li><strong class="bold">Argo CD Server</strong>, which <a id="_idIndexMarker571"/>provides an API for interacting with Argo CD. This component also provides a frontend web interface.</li>
			</ul>
			<p>Once each of the pods in the <strong class="source-inline">argo</strong> namespace reports the 1/1 ready state (shown by running <strong class="source-inline">kubectl get pods –n argo</strong>), we can access the Argo CD web UI. First, we need to get the admin password that was randomly generated during the Helm installation. We can do this by accessing a Kubernetes <strong class="source-inline">secret</strong> in the <strong class="source-inline">argo</strong> namespace:</p>
			<p class="source-code">$ kubectl get secret argocd-initial-admin-secret –n argo –o jsonpath='{.data.password}' | base64 –d</p>
			<p>The username for accessing the web UI will be <strong class="source-inline">admin</strong>, and the password will be the string displayed after getting the password from <strong class="source-inline">the argocd-initial-admin-secret</strong>.</p>
			<p>Finally, we can run <strong class="source-inline">port-forward</strong> to access the web UI. In a separate terminal, run the following <strong class="source-inline">port-forward</strong> command:</p>
			<p class="source-code">$ kubectl port-forward svc/argo-argocd-server 8443:443 –n argo</p>
			<p>After running the <strong class="source-inline">port-forward</strong> command, navigate to <a href="https://localhost:8443">https://localhost:8443</a> in a web browser. Accept <a id="_idIndexMarker572"/>the self-signed certificate exception; you will be presented with the Argo CD login page:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/Figure_10.01_B17979.jpg" alt="Figure 10.1 – The Argo CD login page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – The Argo CD login page</p>
			<p>For the username, enter <strong class="source-inline">admin</strong>, and for the password, provide the string that was displayed after getting the password from <strong class="source-inline">argocd-initial-admin-secret</strong>. After successfully logging in, you should see the following page titled <strong class="bold">APPLICATIONS TILES</strong>:</p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/Figure_10.02_B17979.jpg" alt="Figure 10.2 – The Argo CD APPLICATIONS TILES page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – The Argo CD APPLICATIONS TILES page</p>
			<p>This page can be used to create new applications, which represent application deployments (or any set of Kubernetes resources). However, in the spirit of adhering to a more <a id="_idIndexMarker573"/>declarative configuration approach, we will make deployments in this chapter by applying <strong class="source-inline">Application</strong> YAML resources instead. With that said, this UI will populate with application tiles as we apply the <strong class="source-inline">Application</strong> resources directly using <strong class="source-inline">kubectl</strong>. Feel free to reference this UI throughout this chapter to see how they are visualized.</p>
			<p>With Argo CD successfully deployed, let’s continue by deploying a Helm chart from a Git repository.</p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor249"/>Deploying a Helm chart from a Git repository</h1>
			<p>In true GitOps <a id="_idIndexMarker574"/>fashion, Argo CD can be used to deploy <a id="_idIndexMarker575"/>a Helm chart from a Git repository. The following diagram shows the flow involved in deploying a Helm chart from a Git repository using Argo CD:</p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/Figure_10.03_B17979.jpg" alt="Figure 10.3 – Deploying a Helm chart from a Git repository&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Deploying a Helm chart from a Git repository</p>
			<p>Here, you can see that Argo CD clones the Git repository containing the desired Helm chart. Then, Argo CD interprets the repository as one containing a Helm chart, since it notices the presence of the <strong class="source-inline">Chart.yaml</strong> file and surrounding Helm chart structure. From there, Argo CD proceeds by rendering the Helm chart manifests and applying them to the designated Kubernetes namespace.</p>
			<p>Note that Argo CD <em class="italic">renders</em> the Helm chart templates and applies them as opposed to installing the Helm chart directly. This is because Argo CD only applies Kubernetes manifests, so it first runs a helm <strong class="source-inline">template</strong> internally to produce the full Kubernetes manifest from the provided Helm values. If you were to run the <strong class="source-inline">helm list</strong> command after deploying a chart using Argo CD, you would not see any releases listed. You would, however, be able to see the applied resources.</p>
			<p>You may be curious about the implications that deploying rendered Kubernetes manifests has on application rollbacks since the <strong class="source-inline">helm rollback</strong> command cannot be used. With the GitOps ideology, you would ideally roll back by performing changes within your Git repository to revert such actions. Argo CD would then detect any new commits that have been created against the target branch and apply the desired changes. With that said, Argo CD does have a native rollback capability to roll back to a previous history ID. This enables users to roll back without reverting to their Git repository.</p>
			<p>Let’s begin to deploy a Helm chart from Git by observing the <strong class="source-inline">Application</strong> resource located in the Packt repository at <strong class="source-inline">chapter10/local-chart/application.yaml</strong> (<a href="https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/local-chart/application.yaml">https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/local-chart/application.yaml</a>). We can break this resource down into separate components:</p>
			<ul>
				<li>First, we must define the resource’s <strong class="source-inline">kind</strong> and provide the resource metadata:<p class="source-code">apiVersion: argoproj.io/v1alpha1</p><p class="source-code">kind: Application</p><p class="source-code">metadata:</p><p class="source-code">  name: nginx</p><p class="source-code">  namespace: argo</p><p class="source-code">  finalizers:</p><p class="source-code">      resources-finalizer.argocd.argoproj.io</p></li>
			</ul>
			<p>Notice the finalizer, <strong class="source-inline">resources-finalizer.argocd.argoproj.io</strong>. <strong class="bold">Finalizers</strong>, in Kubernetes, are used <a id="_idIndexMarker576"/>to trigger a pre-delete action on the managing <a id="_idIndexMarker577"/>controller. With this finalizer, we <a id="_idIndexMarker578"/>tell the application controller that if we delete this application resource, the controller should delete the rendered Kubernetes resources first. If we omit the finalizer, the application controller will simply remove the application resource without deleting the rendered Kubernetes resources.</p>
			<ul>
				<li>Next, we must define the application source. This is where we specify the Git repository URL and the path to the Helm chart:<p class="source-code">source:</p><p class="source-code">  path: helm-charts/charts/nginx/</p><p class="source-code">  repoURL: https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git</p><p class="source-code">  targetRevision: HEAD</p><p class="source-code">  helm:</p><p class="source-code">    values: |-</p><p class="source-code">      resources:</p><p class="source-code">        limits:</p><p class="source-code">          cpu: 50m</p><p class="source-code">          memory: 128Mi</p><p class="source-code">        requests:</p><p class="source-code">          cpu: 50m</p><p class="source-code">          memory: 128Mi</p></li>
			</ul>
			<p>As you can see from the configuration, Argo CD will clone the repository (https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git) at the most recent commit (<strong class="source-inline">HEAD</strong>). Once cloned, it navigates to the <strong class="source-inline">helm-charts/charts/nginx</strong> path, which contains an Nginx Helm chart.</p>
			<ul>
				<li>Here, we <a id="_idIndexMarker579"/>also specified a set of Helm <a id="_idIndexMarker580"/>values, setting the resource limits and requests under the <strong class="source-inline">helm.values</strong> section. Values can also be provided by using the <strong class="source-inline">helm.parameters</strong> setting, like so: <p class="source-code">source:</p><p class="source-code">  helm:</p><p class="source-code">    parameters:</p><p class="source-code">      - name: resources.limits.cpu</p><p class="source-code">        value: 50m</p><p class="source-code">       - name: resources.limits.memory</p><p class="source-code">         value: 128Mi</p></li>
			</ul>
			<p>This would be similar to passing the --set flag on the command line.</p>
			<p>Finally, values can also be provided using the <strong class="source-inline">helm.valueFiles</strong> setting. We will describe this use case in greater detail in the <em class="italic">Deploying a Helm chart to multiple environments</em> section.</p>
			<ul>
				<li>The <a id="_idIndexMarker581"/>final portion of the <strong class="source-inline">Application</strong> resource <a id="_idIndexMarker582"/>defines the destination and synchronization (sync) policy:<p class="source-code">destination:</p><p class="source-code">   server: https://kubernetes.default.svc</p><p class="source-code">   namespace: chapter10</p><p class="source-code">syncPolicy:</p><p class="source-code">   automated:</p><p class="source-code">     prune: true</p><p class="source-code">     selfHeal: true</p></li>
			</ul>
			<p><strong class="source-inline">destination</strong> defines the Kubernetes server API of the target cluster and the namespace that resources should be deployed to. <strong class="source-inline">syncPolicy</strong> determines how the application should be synchronized. In this context, <strong class="source-inline">sync</strong> means to apply, or update, the resources in the cluster with those from the application source. Syncs can be done manually, but in this example, we have selected to automate it so that Nginx is deployed as soon as the application resource is created.</p>
			<p>Under the <strong class="source-inline">syncPolicy.automated</strong> section, several additional configurations can be specified. The <strong class="source-inline">prune</strong> field is a Boolean that determines whether Kubernetes resources should be deleted if they are removed from the source. The <strong class="source-inline">selfHeal</strong> setting instructs Argo CD to ensure consistency between the desired state and the live state. If a resource is modified within the Kubernetes cluster, <strong class="source-inline">selfHeal</strong> will cause Argo CD to revert the modification so that it matches the source configuration.</p>
			<p>Now that we understand the application resource for defining our Nginx application, we can install this <strong class="source-inline">Application</strong> resource by using the <strong class="source-inline">kubectl apply</strong> command:</p>
			<p class="source-code">$ kubectl apply –f chapter10/local-chart/application.yaml -n argo</p>
			<p>The result creates the <strong class="source-inline">Application</strong> resource in the <strong class="source-inline">argo</strong> namespace, where Argo CD has visibility to application resources. </p>
			<p>Upon creating the application resource, you can see the deployment status by running the following command:</p>
			<p class="source-code">$ kubectl get applications –n argo</p>
			<p class="source-code">NAME    SYNC STATUS   HEALTH STATUS</p>
			<p class="source-code">nginx   Synced        Healthy</p>
			<p><strong class="source-inline">SYNC STATUS</strong> shows whether or not the desired state has been synced with the live state, while <strong class="source-inline">HEALTH STATUS</strong> shows whether or not the rollout has been completed or if the <a id="_idIndexMarker583"/>pods are still starting up. It may take a <a id="_idIndexMarker584"/>moment for <strong class="source-inline">SYNC STATUS</strong> and <strong class="source-inline">HEALTH STATUS</strong> to reach these values as the <strong class="source-inline">nginx</strong> chart and the associated resources are installed in the cluster. We can see the status of the deployment using more traditional means – that is, by running the <strong class="source-inline">kubectl get pods</strong> command in the <strong class="source-inline">chapter10</strong> namespace:</p>
			<p class="source-code">$ kubectl get pods –n chapter10</p>
			<p class="source-code">NAME                     READY   STATUS    RESTARTS   AGE</p>
			<p class="source-code">nginx-7bf8646cff-qjv9h   1/1     Running   0          2m5s</p>
			<p>With <strong class="source-inline">Application</strong> reporting as synchronized and healthy, you have successfully deployed a Helm chart from a Git repository using Argo CD! Let’s delete the application resource (which will also remove the <strong class="source-inline">nginx</strong> pod from the <strong class="source-inline">chapter10</strong> namespace):</p>
			<p class="source-code">$ kubectl delete –f chapter10/remote-registry/application.yaml</p>
			<p>Before we depart from this topic, it should be noted that, as expected in a GitOps model, changes to the <strong class="source-inline">nginx</strong> Helm chart in Git will automatically propagate to the Kubernetes <a id="_idIndexMarker585"/>environment. If you were to update <a id="_idIndexMarker586"/>the <strong class="source-inline">nginx</strong> chart and publish a new commit to the Git repository for the particular target branch, Argo CD would notice this change in the next polling interval and update the Kubernetes namespace with the desired state, as defined in the repository. For faster synchronization, webhooks can be configured on the Git repository to trigger an Argo CD sync in an event-driven fashion. Information <a id="_idIndexMarker587"/>on configuring webhooks is described in the Argo CD documentation at <a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/">https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/</a>.</p>
			<p>Next, we will learn how to use Argo CD to deploy a Helm chart from a remote chart repository.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor250"/>Deploying an application from a remote Helm chart repository</h1>
			<p>When <a id="_idIndexMarker588"/>installing <a id="_idIndexMarker589"/>Helm charts, users often interact with remote repositories. Similarly, we can <a id="_idIndexMarker590"/>use Argo CD to deploy an application from a specified Helm chart repository.</p>
			<p>The following diagram shows the flow involved in deploying an application from a remote Helm chart repository with Argo CD:</p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/Figure_10.04_B17979.jpg" alt="Figure 10.4 – Deploying an application from a remote Helm chart repository&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Deploying an application from a remote Helm chart repository</p>
			<p>First, Argo CD downloads the Helm chart configured in the <strong class="source-inline">Application</strong> resource. Then, it renders the Helm chart and applies the manifests to the destination cluster and namespace.</p>
			<p>We <a id="_idIndexMarker591"/>have provided <a id="_idIndexMarker592"/>an example <strong class="source-inline">Application</strong> resource in the Packt repository at <strong class="source-inline">chapter10/remote-registry/application.yaml</strong> (<a href="https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/remote-registry/application.yaml">https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/remote-registry/application.yaml</a>). The resource is configured <a id="_idIndexMarker593"/>similarly to <strong class="source-inline">Application</strong> from the previous section, but we can observe one key difference in the <strong class="source-inline">source</strong> section:</p>
			<pre class="source-code">
source:
  chart: nginx
  targetRevision: 9.7.6
  repoURL: https://raw.githubusercontent.com/bitnami/charts/archive-full-index/bitnami </pre>
			<p>Here, instead of providing a Git repository, we provided the location of a remote Helm chart repository, as well as the chart’s name and version. As you can see, this <strong class="source-inline">Application</strong> will instruct Argo CD to deploy version <strong class="source-inline">9.7.6</strong> of the <strong class="source-inline">nginx</strong> chart from the Bitnami chart repository.</p>
			<p>The process of deploying a Helm chart from a chart repository is the same as deploying from <a id="_idIndexMarker594"/>a Git <a id="_idIndexMarker595"/>repository – simply <a id="_idIndexMarker596"/>apply the <strong class="source-inline">Application</strong> resource to the <strong class="source-inline">argo</strong> namespace. Feel free to walk through the same steps provided in the previous section to deploy the application to the <strong class="source-inline">chapter10</strong> namespace.</p>
			<p>Where the process changes slightly is when we talk about deploying a Helm chart to multiple environments, a topic that we will cover in the next section.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor251"/>Deploying a Helm chart to multiple environments</h1>
			<p>In the previous <a id="_idIndexMarker597"/>sections, we used Argo CD to deploy a Helm chart to a single environment (or namespace). However, when deploying applications in the enterprise, you will often expect to deploy across multiple different environments, achieving a process similar to what’s shown in the following diagram:</p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/Figure_10.05_B17979.jpg" alt="Figure 10.5 – Deploying to multiple namespaces&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Deploying to multiple namespaces</p>
			<p>You may want to deploy charts to different environments (separate namespaces or even separate clusters) for a variety of reasons, including high availability or for deploying an application across multiple stages of a pipeline, such as dev, test, and prod. Luckily, we can achieve this in Argo CD using the <strong class="source-inline">ApplicationSet</strong> construct.</p>
			<p>Imagine that <a id="_idIndexMarker598"/>we have two separate namespaces – one for dev and another for prod. We could create two separate <strong class="source-inline">Application</strong> resources, each targeting a separate namespace in the destination section:</p>
			<ul>
				<li>Dev would look as follows:<p class="source-code">destination:</p><p class="source-code">  server: https://kubernetes.default.svc</p><p class="source-code">  namespace: dev</p></li>
				<li>Prod would be very similar, but we would specify <strong class="source-inline">prod</strong> in the <strong class="source-inline">namespace</strong> property:<p class="source-code">destination:</p><p class="source-code">  server: https://kubernetes.default.svc</p><p class="source-code">  namespace: prod</p></li>
			</ul>
			<p>Using two different <strong class="source-inline">Application</strong> resources – one for each environment – is a perfectly <a id="_idIndexMarker599"/>valid option for approaching this type of deployment. However, Argo CD introduced <strong class="source-inline">ApplicationSet</strong> as a method for wrapping multiple <strong class="source-inline">Application</strong> instances in a single resource, allowing you to define multiple destinations without managing multiple resource YAML files.</p>
			<p>An example of an <strong class="source-inline">ApplicationSet</strong> is provided in the Packt repository at <strong class="source-inline">chapter10/multiple-envs/applicationset.yaml</strong> (<a href="https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/multiple-envs/applicationset.yaml">https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/multiple-envs/applicationset.yaml</a>). Let’s break down the different sections of this resource:</p>
			<ul>
				<li>The first component of an <strong class="source-inline">ApplicationSet</strong> is the <strong class="source-inline">generators</strong> section, which generates parameters that are used later on to dynamically configure the application details, such as the source and destination. There are many different types of <a id="_idIndexMarker600"/>generators, which can be explored in greater detail in the Argo CD documentation at <a href="https://argocd-applicationset.readthedocs.io/en/stable/Generators/">https://argocd-applicationset.readthedocs.io/en/stable/Generators/</a>. In our example, we used the <strong class="source-inline">list</strong> generator, which allows a list of simple key-value pairs to be provided:<p class="source-code">generators:</p><p class="source-code">   - list:</p><p class="source-code">       elements:</p><p class="source-code">        - env: dev</p><p class="source-code">        - env: prod</p></li>
			</ul>
			<p>As you can see, two elements that define our different environments are specified – <strong class="source-inline">dev</strong> and <strong class="source-inline">prod</strong>. We will reference these environments throughout the rest of <strong class="source-inline">ApplicationSet</strong> to deploy the <strong class="source-inline">nginx</strong> chart to both stages of our deployment pipeline.</p>
			<ul>
				<li>Next, we must define the <strong class="source-inline">Application</strong> template. We start by providing a name that <strong class="source-inline">ApplicationSet</strong> will inject into the generated <strong class="source-inline">Applications</strong>:<p class="source-code">metadata:</p><p class="source-code">   name: nginx-{{ env }}</p></li>
			</ul>
			<p>The <strong class="source-inline">{{ env }}</strong> syntax denotes a placeholder that will be replaced by the <strong class="source-inline">env</strong> elements described in the <strong class="source-inline">generators</strong> section. So, when we create <strong class="source-inline">ApplicationSet</strong>, we can expect two different applications to be created: <strong class="source-inline">– nginx-dev</strong> and <strong class="source-inline">nginx-prod</strong>.</p>
			<ul>
				<li>Now that we <a id="_idIndexMarker601"/>have specified the names of the applications that will be created, we can configure the sources. This will look similar to what we have seen in the previous sections:<p class="source-code">source:</p><p class="source-code">  path: chapter10/multiple-envs/nginx</p><p class="source-code">  repoURL: https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git</p><p class="source-code">  targetRevision: HEAD</p><p class="source-code">   helm:</p><p class="source-code">    releaseName: nginx</p><p class="source-code">     valueFiles:</p><p class="source-code">      - values/common-values.yaml</p><p class="source-code">      - values/{{ env }}/values.yaml</p></li>
			</ul>
			<p>This source indicates that Argo CD will deploy the Helm chart located under <strong class="source-inline">chapter10/multiple-envs/nginx</strong> at <a href="https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git">https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git</a>. However, instead of deploying the same configuration in each environment, we will apply slightly different values based on the environment. This can be seen under the <strong class="source-inline">helm.valueFiles</strong> setting, which provides a list of values files to be applied (similar to using the <strong class="source-inline">--values</strong> flag on the command line). Regardless of the environment, we will always apply a common set of values <a id="_idIndexMarker602"/>defined in the <strong class="source-inline">values/common-values.yaml</strong> file, but depending on the environment, we will also apply either the <strong class="source-inline">values/dev/values.yaml</strong> file or the <strong class="source-inline">values/prod/values.yaml</strong> file.</p>
			<p>These values files can be seen within the <strong class="source-inline">chapter10/multiple-envs/nginx/values</strong> directory (<a href="https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter10/multiple-envs/nginx/values">https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter10/multiple-envs/nginx/values</a>). Note that, since Argo CD has been configured to use the <strong class="source-inline">chapter10/multiple-envs/nginx</strong> chart path, the values files must be located underneath this path. It is also important to note that this method of applying values files is only applicable when deploying a Helm chart from Git. When deploying from a remote Helm chart repository, values can be provided using the <strong class="source-inline">helm.values</strong> or <strong class="source-inline">helm.parameters</strong> method, as described in the <em class="italic">Deploying a Helm chart from a Git repository</em> section.</p>
			<ul>
				<li>Finally, we must define the destinations that Argo CD should deploy the resources to:<p class="source-code">destination:</p><p class="source-code">  server: https://kubernetes.default.svc</p><p class="source-code">  namespace: chapter10-{{ env }}</p></li>
			</ul>
			<p>This will deploy the Helm chart to the <strong class="source-inline">chapter10-dev</strong> and <strong class="source-inline">chapter10-prod</strong> namespaces. In this example, we separated environments by namespace for simplicity, but <a id="_idIndexMarker603"/>you can also instruct Argo CD to deploy to separate clusters by parameterizing the <strong class="source-inline">destination.server</strong> section in a fashion similar to how we have parameterized the namespace.</p>
			<p>Now that we know how <strong class="source-inline">ApplicationSet</strong> is created, let’s apply it to our Kubernetes cluster to deploy our Helm chart across different environments. First, apply <strong class="source-inline">ApplicationSet</strong> located at <strong class="source-inline">chapter10/multiple-envs/applicationset.yaml</strong> (<a href="https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/multiple-envs/applicationset.yaml">https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/multiple-envs/applicationset.yaml</a>):</p>
			<p class="source-code">$ kubectl apply –f chapter10/multiple-envs/applicationset.yaml -n argo</p>
			<p>Shortly, we should see two different applications appear in the <strong class="source-inline">argo</strong> namespace:</p>
			<p class="source-code">$ kubectl get applications –n argo</p>
			<p class="source-code">NAME         SYNC STATUS   HEALTH STATUS</p>
			<p class="source-code">nginx-dev    Synced        Healthy</p>
			<p class="source-code">nginx-prod   Synced        Healthy</p>
			<p>We can also observe the deployment running in our different environments:</p>
			<p class="source-code">$ kubectl get pods –n chapter10-dev</p>
			<p class="source-code">NAME                     READY   STATUS    RESTARTS   AGE</p>
			<p class="source-code">nginx-6d948d7f48-kkr4j   1/1     Running   0          75s</p>
			<p class="source-code">$ kubectl get pods –n chapter10-prod</p>
			<p class="source-code">NAME                     READY   STATUS    RESTARTS   AGE</p>
			<p class="source-code">nginx-6d948d7f48-76p22   1/1     Running   0          107s</p>
			<p class="source-code">nginx-6d948d7f48-bf76x   1/1     Running   0          107s</p>
			<p class="source-code">nginx-6d948d7f48-rcq4z   1/1     Running   0          107s</p>
			<p>You can observe three different <strong class="source-inline">nginx</strong> pods in <strong class="source-inline">chapter10-prod</strong> because the <strong class="source-inline">values</strong> file <a id="_idIndexMarker604"/>under <strong class="source-inline">chapter10/multiple-envs/nginx/values/prod/values.yaml</strong> specifies three replicas, while the <strong class="source-inline">dev values</strong> file only specifies one.</p>
			<p>If you were able to observe similar output in your minikube environment to those shown previously, congratulations! You have successfully deployed a Helm chart to multiple environments in a GitOps fashion with Argo CD.</p>
			<p>Let’s conclude this chapter by cleaning up the environment.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor252"/>Cleaning up</h1>
			<p>First, let’s <a id="_idIndexMarker605"/>remove the namespaces from this chapter and the Argo installation:</p>
			<p class="source-code">$ kubectl delete namespace chapter10-prod</p>
			<p class="source-code">$ kubectl delete namespace chapter10-dev</p>
			<p class="source-code">$ kubectl delete namespace chapter10</p>
			<p class="source-code">$ helm uninstall argo –n argo</p>
			<p class="source-code">$ kubectl delete namespace argo</p>
			<p>Then, you can stop the minikube cluster with the <strong class="source-inline">minikube stop</strong> command.</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor253"/>Summary</h1>
			<p>CD and GitOps provide scalable methods for further abstracting the capabilities that Helm provides, allowing deployments to be controlled by the contents of a Git repository or a remote chart repository. In this chapter, we introduced the concepts of CI/CD and GitOps and explored them using Argo CD as a solution to implementing these models in the context of Helm. Then, we learned how to install Argo CD and how to create the <strong class="source-inline">Application</strong> and <strong class="source-inline">ApplicationSet</strong> resources, which are primitives for enabling Argo CD deployments and synchronizing them with specified Helm charts and values. Finally, we learned how to deploy a Helm chart across multiple different environments.</p>
			<p>In the next chapter, we will explore another abstraction – the Helm operator.</p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor254"/>Questions</h1>
			<p>Answer the following questions to test your knowledge of this chapter:</p>
			<ol>
				<li value="1">What is the difference between CI and CD?</li>
				<li>What is the relationship between CD and GitOps?</li>
				<li>What is the difference between an Argo CD <strong class="source-inline">Application</strong> and <strong class="source-inline">ApplicationSet</strong>?</li>
				<li>What is the Argo CD equivalent of passing the <strong class="source-inline">--values</strong> flag on the command line?</li>
				<li>What is the Argo CD equivalent of passing the <strong class="source-inline">--set</strong> flag on the command line?</li>
				<li>What is an <strong class="source-inline">ApplicationSet</strong> generator? Why are generators useful when deploying to multiple environments?</li>
			</ol>
		</div>
		<div>
			<div id="_idContainer110">
			</div>
		</div>
	</body></html>