- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring External Secret Stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we worked with the cloud providers AWS, Azure, and GCP. We ran our
    application and integrated it with the secret providers offered on these platforms.
    We used the Secrets management facilities of each cloud provider and benefited
    from the ecosystem of tools that the cloud providers provides us with. This made
    it feasible to tackle concerns such as auditing high availability and disaster
    recovery. In this chapter, we shall explore external secret stores that are not
    part of a cloud provider’s offerings.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of external secret store providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different types of external secret stores, such as HashiCorp Vault, and
    CyberArk Secrets Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Secrets in an external secret store for Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To link concepts with hands-on examples, we are leveraging a series of tools
    and platforms commonly used to interact with the Google Cloud API and Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**kubectl**: This is the command-line tool used for communicating with a Kubernetes
    cluster through the Kubernetes API ([https://kubernetes.io/docs/reference/kubectl/](https://kubernetes.io/docs/reference/kubectl/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**minikube**: This is a local Kubernetes distribution used for Kubernetes learning
    and development. To install minikube on your system, you can follow the instructions
    from the official documentation ([https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vault CLI**: This is used to interact with a HashiCorp Vault installation
    ([https://developer.hashicorp.com/vault/docs/install](https://developer.hashicorp.com/vault/docs/install)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl` commands ([https://jqlang.github.io/jq/](https://jqlang.github.io/jq/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Helm**: This is a package manager for Kubernetes that we will be using to
    simplify the deployment and management of Kubernetes resources ([https://helm.sh](https://helm.sh)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of external secret providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Secrets on Kubernetes are stored in **etcd** as mentioned in [*Chapter
    1*](B20970_01.xhtml#_idTextAnchor015), *Understanding Kubernetes Secrets Management*.
    Storing Secrets on etcd comes with certain security concerns, as mentioned in
    [*Chapter 7*](B20970_07.xhtml#_idTextAnchor142), *Challenges and Risks in Managing
    Secrets*. Alternative forms of secret storage can help us harden our security
    and also segregate the concerns that come with secret usage. We will focus on
    the components that make it feasible to have external secret providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let us have a look at the available external secret store providers:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS Secrets Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Key Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCP Secret Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HashiCorp Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CyberArk Conjur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way these providers offer integration with Kubernetes might differ. A very
    popular approach to achieving integration with a secret store provider is through
    the Secrets Store CSI Driver.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets Store CSI Driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Secrets Store CSI Driver makes it feasible to integrate Kubernetes Secrets
    through a **container storage interface** (**CSI**) volume. The Kubernetes Secrets
    Store interface is based on the Kubernetes CSI plugin. Through CSI, we can integrate
    external store providers to Kubernetes by implementing a CSI plugin, which can
    extend our cluster’s storage capabilities without having to change the Kubernetes
    core code.
  prefs: []
  type: TYPE_NORMAL
- en: External secret store providers with CSI plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a handful of CSI provider plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCP provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vault provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous chapters, we focused on the CSI Secrets Store CSI Driver that
    came along with the cloud provider solutions. We mention a new provider, the Vault
    provider, which is HashiCorp’s secret storage.
  prefs: []
  type: TYPE_NORMAL
- en: All the secret providers on the list give the option of high availability, and
    all secret providers provide auditing and logging. Those elements ensure data
    governance and security. Apart from the CSI Driver solution, there are also other
    approaches available for Secrets management integration. One of them is the Secrets
    Injector component, which we will cover next.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets Injector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Secrets Injector component offers another way to inject Secrets on an application
    and Secrets hosted on an external secret store provider.
  prefs: []
  type: TYPE_NORMAL
- en: Secret managers such as HashiCorp Vault and CyberArk Conjur support secret storage
    usage through the Sidecar Injector. Those sidecar injectors focus on the aspects
    of authorization and authentication when it comes to receiving the Secrets from
    the secret storage. Also, they tackle the integration with the Kubernetes workloads.
  prefs: []
  type: TYPE_NORMAL
- en: However, take note that injecting Secrets is not an action that always requires
    a sophisticated binary that interacts with Kubernetes. For example, let us consider
    GCP Secret Manager. There is no official binary that will receive the Secrets
    from Secret Manager and then attach them to the Pod. This does not prevent us
    from implementing a solution that will securely achieve the same result. We can
    utilize Workload Identity, as mentioned in [*Chapter 10*](B20970_10.xhtml#_idTextAnchor193),
    *Exploring Cloud Secret Store on GCP*. Through Workload Identity, our Kubernetes
    workloads can interact with Secret Manager. We can then use the client libraries
    of GCP Secret Manager, and through an initialization container, the Secrets can
    be mounted locally to the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe can be applied to any other form of storage. The key element to
    note is the usage of Workload Identity; the security remained intact by utilizing
    it. We did not have to store any Secrets on etcd that would make it feasible to
    interact with Secret Manager. Instead, Kubernetes workloads would get assigned
    certain permissions to make it feasible to interact with Secret Manager.
  prefs: []
  type: TYPE_NORMAL
- en: In other forms of Secrets management, such as HashiCorp Vault, authentication
    and interaction with the secret storage are a bit different from what we have
    seen so far, yet the security qualities remain the same. Access to the Secrets
    is achieved in a secure and authorized way where the principle of least permissions
    is followed. We will examine this in the following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we had an overview of the external Secrets Provider that we can
    use to inject our Secrets into Kubernetes. Going forward, we will focus on the
    HashiCorp Vault and its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: HashiCorp Vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the rapidly evolving landscape of distributed computing, securing sensitive
    information is paramount. Kubernetes, a leader in container orchestration, requires
    robust solutions to manage Secrets—sensitive data necessary for the proper configuration
    and operation of applications. HashiCorp Vault stands out as a central figure
    in addressing these challenges, providing a comprehensive suite of tools for secure
    Secrets management across Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: HashiCorp Vault offers a centralized, encrypted solution, ensuring that Secrets
    remain confidential and are never exposed in application code or configuration
    files. Its integration with Kubernetes not only simplifies Secrets management
    but also fortifies the security of containerized applications, introducing features
    such as dynamic Secrets, secure secret injection into Pods, and a Kubernetes-native
    authentication method. These features foster secure communications and secret
    retrieval between HashiCorp Vault and Kubernetes, enhancing flexibility, security,
    and efficiency in managing Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: HashiCorp Vault’s capability to dynamically generate short-lived credentials
    on demand distinguishes it from native Kubernetes Secrets, which are often stored
    unencrypted in etcd and become unwieldy as applications scale. HashiCorp Vault’s
    approach minimizes the attack surface, enhances security, and addresses the potential
    mismanagement of Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, HashiCorp Vault’s extensive audit logging ensures transparency and
    accountability, aiding compliance and facilitating swift responses to security
    incidents. By integrating HashiCorp Vault into Kubernetes deployments, organizations
    position themselves to achieve a robust, secure, and compliant containerized application
    environment, overcoming the limitations of native Kubernetes Secrets and elevating
    their Secrets management practices to the highest security standards.
  prefs: []
  type: TYPE_NORMAL
- en: There is an open source and an enterprise version, and we will focus on the
    open source version next.
  prefs: []
  type: TYPE_NORMAL
- en: Using HashiCorp Vault as a secret storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HashiCorp Vault can be used as a secret storage; it can contain the Secrets
    of our application. This makes it feasible to host Kubernetes Secrets on Vault.
    This can be done in two ways: either having the Vault hosted outside of Kubernetes
    or hosting the Vault with Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us examine how we can integrate an external HashiCorp Vault with Kubernetes.
    For our needs, we shall use a minikube installation.
  prefs: []
  type: TYPE_NORMAL
- en: External Vault storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will proceed with creating a Vault instance, which will be run through a
    Docker container. We can run Vault using Docker Compose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run Vault using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Another solution is to run Vault by using a plain Docker command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There is no difference in the outcome of those two commands. Compose has the
    convenience of being just one file, but standalone docker commands also work as
    well. It is a matter of preference.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that we run Vault in development mode for debugging
    purposes. This is not a secure way to run Vault, which we will see in the *Development
    mode versus production mode* section of this chapter. Development mode will be
    used to make our example use case simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Let us examine Vault. We specified the root token; this is a token with root
    permissions. We also set the level of logging to `debug`. This is to help us with
    troubleshooting our installation. The `VAULT_DEV_LISTEN_ADDRESS` is the address
    to bind when in development mode. For now, this is sufficient to proceed with
    integrating with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vault on Kubernetes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To be able to integrate Vault with Kubernetes, we need to install the Vault
    binaries. The easiest way to do so is through a Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we shall acquire a reference for our Vault installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will install Vault on Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We installed the Vault package on Kubernetes and set an external Vault address
    that Kubernetes will point to. Also, we enabled the CSI since we will show the
    CSI capabilities in another example. To check that our installation was successful,
    we can check whether the deployment of `vault-agent-injector` is in our cluster.
    By using `kubectl`, we can identify whether a `vault-agent-injector` deployment
    exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let us understand how the Vault Agent Injector works.
  prefs: []
  type: TYPE_NORMAL
- en: Vault Agent Injector
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we examine the Vault Agent Injector, we shall see that it uses a specific
    service account, `vault-agent-injector`. This component is responsible for changing
    the Pod specifications so agent containers can be included. These Vault Agent
    containers render Secrets from Vault to a shared memory volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'On an initialization of a Pod that uses Vault Secrets, the following actions
    occur:'
  prefs: []
  type: TYPE_NORMAL
- en: The agent will identify the Pod that uses the Vault Secrets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Pod specification will be changed and will include the Vault Agent containers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Vault init container will fetch the Secrets and attach them to the Pod as
    shared memory volume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the Secrets change in the Vault, the Vault Sidecar Injector will change the
    Secrets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `vault-agent-injector` Pod is assigned the `vault-agent-injector-clusterrole`
    role.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the `vault-agent-injector-clusterrole` cluster role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `vault-agent-injector` is registered to Kubernetes as a `vault-agent-injector`
    will intercept the creation request and rewrite the Pod definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Vault annotations would be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we enable the injection method. Then, we specify the Vault role
    that will be used to fetch the Secrets and the Secrets that will be fetched:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Vault Injector and application hosted on Kubernetes](img/B20970_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Vault Injector and application hosted on Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: By rewriting the Pod definition, the Pod will now contain Vault Agent containers.
    The Vault Agent containers will then interact with Vault to retrieve the Secrets
    and inject them into the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Vault service account and Kubernetes authentication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For Vault to interact with Kubernetes, it must use a service account. By installing
    the Vault Helm package, a service account will also be created. The service account
    is named `vault`.
  prefs: []
  type: TYPE_NORMAL
- en: We need to create a token for that service account. From [*Chapter 2*](B20970_02.xhtml#_idTextAnchor031),
    *Walking through Kubernetes Secrets Management Concepts*, we know that in new
    versions of Kubernetes, we must create a secret for the service account by ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the secret for the service account. We will create a YAML file
    with the following specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we shall apply the YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The secret will be created, and we should be able to use it for Vault. Now we
    should configure Vault to enable the Kubernetes authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes authentication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can authenticate Vault by using a Kubernetes service account token. This
    is the Kubernetes auth method. Essentially, we configure a Kubernetes service
    account token on Vault. Then, this service account token is used to interact with
    the Kubernetes API. To enable this, we need to have the auth method enabled on
    Vault.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps should be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us see how this works behind the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: A service account is configured on Vault. It has the permissions to interact
    with the Kubernetes API and execute TokenReview requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A role is created on Vault with permissions to interact with a secret residing
    in Vault. The role is mapped to a Kubernetes service account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Pod is created and gets assigned the service account we created in the previous
    step. The Vault Injector issues a request to Vault using the service account JWT
    in order to fetch the secret from Vault.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vault issues a TokenReview request to the Kubernetes API in order to validate
    the JWT token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes validates the token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vault checks whether the service account mapped to the token is mapped to a
    role with access to the secret requested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vault responds with the secret value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Vault Injector injects the secret into the Pod.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a diagram of the flow we discussed so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Kubernetes auth flow](img/B20970_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Kubernetes auth flow
  prefs: []
  type: TYPE_NORMAL
- en: We configured Kubernetes authentication. One of the problems we will face is
    that `$KUBE_HOST` points to `localhost`; thus, the certificate is mapped to `localhost`.
    This can be an issue since Vault can access minikube through the Docker host address,
    thus a different address from `localhost`. For this reason, we shall use the `proxy`
    file we mounted previously. The port will have to change with the port of the
    `$KUBE_HOST`, which changes dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'On another terminal, we shall execute the following commands and enable port
    forwarding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this form of authentication involves many steps, auditing will help to
    increase our observability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The audit log file at `/tmp/vault_audit.log` can be tailed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since authentication is enabled and we have configured the service account needed,
    we should proceed and provide permissions for Vault to certain service accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Vault policies and bindings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The benefit of using a secret provider such as Vault is the fact that we can
    store our Secrets and provide fine-grained policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we shall store the following secret in Vault:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We would like to have a restrictive read-only policy for the secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we shall implement a policy with read-only permissions to the `secret/webapp/admin`
    secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The policy is in place, so if we want certain workloads to be able to use this
    policy, we need to declaratively specify so. In our case, we shall have a Kubernetes
    service account mapped to a Pod that would require Secrets from Vault. The service
    account name would be `simple-app`. Our next step would be to bind the policy
    we created previously with that service account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we should create that service account on Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This service account would be used by Vault Injector to inject the Secrets
    into the application. Provisioning the service account alone is not sufficient
    enough to interact with Vault. A cluster role binding is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`auth-delegator` is a role that allows delegated authentication and authorization
    checks. This way, the service account we configured on Vault can issue a TokenReview
    request for a JWT token that is bound to the `simple-app` service account.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Vault Secrets in an application
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `simple-app` service account will have the `auth-delegator` cluster role.
    The role enables delegated authentication and checks. Vault would be able to perform
    delegated authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall create the application that will fetch the secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted annotations used are crucial for `vault-agent-injector` to rewrite
    the Pod configuration so that the Vault initialization containers will take effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once our application is up and running, we can now check the credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Overall, we managed to interact with Vault in a secure way without having to
    mount any Vault-specific credentials to Kubernetes Secrets and thus on etcd. Instead,
    we relied on using the Kubernetes auth method supported by Vault. Now we can finally
    inject our credentials into the application by using the Vault sidecar container.
    However, Vault also supports another method of injecting Secrets into Kubernetes:
    the familiar CSI Driver method.'
  prefs: []
  type: TYPE_NORMAL
- en: Vault and CSI Driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thanks to previous chapters, we are familiar with the Secret Store CSI Driver.
    Vault also enables us to use this approach. Using the CSI Driver is a different
    approach to mounting the Secrets from Vault on a Pod; however, it benefits from
    the same components. Since we have the Kubernetes auth method configured, we have
    the Vault authentication requirements tackled.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we do need to have the `secrets-store-csi-driver` package installed.
    We shall execute the following Helm commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create `SecretProviderClass` pointing to the Secrets located
    in Vault:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to provision the app, which will use the CSI provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We managed to securely integrate Vault with Kubernetes. We achieved this using
    the CSI and Vault Injector methods. There is another method to integrate Kubernetes
    workloads with Vault and this is by running an installation of Vault on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Vault hosted on Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In certain cases, a Vault cluster might be hosted on Kubernetes. It is an approach
    with several benefits. From a maintenance perspective, you take advantage of Kubernetes,
    and from a latency perspective, it can be faster, provided that the previous Vault
    installation was deployed on another network.
  prefs: []
  type: TYPE_NORMAL
- en: We shall do the installation through minikube.
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall configure the values for the Vault installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to running Vault on minikube, we do not have the option to run on multiple
    nodes. Thus, we disable the network affinity. Also, we shall run Vault with high
    availability enabled using three replicas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: By running Vault in a high availability mode, the Raft consensus algorithm is
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Take note that Vault is installed using `StatefulSet` and the default number
    is `3` nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we check the logs, we shall see that Vault is not initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to initialize Vault:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will create the `cluster-keys.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the contents of the cluster key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next step is to unseal the vault using the unseal key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to join the nodes one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: By joining the nodes on the cluster, the leader election process should start
    taking place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to unseal the other nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now that unsealing has been done, we can start adding data to Vault.
  prefs: []
  type: TYPE_NORMAL
- en: 'A port forward on Kubernetes should be effective:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us stop forwarding to `vault-0` and forward to another node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We also evaluate whether we can fetch the Secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we got our Secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The Secrets were stored and replicated through the node.
  prefs: []
  type: TYPE_NORMAL
- en: Take note that in this example we enabled the `kv-v2` engine. The engine allows
    us to have multiple versions of Secrets. We will examine this functionality in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: We read through an overview of running Vault on Kubernetes, which covered aspects
    of running Vault in production mode. Therefore, it is worth noting the differences
    between running Vault in development mode and in production mode.
  prefs: []
  type: TYPE_NORMAL
- en: Development mode versus production mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have run Vault so far in development mode. Development mode has certain
    characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Lack of high availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsealed by default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single unseal key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialized by default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data stored in memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it comes to production, things should be different.
  prefs: []
  type: TYPE_NORMAL
- en: Production mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In production mode, high availability should be in place. This is achieved with
    the Raft protocol. When Vault is run in production, we do not have a standalone
    Vault instance but a Vault cluster based on the Raft protocol. This comes with
    the benefit of high availability; if a Vault node goes down, the requests can
    be served by another node that is available. Also, we can have performance standby
    nodes, nodes that are used to serve read requests, thus achieving horizontal scalability
    on read operations.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that is much different in production mode is the initialization.
    When a Vault cluster is created it must be initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Seal and unseal
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To be able to use a Vault installation, Vault needs to be initialized so that
    the storage backend will be prepared to receive data.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the initialization, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: A root key is generated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root key is stored in the storage backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root key is encrypted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root key is stored in its encrypted form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the root key is encrypted, it cannot be used; it needs to be decrypted.
    In order to decrypt a root key, an unseal key is needed.
  prefs: []
  type: TYPE_NORMAL
- en: The unseal key is not distributed as a single key. It uses Shamir’s secret-sharing
    algorithm ([https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing](https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing)).
    The unseal key is divided into parts called *shares*, and those shares are spread
    throughout the cluster. For the key to be reassembled, it requires several shares
    to be reassembled, which is called the **threshold**. Supposing an attacker steals
    some shares. It will not be possible to reconstruct the unseal key if the shares
    stolen are less than the threshold. By using Shamir’s secret sharing algorithm,
    Vault becomes more resilient to attacks that aim to acquire an unseal key.
  prefs: []
  type: TYPE_NORMAL
- en: When we unseal a vault, we use the unseal keys to retrieve the root key unencrypted.
    Then, the root key will reside unencrypted in the Vault memory. Vault, by using
    the root key, will be able to decrypt the encryption key needed to store data
    in Vault.
  prefs: []
  type: TYPE_NORMAL
- en: When we run Vault in production mode, the initialization is manual. The initialization
    is executed using the `vault operator init` command. We can specify the number
    of shares—the unseal keys. As a result, we shall have printed some unseal keys
    and a root token. The unseal keys will be used to reassemble the root token. The
    root token is a token to which the root policy is attached. It is a token that
    can perform operations using the root key.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of an intrusion, it is feasible to seal the vault. By sealing, the
    root key will be purged from Vault’s memory, and the vault will no longer be able
    to decrypt the data residing in its storage. Furthermore, operations and Vault
    services will stop.
  prefs: []
  type: TYPE_NORMAL
- en: High availability
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we have seen by installing Vault on Kubernetes, we had three instances deployed
    by default in StatefulSets. This is because of Raft. Vault is a distributed system
    and Raft is the consensus algorithm used. The minimum number of nodes is three.
    With three nodes, a failure of one node can be tolerated, provided the other two
    nodes continue operating. To calculate the node tolerance, use the formula *(n-1)/2*,
    where *n* is the number of total nodes. For example, on a Vault installation consisting
    of five nodes, Vault will continue to be operational if two nodes fail. Once Vault
    is up and the nodes achieve consensus, data is written to the leader. The leader
    must replicate the data written to the followers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Replication of data](img/B20970_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Replication of data
  prefs: []
  type: TYPE_NORMAL
- en: Take note that if a write operation is tried on a follower, Vault will respond
    to the caller with the leader address. This way, the data will be written to the
    leader.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Client redirect](img/B20970_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Client redirect
  prefs: []
  type: TYPE_NORMAL
- en: Raft on Vault tackles the problem of state synchronization, thus enabling the
    option of integrated storage. However, Vault can be backed by various forms of
    external storage.
  prefs: []
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Vault has various options for storage. There are options for external storage,
    which include databases such as Cassandra, DynamoDB, and more. Those options provide
    all the benefits that come with the underlying external storage. For example,
    in the case of DynamoDB, Vault can benefit from the backups, auditing, high availability,
    and all the other features that come with DynamoDB.
  prefs: []
  type: TYPE_NORMAL
- en: The other storage that is recommended is integrated storage. Integrated storage
    is maintained by HashiCorp. It is collocated with the host; this makes operations
    more efficient due to avoiding network hops. Also, by using integrated storage,
    the operational complexity is reduced and extra expertise on external storage
    is not required.
  prefs: []
  type: TYPE_NORMAL
- en: KV-2 vs KV-1 storage engine
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `kv` Secrets engine is used to store Secrets in the physical storage in
    Vault. The latest version of `kv`, KV version 2, offers versioning on secret storage.
    By default, 10 versions of a secret are retained. The number is configurable.
    The older versions of a secret can be retrieved. Versioning increases storage
    costs. Deleting a version marks it as deleted, but the version is not physically
    deleted; it can be undeleted. To force a version’s physical deletion, the `destroy`
    command needs to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the `destroy` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first version of the `kv` engine, KV version 1, does not have the versioning
    feature; thus, the storage needs are less than for KV version 2.
  prefs: []
  type: TYPE_NORMAL
- en: Policies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The principle of least permissions is crucial to ensuring the security of our
    Secrets. This is achieved by Vault policies.
  prefs: []
  type: TYPE_NORMAL
- en: By using policies, we can specify access privileges. Take, for example, the
    policies we created previously to fetch the Secrets from Vault on a Kubernetes
    application. We created the policy `devwebapp`, which will provide read capabilities
    to the `secret/devwebapp/config` path. This policy was attached to the service
    account of the Kubernetes application that would use that secret. Thus, the tokens
    generated for that service account would be able to read only the secret specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, we had an overview of HashiCorp Vault and how it can be integrated
    with Kubernetes. Next, we will focus on another secret manager provider: CyberArk
    Conjur.'
  prefs: []
  type: TYPE_NORMAL
- en: CyberArk Conjur
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conjur from CyberArk is a Secrets management solution. It has a commercial and
    an open source version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conjur as a solution comes with the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Role-based access** **control** (**RBAC**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging and auditing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us take a closer look at Conjur and see how it achieves these qualities.
  prefs: []
  type: TYPE_NORMAL
- en: How Conjur works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conjur requires the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Reverse Nginx proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conjur application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reverse proxy is used to handle the TLS termination. It sits in front of
    the Conjur application. The Conjur application is a Ruby-based application and
    is responsible for securely storing Secrets. This application is backed by a PostgreSQL
    database.
  prefs: []
  type: TYPE_NORMAL
- en: High availability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Conjur uses Raft to make high availability possible. It has a leader–follower
    architecture. The master will serve inbound traffic. In case of a master failure,
    a follower instance will be promoted to master.
  prefs: []
  type: TYPE_NORMAL
- en: Server keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Conjur uses a data key, a Conjur UI key, and SSL keys. Those keys are generated
    during the Conjur server initialization plaintext. They should be encrypted to
    harden the initialization. This happens through the usage of a master key.
  prefs: []
  type: TYPE_NORMAL
- en: By using the master key, the keys are encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Before using the Conjur services, we need to unlock the keys using the master
    key. Once the encrypted keys are unlocked using the master key, they will reside
    on the Linux keyring and memory-based file system. Conjur offers the option to
    use AWS KMS or a hardware security module as a master key.
  prefs: []
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For storing Secrets, Conjur is backed by a database. Conjur uses PostgreSQL
    to store the Secrets. Conjur benefits from all the features that come with a PostgreSQL
    database. A PostgreSQL database comes with many features, such as replication,
    auditing, and fine-grained permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a secret stored on Conjur can be found on the PostgreSQL database
    by querying the Secrets table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This secret is unusable since it is encrypted. In case of a breach, the names
    of the Secrets would be leaked but not the actual value of the Secrets since the
    decryption key is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Conjur also has the secret versioning feature. It keeps the last 20 versions
    of a secret.
  prefs: []
  type: TYPE_NORMAL
- en: Policies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By using Conjur policies, we can define security rules that describe which roles
    have permissions to perform certain operations on a Conjur resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a Conjur policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `ExamplePolicy` policy provides to the non-human identity
    `webApp` the permission to read the `secretVar` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Audit logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have seen in previous chapters, audit logs are crucial when it comes to
    Secrets management.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the documentation, we can see what an audit log in JSON format looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The preceding log has all the information that we need to identify what happened
    on our Conjur server. `action` displays the action that took place, `auth` displays
    the entity that executed the action that took place, and `subject` displays the
    resource affected.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Conjur has many options for enabling Kubernetes integration. One of them is
    the Kubernetes Authenticator Client.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Authenticator Client
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Conjur has the Kubernetes Authenticator Client. The Kubernetes application that
    uses Conjur Secrets has a sidecar container with a Conjur client. The client using
    the service account will authenticate with Conjur. Then, Conjur will issue a temporary
    token. The sidecar container will use that temporary token to retrieve the Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned more about the secret manager Conjur. We identified
    its features and how it can integrate with Kubernetes. Those features, along with
    the features that we focused on in the previous chapters, form the standards for
    managing Secrets using an external secret store.
  prefs: []
  type: TYPE_NORMAL
- en: Qualities for securely managing Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, there are certain qualities when it comes to storing external
    Secrets. In this chapter, we took a deep dive into the HashiCorp Vault and how
    it integrates with Kubernetes. We also had a look at another Secrets management
    provider, Conjur.
  prefs: []
  type: TYPE_NORMAL
- en: 'A secret manager needs to have certain qualities:'
  prefs: []
  type: TYPE_NORMAL
- en: High availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RBAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auditing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those qualities are essential to ensuring the secure and robust storage of an
    application’s Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: High availability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: High availability is required to ensure our data is safe. It can protect us
    from losing any data in case of a service outage. It ensures business continuity.
    External secret stores such as Vault and Conjur achieve high availability by utilizing
    Raft, the popular consensus method. By having a consensus method, the cluster
    approach for availability is feasible; we can add multiple nodes to different
    data centers, which will form a cluster and share workloads. Thanks to this choice,
    in case of a failure, data is distributed in a way that can tolerate failures.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption of data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data in an external secret store should be encrypted. The encryption keys
    that encrypt the data in the external secret store should also be encrypted. As
    we have seen previously, providers achieve this by implementing mechanisms such
    as Shamir’s secret sharing or by using a master key to encrypt the data encryption
    keys. Then, the data encryption keys are used to encrypt the actual data.
  prefs: []
  type: TYPE_NORMAL
- en: Secure access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Access is secured with proper authentication methods and the principle of least
    privilege. We can achieve this with policies. External secret stores such as Vault
    and Conjur give us the option of policies. With policies, we can specify the operations
    that an identity can perform on a secret resource. This allows us to create fine-grained
    permissions that minimize the risks that come with overprivileged accounts that
    interact with the Secrets storage.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the secret store providers we worked with throughout this book offered versioning.
    Versioning is crucial in preventing accidental deletion and enabling smooth rotation.
    Secrets, by their nature, are sensitive, which makes rotation a necessity. Having
    a versioning of Secrets enables developer teams to proceed with the secret rotation
    operations in a robust and resilient way.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we can see, integration with Kubernetes is achieved using the least permissions
    needed, and we did not store any sensitive keys in etcd. Instead, HashiCorp Vault
    or Conjur were managed through Kubernetes service accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets were injected into our applications without having to store them in
    etcd. Also, we did not have to store any Secrets that could communicate with the
    secret storage.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Auditing is crucial for Secrets management. Through auditing, we achieve a record
    of activity towards the resources that reside on an external secret store. In
    all the options for external Secrets storage, auditing capabilities are present.
    In case of a breach or any malevolent action, auditing can help us identify the
    exposure and take remediation actions. Auditing can also help in debugging as
    well as ensure that the system operates properly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a deep dive into HashiCorp Vault, how it integrates
    with Kubernetes, and the different methods that can be used to access the Vault
    Secrets through Kubernetes workloads. We used Secrets from Vault either through
    the `vault-agent-injector` method or through the CSI Driver. Furthermore, we performed
    an installation of Vault on Kubernetes and identified the qualities for a Vault
    production deployment. We also learned about another Secrets provider, CyberArk
    Conjur, and its capabilities. In the next chapter, we will focus on the overall
    use cases of Secrets and the different approaches that we can follow for integrating
    with external secret stores. Also, we will take a deep dive into the approaches
    to integration with external secret stores.
  prefs: []
  type: TYPE_NORMAL
