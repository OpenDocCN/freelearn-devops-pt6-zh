<html><head></head><body>
		<div id="_idContainer116">
			<h1 id="_idParaDest-223" class="chapter-number"><a id="_idTextAnchor270"/>12</h1>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor271"/>Helm Security Considerations</h1>
			<p>As you have likely come to realize throughout this book, Helm is a powerful tool that makes deploying applications on Kubernetes simple and efficient. With that said, we need to <a id="_idIndexMarker647"/>ensure that we do not lose sight of security best practices when leveraging Helm. Luckily, Helm provides several ways to incorporate good security practices into everyday usage in ways that are simple to achieve, from the moment the Helm CLI is downloaded to the moment a Helm chart is installed into a Kubernetes cluster.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Data provenance and integrity</li>
				<li>Developing secure and stable Helm charts</li>
				<li>Configuring RBAC rules</li>
			</ul>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor272"/>Technical requirements</h1>
			<p>This chapter will make use of the following technologies:</p>
			<ul>
				<li><strong class="source-inline">minikube</strong></li>
				<li><strong class="source-inline">kubectl</strong></li>
				<li><strong class="source-inline">helm</strong></li>
				<li><strong class="source-inline">gpg</strong> (GNU Privacy Guard)</li>
			</ul>
			<p>You learned how to install and configure the <strong class="source-inline">minikube</strong>, <strong class="source-inline">kubectl</strong>, and <strong class="source-inline">helm</strong> <strong class="bold">command-line interfaces</strong> (<strong class="bold">CLIs</strong>) in <a href="B17979_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Preparing a Kubernetes and Helm Environment</em>.</p>
			<p>We will also leverage the guestbook chart from the Packt repository located at <a href="https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm">https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm</a> for an exercise later in this chapter. If you have not already cloned the repository, you can do so with the following command:</p>
			<p class="source-code">$ git clone https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git</p>
			<p>Let’s begin by discussing data provenance and integrity.</p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor273"/>Data provenance and integrity</h1>
			<p>When working with any kind of data, two often-overlooked questions should be considered:</p>
			<ul>
				<li>Does the data come from a reliable source?</li>
				<li>Does the data contain all of the contents that you expected it to?</li>
			</ul>
			<p>The first question relates<a id="_idIndexMarker648"/> to the topic of <strong class="bold">data provenance</strong>. Data provenance is about determining the origin of data and determining where the data originated from.</p>
			<p>The second question refers to the <a id="_idIndexMarker649"/>topic of <strong class="bold">data integrity</strong>. Data integrity is about determining whether the contents you received from a remote location represents what you expected to receive. It helps determine whether data was tampered with as it was sent across the wire.</p>
			<p>Both data provenance and data integrity can be verified using a concept <a id="_idIndexMarker650"/>called <strong class="bold">digital signatures</strong>. An author can create a unique signature based on cryptography to sign data, and the consumer of that data can use cryptographic tools to verify the authenticity of that signature. If the authenticity is verified, then the consumer is assured that the data originates from the expected source and was not tampered with as it was transferred.</p>
			<p>Authors can <a id="_idIndexMarker651"/>create a digital signature using a variety of tools. One such method is by using <strong class="bold">Pretty Good Privacy</strong> (<strong class="bold">PGP</strong>). PGP, in this context, refers to OpenPGP, which is a set of standards based on encryption. PGP focuses on establishing asymmetric encryption, which is based on the use of two different keys – private and public.</p>
			<p>Private keys are <a id="_idIndexMarker652"/>meant to be kept secret, while public keys are designed to be shared. In PGP, the private key is used to encrypt data, while the public key is used by consumers to decrypt that data. The PGP key pair is often created using a tool called GPG, which is an open source tool that implements the OpenPGP standard.</p>
			<p>To begin working <a id="_idIndexMarker653"/>with PGP, the first step is to create the key pair, which will generate a set of public and private keys. Once the PGP key pair has been created, the author can use GPG to sign the data. When data has been signed, GPG performs the following steps in the background:</p>
			<ol>
				<li>A hash is calculated based on the contents of the data. The output is a fixed-length string called<a id="_idIndexMarker654"/> the <strong class="bold">message digest</strong>.</li>
				<li>The message digest is encrypted using the author’s private key. The output is the digital signature.</li>
			</ol>
			<p>To verify the <a id="_idIndexMarker655"/>signature, consumers must use the author’s public key to decrypt it. This verification can also be performed using GPG.</p>
			<p>Digital signatures play a role in Helm in two ways:</p>
			<ul>
				<li>First, each Helm binary has an accompanying digital signature that’s owned by one of the Helm maintainers. This signature can be used to verify the origin of the download, as well as its integrity.</li>
				<li>Second, Helm charts can also be digitally signed so that they benefit from the same form of verifications. Authors of Helm charts can sign the chart during packaging, and the chart users can verify the chart’s authenticity by using the author’s public key.</li>
			</ul>
			<p>Now that you understand how data provenance and integrity come into play concerning digital signatures, in the next section, you will create a GPG key pair on your local machine that will be used to elaborate on the previously described concepts.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor274"/>Creating a GPG key pair</h2>
			<p>To create a key pair, you must <a id="_idIndexMarker656"/>have GPG installed on your local machine. Use the following instructions as a guide to installing GPG on your respective machine. Note that this chapter is based on <strong class="source-inline">gpg</strong> version 2.3.6:</p>
			<ul>
				<li>For Windows, you can use the Chocolatey package manager:<p class="source-code"><strong class="bold">&gt; choco install gnupg</strong></p></li>
			</ul>
			<p>You can also download the installer for Windows from <a href="https://gpg4win.org/download.html">https://gpg4win.org/download.html</a>.</p>
			<ul>
				<li>For macOS, you <a id="_idIndexMarker657"/>can use the Homebrew package manager by using the following command:<p class="source-code"><strong class="bold">$ brew install gpg</strong></p></li>
			</ul>
			<p>You can also download the macOS-based installer from <a href="https://sourceforge.net/p/gpgosx/docu/Download/">https://sourceforge.net/p/gpgosx/docu/Download/</a>.</p>
			<ul>
				<li>For Debian-based Linux distributions, you can use the <strong class="source-inline">apt</strong> package manager:<p class="source-code"><strong class="bold">$ sudo apt install gnupg</strong></p></li>
				<li>For RPM-based Linux distributions, you can use the <strong class="source-inline">dnf</strong> package manager:<p class="source-code"><strong class="bold">$ sudo dnf install gnupg</strong></p></li>
			</ul>
			<p>Once you have installed GPG, you can create your own GPG key pair, which we will use throughout our discussion on data provenance and integrity.</p>
			<p>Follow these steps to configure your key pair:</p>
			<ol>
				<li value="1">First, we need to begin the generation process by running the <strong class="source-inline">gpg --full-generate-key</strong> command:<p class="source-code"><strong class="bold">$ gpg --full-generate-key</strong></p></li>
				<li>For the <strong class="source-inline">Please select what kind of key you want</strong> prompt, select <strong class="source-inline">(1) RSA and RSA</strong>:<p class="source-code"><strong class="bold">Please select what kind of key you want:</strong></p><p class="source-code"><strong class="bold">   (1) RSA and RSA</strong></p><p class="source-code"><strong class="bold">   (2) DSA and Elgamal</strong></p><p class="source-code"><strong class="bold">   (3) DSA (sign only)</strong></p><p class="source-code"><strong class="bold">   (4) RSA (sign only)</strong></p><p class="source-code"><strong class="bold">   (9) ECC (sign and encrypt) *default*</strong></p><p class="source-code"><strong class="bold">  (10) ECC (sign only)</strong></p><p class="source-code"><strong class="bold">  (14) Existing key from card</strong></p><p class="source-code"><strong class="bold">Your selection? 1</strong></p></li>
			</ol>
			<p>The reason we are using RSA instead of the default option (ECC) is that ECC is not supported by the crypto library used in Helm’s source code.</p>
			<ol>
				<li value="3">Next, you <a id="_idIndexMarker658"/>will be prompted to enter the key size. For this example, we can simply select the default, so continue by pressing the <em class="italic">Enter</em> key:<p class="source-code"><strong class="bold">RSA keys may be between 1024 and 4096 bits long.</strong></p><p class="source-code"><strong class="bold">What keysize do you want? (3072) &lt;enter&gt;</strong></p><p class="source-code"><strong class="bold">Requested keysize is 3072 bits</strong></p></li>
				<li>After you enter your key size, you will be asked how long the key should be valid. Since this key will be used solely to run through the examples, we recommend setting a short expiration, such as 1 week (<strong class="source-inline">1w</strong>):<p class="source-code"><strong class="bold">Please specify how long the key should be valid.</strong></p><p class="source-code"><strong class="bold">         0 = key does not expire</strong></p><p class="source-code"><strong class="bold">      &lt;n&gt;  = key expires in n days</strong></p><p class="source-code"><strong class="bold">      &lt;n&gt;w = key expires in n weeks</strong></p><p class="source-code"><strong class="bold">      &lt;n&gt;m = key expires in n months</strong></p><p class="source-code"><strong class="bold">      &lt;n&gt;y = key expires in n years</strong></p><p class="source-code"><strong class="bold">Key is valid for? (0) 1w</strong></p><p class="source-code"><strong class="bold">Key expires at Sun May 22 12:26:09 2022 EDT</strong></p><p class="source-code"><strong class="bold">Is this correct? (y/N) y</strong></p></li>
				<li>Now, you will be prompted for your name and email address. These will be used to identify you as the owner of the key pair and will be the name and email address displayed by those who receive your public key. You will also be prompted to provide a comment, which you can simply leave blank:<p class="source-code">GnuPG needs to construct a user ID to identify your key.</p><p class="source-code">Real name: John Doe</p><p class="source-code">Email address: jdoe@example.com</p><p class="source-code">Comment: &lt;enter&gt;</p><p class="source-code">You selected this USER-ID:</p><p class="source-code">    "John Doe &lt;jdoe@example.com&gt;"</p></li>
				<li>Press the <em class="italic">O</em> key to continue.</li>
				<li>Finally, you <a id="_idIndexMarker659"/>will be prompted to enter your private key passphrase. Providing a strong passphrase is essential for protecting your identity in the event your private key is stolen. This is because it must be provided each time you attempt to access your key.</li>
			</ol>
			<p>To keep our example simple, we will create an empty string passphrase to avoid passphrase prompts. While this is acceptable in this demonstration, you should protect any private key you intend to use in a real-world situation with a strong passphrase.</p>
			<p>To continue, simply press <em class="italic">Enter</em> to submit an empty passphrase. When prompted, select <strong class="source-inline">&lt;Yes, protection is not needed&gt;</strong>.</p>
			<p>Once your GPG key pair has been created, you will see an output similar to the following:</p>
			<pre class="source-code">
pub   rsa3072 2022-05-15 [SC] [expires: 2022-05-22]
      D2557B1EDD57BBC41A5D4DA7161DADB1C5AC21B5
uid                      John Doe &lt;jdoe@example.com&gt;
sub   rsa3072 2022-05-15 [E] [expires: 2022-05-22]</pre>
			<p>The preceding output displays information about the public (<strong class="source-inline">pub</strong>) and private (<strong class="source-inline">sub</strong>) keys, as well as the fingerprint of the public key (the second line of the output). The fingerprint is a <a id="_idIndexMarker660"/>unique identifier that’s used to identify you as the owner of that key. The third line, beginning with <strong class="source-inline">uid</strong>, displays the name and email address that you entered when generating the GPG key pair.</p>
			<p>With your key pair now created, let’s continue to the next section to learn how a Helm binary can be verified.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor275"/>Verifying Helm downloads</h2>
			<p>As discussed in <a href="B17979_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Preparing a Kubernetes and Helm Environment</em>, one of the <a id="_idIndexMarker661"/>ways Helm can be installed is by downloading an archive from GitHub. These archives can be installed from Helm’s GitHub releases page (<a href="https://github.com/helm/helm/releases">https://github.com/helm/helm/releases</a>) by selecting one of the links shown in the following screenshot:</p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/Figure_12.01_B17979.jpg" alt="Figure 12.1 – The Installation and Upgrading section of Helm’s GitHub releases page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – The Installation and Upgrading section of Helm’s GitHub releases page</p>
			<p>At the bottom of the preceding screenshot, you will notice a paragraph explaining that the release was signed. Each Helm release is signed by a Helm maintainer and can be verified against the digital signature that corresponds to the downloaded release. Each of the signatures is located under the <strong class="bold">Assets</strong> section, as shown here:</p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/Figure_12.02_B17979.jpg" alt="Figure 12.2 – The Assets section of Helm’s GitHub releases page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – The Assets section of Helm’s GitHub releases page</p>
			<p>To verify the <a id="_idIndexMarker662"/>provenance and integrity of a Helm download, in addition to the binary itself, you should also download the corresponding <strong class="source-inline">.asc</strong> file. Note that <strong class="source-inline">sha256</strong> files are used to verify the integrity only. In this example, we will download the <strong class="source-inline">.tar.gz.asc</strong> file, which verifies both provenance and integrity.</p>
			<p>Let’s demonstrate how a Helm release can be verified. First, we should download a Helm archive, along with its corresponding <strong class="source-inline">.asc</strong> file:</p>
			<ol>
				<li value="1">Download a Helm archive that corresponds with your operating system. For this example, we will use version 3.8.2. If you are running an AMD64-based Linux system, the version for this distribution can be downloaded from the GitHub release page or by using the following <strong class="source-inline">curl</strong> command:<p class="source-code"><strong class="bold">$ curl -LO https://get.helm.sh/helm-v3.8.2-linux-amd64.tar.gz</strong></p></li>
				<li>Next, download the<strong class="source-inline">.asc</strong> file that corresponds with your operating system. When running an AMD64-based Linux system, <strong class="source-inline">helm-v3.8.2-linux-amd64.tar.gz.asc</strong> would be the resulting file that would be downloaded. You can download this file from the GitHub release page or by using the following <strong class="source-inline">curl</strong> command:<p class="source-code"><strong class="bold">$ curl -LO https://github.com/helm/helm/releases/download/v3.8.2/helm-v3.8.2-linux-amd64.tar.gz.asc</strong></p></li>
			</ol>
			<p>Once both <a id="_idIndexMarker663"/>files have been downloaded, you should see the two files located within the same directory on the command line:</p>
			<p class="source-code">$ ls –l</p>
			<p class="source-code">helm-v3.8.2-linux-amd64.tar.gz</p>
			<p class="source-code">helm-v3.8.2-linux-amd64.tar.gz.asc</p>
			<p>The next step involves importing the Helm maintainer’s public key to your local GPG keyring. This allows you to decrypt the digital signature contained in the <strong class="source-inline">.asc</strong> file to verify the provenance and integrity of your downloaded binary. GPG public keys are saved in public key servers such as <strong class="source-inline">keyserver.ubuntu.com</strong> and <strong class="source-inline">pgp.mit.edu</strong>. As such, we can use the <strong class="source-inline">gpg --recv-key</strong> command to download the maintainer’s key from a public key server.</p>
			<p>Let’s import the maintainer’s public key and continue with the verification process:</p>
			<ol>
				<li value="1">First, recall the maintainer’s public key fingerprint from <em class="italic">Figure 12.1</em>:<p class="source-code"><strong class="bold">672C657BE06B4B30969C4A57461449C25E36B98E</strong></p></li>
				<li>Use the <strong class="source-inline">gpg --recv-key</strong> command to download and import the key into your local keychain:<p class="source-code"><strong class="bold">$ gpg --recv-key 672C657BE06B4B30969C4A57461449C25E36B98E</strong></p><p class="source-code"><strong class="bold">gpg: key 461449C25E36B98E: public key "Matthew Farina &lt;matt@mattfarina.com&gt;" imported</strong></p><p class="source-code"><strong class="bold">gpg: Total number processed: 1</strong></p><p class="source-code"><strong class="bold">gpg:               imported: 1</strong></p></li>
				<li>Now that the public key has been imported, you can verify the Helm release by using the <strong class="source-inline">--verify</strong> subcommand of GPG. This command has the <strong class="source-inline">gpg --verify &lt;signature&gt; &lt;data&gt;</strong> syntax:<p class="source-code"><strong class="bold">$ gpg --verify helm-v3.8.2-linux-amd64.tar.gz.asc helm-v3.8.2-linux-amd64.tar.gz</strong></p></li>
			</ol>
			<p>This <a id="_idIndexMarker664"/>command decrypts the digital signature contained in the <strong class="source-inline">.asc</strong> file. If it is successful, it means that the Helm download (the file ending in <strong class="source-inline">.tar.gz</strong>) was signed by the person you expected (Matt Farina for this release) and that the download was not modified or altered in any way. A successful output looks similar to the following:</p>
			<p class="source-code">gpg: Signature made Wed Apr 13 14:00:32 2022 EDT</p>
			<p class="source-code">gpg:                using RSA key 711F28D510E1E0BCBD5F6BFE9436E80BFBA46909</p>
			<p class="source-code">gpg: Good signature from "Matthew Farina &lt;matt@mattfarina.com&gt;" [unknown]</p>
			<p class="source-code">gpg: WARNING: This key is not certified with a trusted signature!</p>
			<p class="source-code">gpg:          There is no indication that the signature belongs to the owner.</p>
			<p class="source-code">Primary key fingerprint: 672C 657B E06B 4B30 969C  4A57 4614 49C2 5E36 B98E</p>
			<p class="source-code">     Subkey fingerprint: 711F 28D5 10E1 E0BC BD5F  6BFE 9436 E80B FBA4 6909</p>
			<p>Upon further inspection of this output, you may notice the <strong class="source-inline">WARNING</strong> message, indicating that the key was not certified, which may lead you to question whether or not the verification was successful. In this case, the verification was indeed successful, but you have not certified the maintainer’s key yet, so GPG returns this warning.</p>
			<p>The <strong class="source-inline">This key is not certified</strong> message is normally not an issue, but if you would like to ensure this warning does not appear in the future, you can follow these steps to certify the maintainer’s public key:</p>
			<ol>
				<li value="1">Check that the public key’s fingerprint (also referred to as the primary key from the <strong class="source-inline">gpg –verify</strong> output) matches the fingerprint displayed on the Helm releases page. As you will recall from <em class="italic">Figure 12.1</em>, the fingerprint was displayed, as shown here:<p class="source-code">This release was signed with 672C 657B E06B 4B30 969C 4A57 4614 49C2 5E36 B98E and can be found at @mattfarina keybase account.</p></li>
				<li>Because<a id="_idIndexMarker665"/> the key we imported matches the fingerprint displayed on GitHub, we know that we can trust this key. Trust can be associated with this key by using the <strong class="source-inline">gpg --sign-key</strong> subcommand:<p class="source-code"><strong class="bold">$ gpg --sign-key 672C657BE06B4B30969C4A57461449C25E36B98E</strong></p></li>
			</ol>
			<p>In the <strong class="source-inline">Really sign?</strong> prompt, enter <strong class="source-inline">y</strong>.</p>
			<p>Now that you have signed the maintainer’s public key, the key has been certified. The next time you perform a verification with this key, you should no longer see the warning message:</p>
			<p class="source-code">$ gpg --verify helm-v3.8.2-linux-amd64.tar.gz.asc helm-v3.8.2-linux-amd64.tar.gz</p>
			<p class="source-code">gpg: assuming signed data in 'helm-v3.8.2-linux-amd64.tar.gz'</p>
			<p class="source-code">gpg: Signature made Wed Apr 13 14:00:32 2022 EDT</p>
			<p class="source-code">gpg:                using RSA key 711F28D510E1E0BCBD5F6BFE9436E80BFBA46909</p>
			<p class="source-code">gpg: Good signature from "Matthew Farina &lt;matt@mattfarina.com&gt;" [full]</p>
			<p>Digital signatures also play a role in signing and verifying Helm charts. We will explore this topic in the next section.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor276"/>Signing and verifying Helm charts</h2>
			<p>Similar to <a id="_idIndexMarker666"/>how the Helm maintainers sign releases, you can sign your Helm charts so that users can verify its origin as well as confirm it contains the expected content. To sign a chart, you must have a GPG key pair present on your local workstation (we created a GPG key pair earlier in the <em class="italic">Creating a GPG key pair</em> section).</p>
			<p>There is <a id="_idIndexMarker667"/>one important caveat to note before we start signing charts. If you are using GPG version 2 or greater, you must export your public and secret keyrings to a legacy format. Early versions of GPG stored keyrings in the <strong class="source-inline">.gpg</strong> file format, which is the format that Helm expects your keyring to be in (at the time of writing). Newer versions of GPG store keyrings in the <strong class="source-inline">.kbx</strong> file format, which is not compatible at the time of writing.</p>
			<p>Luckily, we can export our keys in the <strong class="source-inline">.gpg</strong> format by following these steps:</p>
			<ol>
				<li value="1">First, find your GPG version by running the following command:<p class="source-code"><strong class="bold">$ gpg --version</strong></p><p class="source-code"><strong class="bold">gpg (GnuPG) 2.3.6</strong></p><p class="source-code"><strong class="bold">libgcrypt 1.10.1</strong></p><p class="source-code"><strong class="bold">Copyright (C) 2021 Free Software Foundation, Inc.</strong></p></li>
				<li>If your GPG version is 2 or greater, export your public and secret keyrings using the <strong class="source-inline">gpg --export</strong> and <strong class="source-inline">gpg --export-secret-keys</strong> commands:<p class="source-code"><strong class="bold">$ gpg --export &gt; ~/.gnupg/pubring.gpg</strong></p><p class="source-code"><strong class="bold">$ gpg --export-secret-keys &gt; ~/.gnupg/secring.gpg</strong></p></li>
			</ol>
			<p>Once your keyrings have been exported, you will be able to sign your charts using the <strong class="source-inline">helm package</strong> command. The <strong class="source-inline">helm package</strong> command provides three key flags that allow you to sign and package charts:</p>
			<ul>
				<li><strong class="source-inline">--sign</strong>: This allows you to sign a chart using a PGP private key.</li>
				<li><strong class="source-inline">--key</strong>: The name of the key to use when signing.</li>
				<li><strong class="source-inline">--keyring</strong>: The location of the keyring containing the PGP private key.</li>
			</ul>
			<p>Let’s run the <strong class="source-inline">helm package</strong> command to sign the guestbook Helm chart from the Packt repository:</p>
			<p class="source-code">$ helm package --sign --key &lt;key_name&gt; --keyring ~/.gnupg/secring.gpg helm-charts/charts/guestbook</p>
			<p>The <strong class="source-inline">&lt;key_name&gt;</strong> placeholder refers to either the email, name, or fingerprint associated with the desired key. These<a id="_idIndexMarker668"/> details can be found by using the <strong class="source-inline">gpg --list-keys</strong> command.</p>
			<p>If the <strong class="source-inline">helm package</strong> command is successful, you will see the following files displayed in the current directory:</p>
			<pre class="source-code">
guestbook-0.1.0.tgz
guestbook-0.1.0.tgz.prov</pre>
			<p>The <strong class="source-inline">guestbook-0.1.0.tgz</strong> file is the archive that contains the Helm chart. This file is always created by <strong class="source-inline">helm package</strong>, whether you are signing the chart or not.</p>
			<p>The <strong class="source-inline">guestbook-0.1.0.tgz.prov</strong> file is <a id="_idIndexMarker669"/>called a <strong class="bold">provenance file</strong>. The provenance file contains a provenance record, which contains the following:</p>
			<ul>
				<li>The chart metadata from the file</li>
				<li>The sha256 hash of the <strong class="source-inline">guestbook-0.1.0.tgz</strong> file</li>
				<li>The PGP digital signature</li>
			</ul>
			<p>Helm chart<a id="_idIndexMarker670"/> consumers leverage provenance files to verify the data provenance and integrity of the chart that they have downloaded. So, chart developers should be sure to publish both the <strong class="source-inline">.tgz</strong> archive as well as the <strong class="source-inline">.tgz.prov</strong> provenance file to their Helm chart repository.</p>
			<p>While you have successfully signed the guestbook chart and have created the <strong class="source-inline">.tgz.prov</strong> file, it is not quite enough for users to verify the chart, as they still need to access your public key to decrypt your signature. You can make this key available for users by publishing it to the PGP key servers with the <strong class="source-inline">gpg --send-key</strong> command:</p>
			<p class="source-code">$ gpg --send-key &lt;key_name&gt;</p>
			<p>End users can then download and import this key by using the <strong class="source-inline">gpg --recv-key</strong> command:</p>
			<p class="source-code">$ gpg --recv-key &lt;key_name&gt;</p>
			<p>Once a user has<a id="_idIndexMarker671"/> imported your public key (and exported it to the <strong class="source-inline">~/.gnupg/pubring.gpg</strong> keyring, as shown earlier in this section), they can verify your Helm chart by using the <strong class="source-inline">helm verify</strong> command, provided both the <strong class="source-inline">.tgz</strong> chart archive and <strong class="source-inline">.tgz.prov</strong> provenance file have been downloaded to the same directory:</p>
			<p class="source-code">$ helm verify --keyring ~/.gnupg/pubring.gpg guestbook-0.1.0.tgz</p>
			<p class="source-code">Signed by: John Doe &lt;jdoe@example.com&gt;</p>
			<p class="source-code">Using Key With Fingerprint: D2557B1EDD57BBC41A5D4DA7161DADB1C5AC21B5</p>
			<p class="source-code">Chart Hash Verified: sha256:c8089c7748bb0c8102894a8d70e641010b90abe9bb45962a 53468eacfbaf6731</p>
			<p>If verification<a id="_idIndexMarker672"/> is successful, you will see that the signer, the signer’s public key, and the chart have been verified. Otherwise, an error will be returned. The verification could fail for a variety of reasons, including the following:</p>
			<ul>
				<li>The <strong class="source-inline">.tgz</strong> and <strong class="source-inline">.tgz.prov</strong> files are not in the same directory.</li>
				<li>The <strong class="source-inline">.tgz</strong> or <strong class="source-inline">.tgz.prov</strong> files are corrupt.</li>
				<li>The file hashes do not match, indicating a loss of integrity.</li>
				<li>The public key used to decrypt the signature does not match the private key originally used to encrypt it.</li>
			</ul>
			<p>The <strong class="source-inline">helm verify</strong> command is designed to be run on locally downloaded charts, so users may find it better to leverage the <strong class="source-inline">helm install --verify</strong> command instead, which performs the verification and installation in a single command, assuming that the <strong class="source-inline">.tgz</strong> and .<strong class="source-inline">tgz.prov</strong> files can both be downloaded from a chart repository.</p>
			<p>The following command describes how the <strong class="source-inline">helm install --verify</strong> command can be used:</p>
			<p class="source-code">$ helm install guestbook &lt;chart_repo&gt;/guestbook --verify --keyring ~/.gnupg/pubring.gpg</p>
			<p>By using the methodologies described in this section, chart developers and consumers can be assured that the content is sourced from a trusted origin and has been unaltered.</p>
			<p>With an understanding of how data provenance and integrity play a role in Helm, let’s continue discussing Helm security considerations by moving on to our next topic – security concerning Helm charts and Helm chart development.</p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor277"/>Developing secure and stable Helm charts</h1>
			<p>While <a id="_idIndexMarker673"/>provenance and integrity play a major role in the security of Helm, they are not the only concerns you need to consider. During the development<a id="_idIndexMarker674"/> process, chart developers should ensure that they are adhering to best practices around security to prevent vulnerabilities from being introduced when a user installs their chart into a Kubernetes cluster. In this section, we will discuss many of the concerns surrounding security as it relates to Helm chart development and what you, as a developer, can do to write Helm charts with security as a priority. </p>
			<p>We will begin by discussing the security around any container images that your Helm chart may reference.</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor278"/>Using secure images</h2>
			<p>Since<a id="_idIndexMarker675"/> the goal of Helm (and Kubernetes) is to deploy container images, the image itself presents several areas of consideration concerning security. To start, chart developers should be aware of the differences between image tags and image digests.</p>
			<p>A tag is a human-readable reference to a given image and provides both developers and consumers with an easy way to reference an image. However, tags can present a security concern as there are no guarantees that the contents of a given tag will always remain the same. The image owner may choose to push an updated image using the same tag, which would result in a different underlying image being executed at runtime (even though the tag is the same). Performing these actions against the same tag introduces the possibility of regressions, which can cause unexpected adverse effects for end users. Instead of referencing an image by tag, images can also be referenced by digest. An image digest is a computed <strong class="source-inline">SHA-256</strong> value of an image that not only provides an immutable identifier to an exact image but also allows for the container runtime to verify the integrity of the image that is retrieved from a remote registry. This removes the risk of deploying an image that contains an accidental regression against a given tag and can also remove the risks of a man-in-the-middle attack, where the tag’s contents are modified with malicious intent.</p>
			<p>As an<a id="_idIndexMarker676"/> example, an image referenced as <strong class="source-inline">quay.io/bitnami/redis:5.0.9</strong> in a chart template can be referenced by a digest as <strong class="source-inline">quay.io/bitnami/redis@sha256:70b816f2127afb5d4af7ec9d6e8636b2f0f973a3cd8dda7032f9dcffa38ba11f</strong>. Notice that instead of specifying the name of a tag after the name of the image, the <strong class="source-inline">SHA-256</strong> digest is explicitly specified. This assures that the image content will not change over time, even if the tag changes, thus strengthening your security posture.</p>
			<p>As time progresses, a tag or a digest may become unsafe for deployment, as vulnerabilities may eventually be found in the underlying packages or base components. There are many different ways to determine whether there are any vulnerabilities associated with a given image. One way is to leverage the native capabilities of the registry that the image belongs to. Many different image registry solutions contain capabilities around image vulnerability scanning that can help provide insight as to when an image is vulnerable.</p>
			<p>The Quay container registry, for example, can automatically scan images at specified intervals to determine vulnerabilities that may be present within a given image. The Nexus and Artifactory container registries are also examples of container registries that have similar capabilities. Outside of native scanning capabilities provided by container registries, other tools can be <a id="_idIndexMarker677"/>leveraged, such as <strong class="bold">Vuls</strong> and <strong class="bold">OpenSCAP</strong>. When your <a id="_idIndexMarker678"/>image registry or standalone scanning tool reports that an image is vulnerable, you should immediately update your chart’s image to a newer version, if available, to prevent vulnerabilities from being introduced to your users’ Kubernetes clusters. </p>
			<p>To help simplify the process of updating the container image, you can develop a regular cadence where image updates are checked. This helps prevent you from getting to a point where your target image contains vulnerabilities that make it unfit for deployment. Many teams and organizations also restrict the source of images to trusted registries to reduce the potential of running images that do contain vulnerabilities. This setting can be configured at the container runtime level or within policies applied to a Kubernetes cluster. The specific location and configurations vary based on the specific implementation(s).</p>
			<p>Apart from image vulnerability scanning and content sourcing, you should also avoid deploying images that run as <strong class="bold">root</strong> or <strong class="bold">privileged</strong>. Running containers as the root user (UID 0) is dangerous, as the process would also have root access to the underlying host if it can break out of the container. Your application likely does not need the level of permission that root provides, so you should run the container as a non-root user instead to limit its available permissions.</p>
			<p>While<a id="_idIndexMarker679"/> running a container as root is dangerous, due to the process isolation that containers provide, it does not quite grant all available Linux capabilities by default. As a result, some users, often mistakenly, will further escalate permissions by running containers as privileged. Running a container as privileged grants all capabilities to the container, allowing it to interact with the underlying host from within the container. If your application does require additional capabilities, rather than running the container as privileged, you can instead select the exact list of capabilities in <strong class="source-inline">securityContext</strong> of a pod that is desired. A list of capabilities can <a id="_idIndexMarker680"/>be found in the <em class="italic">CAPABILITIES(7)</em> page of the Linux manual pages (<a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">http://man7.org/linux/man-pages/man7/capabilities.7.html</a>).</p>
			<p>In addition to the container image that has been deployed, chart developers should focus on the resources that have been granted to an application to ensure the integrity of the Kubernetes cluster. We will dive into this topic in the next section.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor279"/>Setting resource requests and limits</h2>
			<p>Pods consume<a id="_idIndexMarker681"/> resources from the host (node) that it is running within. Resources are defined in terms of <strong class="bold">requests</strong> (the minimum amount of resources to allocate) and <strong class="bold">limits</strong> (the maximum amount of resources the pod is allowed to use). Pods that <a id="_idIndexMarker682"/>do not define requests run the risk of being scheduled on nodes that cannot support their minimum resource requirements. Pods that do not define limits run the risk of exhausting a node’s resources, resulting in pod eviction and resource contention with other workloads. Because of the issues that can occur when resource requests and limits are not set, chart developers should ensure that their charts define these resource constraints while allowing users to override them with Helm values as needed.</p>
			<p>For example, as a chart developer, you may write your chart so that it includes the following default values for configuring resources:</p>
			<pre class="source-code">
resources:
  limits:
    cpu: "1"
    memory: 4Gi
  requests:
    cpu: 500m
    memory: 2Gi</pre>
			<p>Then, if the chart is installed without explicitly setting the application’s resource requirements, the defaults would be applied to avoid under- or over-utilizing cluster resources.</p>
			<p>Apart from<a id="_idIndexMarker683"/> resource requests and limits, a Kubernetes administrator can also create <strong class="source-inline">LimitRange</strong> and <strong class="source-inline">ResourceQuota</strong> objects to restrict the number of resources requested and consumed by applications within namespaces. The <strong class="source-inline">LimitRange</strong> and <strong class="source-inline">ResourceQuota</strong> objects are applied separately from Helm, usually as part of a namespace provisioning process. </p>
			<p><strong class="source-inline">LimitRanges</strong> are <a id="_idIndexMarker684"/>used to restrict the number of resources a container or pod is allowed to consume within a given namespace. They are also used to set the default resources for containers that don’t already have resource limits defined. The following is an example of a <strong class="source-inline">LimitRange</strong> definition:</p>
			<pre class="source-code">
apiVersion: v1
kind: LimitRange
metadata:
  name: limits-per-container
spec:
  limits:
    - max:
        cpu: 4
        memory: 16Gi
      default:
        cpu: 500m
        memory: 2Gi
      defaultRequest:
        cpu: 50m
        memory: 128Mi
      type: Container</pre>
			<p>In the <a id="_idIndexMarker685"/>example, <strong class="source-inline">LimitRange</strong> sets the maximum amount of allowed container resources to 4 CPU cores and 16 Gi of memory. For <a id="_idIndexMarker686"/>containers whose resource limits are undefined, a limit of 500 millicores of CPU and 2 Gi of memory will automatically be applied. For containers whose resource requests are undefined, a request of 50 millicores of CPU and 128 Mi of memory will automatically be applied. <strong class="source-inline">LimitRanges</strong> can also be applied at the pod level by setting the <strong class="source-inline">type</strong> field to <strong class="source-inline">Pod</strong>. This setting ensures that the sum of resource utilization of all containers in the pod satisfies the specified limits.</p>
			<p>In addition to setting limits against CPU and memory utilization, you can configure <strong class="source-inline">LimitRange</strong> to restrict storage consumption by setting the <strong class="source-inline">type</strong> field to <strong class="source-inline">PersistentVolumeClaim</strong>. The following is a <strong class="source-inline">LimitRange</strong> example used to restrict storage claims to 8 Gi or fewer:</p>
			<pre class="source-code">
apiVersion: v1
kind: LimitRange
metadata:
  name: limits-per-pvc
spec:
  - max:
      storage: 8Gi
    type: PersistentVolumeClaim</pre>
			<p>While <strong class="source-inline">LimitRange</strong> objects are used to restrict resources at the <strong class="source-inline">Container</strong>, <strong class="source-inline">Pod</strong>, or <strong class="source-inline">PersistentVolumeClaim</strong> level, <strong class="source-inline">ResourceQuotas</strong> are used by cluster administrators to restrict resource utilization at the namespace level. They are used to define the maximum number of resources a namespace can utilize in addition to limiting the amount <a id="_idIndexMarker687"/>of Kubernetes objects that can be <a id="_idIndexMarker688"/>created, such as Secrets and ConfigMaps. The following is an example <strong class="source-inline">ResourceQuota</strong> definition:</p>
			<pre class="source-code">
apiVersion: v1
kind: ResourceQuota
metadata:
  name: pod-and-pvc-quota
spec:
  hard:
    limits.cpu: "32"
    limits.memory: 64Gi
    requests.cpu: "24"
    requests.memory: 48Gi
    requests.storage: 20Gi</pre>
			<p>This <strong class="source-inline">ResourceQuota</strong> would ensure that the sum of all CPU and memory requests and limits remain under the defined amounts. It also sets a limit on the storage for <strong class="source-inline">PersistentVolumeClaims</strong> that can be requested within the namespace.</p>
			<p>By setting reasonable defaults for resource constraints in your Helm charts, along with the usage of <strong class="source-inline">LimitRange</strong> and <strong class="source-inline">ResourceQuotas</strong>, you can ensure that users of your Helm charts do not exhaust cluster resources. You can also help ensure that applications request the minimum amount of resources necessary for a proper operation.</p>
			<p>With an understanding of resource requests and limits, let’s move on to the next topic – handling secrets in Helm charts.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor280"/>Handling secrets in Helm charts</h2>
			<p>Handling secrets is <a id="_idIndexMarker689"/>a common concern when working with Helm charts. Consider the WordPress application from <a href="B17979_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>, <em class="italic">Installing Your First App with Helm</em>, where you were required to provide a password to configure an admin user. This password was not provided by default in the <strong class="source-inline">values.yaml</strong> file because this would have left the application vulnerable if you forgot to override the <strong class="source-inline">password</strong> value. Chart developers should be in the habit of not providing defaults for secret values, such as passwords, and should instead require users to provide an explicit value. This can easily be accomplished by leveraging the <strong class="source-inline">required</strong> function. Helm can also generate random strings using the <strong class="source-inline">randAlphaNum</strong> function.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Note that the <strong class="source-inline">randAlphaNum</strong> function generates a new random string each time the chart is upgraded. For that reason, developers should design charts with the expectation that users will provide their own password or another secret key, with the <strong class="source-inline">required</strong> function serving as a gate to ensure that a value is provided.</p>
			<p>When using native Kubernetes resources to store secret information, chart developers should ensure that these sensitive assets are saved in a Kubernetes Secret, not a ConfigMap. Secrets and ConfigMaps are similar, but Secrets are reserved for sensitive data. Because secret and non-secret data is stored in separate objects, cluster administrators can set RBAC policies accordingly to restrict access to secret data while allowing permission to data that is non-secret (RBAC will be described further later in the <em class="italic">Configuring RBAC rules</em> section).</p>
			<p>Chart users should ensure that secret values such as credentials are provided securely. Values are most commonly provided using the <strong class="source-inline">--values</strong> flag, in which properties are configured within <strong class="source-inline">values</strong> files. This is an appropriate method when working with non-secret values, but you should use caution when using this approach with secrets. Users should be sure that <strong class="source-inline">values</strong> files that contain secrets are not checked into a Git repository or an otherwise public location where those secrets could be exposed. One way that users can avoid exposing secrets is by leveraging the <strong class="source-inline">--set</strong> flag to pass secrets inline from the command line. This reduces the risk of credentials being exposed, but users should be aware that this could reveal the credentials in the bash history.</p>
			<p>Another way that users can avoid exposing secrets is by leveraging an encryption tool to encrypt <strong class="source-inline">values</strong> files that contain secrets. This approach would continue to allow users to apply the <strong class="source-inline">--values</strong> flag, along with enabling the <strong class="source-inline">values</strong> file to be stored in a remote location, such as a Git repository. Then, the <strong class="source-inline">values</strong> file can only be decrypted by users that have the appropriate decryption key and would remain encrypted for all other users, only allowing trusted entities to access the data. Users can simply leverage GPG to encrypt the <strong class="source-inline">values</strong> files, or<a id="_idIndexMarker690"/> they can leverage a purpose-built tool such as <strong class="bold">Secrets OPerationS</strong> (<strong class="bold">SOPS</strong>). SOPS (<a href="https://github.com/mozilla/sops">https://github.com/mozilla/sops</a>) is a<a id="_idIndexMarker691"/> tool designed to encrypt the values of YAML or JSON files, but leave the keys unencrypted. The <a id="_idIndexMarker692"/>following code depicts a secret key/value pair from a SOPS-encrypted file:</p>
			<pre class="source-code">
password: ENC[AES256_GCM,data:xhdUx7DVUG8bitGnqjGvPMygpw==,iv:3LR9KcttchCvZNpRKqE5L cXRyWD1I00v2kEAIl1ttco=,tag:9HEwxhT9s1pxo9lg19wyNg==,type:str]</pre>
			<p>Notice how the <strong class="source-inline">password</strong> key is unencrypted but the value is encrypted. This allows you to easily see the types of values contained within the file without exposing their sensitive values.</p>
			<p>There are other tools capable of encrypting <strong class="source-inline">values</strong> files that contain secrets. Some examples<a id="_idIndexMarker693"/> include <strong class="bold">git-crypt</strong> (<a href="https://github.com/AGWA/git-crypt">https://github.com/AGWA/git-crypt</a>) and <strong class="bold">blackbox</strong> (<a href="https://github.com/StackExchange/blackbox">https://github.com/StackExchange/blackbox</a>). Additionally, purpose-built secret management<a id="_idIndexMarker694"/> utilities, such <a id="_idIndexMarker695"/>as <strong class="bold">HashiCorp Vault</strong> or <strong class="bold">CyberArk Conjur</strong>, can<a id="_idIndexMarker696"/> be used to encrypt secrets in the form of key/value stores. Secrets can then be retrieved by authenticating against the secret management system and then be utilized within Helm by specifying their values with the <strong class="source-inline">--set</strong> flag.</p>
			<p>Now that you understand how security plays a role in Helm chart development, let’s discuss how <strong class="bold">Role-Based Access Control</strong> (<strong class="bold">RBAC</strong>) can be applied in Kubernetes to provide greater security to your users.</p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor281"/>Configuring RBAC rules</h1>
			<p>The ability <a id="_idIndexMarker697"/>of an authenticated user in Kubernetes to perform actions is governed by a set of RBAC policies. As introduced in <a href="B17979_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Preparing a Kubernetes and Helm Environment</em>, policies, known as roles, can be associated with users or service accounts, and Kubernetes includes several roles with any installation. RBAC has been enabled by default in Kubernetes since version <strong class="source-inline">1.6</strong>. When thinking about Kubernetes RBAC in the context of Helm usage, you need to consider two factors:</p>
			<ul>
				<li>The user installing the Helm chart</li>
				<li>The service account associated with the pod running the workload</li>
			</ul>
			<p>In most cases, the individual responsible for installing a Helm chart is associated with a Kubernetes user. However, Helm charts can be installed through other means, such as by a Kubernetes operator with an associated service account.</p>
			<p>By default, users and service accounts have minimal permissions in a Kubernetes cluster. Additional permissions are granted through the use of roles, which have been scoped to an individual namespace, or cluster roles, which grant access at a cluster level. These roles are then associated with a user or service account using either a role binding or a cluster role binding, depending on the type of policy being targeted. While Kubernetes has several<a id="_idIndexMarker698"/> included roles, the <strong class="bold">Principle of Least Privilege</strong> should be used wherever possible. The Principle of Least Privilege is a security concept that emphasizes that a user or application is granted only the minimum set of permissions that is needed to function. For example, imagine we wanted to add functionality to our application that allows for pod metadata to be queried. While Kubernetes contains a built-in role <a id="_idIndexMarker699"/>called <strong class="bold">view</strong> that provides the necessary permissions for reading pod manifests in a given namespace, it also grants access to other resources, such as ConfigMaps and Deployments. To minimize the level of access that is provided to an application, a custom policy, in the form of <strong class="source-inline">Role</strong> or <strong class="source-inline">ClusterRole</strong>, can be created that provides only the necessary permissions that the application needs. Since most typical users of a Kubernetes cluster do not have access to create resources at a cluster level, let’s create a role that is applied to the namespace that the Helm chart is deployed in. </p>
			<p>The <strong class="source-inline">kubectl create role</strong> command can be used to create a Kubernetes <strong class="source-inline">Role</strong>. Alternatively, the <strong class="source-inline">Role</strong> and <strong class="source-inline">RoleBinding</strong> resources could have been created using YAML definitions. A basic role contains two key elements:</p>
			<ul>
				<li>The type of action (verb) made against the Kubernetes API</li>
				<li>The list of Kubernetes resources to target</li>
			</ul>
			<p>As an<a id="_idIndexMarker700"/> example, to demonstrate how RBAC can be configured in Kubernetes, let’s configure a set of RBAC rules to allow an authenticated user to view Pods within a namespace:</p>
			<ol>
				<li value="1">First, be sure to start your minikube cluster and create a new namespace for this exercise:<p class="source-code"><strong class="bold">$ minikube start</strong></p><p class="source-code"><strong class="bold">$ kubectl create namespace chapter12</strong></p></li>
				<li>Next, use the <strong class="source-inline">kubectl</strong> CLI to create a new role called <strong class="source-inline">pod-viewer</strong>:<p class="source-code"><strong class="bold">$ kubectl create role pod-viewer --resource=pods --verb=get,list –n chapter12</strong></p></li>
			</ol>
			<p>With this new role created, it needs to be associated with a user or service account. Since we want to associate the role with an application running in Kubernetes, we will apply the role to a service account. To abide by the Principle of Least Privilege, it is recommended to create a unique service account for the application (otherwise, the default service account would be used). This is to ensure that no other workloads are deployed in the same namespace that would accidentally inherit the same permissions. </p>
			<ol>
				<li value="3">Create a new service account called <strong class="source-inline">example</strong> by running the following command:<p class="source-code"><strong class="bold">$ kubectl create sa example –n chapter12</strong></p></li>
				<li>Finally, create <strong class="source-inline">RoleBinding</strong> called <strong class="source-inline">pod-viewers</strong> and associate it with the <strong class="source-inline">example</strong> service account:<p class="source-code"><strong class="bold">$ kubectl create rolebinding pod-viewers --role=pod-viewer --serviceaccount=chapter12:example –n chapter12</strong></p></li>
			</ol>
			<p>With the <a id="_idIndexMarker701"/>role and role binding created, the <strong class="source-inline">example</strong> service account has the appropriate permissions to list and get pods. To verify this assumption, we can use the <strong class="source-inline">kubectl auth can-i</strong> command:</p>
			<p class="source-code">$ kubectl auth can-i list pods --as=system:serviceaccount:chapter12:example –n chapter12</p>
			<p class="source-code">yes</p>
			<p>The <strong class="source-inline">--as</strong> flag makes use of the user impersonation feature in Kubernetes to allow you to debug authorization policies.</p>
			<p>To confirm that the service account cannot access a resource it should not be able to, such as listing Deployments, you can run the following command:</p>
			<p class="source-code">$ kubectl auth can-i list deployments --as=system:serviceaccount:chapter12:example –n chapter12</p>
			<p class="source-code">no</p>
			<p>As you can see from the output of <strong class="source-inline">no</strong> for listing Deployments and <strong class="source-inline">yes</strong> for listing pods, the expected policies are in place. This service account can now be referenced by a Helm chart. Alternatively, a Helm chart could be written to create the <strong class="source-inline">ServiceAccount</strong>, <strong class="source-inline">Role</strong>, and <strong class="source-inline">RoleBinding</strong> resources natively, assuming that a user installing the chart has the appropriate privileges required.</p>
			<p>When used effectively, Kubernetes RBAC aids in providing Helm chart developers with the tools needed to enforce least-privilege access, protecting users and applications from potential errant or malicious actions.</p>
			<p>To clean up from this exercise, you can delete your namespace with <strong class="source-inline">kubectl delete ns chapter12</strong> and stop your minikube cluster with <strong class="source-inline">minikube stop</strong>.</p>
			<p>Next, let’s discuss how to access secure Helm chart repositories.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor282"/>Accessing secure chart repositories</h2>
			<p>Chart repositories <a id="_idIndexMarker702"/>allow you to discover Helm charts and install them on your Kubernetes cluster. Repositories were explored in <a href="B17979_08.xhtml#_idTextAnchor210"><em class="italic">Chapter 8</em></a>, <em class="italic">Publishing to a Helm Chart Repository</em>. There, you learned how to serve charts using an HTTP server (demonstrated using GitHub Pages) and an OCI registry (demonstrated using GitHub’s container registry, <strong class="source-inline">ghcr.io</strong>).</p>
			<p>Most chart repositories are readily available and open for those who are interested. However, chart repositories and hosting services do provide additional security measures for interacting with content stored within a repository, including the following:</p>
			<ul>
				<li>Authentication</li>
				<li><strong class="bold">Transport Layer Security</strong> (<strong class="bold">TLS</strong>)</li>
			</ul>
			<p>HTTP(S)-based chart repositories <a id="_idIndexMarker703"/>support basic and certificate-based authentication. For basic authentication, a username and password can be provided when adding a repository using the <strong class="source-inline">helm repo add</strong> command through the use of the <strong class="source-inline">--username</strong> and <strong class="source-inline">--password</strong> flags. For example, if you wanted to access a repository that is protected via basic authentication, adding the repository would take the following form:</p>
			<p class="source-code">$ helm repo add &lt;repo_name&gt; &lt;repo_url&gt; --username &lt;username&gt; --password &lt;password&gt;</p>
			<p>Under certain circumstances, you may also need to use the <strong class="source-inline">--pass-credentials</strong> flag in addition to <strong class="source-inline">--username</strong> and <strong class="source-inline">--password</strong>. Recall that an <strong class="source-inline">index.yaml</strong> file contains indexing of all Helm charts within the chart repository. Within the <strong class="source-inline">index.yaml</strong> file is a property field named <strong class="source-inline">urls</strong> that refers to the location of the associated Helm chart. Typically, the <strong class="source-inline">urls</strong> field contains relative paths within the chart repository, but in some cases, a location at an entirely different domain can be specified. Without the <strong class="source-inline">--pass-credentials</strong> flag, Helm will not forward your username and password along to these domains, which is a security feature implemented in Helm 3.6.1 to prevent your information from being exposed. However, if you do need to pass your credentials to another domain to authenticate against those endpoints, you can provide the <strong class="source-inline">--pass-credentials</strong> flag when using the <strong class="source-inline">helm repo add</strong> command.</p>
			<p>OCI registries also support basic authentication using the <strong class="source-inline">helm registry login</strong> command. The username is provided using the <strong class="source-inline">--username</strong> flag, but there are two ways to specify the password:</p>
			<ul>
				<li><strong class="source-inline">--password</strong>: Provides the password as an argument. This could reveal the password in plaintext in the bash history.</li>
				<li><strong class="source-inline">--password-stdin</strong>: Provides the password from <strong class="source-inline">stdin</strong>. This allows you to keep the password hidden from the bash history by redirecting it from <strong class="source-inline">stdin</strong>.</li>
			</ul>
			<p>It is recommended to use the <strong class="source-inline">--password-stdin</strong> flag to keep the password concealed from the bash history. As such, you can perform basic authentication against an OCI registry using the following command:</p>
			<p class="source-code">$ cat &lt;password_file&gt; | helm registry login &lt;registry_host&gt; --username &lt;username&gt; --password-stdin</p>
			<p>While <a id="_idIndexMarker704"/>basic authentication is most commonly used, certificate-based authentication is another way of verifying a client’s identity. Helm, at the time of writing, does not provide flags for OCI certificate-based authentication, but for traditional Helm repositories, the Helm <strong class="source-inline">repo add</strong> command provides the <strong class="source-inline">--cert-file</strong> and <strong class="source-inline">--key-file</strong> flags, which are used to specify your client certificate and key, respectively.</p>
			<p>Enabling basic authentication and certificate authentication on the chart repository itself depends on the repository implementation that is used. For example, <strong class="bold">ChartMuseum</strong>, a <a id="_idIndexMarker705"/>popular chart repository solution, provides the <strong class="source-inline">--basic-auth-user</strong> and <strong class="source-inline">--basic-auth-pass</strong> flags, which can be used on startup to configure the basic auth username and password. It also provides the <strong class="source-inline">--tls-ca-cert</strong> flag to <a id="_idIndexMarker706"/>configure the <strong class="bold">certificate authority</strong> (<strong class="bold">CA</strong>) certificate for certificate authentication. Other chart repository implementations may provide similar or additional capabilities.</p>
			<p>Even with authentication in place, the packets sent between your Helm client and your chart repository must be transmitted securely using TLS-based encryption. While this is a given for certificate-based authentication, which leverages TLS natively, repositories that use basic authentication can still benefit from encrypting network traffic. Configuring TLS on the chart repository depends on the repository implementation being used, but for ChartMuseum, the <strong class="source-inline">--tls-cert</strong> and <strong class="source-inline">--tls-key</strong> flags can be used to provide the certificate chain and key files. More general web servers, such as NGINX, typically require a configuration file that provides the location of the certificate and key files on the server. Offerings such as GitHub Pages already have TLS configured.</p>
			<p>Each of the Helm repositories that we have used so far has used certificates signed by publicly available CAs that are stored in your web browser and underlying operating system. As a result, we did not need to go out of our way to trust their certificates. Many large organizations, however, have their own CAs that are used to produce the certificate for the chart repository. Since this certificate is likely not from a publicly available CA, the Helm CLI may not trust the certificate, resulting in the following error:</p>
			<pre class="source-code">
Error: looks like "&lt;repo_url&gt;" is not a valid chart repository or cannot be reached: Get &lt;repo_url&gt;/index.yaml: x509: certificate signed by unknown authority</pre>
			<p>To allow <a id="_idIndexMarker707"/>the Helm CLI to trust the chart repository’s certificate, the CA certificate, or CA bundle containing the certificate chain, can be added to the operating system’s trust store. Alternatively, for HTTPS chart repositories, the <strong class="source-inline">--ca-file</strong> flag can be added to the <strong class="source-inline">helm repo add</strong> command. </p>
			<p>Finally, depending on how the chart repository is configured, additional metrics can be obtained to perform request-level auditing and logging to determine who has attempted to access the repository.</p>
			<p>Through the use of authentication and TLS, additional capabilities can be realized for enhancing the security footprint of Helm repositories.</p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor283"/>Summary</h1>
			<p>In this chapter, you learned about different topics around security that pertain to Helm usage. First, you learned how to prove the data provenance and integrity of Helm releases and Helm charts. Next, you learned about Helm chart security and how a chart developer can leverage security best practices to write a stable and secure Helm chart. Then, we focused on using RBAC to create an environment based on the Principle of Least Privilege, and we finished by talking about how chart repositories can be secured using authentication and TLS. Now, by employing each of these concepts, you are well equipped to create a secure Helm architecture and working environment.</p>
			<p>Thank you for reading <em class="italic">Managing Kubernetes Resources Using Helm</em>! We hope that this book helps you be confident and efficient as you use Helm to work within the Kubernetes ecosystem. </p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor284"/>Further reading</h1>
			<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li>To learn more about data provenance and integrity in the context of Helm charts, go to <a href="https://helm.sh/docs/topics/provenance/">https://helm.sh/docs/topics/provenance/</a>. </li>
				<li>To learn more about Kubernetes RBAC, check out the <em class="italic">Using RBAC Authorization</em> section from the Kubernetes documentation at <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">https://kubernetes.io/docs/reference/access-authn-authz/rbac/</a>. </li>
				<li>Check out the chart repository guide from the Helm documentation to learn more about chart repositories: <a href="https://helm.sh/docs/topics/chart_repository/">https://helm.sh/docs/topics/chart_repository/</a>.</li>
				<li>Finally, visit the <em class="italic">Registries</em> page from the Helm documentation to learn more about OCI support: <a href="https://helm.sh/docs/topics/registries/">https://helm.sh/docs/topics/registries/</a>.</li>
			</ul>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor285"/>Questions</h1>
			<p>Answer the following questions to test your knowledge of this chapter:</p>
			<ol>
				<li value="1">What are data provenance and integrity? How are data provenance and data integrity different?</li>
				<li>What commands can a user run to verify the data provenance and integrity of a Helm chart? Which files are required to make this process possible?</li>
				<li>What considerations need to be taken into account to use and maintain secure container images?</li>
				<li>Why is it important to leverage resource requests and limits in your Helm chart? What other Kubernetes resources can be used to configure requests and limits?</li>
				<li>What is the Principle of Least Privilege? Which Kubernetes resources allow you to configure authorization and achieve the least privilege?</li>
				<li>Which flags can you use to authenticate to an HTTP(S) repository?</li>
				<li>Which flags can you use to authenticate to an OCI registry?</li>
			</ol>
		</div>
		<div>
			<div id="_idContainer117">
			</div>
		</div>
	</body></html>