<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing for Continuous Integration and Delivery</h1>
                </header>
            
            <article>
                
<p>This chapter will show the reader how to integrate their build pipeline and deployments with a Kubernetes cluster. It will cover the concept of using gulp.js and Jenkins in conjunction with your Kubernetes cluster. We'll also use Helm and Minikube to show you another demo of how Continuous Integration and Delivery works with newer, more advanced methods.</p>
<p>The following topics will be<span> covered in the chapter:</span></p>
<ul>
<li>Integrating Kubernetes with a Continuous Deployment pipeline</li>
<li>Using gulp.js with Kubernetes</li>
<li>Integrating Jenkins with Kubernetes</li>
<li>Installing and using Helm and Jenkins</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You'll need to have your Google Cloud Platform account enabled and logged in, or you can use a local Minikube instance of Kubernetes. You can also use the Play with Kubernetes app, designed for use over the web, at <a href="https://labs.play-with-k8s.com/">https://labs.play-with-k8s.com/</a>.</p>
<p>Here's the GitHub repository for this chapter: <a href="https://github.com/PacktPublishing/Getting-Started-with-Kubernetes-third-edition/tree/master/Code-files/Chapter07">https://github.com/PacktPublishing/Getting-Started-with-Kubernetes-third-edition/tree/master/Code-files/Chapter07</a><a href="https://github.com/PacktPublishing/Getting-Started-with-Kubernetes-third-edition/tree/master/Code%20files/Chapter%2007">.</a></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Integrating Kubernetes with a continuous delivery pipeline</h1>
                </header>
            
            <article>
                
<p>Continuous integration and delivery are key components in modern development shops. <strong>Continuous Integration/Continuous Delivery</strong> (<strong>CI/CD</strong>) often easy to remove them after builds are run. In addition, if you already have a large portion of infrastructure available on your cluster, it can make sense to utilize the idle capacity for builds and testing.</p>
<p>In this article, we will explore two popular tools used in building and deploying software:</p>
<ul>
<li><strong>gulp.js</strong>: This is a simple task runner used to automate the build process using JavaScript and Node.js</li>
<li><strong>Jenkins</strong>: This is a fully-fledged continuous integration server</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">gulp.js</h1>
                </header>
            
            <article>
                
<p>gulp.js gives us the framework to do build as code. Similar to Infrastructure as code, this allows us to programmatically define our build process. We will walk through a short example to demonstrate how you can create a complete workflow, from a Docker image build through to the final Kubernetes service.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Prerequisites</h1>
                </header>
            
            <article>
                
<p>For this section of the article, you will need a Node.js environment installed and ready, including the <strong>node package manager</strong> (<strong>npm</strong>). If you do not already have these packages installed, you can find instructions for installing them at <a href="https://docs.npmjs.com/getting-started/installing-node"><span class="URLPACKT">https://docs.npmjs.com/getting-started/installing-node</span></a>.</p>
<p>You can check whether or not Node.js is installed correctly by using the <kbd>node -v</kbd> command.</p>
<p>You'll also need Docker CE and a Docker Hub account to push a new image. You can find instructions to install Docker CE at <a href="https://docs.docker.com/installation/"><span class="URLPACKT">https://docs.docker.com/installation/</span></a>. You can easily create a DockerHub account at <a href="https://hub.docker.com/"><span class="URLPACKT">https://hub.docker.com/</span></a>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>After you have your credentials, you can log in with the CLI using the <kbd>$ docker login</kbd> command.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">gulp.js build example</h1>
                </header>
            
            <article>
                
<p>Let's start by creating a project directory named <kbd>node-gulp</kbd>:</p>
<pre><strong>$ mkdir node-gulp</strong><br/><strong>$ cd node-gulp</strong></pre>
<p>Next, we will install the <kbd>gulp</kbd> package and then check whether it's ready by running the <kbd>npm</kbd> command with the version flag, as follows:</p>
<pre><strong>$ npm install -g gulp</strong></pre>
<p>You may need to open a new Terminal window to make sure that <kbd>gulp</kbd> is on your path. Also, make sure to navigate back to your <kbd>node-gulp</kbd> directory with the following command:</p>
<pre> <strong>$ gulp -v</strong></pre>
<p>Next, we will install <kbd>gulp</kbd> locally in our project folder, along with the <kbd>gulp-git</kbd> and <kbd>gulp-shell</kbd> plugins, as follows:</p>
<pre><strong>$ npm install --save-dev gulp</strong><br/><strong>$ npm install gulp-git -save</strong><br/><strong>$ npm install --save-dev gulp-shell</strong></pre>
<p>Finally, we need to create a Kubernetes controller and service definition file, as well as a <kbd>gulpfile.js</kbd> file, to run all of our tasks. Again, these files are available in the book file bundle, should you wish to copy them straight over instead. Refer to the following <kbd>node-gulp-controller.yaml</kbd> file:</p>
<pre>apiVersion: v1 <br/>kind: ReplicationController <br/>metadata: <br/>  name: node-gulp <br/>  labels: <br/>    name: node-gulp <br/>spec: <br/>  replicas: 1 <br/>  selector: <br/>    name: node-gulp <br/>  template: <br/>    metadata: <br/>      labels: <br/>        name: node-gulp <br/>    spec: <br/>      containers: <br/>      - name: node-gulp <br/>        image: &lt;your username&gt;/node-gulp:latest <br/>        imagePullPolicy: Always <br/>        ports: <br/>        - containerPort: 80 </pre>
<p>As you can see in the preceding code, we have a basic controller. You will need to replace <kbd>&lt;your username&gt;/node-gulp:latest</kbd> with your Docker Hub username. Save the following code as <kbd>node-gulp-service.yaml</kbd> file:</p>
<pre>apiVersion: v1 <br/>kind: Service <br/>metadata: <br/>  name: node-gulp <br/>  labels: <br/>    name: node-gulp <br/>spec: <br/>  type: LoadBalancer <br/>  ports: <br/>  - name: http <br/>    protocol: TCP <br/>    port: 80 <br/>  selector: <br/>    name: node-gulp </pre>
<p>Next, we have a simple service that selects the pods from our controller and creates an external load balancer for access, as earlier:</p>
<pre>var gulp = require('gulp'); <br/>var git = require('gulp-git'); <br/>var shell = require('gulp-shell'); <br/><br/>// Clone a remote repo <br/>gulp.task('clone', function(){ <br/>  return git.clone('https://github.com/jonbaierCTP/getting-started-with-kubernetes-se.git', function (err) { <br/>    if (err) throw err; <br/>  }); <br/><br/>}); <br/><br/>// Update codebase <br/>gulp.task('pull', function(){ <br/>  return git.pull('origin', 'master', {cwd: './getting-started-with-kubernetes-se'}, function (err) { <br/>    if (err) throw err; <br/>  }); <br/>}); <br/><br/>//Build Docker image <br/>gulp.task('docker-build', shell.task([ <br/>  'docker build -t &lt;your username&gt;/node-gulp ./getting-started-with-kubernetes-se/docker-image-source/container-info/', <br/>  'docker push &lt;your username&gt;/node-gulp' <br/>])); <br/><br/>//Run new pod <br/>gulp.task('create-kube-pod', shell.task([ <br/>  'kubectl create -f node-gulp-controller.yaml', <br/>  'kubectl create -f node-gulp-service.yaml' <br/>])); <br/><br/>//Update pod <br/>gulp.task('update-kube-pod', shell.task([ <br/>  'kubectl delete -f node-gulp-controller.yaml', <br/>  'kubectl create -f node-gulp-controller.yaml' <br/>])); </pre>
<p>Finally, we have the preceding <kbd>gulpfile.js</kbd> file. This is where all of our build tasks are defined. Again, fill in your own Docker Hub username in both of the <kbd>&lt;your username&gt;/node-gulp</kbd> sections.</p>
<p>Looking through the file, first, we can see that the clone task downloads our image source code from GitHub. The pull tasks execute a <kbd>git</kbd> pull on the cloned repository. Next, the <kbd>docker-build</kbd> command builds an image from the <kbd>container-info</kbd> sub folder and pushes it to Docker Hub. Finally, we have the <kbd>create-kube-pod</kbd> and <kbd>update-kube-pod</kbd> commands. As you can probably guess, the <kbd>create-kube-pod</kbd> command creates our controller and service for the first time, whereas the <kbd>update-kube-pod</kbd> command simply replaces the controller.</p>
<p>Let's go ahead and run these commands and see our end-to-end workflow:</p>
<pre><strong>$ gulp clone</strong><br/><strong>$ gulp docker-build</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The first time through, you can also run the <kbd>create-kube-pod</kbd> command, as follows:</p>
<pre><strong>$ gulp create-kube-pod</strong></pre>
<p>This is all there is to it. If we run a quick <kbd>kubectl</kbd> describe command for the <kbd>node-gulp</kbd> service, we can get the external IP for our new service. Browse to that IP and you'll see the familiar <kbd>container-info</kbd> application running. Note that the host starts with <kbd>node-gulp</kbd>, just as we named it in the previously mentioned pod definition:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="Images/63c5096a-7997-48a6-b331-3d4c10924fda.png" style="width:34.00em;height:10.33em;" width="640" height="195"/></div>
<p>On subsequent updates, run the <kbd>pull</kbd> and <kbd>update-kube-pod</kbd> commands, as shown here:</p>
<pre><strong>$ gulp pull</strong><br/><strong>$ gulp docker-build</strong><br/><strong>$ gulp update-kube-pod</strong></pre>
<p>This is a very simple example, but you can begin to see how easy it is to coordinate your build and deployment end to end with a few simple lines of code. Next, we will look at how to use Kubernetes to actually run builds using Jenkins.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Kubernetes plugin for Jenkins</h1>
                </header>
            
            <article>
                
<p>One way we can use Kubernetes for our CI/CD pipeline is to run our Jenkins build slaves in a containerized environment. Luckily, there is already a plugin, written by Carlos Sanchez, that allows you to run Jenkins slaves in Kubernetes' pods.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Prerequisites</h1>
                </header>
            
            <article>
                
<p>You'll need a Jenkins server handy for this next example. If you don't have one you can use, there is a Docker image available at <a href="https://hub.docker.com/_/jenkins/"><span class="URLPACKT">https://hub.docker.com/_/jenkins/</span></a>.</p>
<p>Running it from the Docker CLI is as simple as the following command:</p>
<pre><strong>docker run --name myjenkins -p 8080:8080 -v /var/jenkins_home jenkins</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing plugins</h1>
                </header>
            
            <article>
                
<p>Log in to your Jenkins server, and from your home dashboard, click on <span class="packt_screen">Manage Jenkins</span>. </p>
<div class="packt_tip">A note for those installing a new Jenkins server: when you first log in to the Jenkins server, it asks you to install plugins. Choose the default ones, or no plugins will be installed!</div>
<p><span>Then, on the <span class="packt_screen">Manage Jenkins</span> page, select </span><span class="packt_screen">Manage Plugins</span><span> from the list, as follows:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="Images/dfbe63c8-5fdd-492c-be72-213205d6e358.png" style="width:46.58em;height:27.50em;" width="640" height="377"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The main dashboard in Jenkins</div>
<p>The credentials plugin is required, but should be installed by default. We can check the <span class="packt_screen">Installed</span> tab if in doubt, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="Images/1c51766b-77d6-4705-b3c2-5a624cda4545.png" width="640" height="400"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Installed plugins in Jenkins</div>
<p>Next, let's click on the <span class="packt_screen">Available</span> tab. The Kubernetes plugin should be located under <span class="packt_screen">Cluster Management and Distributed Build</span> or <span class="packt_screen">Misc (cloud)</span>. There are many plugins, so you can alternatively search for <kbd>Kubernetes</kbd> on the page. Check the box for <span class="packt_screen">Kubernetes plugin</span> and click on <span class="packt_screen">Install without restart</span>. This will install the <span class="packt_screen">Kubernetes plugin</span> and the <span class="packt_screen">Durable Task Plugin</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/710037cf-a8ba-4264-b8cf-2a56a329cd8d.png" style="width:38.83em;height:54.17em;" width="612" height="854"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The plugin installation screen in Jenkins</div>
<p class="mce-root">If you wish to install a nonstandard version, or just like to tinker, you can optionally download the plugins. The latest Kubernetes and durable task plugins can be found here:</p>
<ul>
<li><strong>Kubernetes plugin</strong>: <span class="URLPACKT"><a href="https://wiki.jenkins-ci.org/display/JENKINS/Kubernetes+Plugin">https://wiki.jenkins-ci.org/display/JENKINS/Kubernetes+Plugin<br/></a></span></li>
<li><strong>Durable task plugin</strong>: <a href="https://wiki.jenkins-ci.org/display/JENKINS/Durable+Task+Plugin" target="_blank"><span class="URLPACKT">https://wiki.jenkins-ci.org/display/JENKINS/Durable+Task+Plugin<br/></span></a></li>
</ul>
<p><span>Next, we can click on the </span><span class="packt_screen">Advanced</span><span> tab and scroll down to </span><span class="packt_screen">Upload plugin</span><span>. Navigate to the </span><kbd>durable-task.hpi</kbd><span> file and click on </span><span class="packt_screen">Upload</span><span>. You should see a screen that shows an installation progress bar. After a minute or two, it will update to </span><span class="packt_screen">Success</span><span>.</span></p>
<p><span>Finally, install the main Kubernetes plugin. On the left-hand side, click on </span><span class="packt_screen">Manage Plugins</span><span> and then the </span><span class="packt_screen">Advanced</span><span> tab once again. This time, upload the </span><kbd>kubernetes.hpi</kbd><span> file and click on </span><span class="packt_screen">Upload</span><span>. After a few minutes, the installation should be complete.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring the Kubernetes plugin</h1>
                </header>
            
            <article>
                
<p class="CDPAlignLeft CDPAlign">Click on <span class="packt_screen">Back to Dashboard</span>, or the <span class="packt_screen">Jenkins</span> link in the top-left corner. Back on the main dashboard page, click on the <span class="packt_screen">Credentials</span> link. Choose a domain from the list; in my case, I just used the default global credentials domain. Click on <span class="packt_screen">Add Credentials</span>, and you'll be presented with the following screen:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/82c08ce3-3d4c-4398-97a6-592365826a04.png" style="width:41.58em;height:36.83em;" width="640" height="566"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The Add Credentials screen</div>
<p>Leave <span class="packt_screen">Kind</span> as <span class="packt_screen">Username with password</span> and <span class="packt_screen">Scope</span> as <span class="packt_screen">Global (Jenkins, nodes, items, all child items, etc)</span>. Add your Kubernetes admin credentials. Remember that you can find these by running the following <kbd>config</kbd> command:</p>
<pre><strong>$ kubectl config view</strong></pre>
<p>You can leave <span class="packt_screen">ID</span> blank, fill in <span class="packt_screen">Description</span> with something sensible, and then click on the <span class="packt_screen">OK</span> button.</p>
<p>Now that we have our credentials saved, we can add our Kubernetes server. Click on the <span class="packt_screen">Jenkins</span> link in the top-left corner, and then <span class="packt_screen">Manage Jenkins</span>. From there, select <span class="packt_screen">Configure System</span> and scroll all the way down to the <span class="packt_screen">Cloud</span> section. Select <span class="packt_screen">Kubernetes</span> from the <span class="packt_screen">Add a new cloud</span> drop-down menu and a <span class="packt_screen">Kubernetes</span> section will appear, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="Images/20a307c9-610e-4337-a4e1-690cb9512c13.png" style="width:32.50em;height:45.83em;" width="608" height="857"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The new Kubernetes cloud settings page in Jenkins</div>
<p>You'll need to specify the URL for your master in the form of <kbd>https://&lt;Master IP&gt;/</kbd>.</p>
<p>Next, choose the credentials we added from the drop-down menu. Since Kubernetes uses a self-signed certificate by default, you'll also need to check the <span class="packt_screen">Disable https certificate check</span> checkbox.</p>
<p>Click on <span class="packt_screen">Test Connection</span>, and if all goes well, you should see <span class="packt_screen">Connection</span> <span class="packt_screen">successful</span> appear next to the button.</p>
<div class="packt_tip">If you are using an older version of the plugin, you may not see the <span class="packt_screen">Disable https certificate check</span> checkbox. If this is the case, you will need to install the self-signed certificate directly on the Jenkins master.</div>
<p>Finally, we will add a pod template by choosing <span class="packt_screen">Kubernetes Pod Template</span> from the <span class="packt_screen">Add Pod Template</span> drop-down menu next to <span class="packt_screen">Images</span>.</p>
<p>This will create another new section. Use <kbd>jenkins-slave</kbd> for the <span class="packt_screen">Name</span> and <span class="packt_screen">Labels</span> section. Click on <span class="packt_screen">Add</span> next to <span class="packt_screen">Containers</span> and again use <kbd>jenkins-slave</kbd> <span>for the</span> <span class="packt_screen">Name. </span>Use <kbd>csanchez/jenkins-slave</kbd> for the <span class="packt_screen">Docker Image</span> and leave <kbd>/home/jenkins</kbd> for the <span class="packt_screen">Working Directory</span>.</p>
<p>Labels can be used later on in the build settings to force the build to use the Kubernetes cluster:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="Images/e9bdf8b9-1c38-4c1c-96d1-1fbf00b9086d.png" style="width:38.33em;height:19.83em;" width="637" height="330"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Kubernetes cluster addition</div>
<p>Here is the pod template that expands the cluster addition, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/ac2a8088-3248-40f0-baad-b8c12475965a.png" style="width:47.00em;height:46.00em;" width="676" height="662"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref"><span><span>The Kubernetes pod template</span></span></div>
<p>Click on <span class="packt_screen">Save</span> and you are all set. Now, new builds created in Jenkins can use the slaves in the Kubernetes pod we just created.</p>
<div class="packt_infobox">Here is another note about firewalls. The Jenkins master will need to be reachable by all the machines in your Kubernetes cluster, as the pod could land anywhere. You can find out your port settings in Jenkins under <span class="packt_screen">Manage Jenkins</span> | <span class="packt_screen">Configure Global Security</span>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Helm and Minikube</h1>
                </header>
            
            <article>
                
<p>Let's try setting up some CI/CD with other tools, so we can experiment with the newest offerings in the Kubernetes ecosystem. First, let's explore how easy it is to install Jenkins with Helm.</p>
<p>First, open the Minikube dashboard so you can see what happens when we install various things. Do this with the following command:</p>
<pre><strong>$ minikube dashboard</strong></pre>
<p>Let's create a namespace for the Jenkins environment, as follows:</p>
<pre><strong>$ kubectl get namespaces</strong><br/><strong>NAME          STATUS AGE</strong><br/><strong><span>default       Active 3d<br/></span><span>kube-public   Active 3d<br/></span></strong><span><strong>kube-system   Active 3d</strong><br/></span></pre>
<p><span>Now, let's create a template:</span></p>
<pre><strong>$ mkdir -p ~/gsw-k8s-helm &amp;&amp; cd ~/gsw-k8s-helm</strong><br/><strong><span>$ cat &lt;&lt;K8s &gt;&gt; namespace-jenkins.yaml<br/></span><span>apiVersion: v1<br/></span><span>kind: Namespace<br/></span><span>metadata:<br/></span><span> name: gsw-k8s-jenkins<br/></span><span>K8s</span></strong></pre>
<p>Now, you can create the namespace as follows:</p>
<pre><strong>kubectl create -f namespace-jenkins.yaml</strong><br/><strong>namespace "gsw-k8s-jenkins" created</strong></pre>
<p>There are two ways to verify that it was actually created. First, you can take a look at the dashboard with the <kbd>minikube dashboard</kbd> command:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/243b7f12-05ec-4768-b829-9181f998a437.png" width="1995" height="613"/></p>
<p>Secondly, you can look at the CLI with <kbd>kubectl get namespaces</kbd>:</p>
<pre><strong>$ helm-jenkins jesse$ kubectl get namespaces</strong><br/><strong><span>NAME              STATUS AGE<br/></span><span>default           Active 5d<br/></span><span>gsw-k8s-jenkins   Active 1d<br/></span><span>kube-public       Active 5d<br/></span><span>kube-system       Active 5d</span></strong></pre>
<p>Let's create a persistent volume for Jenkins to take advantage of. This will allow us to persist data in the cluster when Minikube reboots. In a production environment, you'd need to use some type of block or driver for your storage. Let's create a <kbd>jenkins-volume.yaml</kbd> file called <kbd>jenkins-persist</kbd>.</p>
<p>Here's what you'll put into that file:</p>
<pre>apiVersion: v1<br/>kind: PersistentVolume<br/><span>metadata:<br/></span><span> name: jenkins-persist<br/></span><span> namespace: jenkins-project<br/></span><span>spec:<br/></span><span> storageClassName: jenkins-persist<br/></span><span> accessModes:<br/></span><span>   - ReadWriteOnce<br/></span><span> capacity:<br/></span><span>   storage: 20Gi<br/></span><span> persistentVolumeReclaimPolicy: Retain<br/></span><span> hostPath:<br/></span><span>   path: /storage/jenkins-volume/</span></pre>
<p><span>Now, let's create the volume for Jenkins to use:</span></p>
<pre><strong>$ kubectl create -f jenkins-volume.yaml</strong><br/><strong>persistentvolume "jenkins-persist" created</strong></pre>
<p>Great! Now, we're ready to use Helm to install Jenkins nice and easily. Let's use the following values file with our installation:</p>
<pre># Default values for jenkins.<br/># This is a YAML-formatted file.<br/># Declare name/value pairs to be passed into your templates.<br/># name: value<br/>## Overrides for generated resource names<br/># See templates/_helpers.tpl<br/># nameOverride:<br/># fullnameOverride:<br/>Master:<br/> Name: jenkins-master<br/> Image: "jenkins/jenkins"<br/> ImageTag: "2.127"<br/> ImagePullPolicy: "Always"<br/> Component: "jenkins-master"<br/> UseSecurity: true<br/> AdminUser: admin<br/> # AdminPassword: &lt;defaults to random&gt;<br/> Cpu: "200m"<br/> Memory: "256Mi"<br/> ServicePort: 8080<br/> # For minikube, set this to NodePort, elsewhere use LoadBalancer # &lt;to set explicitly, choose port between 30000-32767&gt;<br/>ServiceType: NodePort<br/> NodePort: 32000<br/> ServiceAnnotations: {}<br/> ContainerPort: 8080<br/> # Enable Kubernetes Liveness and Readiness Probes<br/> HealthProbes: true<br/> HealthProbesTimeout: 60<br/> SlaveListenerPort: 50000<br/> LoadBalancerSourceRanges:<br/> - 0.0.0.0/0<br/> # List of plugins to be install during Jenkins master start<br/> InstallPlugins:<br/> - kubernetes:1.7.1<br/> - workflow-aggregator:2.5<br/> - workflow-job:2.21<br/> - credentials-binding:1.16<br/> - git:3.9.1<br/> - greenballs:1.15<br/> # Used to approve a list of groovy functions in pipelines used<br/>the script-security plugin. Can be viewed under /scriptApproval<br/> ScriptApproval:<br/> - "method groovy.json.JsonSlurperClassic parseText<br/>java.lang.String"<br/> - "new groovy.json.JsonSlurperClassic"<br/> - "staticMethod<br/>org.codehaus.groovy.runtime.DefaultGroovyMethods leftShift<br/>java.util.Map java.util.Map"<br/> - "staticMethod<br/>org.codehaus.groovy.runtime.DefaultGroovyMethods split<br/>java.lang.String"<br/> CustomConfigMap: false<br/> NodeSelector: {}<br/> Tolerations: {}<br/>Agent:<br/> Enabled: true<br/> Image: jenkins/jnlp-slave<br/> ImageTag: 3.10-1<br/> Component: "jenkins-slave"<br/> Privileged: false<br/> Cpu: "200m"<br/> Memory: "256Mi"<br/> # You may want to change this to true while testing a new image<br/> AlwaysPullImage: false<br/> # You can define the volumes that you want to mount for this<br/>container<br/> # Allowed types are: ConfigMap, EmptyDir, HostPath, Nfs, Pod,<br/>Secret<br/> volumes:<br/> - type: HostPath<br/> hostPath: /var/run/docker.sock<br/> mountPath: /var/run/docker.sock<br/> NodeSelector: {}<br/>Persistence:<br/> Enabled: true<br/> ## A manually managed Persistent Volume and Claim<br/> ## Requires Persistence.Enabled: true<br/> ## If defined, PVC must be created manually before volume will<br/>be bound<br/> # ExistingClaim:<br/> ## jenkins data Persistent Volume Storage Class<br/> StorageClass: jenkins-pv<br/> Annotations: {}<br/> AccessMode: ReadWriteOnce<br/> Size: 20Gi<br/> volumes:<br/> # - name: nothing<br/> # emptyDir: {}<br/> mounts:<br/> # - mountPath: /var/nothing<br/> # name: nothing<br/> # readOnly: true<br/>NetworkPolicy:<br/> # Enable creation of NetworkPolicy resources.<br/> Enabled: false<br/> # For Kubernetes v1.4, v1.5 and v1.6, use 'extensions/v1beta1'<br/> # For Kubernetes v1.7, use 'networking.k8s.io/v1'<br/> ApiVersion: networking.k8s.io/v1<br/>## Install Default RBAC roles and bindings<br/>rbac:<br/> install: true<br/> serviceAccountName: default<br/> # RBAC api version (currently either v1beta1 or v1alpha1)<br/> apiVersion: v1beta1<br/> # Cluster role reference<br/> roleRef: cluster-admin</pre>
<p>Now that we've set the values file, let's use it to deploy Jenkins:</p>
<pre><strong>helm install --name gsw-k8s-jenkins -f jenkins-vaules.yaml stable/jenkins --namespace gsw-k8s-jenkins</strong><br/><strong>NAME:   gsw-k8s-jenkins</strong><br/><strong>LAST DEPLOYED: Mon Jun 18 22:44:34 2018</strong><br/><strong>NAMESPACE: gsw-k8s-jenkins</strong><br/><strong>STATUS: DEPLOYED</strong><br/><strong>RESOURCES:</strong><br/><strong>…</strong></pre>
<p>We can get the randomly generated Jenkins secret by addressing the Kubernetes secret store API:</p>
<pre><strong>$ kubectl get secret --namespace gsw-k8s-jenkins gsw-k8s-jenkins -o jsonpath="{.data.jenkins-admin-password}" | base64 --decode; echo</strong><br/><strong>&lt;YOUR_PASSWORD_HERE&gt;</strong></pre>
<p>Verify that Jenkins has installed using the following commands:</p>
<pre><strong>$ helm ls</strong><br/><strong>NAME REVISION UPDATED STATUS CHART NAMESPACE</strong><br/><strong><span>gsw-k8s-jenkins 1 Mon Jun 18 22:44:34 2018 DEPLOYED jenkins-0.16.3 gsw-k8s-jenkins</span></strong></pre>
<p><span>Then, open up Jenkins' home page. </span>You should be able to visit the home page at <kbd>http://192.168.99.100:3200</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Bonus fun</h1>
                </header>
            
            <article>
                
<p><strong>fabric8</strong> bills itself as an integration platform. It includes a variety of logging, monitoring, and continuous delivery tools. It also has a nice console, an API registry, and a 3D game that lets you shoot at your pods. It's a very cool project, and it actually runs on Kubernetes. The website for the project can be found at <a href="http://fabric8.io/"><span class="URLPACKT">http://fabric8.io/</span></a>.</p>
<p>fabric8 can be set up easily on your Kubernetes cluster with just a single command, so refer to <a href="http://fabric8.io/guide/getStarted/gke.html"><span class="URLPACKT">http://fabric8.io/guide/getStarted/gke.html/</span></a> for more information.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We looked at two continuous integration tools that can be used with Kubernetes. We did a brief walk-through, examining how to deploy the gulp.js task on our cluster. We also looked at a new plugin used to integrate Jenkins build slaves into your Kubernetes cluster. You should now have a better sense of how Kubernetes can integrate with your own CI/CD pipeline.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li style="font-weight: 400">What type of software does gulp.js enable us to build?</li>
<li style="font-weight: 400">What is the name of the popular CI/CD system that we installed?</li>
<li style="font-weight: 400">What is an alternative method of installation for Jenkins?</li>
<li style="font-weight: 400">What type of volume is required to run Jenkins on Kubernetes?</li>
<li style="font-weight: 400">What is the other requirement for running Jenkins on Kubernetes?</li>
<li style="font-weight: 400">What kind of controller is used when deploying with gulp.js?</li>
<li style="font-weight: 400">What tool did we use to install gulp.js?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>If you'd like some additional information on the Node.js and gulp.js ecosystems, check out these titles:</p>
<ul>
<li><a href="https://www.packtpub.com/web-development/mastering-nodejs">https://www.packtpub.com/web-development/mastering-nodejs</a></li>
<li><a href="https://www.packtpub.com/web-development/learning-nodejs-development">https://www.packtpub.com/web-development/learning-nodejs-development</a></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"><span>If you'd like some additional guidance on how to use Jenkins, read the following:</span></p>
<ul>
<li><a href="https://www.packtpub.com/networking-and-servers/learning-continuous-integration-jenkins">https://www.packtpub.com/networking-and-servers/learning-continuous-integration-jenkins</a></li>
<li><a href="https://www.packtpub.com/application-development/mastering-jenkins">https://www.packtpub.com/application-development/mastering-jenkins</a></li>
<li><a href="https://www.packtpub.com/virtualization-and-cloud/hands-continuous-integration-and-automation-jenkins-video">https://www.packtpub.com/virtualization-and-cloud/hands-continuous-integration-and-automation-jenkins-video</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>