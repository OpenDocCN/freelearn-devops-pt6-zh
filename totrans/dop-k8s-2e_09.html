<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Continuous Delivery</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">At the beginning of this book, we started by containerizing our applications, orchestrating them with Kubernetes, persisting their data, and exposing our service to the outside world. </span><span class="koboSpan" id="kobo.2.2">Later, we gained more confidence in our services by setting up monitoring and logging, and we made them scale in and out in a fully automatic manner. </span><span class="koboSpan" id="kobo.2.3">We'd now like to set our service on course by delivering our latest features and improvements to our services continuously in Kubernetes. </span><span class="koboSpan" id="kobo.2.4">We'll learn about the following topics in this chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">Updating Kubernetes resources</span></li>
<li><span class="koboSpan" id="kobo.4.1">Setting up a delivery pipeline</span></li>
<li><span class="koboSpan" id="kobo.5.1">How to improve the deployment process</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Updating resources</span></h1>
                </header>
            
            <article>
                
<p><strong><span class="koboSpan" id="kobo.2.1">Continuous Delivery</span></strong><span class="koboSpan" id="kobo.3.1"> (</span><strong><span class="koboSpan" id="kobo.4.1">CD</span></strong><span class="koboSpan" id="kobo.5.1">), as we described in </span><a href="43698ec3-b595-4aa0-811a-111010763585.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.6.1">Chapter 1</span></span></a><span class="koboSpan" id="kobo.7.1">, </span><em><span class="koboSpan" id="kobo.8.1">Introduction to DevOps</span></em><span class="koboSpan" id="kobo.9.1">, is a set of operations including </span><strong><span class="koboSpan" id="kobo.10.1">Continuous Integration</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong><span class="koboSpan" id="kobo.12.1">CI</span></strong><span class="koboSpan" id="kobo.13.1">) and the ensuing deployment tasks. </span><span class="koboSpan" id="kobo.13.2">The CI flow is made up of elements such as version control systems, buildings, and different levels of validation, which aim to eliminate the effort to integrate every change in the main release line. </span><span class="koboSpan" id="kobo.13.3">Tools to implement functions are usually at the application layer, which might be independent to the underlying infrastructure. </span><span class="koboSpan" id="kobo.13.4">Even so, when it comes to the deployment part, understanding and dealing with infrastructure is still inevitable. </span><span class="koboSpan" id="kobo.13.5">Deployment tasks are tightly coupled with the platform our application is running on, no matter which practice, continuous delivery or continuous deployment, we're implementing. </span><span class="koboSpan" id="kobo.13.6">For instance, in an environment where the software runs on baremetal or virtual machines, we'd utilize configuration management tools, orchestrators, and scripts to deploy our software. </span><span class="koboSpan" id="kobo.13.7">However, if we're running our service on an application platform such as Heroku, or even in the serverless pattern, designing the deployment pipeline would be a totally different story. </span><span class="koboSpan" id="kobo.13.8">All in all, the goal of deployment tasks is about making sure our software works properly in the right places. </span><span class="koboSpan" id="kobo.13.9">In Kubernetes, it's about knowing how to correctly update resources, in particular pods.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Triggering updates</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In </span><span class="ChapterrefPACKT"><a href="a5cf080a-372a-406e-bb48-019af313c676.xhtml"><span class="koboSpan" id="kobo.3.1">Chapter 3</span></a><span class="koboSpan" id="kobo.4.1">,</span></span> <em><span class="koboSpan" id="kobo.5.1">Getting Started with Kubernetes</span></em><span class="koboSpan" id="kobo.6.1">, we discussed the rolling update mechanism of the pods in a deployment. </span><span class="koboSpan" id="kobo.6.2">Let's recap what happens after the update process is triggered:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">The deployment creates a new </span><kbd><span class="koboSpan" id="kobo.8.1">ReplicaSet</span></kbd><span class="koboSpan" id="kobo.9.1"> with </span><kbd><span class="koboSpan" id="kobo.10.1">0</span></kbd><span class="koboSpan" id="kobo.11.1"> pods, according to the updated manifest</span></li>
<li><span class="koboSpan" id="kobo.12.1">The new </span><kbd><span class="koboSpan" id="kobo.13.1">ReplicaSet</span></kbd><span class="koboSpan" id="kobo.14.1"> is scaled up gradually while the previous </span><kbd><span class="koboSpan" id="kobo.15.1">ReplicaSet</span></kbd><span class="koboSpan" id="kobo.16.1"> keeps shrinking</span></li>
<li><span class="koboSpan" id="kobo.17.1">The process ends after all of the old pods are replaced</span></li>
</ul>
<p><span class="koboSpan" id="kobo.18.1">This mechanism is implemented automatically by Kubernetes, meaning we don't have to supervise the updating process. </span><span class="koboSpan" id="kobo.18.2">To trigger it, all we need to do is inform Kubernetes that the pod specification of a deployment is updated; that is to say, we modify the manifest of a resource in Kubernetes. </span><span class="koboSpan" id="kobo.18.3">Suppose we have a deployment, </span><kbd><span class="koboSpan" id="kobo.19.1">my-app</span></kbd><span class="koboSpan" id="kobo.20.1"> (see </span><kbd><span class="koboSpan" id="kobo.21.1">ex-deployment.yml</span></kbd><span class="koboSpan" id="kobo.22.1"> under the example directory for this section), we can modify the manifest with the sub–commands of </span><kbd><span class="koboSpan" id="kobo.23.1">kubectl</span></kbd><span class="koboSpan" id="kobo.24.1"> as follows:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.25.1">kubectl patch</span></kbd><span class="koboSpan" id="kobo.26.1">: This patches a manifest of an object partially according to the input JSON parameter. </span><span class="koboSpan" id="kobo.26.2">If we'd like to update the image of </span><kbd><span class="koboSpan" id="kobo.27.1">my-app</span></kbd><span class="koboSpan" id="kobo.28.1"> from </span><kbd><span class="koboSpan" id="kobo.29.1">alpine:3.7</span></kbd><span class="koboSpan" id="kobo.30.1"> to </span><kbd><span class="koboSpan" id="kobo.31.1">alpine:3.8</span></kbd><span class="koboSpan" id="kobo.32.1">, it'd be as follows:</span></li>
</ul>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.33.1">$ kubectl patch deployment my-app -p '{"spec":{"template":{"spec":{"containers":[{"name":"app","image":"alpine:3.8"}]}}}}'</span></strong></pre>
<ul>
<li><kbd><span class="koboSpan" id="kobo.34.1">kubectl set</span></kbd><span class="koboSpan" id="kobo.35.1">: This makes changes to certain properties of an object. </span><span class="koboSpan" id="kobo.35.2">This is a shortcut to change some properties directly. </span><span class="koboSpan" id="kobo.35.3">The image of </span><kbd><span class="koboSpan" id="kobo.36.1">deployment</span></kbd><span class="koboSpan" id="kobo.37.1"> is one of the properties it supports:</span></li>
</ul>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.38.1">$ kubectl set image deployment my-app app=alpine:3.8</span></strong></pre>
<ul>
<li><kbd><span class="koboSpan" id="kobo.39.1">kubectl edit</span></kbd><span class="koboSpan" id="kobo.40.1">: This opens an editor and dumps the current manifest so that we can edit it interactively. </span><span class="koboSpan" id="kobo.40.2">The modified </span><span><span class="koboSpan" id="kobo.41.1">manifest</span></span><span class="koboSpan" id="kobo.42.1"> will take effect immediately after being saved. </span><span class="koboSpan" id="kobo.42.2">To change the default editor for this command, use the</span><span><span class="koboSpan" id="kobo.43.1"> </span></span><kbd><span class="koboSpan" id="kobo.44.1">EDITOR</span></kbd><span class="koboSpan" id="kobo.45.1"> environment variable. </span><span class="koboSpan" id="kobo.45.2">For example, </span><kbd><span class="koboSpan" id="kobo.46.1">EDITOR</span></kbd><span class="koboSpan" id="kobo.47.1">="</span><kbd><span class="koboSpan" id="kobo.48.1">code --wait</span></kbd><span class="koboSpan" id="kobo.49.1">" kubectl edit deployments my-app opens Visual Studio Code.</span></li>
</ul>
<ul>
<li><kbd><span class="koboSpan" id="kobo.50.1">kubectl replace</span></kbd><span class="koboSpan" id="kobo.51.1">: This replaces one manifest with another submitted template file. </span><span class="koboSpan" id="kobo.51.2">If a resource isn't created yet or contains properties that can't be changed, it yields errors. </span><span class="koboSpan" id="kobo.51.3">For instance, there are two resources in our example template, </span><kbd><span class="koboSpan" id="kobo.52.1">ex-deployment.yml</span></kbd><span class="koboSpan" id="kobo.53.1">, namely the deployment, </span><kbd><span class="koboSpan" id="kobo.54.1">my-app</span></kbd><span class="koboSpan" id="kobo.55.1">, and its </span><kbd><span class="koboSpan" id="kobo.56.1">Service</span></kbd><span class="koboSpan" id="kobo.57.1">, </span><kbd><span class="koboSpan" id="kobo.58.1">my-app-svc</span></kbd><span class="koboSpan" id="kobo.59.1">. </span><span class="koboSpan" id="kobo.59.2">Let's replace them with a new specification file:</span></li>
</ul>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.60.1">$ kubectl replace -f ex-deployment.yml</span><br/><span class="koboSpan" id="kobo.61.1">deployment.apps/my-app replaced</span><br/><span class="koboSpan" id="kobo.62.1">The Service "my-app-svc" is invalid: spec.clusterIP: Invalid value: "": field is immutable</span><br/><span class="koboSpan" id="kobo.63.1">$ echo $?</span><br/><span class="koboSpan" id="kobo.64.1">1</span></strong></pre>
<p style="padding-left: 60px"><span class="koboSpan" id="kobo.65.1">After they're replaced, we see that the error code is </span><kbd><span class="koboSpan" id="kobo.66.1">1</span></kbd><span class="koboSpan" id="kobo.67.1"> as expected, so we are updating </span><kbd><span class="koboSpan" id="kobo.68.1">deployment</span></kbd><span class="koboSpan" id="kobo.69.1"> rather than </span><kbd><span class="koboSpan" id="kobo.70.1">Service</span></kbd><span class="koboSpan" id="kobo.71.1">. </span><span class="koboSpan" id="kobo.71.2">This behavior is particularly important when composing automation scripts for the CI/CD flow.</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.72.1">kubectl apply</span></kbd><span class="koboSpan" id="kobo.73.1">: This applies the manifest file anyway. </span><span class="koboSpan" id="kobo.73.2">In other words, if a resource exists in Kubernetes, it'd be updated; otherwise, it'd be created. </span><span class="koboSpan" id="kobo.73.3">When </span><kbd><span class="koboSpan" id="kobo.74.1">kubectl apply</span></kbd><span class="koboSpan" id="kobo.75.1"> is used to create resources, it is roughly equal to </span><kbd><span class="koboSpan" id="kobo.76.1">kubectl create --save-config</span></kbd><span class="koboSpan" id="kobo.77.1"> in terms of functionality. </span><span class="koboSpan" id="kobo.77.2">The applied specification file would be saved to the annotation field, </span><kbd><span class="koboSpan" id="kobo.78.1">kubectl.kubernetes.io/last-applied- configuration</span></kbd><span class="koboSpan" id="kobo.79.1">, accordingly, and we can manipulate it with the sub-commands </span><kbd><span class="koboSpan" id="kobo.80.1">edit-last-applied</span></kbd><span class="koboSpan" id="kobo.81.1">, </span><kbd><span class="koboSpan" id="kobo.82.1">set-last-applied</span></kbd><span class="koboSpan" id="kobo.83.1">, and </span><kbd><span class="koboSpan" id="kobo.84.1">view-last-applied</span></kbd><span class="koboSpan" id="kobo.85.1">. </span><span class="koboSpan" id="kobo.85.2">For example, we can view the template we submitted previously with the following:</span></li>
</ul>
<pre style="padding-left: 90px"><strong><span class="koboSpan" id="kobo.86.1">$ kubectl apply -f ex-deployment.yml view-last-applied</span></strong></pre>
<p><span class="koboSpan" id="kobo.87.1">The saved manifest information will be </span><span><span class="koboSpan" id="kobo.88.1">exactly </span></span><span class="koboSpan" id="kobo.89.1">the same as what we've sent, unlike the information we retrieve via </span><kbd><span class="koboSpan" id="kobo.90.1">kubectl get &lt;resource&gt; -o &lt;yaml or json&gt;</span></kbd><span class="koboSpan" id="kobo.91.1">, which contains an object's live status, in addition to specifications.</span></p>
<p><span class="koboSpan" id="kobo.92.1">Although in this section we are only focusing on manipulating a deployment, the commands here also work for updating all other Kubernetes resources, such as </span><kbd><span class="koboSpan" id="kobo.93.1">service</span></kbd><span class="koboSpan" id="kobo.94.1"> and </span><kbd><span class="koboSpan" id="kobo.95.1">role</span></kbd><span class="koboSpan" id="kobo.96.1">.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.97.1">Depending on the </span><span><span class="koboSpan" id="kobo.98.1">convergence speed of</span></span><span class="koboSpan" id="kobo.99.1"> </span><kbd><span class="koboSpan" id="kobo.100.1">etcd</span></kbd><span class="koboSpan" id="kobo.101.1">, changes to </span><kbd><span class="koboSpan" id="kobo.102.1">ConfigMap</span></kbd><span class="koboSpan" id="kobo.103.1"> and </span><kbd><span class="koboSpan" id="kobo.104.1">secret</span></kbd><span class="koboSpan" id="kobo.105.1"> usually take a couple of seconds to propagate to pods.</span></div>
<p><span class="koboSpan" id="kobo.106.1">The recommended way to interact with a Kubernetes API server is by using </span><kbd><span class="koboSpan" id="kobo.107.1">kubectl</span></kbd><span class="koboSpan" id="kobo.108.1">. </span><span class="koboSpan" id="kobo.108.2">If you're in a confined environment or you want to implement your own operator controllers, there are also RESTful APIs for manipulating resources in Kubernetes. </span><span class="koboSpan" id="kobo.108.3">For instance, the </span><kbd><span class="koboSpan" id="kobo.109.1">kubectl patch</span></kbd><span class="koboSpan" id="kobo.110.1"> command we used before would look as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.111.1">$ curl -X PATCH -H 'Content-Type: application/strategic-merge-patch+json' --data '{"spec":{"template":{"spec":{"containers":[{"name":"app","image":"alpine:3.8"}]}}}}' 'https://$KUBEAPI/apis/apps/v1/namespaces/default/deployments/my-app'</span></strong></pre>
<p><span class="koboSpan" id="kobo.112.1">Here, the </span><kbd><span class="koboSpan" id="kobo.113.1">$KUBEAPI</span></kbd> <span><span class="koboSpan" id="kobo.114.1">variable </span></span><span class="koboSpan" id="kobo.115.1">is the endpoint of the API server. </span><span class="koboSpan" id="kobo.115.2">See the API reference material for more information: </span><a href="https://kubernetes.io/docs/reference/kubernetes-api/"><span class="koboSpan" id="kobo.116.1">https://kubernetes.io/docs/reference/kubernetes-api/</span></a><span class="koboSpan" id="kobo.117.1">.</span><a href="https://kubernetes.io/docs/api-reference/v1.7/" target="_blank"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Managing rollouts</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Once the rollout process is triggered, Kubernetes silently completes all tasks in the background. </span><span class="koboSpan" id="kobo.2.2">Let's try some hands-on experiments. </span><span class="koboSpan" id="kobo.2.3">Again, the rolling update process won't be triggered even if we've modified something with the commands mentioned earlier, unless the associated pod's specification is changed. </span><span class="koboSpan" id="kobo.2.4">The example we prepared is a simple script that will respond to any request with its hostname and the Alpine version it runs on. </span><span class="koboSpan" id="kobo.2.5">First, we create </span><kbd><span class="koboSpan" id="kobo.3.1">deployment</span></kbd><span class="koboSpan" id="kobo.4.1"> and check its response in another Terminal:</span></p>
<pre><strong><span class="koboSpan" id="kobo.5.1">$ kubectl apply -f ex-deployment.yml</span><br/><span class="koboSpan" id="kobo.6.1">deployment.apps/my-app created</span><br/><span class="koboSpan" id="kobo.7.1">service/my-app-svc created</span><br/><span class="koboSpan" id="kobo.8.1">$ kubectl proxy &amp;</span><br/><span class="koboSpan" id="kobo.9.1">[1] 48334</span><br/><span class="koboSpan" id="kobo.10.1">Starting to serve on 127.0.0.1:8001</span><br/><span class="koboSpan" id="kobo.11.1">## switch to another terminal, #2</span><br/><span class="koboSpan" id="kobo.12.1">$ while :; do curl http://localhost:8001/api/v1/namespaces/default/services/my-app-svc:80/proxy/; sleep 1; done</span><br/><span class="koboSpan" id="kobo.13.1">my-app-5fbdb69f94-5s44q-v-3.7.1 is running...</span><br/><span class="koboSpan" id="kobo.14.1">my-app-5fbdb69f94-g7k7t-v-3.7.1 is running...</span><br/><span class="koboSpan" id="kobo.15.1">...</span></strong></pre>
<p><span class="koboSpan" id="kobo.16.1">Now, we change its image to another version and see what the responses are:</span></p>
<pre><strong><span class="koboSpan" id="kobo.17.1">## go back to terminal#1</span><br/><span class="koboSpan" id="kobo.18.1">$ kubectl set image deployment.apps my-app app=alpine:3.8</span><br/><span class="koboSpan" id="kobo.19.1">deployment.apps/my-app image updated</span><br/><br/><span class="koboSpan" id="kobo.20.1">## switch to terminal#2</span><br/><span class="koboSpan" id="kobo.21.1">...</span><br/><span class="koboSpan" id="kobo.22.1">my-app-5fbdb69f94-7fz6p-v-3.7.1 is running...</span><br/><span class="koboSpan" id="kobo.23.1">my-app-6965c8f887-mbld5-v-3.8.1 is running...</span></strong><strong><br/></strong><strong><span class="koboSpan" id="kobo.24.1">...</span></strong></pre>
<p><span class="koboSpan" id="kobo.25.1">Messages from version 3.7 and 3.8 are interleaved until the updating process ends. </span><span class="koboSpan" id="kobo.25.2">In order to immediately determine the status of updating processes from Kubernetes, rather than polling the service endpoint, we can use </span><kbd><span class="koboSpan" id="kobo.26.1">kubectl rollout</span></kbd><span class="koboSpan" id="kobo.27.1"> to manage the rolling update process, including inspecting the progress of ongoing updates. </span><span class="koboSpan" id="kobo.27.2">Let's see the acting </span><kbd><span class="koboSpan" id="kobo.28.1">rollout</span></kbd><span class="koboSpan" id="kobo.29.1"> with the </span><span><kbd><span class="koboSpan" id="kobo.30.1">status</span></kbd><span class="koboSpan" id="kobo.31.1"> </span></span><span class="koboSpan" id="kobo.32.1">sub-command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.33.1">## if the previous rollout has finished,</span><br/><span class="koboSpan" id="kobo.34.1">## you can make some changes to my-app again:</span><br/><br/><span class="koboSpan" id="kobo.35.1">$ kubectl rollout status deployment my-app</span><br/><span class="koboSpan" id="kobo.36.1">Waiting for deployment "my-app" rollout to finish: 3 out of 5 new replicas have been updated...</span><br/><span class="koboSpan" id="kobo.37.1">...</span><br/><span class="koboSpan" id="kobo.38.1">Waiting for deployment "my-app" rollout to finish: 3 out of 5 new replicas have been updated...</span><br/><span class="koboSpan" id="kobo.39.1">Waiting for deployment "my-app" rollout to finish: 3 of 5 updated replicas are available...</span><br/><span class="koboSpan" id="kobo.40.1">Waiting for deployment "my-app" rollout to finish: 3 of 5 updated replicas are available...</span><br/><span class="koboSpan" id="kobo.41.1">Waiting for deployment "my-app" rollout to finish: 3 of 5 updated replicas are available...</span><br/><span class="koboSpan" id="kobo.42.1">deployment "my-app" successfully rolled out</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.43.1">At this moment, the output at </span><kbd><span class="koboSpan" id="kobo.44.1">terminal#2</span></kbd><span class="koboSpan" id="kobo.45.1"> should be from version 3.6. </span><span class="koboSpan" id="kobo.45.2">The </span><kbd><span class="koboSpan" id="kobo.46.1">history</span></kbd> <span><span class="koboSpan" id="kobo.47.1">sub-command </span></span><span class="koboSpan" id="kobo.48.1">allows us to review previous changes to </span><kbd><span class="koboSpan" id="kobo.49.1">deployment</span></kbd><span class="koboSpan" id="kobo.50.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.51.1">$ kubectl rollout history deployment.app my-app</span><br/><span class="koboSpan" id="kobo.52.1">deployment.apps/my-app</span><br/><span class="koboSpan" id="kobo.53.1">REVISION  CHANGE-CAUSE</span><br/><span class="koboSpan" id="kobo.54.1">1         &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.55.1">2         &lt;none&gt;</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.56.1">However, the </span><kbd><span class="koboSpan" id="kobo.57.1">CHANGE-CAUSE</span></kbd><span class="koboSpan" id="kobo.58.1"> field doesn't show any useful information that helps us to see the details of the revision. </span><span class="koboSpan" id="kobo.58.2">To profit from the rollout history feature, add a </span><kbd><span class="koboSpan" id="kobo.59.1">--record</span></kbd> <span><span class="koboSpan" id="kobo.60.1">flag </span></span><span class="koboSpan" id="kobo.61.1">after each command that leads to a change, such as </span><kbd><span class="koboSpan" id="kobo.62.1">apply</span></kbd><span class="koboSpan" id="kobo.63.1"> or </span><kbd><span class="koboSpan" id="kobo.64.1">patch</span></kbd><span class="koboSpan" id="kobo.65.1">. </span><kbd><span class="koboSpan" id="kobo.66.1">kubectl create</span></kbd><span class="koboSpan" id="kobo.67.1"> also supports the </span><kbd><span class="koboSpan" id="kobo.68.1">record</span></kbd><span class="koboSpan" id="kobo.69.1"> flag.</span></p>
<p><span class="koboSpan" id="kobo.70.1">Let's make some changes to the </span><kbd><span class="koboSpan" id="kobo.71.1">deployment</span></kbd><span class="koboSpan" id="kobo.72.1">, such as modifying the </span><kbd><span class="koboSpan" id="kobo.73.1">DEMO</span></kbd> <span><span class="koboSpan" id="kobo.74.1">environment variable </span></span><span class="koboSpan" id="kobo.75.1">on pods in </span><kbd><span class="koboSpan" id="kobo.76.1">my-app</span></kbd><span class="koboSpan" id="kobo.77.1">. </span><span class="koboSpan" id="kobo.77.2">As this causes a change in the pod's specification, </span><kbd><span class="koboSpan" id="kobo.78.1">rollout</span></kbd><span class="koboSpan" id="kobo.79.1"> will start right away. </span><span class="koboSpan" id="kobo.79.2">This sort of behavior allows us to trigger an update without building a new image. </span><span class="koboSpan" id="kobo.79.3">For simplicity, we use </span><kbd><span class="koboSpan" id="kobo.80.1">patch</span></kbd><span class="koboSpan" id="kobo.81.1"> to modify the variable:</span></p>
<pre><strong><span class="koboSpan" id="kobo.82.1">$ kubectl patch deployment.apps my-app -p '{"spec":{"template":{"spec":{"containers":[{"name":"app","env":[{"name":"DEMO","value":"1"}]}]}}}}' --record</span><br/><span class="koboSpan" id="kobo.83.1">deployment.apps/my-app patched</span><br/><span class="koboSpan" id="kobo.84.1">$ kubectl rollout history deployment.apps my-app</span><br/><span class="koboSpan" id="kobo.85.1">deployment.apps/my-app</span><br/><span class="koboSpan" id="kobo.86.1">REVISION  CHANGE-CAUSE</span><br/><span class="koboSpan" id="kobo.87.1">1         &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.88.1">2         &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.89.1">3         kubectl patch deployment.apps my-app --patch={"spec":{"template":{"spec":{"containers":[{"name":"app","env":[{"name":"DEMO","value":"1"}]}]}}}} --record=true</span><br/></strong></pre>
<p><kbd><span class="koboSpan" id="kobo.90.1">CHANGE-CAUSE</span></kbd><span class="koboSpan" id="kobo.91.1"> of </span><kbd><span class="koboSpan" id="kobo.92.1">REVISION 3</span></kbd><span class="koboSpan" id="kobo.93.1"> notes the committed command clearly. </span><span class="koboSpan" id="kobo.93.2">Only the command will be recorded, which means that any modification inside </span><kbd><span class="koboSpan" id="kobo.94.1">edit</span></kbd><span class="koboSpan" id="kobo.95.1">/</span><kbd><span class="koboSpan" id="kobo.96.1">apply</span></kbd><span class="koboSpan" id="kobo.97.1">/</span><kbd><span class="koboSpan" id="kobo.98.1">replace</span></kbd><span class="koboSpan" id="kobo.99.1"> won't be marked down explicitly. </span><span class="koboSpan" id="kobo.99.2">If we want to get the manifest of the former revisions, we could retrieve the saved configuration, as long as our changes are made with </span><kbd><span class="koboSpan" id="kobo.100.1">apply</span></kbd><span class="koboSpan" id="kobo.101.1">.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.102.1">The </span><kbd><span class="koboSpan" id="kobo.103.1">CHANGE-CAUSE</span></kbd> <span><span class="koboSpan" id="kobo.104.1">field </span></span><span class="koboSpan" id="kobo.105.1">is actually stored in the </span><kbd><span class="koboSpan" id="kobo.106.1">kubernetes.io/change-cause</span></kbd> <span><span class="koboSpan" id="kobo.107.1">annotation </span></span><span class="koboSpan" id="kobo.108.1">of an object.</span></div>
<p><span class="koboSpan" id="kobo.109.1">For various reasons, </span><span><span class="koboSpan" id="kobo.110.1">we</span></span><span><span class="koboSpan" id="kobo.111.1"> </span></span><span><span class="koboSpan" id="kobo.112.1">sometimes want to roll back our application even if the</span></span> <kbd><span class="koboSpan" id="kobo.113.1">rollout</span></kbd> <span><span class="koboSpan" id="kobo.114.1">is successful to a certain extent. </span><span class="koboSpan" id="kobo.114.2">This can be achieved with the </span><kbd><span class="koboSpan" id="kobo.115.1">undo</span></kbd><span class="koboSpan" id="kobo.116.1"> sub-command </span></span><span><span class="koboSpan" id="kobo.117.1">:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.118.1">$ kubectl rollout undo deployment my-app</span></strong><strong><br/></strong></pre>
<p><span class="koboSpan" id="kobo.119.1">The whole process is basically identical to updating</span><span><span class="koboSpan" id="kobo.120.1">—</span></span><span class="koboSpan" id="kobo.121.1">that is, applying the previous manifest—and performing a rolling update. </span><span class="koboSpan" id="kobo.121.2">We can also utilize the </span><kbd><span class="koboSpan" id="kobo.122.1">--to-revision=&lt;REVISION#&gt;</span></kbd> <span><span class="koboSpan" id="kobo.123.1">flag </span></span><span class="koboSpan" id="kobo.124.1">to roll back to a specific version, but only retained revisions are able to be rolled back. </span><span class="koboSpan" id="kobo.124.2">Kubernetes determines how many revisions it keeps according to the </span><kbd><span class="koboSpan" id="kobo.125.1">revisionHistoryLimit</span></kbd><span class="koboSpan" id="kobo.126.1"> parameter in the </span><kbd><span class="koboSpan" id="kobo.127.1">deployment</span></kbd><span class="koboSpan" id="kobo.128.1"> object.</span></p>
<p><span class="koboSpan" id="kobo.129.1">The progress of an update is controlled by </span><kbd><span class="koboSpan" id="kobo.130.1">kubectl rollout pause</span></kbd><span class="koboSpan" id="kobo.131.1"> and </span><kbd><span class="koboSpan" id="kobo.132.1">kubectl rollout resume</span></kbd><span class="koboSpan" id="kobo.133.1">. </span><span class="koboSpan" id="kobo.133.2">As their names indicate, they should be used in pairs. </span><span class="koboSpan" id="kobo.133.3">Pausing a deployment involves not only stopping an ongoing </span><kbd><span class="koboSpan" id="kobo.134.1">rollout</span></kbd><span class="koboSpan" id="kobo.135.1">, but also freezing any triggering of updates even if the specification is modified, unless it's resumed.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Updating DaemonSet and StatefulSet</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Kubernetes supports various ways to orchestrate pods for different types of workloads. </span><span class="koboSpan" id="kobo.2.2">In addition to deployments, we also have </span><kbd><span class="koboSpan" id="kobo.3.1">DaemonSet</span></kbd><span class="koboSpan" id="kobo.4.1"> and </span><kbd><span class="koboSpan" id="kobo.5.1">StatefulSet</span></kbd><span class="koboSpan" id="kobo.6.1"> for long-running and non-batch workloads. </span><span class="koboSpan" id="kobo.6.2">As pods spawned by these have more constraints than the ones from deployments, there are a few caveats that we need to be aware of in order to handle their updates.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">DaemonSet</span></h1>
                </header>
            
            <article>
                
<p><kbd><span class="koboSpan" id="kobo.2.1">DaemonSet</span></kbd><span class="koboSpan" id="kobo.3.1"> is a controller designed for system daemons, as its name suggests. </span><span class="koboSpan" id="kobo.3.2">Consequently, a </span><kbd><span class="koboSpan" id="kobo.4.1">DaemonSet</span></kbd><span class="koboSpan" id="kobo.5.1"> controller launches and maintains exactly one pod per node; the total number of pods launched by a </span><kbd><span class="koboSpan" id="kobo.6.1">DaemonSet</span></kbd><span class="koboSpan" id="kobo.7.1"> controller adheres to the number of nodes in a cluster. </span><span class="koboSpan" id="kobo.7.2">Due to this limitation, updating </span><kbd><span class="koboSpan" id="kobo.8.1">DaemonSet</span></kbd><span class="koboSpan" id="kobo.9.1"> isn't as straightforward as updating a deployment. </span><span class="koboSpan" id="kobo.9.2">For instance, </span><kbd><span class="koboSpan" id="kobo.10.1">deployment</span></kbd><span class="koboSpan" id="kobo.11.1"> has a </span><kbd><span class="koboSpan" id="kobo.12.1">maxSurge</span></kbd><span class="koboSpan" id="kobo.13.1"> parameter (</span><kbd><span class="koboSpan" id="kobo.14.1">.spec.strategy.rollingUpdate.maxSurge</span></kbd><span class="koboSpan" id="kobo.15.1">) that controls how many redundant pods over the desired number can be created during updates, but we can't employ the same strategy for pods managed by </span><kbd><span class="koboSpan" id="kobo.16.1">DaemonSet</span></kbd><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">Because daemon pods usually come with special concerns that might occupy a host's resources, such as ports, it could result in errors if we have two or more system pods simultaneously on a node. </span><span class="koboSpan" id="kobo.17.3">As such, the update is in the form that a new pod is created after the old pod is terminated on a host.</span></p>
<p><span class="koboSpan" id="kobo.18.1">Kubernetes implements two update strategies for </span><kbd><span class="koboSpan" id="kobo.19.1">DaemonSet</span></kbd><span class="koboSpan" id="kobo.20.1">:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.21.1">OnDelete</span></kbd><span class="koboSpan" id="kobo.22.1">: Pods are only updated after they are deleted manually.</span></li>
<li><kbd><span class="koboSpan" id="kobo.23.1">RollingUpdate</span></kbd><span class="koboSpan" id="kobo.24.1">: This works like </span><kbd><span class="koboSpan" id="kobo.25.1">OnDelete</span></kbd><span class="koboSpan" id="kobo.26.1">, but the deletion of pods is performed by Kubernetes automatically. </span><span class="koboSpan" id="kobo.26.2">There is one optional parameter, </span><kbd><span class="koboSpan" id="kobo.27.1">.spec.updateStrategy.rollingUpdate.maxUnavailable</span></kbd><span class="koboSpan" id="kobo.28.1">, which is similar to the one in </span><kbd><span class="koboSpan" id="kobo.29.1">deployment</span></kbd><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">Its default value is </span><kbd><span class="koboSpan" id="kobo.31.1">1</span></kbd><span class="koboSpan" id="kobo.32.1">, which means Kubernetes replaces one pod at a time, node by node.</span></li>
</ul>
<p><span><span class="koboSpan" id="kobo.33.1">You can find an example that demonstrates how to write a template of </span></span><kbd><span class="koboSpan" id="kobo.34.1">DaemonSet</span></kbd><span><span class="koboSpan" id="kobo.35.1"> at </span><a href="https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/blob/master/chapter9/9-1_updates/ex-daemonset.yml"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/blob/master/chapter9/9-1_updates/ex-daemonset.yml</span></a></span><span><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">The update strategy is set at the </span></span><kbd><span class="koboSpan" id="kobo.38.1">.spec.updateStrategy.type</span></kbd><span class="koboSpan" id="kobo.39.1"> path, </span><span><span class="koboSpan" id="kobo.40.1">and its default is </span></span><kbd><span><span class="koboSpan" id="kobo.41.1">RollingUpdate</span></span></kbd><span><span class="koboSpan" id="kobo.42.1">.</span></span> <span><span class="koboSpan" id="kobo.43.1">The way to t</span></span><span class="koboSpan" id="kobo.44.1">rigger the rolling update is identical </span><span><span class="koboSpan" id="kobo.45.1">to the way in which we trigger a deployment</span></span><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">We can also utilize </span><kbd><span class="koboSpan" id="kobo.47.1">kubectl rollout</span></kbd><span class="koboSpan" id="kobo.48.1"> to manage rollouts of our </span><kbd><span class="koboSpan" id="kobo.49.1">DaemonSet</span></kbd><span class="koboSpan" id="kobo.50.1"> controller, but </span><kbd><span class="koboSpan" id="kobo.51.1">pause</span></kbd><span class="koboSpan" id="kobo.52.1"> and </span><kbd><span class="koboSpan" id="kobo.53.1">resume</span></kbd><span class="koboSpan" id="kobo.54.1"> aren't supported.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">StatefulSet</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The updating of </span><kbd><span class="koboSpan" id="kobo.3.1">StatefulSet</span></kbd><span class="koboSpan" id="kobo.4.1"> and </span><kbd><span class="koboSpan" id="kobo.5.1">DaemonSet</span></kbd><span class="koboSpan" id="kobo.6.1"> are pretty much the same; they don't create redundant pods during an update and their update strategies also behave in a similar way. </span><span class="koboSpan" id="kobo.6.2">There's a template file at </span><kbd><span class="koboSpan" id="kobo.7.1">9-1_updates/ex-statefulset.yml</span></kbd><span class="koboSpan" id="kobo.8.1"> that you can use for practice. </span><span class="koboSpan" id="kobo.8.2">The options of the update strategy are set at the </span><kbd><span class="koboSpan" id="kobo.9.1">.spec.updateStrategy.type</span></kbd><span class="koboSpan" id="kobo.10.1"> </span><span><span class="koboSpan" id="kobo.11.1">path:</span></span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.12.1">OnDelete</span></kbd><span class="koboSpan" id="kobo.13.1">: Pods are only updated after they're manually deleted.</span></li>
<li><kbd><span class="koboSpan" id="kobo.14.1">RollingUpdate</span></kbd><span class="koboSpan" id="kobo.15.1">: Like rolling updates for other controllers, Kubernetes deletes and creates pods in a managed fashion. </span><span class="koboSpan" id="kobo.15.2">Kubernetes knows the order matters in </span><kbd><span class="koboSpan" id="kobo.16.1">StatefulSet</span></kbd><span class="koboSpan" id="kobo.17.1">, so it replaces pods in reverse order. </span><span class="koboSpan" id="kobo.17.2">Say we have three pods in </span><kbd><span class="koboSpan" id="kobo.18.1">StatefulSet</span></kbd><span class="koboSpan" id="kobo.19.1">: </span><kbd><span class="koboSpan" id="kobo.20.1">my-ss-0</span></kbd><span class="koboSpan" id="kobo.21.1">, </span><kbd><span class="koboSpan" id="kobo.22.1">my-ss-1</span></kbd><span class="koboSpan" id="kobo.23.1">, and </span><kbd><span class="koboSpan" id="kobo.24.1">my-ss-2</span></kbd><span class="koboSpan" id="kobo.25.1">. </span><span class="koboSpan" id="kobo.25.2">The update order will start at </span><kbd><span class="koboSpan" id="kobo.26.1">my-ss-2</span></kbd><span class="koboSpan" id="kobo.27.1"> and run to </span><kbd><span class="koboSpan" id="kobo.28.1">my-ss-0</span></kbd><span class="koboSpan" id="kobo.29.1">. </span><span class="koboSpan" id="kobo.29.2">The deletion process doesn't respect the pod management policy of </span><kbd><span><span class="koboSpan" id="kobo.30.1">StatefulSet</span></span></kbd><span class="koboSpan" id="kobo.31.1">; even if we set the pod management policies to </span><kbd><span class="koboSpan" id="kobo.32.1">Parallel</span></kbd><span class="koboSpan" id="kobo.33.1">, the updates would still be performed one by one.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.34.1">The only parameter for the </span><kbd><span class="koboSpan" id="kobo.35.1">RollingUpdate</span></kbd><span class="koboSpan" id="kobo.36.1"> type is </span><kbd><span class="koboSpan" id="kobo.37.1">partition</span></kbd><span class="koboSpan" id="kobo.38.1"> (</span><kbd><span class="koboSpan" id="kobo.39.1">.spec.updateStrategy.rollingUpdate.partition</span></kbd><span class="koboSpan" id="kobo.40.1">). </span><span class="koboSpan" id="kobo.40.2">If this is specified, any pod with an ordinal less than the partition number will keep its current version and won't be updated. </span><span class="koboSpan" id="kobo.40.3">For instance, if we set </span><kbd><span class="koboSpan" id="kobo.41.1">partition</span></kbd><span class="koboSpan" id="kobo.42.1"> to </span><kbd><span class="koboSpan" id="kobo.43.1">1</span></kbd><span class="koboSpan" id="kobo.44.1"> in a </span><kbd><span class="koboSpan" id="kobo.45.1">StatefulSet</span></kbd><span class="koboSpan" id="kobo.46.1"> with three pods, only pod-1 and pod-2 would be updated after a rollout. </span><span class="koboSpan" id="kobo.46.2">This parameter allows us to control the progress to a certain extent and it's particularly handy for scenarios such as waiting for data synchronization, carrying out a canary test, or staging an update.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Building a delivery pipeline</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Implementing a CD pipeline for containerized applications is quite simple. </span><span class="koboSpan" id="kobo.2.2">Let's recall what practices we learned about Docker and Kubernetes so far and organize those practices into the CD pipeline. </span><span class="koboSpan" id="kobo.2.3">Suppose we've finished our code, Dockerfile, and corresponding Kubernetes templates. </span><span class="koboSpan" id="kobo.2.4">To deploy these to our cluster, we'd go through the following steps:</span></p>
<ol>
<li><kbd><span class="koboSpan" id="kobo.3.1">docker build</span></kbd><span class="koboSpan" id="kobo.4.1">: Produces an executable and immutable artifact</span></li>
<li><kbd><span class="koboSpan" id="kobo.5.1">docker run</span></kbd><span class="koboSpan" id="kobo.6.1">: Verifies whether the build works with a simple test</span></li>
<li><kbd><span class="koboSpan" id="kobo.7.1">docker tag</span></kbd><span class="koboSpan" id="kobo.8.1">: Tags the build with meaningful versions if it's good</span></li>
</ol>
<ol start="4">
<li><kbd><span class="koboSpan" id="kobo.9.1">docker push</span></kbd><span class="koboSpan" id="kobo.10.1">: Moves the build to the </span><kbd><span class="koboSpan" id="kobo.11.1">artifacts</span></kbd><span class="koboSpan" id="kobo.12.1"> repository for distribution</span></li>
<li><kbd><span class="koboSpan" id="kobo.13.1">kubectl apply</span></kbd><span class="koboSpan" id="kobo.14.1">: Deploys the build to a desired environment</span></li>
<li><kbd><span class="koboSpan" id="kobo.15.1">kubectl rollout status</span></kbd><span class="koboSpan" id="kobo.16.1">: Tracks the progress of deployment tasks</span></li>
</ol>
<p><span class="koboSpan" id="kobo.17.1">This is all we need for a simple but viable delivery pipeline.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.18.1">Here, we use the term continuous delivery instead of </span><span><span class="koboSpan" id="kobo.19.1">continuous deployment</span></span> <span><span class="koboSpan" id="kobo.20.1">because there are still gaps between the steps described previously, which can be implemented as either human-controlled or fully automatic deployments. </span><span class="koboSpan" id="kobo.20.2">The consideration may differ from team to team.</span></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Choosing tools</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">The steps we're going to implement are quite simple. </span><span class="koboSpan" id="kobo.2.2">However, when it comes to chaining them as a pipeline, there's no generic pipeline that suits all scenarios. </span><span class="koboSpan" id="kobo.2.3">It might differ by factors such as the form of an organization, the development workflow a team is running, or the interaction between the pipeline and other systems in the existing infrastructure. </span><span class="koboSpan" id="kobo.2.4">In light of this, setting a goal and choosing tools are the first things we have to think about.</span></span></p>
<p><span class="koboSpan" id="kobo.3.1">Generally speaking, to make the pipeline ship builds continuously, we'll need at least three kinds of tools: version control systems, build servers, and a repository for storing container artifacts. In this section, we will set a reference CD pipeline based on the SaaS tools we introduced in previous chapters:</span></p>
<ul>
<li><span><span class="koboSpan" id="kobo.4.1">GitHub</span></span><span class="koboSpan" id="kobo.5.1"> </span><span><span class="koboSpan" id="kobo.6.1">(</span></span><a href="https://github.com" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.7.1">https://</span></span><span class="URLPACKT"><span class="koboSpan" id="kobo.8.1">github.com</span></span></a><span><span class="koboSpan" id="kobo.9.1">)</span></span></li>
<li><span><span class="koboSpan" id="kobo.10.1">Travis C</span></span><span class="koboSpan" id="kobo.11.1">I </span><span><span class="koboSpan" id="kobo.12.1">(</span></span><a href="https://travis-ci.com"><span class="koboSpan" id="kobo.13.1">https://travis-ci.com</span></a><span><span class="koboSpan" id="kobo.14.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Docker Hub </span><span><span class="koboSpan" id="kobo.16.1">(</span></span><a href="https://hub.docker.com" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.17.1">https://hub.docker.co</span></span><span class="URLPACKT"><span class="koboSpan" id="kobo.18.1">m</span></span></a><span><span class="koboSpan" id="kobo.19.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.20.1">All of these are free for open source projects. </span><span class="koboSpan" id="kobo.20.2">Certainly, there are numerous alternatives for each tool we used here, such as GitLab for VCS, hosting Jenkins for CI, or even dedicated deployment tools such as S</span><span><span class="koboSpan" id="kobo.21.1">pinnaker </span></span><span class="koboSpan" id="kobo.22.1">(</span><a href="https://www.spinnaker.io/"><span class="koboSpan" id="kobo.23.1">https://www.spinnaker.io/</span></a><span class="koboSpan" id="kobo.24.1">). </span><span class="koboSpan" id="kobo.24.2">In addition to these large building blocks, we can also benefit from tools such as </span><span><span class="koboSpan" id="kobo.25.1">Helm (</span></span><a href="https://github.com/kubernetes/helm"><span class="koboSpan" id="kobo.26.1">https://github.com/kubernetes/helm</span></a><span><span class="koboSpan" id="kobo.27.1">) to help us to organize templates and their instantialized releases. </span><span class="koboSpan" id="kobo.27.2">All in all, it's up to you to choose the tools that best suit your needs. </span><span class="koboSpan" id="kobo.27.3">We'll focus on how these fundamental components interact with our deployments in Kubernetes.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">End-to-end walk-through of the delivery pipeline </span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The following diagram is our CD flow based on the three services mentioned earlier:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img class=" image-border" src="assets/964506b1-8d43-4d17-99bd-0af7675bde57.png" style="width:39.00em;height:18.08em;"/></span></div>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.4.1">The workflow for code integration is as follows:</span></p>
<ol>
<li><span><span class="koboSpan" id="kobo.5.1">Code is committed to a repository on GitHub.</span></span></li>
<li><span><span class="koboSpan" id="kobo.6.1">The commit triggers a build job on Travis CI:</span></span>
<ul>
<li><span><span class="koboSpan" id="kobo.7.1">A Docker image will be built.</span></span></li>
<li><span><span class="koboSpan" id="kobo.8.1">To ensure that the quality of the build is solid and ready to be integrated, different levels of tests are usually performed at this stage on the CI server. </span><span class="koboSpan" id="kobo.8.2">Furthermore, as running an application stack with Docker Compose or Kubernetes is easier than ever, running tests involving many components in a build job is also possible.</span></span></li>
</ul>
</li>
<li><span><span class="koboSpan" id="kobo.9.1">The verified image is tagged with identifiers and pushed to Docker Hub.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.10.1">As for the deployment in Kubernetes, this can be as simple as updating the image path in a template and then applying the template to a production cluster, or as complex as a series of operatio</span><span><span class="koboSpan" id="kobo.11.1">ns including traffic distribution and canary deployment. </span><span class="koboSpan" id="kobo.11.2">In our example, a rollout starts from manually publishing</span></span><span><span class="koboSpan" id="kobo.12.1"> </span></span><span><span class="koboSpan" id="kobo.13.1">a new</span></span><span class="koboSpan" id="kobo.14.1"> G</span><span><span class="koboSpan" id="kobo.15.1">it S</span></span><span><span class="koboSpan" id="kobo.16.1">emVe</span></span><span><span class="koboSpan" id="kobo.17.1">r</span></span><span><span class="koboSpan" id="kobo.18.1"> </span></span><span><span class="koboSpan" id="kobo.19.1">tag, and the CI script repeats the same flow as in the integration part until the image pushing step. </span><span class="koboSpan" id="kobo.19.2">As a CI server sometimes may not be able to touch the production environment, we put an agent inside our cluster to watch and apply the changes in the configuration branch.</span></span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.20.1">A dedicated config repository is a popular pattern for</span><span><span class="koboSpan" id="kobo.21.1"> </span></span><span class="koboSpan" id="kobo.22.1">segregating an application and its infrastructure. </span><span class="koboSpan" id="kobo.22.2">There are many </span><strong><span class="koboSpan" id="kobo.23.1">Infrastructure as Code</span></strong><span class="koboSpan" id="kobo.24.1"> (</span><strong><span><span class="koboSpan" id="kobo.25.1">IaC</span></span></strong><span class="koboSpan" id="kobo.26.1">) tools that help us to express infrastructure and their states in a way that can be recorded in a version control system. </span><span class="koboSpan" id="kobo.26.2">Additionally, by tracking everything in a version control system, we can translate every change made to the infrastructure into Git operations. </span><span class="koboSpan" id="kobo.26.3">For the sake of simplicity, we use another branch in the same repository for the config changes.</span></div>
<p><span class="koboSpan" id="kobo.27.1">Once the agent observes the change, it pulls the new template and updates the corresponding controller accordingly.</span><span><span class="koboSpan" id="kobo.28.1"> </span></span><span class="koboSpan" id="kobo.29.1">Finally, the delivery is finished after the rolling update process of Kubernetes ends.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The steps explained</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Our example, </span><kbd><span class="koboSpan" id="kobo.3.1">okeydokey</span></kbd><span class="koboSpan" id="kobo.4.1">, is a web service that always echoes </span><kbd><span class="koboSpan" id="kobo.5.1">OK</span></kbd><span class="koboSpan" id="kobo.6.1"> to every request, and the code as well as the files for deployment are committed in our repository over in GitHub: </span><a href="https://github.com/DevOps-with-Kubernetes/okeydokey"><span class="koboSpan" id="kobo.7.1">https://github.com/DevOps-with-Kubernetes/okeydokey</span></a><span class="koboSpan" id="kobo.8.1">.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Before configuring our builds on Travis CI, let's create an image repository in Docker Hub first for later use. </span><span class="koboSpan" id="kobo.9.2">After signing in to Docker Hub, press the huge </span><span class="packt_screen"><span class="koboSpan" id="kobo.10.1">Create Repository</span></span><span class="koboSpan" id="kobo.11.1"> button at the top right, and then follow the steps onscreen to create one. </span><span class="koboSpan" id="kobo.11.2">The image repository of </span><kbd><span class="koboSpan" id="kobo.12.1">okeydokey</span></kbd><span class="koboSpan" id="kobo.13.1"> is at </span><kbd><span><span class="koboSpan" id="kobo.14.1">devopswithkubernetes/okeydokey</span></span></kbd><span class="koboSpan" id="kobo.15.1"> (</span><a href="https://hub.docker.com/r/devopswithkubernetes/okeydokey/"><span class="koboSpan" id="kobo.16.1">https://hub.docker.com/r/devopswithkubernetes/okeydokey/</span></a><a href="https://hub.docker.com/r/devopswithkubernetes/my-app/" target="_blank"><span class="koboSpan" id="kobo.17.1">)</span></a><span class="koboSpan" id="kobo.18.1">.</span></p>
<p><span class="koboSpan" id="kobo.19.1">Connecting Travis CI with a GitHub repository is quite simple; all we need to do is authorize Travis CI to access our GitHub repositories and enable it to build the repository in the settings page (</span><a href="https://travis-ci.com/account/repositories"><span class="koboSpan" id="kobo.20.1">https://travis-ci.com/account/repositories</span></a><span class="koboSpan" id="kobo.21.1">). </span><span><span class="koboSpan" id="kobo.22.1">Another thing we'll need is a GitHub access token or a deploy key that has write permission to our repository. </span><span class="koboSpan" id="kobo.22.2">This will be put on the Travis CI so that the CI script can update the built image back into the config branch. </span><span class="koboSpan" id="kobo.22.3">Please refer to the GitHub official documentation (</span><a href="https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys"><span class="koboSpan" id="kobo.23.1">https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys</span></a><span class="koboSpan" id="kobo.24.1">) to obtain a deploy key.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">The definition of a job in Travis CI is configured in a file, </span><kbd><span class="koboSpan" id="kobo.26.1">.travis.yml</span></kbd><span class="koboSpan" id="kobo.27.1">, placed under the same repository. </span><span><span><span class="koboSpan" id="kobo.28.1">The definition is</span></span></span><span class="koboSpan" id="kobo.29.1"> a YAML format template consisting of blocks of shell scripts that tell us what Travis CI should do during a build.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.30.1">The full </span><span><span class="koboSpan" id="kobo.31.1">Travis CI </span></span><span class="koboSpan" id="kobo.32.1">document can be found here: </span><a href="https://docs.travis-ci.com/user/tutorial/"><span class="koboSpan" id="kobo.33.1">https://docs.travis-ci.com/user/tutorial/</span></a><span class="koboSpan" id="kobo.34.1">.</span></div>
<p><span class="koboSpan" id="kobo.35.1">You can find explanations for the blocks of our </span><kbd><span class="koboSpan" id="kobo.36.1">.travis.yml</span></kbd><span class="koboSpan" id="kobo.37.1"> file </span><span><span class="koboSpan" id="kobo.38.1">at the following URL: </span></span><a href="https://github.com/DevOps-with-Kubernetes/okeydokey/blob/master/.travis.yml"><span class="koboSpan" id="kobo.39.1">https://github.com/DevOps-with-Kubernetes/okeydokey/blob/master/.travis.yml</span></a><span class="koboSpan" id="kobo.40.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">env</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This section defines environment variables that are visible throughout a build:</span></p>
<pre><strong><span class="koboSpan" id="kobo.3.1">DOCKER_REPO=devopswithkubernetes/okeydokey</span><br/><span class="koboSpan" id="kobo.4.1">BUILD_IMAGE_PATH=${DOCKER_REPO}:build-${TRAVIS_COMMIT}</span><br/><span class="koboSpan" id="kobo.5.1">RELEASE_IMAGE_PATH=${DOCKER_REPO}:${TRAVIS_TAG}</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.6.1">Here, we set some variables that might be changed, such as the Docker registry path where the built image is heading. </span><span class="koboSpan" id="kobo.6.2">There's also metadata about a build passed from Travis CI in the form of environment variables, which is documented here: </span><a href="https://docs.travis-ci.com/user/environment-variables/#default-environment-variables"><span class="koboSpan" id="kobo.7.1">https://docs.travis-ci.com/user/environment-variables/#default-environment-variables</span></a><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">For example, </span><kbd><span class="koboSpan" id="kobo.9.1">TRAVIS_COMMIT</span></kbd><span class="koboSpan" id="kobo.10.1"> represents the hash of the current commit, and we use it as an identifier to distinguish our images across builds.</span></p>
<p><span class="koboSpan" id="kobo.11.1">The other source of environment variables is configured manually on Travis CI. </span><span class="koboSpan" id="kobo.11.2">Because the variables configured there would be</span><span><span><span class="koboSpan" id="kobo.12.1"> hidden from public view</span></span></span><span class="koboSpan" id="kobo.13.1">, we stored some sensitive data such as credentials for Docker Hub and our GitHub repository there:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.14.1"><img class=" image-border" src="assets/0cb129a6-81d7-4e69-a05c-7a15663db0c8.png"/></span></div>
<p><span class="koboSpan" id="kobo.15.1">Every CI tool has its own best practices to deal with secrets. </span><span class="koboSpan" id="kobo.15.2">For instance, some CI tools also allow us to save variables in the CI server, but these are still printed in the building logs, so we're unlikely to save secrets there in such cases.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.16.1">Key management systems such as Vault (</span><a href="https://www.vaultproject.io/"><span class="koboSpan" id="kobo.17.1">https://www.vaultproject.io/</span></a><span class="koboSpan" id="kobo.18.1">) or similar services by cloud providers such as GCP KMS (</span><a href="https://cloud.google.com/kms/"><span class="koboSpan" id="kobo.19.1">https://cloud.google.com/kms/</span></a><span class="koboSpan" id="kobo.20.1">), AWS KMS (</span><a href="https://aws.amazon.com/kms/"><span class="koboSpan" id="kobo.21.1">https://aws.amazon.com/kms/</span></a><span class="koboSpan" id="kobo.22.1">), and Azure Key Vault (</span><a href="https://azure.microsoft.com/en-us/services/key-vault/"><span class="koboSpan" id="kobo.23.1">https://azure.microsoft.com/en-us/services/key-vault/</span></a><span class="koboSpan" id="kobo.24.1">), are recommended for storing sensitive credentials.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">script</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This section is where we run builds and tests:</span></p>
<pre><strong><span class="koboSpan" id="kobo.3.1">docker build -t my-app .</span><br/><span class="koboSpan" id="kobo.4.1">docker run --rm --name app -dp 5000:5000 my-app</span><br/><span class="koboSpan" id="kobo.5.1">sleep 10</span><br/><span class="koboSpan" id="kobo.6.1">CODE=$(curl -IXGET -so /dev/null -w "%{http_code}" localhost:5000)</span><br/><span class="koboSpan" id="kobo.7.1">'[ ${CODE} -eq 200 ] &amp;&amp; echo "Image is OK"'</span><br/><span class="koboSpan" id="kobo.8.1">docker stop app</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.9.1">As we're on Docker, the build only takes up one line of script. </span><span class="koboSpan" id="kobo.9.2">Our test is quite simple; it involves launching a container with the built image and making some requests to determine its integrity. </span><span class="koboSpan" id="kobo.9.3">We can do everything, including adding unit tests or running an automated integration test to improve the resultant artifacts, in this stage.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">after_success</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This block is executed only if the previous stage ends without any error. </span><span class="koboSpan" id="kobo.2.2">Once the block is executed, we are ready to publish our image:</span></p>
<pre><strong><span class="koboSpan" id="kobo.3.1">docker login -u ${CI_ENV_REGISTRY_USER} -p "${CI_ENV_REGISTRY_PASS}"
if [[ ${TRAVIS_TAG} =~ ^v.*$ ]]; then</span><br/><span class="koboSpan" id="kobo.4.1">  docker tag my-app ${RELEASE_IMAGE_PATH}</span><br/><span class="koboSpan" id="kobo.5.1">  docker push ${RELEASE_IMAGE_PATH}</span><br/><span class="koboSpan" id="kobo.6.1">else</span><br/><span class="koboSpan" id="kobo.7.1">  docker tag my-app ${BUILD_IMAGE_PATH}</span><br/><span class="koboSpan" id="kobo.8.1">  docker push ${BUILD_IMAGE_PATH}</span><br/><span class="koboSpan" id="kobo.9.1">fi</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.10.1">Our image tag uses the commit hash for ordinary builds and uses a manually</span><span><span class="koboSpan" id="kobo.11.1"> tagged </span></span><span><span class="koboSpan" id="kobo.12.1">versio</span></span><span><span class="koboSpan" id="kobo.13.1">n</span></span> <span><span class="koboSpan" id="kobo.14.1">for releases. </span><span class="koboSpan" id="kobo.14.2">There's no absolute rule for tagging an image, but using the default </span></span><kbd><span class="koboSpan" id="kobo.15.1">latest</span></kbd><span><span class="koboSpan" id="kobo.16.1"> </span></span><span><span class="koboSpan" id="kobo.17.1">tag </span></span><span><span class="koboSpan" id="kobo.18.1">for your business service is strongly discouraged as it could result in version confusion, such as running two different images that have the same name. </span><span class="koboSpan" id="kobo.18.2">The last conditional block is used to publish the image on certain branch tags, and we want to keep building and releasing on separate tracks. </span><span class="koboSpan" id="kobo.18.3">Remember to authenticate to Docker Hub before pushing an image.</span></span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.19.1">Kubernetes decides whether the image should be pulled using </span><kbd><span class="koboSpan" id="kobo.20.1">imagePullPolicy</span></kbd><span class="koboSpan" id="kobo.21.1">, which defaults to </span><span><kbd><span class="koboSpan" id="kobo.22.1">IfNotPresent</span></kbd><span class="koboSpan" id="kobo.23.1">:</span></span><br/>
<span><kbd><span class="koboSpan" id="kobo.24.1">IfNotPresent</span></kbd><span class="koboSpan" id="kobo.25.1">: kubelet pulls images if they aren't present on the node. </span><span class="koboSpan" id="kobo.25.2">If the image tag is </span><kbd><span class="koboSpan" id="kobo.26.1">:latest</span></kbd><span class="koboSpan" id="kobo.27.1"> and the policy isn't </span><kbd><span class="koboSpan" id="kobo.28.1">Never</span></kbd><span class="koboSpan" id="kobo.29.1">, then kubelet falls back to </span><kbd><span class="koboSpan" id="kobo.30.1">Always</span></kbd><span class="koboSpan" id="kobo.31.1">.</span><br/>
<kbd><span class="koboSpan" id="kobo.32.1">Always</span></kbd><span class="koboSpan" id="kobo.33.1">: kubelet always pulls images.</span><br/>
<kbd><span class="koboSpan" id="kobo.34.1">Never</span></kbd><span class="koboSpan" id="kobo.35.1">: kubelet never pulls images; it will find out whether the desired image is on the node or not.</span></span><a href="https://kubernetes.io/docs/concepts/containers/images/#updating-images" target="_blank"/></div>
<p><span class="koboSpan" id="kobo.36.1">Because we set our project deployments to actual machines only on a release, a build may stop and be returned at that moment. </span><span class="koboSpan" id="kobo.36.2">Let's have a look into the log of this build: </span><a href="https://travis-ci.com/DevOps-with-Kubernetes/okeydokey/builds/93296022"><span class="koboSpan" id="kobo.37.1">https://travis-ci.com/DevOps-with-Kubernetes/okeydokey/builds/93296022</span></a><span class="koboSpan" id="kobo.38.1">. </span><span class="koboSpan" id="kobo.38.2">The log retains the executed scripts and outputs from every line of the script during a CI build:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.39.1"><img class=" image-border" src="assets/c735c0d7-b93c-4b31-aa0d-21ad62a98269.png" style="width:60.08em;height:9.00em;"/></span></div>
<p><span class="koboSpan" id="kobo.40.1">As we can see, our build is successful, so the image is then published here: </span><a href="https://hub.docker.com/r/devopswithkubernetes/okeydokey/tags/"><span class="koboSpan" id="kobo.41.1">https://hub.docker.com/r/devopswithkubernetes/okeydokey/tags/</span></a><span class="URLPACKT"><span class="koboSpan" id="kobo.42.1">. </span></span><span class="koboSpan" id="kobo.43.1">The build refers to the </span><kbd><span class="koboSpan" id="kobo.44.1">build-842eb66b2fa612598add8e19769af5c56b922532</span></kbd><span class="koboSpan" id="kobo.45.1"> tag and we can now run it outside the CI server:</span></p>
<pre><strong><span class="koboSpan" id="kobo.46.1">$ docker run --name test -dp 5000:5000 devopswithkubernetes/okeydokey:build-842eb66b2fa612598add8e19769af5c56b922532</span><br/><span class="koboSpan" id="kobo.47.1">3d93d6505e369286c3f072ef4f04e15db2638f280c4615be95bff47379a70388</span><br/><span class="koboSpan" id="kobo.48.1">$ curl localhost:5000</span><br/><span class="koboSpan" id="kobo.49.1">OK</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">deploy</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Although we can achieve a fully automated pipeline from end to end, we often encounter situations that hold up the deployment of a new build due to business concerns. </span><span class="koboSpan" id="kobo.2.2">Consequently, we tell Travis CI to run deployment scripts only when we want to release a new version.</span></p>
<p><span class="koboSpan" id="kobo.3.1">As we stated earlier, the deployment in this example on Travis CI is </span><span><span class="koboSpan" id="kobo.4.1">merely</span></span><span><span class="koboSpan" id="kobo.5.1"> </span></span><span><span class="koboSpan" id="kobo.6.1">to write the built image back to the template to be deployed. </span><span class="koboSpan" id="kobo.6.2">Here, we utilize the script provider to make Travis CI run our deployment script (</span></span><a href="https://github.com/DevOps-with-Kubernetes/okeydokey/blob/master/deployment/update-config.sh"><span class="koboSpan" id="kobo.7.1">deployment/update-config.sh</span></a><span><span class="koboSpan" id="kobo.8.1">) and the script does the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Locates the config repository and corresponding branch</span></li>
<li><span class="koboSpan" id="kobo.10.1">Updates the image tag </span></li>
<li><span class="koboSpan" id="kobo.11.1">Commits the updated template back</span></li>
</ul>
<p><span class="koboSpan" id="kobo.12.1">After the updated image tag is committed into the repository, the job on Travis CI is done.</span></p>
<p><span class="koboSpan" id="kobo.13.1">The other end of the pipeline is our agent inside the cluster. </span><span class="koboSpan" id="kobo.13.2">It is responsible for the following tasks:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.14.1">Periodically monitoring the change of our configs on GitHub</span></li>
<li><span class="koboSpan" id="kobo.15.1">Pulling and applying the updated image to our pod controller</span></li>
</ul>
<p><span class="koboSpan" id="kobo.16.1">The former is quite simple, but for the latter, we have to grant the agent </span><span><span class="koboSpan" id="kobo.17.1">sufficient permissions</span></span><span class="koboSpan" id="kobo.18.1"> so that it can </span><span><span class="koboSpan" id="kobo.19.1">manipulate resources inside the cluster. </span><span class="koboSpan" id="kobo.19.2">Our example uses a service account, </span><kbd><span class="koboSpan" id="kobo.20.1">cd-agent</span></kbd><span class="koboSpan" id="kobo.21.1">, under a dedicated namespace, </span><kbd><span class="koboSpan" id="kobo.22.1">cd</span></kbd><span class="koboSpan" id="kobo.23.1">, to create and update our deployments, and the related RBAC configurations can be found under </span></span><a href="https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter9/9-2_service-account-for-ci-tool/cd-agent"><span class="koboSpan" id="kobo.24.1">chapter9/9-2_service-account-for-ci-tool/cd-agent</span></a> <span><span class="koboSpan" id="kobo.25.1">in the repository for this book.</span></span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.26.1">Here, we grant the service account the permission to read and modify resources across namespaces, including the secrets of the whole cluster. </span><span class="koboSpan" id="kobo.26.2">Due to security concerns, it's always encouraged to restrict the permissions of a service account to the resources that the account actually uses, or it could be a potential vulnerability.</span></div>
<p><span class="koboSpan" id="kobo.27.1">The agent itself is merely a long-running script at </span><a href="https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/blob/master/chapter9/9-2_service-account-for-ci-tool/utils/watcher/watcher.sh"><span class="koboSpan" id="kobo.28.1">chapter9/9-2_service-account-for-ci-tool/utils/watcher/watcher.sh</span></a><span><span class="koboSpan" id="kobo.29.1">. </span><span class="koboSpan" id="kobo.29.2">To carry out updates, it uses </span><kbd><span class="koboSpan" id="kobo.30.1">apply</span></kbd><span class="koboSpan" id="kobo.31.1"> and </span><kbd><span class="koboSpan" id="kobo.32.1">rollout</span></kbd><span class="koboSpan" id="kobo.33.1">:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.34.1">...</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">apply_to_kube() {</span></strong><br/><strong><span class="koboSpan" id="kobo.36.1">  kubectl apply -f &lt;template_path&gt; -n &lt;namespace&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">  kubectl rollout status -f </span><span><span class="koboSpan" id="kobo.38.1">&lt;template_path&gt;</span></span><span class="koboSpan" id="kobo.39.1"> -n </span><span><span class="koboSpan" id="kobo.40.1">&lt;namespace&gt;</span></span><span class="koboSpan" id="kobo.41.1"> --timeout 5m</span></strong><br/><strong><span class="koboSpan" id="kobo.42.1">}</span></strong><br/><strong><span class="koboSpan" id="kobo.43.1">...</span></strong></pre>
<p><span class="koboSpan" id="kobo.44.1">Let's deploy </span><kbd><span class="koboSpan" id="kobo.45.1">agent</span></kbd><span class="koboSpan" id="kobo.46.1"> and its related </span><kbd><span class="koboSpan" id="kobo.47.1">config</span></kbd><span class="koboSpan" id="kobo.48.1"> before rolling out our application:</span></p>
<pre><strong><span class="koboSpan" id="kobo.49.1">$ kubectl apply -f chapter9/9-2_service-account-for-ci-tool/cd-agent</span></strong><br/><strong><span class="koboSpan" id="kobo.50.1">clusterrole.rbac.authorization.k8s.io/cd-role created</span></strong><br/><strong><span class="koboSpan" id="kobo.51.1">clusterrolebinding.rbac.authorization.k8s.io/cd-agent created</span></strong><br/><strong><span class="koboSpan" id="kobo.52.1">namespace/cd created</span></strong><br/><strong><span class="koboSpan" id="kobo.53.1">serviceaccount/cd-agent created</span></strong><br/><strong><span class="koboSpan" id="kobo.54.1">deployment.apps/state-watcher created</span></strong></pre>
<p><span class="koboSpan" id="kobo.55.1">The </span><kbd><span class="koboSpan" id="kobo.56.1">state-watcher</span></kbd> <span><span class="koboSpan" id="kobo.57.1">deployment </span></span><span class="koboSpan" id="kobo.58.1">is our </span><kbd><span class="koboSpan" id="kobo.59.1">agent</span></kbd><span class="koboSpan" id="kobo.60.1">, and it has been configured to monitor our config repository for environment variables:</span></p>
<pre><strong><span class="koboSpan" id="kobo.61.1">$ cat chapter9/9-2_service-account-for-ci-tool/cd-agent/watcher-okeydokey.yml</span></strong><br/><strong><span class="koboSpan" id="kobo.62.1">...</span></strong><br/><strong><span class="koboSpan" id="kobo.63.1">        env:</span></strong><br/><strong><span class="koboSpan" id="kobo.64.1">        - name: WORK_PATH</span></strong><br/><strong><span class="koboSpan" id="kobo.65.1">          value: /repo</span></strong><br/><strong><span class="koboSpan" id="kobo.66.1">        - name: TEMPLATE_PATH</span></strong><br/><strong><span class="koboSpan" id="kobo.67.1">          value: /repo/deployment</span></strong><br/><strong><span class="koboSpan" id="kobo.68.1">        - name: REMOTE_GIT_REPO</span></strong><br/><strong><span class="koboSpan" id="kobo.69.1">          value: https://github.com/DevOps-with-Kubernetes/okeydokey.git</span></strong><br/><strong><span class="koboSpan" id="kobo.70.1">        - name: WATCH_BRANCH</span></strong><br/><strong><span class="koboSpan" id="kobo.71.1">          value: config</span></strong><br/><strong><span class="koboSpan" id="kobo.72.1">        - name: RELEASE_TARGET_NAMESPACE</span></strong><br/><strong><span class="koboSpan" id="kobo.73.1">          value: default</span></strong><br/><strong><span class="koboSpan" id="kobo.74.1">        - name: RELEASE_TARGET_CONTROLLER_TEMPLATE</span></strong><br/><strong><span class="koboSpan" id="kobo.75.1">          value: deployment.yml</span></strong><br/><strong><span class="koboSpan" id="kobo.76.1">...</span></strong></pre>
<p><span class="koboSpan" id="kobo.77.1">Everything is ready. </span><span class="koboSpan" id="kobo.77.2">Let's see the entire flow in action.</span></p>
<p><span class="koboSpan" id="kobo.78.1">We publish a release with a </span><kbd><span class="koboSpan" id="kobo.79.1">v0.0.3</span></kbd> <span><span class="koboSpan" id="kobo.80.1">tag </span></span><span class="koboSpan" id="kobo.81.1">at GitHub (</span><a href="https://github.com/DevOps-with-Kubernetes/okeydokey/releases/tag/v0.0.3"><span class="koboSpan" id="kobo.82.1">https://github.com/DevOps-with-Kubernetes/okeydokey/releases/tag/v0.0.3</span></a><span class="koboSpan" id="kobo.83.1">):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.84.1"> </span><span class="koboSpan" id="kobo.85.1"><img class=" image-border" src="assets/fc6593f4-845b-4b80-b3ac-55b4cd3596d1.png" style="width:19.08em;height:12.33em;"/></span></div>
<p><span class="koboSpan" id="kobo.86.1">Travis CI starts to build our job right after being triggered by the new tag:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.87.1"><img class=" image-border" src="assets/2499ae7a-fae7-4c92-8a34-111eaec87856.png" style="width:14.92em;height:13.42em;"/></span></div>
<p><span class="koboSpan" id="kobo.88.1">If it fails, we can check the build log to see what went wrong: </span><a href="https://travis-ci.com/DevOps-with-Kubernetes/okeydokey/jobs/162862675"><span class="koboSpan" id="kobo.89.1">https://travis-ci.com/DevOps-with-Kubernetes/okeydokey/jobs/162862675</span></a><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">Fortunately, we get a green flag, so the built image will be pushed onto Docker Hub after a while:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.91.1"><img class=" image-border" src="assets/aa75bd53-c20f-485d-a454-5228e6ac5ca6.png" style="width:31.75em;height:17.83em;"/></span></div>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.92.1">At this moment, our </span><kbd><span class="koboSpan" id="kobo.93.1">agent</span></kbd><span class="koboSpan" id="kobo.94.1"> should also notice the change in </span><kbd><span class="koboSpan" id="kobo.95.1">config</span></kbd><span class="koboSpan" id="kobo.96.1"> and act upon it:</span></p>
<pre><strong><span class="koboSpan" id="kobo.97.1">$ kubectl logs -f -n cd state-watcher-69bfdd578-8nn9s -f</span></strong><br/><strong><span class="koboSpan" id="kobo.98.1">...</span></strong><br/><strong><span class="koboSpan" id="kobo.99.1">From https://github.com/DevOps-with-Kubernetes/okeydokey</span></strong><br/><strong><span class="koboSpan" id="kobo.100.1"> * branch config -&gt; FETCH_HEAD</span></strong><br/><strong><span class="koboSpan" id="kobo.101.1"> * [new branch] config -&gt; origin/config</span></strong><br/><strong><span class="koboSpan" id="kobo.102.1">Tue Dec 4 23:44:56 UTC 2018: No update detected.</span></strong><br/><strong><span class="koboSpan" id="kobo.103.1">deployment.apps/okeydokey created</span><br/><span class="koboSpan" id="kobo.104.1">service/okeydokey-svc created</span></strong><br/><strong><span class="koboSpan" id="kobo.105.1">Waiting for deployment "okeydokey" rollout to finish: 0 of 2 updated replicas are available...</span></strong><br/><strong><span class="koboSpan" id="kobo.106.1">Waiting for deployment "okeydokey" rollout to finish: 0 of 2 updated replicas are available...</span></strong><br/><strong><span class="koboSpan" id="kobo.107.1">Waiting for deployment "okeydokey" rollout to finish: 1 of 2 updated replicas are available...</span></strong><br/><strong><span class="koboSpan" id="kobo.108.1">deployment "okeydokey" successfully rolled out</span></strong><br/><strong><span class="koboSpan" id="kobo.109.1">...</span></strong></pre>
<p><span class="koboSpan" id="kobo.110.1">As we can see, our application has rolled out successfully, and it should start to welcome everyone with </span><kbd><span class="koboSpan" id="kobo.111.1">OK</span></kbd><span class="koboSpan" id="kobo.112.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.113.1">$ kubectl proxy &amp;</span><br/><span class="koboSpan" id="kobo.114.1">$ curl localhost:8001/api/v1/namespaces/default/services/</span></strong><strong><span class="koboSpan" id="kobo.115.1">okeydokey-</span></strong><strong><span class="koboSpan" id="kobo.116.1">svc:80/proxy/</span><br/><span class="koboSpan" id="kobo.117.1">OK</span></strong></pre>
<p><span class="koboSpan" id="kobo.118.1">The pipeline we built and demonstrated in this section is a classic flow to deliver code continuously in Kubernetes. </span><span class="koboSpan" id="kobo.118.2">However, as the work style and culture varies from team to team, designing a tailor-made continuous delivery pipeline for your team can improve efficiency. </span><span class="koboSpan" id="kobo.118.3">For example, the built-in update strategy of a deployment is the rolling update. </span><span class="koboSpan" id="kobo.118.4">Teams that prefer other types of deployment strategies such as blue/green or canary have to change the pipeline to fit their needs. </span><span class="koboSpan" id="kobo.118.5">Fortunately, Kubernetes is extremely flexible, and we can implement various strategies by compositing </span><kbd><span class="koboSpan" id="kobo.119.1">Deployment</span></kbd><span class="koboSpan" id="kobo.120.1">, </span><kbd><span class="koboSpan" id="kobo.121.1">Service</span></kbd><span class="koboSpan" id="kobo.122.1">, </span><kbd><span class="koboSpan" id="kobo.123.1">Ingress</span></kbd><span class="koboSpan" id="kobo.124.1">, and so on.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.125.1">In the previous edition of this book, we demonstrated a similar flow but applied the configuration from the CI server directly. </span><span class="koboSpan" id="kobo.125.2">Both approaches have their pros and cons. </span><span class="koboSpan" id="kobo.125.3">If you don't have any security concerns related to putting cluster information on the CI server and just need a really easy CD flow, then the push-based pipeline is still an option. </span><span class="koboSpan" id="kobo.125.4">You can find a script for exporting the tokens of a service account and another script for applying configuration to Kubernetes here: </span><a href="https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter9/9-2_service-account-for-ci-tool/utils/push-cd"><span class="koboSpan" id="kobo.126.1">https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter9/9-2_service-account-for-ci-tool/utils/push-cd</span></a><span class="koboSpan" id="kobo.127.1">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Gaining a deeper understanding of pods</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Although birth and death are merely a blink during a pod's lifetime, they're also the most fragile points of a service. </span><span class="koboSpan" id="kobo.2.2">We want to avoid common situations such as routing requests to an unready box or brutally cutting all in-flight connections to a terminating machine. </span><span class="koboSpan" id="kobo.2.3">As a consequence, even if Kubernetes takes care of most things for us, we should know how to configure our service properly to make sure every feature is delivered perfectly.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Starting a pod</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">By default, Kubernetes moves a pod's state to </span><span class="packt_screen"><span class="koboSpan" id="kobo.3.1">Running</span></span><span class="koboSpan" id="kobo.4.1"> as soon as a pod launches. </span><span class="koboSpan" id="kobo.4.2">If the pod is behind a service, the endpoint controller registers an endpoint to Kubernetes immediately. </span><span class="koboSpan" id="kobo.4.3">Later on, </span><kbd><span class="koboSpan" id="kobo.5.1">kube-proxy</span></kbd><span class="koboSpan" id="kobo.6.1"> observes the change of endpoints and configures the host's </span><kbd><span class="koboSpan" id="kobo.7.1">ipvs</span></kbd><span class="koboSpan" id="kobo.8.1"> or </span><kbd><span class="koboSpan" id="kobo.9.1">iptables</span></kbd><span class="koboSpan" id="kobo.10.1"> accordingly. </span><span class="koboSpan" id="kobo.10.2">Requests from the outside world now go to pods. </span><span class="koboSpan" id="kobo.10.3">These operations happen very quickly, so it's quite possible t</span><span><span class="koboSpan" id="kobo.11.1">hat requests arrive at a pod before the application is ready</span></span><span class="koboSpan" id="kobo.12.1">, especially with bulky software. </span><span class="koboSpan" id="kobo.12.2">If a pod fails while running, we should remove it from the pool of a service instantly to make sure no requests reach a bad endpoint.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.13.1">The </span><kbd><span class="koboSpan" id="kobo.14.1">minReadySeconds</span></kbd><span class="koboSpan" id="kobo.15.1"> field of deployment and other controllers doesn't postpone a pod from becoming ready. </span><span class="koboSpan" id="kobo.15.2">Instead, it delays a pod from becoming available. </span><span class="koboSpan" id="kobo.15.3">A rollout is only </span><span><span class="koboSpan" id="kobo.16.1">successful if all pods are available.</span></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Liveness and readiness probes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A probe is an indicator of a container's health. </span><span class="koboSpan" id="kobo.2.2">It judges health through periodically performing diagnostic actions against a container via kubelet. </span><span class="koboSpan" id="kobo.2.3">There are two kinds of probes for determining the state of a container:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.3.1">Liveness</span></strong> <strong><span class="koboSpan" id="kobo.4.1">probe</span></strong><span class="koboSpan" id="kobo.5.1">: This indicates whether or not a container is alive. </span><span class="koboSpan" id="kobo.5.2">If a container fails on this probe, kubelet kills it and may restart it based on the </span><kbd><span class="koboSpan" id="kobo.6.1">restartPolicy</span></kbd><span class="koboSpan" id="kobo.7.1"> of a pod.</span></li>
<li><strong><span class="koboSpan" id="kobo.8.1">Readiness probe</span></strong><span class="koboSpan" id="kobo.9.1">: This indicates whether a container is ready for incoming traffic. </span><span class="koboSpan" id="kobo.9.2">If a pod behind a service isn't ready, its endpoint won't be created until the pod is ready.</span></li>
</ul>
<div class="packt_infobox"><span class="koboSpan" id="kobo.10.1">The </span><kbd><span class="koboSpan" id="kobo.11.1">restartPolicy</span></kbd><span class="koboSpan" id="kobo.12.1"> tells us how Kubernetes treats a pod on failures or terminations. </span><span class="koboSpan" id="kobo.12.2">It has three modes: </span><kbd><span class="koboSpan" id="kobo.13.1">Always</span></kbd><span class="koboSpan" id="kobo.14.1">, </span><kbd><span class="koboSpan" id="kobo.15.1">OnFailure</span></kbd><span class="koboSpan" id="kobo.16.1">, or </span><kbd><span class="koboSpan" id="kobo.17.1">Never</span></kbd><span class="koboSpan" id="kobo.18.1">. </span><span class="koboSpan" id="kobo.18.2">The default is set to </span><kbd><span class="koboSpan" id="kobo.19.1">Always</span></kbd><span class="koboSpan" id="kobo.20.1">.</span></div>
<p><span class="koboSpan" id="kobo.21.1">Three kinds of action handlers can be configured to diagnose a container:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.22.1">exec</span></kbd><span class="koboSpan" id="kobo.23.1">: This executes a defined command inside the container. </span><span class="koboSpan" id="kobo.23.2">It's considered to be successful if the exit code is </span><kbd><span class="koboSpan" id="kobo.24.1">0</span></kbd><span class="koboSpan" id="kobo.25.1">.</span></li>
<li><kbd><span class="koboSpan" id="kobo.26.1">tcpSocket</span></kbd><span class="koboSpan" id="kobo.27.1">: This tests a given port via TCP and is successful if the port is opened.</span></li>
</ul>
<ul>
<li><kbd><span class="koboSpan" id="kobo.28.1">httpGet</span></kbd><span class="koboSpan" id="kobo.29.1">: This performs </span><kbd><span class="koboSpan" id="kobo.30.1">HTTP GET</span></kbd><span class="koboSpan" id="kobo.31.1"> on the IP address of the target container. </span><span class="koboSpan" id="kobo.31.2">Headers in the request to be sent are customizable. </span><span class="koboSpan" id="kobo.31.3">This check is considered to be healthy if the status code satisfies </span><kbd><span class="koboSpan" id="kobo.32.1">400 &gt; CODE &gt;= 200</span></kbd><span class="koboSpan" id="kobo.33.1">.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.34.1">Additionally, there are five parameters that define a probe's behavior:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.35.1">initialDelaySeconds</span></kbd><span class="koboSpan" id="kobo.36.1">: How long kubelet should wait for before the first probing</span></li>
<li><kbd><span class="koboSpan" id="kobo.37.1">successThreshold</span></kbd><span class="koboSpan" id="kobo.38.1">: A container is considered to be healthy only if it got consecutive times of probing successes over this threshold</span></li>
<li><kbd><span class="koboSpan" id="kobo.39.1">failureThreshold</span></kbd><span class="koboSpan" id="kobo.40.1">: The same as the previous one, but defines the negative side instead</span></li>
<li><kbd><span class="koboSpan" id="kobo.41.1">timeoutSeconds</span></kbd><span class="koboSpan" id="kobo.42.1">: The time limitation of a single probe action</span></li>
<li><kbd><span class="koboSpan" id="kobo.43.1">periodSeconds</span></kbd><span class="koboSpan" id="kobo.44.1">: Intervals between probe actions</span></li>
</ul>
<p><span class="koboSpan" id="kobo.45.1">The following code snippet demonstrates the use of a readiness probe. </span><span class="koboSpan" id="kobo.45.2">The full template can be found at </span><a href="https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/blob/master/chapter9/9-3_on_pods/probe.yml"><span class="koboSpan" id="kobo.46.1">https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/blob/master/chapter9/9-3_on_pods/probe.yml</span></a><span class="koboSpan" id="kobo.47.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.48.1">...</span><br/><span class="koboSpan" id="kobo.49.1">     containers:</span><br/><span class="koboSpan" id="kobo.50.1">      - name: main</span><br/><span class="koboSpan" id="kobo.51.1">        image: devopswithkubernetes/okeydokey:v0.0.4</span><br/><span class="koboSpan" id="kobo.52.1">        readinessProbe:</span><br/><span class="koboSpan" id="kobo.53.1">          httpGet:</span><br/><span class="koboSpan" id="kobo.54.1">            path: /</span><br/><span class="koboSpan" id="kobo.55.1">            port: 5000</span><br/><span class="koboSpan" id="kobo.56.1">          periodSeconds: 5</span><br/><span class="koboSpan" id="kobo.57.1">          initialDelaySeconds: 10</span><br/><span class="koboSpan" id="kobo.58.1">          successThreshold: 2</span><br/><span class="koboSpan" id="kobo.59.1">          failureThreshold: 3</span><br/><span class="koboSpan" id="kobo.60.1">          timeoutSeconds: 1</span><br/><span class="koboSpan" id="kobo.61.1">        command:</span><br/><span class="koboSpan" id="kobo.62.1">...</span></strong></pre>
<p><span class="koboSpan" id="kobo.63.1">In this example, we used some tricks with our main application, which set the starting time of the application to around six seconds and replace the application </span><span><span class="koboSpan" id="kobo.64.1">after 20 seconds </span></span><span class="koboSpan" id="kobo.65.1">with another one that echoes </span><kbd><span class="koboSpan" id="kobo.66.1">HTTP 500</span></kbd><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">The application's interaction with the readiness probe is illustrated in the following diagram:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.68.1"><img class=" image-border" src="assets/eb1f7b10-2da5-418b-88a8-889ef9528d93.png" style="width:28.33em;height:11.00em;"/></span></div>
<p><span class="koboSpan" id="kobo.69.1">The upper timeline is a pod's real readiness, and the other one is its readiness from Kubernetes' perspective. </span><span class="koboSpan" id="kobo.69.2">The first probe executes 10 seconds after the pod is created, and the pod is regarded as ready after two probing successes. </span><span class="koboSpan" id="kobo.69.3">A few seconds later, the pod goes out of service due to the termination of our application, and it becomes unready after the next three failures. </span><span class="koboSpan" id="kobo.69.4">Try to deploy the preceding example and observe its output:</span></p>
<pre><strong><span class="koboSpan" id="kobo.70.1">$ kubectl logs -f my-app-6759578c94-kkc5k</span></strong><br/><strong><span class="koboSpan" id="kobo.71.1">1544137145.530593922 - [sys] pod is created.</span></strong><br/><strong><span class="koboSpan" id="kobo.72.1">1544137151.658855438 - [app] starting server.</span></strong><br/><strong><span class="koboSpan" id="kobo.73.1">1544137155.164726019 - [app] GET / HTTP/1.1</span></strong><br/><strong><span class="koboSpan" id="kobo.74.1">1544137160.165020704 - [app] GET / HTTP/1.1</span></strong><br/><strong><span class="koboSpan" id="kobo.75.1">1544137161.129309654 - [app] GET /from-tester</span></strong><br/><strong><span class="koboSpan" id="kobo.76.1">1544137165.141985178 - [app] GET /from-tester</span></strong><br/><strong><span class="koboSpan" id="kobo.77.1">1544137165.165597677 - [app] GET / HTTP/1.1</span></strong><br/><strong><span class="koboSpan" id="kobo.78.1">1544137168.533407211 - [app] stopping server.</span></strong><br/><strong><span class="koboSpan" id="kobo.79.1">1544137170.169371453 - [500] readiness test fail#1</span></strong><br/><strong><span class="koboSpan" id="kobo.80.1">1544137175.180640604 - [500] readiness test fail#2</span><br/><span class="koboSpan" id="kobo.81.1">1544137180.171766986 - [500] readiness test fail#3</span></strong><br/><strong><span class="koboSpan" id="kobo.82.1">...</span></strong></pre>
<p><span class="koboSpan" id="kobo.83.1">In our example file, there is another pod, </span><kbd><span class="koboSpan" id="kobo.84.1">tester</span></kbd><span class="koboSpan" id="kobo.85.1">, which is constantly making requests to our service and the log entries. </span><kbd><span class="koboSpan" id="kobo.86.1">/from-tester</span></kbd><span class="koboSpan" id="kobo.87.1"> in our service represents the requests from the tester. </span><span class="koboSpan" id="kobo.87.2">From the tester's activity logs, we can observe that the traffic from </span><kbd><span class="koboSpan" id="kobo.88.1">tester</span></kbd><span class="koboSpan" id="kobo.89.1"> is stopped after our service becomes unready (notice the activities of two pods around the time </span><kbd><span class="koboSpan" id="kobo.90.1">1544137180</span></kbd><span class="koboSpan" id="kobo.91.1">):</span></p>
<pre><strong><span class="koboSpan" id="kobo.92.1">$ kubectl logs tester</span><br/><span class="koboSpan" id="kobo.93.1">1544137141.107777059 - timed out</span><br/><span class="koboSpan" id="kobo.94.1">1544137147.116839441 - timed out</span><br/><span class="koboSpan" id="kobo.95.1">1544137154.078540367 - timed out</span><br/><span class="koboSpan" id="kobo.96.1">1544137160.094933434 - OK</span><br/><span class="koboSpan" id="kobo.97.1">1544137165.136757412 - OK</span><br/><span class="koboSpan" id="kobo.98.1">1544137169.155453804 -</span><br/><span class="koboSpan" id="kobo.99.1">1544137173.161426446 - HTTP/1.1 500</span><br/><span class="koboSpan" id="kobo.100.1">1544137177.167556193 - HTTP/1.1 500</span><br/><span class="koboSpan" id="kobo.101.1">1544137181.173484008 - timed out</span><br/><span class="koboSpan" id="kobo.102.1">1544137187.189133495 - timed out</span><br/><span class="koboSpan" id="kobo.103.1">1544137193.198797682 - timed out</span><br/><span class="koboSpan" id="kobo.104.1">...</span></strong></pre>
<p><span class="koboSpan" id="kobo.105.1">Since we didn't configure the liveness probe in our service, the unhealthy container won't be restarted unless we kill it manually. </span><span class="koboSpan" id="kobo.105.2">In general, we would use both probes together to automate the healing process.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Custom readiness gate</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">The testing targets of the readiness probe are always containers, which means that it can't be used to disable a pod from a</span></span><span class="koboSpan" id="kobo.3.1"> service </span><span><span class="koboSpan" id="kobo.4.1">by using external states. </span><span class="koboSpan" id="kobo.4.2">Since a service selects pods by their labels, we can control the traffic to pods by manipulating pod labels to a certain extent. </span><span class="koboSpan" id="kobo.4.3">However, pod labels are also read by other components inside Kubernetes, so</span></span><span><span class="koboSpan" id="kobo.5.1"> </span></span><span><span class="koboSpan" id="kobo.6.1">building complex toggles with labels </span></span><span><span class="koboSpan" id="kobo.7.1">could lead to unexpected results.</span></span></p>
<p><span><span class="koboSpan" id="kobo.8.1">The pod readiness gate is the feature that allows us to mark whether a pod is ready or not, based on the conditions we defined. </span><span class="koboSpan" id="kobo.8.2">With the pod readiness gates defined, a pod is regarded as ready only if its readiness probe passes and the status of all readiness gates associated with the pod is </span><kbd><span class="koboSpan" id="kobo.9.1">True</span></kbd><span class="koboSpan" id="kobo.10.1">. </span></span><span class="koboSpan" id="kobo.11.1">We can define the readiness gate as shown in the following snippet:</span></p>
<pre><strong><span class="koboSpan" id="kobo.12.1">...</span></strong><br/><strong><span class="koboSpan" id="kobo.13.1">    spec:</span></strong><br/><strong><span class="koboSpan" id="kobo.14.1">      readinessGates:</span></strong><br/><strong><span class="koboSpan" id="kobo.15.1">      - conditionType: &lt;value&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.16.1">      containers:</span></strong><br/><strong><span class="koboSpan" id="kobo.17.1">      - name: main</span></strong><br/><strong><span class="koboSpan" id="kobo.18.1">...</span></strong></pre>
<p><span class="koboSpan" id="kobo.19.1">The value must follow the format of a label key such as </span><kbd><span class="koboSpan" id="kobo.20.1">feature_1</span></kbd><span class="koboSpan" id="kobo.21.1"> or </span><kbd><span class="koboSpan" id="kobo.22.1">myorg.com/fg-2</span></kbd><span class="koboSpan" id="kobo.23.1">.</span></p>
<p><span class="koboSpan" id="kobo.24.1">When a pod starts, a condition type we defined will be populated as a condition under a pod's </span><kbd><span class="koboSpan" id="kobo.25.1">.status.conditions[]</span></kbd><span class="koboSpan" id="kobo.26.1"> path, and we have to explicitly set the condition to </span><kbd><span class="koboSpan" id="kobo.27.1">True</span></kbd><span class="koboSpan" id="kobo.28.1"> to mark a pod ready. </span><span class="koboSpan" id="kobo.28.2">As for Kubernetes 1.13, the only way to edit the condition is with the </span><kbd><span class="koboSpan" id="kobo.29.1">patch</span></kbd><span class="koboSpan" id="kobo.30.1"> API. </span><span class="koboSpan" id="kobo.30.2">Let's see an example at </span><a href="https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/blob/master/chapter9/9-3_on_pods/readiness_gates.yml"><span class="koboSpan" id="kobo.31.1">https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/blob/master/chapter9/9-3_on_pods/readiness_gates.yml</span></a><span class="koboSpan" id="kobo.32.1">:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.33.1">$ cat </span></span></strong><strong><span><span class="koboSpan" id="kobo.34.1">chapter9/9-3_on_pods/readiness_gates.yml </span></span></strong><strong><span><span class="koboSpan" id="kobo.35.1">| grep readinessGates -C 1</span><br/><span class="koboSpan" id="kobo.36.1">    spec:</span><br/><span class="koboSpan" id="kobo.37.1">      readinessGates:</span><br/><span class="koboSpan" id="kobo.38.1">      - conditionType: "MY-GATE-1"</span><br/><br/><span class="koboSpan" id="kobo.39.1">$ kubectl apply -f chapter9/9-3_on_pods/readiness_gates.yml</span><br/><span class="koboSpan" id="kobo.40.1">deployment.apps/my-2nd-app created</span><br/><span class="koboSpan" id="kobo.41.1">service/my-2nd-app-svc created</span><br/><br/><span class="koboSpan" id="kobo.42.1">$ kubectl get pod -o custom-columns=NAME:.metadata.name,IP:.status.podIP</span><br/><span class="koboSpan" id="kobo.43.1">NAME                          IP</span><br/><span class="koboSpan" id="kobo.44.1">my-2nd-app-78786c6d5d-t4564   172.17.0.2</span><br/><br/><span class="koboSpan" id="kobo.45.1">$ kubectl logs my-2nd-app-78786c6d5d-t4564</span><br/><span class="koboSpan" id="kobo.46.1">1544216932.875020742 - [app] starting server.</span><br/><br/><span class="koboSpan" id="kobo.47.1">$ kubectl describe ep my-2nd-app-svc</span><br/><span class="koboSpan" id="kobo.48.1">Name: my-2nd-app-svc</span><br/><span class="koboSpan" id="kobo.49.1">Namespace: default</span><br/><span class="koboSpan" id="kobo.50.1">Labels: app=my-2nd-app</span><br/><span class="koboSpan" id="kobo.51.1">Annotations: &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.52.1">Subsets:</span><br/><span class="koboSpan" id="kobo.53.1">  Addresses: &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.54.1">  NotReadyAddresses: 172.17.0.2</span><br/><span class="koboSpan" id="kobo.55.1">...</span><br/></span></strong></pre>
<p><span class="koboSpan" id="kobo.56.1">Here, our custom condition is called </span><kbd><span class="koboSpan" id="kobo.57.1">MY-GATE-1</span></kbd><span class="koboSpan" id="kobo.58.1"> and the application is the one that we have used throughout this chapter. </span><span class="koboSpan" id="kobo.58.2">As we can see, even if the pod has started, its address is still listed in </span><kbd><span class="koboSpan" id="kobo.59.1">NotReadyAddresses</span></kbd><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">This means that the pod isn't taking any traffic. </span><span class="koboSpan" id="kobo.60.3">We can verify its status with </span><kbd><span class="koboSpan" id="kobo.61.1">describe</span></kbd><span class="koboSpan" id="kobo.62.1"> (or </span><kbd><span class="koboSpan" id="kobo.63.1">wide</span></kbd><span class="koboSpan" id="kobo.64.1">/</span><kbd><span class="koboSpan" id="kobo.65.1">json</span></kbd><span class="koboSpan" id="kobo.66.1">/</span><kbd><span class="koboSpan" id="kobo.67.1">yaml</span></kbd><span class="koboSpan" id="kobo.68.1">):</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.69.1">$ kubectl describe pod my-2nd-app-78786c6d5d-t4564</span><br/><span class="koboSpan" id="kobo.70.1">...</span><br/><span class="koboSpan" id="kobo.71.1">Readiness Gates:</span><br/><span class="koboSpan" id="kobo.72.1">  Type        Status</span><br/><span class="koboSpan" id="kobo.73.1">  MY-GATE-1   &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.74.1">Conditions:</span><br/><span class="koboSpan" id="kobo.75.1">  Type              Status</span><br/><span class="koboSpan" id="kobo.76.1">  Initialized       True</span><br/><span class="koboSpan" id="kobo.77.1">  Ready             False</span><br/><span class="koboSpan" id="kobo.78.1">  ContainersReady   True</span><br/><span class="koboSpan" id="kobo.79.1">  PodScheduled      True</span><br/><span class="koboSpan" id="kobo.80.1">...</span></span></strong></pre>
<p><span><span class="koboSpan" id="kobo.81.1">The container in the pod is ready, but the pod itself isn't ready due to the readiness gates. </span></span><span><span class="koboSpan" id="kobo.82.1">To toggle it on, we'll need to make a request to the API server with a </span><strong><span class="koboSpan" id="kobo.83.1">JSON Patch</span></strong><span class="koboSpan" id="kobo.84.1"> payload to </span><kbd><span class="koboSpan" id="kobo.85.1">/api/v1/namespaces/&lt;namespace&gt;/pods/&lt;pod_name&gt;/status</span></kbd><span class="koboSpan" id="kobo.86.1">:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.87.1">$ kubectl proxy &amp;</span></strong><br/><strong><span class="koboSpan" id="kobo.88.1">$ curl http://localhost:8001/api/v1/namespaces/default/pods/</span><span><span class="koboSpan" id="kobo.89.1">my-2nd-app-78786c6d5d-t4564</span></span><span class="koboSpan" id="kobo.90.1">/status \</span></strong><br/><strong><span class="koboSpan" id="kobo.91.1">-XPATCH -H "Content-Type: application/json-patch+json" -d \</span></strong><br/><strong><span class="koboSpan" id="kobo.92.1">'[{"op":"add","path":"/status/conditions/-","value":{"type":"</span><span><span class="koboSpan" id="kobo.93.1">MY-GATE-1</span></span><span class="koboSpan" id="kobo.94.1">", "status": "True"}}]'</span><br/><span class="koboSpan" id="kobo.95.1">...</span><br/><span class="koboSpan" id="kobo.96.1">  "status": {</span><br/><span class="koboSpan" id="kobo.97.1">    "phase": "Running",</span><br/><span class="koboSpan" id="kobo.98.1">    "conditions": [</span><br/><span class="koboSpan" id="kobo.99.1">...</span><br/><span class="koboSpan" id="kobo.100.1">      {</span><br/><span class="koboSpan" id="kobo.101.1">        "type": "MY-GATE-1",</span><br/><span class="koboSpan" id="kobo.102.1">        "status": "True",</span><br/><span class="koboSpan" id="kobo.103.1">        "lastProbeTime": null,</span><br/><span class="koboSpan" id="kobo.104.1">        "lastTransitionTime": null</span><br/><span class="koboSpan" id="kobo.105.1">      }</span><br/><span class="koboSpan" id="kobo.106.1">...</span></strong></pre>
<p><span class="koboSpan" id="kobo.107.1">We'll see that an entry will be inserted into the </span><kbd><span class="koboSpan" id="kobo.108.1">.status.conditions</span></kbd><span class="koboSpan" id="kobo.109.1"> list. </span><span class="koboSpan" id="kobo.109.2">Now, if we check the endpoints of the service, we can see that the pod has started to serve requests:</span></p>
<pre><strong><span class="koboSpan" id="kobo.110.1">$ kubectl describe ep my-2nd-app-svc</span></strong><br/><strong><span class="koboSpan" id="kobo.111.1">Name: my-2nd-app-svc</span></strong><br/><strong><span class="koboSpan" id="kobo.112.1">Namespace: default</span></strong><br/><strong><span class="koboSpan" id="kobo.113.1">Labels: app=my-2nd-app</span></strong><br/><strong><span class="koboSpan" id="kobo.114.1">Annotations: &lt;none&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.115.1">Subsets:</span></strong><br/><strong><span class="koboSpan" id="kobo.116.1">  Addresses: 172.17.0.2</span></strong><br/><strong><span class="koboSpan" id="kobo.117.1">...</span><br/><span class="koboSpan" id="kobo.118.1">## also the status of the gates:</span><br/><span class="koboSpan" id="kobo.119.1">$ kubectl describe pod my-2nd-app-78786c6d5d-t4564 | grep -A2 Readiness</span><br/><span class="koboSpan" id="kobo.120.1">Readiness Gates:</span><br/><span class="koboSpan" id="kobo.121.1">  Type        Status</span><br/><span class="koboSpan" id="kobo.122.1">  MY-GATE-1   True</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.123.1">To put the pod in the other way around, we could use the </span><kbd><span class="koboSpan" id="kobo.124.1">replace</span></kbd><span class="koboSpan" id="kobo.125.1"> or </span><kbd><span class="koboSpan" id="kobo.126.1">remove</span></kbd><span class="koboSpan" id="kobo.127.1"> operation of JSON Patch to set the condition's status to </span><kbd><span class="koboSpan" id="kobo.128.1">False</span></kbd><span class="koboSpan" id="kobo.129.1"> or </span><kbd><span class="koboSpan" id="kobo.130.1">&lt;none&gt;</span></kbd><span class="koboSpan" id="kobo.131.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.132.1">## we need the index of our gate, and we use jq to query it here:</span></strong><br/><strong><span class="koboSpan" id="kobo.133.1">$ export RG_NAME="MY-GATE-1"</span></strong><br/><strong><span class="koboSpan" id="kobo.134.1">$ kubectl get pod my-2nd-app-78786c6d5d-t4564 -o json | jq --arg R "$RG_NAME" 'foreach .status.conditions[] as $e (-1; .+1; select($e.type == $R))'</span></strong><br/><strong><span class="koboSpan" id="kobo.135.1">0</span></strong><br/><strong><span class="koboSpan" id="kobo.136.1">$ kubectl proxy &amp;</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.137.1">## fill the queried "0" to the path parameter</span></strong><br/><strong><span class="koboSpan" id="kobo.138.1">$ curl http://localhost:8001/api/v1/namespaces/default/pods/my-2nd-app-78786c6d5d-t4564/status \</span></strong><br/><strong><span class="koboSpan" id="kobo.139.1">-XPATCH -H "Content-Type: application/json-patch+json" -d \</span></strong><br/><strong><span class="koboSpan" id="kobo.140.1">'[{"op":"replace","path":"/status/conditions/0","value":{"type":"MY-GATE-1", "status": "False"}}]'</span></strong><br/><strong><span class="koboSpan" id="kobo.141.1">...</span></strong><br/><strong><span class="koboSpan" id="kobo.142.1">$ kubectl describe ep my-2nd-app-svc | grep -B2 NotReadyAddresses</span></strong><br/><strong><span class="koboSpan" id="kobo.143.1">Subsets:</span></strong><br/><strong><span class="koboSpan" id="kobo.144.1">  Addresses: &lt;none&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.145.1">  NotReadyAddresses: 172.17.0.2</span></strong></pre>
<p><span class="koboSpan" id="kobo.146.1">The pod now becomes unready again. </span><span class="koboSpan" id="kobo.146.2">With the readiness gate, we can nicely separate the logic of toggling business features and managing labels.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">init containers</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">At times we'll need to initialize our application before it actually runs, such as by preparing schema for the main application or loading data from another place. </span><span class="koboSpan" id="kobo.2.2">As it's</span></span><span class="koboSpan" id="kobo.3.1"> difficult</span><span><span class="koboSpan" id="kobo.4.1"> to predict how long the initialization could take, we can't simply rely on </span></span><span><kbd><span class="koboSpan" id="kobo.5.1">initialDelaySeconds</span></kbd><span class="koboSpan" id="kobo.6.1"> to create a buffer for this preparation, so</span></span><span><span class="koboSpan" id="kobo.7.1"> </span></span><kbd><span class="koboSpan" id="kobo.8.1">init</span></kbd> <span><span class="koboSpan" id="kobo.9.1">containers come in handy here.</span></span></p>
<p><kbd><span class="koboSpan" id="kobo.10.1">init</span></kbd><span class="koboSpan" id="kobo.11.1"> containers are one or more containers that start prior to application containers and run one by one to completion in order. </span><span class="koboSpan" id="kobo.11.2">If any container fails, it's subject to the </span><kbd><span class="koboSpan" id="kobo.12.1">restartPolicy</span></kbd><span class="koboSpan" id="kobo.13.1"> of a pod and starts over again until all containers are exited with code </span><kbd><span class="koboSpan" id="kobo.14.1">0</span></kbd><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">Defining </span><kbd><span class="koboSpan" id="kobo.16.1">init</span></kbd><span class="koboSpan" id="kobo.17.1"> containers is similar to defining regular containers:</span></p>
<pre><strong><span class="koboSpan" id="kobo.18.1">...</span><br/><span class="koboSpan" id="kobo.19.1">spec:</span><br/><span class="koboSpan" id="kobo.20.1">  containers:</span><br/><span class="koboSpan" id="kobo.21.1">  - name: my-app</span><br/><span class="koboSpan" id="kobo.22.1">    image: &lt;my-app&gt;</span><br/><span class="koboSpan" id="kobo.23.1">  initContainers:</span><br/><span class="koboSpan" id="kobo.24.1">  - name: init-my-app</span><br/><span class="koboSpan" id="kobo.25.1">    image: &lt;init-my-app&gt;</span><br/><span class="koboSpan" id="kobo.26.1">...</span></strong></pre>
<p><span class="koboSpan" id="kobo.27.1">They only differ in the following respects:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.28.1">init</span></kbd><span class="koboSpan" id="kobo.29.1"> containers don't have readiness probes as they run to completion.</span></li>
<li><span class="koboSpan" id="kobo.30.1">The port defined in </span><kbd><span class="koboSpan" id="kobo.31.1">init</span></kbd><span class="koboSpan" id="kobo.32.1"> containers won't be captured by the service in front of the pod.</span></li>
</ul>
<ul>
<li><span class="koboSpan" id="kobo.33.1">The request limit of resources are calculated with </span><kbd><span class="koboSpan" id="kobo.34.1">max(sum(regular containers)</span></kbd><span class="koboSpan" id="kobo.35.1">, and </span><kbd><span class="koboSpan" id="kobo.36.1">max(init containers))</span></kbd><span class="koboSpan" id="kobo.37.1">, which means if one of the </span><kbd><span class="koboSpan" id="kobo.38.1">init</span></kbd><span class="koboSpan" id="kobo.39.1"> containers sets a higher resource limit than other </span><kbd><span class="koboSpan" id="kobo.40.1">init</span></kbd><span class="koboSpan" id="kobo.41.1"> containers, as well as the sum of the resource limits of all regular containers, Kubernetes schedules the pod according to the </span><kbd><span class="koboSpan" id="kobo.42.1">init</span></kbd><span class="koboSpan" id="kobo.43.1"> container's resource limit.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.44.1">The usefulness of </span><kbd><span class="koboSpan" id="kobo.45.1">init</span></kbd><span class="koboSpan" id="kobo.46.1"> containers is more than blocking the application containers. </span><span class="koboSpan" id="kobo.46.2">For instance, we can utilize an </span><kbd><span class="koboSpan" id="kobo.47.1">init</span></kbd><span class="koboSpan" id="kobo.48.1"> container to configure an image by sharing an </span><kbd><span class="koboSpan" id="kobo.49.1">emptyDir</span></kbd><span class="koboSpan" id="kobo.50.1"> volume with </span><kbd><span class="koboSpan" id="kobo.51.1">init</span></kbd><span class="koboSpan" id="kobo.52.1"> containers and application containers, </span><span><span class="koboSpan" id="kobo.53.1">instead of building another image that only runs</span></span> <kbd><span class="koboSpan" id="kobo.54.1">awk</span></kbd><span><span class="koboSpan" id="kobo.55.1">/</span></span><kbd><span class="koboSpan" id="kobo.56.1">sed</span></kbd> <span><span class="koboSpan" id="kobo.57.1">on the base image. </span><span class="koboSpan" id="kobo.57.2">Also, it grants us the flexibility to use different images for initialization tasks and the main application.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Terminating a pod</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The sequence of shutdown events is similar to events while starting a pod. </span><span class="koboSpan" id="kobo.2.2">After receiving a deletion invocation, Kubernetes sends </span><kbd><span class="koboSpan" id="kobo.3.1">SIGTERM</span></kbd><span class="koboSpan" id="kobo.4.1"> to the pod that is going to be deleted, and the pod's state becomes terminating. </span><span class="koboSpan" id="kobo.4.2">Meanwhile, Kubernetes removes the endpoint of that pod to stop further requests if the pod is backing a service. </span><span class="koboSpan" id="kobo.4.3">Occasionally, there are pods that don't quit at all. </span><span class="koboSpan" id="kobo.4.4">It could be that the pods don't honor </span><kbd><span class="koboSpan" id="kobo.5.1">SIGTERM</span></kbd><span class="koboSpan" id="kobo.6.1">, or simply because their tasks aren't completed. </span><span class="koboSpan" id="kobo.6.2">Under such circumstances, Kubernetes will send </span><kbd><span class="koboSpan" id="kobo.7.1">SIGKILL</span></kbd><span class="koboSpan" id="kobo.8.1"> to forcibly kill those pods after the termination period. </span><span class="koboSpan" id="kobo.8.2">The period length is set at </span><kbd><span class="koboSpan" id="kobo.9.1">.spec.terminationGracePeriodSeconds</span></kbd><span class="koboSpan" id="kobo.10.1"> under the pod specification. </span><span class="koboSpan" id="kobo.10.2">Even though Kubernetes has mechanisms to reclaim such pods anyway, we still should make sure our pods can be closed properly.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Handling SIGTERM</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Graceful termination isn't a new idea; it is a common practice in programming. </span><span class="koboSpan" id="kobo.2.2">Killing a pod forcibly while it's still working is like suddenly unplugging the power cord of a running computer, which could harm the data. </span></p>
<p><span class="koboSpan" id="kobo.3.1">The implementation </span><span><span class="koboSpan" id="kobo.4.1">principally </span></span><span class="koboSpan" id="kobo.5.1">includes three steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.6.1">Register a handler to capture termination signals.</span></li>
<li><span class="koboSpan" id="kobo.7.1">Do everything required in the handler, such as freeing resources, writing data to external persistent layers, releasing distribution locks, or closing connections.</span></li>
</ol>
<ol start="3">
<li><span class="koboSpan" id="kobo.8.1">Perform a program shutdown. </span><span class="koboSpan" id="kobo.8.2">Our previous example demonstrates the idea: closing the controller thread on </span><kbd><span class="koboSpan" id="kobo.9.1">SIGTERM</span></kbd><span class="koboSpan" id="kobo.10.1"> in the </span><kbd><span class="koboSpan" id="kobo.11.1">graceful_exit_handler</span></kbd><span class="koboSpan" id="kobo.12.1"> handler. </span><span class="koboSpan" id="kobo.12.2">The code can be found here: </span><a href="https://github.com/DevOps-with-Kubernetes/okeydokey/blob/master/app.py"><span class="koboSpan" id="kobo.13.1">https://github.com/DevOps-with-Kubernetes/okeydokey/blob/master/app.py</span></a><span class="koboSpan" id="kobo.14.1">.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.15.1">Due to the fact that Kubernetes can only send signals to the </span><kbd><span class="koboSpan" id="kobo.16.1">PID 1</span></kbd><span class="koboSpan" id="kobo.17.1"> process in a container, there are some common pitfalls that could fail the graceful handler in our program.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">SIGTERM isn't sent to the application process</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In </span><span class="ChapterrefPACKT"><a href="05e2d0b4-0e70-4480-b5a0-f3860ddb24f2.xhtml"><span class="koboSpan" id="kobo.3.1">Chapter 2</span></a><span class="koboSpan" id="kobo.4.1">,</span></span> <em><span class="koboSpan" id="kobo.5.1">DevOps with Containers</span></em><span class="koboSpan" id="kobo.6.1">, we learned there are two forms to invoke our program when writing a Dockerfile: the shell form and the exec form. </span><span class="koboSpan" id="kobo.6.2">The shell to run the shell form commands defaults to </span><kbd><span class="koboSpan" id="kobo.7.1">/bin/sh -c</span></kbd><span class="koboSpan" id="kobo.8.1"> on Linux containers. </span><span class="koboSpan" id="kobo.8.2">Hence, there are a few questions related to whether </span><kbd><span class="koboSpan" id="kobo.9.1">SIGTERM</span></kbd><span class="koboSpan" id="kobo.10.1"> can be received by our applications:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">How is our application invoked?</span></li>
<li><span class="koboSpan" id="kobo.12.1">What shell implementation is used in the image?</span></li>
<li><span class="koboSpan" id="kobo.13.1">How does the </span><span><span class="koboSpan" id="kobo.14.1">shell implementation deal with the </span><kbd><span class="koboSpan" id="kobo.15.1">-c</span></kbd><span class="koboSpan" id="kobo.16.1"> parameter?</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">Let's approach these questions one by one. </span><span class="koboSpan" id="kobo.17.2">The Dockerfile used in the following example can be found here: </span><a href="https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter9/9-3_on_pods/graceful_docker"><span class="koboSpan" id="kobo.18.1">https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter9/9-3_on_pods/graceful_docker</span></a><span class="koboSpan" id="kobo.19.1">.</span></p>
<p><span class="koboSpan" id="kobo.20.1">Say we're using the shell form command, </span><kbd><span class="koboSpan" id="kobo.21.1">CMD python -u app.py</span></kbd><span class="koboSpan" id="kobo.22.1">, in our Dockerfile to execute our application. </span><span class="koboSpan" id="kobo.22.2">The starting command of the container would be </span><kbd><span class="koboSpan" id="kobo.23.1">/bin/sh -c "python3 -u app.py"</span></kbd><span class="koboSpan" id="kobo.24.1">. </span><span class="koboSpan" id="kobo.24.2">When the container starts, the structure of the </span><span><span class="koboSpan" id="kobo.25.1">processes</span></span><span class="koboSpan" id="kobo.26.1"> inside it is as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.27.1"># the image is from "graceful_docker/Dockerfile.shell-sh"</span><br/><span class="koboSpan" id="kobo.28.1">$ kubectl run --generator=run-pod/v1 \</span><br/><span class="koboSpan" id="kobo.29.1">--image=devopswithkubernetes/ch93:shell-sh my-app</span></strong><br/><strong><span class="koboSpan" id="kobo.30.1">pod/my-app created</span></strong><br/><strong><span class="koboSpan" id="kobo.31.1">$ kubectl exec my-app ps ax</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">  PID TTY      STAT   TIME COMMAND</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">    1 ?        </span><span class="koboSpan" id="kobo.33.2">Ss     0:00 /bin/sh -c python3 -u app.py</span></strong><br/><strong><span class="koboSpan" id="kobo.34.1">    6 ?        </span><span class="koboSpan" id="kobo.34.2">S      0:00 python3 -u app.py</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">    7 ?        </span><span class="koboSpan" id="kobo.35.2">Rs     0:00 ps ax</span></strong></pre>
<p><span class="koboSpan" id="kobo.36.1">We can see that the </span><kbd><span class="koboSpan" id="kobo.37.1">PID 1</span></kbd><span class="koboSpan" id="kobo.38.1"> process isn't our application with handlers; it's the shell instead. </span><span class="koboSpan" id="kobo.38.2">When we try to kill the pod, </span><kbd><span class="koboSpan" id="kobo.39.1">SIGTERM</span></kbd><span class="koboSpan" id="kobo.40.1"> will be sent to the shell rather than to our application, and the pod will be terminated after the grace period expires. </span><span class="koboSpan" id="kobo.40.2">We can check the log in our application when deleting it to see whether it received </span><kbd><span><span class="koboSpan" id="kobo.41.1">SIGTERM</span></span></kbd><span class="koboSpan" id="kobo.42.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.43.1">$ kubectl delete pod my-app &amp;</span></strong><br/><strong><span class="koboSpan" id="kobo.44.1">pod "my-app" deleted</span></strong><br/><strong><span class="koboSpan" id="kobo.45.1">$ kubectl logs -f my-app</span></strong><br/><strong><span class="koboSpan" id="kobo.46.1">$ 1544368565.736720800 - [app] starting server.</span></strong><br/><strong><span class="koboSpan" id="kobo.47.1">rpc error: code = Unknown desc = Error: No such container: 2f007593553cfb700b0aece1f8b6045b4096b2f50f97a42e684a98e502af29ed</span></strong></pre>
<p><span class="koboSpan" id="kobo.48.1">Our application exited without going to the stop handler in the code. </span><span class="koboSpan" id="kobo.48.2">There are a couple of ways to properly promote our application to </span><kbd><span class="koboSpan" id="kobo.49.1">PID 1</span></kbd><span class="koboSpan" id="kobo.50.1">. </span><span class="koboSpan" id="kobo.50.2">For example, we can explicitly call </span><kbd><span class="koboSpan" id="kobo.51.1">exec</span></kbd><span class="koboSpan" id="kobo.52.1"> in the shell form, such as </span><kbd><span class="koboSpan" id="kobo.53.1">CMD exec python3 -u app.py</span></kbd><span class="koboSpan" id="kobo.54.1">, so that our program will inherit </span><kbd><span class="koboSpan" id="kobo.55.1">PID 1</span></kbd><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">Or, we can choose the </span><kbd><span class="koboSpan" id="kobo.57.1">exec</span></kbd><span class="koboSpan" id="kobo.58.1"> form, </span><span><kbd><span class="koboSpan" id="kobo.59.1">CMD [ "python3", "-u", "app.py" ]</span></kbd><span class="koboSpan" id="kobo.60.1">,</span></span><span class="koboSpan" id="kobo.61.1"> to execute our program directly:</span></p>
<pre><strong><span class="koboSpan" id="kobo.62.1">## shell form with exec</span></strong><br/><strong><span class="koboSpan" id="kobo.63.1">$ kubectl run --generator=run-pod/v1 \</span></strong><br/><strong><span class="koboSpan" id="kobo.64.1">--image=devopswithkubernetes/ch93:shell-exec my-app-shell-exec</span></strong><br/><strong><span class="koboSpan" id="kobo.65.1">pod/my-app-shell-exec created</span></strong><br/><strong><span class="koboSpan" id="kobo.66.1">$ kubectl exec my-app-exec ps ax</span></strong><br/><strong><span class="koboSpan" id="kobo.67.1">  PID TTY      STAT   TIME COMMAND</span></strong><br/><strong><span class="koboSpan" id="kobo.68.1">    1 ?        </span><span class="koboSpan" id="kobo.68.2">Ss     0:00 python3 -u app.py</span></strong><br/><strong><span class="koboSpan" id="kobo.69.1">    5 ?        </span><span class="koboSpan" id="kobo.69.2">Rs     0:00 ps ax</span></strong><br/><strong><span class="koboSpan" id="kobo.70.1">## delete the pod in another terminal</span></strong><br/><strong><span class="koboSpan" id="kobo.71.1">$ kubectl logs -f my-app-shell-exec</span></strong><br/><strong><span class="koboSpan" id="kobo.72.1">1544368913.313778162 - [app] starting server.</span></strong><br/><strong><span class="koboSpan" id="kobo.73.1">1544369448.991261721 - [app] stopping server.</span></strong><br/><strong><span class="koboSpan" id="kobo.74.1">rpc error: code = Unknown desc =...</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.75.1">## exec form</span></strong><br/><strong><span class="koboSpan" id="kobo.76.1">$ kubectl run --generator=run-pod/v1 \</span></strong><br/><strong><span class="koboSpan" id="kobo.77.1">--image=devopswithkubernetes/ch93:exec-sh my-app-exec</span></strong><br/><strong><span class="koboSpan" id="kobo.78.1">pod/my-app-exec created</span></strong><br/><strong><span class="koboSpan" id="kobo.79.1">  PID TTY      STAT   TIME COMMAND</span></strong><br/><strong><span class="koboSpan" id="kobo.80.1">    1 ?        </span><span class="koboSpan" id="kobo.80.2">Ss     0:00 python3 -u app.py</span></strong><br/><strong><span class="koboSpan" id="kobo.81.1">    5 ?        </span><span class="koboSpan" id="kobo.81.2">Rs     0:00 ps ax</span></strong><br/><strong><span class="koboSpan" id="kobo.82.1">$ kubectl logs -f my-app-exec</span></strong><br/><strong><span class="koboSpan" id="kobo.83.1">1544368942.935727358 - [app] starting server.</span></strong><br/><strong><span class="koboSpan" id="kobo.84.1">1544369503.846865654 - [app] stopping server.</span></strong><br/><strong><span class="koboSpan" id="kobo.85.1">rpc error: code = Unknown desc =...</span></strong></pre>
<p><span class="koboSpan" id="kobo.86.1">The program, executed in either way, can now receive </span><kbd><span class="koboSpan" id="kobo.87.1">SIGTERM</span></kbd><span class="koboSpan" id="kobo.88.1"> properly. </span><span class="koboSpan" id="kobo.88.2">Besides, if we need to set up the environment with a shell script for our program, we should either trap signals in the script to propagate them to our program, or use the exec call to invoke our program so that the handler in our application is able to work as desired.</span></p>
<p><span class="koboSpan" id="kobo.89.1">The second and the third questions are about the shell implication: how could it affect our graceful handler? </span><span class="koboSpan" id="kobo.89.2">Again, the default command of a Docker container in Linux is </span><kbd><span class="koboSpan" id="kobo.90.1">/bin/sh -c</span></kbd><span class="koboSpan" id="kobo.91.1">. </span><span class="koboSpan" id="kobo.91.2">As </span><kbd><span class="koboSpan" id="kobo.92.1">sh</span></kbd><span class="koboSpan" id="kobo.93.1"> differs among popular Docker images, the way it handles </span><kbd><span class="koboSpan" id="kobo.94.1">-c</span></kbd><span class="koboSpan" id="kobo.95.1"> could also affect the signals if we're using the shell form. </span><span class="koboSpan" id="kobo.95.2">For example, Alpine Linux links </span><kbd><span class="koboSpan" id="kobo.96.1">ash</span></kbd><span class="koboSpan" id="kobo.97.1"> to </span><kbd><span class="koboSpan" id="kobo.98.1">/bin/sh</span></kbd><span class="koboSpan" id="kobo.99.1">, and the Debian family of distributions use </span><kbd><span class="koboSpan" id="kobo.100.1">dash</span></kbd><span class="koboSpan" id="kobo.101.1">. </span><span class="koboSpan" id="kobo.101.2">Before Alpine 3.8 (or BusyBox 1.28.0), </span><kbd><span class="koboSpan" id="kobo.102.1">ash</span></kbd><span class="koboSpan" id="kobo.103.1"> forks a new process when using </span><kbd><span class="koboSpan" id="kobo.104.1">sh -c</span></kbd><span class="koboSpan" id="kobo.105.1">, and it uses </span><kbd><span class="koboSpan" id="kobo.106.1">exec</span></kbd><span class="koboSpan" id="kobo.107.1"> in 3.8. </span><span class="koboSpan" id="kobo.107.2">We can observe the difference with </span><kbd><span class="koboSpan" id="kobo.108.1">ps</span></kbd><span class="koboSpan" id="kobo.109.1">, where we can see the one in 3.7 gets </span><kbd><span class="koboSpan" id="kobo.110.1">PID 6</span></kbd><span class="koboSpan" id="kobo.111.1"> while it's </span><kbd><span class="koboSpan" id="kobo.112.1">PID 1</span></kbd><span class="koboSpan" id="kobo.113.1"> in 3.8:</span></p>
<pre><strong><span class="koboSpan" id="kobo.114.1">$ docker run alpine:3.7 /bin/sh -c "ps ax"</span></strong><br/><strong><span class="koboSpan" id="kobo.115.1">PID   USER     TIME   COMMAND</span></strong><br/><strong><span class="koboSpan" id="kobo.116.1">    1 root       0:00 /bin/sh -c ps ax</span></strong><br/><strong><span class="koboSpan" id="kobo.117.1">    6 root       0:00 ps ax</span></strong><br/><strong><span class="koboSpan" id="kobo.118.1">$ docker run alpine:3.8 /bin/sh -c "ps ax"</span></strong><br/><strong><span class="koboSpan" id="kobo.119.1">PID   USER     TIME  COMMAND</span></strong><br/><strong><span class="koboSpan" id="kobo.120.1">    1 root      0:00 ps ax</span></strong></pre>
<p><span class="koboSpan" id="kobo.121.1">How do </span><kbd><span class="koboSpan" id="kobo.122.1">dash</span></kbd><span class="koboSpan" id="kobo.123.1"> and </span><kbd><span class="koboSpan" id="kobo.124.1">bash</span></kbd><span class="koboSpan" id="kobo.125.1"> handle these cases? </span><span class="koboSpan" id="kobo.125.2">Let's take a look:</span></p>
<pre><strong><span class="koboSpan" id="kobo.126.1">## there is no ps inside the official debian image, Here we reuse the one from above, which is also based on the debian:</span></strong><br/><strong><span class="koboSpan" id="kobo.127.1">$ docker run devopswithkubernetes/ch93:exec-sh /bin/sh -c "ps ax"</span></strong><br/><strong><span class="koboSpan" id="kobo.128.1">  PID TTY      STAT   TIME COMMAND</span></strong><br/><strong><span class="koboSpan" id="kobo.129.1">    1 ?        </span><span class="koboSpan" id="kobo.129.2">Ss     0:00 /bin/sh -c ps ax</span></strong><br/><strong><span class="koboSpan" id="kobo.130.1">    6 ?        </span><span class="koboSpan" id="kobo.130.2">R      0:00 ps ax</span></strong><br/><strong><span class="koboSpan" id="kobo.131.1">$ docker run devopswithkubernetes/ch93:exec-sh /bin/bash -c "ps ax"</span></strong><br/><strong><span class="koboSpan" id="kobo.132.1">  PID TTY      STAT   TIME COMMAND</span></strong><br/><strong><span class="koboSpan" id="kobo.133.1">    1 ?        </span><span class="koboSpan" id="kobo.133.2">Rs     0:00 ps ax</span></strong></pre>
<p><span class="koboSpan" id="kobo.134.1">As we can see, their results are different as well. </span><span class="koboSpan" id="kobo.134.2">Our application </span><span><span class="koboSpan" id="kobo.135.1">can</span></span><span><span class="koboSpan" id="kobo.136.1"> </span></span><span><span class="koboSpan" id="kobo.137.1">now respond to the terminating event appropriately. </span><span class="koboSpan" id="kobo.137.2">There is one more thing, however, that could potentially harm our system if our application is run as</span></span> <kbd><span class="koboSpan" id="kobo.138.1">PID 1</span></kbd> <span><span class="koboSpan" id="kobo.139.1">and it uses more than one process inside the container.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">On Linux, a child process becomes a zombie if its parent doesn't wait for its execution. </span><span class="koboSpan" id="kobo.140.2">If the parent </span><span><span class="koboSpan" id="kobo.141.1">dies before its child process ends, the </span><kbd><span class="koboSpan" id="kobo.142.1">init</span></kbd><span class="koboSpan" id="kobo.143.1"> process should adopt those orphaned processes and reap processes that become zombies. </span><span class="koboSpan" id="kobo.143.2">System programs know how to deal with orphaned processes, so zombie processes are not a problem most of the time. However, i</span></span><span><span class="koboSpan" id="kobo.144.1">n a containerized context, the process that holds </span><kbd><span class="koboSpan" id="kobo.145.1">PID 1</span></kbd><span class="koboSpan" id="kobo.146.1"> is our application, and the operating system would expect our application to reap zombie processes. </span><span class="koboSpan" id="kobo.146.2">Because </span></span><span><span class="koboSpan" id="kobo.147.1">our application isn't designed to act as a proper </span><kbd><span class="koboSpan" id="kobo.148.1">init</span></kbd><span class="koboSpan" id="kobo.149.1"> process, however, handling the state of child processes is unrealistic. </span><span class="koboSpan" id="kobo.149.2">If we just ignore it, at worst the process table of the node will be filled with zombie processes and we won't be able to launch new programs on the node anymore. </span><span class="koboSpan" id="kobo.149.3">In Kubernetes, if a pod with zombie processes is gone, then all zombie processes inside will be cleaned. </span><span class="koboSpan" id="kobo.149.4">Another possible scenario is if our application performs some tasks frequently through scripts in the background, which could potentially fork lots of processes. </span></span><span><span class="koboSpan" id="kobo.150.1">Let's consider the following simple example:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.151.1">$ </span></strong><strong><span class="koboSpan" id="kobo.152.1">kubectl run --generator=run-pod/v1 \</span></strong><br/><strong><span class="koboSpan" id="kobo.153.1">--image=devopswithkubernetes/ch93:exec-sh my-app-exec</span></strong><strong><br/><span class="koboSpan" id="kobo.154.1">pod/my-app-exec created</span><br/></strong><strong><span class="koboSpan" id="kobo.155.1">## let's enter our app pod and run sleep in background inside it</span></strong><strong><br/><span class="koboSpan" id="kobo.156.1">$ kubectl exec -it my-app-exec /bin/sh</span><br/><span class="koboSpan" id="kobo.157.1"># ps axf</span><br/><span class="koboSpan" id="kobo.158.1">  PID TTY      STAT   TIME COMMAND</span><br/><span class="koboSpan" id="kobo.159.1">    5 pts/0    Ss     0:00 /bin/sh</span><br/><span class="koboSpan" id="kobo.160.1">   10 pts/0    R+     0:00  \_ ps axf</span><br/><span class="koboSpan" id="kobo.161.1">    1 ?        </span><span class="koboSpan" id="kobo.161.2">Ss     0:00 python3 -u app.py</span><br/><span class="koboSpan" id="kobo.162.1"># sleep 30 &amp;</span><br/><span class="koboSpan" id="kobo.163.1"># ps axf</span><br/><span class="koboSpan" id="kobo.164.1">  PID TTY      STAT   TIME COMMAND</span><br/><span class="koboSpan" id="kobo.165.1">    5 pts/0    Ss     0:00 /bin/sh</span><br/><span class="koboSpan" id="kobo.166.1">   11 pts/0    S      0:00  \_ sleep 30</span><br/><span class="koboSpan" id="kobo.167.1">   12 pts/0    R+     0:00  \_ ps axf</span><br/><span class="koboSpan" id="kobo.168.1">    1 ?        </span><span class="koboSpan" id="kobo.168.2">Ss     0:00 python3 -u app.py</span><br/><br/><span class="koboSpan" id="kobo.169.1">## now quit kubectl exec, wait 30 seconds, and check the pod again</span><br/><span class="koboSpan" id="kobo.170.1">$ kubectl exec my-app-exec ps axf</span><br/><span class="koboSpan" id="kobo.171.1">  PID TTY      STAT   TIME COMMAND</span><br/><span class="koboSpan" id="kobo.172.1">   23 ?        </span><span class="koboSpan" id="kobo.172.2">Rs     0:00 ps axf</span><br/><span class="koboSpan" id="kobo.173.1">    1 ?        </span><span class="koboSpan" id="kobo.173.2">Ss     0:00 python3 -u app.py</span><br/><span class="koboSpan" id="kobo.174.1">   11 ?        </span><span class="koboSpan" id="kobo.174.2">Z      0:00 [sleep] &lt;defunct&gt;</span><br/></strong></pre>
<p><kbd><span class="koboSpan" id="kobo.175.1">sleep 30</span></kbd><span class="koboSpan" id="kobo.176.1"> is now a zombie in our pod. </span><span><span class="koboSpan" id="kobo.177.1">In </span></span><span class="ChapterrefPACKT"><a href="05e2d0b4-0e70-4480-b5a0-f3860ddb24f2.xhtml"><span class="koboSpan" id="kobo.178.1">Chapter 2</span></a><span class="koboSpan" id="kobo.179.1">,</span></span><span><span class="koboSpan" id="kobo.180.1"> </span></span><em><span class="koboSpan" id="kobo.181.1">DevOps with Containers</span></em><span class="koboSpan" id="kobo.182.1">, we mentioned that the </span><kbd><span class="koboSpan" id="kobo.183.1">docker run --init</span></kbd><span class="koboSpan" id="kobo.184.1"> parameter can set a simple </span><kbd><span class="koboSpan" id="kobo.185.1">init</span></kbd><span class="koboSpan" id="kobo.186.1"> process for our container. </span><span class="koboSpan" id="kobo.186.2">In Kubernetes, we can make the </span><kbd><span class="koboSpan" id="kobo.187.1">pause</span></kbd><span class="koboSpan" id="kobo.188.1"> container, a special container that deals with those chores silently for us, be present in our pod by specifying </span><kbd><span class="koboSpan" id="kobo.189.1">.spec.shareProcessNamespace</span></kbd><span class="koboSpan" id="kobo.190.1"> in the pod specification:</span></p>
<pre><strong><span class="koboSpan" id="kobo.191.1">$ kubectl apply -f chapter9/9-3_on_pods/sharepidns.yml</span></strong><br/><strong><span class="koboSpan" id="kobo.192.1">pod/my-app-with-pause created</span></strong><br/><strong><span class="koboSpan" id="kobo.193.1">$ kubectl exec my-app-with-pause ps ax</span></strong><br/><strong><span class="koboSpan" id="kobo.194.1">    1 ?        </span><span class="koboSpan" id="kobo.194.2">Ss     0:00 /pause</span></strong><br/><strong><span class="koboSpan" id="kobo.195.1">    6 ?        </span><span class="koboSpan" id="kobo.195.2">Ss     0:00 python3 -u app.py</span></strong><br/><strong><span class="koboSpan" id="kobo.196.1">   10 ?        </span><span class="koboSpan" id="kobo.196.2">Rs     0:00 ps ax</span></strong></pre>
<p><span class="koboSpan" id="kobo.197.1">The </span><kbd><span class="koboSpan" id="kobo.198.1">pause</span></kbd><span class="koboSpan" id="kobo.199.1"> process ensures that zombies are reaped and </span><kbd><span class="koboSpan" id="kobo.200.1">SIGTERM</span></kbd><span class="koboSpan" id="kobo.201.1"> goes to our application process. </span><span class="koboSpan" id="kobo.201.2">Notice that by enabling process namespace sharing, aside from our application no longer having </span><kbd><span class="koboSpan" id="kobo.202.1">PID 1</span></kbd><span class="koboSpan" id="kobo.203.1">, there are two other key differences:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.204.1">All containers in the same pod share process information with each other, which means a container can send signals to another container</span></li>
<li><span class="koboSpan" id="kobo.205.1">The filesystem of containers can be accessed via the </span><kbd><span class="koboSpan" id="kobo.206.1">/proc/$PID/root</span></kbd><span class="koboSpan" id="kobo.207.1"> path</span></li>
</ul>
<p><span class="koboSpan" id="kobo.208.1">If the described behaviors aren't feasible to your application while an </span><kbd><span class="koboSpan" id="kobo.209.1">init</span></kbd><span class="koboSpan" id="kobo.210.1"> process is still needed, you can opt for Tini (</span><a href="https://github.com/krallin/tini"><span class="koboSpan" id="kobo.211.1">https://github.com/krallin/tini</span></a><span class="koboSpan" id="kobo.212.1">), or dump-init (</span><a href="https://github.com/Yelp/dumb-init"><span class="koboSpan" id="kobo.213.1">https://github.com/Yelp/dumb-init</span></a><span class="koboSpan" id="kobo.214.1">), or even write a wrapper script to resolve the zombie reaping problem.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">SIGTERM doesn't invoke the termination handler</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In some cases, the termination handler of a process isn't triggered by </span><kbd><span class="koboSpan" id="kobo.3.1">SIGTERM</span></kbd><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">For instance, sending </span><kbd><span class="koboSpan" id="kobo.5.1">SIGTERM</span></kbd><span class="koboSpan" id="kobo.6.1"> to </span><kbd><span class="koboSpan" id="kobo.7.1">nginx</span></kbd><span class="koboSpan" id="kobo.8.1"> actually causes a fast shutdown. </span><span class="koboSpan" id="kobo.8.2">To gracefully close an </span><kbd><span class="koboSpan" id="kobo.9.1">nginx</span></kbd><span class="koboSpan" id="kobo.10.1"> controller, we have to send </span><kbd><span class="koboSpan" id="kobo.11.1">SIGQUIT</span></kbd><span class="koboSpan" id="kobo.12.1"> with </span><kbd><span class="koboSpan" id="kobo.13.1">nginx -s quit</span></kbd><span class="koboSpan" id="kobo.14.1"> instead.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.15.1">The full list of supported actions on the signal of </span><kbd><span class="koboSpan" id="kobo.16.1">nginx</span></kbd><span class="koboSpan" id="kobo.17.1"> is listed here: </span><a href="http://nginx.org/en/docs/control.html" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.18.1">http://nginx.org/en/docs/control.html</span></span></a><span class="URLPACKT"><span class="koboSpan" id="kobo.19.1">.</span></span><a href="http://nginx.org/en/docs/control.html" target="_blank"/></div>
<p><span class="koboSpan" id="kobo.20.1">Now, another problem arises: how do we send signals other than </span><kbd><span class="koboSpan" id="kobo.21.1">SIGTERM</span></kbd><span class="koboSpan" id="kobo.22.1"> to a container when deleting a pod? </span><span class="koboSpan" id="kobo.22.2">We can modify the behavior of our program to trap </span><kbd><span class="koboSpan" id="kobo.23.1">SIGTERM</span></kbd><span class="koboSpan" id="kobo.24.1">, but there's nothing we can do about popular tools such as </span><kbd><span class="koboSpan" id="kobo.25.1">nginx</span></kbd><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">For such a situation, we can use life cycle hooks.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Container life cycle hooks</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Life cycle hooks are actions triggered on certain events and performed against containers. </span><span class="koboSpan" id="kobo.2.2">They work like a single Kubernetes probing action, but they'll be fired at least once per event during a container's lifetime. </span><span class="koboSpan" id="kobo.2.3">Currently, two events are supported:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.3.1">PostStart</span></kbd><span class="koboSpan" id="kobo.4.1">: This executes right after a container is created. </span><span class="koboSpan" id="kobo.4.2">Since this hook and the entry point of a container are fired asynchronously, there's no guarantee that the hook will be executed before the container starts. </span><span class="koboSpan" id="kobo.4.3">As such, we're unlikely to use it to initialize resources for a container.</span></li>
<li><kbd><span class="koboSpan" id="kobo.5.1">PreStop</span></kbd><span class="koboSpan" id="kobo.6.1">: This executes right before sending </span><kbd><span class="koboSpan" id="kobo.7.1">SIGTERM</span></kbd><span class="koboSpan" id="kobo.8.1"> to a container. </span><span class="koboSpan" id="kobo.8.2">One difference from the </span><kbd><span class="koboSpan" id="kobo.9.1">PostStart</span></kbd><span class="koboSpan" id="kobo.10.1"> hook is that the </span><kbd><span class="koboSpan" id="kobo.11.1">PreStop</span></kbd><span class="koboSpan" id="kobo.12.1"> hook is a synchronous call; in other words, </span><kbd><span class="koboSpan" id="kobo.13.1">SIGTERM</span></kbd><span class="koboSpan" id="kobo.14.1"> is only sent after a </span><kbd><span class="koboSpan" id="kobo.15.1">PreStop</span></kbd><span class="koboSpan" id="kobo.16.1"> hook exited.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">We can easily solve our </span><kbd><span class="koboSpan" id="kobo.18.1">nginx</span></kbd><span class="koboSpan" id="kobo.19.1"> shutdown problem with a </span><kbd><span class="koboSpan" id="kobo.20.1">PreStop</span></kbd><span class="koboSpan" id="kobo.21.1"> hook:</span></p>
<pre><strong><span class="koboSpan" id="kobo.22.1">...</span><br/><span class="koboSpan" id="kobo.23.1">     containers:</span><br/><span class="koboSpan" id="kobo.24.1">     - name: main</span><br/><span class="koboSpan" id="kobo.25.1">       image: nginx</span><br/><span class="koboSpan" id="kobo.26.1">       life cycle:</span><br/><span class="koboSpan" id="kobo.27.1">        preStop:</span><br/><span class="koboSpan" id="kobo.28.1">         exec:</span><br/><span class="koboSpan" id="kobo.29.1">          command: [ "nginx", "-s", "quit" ]</span><br/><span class="koboSpan" id="kobo.30.1">... </span></strong></pre>
<p><span class="koboSpan" id="kobo.31.1">An important property of hooks is they can affect the state of a pod in certain ways: a pod won't be running unless its </span><kbd><span class="koboSpan" id="kobo.32.1">PostStart</span></kbd><span class="koboSpan" id="kobo.33.1"> hook exits successfully. </span><span class="koboSpan" id="kobo.33.2">A pod is set to terminate immediately on deletion, but </span><kbd><span class="koboSpan" id="kobo.34.1">SIGTERM</span></kbd><span class="koboSpan" id="kobo.35.1"> won't be sent unless the </span><kbd><span class="koboSpan" id="kobo.36.1">PreStop</span></kbd><span class="koboSpan" id="kobo.37.1"> hook exits successfully. </span><span class="koboSpan" id="kobo.37.2">Therefore, we can resolve a situation that a pod quits before its proxy rules are removed on the node by the </span><kbd><span class="koboSpan" id="kobo.38.1">PreStop</span></kbd><span class="koboSpan" id="kobo.39.1"> hook.</span></p>
<p><span class="koboSpan" id="kobo.40.1">The following diagram illustrates how to use the hook to eliminate the unwanted gap:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.41.1"><img class=" image-border" src="assets/956a3c06-c7c9-488d-8c63-66b7fde1d620.png" style="width:26.67em;height:23.42em;"/></span></div>
<p><span class="koboSpan" id="kobo.42.1">The implementation is to just add a hook that sleeps for a few seconds:</span></p>
<pre><strong><span class="koboSpan" id="kobo.43.1">...</span><br/><span class="koboSpan" id="kobo.44.1">     containers:</span><br/><span class="koboSpan" id="kobo.45.1">     - name: main</span><br/><span class="koboSpan" id="kobo.46.1">       image: my-app</span><br/><span class="koboSpan" id="kobo.47.1">       life cycle:</span><br/><span class="koboSpan" id="kobo.48.1">        preStop:</span><br/><span class="koboSpan" id="kobo.49.1">         exec:</span><br/><span class="koboSpan" id="kobo.50.1">           command: [ "/bin/sh", "-c", "sleep 5" ]</span><br/><span class="koboSpan" id="kobo.51.1">...</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Tackling pod disruptions</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">Ideally, we'd like to keep the availability of our service as high as we can. </span><span class="koboSpan" id="kobo.2.2">However, t</span><span><span class="koboSpan" id="kobo.3.1">here're always lots of events that cause the pods that are backing our service to go up and down, either voluntarily or involuntarily. Voluntary disruptions include </span><kbd><span class="koboSpan" id="kobo.4.1">Deployment</span></kbd><span class="koboSpan" id="kobo.5.1"> rollouts, planned node maintenance, or the accidental killing of a pod with the API. </span><span class="koboSpan" id="kobo.5.2">On the whole, every operation that goes through the Kubernetes master counts. </span><span class="koboSpan" id="kobo.5.3">On the ot</span></span><span><span class="koboSpan" id="kobo.6.1">her hand, any unexpected outage that leads to the termination of our service belongs to the category of involuntary disruptions.</span></span></p>
<p class="mce-root"><span><span class="koboSpan" id="kobo.7.1">In previous chapters, we discussed how to prevent involuntary disruptions by replicating pods with </span><kbd><span class="koboSpan" id="kobo.8.1">Deployment</span></kbd><span class="koboSpan" id="kobo.9.1"> and </span><kbd><span class="koboSpan" id="kobo.10.1">StatefulSet</span></kbd><span class="koboSpan" id="kobo.11.1">, appropriately configuring resource requests and limits, scaling an application's capacity with the autoscaler, and distributing pods to multiple locations with affinities and anti-affinities. </span></span><span><span class="koboSpan" id="kobo.12.1">Since we've already put a lot of effort into our service, what could go wrong when it comes to these expected voluntary disruptions? </span><span class="koboSpan" id="kobo.12.2">In fact, because they're events that are likely to happen, we ought to pay more attention to them.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">In </span><kbd><span class="koboSpan" id="kobo.14.1">Deployment</span></kbd><span class="koboSpan" id="kobo.15.1"> and other similar objects, we can use the </span><kbd><span class="koboSpan" id="kobo.16.1">maxUnavailable</span></kbd><span class="koboSpan" id="kobo.17.1"> and </span><kbd><span class="koboSpan" id="kobo.18.1">maxSurge</span></kbd> <span><span class="koboSpan" id="kobo.19.1">fields </span></span><span class="koboSpan" id="kobo.20.1">that help us roll out our updates in a controlled manner. </span><span class="koboSpan" id="kobo.20.2">As for other cases, such as node maintenance tasks performed by cluster administrators who don't have domain knowledge about all the applications run in the cluster, the service owner can utilize </span><kbd><span class="koboSpan" id="kobo.21.1">PodDisruptionBudget</span></kbd><span class="koboSpan" id="kobo.22.1"> to tell Kubernetes how many pods are required for a service to meet its service level.</span></p>
<p><span class="koboSpan" id="kobo.23.1">A pod disruption budget has the following syntax:</span></p>
<pre><strong><span class="koboSpan" id="kobo.24.1">apiVersion: policy/v1beta1</span></strong><br/><strong><span class="koboSpan" id="kobo.25.1">kind: PodDisruptionBudget</span></strong><br/><strong><span class="koboSpan" id="kobo.26.1">metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.27.1">  name: &lt;pdb name&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">spec:</span></strong><br/><strong>  <span><span class="koboSpan" id="kobo.29.1">maxUnavailable</span></span><span class="koboSpan" id="kobo.30.1">: &lt;desired number or percentage of pods&gt;</span></strong><br/><strong>  <span><span class="koboSpan" id="kobo.31.1">minAvailable: &lt;desired number or percentage of pods&gt;</span></span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">  selector:</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">    &lt;matchLabels&gt; or &lt;</span><span><span class="koboSpan" id="kobo.34.1">matchExpressions&gt;</span></span></strong></pre>
<p><span class="koboSpan" id="kobo.35.1">There are two configurable fields in a pod disruption budget, but they can't be used together. </span><span class="koboSpan" id="kobo.35.2">The selector is identical to the one in </span><kbd><span class="koboSpan" id="kobo.36.1">Deployment</span></kbd><span class="koboSpan" id="kobo.37.1"> or other places. </span><span class="koboSpan" id="kobo.37.2">Note that a pod disruption budget is immutable, which means it can't be updated after its creation. </span><span class="koboSpan" id="kobo.37.3">The </span><kbd><span class="koboSpan" id="kobo.38.1">minAvailable</span></kbd><span class="koboSpan" id="kobo.39.1"> and </span><kbd><span class="koboSpan" id="kobo.40.1">maxUnavailable</span></kbd> <span><span class="koboSpan" id="kobo.41.1">fields </span></span><span class="koboSpan" id="kobo.42.1">are mutually exclusive, but they're the same in some ways. </span><span class="koboSpan" id="kobo.42.2">For example, </span><span><kbd><span class="koboSpan" id="kobo.43.1">maxUnavailable:0</span></kbd><span class="koboSpan" id="kobo.44.1"> means zero tolerance of any pod losses, and it's roughly equivalent to </span><kbd><span class="koboSpan" id="kobo.45.1">minAvailable:100%</span></kbd><span class="koboSpan" id="kobo.46.1">, which means that all pods should be available.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">Pod disruption budgets work by evicting events such as draining nodes or pod preemption. </span><span class="koboSpan" id="kobo.47.2">They don't interfere with the rolling update process performed by controllers such as </span><kbd><span class="koboSpan" id="kobo.48.1">Deployment</span></kbd><span class="koboSpan" id="kobo.49.1"> or </span><kbd><span class="koboSpan" id="kobo.50.1">StatefulSet</span></kbd><span class="koboSpan" id="kobo.51.1">. </span><span class="koboSpan" id="kobo.51.2">Suppose that we want to temporarily remove one node from the cluster with </span><kbd><span class="koboSpan" id="kobo.52.1">kubectl drain</span></kbd><span class="koboSpan" id="kobo.53.1">, but this would violate certain p</span><span><span class="koboSpan" id="kobo.54.1">od disruption budgets of running applications. </span><span class="koboSpan" id="kobo.54.2">In this case, the draining operation would be blocked unless all pod disruption budgets can be satisfied. </span><span class="koboSpan" id="kobo.54.3">However, if the Kubernetes scheduler is going to evict a victim pod to fulfill high priority pods, the scheduler would only try to meet all of the pod disruption budgets if possible. </span><span class="koboSpan" id="kobo.54.4">If the scheduler can't find a target without breaking any pod disruption budgets, it would still pick a pod with the lowest priority.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, we've discussed topics related to building a continuous delivery pipeline and how to strengthen our deployment tasks. </span><span class="koboSpan" id="kobo.2.2">The rolling update of a pod is a powerful tool that allows us to perform updates in a controlled fashion. </span><span class="koboSpan" id="kobo.2.3">To trigger a rolling update, what we need to do is change the pod's specification in a controller that supports that rolling update. </span><span class="koboSpan" id="kobo.2.4">Additionally, although the update is managed by Kubernetes, we can still control it with </span><kbd><span class="koboSpan" id="kobo.3.1">kubectl rollout</span></kbd><span class="koboSpan" id="kobo.4.1"> to a certain extent.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Later on, we fabricated an extensible continuous delivery pipeline using </span><kbd><span class="koboSpan" id="kobo.6.1">GitHub</span></kbd><span class="koboSpan" id="kobo.7.1">/</span><kbd><span class="koboSpan" id="kobo.8.1">DockerHub</span></kbd><span class="koboSpan" id="kobo.9.1">/</span><kbd><span class="koboSpan" id="kobo.10.1">Travis-CI</span></kbd><span class="koboSpan" id="kobo.11.1">. </span><span class="koboSpan" id="kobo.11.2">We then moved on to learn more about the life cycle of pods to prevent any possible failures, including using the readiness and liveness probes to protect a pod; initializing a pod with </span><kbd><span class="koboSpan" id="kobo.12.1">init</span></kbd><span class="koboSpan" id="kobo.13.1"> containers; handling </span><kbd><span class="koboSpan" id="kobo.14.1">SIGTERM</span></kbd><span class="koboSpan" id="kobo.15.1"> properly by picking the right composition of invocation commands of the entry point of our program and the shell to run it; using life cycle hooks to stall a pod's readiness, as well as its termination for the pod to be removed from a service at the right time; and assigning pod disruption budgets to ensure the availability of our pods.</span></p>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span><span class="koboSpan" id="kobo.16.1">In </span><a href="f55d3fa8-e791-4473-83ba-ed8c4f848a90.xhtml"><span class="koboSpan" id="kobo.17.1">Chapter 10</span></a><span class="koboSpan" id="kobo.18.1">, </span><em><span class="koboSpan" id="kobo.19.1">Kubernetes on AWS</span></em></span><span><span class="koboSpan" id="kobo.20.1">, we'll move on to learn the essentials of how to deploy the cluster on AWS, the major player among all public cloud providers.</span></span></p>
</div>
</div>
</div>


            </article>

            
        </section>
    </body></html>