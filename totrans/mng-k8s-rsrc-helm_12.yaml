- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm Security Considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have likely come to realize throughout this book, Helm is a powerful
    tool that makes deploying applications on Kubernetes simple and efficient. With
    that said, we need to ensure that we do not lose sight of security best practices
    when leveraging Helm. Luckily, Helm provides several ways to incorporate good
    security practices into everyday usage in ways that are simple to achieve, from
    the moment the Helm CLI is downloaded to the moment a Helm chart is installed
    into a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Data provenance and integrity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing secure and stable Helm charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring RBAC rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will make use of the following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`minikube`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`helm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gpg` (GNU Privacy Guard)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You learned how to install and configure the `minikube`, `kubectl`, and `helm`
    **command-line interfaces** (**CLIs**) in [*Chapter 2*](B17979_02.xhtml#_idTextAnchor038),
    *Preparing a Kubernetes and Helm Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also leverage the guestbook chart from the Packt repository located
    at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm)
    for an exercise later in this chapter. If you have not already cloned the repository,
    you can do so with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s begin by discussing data provenance and integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Data provenance and integrity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with any kind of data, two often-overlooked questions should be
    considered:'
  prefs: []
  type: TYPE_NORMAL
- en: Does the data come from a reliable source?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the data contain all of the contents that you expected it to?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first question relates to the topic of **data provenance**. Data provenance
    is about determining the origin of data and determining where the data originated
    from.
  prefs: []
  type: TYPE_NORMAL
- en: The second question refers to the topic of **data integrity**. Data integrity
    is about determining whether the contents you received from a remote location
    represents what you expected to receive. It helps determine whether data was tampered
    with as it was sent across the wire.
  prefs: []
  type: TYPE_NORMAL
- en: Both data provenance and data integrity can be verified using a concept called
    **digital signatures**. An author can create a unique signature based on cryptography
    to sign data, and the consumer of that data can use cryptographic tools to verify
    the authenticity of that signature. If the authenticity is verified, then the
    consumer is assured that the data originates from the expected source and was
    not tampered with as it was transferred.
  prefs: []
  type: TYPE_NORMAL
- en: Authors can create a digital signature using a variety of tools. One such method
    is by using **Pretty Good Privacy** (**PGP**). PGP, in this context, refers to
    OpenPGP, which is a set of standards based on encryption. PGP focuses on establishing
    asymmetric encryption, which is based on the use of two different keys – private
    and public.
  prefs: []
  type: TYPE_NORMAL
- en: Private keys are meant to be kept secret, while public keys are designed to
    be shared. In PGP, the private key is used to encrypt data, while the public key
    is used by consumers to decrypt that data. The PGP key pair is often created using
    a tool called GPG, which is an open source tool that implements the OpenPGP standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin working with PGP, the first step is to create the key pair, which
    will generate a set of public and private keys. Once the PGP key pair has been
    created, the author can use GPG to sign the data. When data has been signed, GPG
    performs the following steps in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: A hash is calculated based on the contents of the data. The output is a fixed-length
    string called the **message digest**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The message digest is encrypted using the author’s private key. The output is
    the digital signature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To verify the signature, consumers must use the author’s public key to decrypt
    it. This verification can also be performed using GPG.
  prefs: []
  type: TYPE_NORMAL
- en: 'Digital signatures play a role in Helm in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: First, each Helm binary has an accompanying digital signature that’s owned by
    one of the Helm maintainers. This signature can be used to verify the origin of
    the download, as well as its integrity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, Helm charts can also be digitally signed so that they benefit from the
    same form of verifications. Authors of Helm charts can sign the chart during packaging,
    and the chart users can verify the chart’s authenticity by using the author’s
    public key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you understand how data provenance and integrity come into play concerning
    digital signatures, in the next section, you will create a GPG key pair on your
    local machine that will be used to elaborate on the previously described concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GPG key pair
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a key pair, you must have GPG installed on your local machine. Use
    the following instructions as a guide to installing GPG on your respective machine.
    Note that this chapter is based on `gpg` version 2.3.6:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, you can use the Chocolatey package manager:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can also download the installer for Windows from [https://gpg4win.org/download.html](https://gpg4win.org/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'For macOS, you can use the Homebrew package manager by using the following
    command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can also download the macOS-based installer from [https://sourceforge.net/p/gpgosx/docu/Download/](https://sourceforge.net/p/gpgosx/docu/Download/).
  prefs: []
  type: TYPE_NORMAL
- en: 'For Debian-based Linux distributions, you can use the `apt` package manager:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For RPM-based Linux distributions, you can use the `dnf` package manager:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you have installed GPG, you can create your own GPG key pair, which we
    will use throughout our discussion on data provenance and integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to configure your key pair:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to begin the generation process by running the `gpg --full-generate-key`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `Please select what kind of key you want` prompt, select `(1) RSA and
    RSA`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The reason we are using RSA instead of the default option (ECC) is that ECC
    is not supported by the crypto library used in Helm’s source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will be prompted to enter the key size. For this example, we can
    simply select the default, so continue by pressing the *Enter* key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After you enter your key size, you will be asked how long the key should be
    valid. Since this key will be used solely to run through the examples, we recommend
    setting a short expiration, such as 1 week (`1w`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you will be prompted for your name and email address. These will be used
    to identify you as the owner of the key pair and will be the name and email address
    displayed by those who receive your public key. You will also be prompted to provide
    a comment, which you can simply leave blank:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Press the *O* key to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you will be prompted to enter your private key passphrase. Providing
    a strong passphrase is essential for protecting your identity in the event your
    private key is stolen. This is because it must be provided each time you attempt
    to access your key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To keep our example simple, we will create an empty string passphrase to avoid
    passphrase prompts. While this is acceptable in this demonstration, you should
    protect any private key you intend to use in a real-world situation with a strong
    passphrase.
  prefs: []
  type: TYPE_NORMAL
- en: To continue, simply press *Enter* to submit an empty passphrase. When prompted,
    select `<Yes, protection is not needed>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your GPG key pair has been created, you will see an output similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output displays information about the public (`pub`) and private
    (`sub`) keys, as well as the fingerprint of the public key (the second line of
    the output). The fingerprint is a unique identifier that’s used to identify you
    as the owner of that key. The third line, beginning with `uid`, displays the name
    and email address that you entered when generating the GPG key pair.
  prefs: []
  type: TYPE_NORMAL
- en: With your key pair now created, let’s continue to the next section to learn
    how a Helm binary can be verified.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying Helm downloads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As discussed in [*Chapter 2*](B17979_02.xhtml#_idTextAnchor038), *Preparing
    a Kubernetes and Helm Environment*, one of the ways Helm can be installed is by
    downloading an archive from GitHub. These archives can be installed from Helm’s
    GitHub releases page ([https://github.com/helm/helm/releases](https://github.com/helm/helm/releases))
    by selecting one of the links shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – The Installation and Upgrading section of Helm’s GitHub releases
    page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.01_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – The Installation and Upgrading section of Helm’s GitHub releases
    page
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the preceding screenshot, you will notice a paragraph explaining
    that the release was signed. Each Helm release is signed by a Helm maintainer
    and can be verified against the digital signature that corresponds to the downloaded
    release. Each of the signatures is located under the **Assets** section, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – The Assets section of Helm’s GitHub releases page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.02_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – The Assets section of Helm’s GitHub releases page
  prefs: []
  type: TYPE_NORMAL
- en: To verify the provenance and integrity of a Helm download, in addition to the
    binary itself, you should also download the corresponding `.asc` file. Note that
    `sha256` files are used to verify the integrity only. In this example, we will
    download the `.tar.gz.asc` file, which verifies both provenance and integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s demonstrate how a Helm release can be verified. First, we should download
    a Helm archive, along with its corresponding `.asc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download a Helm archive that corresponds with your operating system. For this
    example, we will use version 3.8.2\. If you are running an AMD64-based Linux system,
    the version for this distribution can be downloaded from the GitHub release page
    or by using the following `curl` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, download the`.asc` file that corresponds with your operating system.
    When running an AMD64-based Linux system, `helm-v3.8.2-linux-amd64.tar.gz.asc`
    would be the resulting file that would be downloaded. You can download this file
    from the GitHub release page or by using the following `curl` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once both files have been downloaded, you should see the two files located
    within the same directory on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The next step involves importing the Helm maintainer’s public key to your local
    GPG keyring. This allows you to decrypt the digital signature contained in the
    `.asc` file to verify the provenance and integrity of your downloaded binary.
    GPG public keys are saved in public key servers such as `keyserver.ubuntu.com`
    and `pgp.mit.edu`. As such, we can use the `gpg --recv-key` command to download
    the maintainer’s key from a public key server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s import the maintainer’s public key and continue with the verification
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, recall the maintainer’s public key fingerprint from *Figure 12.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `gpg --recv-key` command to download and import the key into your local
    keychain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the public key has been imported, you can verify the Helm release
    by using the `--verify` subcommand of GPG. This command has the `gpg --verify
    <signature> <data>` syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This command decrypts the digital signature contained in the `.asc` file. If
    it is successful, it means that the Helm download (the file ending in `.tar.gz`)
    was signed by the person you expected (Matt Farina for this release) and that
    the download was not modified or altered in any way. A successful output looks
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Upon further inspection of this output, you may notice the `WARNING` message,
    indicating that the key was not certified, which may lead you to question whether
    or not the verification was successful. In this case, the verification was indeed
    successful, but you have not certified the maintainer’s key yet, so GPG returns
    this warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `This key is not certified` message is normally not an issue, but if you
    would like to ensure this warning does not appear in the future, you can follow
    these steps to certify the maintainer’s public key:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check that the public key’s fingerprint (also referred to as the primary key
    from the `gpg –verify` output) matches the fingerprint displayed on the Helm releases
    page. As you will recall from *Figure 12.1*, the fingerprint was displayed, as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because the key we imported matches the fingerprint displayed on GitHub, we
    know that we can trust this key. Trust can be associated with this key by using
    the `gpg --sign-key` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Really sign?` prompt, enter `y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have signed the maintainer’s public key, the key has been certified.
    The next time you perform a verification with this key, you should no longer see
    the warning message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Digital signatures also play a role in signing and verifying Helm charts. We
    will explore this topic in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Signing and verifying Helm charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to how the Helm maintainers sign releases, you can sign your Helm charts
    so that users can verify its origin as well as confirm it contains the expected
    content. To sign a chart, you must have a GPG key pair present on your local workstation
    (we created a GPG key pair earlier in the *Creating a GPG key pair* section).
  prefs: []
  type: TYPE_NORMAL
- en: There is one important caveat to note before we start signing charts. If you
    are using GPG version 2 or greater, you must export your public and secret keyrings
    to a legacy format. Early versions of GPG stored keyrings in the `.gpg` file format,
    which is the format that Helm expects your keyring to be in (at the time of writing).
    Newer versions of GPG store keyrings in the `.kbx` file format, which is not compatible
    at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, we can export our keys in the `.gpg` format by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, find your GPG version by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If your GPG version is 2 or greater, export your public and secret keyrings
    using the `gpg --export` and `gpg --export-secret-keys` commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once your keyrings have been exported, you will be able to sign your charts
    using the `helm package` command. The `helm package` command provides three key
    flags that allow you to sign and package charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--sign`: This allows you to sign a chart using a PGP private key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--key`: The name of the key to use when signing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--keyring`: The location of the keyring containing the PGP private key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s run the `helm package` command to sign the guestbook Helm chart from
    the Packt repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `<key_name>` placeholder refers to either the email, name, or fingerprint
    associated with the desired key. These details can be found by using the `gpg
    --list-keys` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `helm package` command is successful, you will see the following files
    displayed in the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `guestbook-0.1.0.tgz` file is the archive that contains the Helm chart.
    This file is always created by `helm package`, whether you are signing the chart
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `guestbook-0.1.0.tgz.prov` file is called a **provenance file**. The provenance
    file contains a provenance record, which contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The chart metadata from the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sha256 hash of the `guestbook-0.1.0.tgz` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PGP digital signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm chart consumers leverage provenance files to verify the data provenance
    and integrity of the chart that they have downloaded. So, chart developers should
    be sure to publish both the `.tgz` archive as well as the `.tgz.prov` provenance
    file to their Helm chart repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you have successfully signed the guestbook chart and have created the
    `.tgz.prov` file, it is not quite enough for users to verify the chart, as they
    still need to access your public key to decrypt your signature. You can make this
    key available for users by publishing it to the PGP key servers with the `gpg
    --send-key` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'End users can then download and import this key by using the `gpg --recv-key`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a user has imported your public key (and exported it to the `~/.gnupg/pubring.gpg`
    keyring, as shown earlier in this section), they can verify your Helm chart by
    using the `helm verify` command, provided both the `.tgz` chart archive and `.tgz.prov`
    provenance file have been downloaded to the same directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If verification is successful, you will see that the signer, the signer’s public
    key, and the chart have been verified. Otherwise, an error will be returned. The
    verification could fail for a variety of reasons, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `.tgz` and `.tgz.prov` files are not in the same directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.tgz` or `.tgz.prov` files are corrupt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file hashes do not match, indicating a loss of integrity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public key used to decrypt the signature does not match the private key
    originally used to encrypt it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `helm verify` command is designed to be run on locally downloaded charts,
    so users may find it better to leverage the `helm install --verify` command instead,
    which performs the verification and installation in a single command, assuming
    that the `.tgz` and .`tgz.prov` files can both be downloaded from a chart repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command describes how the `helm install --verify` command can
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: By using the methodologies described in this section, chart developers and consumers
    can be assured that the content is sourced from a trusted origin and has been
    unaltered.
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of how data provenance and integrity play a role in Helm,
    let’s continue discussing Helm security considerations by moving on to our next
    topic – security concerning Helm charts and Helm chart development.
  prefs: []
  type: TYPE_NORMAL
- en: Developing secure and stable Helm charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While provenance and integrity play a major role in the security of Helm, they
    are not the only concerns you need to consider. During the development process,
    chart developers should ensure that they are adhering to best practices around
    security to prevent vulnerabilities from being introduced when a user installs
    their chart into a Kubernetes cluster. In this section, we will discuss many of
    the concerns surrounding security as it relates to Helm chart development and
    what you, as a developer, can do to write Helm charts with security as a priority.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by discussing the security around any container images that your
    Helm chart may reference.
  prefs: []
  type: TYPE_NORMAL
- en: Using secure images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the goal of Helm (and Kubernetes) is to deploy container images, the image
    itself presents several areas of consideration concerning security. To start,
    chart developers should be aware of the differences between image tags and image
    digests.
  prefs: []
  type: TYPE_NORMAL
- en: A tag is a human-readable reference to a given image and provides both developers
    and consumers with an easy way to reference an image. However, tags can present
    a security concern as there are no guarantees that the contents of a given tag
    will always remain the same. The image owner may choose to push an updated image
    using the same tag, which would result in a different underlying image being executed
    at runtime (even though the tag is the same). Performing these actions against
    the same tag introduces the possibility of regressions, which can cause unexpected
    adverse effects for end users. Instead of referencing an image by tag, images
    can also be referenced by digest. An image digest is a computed `SHA-256` value
    of an image that not only provides an immutable identifier to an exact image but
    also allows for the container runtime to verify the integrity of the image that
    is retrieved from a remote registry. This removes the risk of deploying an image
    that contains an accidental regression against a given tag and can also remove
    the risks of a man-in-the-middle attack, where the tag’s contents are modified
    with malicious intent.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, an image referenced as `quay.io/bitnami/redis:5.0.9` in a chart
    template can be referenced by a digest as `quay.io/bitnami/redis@sha256:70b816f2127afb5d4af7ec9d6e8636b2f0f973a3cd8dda7032f9dcffa38ba11f`.
    Notice that instead of specifying the name of a tag after the name of the image,
    the `SHA-256` digest is explicitly specified. This assures that the image content
    will not change over time, even if the tag changes, thus strengthening your security
    posture.
  prefs: []
  type: TYPE_NORMAL
- en: As time progresses, a tag or a digest may become unsafe for deployment, as vulnerabilities
    may eventually be found in the underlying packages or base components. There are
    many different ways to determine whether there are any vulnerabilities associated
    with a given image. One way is to leverage the native capabilities of the registry
    that the image belongs to. Many different image registry solutions contain capabilities
    around image vulnerability scanning that can help provide insight as to when an
    image is vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: The Quay container registry, for example, can automatically scan images at specified
    intervals to determine vulnerabilities that may be present within a given image.
    The Nexus and Artifactory container registries are also examples of container
    registries that have similar capabilities. Outside of native scanning capabilities
    provided by container registries, other tools can be leveraged, such as **Vuls**
    and **OpenSCAP**. When your image registry or standalone scanning tool reports
    that an image is vulnerable, you should immediately update your chart’s image
    to a newer version, if available, to prevent vulnerabilities from being introduced
    to your users’ Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: To help simplify the process of updating the container image, you can develop
    a regular cadence where image updates are checked. This helps prevent you from
    getting to a point where your target image contains vulnerabilities that make
    it unfit for deployment. Many teams and organizations also restrict the source
    of images to trusted registries to reduce the potential of running images that
    do contain vulnerabilities. This setting can be configured at the container runtime
    level or within policies applied to a Kubernetes cluster. The specific location
    and configurations vary based on the specific implementation(s).
  prefs: []
  type: TYPE_NORMAL
- en: Apart from image vulnerability scanning and content sourcing, you should also
    avoid deploying images that run as **root** or **privileged**. Running containers
    as the root user (UID 0) is dangerous, as the process would also have root access
    to the underlying host if it can break out of the container. Your application
    likely does not need the level of permission that root provides, so you should
    run the container as a non-root user instead to limit its available permissions.
  prefs: []
  type: TYPE_NORMAL
- en: While running a container as root is dangerous, due to the process isolation
    that containers provide, it does not quite grant all available Linux capabilities
    by default. As a result, some users, often mistakenly, will further escalate permissions
    by running containers as privileged. Running a container as privileged grants
    all capabilities to the container, allowing it to interact with the underlying
    host from within the container. If your application does require additional capabilities,
    rather than running the container as privileged, you can instead select the exact
    list of capabilities in `securityContext` of a pod that is desired. A list of
    capabilities can be found in the *CAPABILITIES(7)* page of the Linux manual pages
    ([http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the container image that has been deployed, chart developers
    should focus on the resources that have been granted to an application to ensure
    the integrity of the Kubernetes cluster. We will dive into this topic in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting resource requests and limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pods consume resources from the host (node) that it is running within. Resources
    are defined in terms of **requests** (the minimum amount of resources to allocate)
    and **limits** (the maximum amount of resources the pod is allowed to use). Pods
    that do not define requests run the risk of being scheduled on nodes that cannot
    support their minimum resource requirements. Pods that do not define limits run
    the risk of exhausting a node’s resources, resulting in pod eviction and resource
    contention with other workloads. Because of the issues that can occur when resource
    requests and limits are not set, chart developers should ensure that their charts
    define these resource constraints while allowing users to override them with Helm
    values as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, as a chart developer, you may write your chart so that it includes
    the following default values for configuring resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Then, if the chart is installed without explicitly setting the application’s
    resource requirements, the defaults would be applied to avoid under- or over-utilizing
    cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from resource requests and limits, a Kubernetes administrator can also
    create `LimitRange` and `ResourceQuota` objects to restrict the number of resources
    requested and consumed by applications within namespaces. The `LimitRange` and
    `ResourceQuota` objects are applied separately from Helm, usually as part of a
    namespace provisioning process.
  prefs: []
  type: TYPE_NORMAL
- en: '`LimitRanges` are used to restrict the number of resources a container or pod
    is allowed to consume within a given namespace. They are also used to set the
    default resources for containers that don’t already have resource limits defined.
    The following is an example of a `LimitRange` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the example, `LimitRange` sets the maximum amount of allowed container resources
    to 4 CPU cores and 16 Gi of memory. For containers whose resource limits are undefined,
    a limit of 500 millicores of CPU and 2 Gi of memory will automatically be applied.
    For containers whose resource requests are undefined, a request of 50 millicores
    of CPU and 128 Mi of memory will automatically be applied. `LimitRanges` can also
    be applied at the pod level by setting the `type` field to `Pod`. This setting
    ensures that the sum of resource utilization of all containers in the pod satisfies
    the specified limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to setting limits against CPU and memory utilization, you can configure
    `LimitRange` to restrict storage consumption by setting the `type` field to `PersistentVolumeClaim`.
    The following is a `LimitRange` example used to restrict storage claims to 8 Gi
    or fewer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'While `LimitRange` objects are used to restrict resources at the `Container`,
    `Pod`, or `PersistentVolumeClaim` level, `ResourceQuotas` are used by cluster
    administrators to restrict resource utilization at the namespace level. They are
    used to define the maximum number of resources a namespace can utilize in addition
    to limiting the amount of Kubernetes objects that can be created, such as Secrets
    and ConfigMaps. The following is an example `ResourceQuota` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This `ResourceQuota` would ensure that the sum of all CPU and memory requests
    and limits remain under the defined amounts. It also sets a limit on the storage
    for `PersistentVolumeClaims` that can be requested within the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: By setting reasonable defaults for resource constraints in your Helm charts,
    along with the usage of `LimitRange` and `ResourceQuotas`, you can ensure that
    users of your Helm charts do not exhaust cluster resources. You can also help
    ensure that applications request the minimum amount of resources necessary for
    a proper operation.
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of resource requests and limits, let’s move on to the
    next topic – handling secrets in Helm charts.
  prefs: []
  type: TYPE_NORMAL
- en: Handling secrets in Helm charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Handling secrets is a common concern when working with Helm charts. Consider
    the WordPress application from [*Chapter 3*](B17979_03.xhtml#_idTextAnchor083),
    *Installing Your First App with Helm*, where you were required to provide a password
    to configure an admin user. This password was not provided by default in the `values.yaml`
    file because this would have left the application vulnerable if you forgot to
    override the `password` value. Chart developers should be in the habit of not
    providing defaults for secret values, such as passwords, and should instead require
    users to provide an explicit value. This can easily be accomplished by leveraging
    the `required` function. Helm can also generate random strings using the `randAlphaNum`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `randAlphaNum` function generates a new random string each time
    the chart is upgraded. For that reason, developers should design charts with the
    expectation that users will provide their own password or another secret key,
    with the `required` function serving as a gate to ensure that a value is provided.
  prefs: []
  type: TYPE_NORMAL
- en: When using native Kubernetes resources to store secret information, chart developers
    should ensure that these sensitive assets are saved in a Kubernetes Secret, not
    a ConfigMap. Secrets and ConfigMaps are similar, but Secrets are reserved for
    sensitive data. Because secret and non-secret data is stored in separate objects,
    cluster administrators can set RBAC policies accordingly to restrict access to
    secret data while allowing permission to data that is non-secret (RBAC will be
    described further later in the *Configuring RBAC rules* section).
  prefs: []
  type: TYPE_NORMAL
- en: Chart users should ensure that secret values such as credentials are provided
    securely. Values are most commonly provided using the `--values` flag, in which
    properties are configured within `values` files. This is an appropriate method
    when working with non-secret values, but you should use caution when using this
    approach with secrets. Users should be sure that `values` files that contain secrets
    are not checked into a Git repository or an otherwise public location where those
    secrets could be exposed. One way that users can avoid exposing secrets is by
    leveraging the `--set` flag to pass secrets inline from the command line. This
    reduces the risk of credentials being exposed, but users should be aware that
    this could reveal the credentials in the bash history.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way that users can avoid exposing secrets is by leveraging an encryption
    tool to encrypt `values` files that contain secrets. This approach would continue
    to allow users to apply the `--values` flag, along with enabling the `values`
    file to be stored in a remote location, such as a Git repository. Then, the `values`
    file can only be decrypted by users that have the appropriate decryption key and
    would remain encrypted for all other users, only allowing trusted entities to
    access the data. Users can simply leverage GPG to encrypt the `values` files,
    or they can leverage a purpose-built tool such as **Secrets OPerationS** (**SOPS**).
    SOPS ([https://github.com/mozilla/sops](https://github.com/mozilla/sops)) is a
    tool designed to encrypt the values of YAML or JSON files, but leave the keys
    unencrypted. The following code depicts a secret key/value pair from a SOPS-encrypted
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `password` key is unencrypted but the value is encrypted. This
    allows you to easily see the types of values contained within the file without
    exposing their sensitive values.
  prefs: []
  type: TYPE_NORMAL
- en: There are other tools capable of encrypting `values` files that contain secrets.
    Some examples include `--set` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how security plays a role in Helm chart development,
    let’s discuss how **Role-Based Access Control** (**RBAC**) can be applied in Kubernetes
    to provide greater security to your users.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring RBAC rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ability of an authenticated user in Kubernetes to perform actions is governed
    by a set of RBAC policies. As introduced in [*Chapter 2*](B17979_02.xhtml#_idTextAnchor038),
    *Preparing a Kubernetes and Helm Environment*, policies, known as roles, can be
    associated with users or service accounts, and Kubernetes includes several roles
    with any installation. RBAC has been enabled by default in Kubernetes since version
    `1.6`. When thinking about Kubernetes RBAC in the context of Helm usage, you need
    to consider two factors:'
  prefs: []
  type: TYPE_NORMAL
- en: The user installing the Helm chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service account associated with the pod running the workload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, the individual responsible for installing a Helm chart is associated
    with a Kubernetes user. However, Helm charts can be installed through other means,
    such as by a Kubernetes operator with an associated service account.
  prefs: []
  type: TYPE_NORMAL
- en: By default, users and service accounts have minimal permissions in a Kubernetes
    cluster. Additional permissions are granted through the use of roles, which have
    been scoped to an individual namespace, or cluster roles, which grant access at
    a cluster level. These roles are then associated with a user or service account
    using either a role binding or a cluster role binding, depending on the type of
    policy being targeted. While Kubernetes has several included roles, the `Role`
    or `ClusterRole`, can be created that provides only the necessary permissions
    that the application needs. Since most typical users of a Kubernetes cluster do
    not have access to create resources at a cluster level, let’s create a role that
    is applied to the namespace that the Helm chart is deployed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `kubectl create role` command can be used to create a Kubernetes `Role`.
    Alternatively, the `Role` and `RoleBinding` resources could have been created
    using YAML definitions. A basic role contains two key elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of action (verb) made against the Kubernetes API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of Kubernetes resources to target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, to demonstrate how RBAC can be configured in Kubernetes, let’s
    configure a set of RBAC rules to allow an authenticated user to view Pods within
    a namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, be sure to start your minikube cluster and create a new namespace for
    this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, use the `kubectl` CLI to create a new role called `pod-viewer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this new role created, it needs to be associated with a user or service
    account. Since we want to associate the role with an application running in Kubernetes,
    we will apply the role to a service account. To abide by the Principle of Least
    Privilege, it is recommended to create a unique service account for the application
    (otherwise, the default service account would be used). This is to ensure that
    no other workloads are deployed in the same namespace that would accidentally
    inherit the same permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new service account called `example` by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create `RoleBinding` called `pod-viewers` and associate it with the
    `example` service account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the role and role binding created, the `example` service account has the
    appropriate permissions to list and get pods. To verify this assumption, we can
    use the `kubectl auth can-i` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `--as` flag makes use of the user impersonation feature in Kubernetes to
    allow you to debug authorization policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm that the service account cannot access a resource it should not
    be able to, such as listing Deployments, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output of `no` for listing Deployments and `yes` for
    listing pods, the expected policies are in place. This service account can now
    be referenced by a Helm chart. Alternatively, a Helm chart could be written to
    create the `ServiceAccount`, `Role`, and `RoleBinding` resources natively, assuming
    that a user installing the chart has the appropriate privileges required.
  prefs: []
  type: TYPE_NORMAL
- en: When used effectively, Kubernetes RBAC aids in providing Helm chart developers
    with the tools needed to enforce least-privilege access, protecting users and
    applications from potential errant or malicious actions.
  prefs: []
  type: TYPE_NORMAL
- en: To clean up from this exercise, you can delete your namespace with `kubectl
    delete ns chapter12` and stop your minikube cluster with `minikube stop`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s discuss how to access secure Helm chart repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing secure chart repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chart repositories allow you to discover Helm charts and install them on your
    Kubernetes cluster. Repositories were explored in [*Chapter 8*](B17979_08.xhtml#_idTextAnchor210),
    *Publishing to a Helm Chart Repository*. There, you learned how to serve charts
    using an HTTP server (demonstrated using GitHub Pages) and an OCI registry (demonstrated
    using GitHub’s container registry, `ghcr.io`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Most chart repositories are readily available and open for those who are interested.
    However, chart repositories and hosting services do provide additional security
    measures for interacting with content stored within a repository, including the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transport Layer Security** (**TLS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTTP(S)-based chart repositories support basic and certificate-based authentication.
    For basic authentication, a username and password can be provided when adding
    a repository using the `helm repo add` command through the use of the `--username`
    and `--password` flags. For example, if you wanted to access a repository that
    is protected via basic authentication, adding the repository would take the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Under certain circumstances, you may also need to use the `--pass-credentials`
    flag in addition to `--username` and `--password`. Recall that an `index.yaml`
    file contains indexing of all Helm charts within the chart repository. Within
    the `index.yaml` file is a property field named `urls` that refers to the location
    of the associated Helm chart. Typically, the `urls` field contains relative paths
    within the chart repository, but in some cases, a location at an entirely different
    domain can be specified. Without the `--pass-credentials` flag, Helm will not
    forward your username and password along to these domains, which is a security
    feature implemented in Helm 3.6.1 to prevent your information from being exposed.
    However, if you do need to pass your credentials to another domain to authenticate
    against those endpoints, you can provide the `--pass-credentials` flag when using
    the `helm repo add` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'OCI registries also support basic authentication using the `helm registry login`
    command. The username is provided using the `--username` flag, but there are two
    ways to specify the password:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--password`: Provides the password as an argument. This could reveal the password
    in plaintext in the bash history.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--password-stdin`: Provides the password from `stdin`. This allows you to
    keep the password hidden from the bash history by redirecting it from `stdin`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is recommended to use the `--password-stdin` flag to keep the password concealed
    from the bash history. As such, you can perform basic authentication against an
    OCI registry using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: While basic authentication is most commonly used, certificate-based authentication
    is another way of verifying a client’s identity. Helm, at the time of writing,
    does not provide flags for OCI certificate-based authentication, but for traditional
    Helm repositories, the Helm `repo add` command provides the `--cert-file` and
    `--key-file` flags, which are used to specify your client certificate and key,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling basic authentication and certificate authentication on the chart repository
    itself depends on the repository implementation that is used. For example, `--basic-auth-user`
    and `--basic-auth-pass` flags, which can be used on startup to configure the basic
    auth username and password. It also provides the `--tls-ca-cert` flag to configure
    the **certificate authority** (**CA**) certificate for certificate authentication.
    Other chart repository implementations may provide similar or additional capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Even with authentication in place, the packets sent between your Helm client
    and your chart repository must be transmitted securely using TLS-based encryption.
    While this is a given for certificate-based authentication, which leverages TLS
    natively, repositories that use basic authentication can still benefit from encrypting
    network traffic. Configuring TLS on the chart repository depends on the repository
    implementation being used, but for ChartMuseum, the `--tls-cert` and `--tls-key`
    flags can be used to provide the certificate chain and key files. More general
    web servers, such as NGINX, typically require a configuration file that provides
    the location of the certificate and key files on the server. Offerings such as
    GitHub Pages already have TLS configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the Helm repositories that we have used so far has used certificates
    signed by publicly available CAs that are stored in your web browser and underlying
    operating system. As a result, we did not need to go out of our way to trust their
    certificates. Many large organizations, however, have their own CAs that are used
    to produce the certificate for the chart repository. Since this certificate is
    likely not from a publicly available CA, the Helm CLI may not trust the certificate,
    resulting in the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To allow the Helm CLI to trust the chart repository’s certificate, the CA certificate,
    or CA bundle containing the certificate chain, can be added to the operating system’s
    trust store. Alternatively, for HTTPS chart repositories, the `--ca-file` flag
    can be added to the `helm repo add` command.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, depending on how the chart repository is configured, additional metrics
    can be obtained to perform request-level auditing and logging to determine who
    has attempted to access the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Through the use of authentication and TLS, additional capabilities can be realized
    for enhancing the security footprint of Helm repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about different topics around security that pertain
    to Helm usage. First, you learned how to prove the data provenance and integrity
    of Helm releases and Helm charts. Next, you learned about Helm chart security
    and how a chart developer can leverage security best practices to write a stable
    and secure Helm chart. Then, we focused on using RBAC to create an environment
    based on the Principle of Least Privilege, and we finished by talking about how
    chart repositories can be secured using authentication and TLS. Now, by employing
    each of these concepts, you are well equipped to create a secure Helm architecture
    and working environment.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for reading *Managing Kubernetes Resources Using Helm*! We hope that
    this book helps you be confident and efficient as you use Helm to work within
    the Kubernetes ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about data provenance and integrity in the context of Helm charts,
    go to [https://helm.sh/docs/topics/provenance/](https://helm.sh/docs/topics/provenance/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about Kubernetes RBAC, check out the *Using RBAC Authorization*
    section from the Kubernetes documentation at [https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the chart repository guide from the Helm documentation to learn more
    about chart repositories: [https://helm.sh/docs/topics/chart_repository/](https://helm.sh/docs/topics/chart_repository/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, visit the *Registries* page from the Helm documentation to learn more
    about OCI support: [https://helm.sh/docs/topics/registries/](https://helm.sh/docs/topics/registries/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are data provenance and integrity? How are data provenance and data integrity
    different?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What commands can a user run to verify the data provenance and integrity of
    a Helm chart? Which files are required to make this process possible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What considerations need to be taken into account to use and maintain secure
    container images?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to leverage resource requests and limits in your Helm chart?
    What other Kubernetes resources can be used to configure requests and limits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Principle of Least Privilege? Which Kubernetes resources allow you
    to configure authorization and achieve the least privilege?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which flags can you use to authenticate to an HTTP(S) repository?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which flags can you use to authenticate to an OCI registry?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
