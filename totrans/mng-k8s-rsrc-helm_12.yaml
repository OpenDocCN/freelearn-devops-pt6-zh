- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Helm Security Considerations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm安全性考虑
- en: As you have likely come to realize throughout this book, Helm is a powerful
    tool that makes deploying applications on Kubernetes simple and efficient. With
    that said, we need to ensure that we do not lose sight of security best practices
    when leveraging Helm. Luckily, Helm provides several ways to incorporate good
    security practices into everyday usage in ways that are simple to achieve, from
    the moment the Helm CLI is downloaded to the moment a Helm chart is installed
    into a Kubernetes cluster.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本书中可能已经意识到的，Helm是一个强大的工具，使得在Kubernetes上部署应用程序变得简单高效。话虽如此，我们需要确保在使用Helm时不忽视安全最佳实践。幸运的是，Helm提供了多种方式来将良好的安全实践融入到日常使用中，这些做法从下载Helm
    CLI的那一刻起，到将Helm图表安装到Kubernetes集群中的每一步都可以轻松实现。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主题：
- en: Data provenance and integrity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据来源和数据完整性
- en: Developing secure and stable Helm charts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发安全且稳定的Helm图表
- en: Configuring RBAC rules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置RBAC规则
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter will make use of the following technologies:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用以下技术：
- en: '`minikube`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minikube`'
- en: '`kubectl`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl`'
- en: '`helm`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`helm`'
- en: '`gpg` (GNU Privacy Guard)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpg`（GNU隐私保护）'
- en: You learned how to install and configure the `minikube`, `kubectl`, and `helm`
    **command-line interfaces** (**CLIs**) in [*Chapter 2*](B17979_02.xhtml#_idTextAnchor038),
    *Preparing a Kubernetes and Helm Environment*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何在[*第2章*](B17979_02.xhtml#_idTextAnchor038)《准备Kubernetes和Helm环境》中安装和配置`minikube`、`kubectl`和`helm`**命令行接口**（**CLIs**）。
- en: 'We will also leverage the guestbook chart from the Packt repository located
    at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm)
    for an exercise later in this chapter. If you have not already cloned the repository,
    you can do so with the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用位于[https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm)的Packt仓库中的guestbook图表，作为本章后续练习的一部分。如果你还没有克隆该仓库，可以使用以下命令进行克隆：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s begin by discussing data provenance and integrity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论数据来源和数据完整性开始。
- en: Data provenance and integrity
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据来源和数据完整性
- en: 'When working with any kind of data, two often-overlooked questions should be
    considered:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理任何类型的数据时，应考虑两个常被忽视的问题：
- en: Does the data come from a reliable source?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据来自可靠的源吗？
- en: Does the data contain all of the contents that you expected it to?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据是否包含你预期的所有内容？
- en: The first question relates to the topic of **data provenance**. Data provenance
    is about determining the origin of data and determining where the data originated
    from.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题与**数据来源**的话题有关。数据来源是指确定数据的起源，并确定数据来自何处。
- en: The second question refers to the topic of **data integrity**. Data integrity
    is about determining whether the contents you received from a remote location
    represents what you expected to receive. It helps determine whether data was tampered
    with as it was sent across the wire.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题涉及到**数据完整性**的话题。数据完整性是指确定你从远程位置接收到的内容是否与预期收到的内容一致。它有助于判断数据在传输过程中是否被篡改。
- en: Both data provenance and data integrity can be verified using a concept called
    **digital signatures**. An author can create a unique signature based on cryptography
    to sign data, and the consumer of that data can use cryptographic tools to verify
    the authenticity of that signature. If the authenticity is verified, then the
    consumer is assured that the data originates from the expected source and was
    not tampered with as it was transferred.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数据来源和数据完整性都可以通过一个叫做**数字签名**的概念来验证。作者可以基于加密技术创建一个唯一的签名来签署数据，数据的消费者可以使用加密工具来验证签名的真实性。如果真实性得到验证，那么消费者就可以确保数据来源于预期的源头，并且在传输过程中没有被篡改。
- en: Authors can create a digital signature using a variety of tools. One such method
    is by using **Pretty Good Privacy** (**PGP**). PGP, in this context, refers to
    OpenPGP, which is a set of standards based on encryption. PGP focuses on establishing
    asymmetric encryption, which is based on the use of two different keys – private
    and public.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作者可以使用多种工具创建数字签名。一个方法是使用**Pretty Good Privacy**（**PGP**）。在此背景下，PGP指的是OpenPGP，它是一组基于加密的标准。PGP的重点是建立非对称加密，基于使用两个不同的密钥——私钥和公钥。
- en: Private keys are meant to be kept secret, while public keys are designed to
    be shared. In PGP, the private key is used to encrypt data, while the public key
    is used by consumers to decrypt that data. The PGP key pair is often created using
    a tool called GPG, which is an open source tool that implements the OpenPGP standard.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥是用来保密的，而公钥是用于共享的。在 PGP 中，私钥用于加密数据，公钥则由消费者用于解密数据。PGP 密钥对通常通过一个名为 GPG 的工具来创建，这是一个实现
    OpenPGP 标准的开源工具。
- en: 'To begin working with PGP, the first step is to create the key pair, which
    will generate a set of public and private keys. Once the PGP key pair has been
    created, the author can use GPG to sign the data. When data has been signed, GPG
    performs the following steps in the background:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 PGP，第一步是创建密钥对，这将生成一组公钥和私钥。一旦 PGP 密钥对被创建，作者就可以使用 GPG 对数据进行签名。当数据被签名时，GPG
    在后台执行以下步骤：
- en: A hash is calculated based on the contents of the data. The output is a fixed-length
    string called the **message digest**.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于数据的内容计算哈希。输出结果是一个固定长度的字符串，称为**消息摘要**。
- en: The message digest is encrypted using the author’s private key. The output is
    the digital signature.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息摘要是使用作者的私钥进行加密的。输出结果即为数字签名。
- en: To verify the signature, consumers must use the author’s public key to decrypt
    it. This verification can also be performed using GPG.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证签名，消费者必须使用作者的公钥来解密它。此验证过程也可以使用 GPG 来执行。
- en: 'Digital signatures play a role in Helm in two ways:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名在 Helm 中扮演着两个角色：
- en: First, each Helm binary has an accompanying digital signature that’s owned by
    one of the Helm maintainers. This signature can be used to verify the origin of
    the download, as well as its integrity.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，每个 Helm 二进制文件都有一个数字签名，该签名由其中一位 Helm 维护者拥有。此签名可以用来验证下载的来源以及其完整性。
- en: Second, Helm charts can also be digitally signed so that they benefit from the
    same form of verifications. Authors of Helm charts can sign the chart during packaging,
    and the chart users can verify the chart’s authenticity by using the author’s
    public key.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，Helm charts 也可以进行数字签名，以便享受相同形式的验证。Helm charts 的作者可以在打包时对 chart 进行签名，chart
    用户则可以使用作者的公钥验证 chart 的真实性。
- en: Now that you understand how data provenance and integrity come into play concerning
    digital signatures, in the next section, you will create a GPG key pair on your
    local machine that will be used to elaborate on the previously described concepts.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了数据来源和完整性如何与数字签名相关联，在下一部分中，你将会在本地机器上创建一个 GPG 密钥对，用来详细说明前面提到的概念。
- en: Creating a GPG key pair
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个GPG密钥对
- en: 'To create a key pair, you must have GPG installed on your local machine. Use
    the following instructions as a guide to installing GPG on your respective machine.
    Note that this chapter is based on `gpg` version 2.3.6:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个密钥对，你必须在本地机器上安装 GPG。请按照以下说明作为指南，在你的机器上安装 GPG。请注意，本章基于`gpg`版本2.3.6：
- en: 'For Windows, you can use the Chocolatey package manager:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Windows，你可以使用 Chocolatey 包管理器：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can also download the installer for Windows from [https://gpg4win.org/download.html](https://gpg4win.org/download.html).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从[https://gpg4win.org/download.html](https://gpg4win.org/download.html)下载
    Windows 安装程序。
- en: 'For macOS, you can use the Homebrew package manager by using the following
    command:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 macOS，你可以使用 Homebrew 包管理器，通过以下命令来安装：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can also download the macOS-based installer from [https://sourceforge.net/p/gpgosx/docu/Download/](https://sourceforge.net/p/gpgosx/docu/Download/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从[https://sourceforge.net/p/gpgosx/docu/Download/](https://sourceforge.net/p/gpgosx/docu/Download/)下载基于
    macOS 的安装程序。
- en: 'For Debian-based Linux distributions, you can use the `apt` package manager:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于基于 Debian 的 Linux 发行版，你可以使用`apt`包管理器：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For RPM-based Linux distributions, you can use the `dnf` package manager:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于基于 RPM 的 Linux 发行版，你可以使用`dnf`包管理器：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once you have installed GPG, you can create your own GPG key pair, which we
    will use throughout our discussion on data provenance and integrity.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了 GPG，你就可以创建你自己的 GPG 密钥对，我们将在整个数据来源和完整性的讨论中使用它。
- en: 'Follow these steps to configure your key pair:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置你的密钥对：
- en: 'First, we need to begin the generation process by running the `gpg --full-generate-key`
    command:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要通过运行`gpg --full-generate-key`命令来开始生成过程：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For the `Please select what kind of key you want` prompt, select `(1) RSA and
    RSA`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`Please select what kind of key you want`提示，选择`(1) RSA and RSA`：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The reason we are using RSA instead of the default option (ECC) is that ECC
    is not supported by the crypto library used in Helm’s source code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用RSA而不是默认选项（ECC）的原因是ECC不被Helm源代码中使用的加密库支持。
- en: 'Next, you will be prompted to enter the key size. For this example, we can
    simply select the default, so continue by pressing the *Enter* key:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，系统将提示您输入密钥大小。在本示例中，我们可以简单地选择默认值，因此按*Enter*键继续：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After you enter your key size, you will be asked how long the key should be
    valid. Since this key will be used solely to run through the examples, we recommend
    setting a short expiration, such as 1 week (`1w`):'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您输入密钥大小后，系统将询问密钥的有效期。由于此密钥仅用于通过示例，我们建议设置较短的过期时间，例如1周（`1w`）：
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, you will be prompted for your name and email address. These will be used
    to identify you as the owner of the key pair and will be the name and email address
    displayed by those who receive your public key. You will also be prompted to provide
    a comment, which you can simply leave blank:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，系统将提示您输入姓名和电子邮件地址。这些信息将用于标识您为密钥对的拥有者，并且将在接收您公钥的人那里显示您的姓名和电子邮件地址。系统还会提示您提供一个评论，您可以将其留空：
- en: '[PRE9]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Press the *O* key to continue.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*O*键继续。
- en: Finally, you will be prompted to enter your private key passphrase. Providing
    a strong passphrase is essential for protecting your identity in the event your
    private key is stolen. This is because it must be provided each time you attempt
    to access your key.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，系统将提示您输入私人密钥的密码短语。提供强密码短语对于保护您的身份至关重要，以防您的私人密钥被盗。因为每次您尝试访问密钥时，都必须提供密码短语。
- en: To keep our example simple, we will create an empty string passphrase to avoid
    passphrase prompts. While this is acceptable in this demonstration, you should
    protect any private key you intend to use in a real-world situation with a strong
    passphrase.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持示例简洁，我们将创建一个空字符串密码短语，以避免密码短语提示。虽然在本演示中这样做是可以接受的，但您应该在实际使用中为任何私人密钥设置强密码进行保护。
- en: To continue, simply press *Enter* to submit an empty passphrase. When prompted,
    select `<Yes, protection is not needed>`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续，只需按*Enter*键提交一个空的密码短语。当提示时，选择`<是的，不需要保护>`。
- en: 'Once your GPG key pair has been created, you will see an output similar to
    the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的GPG密钥对创建完成，您将看到类似以下内容的输出：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding output displays information about the public (`pub`) and private
    (`sub`) keys, as well as the fingerprint of the public key (the second line of
    the output). The fingerprint is a unique identifier that’s used to identify you
    as the owner of that key. The third line, beginning with `uid`, displays the name
    and email address that you entered when generating the GPG key pair.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示了公钥（`pub`）和私钥（`sub`）的信息，以及公钥的指纹（输出的第二行）。指纹是一个唯一的标识符，用于识别您为该密钥的所有者。第三行以`uid`开头，显示了您在生成GPG密钥对时输入的姓名和电子邮件地址。
- en: With your key pair now created, let’s continue to the next section to learn
    how a Helm binary can be verified.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥对创建完成后，让我们继续下一部分，了解如何验证Helm二进制文件。
- en: Verifying Helm downloads
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证Helm下载
- en: 'As discussed in [*Chapter 2*](B17979_02.xhtml#_idTextAnchor038), *Preparing
    a Kubernetes and Helm Environment*, one of the ways Helm can be installed is by
    downloading an archive from GitHub. These archives can be installed from Helm’s
    GitHub releases page ([https://github.com/helm/helm/releases](https://github.com/helm/helm/releases))
    by selecting one of the links shown in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[*第2章*](B17979_02.xhtml#_idTextAnchor038)中讨论的，*准备Kubernetes和Helm环境*，Helm可以通过从GitHub下载存档来安装。这些存档可以通过访问Helm的GitHub发布页面（[https://github.com/helm/helm/releases](https://github.com/helm/helm/releases)）并选择以下截图中显示的链接来安装：
- en: '![Figure 12.1 – The Installation and Upgrading section of Helm’s GitHub releases
    page'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – Helm GitHub发布页面的安装和升级部分'
- en: '](img/Figure_12.01_B17979.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.01_B17979.jpg)'
- en: Figure 12.1 – The Installation and Upgrading section of Helm’s GitHub releases
    page
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – Helm GitHub发布页面的安装和升级部分
- en: 'At the bottom of the preceding screenshot, you will notice a paragraph explaining
    that the release was signed. Each Helm release is signed by a Helm maintainer
    and can be verified against the digital signature that corresponds to the downloaded
    release. Each of the signatures is located under the **Assets** section, as shown
    here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面截图的底部，你会看到一段说明，解释了该版本已被签名。每个 Helm 发布版本都会由一个 Helm 维护者签名，并且可以通过与下载版本对应的数字签名进行验证。每个签名位于**Assets**部分，如下所示：
- en: '![Figure 12.2 – The Assets section of Helm’s GitHub releases page'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.2 – Helm GitHub 发布页面的 Assets 部分'
- en: '](img/Figure_12.02_B17979.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.02_B17979.jpg)'
- en: Figure 12.2 – The Assets section of Helm’s GitHub releases page
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – Helm GitHub 发布页面的 Assets 部分
- en: To verify the provenance and integrity of a Helm download, in addition to the
    binary itself, you should also download the corresponding `.asc` file. Note that
    `sha256` files are used to verify the integrity only. In this example, we will
    download the `.tar.gz.asc` file, which verifies both provenance and integrity.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证 Helm 下载的来源和完整性，除了下载二进制文件本身外，你还应该下载相应的 `.asc` 文件。请注意，`sha256` 文件仅用于验证完整性。在此示例中，我们将下载
    `.tar.gz.asc` 文件，它用于验证来源和完整性。
- en: 'Let’s demonstrate how a Helm release can be verified. First, we should download
    a Helm archive, along with its corresponding `.asc` file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示如何验证一个 Helm 发布版本。首先，我们应该下载一个 Helm 压缩包，并获取相应的 `.asc` 文件：
- en: 'Download a Helm archive that corresponds with your operating system. For this
    example, we will use version 3.8.2\. If you are running an AMD64-based Linux system,
    the version for this distribution can be downloaded from the GitHub release page
    or by using the following `curl` command:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载与你操作系统相对应的 Helm 压缩包。对于本示例，我们将使用 3.8.2 版本。如果你使用的是基于 AMD64 的 Linux 系统，可以从 GitHub
    发布页面下载该版本，或者使用以下 `curl` 命令：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, download the`.asc` file that corresponds with your operating system.
    When running an AMD64-based Linux system, `helm-v3.8.2-linux-amd64.tar.gz.asc`
    would be the resulting file that would be downloaded. You can download this file
    from the GitHub release page or by using the following `curl` command:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，下载与你操作系统相对应的 `.asc` 文件。当运行基于 AMD64 的 Linux 系统时，`helm-v3.8.2-linux-amd64.tar.gz.asc`
    将是下载的文件。你可以从 GitHub 发布页面下载此文件，或使用以下 `curl` 命令：
- en: '[PRE12]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once both files have been downloaded, you should see the two files located
    within the same directory on the command line:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完这两个文件后，你应该能够在命令行中看到它们位于同一目录中：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The next step involves importing the Helm maintainer’s public key to your local
    GPG keyring. This allows you to decrypt the digital signature contained in the
    `.asc` file to verify the provenance and integrity of your downloaded binary.
    GPG public keys are saved in public key servers such as `keyserver.ubuntu.com`
    and `pgp.mit.edu`. As such, we can use the `gpg --recv-key` command to download
    the maintainer’s key from a public key server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将 Helm 维护者的公钥导入到你的本地 GPG 密钥环中。这将允许你解密 `.asc` 文件中的数字签名，从而验证你下载的二进制文件的来源和完整性。GPG
    公钥保存在公钥服务器中，例如 `keyserver.ubuntu.com` 和 `pgp.mit.edu`。因此，我们可以使用 `gpg --recv-key`
    命令从公钥服务器下载维护者的密钥。
- en: 'Let’s import the maintainer’s public key and continue with the verification
    process:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导入维护者的公钥并继续验证过程：
- en: 'First, recall the maintainer’s public key fingerprint from *Figure 12.1*:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，回想一下维护者的公钥指纹（见*图 12.1*）：
- en: '[PRE14]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Use the `gpg --recv-key` command to download and import the key into your local
    keychain:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `gpg --recv-key` 命令下载并导入公钥到你的本地密钥链中：
- en: '[PRE15]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that the public key has been imported, you can verify the Helm release
    by using the `--verify` subcommand of GPG. This command has the `gpg --verify
    <signature> <data>` syntax:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在公钥已经导入，你可以使用 GPG 的 `--verify` 子命令来验证 Helm 发布版本。该命令的语法为 `gpg --verify <signature>
    <data>`：
- en: '[PRE16]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This command decrypts the digital signature contained in the `.asc` file. If
    it is successful, it means that the Helm download (the file ending in `.tar.gz`)
    was signed by the person you expected (Matt Farina for this release) and that
    the download was not modified or altered in any way. A successful output looks
    similar to the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令解密 `.asc` 文件中的数字签名。如果成功，说明该 Helm 下载（以 `.tar.gz` 结尾的文件）是由你预期的人（本次版本为 Matt
    Farina）签署的，并且下载文件没有被修改或篡改。成功的输出类似于以下内容：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Upon further inspection of this output, you may notice the `WARNING` message,
    indicating that the key was not certified, which may lead you to question whether
    or not the verification was successful. In this case, the verification was indeed
    successful, but you have not certified the maintainer’s key yet, so GPG returns
    this warning.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 经过进一步检查，你可能会注意到 `WARNING` 消息，表示密钥尚未被认证，这可能会让你怀疑验证是否成功。在这种情况下，验证确实成功，但你还没有认证维护者的密钥，所以
    GPG 返回了这个警告。
- en: 'The `This key is not certified` message is normally not an issue, but if you
    would like to ensure this warning does not appear in the future, you can follow
    these steps to certify the maintainer’s public key:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`This key is not certified` 消息通常不是问题，但如果你希望确保将来不再出现此警告，可以按照以下步骤认证维护者的公钥：'
- en: 'Check that the public key’s fingerprint (also referred to as the primary key
    from the `gpg –verify` output) matches the fingerprint displayed on the Helm releases
    page. As you will recall from *Figure 12.1*, the fingerprint was displayed, as
    shown here:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查公钥的指纹（也称为 `gpg --verify` 输出中的主密钥）是否与 Helm 发布页面上显示的指纹匹配。如你所记得，*图 12.1* 中已经显示了该指纹，如下所示：
- en: '[PRE18]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Because the key we imported matches the fingerprint displayed on GitHub, we
    know that we can trust this key. Trust can be associated with this key by using
    the `gpg --sign-key` subcommand:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们导入的密钥与 GitHub 上显示的指纹匹配，我们知道可以信任该密钥。通过使用 `gpg --sign-key` 子命令，可以将信任与此密钥关联：
- en: '[PRE19]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `Really sign?` prompt, enter `y`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Really sign?` 提示中，输入 `y`。
- en: 'Now that you have signed the maintainer’s public key, the key has been certified.
    The next time you perform a verification with this key, you should no longer see
    the warning message:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经签署了维护者的公钥，该密钥已被认证。下次你使用该密钥进行验证时，应该不再看到警告消息：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Digital signatures also play a role in signing and verifying Helm charts. We
    will explore this topic in the next section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名在签署和验证 Helm 图表中也起着重要作用。我们将在下一节中探讨这一主题。
- en: Signing and verifying Helm charts
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 签署和验证 Helm 图表
- en: Similar to how the Helm maintainers sign releases, you can sign your Helm charts
    so that users can verify its origin as well as confirm it contains the expected
    content. To sign a chart, you must have a GPG key pair present on your local workstation
    (we created a GPG key pair earlier in the *Creating a GPG key pair* section).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Helm 维护者签署发布版本的方式类似，你也可以签署你的 Helm 图表，以便用户可以验证其来源并确认其内容符合预期。要签署一个图表，你必须在本地工作站上拥有一对
    GPG 密钥（我们在 *创建 GPG 密钥对* 部分中已创建了 GPG 密钥对）。
- en: There is one important caveat to note before we start signing charts. If you
    are using GPG version 2 or greater, you must export your public and secret keyrings
    to a legacy format. Early versions of GPG stored keyrings in the `.gpg` file format,
    which is the format that Helm expects your keyring to be in (at the time of writing).
    Newer versions of GPG store keyrings in the `.kbx` file format, which is not compatible
    at the time of writing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始签署图表之前，有一个重要的警告需要注意。如果你使用的是 GPG 版本 2 或更高版本，你必须将公钥和私钥导出为旧版格式。早期版本的 GPG 将密钥环存储在
    `.gpg` 文件格式中，这是 Helm 所期望的密钥环格式（在撰写本文时）。较新的 GPG 版本将密钥环存储在 `.kbx` 文件格式中，这在撰写本文时并不兼容。
- en: 'Luckily, we can export our keys in the `.gpg` format by following these steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过以下步骤将密钥导出为 `.gpg` 格式：
- en: 'First, find your GPG version by running the following command:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过运行以下命令找到你的 GPG 版本：
- en: '[PRE21]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If your GPG version is 2 or greater, export your public and secret keyrings
    using the `gpg --export` and `gpg --export-secret-keys` commands:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的 GPG 版本是 2 或更高版本，使用 `gpg --export` 和 `gpg --export-secret-keys` 命令导出你的公钥和私钥：
- en: '[PRE22]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once your keyrings have been exported, you will be able to sign your charts
    using the `helm package` command. The `helm package` command provides three key
    flags that allow you to sign and package charts:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的密钥环已被导出，你将能够使用 `helm package` 命令签署图表。`helm package` 命令提供了三个关键标志，允许你签署并打包图表：
- en: '`--sign`: This allows you to sign a chart using a PGP private key.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--sign`：这允许你使用 PGP 私钥签署图表。'
- en: '`--key`: The name of the key to use when signing.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--key`：签名时使用的密钥名称。'
- en: '`--keyring`: The location of the keyring containing the PGP private key.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--keyring`：包含 PGP 私钥的密钥环位置。'
- en: 'Let’s run the `helm package` command to sign the guestbook Helm chart from
    the Packt repository:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 `helm package` 命令，签署来自 Packt 仓库的 guestbook Helm 图表：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `<key_name>` placeholder refers to either the email, name, or fingerprint
    associated with the desired key. These details can be found by using the `gpg
    --list-keys` command.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`<key_name>`占位符指的是与所需密钥相关的电子邮件、名称或指纹。这些细节可以通过使用`gpg --list-keys`命令找到。'
- en: 'If the `helm package` command is successful, you will see the following files
    displayed in the current directory:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`helm package`命令成功，你将在当前目录中看到以下文件：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `guestbook-0.1.0.tgz` file is the archive that contains the Helm chart.
    This file is always created by `helm package`, whether you are signing the chart
    or not.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`guestbook-0.1.0.tgz`文件是包含Helm chart的归档文件。无论是否签署chart，这个文件总是由`helm package`创建的。'
- en: 'The `guestbook-0.1.0.tgz.prov` file is called a **provenance file**. The provenance
    file contains a provenance record, which contains the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`guestbook-0.1.0.tgz.prov`文件称为**证明文件**。证明文件包含一个证明记录，记录内容包括以下内容：'
- en: The chart metadata from the file
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件中的chart元数据
- en: The sha256 hash of the `guestbook-0.1.0.tgz` file
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`guestbook-0.1.0.tgz`文件的sha256哈希值'
- en: The PGP digital signature
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PGP数字签名
- en: Helm chart consumers leverage provenance files to verify the data provenance
    and integrity of the chart that they have downloaded. So, chart developers should
    be sure to publish both the `.tgz` archive as well as the `.tgz.prov` provenance
    file to their Helm chart repository.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Helm chart的使用者利用证明文件来验证他们下载的chart的数据来源和完整性。因此，chart开发人员应确保将`.tgz`归档文件和`.tgz.prov`证明文件都发布到Helm
    chart仓库中。
- en: 'While you have successfully signed the guestbook chart and have created the
    `.tgz.prov` file, it is not quite enough for users to verify the chart, as they
    still need to access your public key to decrypt your signature. You can make this
    key available for users by publishing it to the PGP key servers with the `gpg
    --send-key` command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你已经成功签署了guestbook chart并创建了`.tgz.prov`文件，但这还不足以让用户验证chart，因为他们仍然需要访问你的公钥来解密你的签名。你可以通过`gpg
    --send-key`命令将此密钥发布到PGP密钥服务器，以便用户获取：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'End users can then download and import this key by using the `gpg --recv-key`
    command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户可以使用`gpg --recv-key`命令下载并导入此密钥：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once a user has imported your public key (and exported it to the `~/.gnupg/pubring.gpg`
    keyring, as shown earlier in this section), they can verify your Helm chart by
    using the `helm verify` command, provided both the `.tgz` chart archive and `.tgz.prov`
    provenance file have been downloaded to the same directory:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户导入了你的公钥（并将其导出到`~/.gnupg/pubring.gpg`密钥环，如本节前面所示），他们可以通过使用`helm verify`命令验证你的Helm
    chart，前提是`.tgz` chart归档文件和`.tgz.prov`证明文件都已下载到同一目录：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If verification is successful, you will see that the signer, the signer’s public
    key, and the chart have been verified. Otherwise, an error will be returned. The
    verification could fail for a variety of reasons, including the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验证成功，你将看到签名者、签名者的公钥和chart已经被验证。否则，会返回一个错误。验证可能失败的原因包括：
- en: The `.tgz` and `.tgz.prov` files are not in the same directory.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.tgz`和`.tgz.prov`文件不在同一目录中。'
- en: The `.tgz` or `.tgz.prov` files are corrupt.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.tgz`或`.tgz.prov`文件已损坏。'
- en: The file hashes do not match, indicating a loss of integrity.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件哈希不匹配，表示完整性丧失。
- en: The public key used to decrypt the signature does not match the private key
    originally used to encrypt it.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于解密签名的公钥与最初用于加密签名的私钥不匹配。
- en: The `helm verify` command is designed to be run on locally downloaded charts,
    so users may find it better to leverage the `helm install --verify` command instead,
    which performs the verification and installation in a single command, assuming
    that the `.tgz` and .`tgz.prov` files can both be downloaded from a chart repository.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm verify`命令旨在运行在本地下载的charts上，因此用户可能会发现使用`helm install --verify`命令更为方便，该命令在一个命令中执行验证和安装，前提是`.tgz`和`.tgz.prov`文件都可以从chart仓库下载。'
- en: 'The following command describes how the `helm install --verify` command can
    be used:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令描述了如何使用`helm install --verify`命令：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By using the methodologies described in this section, chart developers and consumers
    can be assured that the content is sourced from a trusted origin and has been
    unaltered.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本节中描述的方法，chart开发人员和使用者可以确保内容来自可信的来源，并且未被篡改。
- en: With an understanding of how data provenance and integrity play a role in Helm,
    let’s continue discussing Helm security considerations by moving on to our next
    topic – security concerning Helm charts and Helm chart development.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数据溯源和完整性在 Helm 中的作用后，让我们继续讨论 Helm 安全性问题，转到下一个话题——关于 Helm 图表及其开发的安全性。
- en: Developing secure and stable Helm charts
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发安全且稳定的 Helm 图表
- en: While provenance and integrity play a major role in the security of Helm, they
    are not the only concerns you need to consider. During the development process,
    chart developers should ensure that they are adhering to best practices around
    security to prevent vulnerabilities from being introduced when a user installs
    their chart into a Kubernetes cluster. In this section, we will discuss many of
    the concerns surrounding security as it relates to Helm chart development and
    what you, as a developer, can do to write Helm charts with security as a priority.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然溯源和完整性在 Helm 安全性中扮演着重要角色，但它们并不是你需要考虑的唯一问题。在开发过程中，图表开发者应确保他们遵循安全最佳实践，以防止在用户将图表安装到
    Kubernetes 集群时引入漏洞。在本节中，我们将讨论与 Helm 图表开发相关的许多安全问题，以及作为开发者，你可以做些什么，将安全性作为编写 Helm
    图表的优先事项。
- en: We will begin by discussing the security around any container images that your
    Helm chart may reference.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论关于 Helm 图表可能引用的任何容器镜像的安全性。
- en: Using secure images
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用安全的镜像
- en: Since the goal of Helm (and Kubernetes) is to deploy container images, the image
    itself presents several areas of consideration concerning security. To start,
    chart developers should be aware of the differences between image tags and image
    digests.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Helm（和 Kubernetes）的目标是部署容器镜像，因此镜像本身涉及多个安全方面的考虑。首先，图表开发者应该了解镜像标签和镜像摘要之间的区别。
- en: A tag is a human-readable reference to a given image and provides both developers
    and consumers with an easy way to reference an image. However, tags can present
    a security concern as there are no guarantees that the contents of a given tag
    will always remain the same. The image owner may choose to push an updated image
    using the same tag, which would result in a different underlying image being executed
    at runtime (even though the tag is the same). Performing these actions against
    the same tag introduces the possibility of regressions, which can cause unexpected
    adverse effects for end users. Instead of referencing an image by tag, images
    can also be referenced by digest. An image digest is a computed `SHA-256` value
    of an image that not only provides an immutable identifier to an exact image but
    also allows for the container runtime to verify the integrity of the image that
    is retrieved from a remote registry. This removes the risk of deploying an image
    that contains an accidental regression against a given tag and can also remove
    the risks of a man-in-the-middle attack, where the tag’s contents are modified
    with malicious intent.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是对给定镜像的可读引用，为开发人员和使用者提供了一个便捷的方式来引用镜像。然而，标签可能带来安全隐患，因为无法保证给定标签的内容始终保持不变。镜像所有者可能会选择使用相同的标签推送更新的镜像，这会导致在运行时执行的是不同的底层镜像（即使标签相同）。在相同标签下执行这些操作，会引入回归的可能性，这可能会给最终用户带来意想不到的不良影响。与其通过标签引用镜像，不如通过摘要来引用镜像。镜像摘要是一个计算出的`SHA-256`值，它不仅提供了一个不可变的标识符来精确标识镜像，还允许容器运行时验证从远程注册表获取的镜像的完整性。这消除了部署包含意外回归的镜像的风险，同时也能消除中间人攻击的风险，其中标签的内容被恶意篡改。
- en: As an example, an image referenced as `quay.io/bitnami/redis:5.0.9` in a chart
    template can be referenced by a digest as `quay.io/bitnami/redis@sha256:70b816f2127afb5d4af7ec9d6e8636b2f0f973a3cd8dda7032f9dcffa38ba11f`.
    Notice that instead of specifying the name of a tag after the name of the image,
    the `SHA-256` digest is explicitly specified. This assures that the image content
    will not change over time, even if the tag changes, thus strengthening your security
    posture.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，图表模板中引用的镜像`quay.io/bitnami/redis:5.0.9`可以通过摘要引用为`quay.io/bitnami/redis@sha256:70b816f2127afb5d4af7ec9d6e8636b2f0f973a3cd8dda7032f9dcffa38ba11f`。请注意，镜像名称后面不是指定标签的名称，而是明确指定了`SHA-256`摘要。这确保了即使标签发生变化，镜像内容也不会改变，从而增强了你的安全性。
- en: As time progresses, a tag or a digest may become unsafe for deployment, as vulnerabilities
    may eventually be found in the underlying packages or base components. There are
    many different ways to determine whether there are any vulnerabilities associated
    with a given image. One way is to leverage the native capabilities of the registry
    that the image belongs to. Many different image registry solutions contain capabilities
    around image vulnerability scanning that can help provide insight as to when an
    image is vulnerable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，某个标签或摘要可能变得不适合部署，因为最终可能会发现底层包或基础组件存在漏洞。有许多不同的方法可以确定给定镜像是否存在漏洞。一种方法是利用该镜像所属镜像库的原生功能。许多不同的镜像库解决方案都包含有关镜像漏洞扫描的功能，可以帮助提供何时镜像存在漏洞的洞察。
- en: The Quay container registry, for example, can automatically scan images at specified
    intervals to determine vulnerabilities that may be present within a given image.
    The Nexus and Artifactory container registries are also examples of container
    registries that have similar capabilities. Outside of native scanning capabilities
    provided by container registries, other tools can be leveraged, such as **Vuls**
    and **OpenSCAP**. When your image registry or standalone scanning tool reports
    that an image is vulnerable, you should immediately update your chart’s image
    to a newer version, if available, to prevent vulnerabilities from being introduced
    to your users’ Kubernetes clusters.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Quay容器镜像库可以在指定的时间间隔内自动扫描镜像，以确定给定镜像中可能存在的漏洞。Nexus和Artifactory容器镜像库也是具备类似功能的容器镜像库的例子。在容器镜像库提供的原生扫描功能之外，还可以使用其他工具，如**Vuls**和**OpenSCAP**。当你的镜像库或独立扫描工具报告镜像存在漏洞时，应立即将图表中的镜像更新为较新版本（如果有的话），以防止漏洞进入用户的Kubernetes集群。
- en: To help simplify the process of updating the container image, you can develop
    a regular cadence where image updates are checked. This helps prevent you from
    getting to a point where your target image contains vulnerabilities that make
    it unfit for deployment. Many teams and organizations also restrict the source
    of images to trusted registries to reduce the potential of running images that
    do contain vulnerabilities. This setting can be configured at the container runtime
    level or within policies applied to a Kubernetes cluster. The specific location
    and configurations vary based on the specific implementation(s).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化更新容器镜像的过程，你可以制定一个定期检查镜像更新的计划。这有助于防止目标镜像中出现漏洞，进而使其不适合部署。许多团队和组织也将镜像的来源限制为受信任的镜像库，以减少运行包含漏洞的镜像的风险。此设置可以在容器运行时层面配置，或在应用到Kubernetes集群的策略中进行配置。具体的位置和配置会根据具体的实现方式有所不同。
- en: Apart from image vulnerability scanning and content sourcing, you should also
    avoid deploying images that run as **root** or **privileged**. Running containers
    as the root user (UID 0) is dangerous, as the process would also have root access
    to the underlying host if it can break out of the container. Your application
    likely does not need the level of permission that root provides, so you should
    run the container as a non-root user instead to limit its available permissions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了镜像漏洞扫描和内容来源外，你还应该避免部署以**root**或**privileged**身份运行的镜像。以root用户（UID 0）身份运行容器是危险的，因为如果容器能够突破隔离，它将获得对底层主机的root访问权限。你的应用程序可能并不需要root提供的权限级别，因此你应该改为以非root用户身份运行容器，以限制其可用的权限。
- en: While running a container as root is dangerous, due to the process isolation
    that containers provide, it does not quite grant all available Linux capabilities
    by default. As a result, some users, often mistakenly, will further escalate permissions
    by running containers as privileged. Running a container as privileged grants
    all capabilities to the container, allowing it to interact with the underlying
    host from within the container. If your application does require additional capabilities,
    rather than running the container as privileged, you can instead select the exact
    list of capabilities in `securityContext` of a pod that is desired. A list of
    capabilities can be found in the *CAPABILITIES(7)* page of the Linux manual pages
    ([http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以 root 身份运行容器是危险的，但由于容器提供的进程隔离功能，它默认并不会授予所有可用的 Linux 能力。因此，一些用户往往错误地通过以特权模式运行容器来进一步提升权限。以特权模式运行容器会授予容器所有能力，允许它在容器内部与底层主机进行交互。如果你的应用程序确实需要额外的能力，可以通过在
    pod 的 `securityContext` 中选择所需的具体能力列表，而不是以特权模式运行容器。可以在 Linux 手册页的*CAPABILITIES(7)*
    页面中找到能力的列表（[http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)）。
- en: In addition to the container image that has been deployed, chart developers
    should focus on the resources that have been granted to an application to ensure
    the integrity of the Kubernetes cluster. We will dive into this topic in the next
    section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已经部署的容器镜像外，chart 开发者应关注已授予应用程序的资源，以确保 Kubernetes 集群的完整性。我们将在下一节中深入探讨这个话题。
- en: Setting resource requests and limits
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置资源请求和限制
- en: Pods consume resources from the host (node) that it is running within. Resources
    are defined in terms of **requests** (the minimum amount of resources to allocate)
    and **limits** (the maximum amount of resources the pod is allowed to use). Pods
    that do not define requests run the risk of being scheduled on nodes that cannot
    support their minimum resource requirements. Pods that do not define limits run
    the risk of exhausting a node’s resources, resulting in pod eviction and resource
    contention with other workloads. Because of the issues that can occur when resource
    requests and limits are not set, chart developers should ensure that their charts
    define these resource constraints while allowing users to override them with Helm
    values as needed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 从它们运行的主机（节点）中消耗资源。资源通过**请求**（分配的最小资源量）和**限制**（pod 允许使用的最大资源量）来定义。没有定义请求的
    pods 有可能被调度到不能满足其最小资源需求的节点上。没有定义限制的 pods 有可能会耗尽节点资源，导致 pod 被驱逐，并与其他工作负载发生资源争用。由于未设置资源请求和限制可能会导致的问题，chart
    开发者应确保他们的 charts 定义了这些资源约束，并允许用户根据需要通过 Helm 值进行覆盖。
- en: 'For example, as a chart developer, you may write your chart so that it includes
    the following default values for configuring resources:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，作为一个 chart 开发者，你可能会编写你的 chart，使其包括以下默认值来配置资源：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Then, if the chart is installed without explicitly setting the application’s
    resource requirements, the defaults would be applied to avoid under- or over-utilizing
    cluster resources.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果没有明确设置应用程序的资源需求，chart 被安装时会应用这些默认值，以避免集群资源的过度或不足利用。
- en: Apart from resource requests and limits, a Kubernetes administrator can also
    create `LimitRange` and `ResourceQuota` objects to restrict the number of resources
    requested and consumed by applications within namespaces. The `LimitRange` and
    `ResourceQuota` objects are applied separately from Helm, usually as part of a
    namespace provisioning process.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了资源请求和限制外，Kubernetes 管理员还可以创建 `LimitRange` 和 `ResourceQuota` 对象，以限制在命名空间内应用程序请求和消耗的资源数量。`LimitRange`
    和 `ResourceQuota` 对象通常与 Helm 分开应用，通常作为命名空间配置过程的一部分。
- en: '`LimitRanges` are used to restrict the number of resources a container or pod
    is allowed to consume within a given namespace. They are also used to set the
    default resources for containers that don’t already have resource limits defined.
    The following is an example of a `LimitRange` definition:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`LimitRanges` 用于限制容器或 pod 在给定命名空间内允许消耗的资源数量。它们也用于为那些没有已定义资源限制的容器设置默认资源。以下是一个
    `LimitRange` 定义的示例：'
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the example, `LimitRange` sets the maximum amount of allowed container resources
    to 4 CPU cores and 16 Gi of memory. For containers whose resource limits are undefined,
    a limit of 500 millicores of CPU and 2 Gi of memory will automatically be applied.
    For containers whose resource requests are undefined, a request of 50 millicores
    of CPU and 128 Mi of memory will automatically be applied. `LimitRanges` can also
    be applied at the pod level by setting the `type` field to `Pod`. This setting
    ensures that the sum of resource utilization of all containers in the pod satisfies
    the specified limits.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在该示例中，`LimitRange` 将允许的最大容器资源限制设置为 4 个 CPU 核心和 16 Gi 内存。对于资源限制未定义的容器，将自动应用 500
    毫核 CPU 和 2 Gi 内存的限制。对于资源请求未定义的容器，将自动应用 50 毫核 CPU 和 128 Mi 内存的请求。通过将 `type` 字段设置为
    `Pod`，`LimitRanges` 也可以在 pod 级别应用。此设置确保 pod 中所有容器的资源使用总和满足指定的限制。
- en: 'In addition to setting limits against CPU and memory utilization, you can configure
    `LimitRange` to restrict storage consumption by setting the `type` field to `PersistentVolumeClaim`.
    The following is a `LimitRange` example used to restrict storage claims to 8 Gi
    or fewer:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置对 CPU 和内存使用率的限制外，您还可以配置 `LimitRange` 来限制存储消耗，通过将 `type` 字段设置为 `PersistentVolumeClaim`。以下是一个
    `LimitRange` 示例，用于将存储请求限制为 8 Gi 或更少：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'While `LimitRange` objects are used to restrict resources at the `Container`,
    `Pod`, or `PersistentVolumeClaim` level, `ResourceQuotas` are used by cluster
    administrators to restrict resource utilization at the namespace level. They are
    used to define the maximum number of resources a namespace can utilize in addition
    to limiting the amount of Kubernetes objects that can be created, such as Secrets
    and ConfigMaps. The following is an example `ResourceQuota` definition:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `LimitRange` 对象用于限制 `Container`、`Pod` 或 `PersistentVolumeClaim` 级别的资源，`ResourceQuotas`
    则由集群管理员在命名空间级别限制资源使用。它们用于定义一个命名空间可以使用的最大资源数量，并限制可以创建的 Kubernetes 对象的数量，例如 Secrets
    和 ConfigMaps。以下是一个 `ResourceQuota` 定义示例：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This `ResourceQuota` would ensure that the sum of all CPU and memory requests
    and limits remain under the defined amounts. It also sets a limit on the storage
    for `PersistentVolumeClaims` that can be requested within the namespace.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该 `ResourceQuota` 确保所有 CPU 和内存请求及限制的总和保持在定义的限制范围内。它还设置了在命名空间内可以请求的 `PersistentVolumeClaims`
    存储的限制。
- en: By setting reasonable defaults for resource constraints in your Helm charts,
    along with the usage of `LimitRange` and `ResourceQuotas`, you can ensure that
    users of your Helm charts do not exhaust cluster resources. You can also help
    ensure that applications request the minimum amount of resources necessary for
    a proper operation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为资源限制设置合理的默认值，并使用 `LimitRange` 和 `ResourceQuotas`，您可以确保使用您的 Helm charts 的用户不会耗尽集群资源。您还可以帮助确保应用程序请求足够的最小资源以确保正常运行。
- en: With an understanding of resource requests and limits, let’s move on to the
    next topic – handling secrets in Helm charts.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 了解资源请求和限制后，让我们进入下一个话题——在 Helm charts 中处理密钥。
- en: Handling secrets in Helm charts
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm charts 中的密钥处理
- en: Handling secrets is a common concern when working with Helm charts. Consider
    the WordPress application from [*Chapter 3*](B17979_03.xhtml#_idTextAnchor083),
    *Installing Your First App with Helm*, where you were required to provide a password
    to configure an admin user. This password was not provided by default in the `values.yaml`
    file because this would have left the application vulnerable if you forgot to
    override the `password` value. Chart developers should be in the habit of not
    providing defaults for secret values, such as passwords, and should instead require
    users to provide an explicit value. This can easily be accomplished by leveraging
    the `required` function. Helm can also generate random strings using the `randAlphaNum`
    function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 处理密钥是使用 Helm charts 时常见的关注点。考虑到 [*第 3 章*](B17979_03.xhtml#_idTextAnchor083)
    中的 WordPress 应用程序，*使用 Helm 安装第一个应用程序*，在此过程中，您需要提供密码以配置管理员用户。此密码默认不在 `values.yaml`
    文件中提供，因为如果您忘记覆盖 `password` 值，应用程序将变得易受攻击。Chart 开发者应该养成不为密钥值（如密码）提供默认值的习惯，而应要求用户提供显式值。这可以通过利用
    `required` 函数轻松实现。Helm 还可以使用 `randAlphaNum` 函数生成随机字符串。
- en: Note
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `randAlphaNum` function generates a new random string each time
    the chart is upgraded. For that reason, developers should design charts with the
    expectation that users will provide their own password or another secret key,
    with the `required` function serving as a gate to ensure that a value is provided.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`randAlphaNum`函数每次升级图表时都会生成一个新的随机字符串。因此，开发人员应该设计图表时预期用户会提供自己的密码或其他密钥，并使用`required`函数作为门槛，确保提供了一个值。
- en: When using native Kubernetes resources to store secret information, chart developers
    should ensure that these sensitive assets are saved in a Kubernetes Secret, not
    a ConfigMap. Secrets and ConfigMaps are similar, but Secrets are reserved for
    sensitive data. Because secret and non-secret data is stored in separate objects,
    cluster administrators can set RBAC policies accordingly to restrict access to
    secret data while allowing permission to data that is non-secret (RBAC will be
    described further later in the *Configuring RBAC rules* section).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用原生Kubernetes资源存储秘密信息时，图表开发人员应确保将这些敏感资产保存在Kubernetes Secret中，而不是ConfigMap中。Secrets和ConfigMaps类似，但Secrets是专门用于存储敏感数据的。由于秘密数据和非秘密数据存储在不同的对象中，集群管理员可以相应地设置RBAC策略，限制对秘密数据的访问，同时允许对非秘密数据的访问（RBAC将在稍后的*配置RBAC规则*部分进一步说明）。
- en: Chart users should ensure that secret values such as credentials are provided
    securely. Values are most commonly provided using the `--values` flag, in which
    properties are configured within `values` files. This is an appropriate method
    when working with non-secret values, but you should use caution when using this
    approach with secrets. Users should be sure that `values` files that contain secrets
    are not checked into a Git repository or an otherwise public location where those
    secrets could be exposed. One way that users can avoid exposing secrets is by
    leveraging the `--set` flag to pass secrets inline from the command line. This
    reduces the risk of credentials being exposed, but users should be aware that
    this could reveal the credentials in the bash history.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图表用户应该确保像凭证这样的秘密值以安全的方式提供。值通常通过`--values`标志提供，其中属性在`values`文件中配置。当处理非秘密值时，这是一种合适的方法，但在处理秘密时，应该谨慎使用此方法。用户应确保包含秘密的`values`文件没有被检查到Git仓库或其他公开位置，这样这些秘密就不会被暴露。用户避免暴露秘密的一种方法是利用`--set`标志从命令行传递秘密。这降低了凭证暴露的风险，但用户应该注意，这可能会在bash历史中暴露凭证。
- en: 'Another way that users can avoid exposing secrets is by leveraging an encryption
    tool to encrypt `values` files that contain secrets. This approach would continue
    to allow users to apply the `--values` flag, along with enabling the `values`
    file to be stored in a remote location, such as a Git repository. Then, the `values`
    file can only be decrypted by users that have the appropriate decryption key and
    would remain encrypted for all other users, only allowing trusted entities to
    access the data. Users can simply leverage GPG to encrypt the `values` files,
    or they can leverage a purpose-built tool such as **Secrets OPerationS** (**SOPS**).
    SOPS ([https://github.com/mozilla/sops](https://github.com/mozilla/sops)) is a
    tool designed to encrypt the values of YAML or JSON files, but leave the keys
    unencrypted. The following code depicts a secret key/value pair from a SOPS-encrypted
    file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 用户避免暴露秘密的另一种方法是利用加密工具加密包含秘密的`values`文件。此方法仍然允许用户使用`--values`标志，并使`values`文件能够存储在远程位置，如Git仓库中。然后，只有拥有适当解密密钥的用户才能解密`values`文件，其他用户则保持加密状态，仅允许可信实体访问数据。用户可以简单地使用GPG加密`values`文件，或者使用一个专门的工具，如**Secrets
    OPerationS**（**SOPS**）。SOPS（[https://github.com/mozilla/sops](https://github.com/mozilla/sops)）是一个设计用来加密YAML或JSON文件中的值，但保留键未加密的工具。以下代码展示了一个来自SOPS加密文件的秘密键/值对：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice how the `password` key is unencrypted but the value is encrypted. This
    allows you to easily see the types of values contained within the file without
    exposing their sensitive values.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`password`键是未加密的，但其值是加密的。这使得你可以轻松查看文件中包含的值的类型，而不会暴露其敏感值。
- en: There are other tools capable of encrypting `values` files that contain secrets.
    Some examples include `--set` flag.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他工具可以加密包含秘密的`values`文件。一些示例包括`--set`标志。
- en: Now that you understand how security plays a role in Helm chart development,
    let’s discuss how **Role-Based Access Control** (**RBAC**) can be applied in Kubernetes
    to provide greater security to your users.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了安全性在 Helm 图表开发中的作用，接下来让我们讨论如何在 Kubernetes 中应用**基于角色的访问控制**（**RBAC**），以为用户提供更高的安全性。
- en: Configuring RBAC rules
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 RBAC 规则
- en: 'The ability of an authenticated user in Kubernetes to perform actions is governed
    by a set of RBAC policies. As introduced in [*Chapter 2*](B17979_02.xhtml#_idTextAnchor038),
    *Preparing a Kubernetes and Helm Environment*, policies, known as roles, can be
    associated with users or service accounts, and Kubernetes includes several roles
    with any installation. RBAC has been enabled by default in Kubernetes since version
    `1.6`. When thinking about Kubernetes RBAC in the context of Helm usage, you need
    to consider two factors:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，经过身份验证的用户执行操作的能力由一组 RBAC 策略来管理。如在[*第 2 章*](B17979_02.xhtml#_idTextAnchor038)《准备
    Kubernetes 和 Helm 环境》中介绍的，策略（即角色）可以与用户或服务账户关联，Kubernetes 在任何安装中都包含多个角色。自版本 `1.6`
    起，Kubernetes 默认启用 RBAC。当在 Helm 使用的背景下考虑 Kubernetes RBAC 时，需要考虑两个因素：
- en: The user installing the Helm chart
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Helm 图表的用户
- en: The service account associated with the pod running the workload
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与运行工作负载的 pod 关联的服务账户
- en: In most cases, the individual responsible for installing a Helm chart is associated
    with a Kubernetes user. However, Helm charts can be installed through other means,
    such as by a Kubernetes operator with an associated service account.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，负责安装 Helm 图表的个人与 Kubernetes 用户相关联。然而，Helm 图表也可以通过其他方式安装，例如由具有关联服务账户的
    Kubernetes 操作员安装。
- en: By default, users and service accounts have minimal permissions in a Kubernetes
    cluster. Additional permissions are granted through the use of roles, which have
    been scoped to an individual namespace, or cluster roles, which grant access at
    a cluster level. These roles are then associated with a user or service account
    using either a role binding or a cluster role binding, depending on the type of
    policy being targeted. While Kubernetes has several included roles, the `Role`
    or `ClusterRole`, can be created that provides only the necessary permissions
    that the application needs. Since most typical users of a Kubernetes cluster do
    not have access to create resources at a cluster level, let’s create a role that
    is applied to the namespace that the Helm chart is deployed in.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，用户和服务账户在 Kubernetes 集群中具有最小权限。通过使用角色（这些角色已被限定在特定命名空间内）或集群角色（授予集群级别的访问权限），可以授予额外的权限。然后，使用角色绑定或集群角色绑定将这些角色与用户或服务账户关联，具体取决于目标策略的类型。虽然
    Kubernetes 包含几个内置角色，但可以创建 `Role` 或 `ClusterRole`，只授予应用程序所需的必要权限。由于大多数 Kubernetes
    集群的典型用户无法在集群级别创建资源，我们将创建一个角色，应用于 Helm 图表部署所在的命名空间。
- en: 'The `kubectl create role` command can be used to create a Kubernetes `Role`.
    Alternatively, the `Role` and `RoleBinding` resources could have been created
    using YAML definitions. A basic role contains two key elements:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `kubectl create role` 命令来创建一个 Kubernetes `Role`。或者，可以使用 YAML 定义来创建 `Role`
    和 `RoleBinding` 资源。基本角色包含两个关键元素：
- en: The type of action (verb) made against the Kubernetes API
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 Kubernetes API 执行的操作类型（动词）
- en: The list of Kubernetes resources to target
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要目标的 Kubernetes 资源列表
- en: 'As an example, to demonstrate how RBAC can be configured in Kubernetes, let’s
    configure a set of RBAC rules to allow an authenticated user to view Pods within
    a namespace:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，为了演示如何在 Kubernetes 中配置 RBAC，我们将配置一组 RBAC 规则，允许经过身份验证的用户查看命名空间中的 Pods：
- en: 'First, be sure to start your minikube cluster and create a new namespace for
    this exercise:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，请确保启动您的 minikube 集群并为此练习创建一个新的命名空间：
- en: '[PRE34]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, use the `kubectl` CLI to create a new role called `pod-viewer`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `kubectl` 命令行工具创建一个名为 `pod-viewer` 的新角色：
- en: '[PRE35]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this new role created, it needs to be associated with a user or service
    account. Since we want to associate the role with an application running in Kubernetes,
    we will apply the role to a service account. To abide by the Principle of Least
    Privilege, it is recommended to create a unique service account for the application
    (otherwise, the default service account would be used). This is to ensure that
    no other workloads are deployed in the same namespace that would accidentally
    inherit the same permissions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了这个新角色后，需要将其与用户或服务账户关联。由于我们希望将角色与 Kubernetes 中运行的应用程序关联，因此我们将角色应用于服务账户。为了遵循最小权限原则，建议为应用程序创建一个唯一的服务账户（否则将使用默认服务账户）。这样可以确保同一命名空间中没有其他工作负载被意外地继承相同的权限。
- en: 'Create a new service account called `example` by running the following command:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建一个名为 `example` 的新服务账户：
- en: '[PRE36]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, create `RoleBinding` called `pod-viewers` and associate it with the
    `example` service account:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个名为 `pod-viewers` 的 `RoleBinding`，并将其与 `example` 服务账户关联：
- en: '[PRE37]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With the role and role binding created, the `example` service account has the
    appropriate permissions to list and get pods. To verify this assumption, we can
    use the `kubectl auth can-i` command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了角色和角色绑定后，`example` 服务账户具有列出和获取 pods 的适当权限。为了验证这个假设，我们可以使用 `kubectl auth can-i`
    命令：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `--as` flag makes use of the user impersonation feature in Kubernetes to
    allow you to debug authorization policies.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`--as` 标志利用了 Kubernetes 中的用户模拟功能，允许你调试授权策略。'
- en: 'To confirm that the service account cannot access a resource it should not
    be able to, such as listing Deployments, you can run the following command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认服务账户无法访问它不应访问的资源，例如列出 Deployments，你可以运行以下命令：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see from the output of `no` for listing Deployments and `yes` for
    listing pods, the expected policies are in place. This service account can now
    be referenced by a Helm chart. Alternatively, a Helm chart could be written to
    create the `ServiceAccount`, `Role`, and `RoleBinding` resources natively, assuming
    that a user installing the chart has the appropriate privileges required.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `no`（列出 Deployments）和 `yes`（列出 pods）的输出中可以看出，预期的策略已生效。该服务账户现在可以被 Helm chart
    引用。或者，可以编写一个 Helm chart 来原生创建 `ServiceAccount`、`Role` 和 `RoleBinding` 资源，前提是安装该
    chart 的用户拥有所需的适当权限。
- en: When used effectively, Kubernetes RBAC aids in providing Helm chart developers
    with the tools needed to enforce least-privilege access, protecting users and
    applications from potential errant or malicious actions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用得当，Kubernetes RBAC 有助于为 Helm chart 开发者提供必要的工具，以执行最小权限访问，保护用户和应用程序免受潜在错误或恶意行为的威胁。
- en: To clean up from this exercise, you can delete your namespace with `kubectl
    delete ns chapter12` and stop your minikube cluster with `minikube stop`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清理本次练习，你可以使用 `kubectl delete ns chapter12` 删除你的命名空间，并使用 `minikube stop` 停止你的
    minikube 集群。
- en: Next, let’s discuss how to access secure Helm chart repositories.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论如何访问安全的 Helm chart 仓库。
- en: Accessing secure chart repositories
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问安全的 chart 仓库
- en: Chart repositories allow you to discover Helm charts and install them on your
    Kubernetes cluster. Repositories were explored in [*Chapter 8*](B17979_08.xhtml#_idTextAnchor210),
    *Publishing to a Helm Chart Repository*. There, you learned how to serve charts
    using an HTTP server (demonstrated using GitHub Pages) and an OCI registry (demonstrated
    using GitHub’s container registry, `ghcr.io`).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Chart 仓库允许你发现 Helm charts 并将其安装到你的 Kubernetes 集群中。仓库在[*第 8 章*](B17979_08.xhtml#_idTextAnchor210)，*发布到
    Helm Chart 仓库*中进行了探讨。在那里，你学习了如何使用 HTTP 服务器（通过 GitHub Pages 演示）和 OCI 注册表（通过 GitHub
    的容器注册表 `ghcr.io` 演示）提供 charts。
- en: 'Most chart repositories are readily available and open for those who are interested.
    However, chart repositories and hosting services do provide additional security
    measures for interacting with content stored within a repository, including the
    following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 chart 仓库都可以供有兴趣的人访问并且是开放的。然而，chart 仓库和托管服务确实为与存储在仓库中的内容进行交互提供了额外的安全措施，包括以下内容：
- en: Authentication
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证
- en: '**Transport Layer Security** (**TLS**)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层安全性** (**TLS**)'
- en: 'HTTP(S)-based chart repositories support basic and certificate-based authentication.
    For basic authentication, a username and password can be provided when adding
    a repository using the `helm repo add` command through the use of the `--username`
    and `--password` flags. For example, if you wanted to access a repository that
    is protected via basic authentication, adding the repository would take the following
    form:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 基于HTTP(S)的图表仓库支持基本认证和基于证书的认证。对于基本认证，可以在使用`helm repo add`命令添加仓库时，通过使用`--username`和`--password`标志提供用户名和密码。例如，如果您想访问一个通过基本认证保护的仓库，添加该仓库的命令将如下所示：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Under certain circumstances, you may also need to use the `--pass-credentials`
    flag in addition to `--username` and `--password`. Recall that an `index.yaml`
    file contains indexing of all Helm charts within the chart repository. Within
    the `index.yaml` file is a property field named `urls` that refers to the location
    of the associated Helm chart. Typically, the `urls` field contains relative paths
    within the chart repository, but in some cases, a location at an entirely different
    domain can be specified. Without the `--pass-credentials` flag, Helm will not
    forward your username and password along to these domains, which is a security
    feature implemented in Helm 3.6.1 to prevent your information from being exposed.
    However, if you do need to pass your credentials to another domain to authenticate
    against those endpoints, you can provide the `--pass-credentials` flag when using
    the `helm repo add` command.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能还需要在`--username`和`--password`之外使用`--pass-credentials`标志。回想一下，`index.yaml`文件包含了图表仓库中所有Helm图表的索引。在`index.yaml`文件中，有一个名为`urls`的属性字段，指向相关Helm图表的位置。通常，`urls`字段包含图表仓库中的相对路径，但在某些情况下，可以指定一个完全不同域名的位置。如果没有`--pass-credentials`标志，Helm不会将您的用户名和密码传递给这些域名，这是Helm
    3.6.1中实现的安全功能，用来防止您的信息被暴露。但是，如果您确实需要将凭证传递到另一个域以对其进行身份验证，您可以在使用`helm repo add`命令时提供`--pass-credentials`标志。
- en: 'OCI registries also support basic authentication using the `helm registry login`
    command. The username is provided using the `--username` flag, but there are two
    ways to specify the password:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: OCI注册表也支持使用`helm registry login`命令进行基本认证。用户名通过`--username`标志提供，但有两种方式可以指定密码：
- en: '`--password`: Provides the password as an argument. This could reveal the password
    in plaintext in the bash history.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--password`：将密码作为参数提供。这可能会在bash历史记录中以明文形式泄露密码。'
- en: '`--password-stdin`: Provides the password from `stdin`. This allows you to
    keep the password hidden from the bash history by redirecting it from `stdin`.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--password-stdin`：通过`stdin`提供密码。这允许您通过从`stdin`重定向密码来隐藏密码，避免其出现在bash历史记录中。'
- en: 'It is recommended to use the `--password-stdin` flag to keep the password concealed
    from the bash history. As such, you can perform basic authentication against an
    OCI registry using the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用`--password-stdin`标志以避免密码暴露在bash历史记录中。通过这种方式，您可以使用以下命令对OCI注册表进行基本认证：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: While basic authentication is most commonly used, certificate-based authentication
    is another way of verifying a client’s identity. Helm, at the time of writing,
    does not provide flags for OCI certificate-based authentication, but for traditional
    Helm repositories, the Helm `repo add` command provides the `--cert-file` and
    `--key-file` flags, which are used to specify your client certificate and key,
    respectively.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基本认证是最常用的方式，但基于证书的认证也是验证客户端身份的另一种方式。当前Helm并未提供OCI证书认证的标志，但对于传统的Helm仓库，`helm
    repo add`命令提供了`--cert-file`和`--key-file`标志，用于分别指定客户端证书和密钥。
- en: Enabling basic authentication and certificate authentication on the chart repository
    itself depends on the repository implementation that is used. For example, `--basic-auth-user`
    and `--basic-auth-pass` flags, which can be used on startup to configure the basic
    auth username and password. It also provides the `--tls-ca-cert` flag to configure
    the **certificate authority** (**CA**) certificate for certificate authentication.
    Other chart repository implementations may provide similar or additional capabilities.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表仓库本身启用基本认证和证书认证取决于所使用的仓库实现。例如，`--basic-auth-user`和`--basic-auth-pass`标志，可以在启动时配置基本认证的用户名和密码。它还提供`--tls-ca-cert`标志，用于配置**证书颁发机构**（**CA**）证书，以便进行证书认证。其他图表仓库实现可能会提供类似或额外的功能。
- en: Even with authentication in place, the packets sent between your Helm client
    and your chart repository must be transmitted securely using TLS-based encryption.
    While this is a given for certificate-based authentication, which leverages TLS
    natively, repositories that use basic authentication can still benefit from encrypting
    network traffic. Configuring TLS on the chart repository depends on the repository
    implementation being used, but for ChartMuseum, the `--tls-cert` and `--tls-key`
    flags can be used to provide the certificate chain and key files. More general
    web servers, such as NGINX, typically require a configuration file that provides
    the location of the certificate and key files on the server. Offerings such as
    GitHub Pages already have TLS configured.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在启用身份验证的情况下，Helm 客户端与图表仓库之间发送的数据包也必须使用基于 TLS 的加密进行安全传输。虽然对于基于证书的身份验证，这一点是理所当然的，因为它本身就使用
    TLS，但使用基本身份验证的仓库仍然可以通过加密网络流量来获得安全性。为图表仓库配置 TLS 取决于所使用的仓库实现，但对于 ChartMuseum，可以使用
    `--tls-cert` 和 `--tls-key` 标志来提供证书链和密钥文件。更常见的 Web 服务器，如 NGINX，通常需要一个配置文件，提供证书和密钥文件在服务器上的位置。像
    GitHub Pages 这样的服务已经配置了 TLS。
- en: 'Each of the Helm repositories that we have used so far has used certificates
    signed by publicly available CAs that are stored in your web browser and underlying
    operating system. As a result, we did not need to go out of our way to trust their
    certificates. Many large organizations, however, have their own CAs that are used
    to produce the certificate for the chart repository. Since this certificate is
    likely not from a publicly available CA, the Helm CLI may not trust the certificate,
    resulting in the following error:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的每个 Helm 仓库都使用了由公开的 CA 签发的证书，这些证书存储在你的 Web 浏览器和操作系统中。因此，我们不需要特别去信任它们的证书。然而，许多大型组织有自己的
    CA，用于为图表仓库生成证书。由于该证书可能不是来自公开的 CA，Helm CLI 可能无法信任该证书，从而导致以下错误：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To allow the Helm CLI to trust the chart repository’s certificate, the CA certificate,
    or CA bundle containing the certificate chain, can be added to the operating system’s
    trust store. Alternatively, for HTTPS chart repositories, the `--ca-file` flag
    can be added to the `helm repo add` command.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Helm CLI 信任图表仓库的证书，可以将 CA 证书或包含证书链的 CA 包添加到操作系统的信任存储中。或者，对于 HTTPS 图表仓库，可以在
    `helm repo add` 命令中添加 `--ca-file` 标志。
- en: Finally, depending on how the chart repository is configured, additional metrics
    can be obtained to perform request-level auditing and logging to determine who
    has attempted to access the repository.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，根据图表仓库的配置方式，可以获取额外的指标，以执行请求级别的审计和日志记录，确定谁尝试访问该仓库。
- en: Through the use of authentication and TLS, additional capabilities can be realized
    for enhancing the security footprint of Helm repositories.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用身份验证和 TLS，可以实现额外的功能，以增强 Helm 仓库的安全性。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned about different topics around security that pertain
    to Helm usage. First, you learned how to prove the data provenance and integrity
    of Helm releases and Helm charts. Next, you learned about Helm chart security
    and how a chart developer can leverage security best practices to write a stable
    and secure Helm chart. Then, we focused on using RBAC to create an environment
    based on the Principle of Least Privilege, and we finished by talking about how
    chart repositories can be secured using authentication and TLS. Now, by employing
    each of these concepts, you are well equipped to create a secure Helm architecture
    and working environment.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你学习了与 Helm 使用相关的各种安全主题。首先，你学习了如何验证 Helm 发布和 Helm 图表的数据来源和完整性。接着，你学习了 Helm
    图表的安全性，以及图表开发者如何利用安全最佳实践来编写稳定且安全的 Helm 图表。然后，我们重点介绍了如何使用 RBAC 创建基于最小权限原则的环境，最后，我们讨论了如何使用身份验证和
    TLS 来保护图表仓库的安全。现在，通过应用这些概念，你已经具备了创建安全 Helm 架构和工作环境的能力。
- en: Thank you for reading *Managing Kubernetes Resources Using Helm*! We hope that
    this book helps you be confident and efficient as you use Helm to work within
    the Kubernetes ecosystem.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢阅读 *使用 Helm 管理 Kubernetes 资源*！我们希望本书能帮助你在使用 Helm 在 Kubernetes 生态系统中工作时充满信心和高效。
- en: Further reading
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多本章所涵盖的主题，请查阅以下资源：
- en: To learn more about data provenance and integrity in the context of Helm charts,
    go to [https://helm.sh/docs/topics/provenance/](https://helm.sh/docs/topics/provenance/).
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要了解有关 Helm chart 上下文中数据来源和完整性的更多信息，请访问[https://helm.sh/docs/topics/provenance/](https://helm.sh/docs/topics/provenance/)。
- en: To learn more about Kubernetes RBAC, check out the *Using RBAC Authorization*
    section from the Kubernetes documentation at [https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/).
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要了解更多关于 Kubernetes RBAC 的信息，请查看 Kubernetes 文档中的*Using RBAC Authorization*部分：[https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)。
- en: 'Check out the chart repository guide from the Helm documentation to learn more
    about chart repositories: [https://helm.sh/docs/topics/chart_repository/](https://helm.sh/docs/topics/chart_repository/).'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 Helm 文档中的 chart 仓库指南，了解更多关于 chart 仓库的信息：[https://helm.sh/docs/topics/chart_repository/](https://helm.sh/docs/topics/chart_repository/)。
- en: 'Finally, visit the *Registries* page from the Helm documentation to learn more
    about OCI support: [https://helm.sh/docs/topics/registries/](https://helm.sh/docs/topics/registries/).'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，访问 Helm 文档中的*Registries*页面，了解更多关于 OCI 支持的信息：[https://helm.sh/docs/topics/registries/](https://helm.sh/docs/topics/registries/)。
- en: Questions
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章节的理解：
- en: What are data provenance and integrity? How are data provenance and data integrity
    different?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据来源和数据完整性是什么？数据来源和数据完整性有什么区别？
- en: What commands can a user run to verify the data provenance and integrity of
    a Helm chart? Which files are required to make this process possible?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可以运行哪些命令来验证 Helm chart 的数据来源和完整性？需要哪些文件才能实现这个过程？
- en: What considerations need to be taken into account to use and maintain secure
    container images?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用和维护安全容器镜像时需要考虑哪些因素？
- en: Why is it important to leverage resource requests and limits in your Helm chart?
    What other Kubernetes resources can be used to configure requests and limits?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在 Helm chart 中利用资源请求和限制很重要？还有哪些其他 Kubernetes 资源可以用来配置请求和限制？
- en: What is the Principle of Least Privilege? Which Kubernetes resources allow you
    to configure authorization and achieve the least privilege?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小权限原则是什么？哪些 Kubernetes 资源允许你配置授权并实现最小权限？
- en: Which flags can you use to authenticate to an HTTP(S) repository?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用哪些标志来验证 HTTP(S) 仓库的身份？
- en: Which flags can you use to authenticate to an OCI registry?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用哪些标志来验证 OCI 注册表的身份？
