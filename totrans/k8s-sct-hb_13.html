<html><head></head><body>
<div id="_idContainer055">
<h1 class="chapter-number" id="_idParaDest-238"><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-239"><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.2.1">Case Studies and Real-World Examples</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will see real-world examples of how Kubernetes Secrets are used in production environments. </span><span class="koboSpan" id="kobo.3.2">The chapter will cover case studies of production Secrets management in Kubernetes and lessons learned from real-world deployments. </span><span class="koboSpan" id="kobo.3.3">Additionally, you will learn about managing Secrets in CI/CD pipelines and integrating Secrets management into the CI/CD process. </span><span class="koboSpan" id="kobo.3.4">The chapter will also cover how to manage Secrets in pipelines using Kubernetes tools and the best practices to secure CI/CD Secrets management. </span><span class="koboSpan" id="kobo.3.5">We will expand on the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.5.1">Real-world examples of how Kubernetes Secrets are used in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">production environments</span></span></li>
<li><span class="koboSpan" id="kobo.7.1">Secrets management from a </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">CI/CD perspective</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Lessons learned from </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">real-world deployments</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Managing the Secrets’ lifecycle end to end in the Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">production system</span></span></li>
</ul>
<h1 id="_idParaDest-240"><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.14.1">To link theory with practice, we are leveraging a series of tools and platforms commonly used to interact with the Google Cloud API </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">and Kubernetes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.16.1">gcloud CLI</span></strong><span class="koboSpan" id="kobo.17.1">: This is a set of tools used to create and manage Google Cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">resources (</span></span><a href="https://cloud.google.com/sdk/gcloud#download_and_install_the"><span class="No-Break"><span class="koboSpan" id="kobo.19.1">https://cloud.google.com/sdk/gcloud#download_and_install_the</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.20.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.21.1">kubectl</span></strong><span class="koboSpan" id="kobo.22.1">: This is the command-line tool used for communicating with a Kubernetes cluster through the Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">API (</span></span><a href="https://kubernetes.io/docs/reference/kubectl/"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://kubernetes.io/docs/reference/kubectl/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.25.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.26.1">minikube</span></strong><span class="koboSpan" id="kobo.27.1">: This is a local Kubernetes distribution used for Kubernetes learning and development. </span><span class="koboSpan" id="kobo.27.2">To install minikube on your system, you can follow the instructions from the official </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">documentation (</span></span><a href="https://minikube.sigs.k8s.io/docs/start/"><span class="No-Break"><span class="koboSpan" id="kobo.29.1">https://minikube.sigs.k8s.io/docs/start/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.30.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.31.1">kubeseal</span></strong><span class="koboSpan" id="kobo.32.1">: The kubeseal client is a utility that assists us with our interactions with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">sealed-secrets</span></strong><span class="koboSpan" id="kobo.34.1"> installation on </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">Kubernetes (</span></span><a href="https://github.com/bitnami-labs/sealed-secrets#kubeseal"><span class="No-Break"><span class="koboSpan" id="kobo.36.1">https://github.com/bitnami-labs/sealed-secrets#kubeseal</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.37.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.38.1">argocd</span></strong><span class="koboSpan" id="kobo.39.1">: This is a command-line utility that simplifies interactions with Argo </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">CD (</span></span><a href="https://argo-cd.readthedocs.io/en/stable/cli_installation/"><span class="No-Break"><span class="koboSpan" id="kobo.41.1">https://argo-cd.readthedocs.io/en/stable/cli_installation/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.42.1">)</span></span></li>
</ul>
<h1 id="_idParaDest-241"><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.43.1">Real-world examples of how Kubernetes Secrets are used in production environments</span></h1>
<p><span class="koboSpan" id="kobo.44.1">So far, we have seen some different approaches to managing Kubernetes Secrets. </span><span class="koboSpan" id="kobo.44.2">We will proceed and see examples of how Secrets are managed in a production environment. </span><span class="koboSpan" id="kobo.44.3">We will compare some different approaches, identifying their differences and looking at the pros </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">and cons.</span></span></p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.46.1">Qualities of Secrets management in production</span></h2>
<p><span class="koboSpan" id="kobo.47.1">When it comes to Kubernetes</span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.48.1"> Secrets management in production, regardless of the approach taken, certain qualities need to be satisfied. </span><span class="koboSpan" id="kobo.48.2">These qualities make our production deployment robust and secure. </span><span class="koboSpan" id="kobo.48.3">The qualities are </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.50.1">High availability</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.51.1">Disaster recovery</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.52.1">Encryption</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.53.1">Auditing</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.54.1">Let us deep dive into each one </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">of them.</span></span></p>
<h3><span class="koboSpan" id="kobo.56.1">High availability</span></h3>
<p><span class="koboSpan" id="kobo.57.1">Kubernetes is highly available; we saw how in </span><a href="B20970_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.58.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.59.1">, </span><em class="italic"><span class="koboSpan" id="kobo.60.1">Understanding Kubernetes Secrets Management</span></em><span class="koboSpan" id="kobo.61.1">. </span><span class="koboSpan" id="kobo.61.2">A secret stored in Kubernetes</span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.62.1"> will be stored on etcd, and etcd nodes are part of the Kubernetes cluster. </span><span class="koboSpan" id="kobo.62.2">If one etcd node goes down, the Secrets will still be present on the other etcd nodes. </span><span class="koboSpan" id="kobo.62.3">This ensures that Kubernetes will continue to operate with all the Secrets functioning. </span><span class="koboSpan" id="kobo.62.4">Eventually, once the missing etcd node is up, it will resume operations along with the other nodes. </span><span class="koboSpan" id="kobo.62.5">High availability ensures the robustness of Kubernetes in scenarios where a node is lost. </span><span class="koboSpan" id="kobo.62.6">Apart from the plain unavailability of a node, high availability should also tackle the risk of a data center going down. </span><span class="koboSpan" id="kobo.62.7">All the nodes of a Kubernetes cluster should not be hosted in the same data center; instead, the nodes of the cluster should be spread through different data centers. </span><span class="koboSpan" id="kobo.62.8">If connectivity to a data center is lost, or if a data center has an issue, the nodes hosted on the other data centers will be able to carry over. </span><span class="koboSpan" id="kobo.62.9">However, we might encounter more extreme scenarios, scenarios where instead of a node or a data center becoming unavailable, an entire region becomes disconnected. </span><span class="koboSpan" id="kobo.62.10">In those cases, being able to perform disaster recovery in another region </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">is crucial.</span></span></p>
<h3><span class="koboSpan" id="kobo.64.1">Disaster recovery</span></h3>
<p><span class="koboSpan" id="kobo.65.1">In </span><a href="B20970_06.xhtml#_idTextAnchor117"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.66.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.67.1">, </span><em class="italic"><span class="koboSpan" id="kobo.68.1">Disaster Recovery and Backups</span></em><span class="koboSpan" id="kobo.69.1">, we focused</span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.70.1"> extensively on disaster recovery. </span><span class="koboSpan" id="kobo.70.2">When it comes to Secrets, it is crucial to have a disaster </span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.71.1">recovery plan in place. </span><span class="koboSpan" id="kobo.71.2">From a Secrets management perspective, the disaster recovery scenarios will vary on the decisions taken on managing Secrets. </span><span class="koboSpan" id="kobo.71.3">Secrets can be managed either on Kubernetes etcd or through external </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">secret storage.</span></span></p>
<h4><span class="koboSpan" id="kobo.73.1">Secret storage using etcd</span></h4>
<p><span class="koboSpan" id="kobo.74.1">The approach taken</span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.75.1"> to implement disaster</span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.76.1"> recovery on a Kubernetes cluster</span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.77.1"> will heavily influence the disaster recovery of Secrets that are managed </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">through etcd.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">We have the </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">following options:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.81.1">Cluster created on demand in </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">another region</span></span></li>
<li><span class="koboSpan" id="kobo.83.1">Standby Kubernetes cluster in </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">another region</span></span></li>
<li><span class="koboSpan" id="kobo.85.1">Active-active Kubernetes clusters in </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">multiple regions</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.87.1">The option of creating a cluster on demand in another region can be achieved with internal tooling such as keeping backups of etcd or by using tools such as Velero. </span><span class="koboSpan" id="kobo.87.2">In the case of a cloud provider, for example, GCP, you can duplicate a Kubernetes cluster with the click of </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">a button.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">In maintaining a standby cluster or active-active clusters, many of the choices are heavily dependent on how you perform deployments on Kubernetes. </span><span class="koboSpan" id="kobo.89.2">CI/CD is crucial. </span><span class="koboSpan" id="kobo.89.3">For example, for your standby cluster to be functional, your CI/CD job might need to push Secrets to two clusters. </span><span class="koboSpan" id="kobo.89.4">You might also follow the GitOps model. </span><span class="koboSpan" id="kobo.89.5">When it comes to the GitOps model, you might utilize a tool such as Argo CD. </span><span class="koboSpan" id="kobo.89.6">In those cases, the standby Kubernetes cluster can be updated by pulling the changes from a Git repository. </span><span class="koboSpan" id="kobo.89.7">This way, the Secrets are applied to the available clusters without the need to push the secret changes directly to </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">the cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">When it comes</span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.92.1"> to Kubernetes</span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.93.1"> and disaster recovery, there</span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.94.1"> are various options, as we saw in </span><a href="B20970_06.xhtml#_idTextAnchor117"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.95.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.96.1">, </span><em class="italic"><span class="koboSpan" id="kobo.97.1">Disaster Recovery </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.98.1">and Backups</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.100.1">External secret store</span></h4>
<p><span class="koboSpan" id="kobo.101.1">With an external secret store, disaster recovery</span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.102.1"> is managed by the secret store itself </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.103.1">and its features. </span><span class="koboSpan" id="kobo.103.2">All the cloud-based Secrets store options we examined supported either cross-regional availability or the option for cross-region replication. </span><span class="koboSpan" id="kobo.103.3">Azure Vault and Google Cloud Secret Manager provide cross-region availability, and AWS Secrets Manager provides cross-region replication. </span><span class="koboSpan" id="kobo.103.4">In HashiCorp Vault Enterprise, there is also the option of </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">cross-region replication.</span></span></p>
<h3><span class="koboSpan" id="kobo.105.1">Encryption</span></h3>
<p><span class="koboSpan" id="kobo.106.1">Encryption is crucial. </span><span class="koboSpan" id="kobo.106.2">We had a deep</span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.107.1"> dive into encryption in </span><a href="B20970_03.xhtml#_idTextAnchor064"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.108.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.109.1">, </span><em class="italic"><span class="koboSpan" id="kobo.110.1">Encrypting Secrets the Kubernetes-Native Way</span></em><span class="koboSpan" id="kobo.111.1">. </span><span class="koboSpan" id="kobo.111.2">On every Kubernetes installation, it is crucial to follow encryption at rest, considering disk storage as well as the encryption of </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">etcd Secrets.</span></span></p>
<h3><span class="koboSpan" id="kobo.113.1">Auditing</span></h3>
<p><span class="koboSpan" id="kobo.114.1">We have seen in </span><a href="B20970_05.xhtml#_idTextAnchor092"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.115.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.116.1">, </span><em class="italic"><span class="koboSpan" id="kobo.117.1">Security, Auditing, and Compliance</span></em><span class="koboSpan" id="kobo.118.1">, why auditing</span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.119.1"> matters and why it is needed in the first place. </span><span class="koboSpan" id="kobo.119.2">On every cloud provider we have worked with, the option of auditing was always present. </span><span class="koboSpan" id="kobo.119.3">Auditing is also available on HashiCorp Vault and </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">CyberArk Conjur.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">We focused on and had an overview of the qualities that need to be in place when it comes to Secrets management in production. </span><span class="koboSpan" id="kobo.121.2">Next, we shall focus on how Secrets management and CI/CD come together and the risks </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">to avoid.</span></span></p>
<h1 id="_idParaDest-243"><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.123.1">Secrets management from a CI/CD perspective</span></h1>
<p><span class="koboSpan" id="kobo.124.1">Managing Secrets in CI/CD pipelines</span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.125.1"> is an interesting concept. </span><span class="koboSpan" id="kobo.125.2">In previous chapters, we focused primarily on the Git-based concept of Secrets management and the secret-storage-based Secrets management. </span><span class="koboSpan" id="kobo.125.3">We have not mentioned manual secret persistence to Kubernetes. </span><span class="koboSpan" id="kobo.125.4">There are many reasons </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">for that:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.127.1">You lose track of your Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">deployment needs</span></span></li>
<li><span class="koboSpan" id="kobo.129.1">Dependencies are </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">not visible</span></span></li>
<li><span class="koboSpan" id="kobo.131.1">No clear depiction of what </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">is applied</span></span></li>
<li><span class="koboSpan" id="kobo.133.1">Not compatible with infrastructure </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">as code</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.135.1">Next, we will focus on interacting with Secrets on our </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">CI/CD pipelines.</span></span></p>
<h2 id="_idParaDest-244"><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.137.1">Integrating Secrets management into your CI/CD process</span></h2>
<p><span class="koboSpan" id="kobo.138.1">Your CI/CD strategy will differ significantly depending on the approach taken for </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">managing Secrets.</span></span></p>
<h3><span class="koboSpan" id="kobo.140.1">Git-based Secrets management</span></h3>
<p><span class="koboSpan" id="kobo.141.1">By managing Secrets through</span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.142.1"> a Git-based </span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.143.1">approach, CI/CD should be able to interact with the </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">components involved.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">Depending on the encryption mechanism, you need to have credentials configured on the CI/CD account that will be able to interact with the KMS system that encrypts the credentials or a Kubernetes service account that can decrypt </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">the Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">Let us examine the case of sealed Secrets, a concept we learned about in </span><a href="B20970_12.xhtml#_idTextAnchor234"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.148.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.149.1">, </span><em class="italic"><span class="koboSpan" id="kobo.150.1">Integrating with Secret Stores</span></em><span class="koboSpan" id="kobo.151.1">, where a fine-grained Kubernetes role and a Kubernetes service account should be created. </span><span class="koboSpan" id="kobo.151.2">The reason is that the sealing operation happens inside the cluster. </span><span class="koboSpan" id="kobo.151.3">The sealed secret can then be stored on Git. </span><span class="koboSpan" id="kobo.151.4">To retrieve the actual value, you need to decrypt it through the cluster. </span><span class="koboSpan" id="kobo.151.5">The sealing operation can also happen offline; in this case, more steps</span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.152.1"> are needed to make sure</span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.153.1"> that the encryption key is </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">securely handled.</span></span></p>
<h3><span class="koboSpan" id="kobo.155.1">External secret store and Workload Identity</span></h3>
<p><span class="koboSpan" id="kobo.156.1">So far, we have worked</span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.157.1"> with Microsoft Azure Key</span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.158.1"> Vault, Google Cloud Secret Manager, and AWS Secrets Manager. </span><span class="koboSpan" id="kobo.158.2">All of them support the integration of Workload Identity and </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">GitHub Actions.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">The traditional way to interact with a cloud component on a CI/CD pipeline was by attaching the credentials of the cloud provider on the CI/CD job. </span><span class="koboSpan" id="kobo.160.2">This practice increases security risks. </span><span class="koboSpan" id="kobo.160.3">The credentials, such as a service account or a key secret, are static credentials; if compromised and without a proper logging or audit system, these could be used for an extended period, creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">silent breach.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">Workload Identity</span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.163.1"> is a more secure</span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.164.1"> solution. </span><span class="koboSpan" id="kobo.164.2">With Workload Identity, we can assign to a CI/CD job fine-grained permissions toward a cloud component. </span><span class="koboSpan" id="kobo.164.3">Workload Identity is not supported by all CI/CD providers out there; however, there is a strong adoption of the Workload Identity approach and it is expected to become </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">the norm.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">By using Workload Identity, a CI/CD job can have temporary credentials to interact with a cloud provider’s secret store. </span><span class="koboSpan" id="kobo.166.2">Since we have now had an introduction to Workload Identity, we will proceed and see it in action </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">using GCP.</span></span></p>
<h4><span class="koboSpan" id="kobo.168.1">GitHub Actions and GCP Workload Identity integration</span></h4>
<p><span class="koboSpan" id="kobo.169.1">One of the issues with CI/CD jobs interacting </span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.170.1">with cloud components is the permissions. </span><span class="koboSpan" id="kobo.170.2">Traditionally, this is resolved by uploading credentials to the CI/CD job variables with all the risks this solution can introduce, which we will cover later in </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">GitHub Action supports </span><strong class="bold"><span class="koboSpan" id="kobo.173.1">OpenID Connect</span></strong><span class="koboSpan" id="kobo.174.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.175.1">OIDC</span></strong><span class="koboSpan" id="kobo.176.1">). </span><span class="koboSpan" id="kobo.176.2">Through OIDC, it is possible to authenticate between</span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.177.1"> cloud providers and GitHub, using short-lived tokens. </span><span class="koboSpan" id="kobo.177.2">This way, we avoid the need for storing long-lived cloud Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">in GitHub.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">In </span><a href="B20970_10.xhtml#_idTextAnchor193"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.180.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.181.1">, </span><em class="italic"><span class="koboSpan" id="kobo.182.1">Exploring Cloud Secret Store on GCP</span></em><span class="koboSpan" id="kobo.183.1">, we integrated a GKE cluster with GCP’s Secret Manager, so we are already familiar with GCP as a platform. </span><span class="koboSpan" id="kobo.183.2">Imagine the scenario of our CI/CD jobs needing</span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.184.1"> to interact with Secret Manager, which is integrated </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">with GKE.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">Without the support of OIDC, we would have to store a GCP service account key to the CI/CD job. </span><span class="koboSpan" id="kobo.186.2">Thanks to OIDC, we can set up the authentication from GitHub to GCP using Workload </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">Identity Federation.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">First, we will have to configure an </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">identity pool:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.190.1">
$ gcloud iam workload-identity-pools create "ga-ksm-pool" --project="${GCP_PROJECT_ID}" --location="global" --display-name="GitHub actions Pool"</span></pre> <p><span class="koboSpan" id="kobo.191.1">Then, we include GitHub as an </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">identity provider:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.193.1">
$ gcloud iam workload-identity-pools providers create-oidc "github" \
--project="${GCP_PROJECT_ID}" \
--location="global" \
--workload-identity-pool="ga-ksm-pool" \
--display-name="Github provider" \
--attribute-mapping="google.subject=assertion.sub,attribute.repository=assertion.repository" \
--issuer-uri="https://token.actions.githubusercontent.com"</span></pre> <p><span class="koboSpan" id="kobo.194.1">The identity pool is provisioned, and GitHub is one of the identity providers. </span><span class="koboSpan" id="kobo.194.2">The next step is to bind a service account on GCP to a </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">GitHub repository:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.196.1">
$ gcloud iam service-accounts create github-service-account --project="${GCP_PROJECT_ID}"
$ project_number=$(gcloud projects list --filter="$(gcloud config get-value project)" --format="value(PROJECT_NUMBER)")
$ gcloud secrets add-iam-policy-binding ksm-secret --member="serviceAccount:github-service-account@${GCP_PROJECT_ID}.iam.gserviceaccount.com" --role=roles/secretmanager.viewer
$ gcloud secrets add-iam-policy-binding ksm-secret --member="serviceAccount:github-service-account@${GCP_PROJECT_ID}.iam.gserviceaccount.com" --role=roles/secretmanager.secretAccessor
$ gcloud iam service-accounts add-iam-policy-binding "github-service-account@${GCP_PROJECT_ID}.iam.gserviceaccount.com" \
--project="${GCP_PROJECT_ID}" \
--role="roles/iam.workloadIdentityUser" \
--member="principalSet://iam.googleapis.com/projects/${project_number}/locations/global/workloadIdentityPools/ga-ksm-pool/attribute.repository/${github_organisation_or_username}/${github_repositoryname}"</span></pre> <p><span class="koboSpan" id="kobo.197.1">Through this configuration, we allow</span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.198.1"> authentications from the Workload Identity provider to impersonate the desired service account. </span><span class="koboSpan" id="kobo.198.2">Also, note that when we specified the Workload Identity pool as a member, we specified the GitHub repository where we shall host the actions that would require </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">GCP access.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">We are set up to proceed with the GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">job configuration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.202.1">
name: Read from Secret Manager
on:
 push:
  branches:
   - 'main'
jobs:
 run:
  name: 'get secret'
  permissions:
   id-token: write
   contents: read
  runs-on: 'ubuntu-latest'
  steps:
  - id: 'auth'
    uses: 'google-github-actions/auth@v1'
    with:
      workload_identity_provider: 'projects/{project-id}/locations/global/workloadIdentityPools/ga-ksm-pool /providers/github'
      service_account: 'github-service-account@${GCP_PROJECT_ID}.iam.gserviceaccount.com'
  - id: fetch
    run: |-
      curl -H 'Bearer: ${{ steps.auth.outputs.access_token }}' https://secretmanager.googleapis.com/v1/projects/project-name/secrets/secret-name/versions/latest:access</span></pre> <p><span class="koboSpan" id="kobo.203.1">On the GitHub Actions console, we should be able </span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.204.1">to see the job successfully creating a token and authenticate upon the Workload Identity instance created, as well as receiving a secret from Secret Manager. </span><span class="koboSpan" id="kobo.204.2">Obviously, this way of authentication can be applied even when we want to interact </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">with GCP.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">Take note that the preceding steps print the secret on purpose since they serve as an example of how GitHub Actions and GCP Workload Identity integrate. </span><span class="koboSpan" id="kobo.206.2">You should not print any retrieved Secrets on the CI/CD console, as we shall mention later in </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">the chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">In a nutshell, by utilizing Workload</span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.209.1"> Identity, we can avoid storing long-lived credentials in a CI/CD job configuration. </span><span class="koboSpan" id="kobo.209.2">Also, we establish seamless integration with the cloud provider and make it easier to interact with cloud provider components such as Secret Manager </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">on GCP.</span></span></p>
<h3><span class="koboSpan" id="kobo.211.1">Vault as an external secret store</span></h3>
<p><span class="koboSpan" id="kobo.212.1">As we have seen from the integration</span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.213.1"> of Vault with Kubernetes, a token</span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.214.1"> is needed to be able</span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.215.1"> to interact with Vault. </span><span class="koboSpan" id="kobo.215.2">When we use a long-lived token, we face the risk of compromise. </span><span class="koboSpan" id="kobo.215.3">For this reason, instead of using a Vault token directly, we can proceed with the method of JWT with GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">OIDC tokens.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">Each GitHub action receives an auto-generated OIDC token. </span><span class="koboSpan" id="kobo.217.2">We can configure trust between a GitHub Actions workflow and Vault using the OIDC provider </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">of GitHub.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">A similar concept was Kubernetes authentication. </span><span class="koboSpan" id="kobo.219.2">We were taking the JWTs, originating from a Kubernetes service account, and using them to retrieve Secrets from Vault. </span><span class="koboSpan" id="kobo.219.3">Since Vault had already established trust with our Kubernetes cluster, it could validate the Secrets and return </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">the credentials.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">A similar process happens with the GitHub OIDC provider and the </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">HashiCorp integration.</span></span></p>
<h3><span class="koboSpan" id="kobo.223.1">Executing CI/CD pipelines on Kubernetes</span></h3>
<p><span class="koboSpan" id="kobo.224.1">Another way to securely</span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.225.1"> integrate CI/CD pipelines with</span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.226.1"> a Kubernetes secret store is to run the pipeline inside Kubernetes. </span><span class="koboSpan" id="kobo.226.2">The CI/CD jobs run inside Kubernetes, so the credentials and other Kubernetes components are not exposed outside of </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">our premises.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">Many major cloud providers, such as GitHub Actions and GitLab, provide the option to manage CI/CD pipeline orchestration on GitHub and GitLab but execute the CI/CD jobs inside Kubernetes. </span><span class="koboSpan" id="kobo.228.2">There are numerous benefits to </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">that approach.</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">By running a CI/CD job on-premises, you make it possible for the CI/CD job to interact with resources that reside only on-premises. </span><span class="koboSpan" id="kobo.230.2">For example, supposing a HashiCorp Vault installation is in a private network that is not publicly accessible. </span><span class="koboSpan" id="kobo.230.3">To integrate the Vault instance with an external CI/CD provider, we must make the Vault instance publicly accessible, which increases our </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">security concerns.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">By running a pipeline on-premises, that is not the case. </span><span class="koboSpan" id="kobo.232.2">Running CI/CD pipelines inside Kubernetes can harden the security of our CI/CD pipelines. </span><span class="koboSpan" id="kobo.232.3">Tekton is a very popular open source framework that enables us to create CI/CD systems in a </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">Kubernetes installation.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">Moving on, there is another approach</span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.235.1"> to continuous delivery, which is through</span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.236.1"> the GitOps model. </span><span class="koboSpan" id="kobo.236.2">Let us see how the GitOps model works by running an example with </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">Argo CD.</span></span></p>
<h4><span class="koboSpan" id="kobo.238.1">GitOps</span></h4>
<p><span class="koboSpan" id="kobo.239.1">GitOps is a set of practices</span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.240.1"> that is used to manage infrastructure and application configurations via a Git-centric approach. </span><span class="koboSpan" id="kobo.240.2">Argo CD follows the GitOps model. </span><span class="koboSpan" id="kobo.240.3">It monitors a Git repository that we specify and ensures that the application is in the desired state. </span><span class="koboSpan" id="kobo.240.4">Argo CD is a Kubernetes controller that monitors the running infrastructure and compares it with the infrastructure specified in the </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">Git repository.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">We can understand the model by doing a simple Argo </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">CD installation:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.244.1">
$ kubectl create namespace argocd
$ kubectl config set-context --current --namespace=argocd
$ kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/v2.5.8/manifests/install.yaml</span></pre> <p><span class="koboSpan" id="kobo.245.1">We can now port forward so that we can interact with Argo CD without the need to expose the service through </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">an ingress:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.247.1">
$ kubectl port-forward svc/argocd-server -n argocd 8080:443</span></pre> <p><span class="koboSpan" id="kobo.248.1">In another session, we can retrieve the default admin autogenerated password, in order to log in </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">argocd</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.252.1">
$ argocd admin initial-password -n argocd
$ argocd login 127.0.0.1:8080 --username admin --password ***-** --insecure</span></pre> <p><span class="koboSpan" id="kobo.253.1">We can now create an application; we shall use the examples in the Argo CD </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">repository (</span></span><a href="https://github.com/argoproj/argocd-example-apps"><span class="No-Break"><span class="koboSpan" id="kobo.255.1">https://github.com/argoproj/argocd-example-apps</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.256.1">):</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.257.1">
$ argocd app create guestbook --repo https://github.com/argoproj/argocd-example-apps.git --path guestbook --dest-server https://kubernetes.default.svc --dest-namespace default</span></pre> <p><span class="koboSpan" id="kobo.258.1">An application is now running based on a deployment file in another </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">Git repository.</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">Let us examine GitOps</span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.261.1"> and its compatibility with the Secrets management methods</span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.262.1"> we have seen </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">so far:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.264.1">Sealed Secrets can be supported without extra effort since the sealed Secrets controller will be able to apply any new Secrets distributed </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">through Git.</span></span></li>
<li><span class="koboSpan" id="kobo.266.1">Solutions driven by external secret storage are not affected since the secret information resides on </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">another component.</span></span></li>
<li><span class="koboSpan" id="kobo.268.1">Helm Secrets support depends on the tool used for GitOps. </span><span class="koboSpan" id="kobo.268.2">Argo CD can support Helm Secrets; however, it requires modifications to facilitate the encryption and decryption of Secrets that are distributed through </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">Helm charts.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.270.1">Now that we have had an overview of Secrets management and CI/CD, let us proceed with the risks that come with the integration of CI/CD </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">and Secrets.</span></span></p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.272.1">Risks to avoid with Secrets in CI/CD pipelines</span></h2>
<p><span class="koboSpan" id="kobo.273.1">A CI/CD pipeline can be subject </span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.274.1">to various risks when it comes to Secrets. </span><span class="koboSpan" id="kobo.274.2">It is quite easy to misconfigure a CI/CD pipeline, which can lead to problems such as leaking sensitive information, running overprivileged pipelines, and supply </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">chain attacks.</span></span></p>
<h3><span class="koboSpan" id="kobo.276.1">Leaking Secrets in a pipeline</span></h3>
<p><span class="koboSpan" id="kobo.277.1">Leaking Secrets in a pipeline</span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.278.1"> is easier to accidentally do than you’d think. </span><span class="koboSpan" id="kobo.278.2">CI/CD pipelines by default treat secret information differently from other configuration variables. </span><span class="koboSpan" id="kobo.278.3">Take, for example, a GitHub Actions workflow. </span><span class="koboSpan" id="kobo.278.4">If we try to print a secret in a job, the secret will be masked, and thus the information will not be leaked. </span><span class="koboSpan" id="kobo.278.5">This is not enough. </span><span class="koboSpan" id="kobo.278.6">By changing the pipeline’s configuration, we can persist the secret value in a file. </span><span class="koboSpan" id="kobo.278.7">This makes it possible to print the file and retrieve the secret information. </span><span class="koboSpan" id="kobo.278.8">To make matters worse, CI/CD pipelines keep the job history and logs. </span><span class="koboSpan" id="kobo.278.9">In certain cases, the history cannot be erased or will be erased after </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">some time.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">Another way that a secret can be leaked is by making it part of the artifacts generated by the CI/CD pipeline. </span><span class="koboSpan" id="kobo.280.2">In this situation, the Secrets can be downloaded through the </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">CI/CD UI.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">These examples of misconfigured pipelines can lead to security incidents. </span><span class="koboSpan" id="kobo.282.2">The secret information has been leaked </span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.283.1">and so it needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">be rotated.</span></span></p>
<h3><span class="koboSpan" id="kobo.285.1">Production Secrets</span></h3>
<p><span class="koboSpan" id="kobo.286.1">Another risk is using the same</span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.287.1"> Secrets used in a production workload with a CI/CD pipeline. </span><span class="koboSpan" id="kobo.287.2">A secret in a production environment is used to perform different operations from the ones that take place in a CI/CD environment. </span><span class="koboSpan" id="kobo.287.3">Having a production secret on a CI/CD environment can lead to code that might run with more privileges than the ones needed if the CI/CD is misconfigured, and its usage might affect an actual production system. </span><span class="koboSpan" id="kobo.287.4">In the case of a secret leak, the risk impact is much greater when using a dedicated secret for a </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">CI/CD job.</span></span></p>
<h3><span class="koboSpan" id="kobo.289.1">Malevolent contributions</span></h3>
<p><span class="koboSpan" id="kobo.290.1">CI/CD can be a target for attackers</span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.291.1"> trying to steal Secrets. </span><span class="koboSpan" id="kobo.291.2">A pull request on a repository that triggers a pipeline gives a variety of options for the pull request author to retrieve the secret value. </span><span class="koboSpan" id="kobo.291.3">For these cases, it is essential to protect the CI/CD jobs that interact with sensitive information. </span><span class="koboSpan" id="kobo.291.4">Branches should be protected, and certain pipelines should be segregated to enable fine-grained permissions and prevent access from individuals who might try to retrieve secret information through </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">CI/CD jobs.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">In open source projects, contributions might have the purpose of stealing Secrets or being part of a supply chain attack attempt. </span><span class="koboSpan" id="kobo.293.2">We can use GitHub Actions as an example, where workflows from forks do not have access to Secrets. </span><span class="koboSpan" id="kobo.293.3">Also, to prevent any abusive behavior on pull requests, GitHub Actions</span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.294.1"> gives the option to approve workflow</span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.295.1"> runs from public </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">forks (</span></span><a href="https://docs.github.com/en/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks"><span class="No-Break"><span class="koboSpan" id="kobo.297.1">https://docs.github.com/en/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.298.1">).</span></span></p>
<h3><span class="koboSpan" id="kobo.299.1">Untrusted software</span></h3>
<p><span class="koboSpan" id="kobo.300.1">A pipeline can be as secure</span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.301.1"> as the software that is used to implement it. </span><span class="koboSpan" id="kobo.301.2">Throughout the internet, there is a wide variety of CI/CD software utilities, ranging from libraries to Docker containers. </span><span class="koboSpan" id="kobo.301.3">These software components can be outdated, exposing the pipeline to security vulnerabilities, or some of them might have been compromised by an attacker with the goal of a supply </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">chain attack.</span></span></p>
<p><span class="koboSpan" id="kobo.303.1">Take, for example, a Jenkins plugin or a GitHub workflow action that reads the Secrets from a pipeline and sends them to an external location. </span><span class="koboSpan" id="kobo.303.2">The same can happen with any utility that is not trusted or has even  </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">been compromised.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">Software should be used only from trusted sources, and its authenticity should be verified, for example, using hash-based verification. </span><span class="koboSpan" id="kobo.305.2">Also, the software used in the pipelines should be the latest software that incorporates the necessary </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">security patches.</span></span></p>
<h3><span class="koboSpan" id="kobo.307.1">Pipelines with extra privileges</span></h3>
<p><span class="koboSpan" id="kobo.308.1">CI/CD is essential for every company</span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.309.1"> that needs to build, test, and release software. </span><span class="koboSpan" id="kobo.309.2">Since it has a crucial role, it is expected to interact with Secrets that might be shared by a Kubernetes installation. </span><span class="koboSpan" id="kobo.309.3">Secrets privileges that exceed the scope of a CI/CD job can cause serious incidents in the case of a leak </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">or misconfiguration.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">Take, for example, a CI/CD job used for testing purposes interacting with an external secret storage used by a Kubernetes cluster. </span><span class="koboSpan" id="kobo.311.2">Suppose this job deletes Secrets from the secret storage, targeting a staging environment. </span><span class="koboSpan" id="kobo.311.3">However, the permissions assigned to the pipeline are broad enough to enable the deletion of Secrets in a production environment. </span><span class="koboSpan" id="kobo.311.4">A pipeline misconfiguration can lead to data loss or even a </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">production outage.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">Now that we have had an overview of the risks associated with Secrets and CI/CD integration, let us proceed with identifying the </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">best practices.</span></span></p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.315.1">Best practices for secure CI/CD Secrets management</span></h2>
<p><span class="koboSpan" id="kobo.316.1">We had an overview</span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.317.1"> of CI/CD jobs interacting with Kubernetes Secrets. </span><span class="koboSpan" id="kobo.317.2">To ensure that we are secure, we need to follow </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">certain practices:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.319.1">Do not commit clear </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">text Secrets</span></span></li>
<li><span class="koboSpan" id="kobo.321.1">If using tokens, rotate them and make </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">them short-lived</span></span></li>
<li><span class="koboSpan" id="kobo.323.1">If an OICD-based integration is possible, use it, as it is </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">more secure</span></span></li>
<li><span class="koboSpan" id="kobo.325.1">Moving pipelines to Kubernetes on-premises </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">hardens security</span></span></li>
<li><span class="koboSpan" id="kobo.327.1">The principle of least privilege should </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">be followed</span></span></li>
<li><span class="koboSpan" id="kobo.329.1">Use dedicated Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">for testing</span></span></li>
<li><span class="koboSpan" id="kobo.331.1">Do not use the same</span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.332.1"> Secrets for testing </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">and production</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.334.1">So far, we have focused on the ways to handle Kubernetes Secrets in production and the integration of Kubernetes Secrets and CI/CD. </span><span class="koboSpan" id="kobo.334.2">Next, we will focus on a case study for implementing a Secrets system within </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">an organization.</span></span></p>
<h1 id="_idParaDest-247"><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.336.1">Lessons learned from real-world deployments</span></h1>
<p><span class="koboSpan" id="kobo.337.1">Let us now look at how we can interact with Secrets on Kubernetes and what we should and should not do when we interact with Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">on Kubernetes.</span></span></p>
<h2 id="_idParaDest-248"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.339.1">Case study – Developing Secrets management</span></h2>
<p><span class="koboSpan" id="kobo.340.1">As more organizations embrace</span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.341.1"> container orchestration, the following case study illustrates the journey toward establishing a robust system for Secrets management within </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">an organization.</span></span></p>
<h2 id="_idParaDest-249"><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.343.1">The Keywhiz Secrets management system at Square</span></h2>
<p><span class="koboSpan" id="kobo.344.1">Keywhiz is a system that Square</span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.345.1"> developed to keep important digital keys and passwords, such as those used to secure websites, safe and in one place. </span><span class="koboSpan" id="kobo.345.2">This system is beneficial as the organization previously lacked secure methods for storing these Secrets. </span><span class="koboSpan" id="kobo.345.3">Keywhiz makes sure that only the right parts of Square can get to these Secrets when they need to, using </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">secure connections.</span></span></p>
<h3><span class="koboSpan" id="kobo.347.1">Deep dive into Keywhiz’s secret system</span></h3>
<p><span class="koboSpan" id="kobo.348.1">Let us dive deep into Keywhiz to see how Square built the system end </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">to end.</span></span></p>
<h4><span class="koboSpan" id="kobo.350.1">Business justification</span></h4>
<p><span class="koboSpan" id="kobo.351.1">Square built Keywhiz with the idea</span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.352.1"> that important Secrets should be hard to reach. </span><span class="koboSpan" id="kobo.352.2">They shouldn’t pop up in places where just anyone can see them, such as on a developer’s computer or the internet. </span><span class="koboSpan" id="kobo.352.3">Only the specific parts of Square that need these Secrets should be able to get them. </span><span class="koboSpan" id="kobo.352.4">This is especially true for services that use secure connections to protect data. </span><span class="koboSpan" id="kobo.352.5">Instead of using many steps or other services to get to these Secrets, Square’s services can get them directly. </span><span class="koboSpan" id="kobo.352.6">Even for special cases, such as when they need to use extra secure hardware, Keywhiz has a way to </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">handle it.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">Keywhiz also focuses on not having too many Secrets scattered around, which can be risky. </span><span class="koboSpan" id="kobo.354.2">By keeping them all in one system, it’s easier to keep track of them and make sure they are safe. </span><span class="koboSpan" id="kobo.354.3">Plus, this system lets Square check on the health of their digital keys and passwords, for instance, to see whether they are strong enough or need to be </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">changed soon.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">It’s important for Square to know when and how a secret is used. </span><span class="koboSpan" id="kobo.356.2">So, Keywhiz keeps a detailed record of every time a secret is accessed. </span><span class="koboSpan" id="kobo.356.3">This isn’t something you can do if you just drop the Secrets onto servers as files. </span><span class="koboSpan" id="kobo.356.4">Although there are tools that can help keep an eye on this, they require extra work to </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">set up.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">Keywhiz is made to work with a lot of different services at Square. </span><span class="koboSpan" id="kobo.358.2">It has been set up to handle a wide range of needs, from securing websites to </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">handling databases.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">The reliability of this system is key. </span><span class="koboSpan" id="kobo.360.2">It has to work all the time because Square’s services rely on these Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">to run.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">The system is also designed to be easy to use. </span><span class="koboSpan" id="kobo.362.2">If it wasn’t, people might try to take shortcuts, which could be </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">less safe.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">Finally, Keywhiz separates the process of changing</span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.365.1"> keys from updating software. </span><span class="koboSpan" id="kobo.365.2">This means that Square can update its security without having to change the whole system, which makes things safer and </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">more flexible.</span></span></p>
<h4><span class="koboSpan" id="kobo.367.1">Categorizing and centralizing the store Secrets</span></h4>
<p><span class="koboSpan" id="kobo.368.1">Square’s Keywhiz system takes the security</span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.369.1"> of its digital Secrets</span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.370.1"> seriously. </span><span class="koboSpan" id="kobo.370.2">It begins by organizing these Secrets into clear categories. </span><span class="koboSpan" id="kobo.370.3">This isn’t just about keeping things tidy—it’s about knowing exactly which part of Square’s system needs which Secrets to operate. </span><span class="koboSpan" id="kobo.370.4">From there, all Secrets are kept in one central place. </span><span class="koboSpan" id="kobo.370.5">This means they’re not scattered across different spots where they could be forgotten or, worse, fall into the </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">wrong hands.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">But what makes Keywhiz stand out is how it locks up these Secrets. </span><span class="koboSpan" id="kobo.372.2">Before a secret is saved in Square’s databases, it gets wrapped up in a layer of encryption—like putting a letter into a safe that only certain</span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.373.1"> people can open. </span><span class="koboSpan" id="kobo.373.2">This</span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.374.1"> involves a specific type of encryption known as </span><strong class="bold"><span class="koboSpan" id="kobo.375.1">AES-GCM</span></strong><span class="koboSpan" id="kobo.376.1"> (</span><a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode"><span class="koboSpan" id="kobo.377.1">https://en.wikipedia.org/wiki/Galois/Counter_Mode</span></a><span class="koboSpan" id="kobo.378.1">). </span><span class="koboSpan" id="kobo.378.2">It’s recommended by the </span><strong class="bold"><span class="koboSpan" id="kobo.379.1">National Institute of Standards and Technology</span></strong><span class="koboSpan" id="kobo.380.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.381.1">NIST</span></strong><span class="koboSpan" id="kobo.382.1">) in their Special Publication 800-38D as a preferred method</span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.383.1"> for block cipher (</span><a href="https://en.wikipedia.org/wiki/Block_cipher"><span class="koboSpan" id="kobo.384.1">https://en.wikipedia.org/wiki/Block_cipher</span></a><span class="koboSpan" id="kobo.385.1">) modes of</span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.386.1"> operation, focusing on </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">Galois/Counter Mode</span></strong><span class="koboSpan" id="kobo.388.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.389.1">GCM</span></strong><span class="koboSpan" id="kobo.390.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.391.1">Galois Message Authentication Code </span></strong><span class="koboSpan" id="kobo.392.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.393.1">GMAC</span></strong><span class="koboSpan" id="kobo.394.1">). </span><span class="koboSpan" id="kobo.394.2">Each secret gets its own unique encryption </span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.395.1">key, created using a method known as </span><strong class="bold"><span class="koboSpan" id="kobo.396.1">HKDF</span></strong><span class="koboSpan" id="kobo.397.1"> (</span><a href="https://en.wikipedia.org/wiki/HKDF"><span class="koboSpan" id="kobo.398.1">https://en.wikipedia.org/wiki/HKDF</span></a><span class="koboSpan" id="kobo.399.1">), a simple </span><strong class="bold"><span class="koboSpan" id="kobo.400.1">key derivation function</span></strong><span class="koboSpan" id="kobo.401.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.402.1">KDF</span></strong><span class="koboSpan" id="kobo.403.1">) based on the HMAC message authentication</span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.404.1"> code, which is a way to make </span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.405.1">sure that even if one key is discovered, the others remain safe. </span><span class="koboSpan" id="kobo.405.2">Square uses hardware security modules to contain </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">derivation keys.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">Now, when it comes to delivering these Secrets, Keywhiz makes sure that only the right parts of Square’s system, which they call </span><em class="italic"><span class="koboSpan" id="kobo.408.1">clients</span></em><span class="koboSpan" id="kobo.409.1">, can get to them. </span><span class="koboSpan" id="kobo.409.2">The structure of access control revolves around three</span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.410.1"> key elements: clients, groups, and Secrets. </span><span class="koboSpan" id="kobo.410.2">A “client” refers to any certificate that gains access to Secrets. </span><span class="koboSpan" id="kobo.410.3">These clients can belong to multiple groups, which are collections of clients. </span><span class="koboSpan" id="kobo.410.4">For a client to access a particular secret, the secret must be associated with at least one of the groups to which the client belongs. </span><span class="koboSpan" id="kobo.410.5">Typically, Keywhiz organizes this by creating three main types of groups: one for</span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.411.1"> each service on a specific server, one for each distinct service, and a universal group that includes </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">all clients.</span></span></p>
<p><span class="koboSpan" id="kobo.413.1">Before, people tried other ways to keep Secrets safe, such as mixing them into the code where programs are written or manually adding them to servers. </span><span class="koboSpan" id="kobo.413.2">But these ways are risky—the Secrets can accidentally get shared with the world or get lost. </span><span class="koboSpan" id="kobo.413.3">Even trying to keep Secrets safe using systems that manage server settings isn’t ideal because those systems are meant to share their information</span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.414.1"> across the company, which is not what</span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.415.1"> you want for </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">your Secrets.</span></span></p>
<h4><span class="koboSpan" id="kobo.417.1">PKI as a source of the truth for authentication</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.418.1">Public key infrastructure</span></strong><span class="koboSpan" id="kobo.419.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.420.1">PKI</span></strong><span class="koboSpan" id="kobo.421.1">) is central to Square’s authentication</span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.422.1"> process. </span><span class="koboSpan" id="kobo.422.2">It’s like a verification system that ensures</span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.423.1"> that only the right parts of Square’s network can access the Secrets they need. </span><span class="koboSpan" id="kobo.423.2">To establish this trust, Square uses mTLS and X509 certificates, which are digital proofs</span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.424.1"> of identity for services. </span><span class="koboSpan" id="kobo.424.2">Square simplifies this task with </span><strong class="bold"><span class="koboSpan" id="kobo.425.1">certstrap</span></strong><span class="koboSpan" id="kobo.426.1">, a straightforward certificate management tool. </span><span class="koboSpan" id="kobo.426.2">This tool helps Square create its own certificate authorities, which you can think of as digital ID offices. </span><span class="koboSpan" id="kobo.426.3">With certstrap, Square can issue these digital IDs to its services, ensuring each one is recognized and trusted within </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">its network.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">certstrap allows Square to avoid the complexities of traditional tools such as OpenSSL. </span><span class="koboSpan" id="kobo.428.2">It enables Square to create a chain of trust where each service’s identity is verified and secured. </span><span class="koboSpan" id="kobo.428.3">This verification is crucial for Square, as it keeps communication between services secure, ensuring that Secrets are only accessed by authorized entities within </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">the company.</span></span></p>
<h4><span class="koboSpan" id="kobo.430.1">Authorization data model</span></h4>
<p><span class="koboSpan" id="kobo.431.1">In Square’s Keywhiz system, authorization—deciding </span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.432.1">who gets access to what—is a structured process. </span><span class="koboSpan" id="kobo.432.2">Here’s how Square has set </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">it up:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.434.1">Clients are parts of Square’s systems, such as a service or an application, that need access to Secrets to work properly. </span><span class="koboSpan" id="kobo.434.2">They prove</span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.435.1"> who they are with something called a client certificate. </span><span class="koboSpan" id="kobo.435.2">It’s like an ID card </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">for systems.</span></span></li>
<li><span class="koboSpan" id="kobo.437.1">Secrets are the sensitive bits of information that clients need to do their jobs, such as configuration files or passwords. </span><span class="koboSpan" id="kobo.437.2">Each secret has a unique name so there are no mixups, and they can’t be changed once they’re set. </span><span class="koboSpan" id="kobo.437.3">However, Square can keep multiple versions of a secret if updates </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">are needed.</span></span></li>
<li><span class="koboSpan" id="kobo.439.1">Groups act as a meeting point for clients and Secrets. </span><span class="koboSpan" id="kobo.439.2">Think of groups as tags or labels. </span><span class="koboSpan" id="kobo.439.3">Square labels the clients and the Secrets with these group tags. </span><span class="koboSpan" id="kobo.439.4">When a client and a secret have the same group tag, the client can see and use the secret. </span><span class="koboSpan" id="kobo.439.5">It’s Square’s way of organizing which parts of their system can access </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">which Secrets.</span></span></li>
<li><span class="koboSpan" id="kobo.441.1">Users are the people who manage Keywhiz at Square. </span><span class="koboSpan" id="kobo.441.2">They’re the ones setting up the system and deciding which clients and Secrets get which group tags. </span><span class="koboSpan" id="kobo.441.3">They log in to Keywhiz with secure methods, and after they’re in, they need a special code from Keywhiz to keep doing their </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">work securely.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.443.1">Square’s Keywhiz manages</span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.444.1"> access through a structured authorization model of clients, Secrets, groups, and user management, maintaining secure and </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">orderly permissions.</span></span></p>
<h4><span class="koboSpan" id="kobo.446.1">Secrets distribution</span></h4>
<p><span class="koboSpan" id="kobo.447.1">Square also maintains a Keywhiz client </span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.448.1">implementation called </span><strong class="bold"><span class="koboSpan" id="kobo.449.1">Keysync</span></strong><span class="koboSpan" id="kobo.450.1">. </span><span class="koboSpan" id="kobo.450.2">Keysync is a program</span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.451.1"> that connects to Square’s Keywhiz server securely and asks for the Secrets it needs to keep Square’s services running. </span><span class="koboSpan" id="kobo.451.2">It uses something called </span><strong class="bold"><span class="koboSpan" id="kobo.452.1">mTLS</span></strong><span class="koboSpan" id="kobo.453.1">—a way of communicating securely—to make</span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.454.1"> sure everything is safe </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">and private.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">Once Keysync gets these Secrets, it keeps</span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.457.1"> them in a secure area of the server’s memory called </span><strong class="bold"><span class="koboSpan" id="kobo.458.1">tmpfs</span></strong><span class="koboSpan" id="kobo.459.1">. </span><span class="koboSpan" id="kobo.459.2">This is a temporary space that doesn’t save anything once the server is turned off. </span><span class="koboSpan" id="kobo.459.3">So, if there’s a power cut or the server has to be restarted, those Secrets don’t get left behind where they could be seen </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">by others.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">The neat thing about Keysync is that it’s built to handle unexpected problems. </span><span class="koboSpan" id="kobo.461.2">If there’s an issue with the Keywhiz server, Keysync will still have the Secrets it previously downloaded, so Square’s services can keep working without interruption. </span><span class="koboSpan" id="kobo.461.3">It’s only after a full server reboot that Keysync needs to get all the </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">Secrets again.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">To handle these Secrets, Square’s administrators have an admin CLI that allows them to type commands directly into the system to add, remove, or change Secrets as needed. </span><span class="koboSpan" id="kobo.463.2">It’s a straightforward way for them to keep everything up to date and to check on the health of the Secrets management system without having to navigate through </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">complicated interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">Keysync, the CLI for Square’s Keywhiz interface, ensures the secure</span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.466.1"> and confidential delivery of Secrets across </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">different scenarios.</span></span></p>
<h3><span class="koboSpan" id="kobo.468.1">Challenges and lessons of Keywhiz from a third-party view</span></h3>
<p><span class="koboSpan" id="kobo.469.1">Given that Keywhiz was deprecated</span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.470.1"> on September 18, 2023, and is no longer maintained, reflecting on the challenges and lessons it presented during its service is insightful. </span><span class="koboSpan" id="kobo.470.2">The recommendation to transition to HashiCorp Vault highlights the need for robust and actively supported Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">management solutions.</span></span></p>
<h4><span class="koboSpan" id="kobo.472.1">Centralized management with Kubernetes cases is hard</span></h4>
<p><span class="koboSpan" id="kobo.473.1">One of the core challenges Keywhiz faces in Kubernetes Secrets management is the inherent complexity of centralized management in a highly distributed and dynamic environment such as Kubernetes. </span><span class="koboSpan" id="kobo.473.2">Kubernetes environments often require a more flexible and decentralized approach to Secrets management. </span><span class="koboSpan" id="kobo.473.3">Although Keywhiz offers centralized control and strong encryption for Secrets, it may not be optimally configured for the decentralized and ephemeral nature of </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">Kubernetes workloads.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">For example, in Kubernetes, it’s essential to have a Secrets management solution that can handle the dynamic creation and deletion of Secrets, in line with the ephemeral nature of Kubernetes Pods and Services. </span><span class="koboSpan" id="kobo.475.2">Secrets</span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.476.1"> management in Kubernetes also requires tight integration with Kubernetes’ </span><strong class="bold"><span class="koboSpan" id="kobo.477.1">role-based access control</span></strong><span class="koboSpan" id="kobo.478.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.479.1">RBAC</span></strong><span class="koboSpan" id="kobo.480.1">) and the ability to manage Secrets across multiple clusters and </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">namespaces efficiently.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">While Keywhiz excels at centralized Secrets management, providing strong encryption and a secure way to distribute Secrets to various services and platforms, adapting these capabilities to the specifics of Kubernetes can be challenging. </span><span class="koboSpan" id="kobo.482.2">Kubernetes environments often benefit from tools such as HashiCorp Vault, which offers extensive Kubernetes integration, including dynamic Secrets, integration with Kubernetes service accounts for authentication, and the ability to define fine-grained access control policies </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">for Secrets.</span></span></p>
<h4><span class="koboSpan" id="kobo.484.1">A Secrets management system is not just one system but a whole ecosystem</span></h4>
<p><span class="koboSpan" id="kobo.485.1">Keywhiz’s role in an organization’s ecosystem</span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.486.1"> extends beyond its function as a standalone Secrets management tool. </span><span class="koboSpan" id="kobo.486.2">Its effectiveness relies heavily on its integration with the company’s existing workflows, policies, and organizational culture. </span><span class="koboSpan" id="kobo.486.3">This scenario illustrates that the efficacy of a Secrets management system is not determined solely by its technical capabilities but by how well it aligns with and supports the broader operational context of </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">the organization.</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">For instance, consider a healthcare organization that adopts Keywhiz to manage sensitive data, such as patient records and login credentials for internal systems. </span><span class="koboSpan" id="kobo.488.2">In this setting, while Keywhiz serves as the repository for these Secrets, its utility is dependent on seamless integration with the organization’s existing healthcare information systems. </span><span class="koboSpan" id="kobo.488.3">This integration could involve syncing with employee directory services to manage access based on roles and departments. </span><span class="koboSpan" id="kobo.488.4">It would also entail aligning with healthcare compliance standards, where Keywhiz’s audit trails and encryption capabilities become critical in meeting regulatory requirements. </span><span class="koboSpan" id="kobo.488.5">In this way, Keywhiz becomes an integral part of the organization’s overall data security framework, influencing and being influenced by various factors beyond the immediate scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">secret storage.</span></span></p>
<h4><span class="koboSpan" id="kobo.490.1">Lack of auditing as a story</span></h4>
<p><span class="koboSpan" id="kobo.491.1">A notable limitation of Keywhiz is its approach to auditing, especially considering how it handles secret distribution. </span><span class="koboSpan" id="kobo.491.2">Keysync works as a client where Secrets are downloaded as </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">tmpfs</span></strong><span class="koboSpan" id="kobo.493.1"> files, which are then used by applications. </span><span class="koboSpan" id="kobo.493.2">However, this model does not inherently provide detailed auditing data for each action taken on these Secrets, and specifically, it lacks visibility into whether applications are actively using the downloaded Secrets, as this interaction occurs client-side and is not directly observable by the </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">Keywhiz server.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">This leads to potential gaps in the auditing process, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.497.1">Identifying the specific user or service that accessed </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">a secret</span></span></li>
<li><span class="koboSpan" id="kobo.499.1">Recording the precise timestamp of </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">each access</span></span></li>
<li><span class="koboSpan" id="kobo.501.1">Understanding the nature of the access, such as whether the secret was read, modified, and </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">so on</span></span></li>
<li><span class="koboSpan" id="kobo.503.1">Detecting the IP address or machine from which the secret </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">was accessed</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.505.1">The Keysync process does not reflect the real-time requirements for Secrets associated with applications, leading to challenges in maintaining a continuous and comprehensive audit trail. </span><span class="koboSpan" id="kobo.505.2">This gap can impact the ability to fully document the lifecycle of secret access within an organization, making it difficult</span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.506.1"> to trace all interactions with </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">sensitive data.</span></span></p>
<h1 id="_idParaDest-250"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.508.1">Managing the Secrets lifecycle from end to end in a Kubernetes production cluster</span></h1>
<p><span class="koboSpan" id="kobo.509.1">The previous chapter covered a broad</span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.510.1"> range of topics, but there was a noticeable disconnect between the concepts discussed and practical examples for managing Secrets in a production environment. </span><span class="koboSpan" id="kobo.510.2">In this section, we will narrow our focus and delve into the end-to-end management of Secrets within a Kubernetes production cluster, offering a more practical, </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">application-oriented perspective.</span></span></p>
<p><span class="koboSpan" id="kobo.512.1">In exploring the management of Secrets in such an environment, we recognize that the process involves more than just secure storage. </span><span class="koboSpan" id="kobo.512.2">We shift our focus from mere storage repositories to a comprehensive view of Secrets usage throughout the system’s lifecycle. </span><span class="koboSpan" id="kobo.512.3">Secrets are integral to operational processes, embedded in the workflows that drive an organization’s </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">digital operations.</span></span></p>
<p><span class="koboSpan" id="kobo.514.1">The challenge lies in effectively managing the entire lifecycle of Secrets, from inception to decommissioning, with a rigorous emphasis on precision and security. </span><span class="koboSpan" id="kobo.514.2">This comprehensive approach is essential for organizations committed to high security and operational standards. </span><span class="koboSpan" id="kobo.514.3">Managing Secrets</span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.515.1"> effectively is about understanding their generation, distribution, revocation, and decommissioning within the dynamic Kubernetes ecosystem. </span><span class="koboSpan" id="kobo.515.2">This section will guide you through the nuanced and vital role of Secrets management in maintaining a secure and efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">digital infrastructure.</span></span></p>
<h2 id="_idParaDest-251"><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.517.1">Finalizing your decision on comprehensive Secrets lifecycle management</span></h2>
<p><span class="koboSpan" id="kobo.518.1">When it comes to managing Secrets</span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.519.1"> in a Kubernetes production environment, adopting a holistic and comprehensive approach is paramount. </span><span class="koboSpan" id="kobo.519.2">Secrets lifecycle management extends far beyond the mere aspect of secure storage, encompassing a range of critical processes from the initial provisioning to the final decommissioning </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">and revocation.</span></span></p>
<p><span class="koboSpan" id="kobo.521.1">Provisioning involves the creation or generation of Secrets in a secure and controlled manner, ensuring that they are strong and unique and that they comply with organizational security policies. </span><span class="koboSpan" id="kobo.521.2">The storage phase requires a robust and secure repository, such as HashiCorp Vault or cloud Secrets stores, ensuring that Secrets are encrypted at rest and protected from unauthorized access. </span><span class="koboSpan" id="kobo.521.3">Distribution is a delicate operation, where Secrets must be securely transmitted to the required services or applications, ensuring integrity and confidentiality </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">throughout transit.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">Decommissioning comes into play when Secrets are no longer required, necessitating a secure process to retire them, ensuring that they cannot be reused or exploited. </span><span class="koboSpan" id="kobo.523.2">Finally, revocation is a critical step in the lifecycle, particularly in instances of compromise or when a secret’s integrity is in doubt. </span><span class="koboSpan" id="kobo.523.3">A swift and efficient revocation mechanism ensures that access is immediately cut off, mitigating </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">potential damage.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">Embracing a comprehensive Secrets lifecycle management approach ensures that Secrets are not just securely stored but are also properly managed throughout their entire lifecycle. </span><span class="koboSpan" id="kobo.525.2">This end-to-end perspective is not just a best practice but an organizational necessity to ensure the integrity of the Secrets and, by extension, the entire production system. </span><span class="koboSpan" id="kobo.525.3">As we delve deeper into each of these aspects in the subsequent sections, the overarching</span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.526.1"> importance of a holistic approach to Secrets management in Kubernetes will become increasingly clear, highlighting its role as a critical component in the broader security and operational landscape of </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">the organization.</span></span></p>
<h2 id="_idParaDest-252"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.528.1">High SLAs as the key to business sustainability</span></h2>
<p><span class="koboSpan" id="kobo.529.1">Maintaining high </span><strong class="bold"><span class="koboSpan" id="kobo.530.1">service-level agreements</span></strong><span class="koboSpan" id="kobo.531.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.532.1">SLAs</span></strong><span class="koboSpan" id="kobo.533.1">) is vital for Secrets management within Kubernetes</span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.534.1"> environments, emphasizing system reliability and availability</span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.535.1"> as foundational aspects of business sustainability. </span><span class="koboSpan" id="kobo.535.2">This is particularly important in production environments where downtime or security breaches could have significant financial and </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">operational implications.</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">To achieve this high level of reliability, businesses need to implement strong monitoring and alerting systems. </span><span class="koboSpan" id="kobo.537.2">Regular stress testing of the Secrets management system is also essential to identify and address potential vulnerabilities, ensuring the system can handle various operational stresses and maintain its </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">SLA commitments.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">In the context of cloud Secrets storage, providers typically offer committed SLAs that meet the requirements of most use cases. </span><span class="koboSpan" id="kobo.539.2">However, for self-deployed Secrets management systems, different approaches are necessary to evaluate and ensure SLAs, especially when secret retrieval is critical for system infrastructure and </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">platform usage.</span></span></p>
<p><span class="koboSpan" id="kobo.541.1">One strategy to ensure high SLAs is the active-active replication model used by solutions such as HashiCorp Vault. </span><span class="koboSpan" id="kobo.541.2">This model provides continuous synchronization across multiple active systems, enhancing fault tolerance and availability. </span><span class="koboSpan" id="kobo.541.3">However, it’s not the </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">only approach.</span></span></p>
<p><span class="koboSpan" id="kobo.543.1">Alternative methods, such as using a secure Redis configuration for buffered Secrets, can offer temporary availability (e.g., for a few hours) and enhance platform reliability. </span><span class="koboSpan" id="kobo.543.2">In this scenario, Secrets are stored as encrypted ciphertext in Redis, which acts as a temporary buffer. </span><span class="koboSpan" id="kobo.543.3">This method not only secures the Secrets but also provides an additional layer of reliability, ensuring that Secrets are available during critical periods or in the event of primary </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">system failures.</span></span></p>
<p><span class="koboSpan" id="kobo.545.1">Overall, the approach</span><a id="_idIndexMarker831"/><span class="koboSpan" id="kobo.546.1"> to maintaining high SLAs in Secrets management should be tailored to the specific needs and architecture of the </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">Kubernetes environment.</span></span></p>
<h2 id="_idParaDest-253"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.548.1">Emergency recovery – backup and restore</span></h2>
<p><span class="koboSpan" id="kobo.549.1">In Kubernetes production</span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.550.1"> clusters, crafting an effective emergency recovery plan for Secrets management is essential. </span><span class="koboSpan" id="kobo.550.2">A robust recovery plan is key to quickly restoring operations in the event of data losses, system failures, or security incidents, thereby minimizing downtime. </span><span class="koboSpan" id="kobo.550.3">This proactive approach ensures that the Secrets management system can swiftly recover from unexpected disruptions, thus maintaining the continuity of the </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">production environment.</span></span></p>
<p><span class="koboSpan" id="kobo.552.1">Regular backups play a critical role in safeguarding the integrity and availability of Secrets and configurations. </span><span class="koboSpan" id="kobo.552.2">These backups form the foundation for a reliable recovery mechanism, ensuring that there’s a dependable process for retrieving sensitive information and configurations following unforeseen data loss, hardware failures, or </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">security breaches.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">For further details and insights on this topic, you may refer to </span><a href="B20970_06.xhtml#_idTextAnchor117"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.555.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.556.1">, </span><em class="italic"><span class="koboSpan" id="kobo.557.1">Disaster Recovery </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.558.1">and Backups</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">.</span></span></p>
<h2 id="_idParaDest-254"><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.560.1">Not just storing but provisioning Secrets</span></h2>
<p><span class="koboSpan" id="kobo.561.1">Provisioning and storing Secrets</span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.562.1"> are critical steps in managing Secrets within a Kubernetes environment, acting as the initial point of entry and a significant opportunity to enforce secure usage models. </span><span class="koboSpan" id="kobo.562.2">By controlling the origin of Secrets and clearly defining their target resources, organizations can establish a robust framework for long-term </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">Secrets management.</span></span></p>
<p><span class="koboSpan" id="kobo.564.1">When provisioning Secrets, it’s imperative to ensure transparency and traceability. </span><span class="koboSpan" id="kobo.564.2">Enforcing a clear and standardized process for secret creation helps in tracking where Secrets come from, their intended purpose, and their targeted resources. </span><span class="koboSpan" id="kobo.564.3">This practice aids in maintaining an organized Secrets inventory, making it simpler to manage and audit </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.566.1">In terms of storing Secrets securely in Kubernetes, adopting best practices such as encryption at rest and in transit, using dedicated service accounts, and implementing role-based access controls is essential. </span><span class="koboSpan" id="kobo.566.2">Organizations should leverage Kubernetes’ native capabilities, such as Namespaces and NetworkPolicies, to provide additional layers of isolation </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">and protection.</span></span></p>
<p><span class="koboSpan" id="kobo.568.1">A key aspect of ensuring long-term success in Secrets management is to enforce the use of specific secret types. </span><span class="koboSpan" id="kobo.568.2">Kubernetes supports various secret types, each tailored to specific use cases. </span><span class="koboSpan" id="kobo.568.3">By mandating the use of these types, organizations can benefit from Kubernetes’ built-in validation mechanisms, ensuring that Secrets conform to the expected structure and reducing the risk of misconfigurations. </span><span class="koboSpan" id="kobo.568.4">For instance, enforcing a secret type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">kubernetes.io/dockerconfigjson</span></strong><span class="koboSpan" id="kobo.570.1"> for storing Docker registry credentials ensures that the secret’s content adheres to the expected format, reducing the risk of </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">runtime errors.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">Furthermore, utilizing specific secret types aids in creating a self-descriptive and more manageable environment. </span><span class="koboSpan" id="kobo.572.2">Developers and administrators can easily understand the purpose and usage of a secret based on its type, enhancing overall clarity and reducing the potential for mistakes. </span><span class="koboSpan" id="kobo.572.3">This practice also simplifies auditing and compliance processes, as it becomes straightforward to track and report on the usage of different types of Secrets across the </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">Incorporating these practices</span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.575.1"> into the provisioning and storage phases of Secrets management sets a solid foundation for secure and efficient secret handling. </span><span class="koboSpan" id="kobo.575.2">It ensures that Secrets are created, stored, and used in a manner that aligns with security best practices, providing a significant return on investment in terms of security, compliance, and manageability. </span><span class="koboSpan" id="kobo.575.3">By enforcing clear standards and utilizing Kubernetes’ native capabilities, organizations can create a robust and resilient Secrets management environment, ready to support their applications securely </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">and efficiently.</span></span></p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.577.1">Secrets rotation</span></h2>
<p><span class="koboSpan" id="kobo.578.1">The rotation of Secrets</span><a id="_idIndexMarker835"/><span class="koboSpan" id="kobo.579.1"> stands as a crucial practice in maintaining a secure Kubernetes environment, primarily due to the inherent security implications tied to static, long-lived credentials. </span><span class="koboSpan" id="kobo.579.2">Secrets, once compromised, can serve as gateways for malicious entities, leading to unauthorized access and potential data breaches. </span><span class="koboSpan" id="kobo.579.3">To mitigate such risks, implementing the periodic rotation of Secrets is necessary, ensuring that even if a secret were to be compromised, its lifespan would be limited, thereby reducing the potential </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">damage inflicted.</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">However, the task of rotating Secrets is not without its challenges, especially when dealing with a large number of Secrets distributed across various services. </span><span class="koboSpan" id="kobo.581.2">This is where automation steps in, offering a streamlined and efficient solution. </span><span class="koboSpan" id="kobo.581.3">By leveraging automated systems, organizations can ensure timely rotations, aligning with best practices and compliance requirements. </span><span class="koboSpan" id="kobo.581.4">These systems work by periodically updating Secrets and credentials, distributing the updated versions to the respective services, and ensuring the outdated Secrets are </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">retired securely.</span></span></p>
<p><span class="koboSpan" id="kobo.583.1">It is crucial to note that while automation plays a significant role in Secrets rotation, there may be exceptional cases where certain Secrets are exempt from rotation due to technical constraints or specific use cases. </span><span class="koboSpan" id="kobo.583.2">In these situations, it is imperative to maintain transparency and clear documentation, marking these Secrets accordingly to ensure visibility. </span><span class="koboSpan" id="kobo.583.3">Despite the exemption, a robust incident response plan must be in place, guaranteeing that if a security incident were to occur, these exempted Secrets could be rotated in a timely manner, mitigating potential risks and securing the environment. </span><span class="koboSpan" id="kobo.583.4">This comprehensive approach to Secrets rotation ensures not only the security of the Secrets themselves</span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.584.1"> but also the resilience and integrity of the entire </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">Kubernetes ecosystem.</span></span></p>
<h3><span class="koboSpan" id="kobo.586.1">Handling secret updates and rotation</span></h3>
<p><span class="koboSpan" id="kobo.587.1">Handling secret updates</span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.588.1"> and rotations is a crucial aspect of maintaining</span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.589.1"> security. </span><span class="koboSpan" id="kobo.589.2">As recommended by NIST, regularly rotating Secrets is essential to minimize </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">security risks.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">Our approach to updating Secrets involves </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">several methods:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.593.1">Monitoring and reloading</span></strong><span class="koboSpan" id="kobo.594.1">: We continually monitor for secret changes, updating them in application memory to ensure the latest values </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">are used.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.596.1">Keyring mode</span></strong><span class="koboSpan" id="kobo.597.1">: This involves maintaining multiple versions of Secrets to prevent downtime. </span><span class="koboSpan" id="kobo.597.2">It’s important to monitor which version is in use and phase out older </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">ones timely.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.599.1">Restart as reload method</span></strong><span class="koboSpan" id="kobo.600.1">: Implement an automatic system to restart Pods when Secrets change, possibly using Kubernetes jobs or other tools to detect changes and </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">initiate</span></span><span class="No-Break"><a id="_idIndexMarker839"/></span><span class="No-Break"><span class="koboSpan" id="kobo.602.1"> restarts.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.603.1">Each application’s needs dictate the chosen</span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.604.1"> method, focusing on </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.606.1">Timely secret consumption</span></strong><span class="koboSpan" id="kobo.607.1">: Depending on the server’s capability to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">multiple values</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.609.1">Graceful secret changes</span></strong><span class="koboSpan" id="kobo.610.1">: Ensuring applications manage new Secrets smoothly, without losing state or </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">causing downtime</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.612.1">Downtime avoidance</span></strong><span class="koboSpan" id="kobo.613.1">: For applications that can’t afford downtime, use strategies such as multiple Pod replicas and </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">rolling updates</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.615.1">Monitoring and alerting</span></strong><span class="koboSpan" id="kobo.616.1">: Keep a robust system to monitor Secrets and Pods, with alerts for secret rotations and </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">Pod restarts</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.618.1">This strategy aims for both security and operational efficiency, adapting to various application requirements on </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">secret rotation.</span></span></p>
<h3><span class="koboSpan" id="kobo.620.1">Sample Kubernetes manifest for automated secret rotation</span></h3>
<p><span class="koboSpan" id="kobo.621.1">The following is a simplified example</span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.622.1"> to illustrate how you might set up a Kubernetes</span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.623.1"> job to trigger Pod restarts upon </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">secret rotation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.625.1">
apiVersion: batch/v1
kind: Job
metadata:
  name: secret-rotator
spec:
  template:
    spec:
      containers:
      - name: secret-rotator
        image: user-implemented-rotator-image
        env:
        - name: VAULT_ADDR
          value: "http://vault:8200"
        - name: SECRET_PATH
          value: "secret/my-app"
        - name: KUBERNETES_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: POD_SELECTOR
          value: "app=my-app"
      restartPolicy: Never
  backoffLimit: 0</span></pre> <p><span class="koboSpan" id="kobo.626.1">Here is a diagram</span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.627.1"> showing the additional</span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.628.1"> Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">rotation job:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.630.1"><img alt="Figure 13.1 – Cro﻿n job for secret rotation" src="image/B20970_13_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.631.1">Figure 13.1 – Cron job for secret rotation</span></p>
<p><span class="koboSpan" id="kobo.632.1">In this example, the job runs a container that watches for secret rotations in Vault and restarts the relevant Pods in Kubernetes when a rotation is detected. </span><span class="koboSpan" id="kobo.632.2">This ensures that the init containers for the affected Pods run again, fetching the latest version of the Secrets. </span><span class="koboSpan" id="kobo.632.3">By adopting such strategies, you ensure</span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.633.1"> that your applications remain secure with up-to-date Secrets while minimizing</span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.634.1"> downtime and maintaining a robust and </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">resilient deployment.</span></span></p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.636.1">Authorization sprawl issue</span></h2>
<p><span class="koboSpan" id="kobo.637.1">In Kubernetes, managing access</span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.638.1"> to Secrets requires careful attention </span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.639.1">due to the delicate </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">balance involved.</span></span></p>
<p><span class="koboSpan" id="kobo.641.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.642.1">authorization sprawl</span></strong><span class="koboSpan" id="kobo.643.1"> issue in Kubernetes arises when permissions are set too broadly, often unintentionally, leading to significant security risks. </span><span class="koboSpan" id="kobo.643.2">This often occurs with RBAC configurations that are not adequately tailored, resulting in users or services gaining more privileges </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">than necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.645.1">Certainly, solutions such as Kubernetes RBAC and integration with identity management solutions are well known, but the real issues include </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.647.1">How to enforce compliance and prevent users from exploiting or circumventing the </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">configuration source</span></span></li>
<li><span class="koboSpan" id="kobo.649.1">How to effectively monitor and promptly revoke any </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">policy violations</span></span></li>
<li><span class="koboSpan" id="kobo.651.1">How to audit configuration-based access policy changes and understand </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">their impact</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.653.1">A typical misconfiguration in Kubernetes RBAC</span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.654.1"> might unintentionally</span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.655.1"> allow unexpected groups to access </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">all Secrets:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.657.1">
# serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: myapp-sa
---
# role.yaml
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: myapp-role
rules:
  - apiGroups: [""]
    resources: ["pods", "secrets"]
    verbs: ["get", "watch", "list", "create", "update", "delete"]
---
# misconfigured-role-binding.yaml
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: myapp-role-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: myapp-role
subjects:
  - kind: ServiceAccount
    name: myapp-sa</span></pre> <p><span class="koboSpan" id="kobo.658.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">myapp-sa</span></strong><span class="koboSpan" id="kobo.660.1"> service account is created with overly broad access to Pods and Secrets. </span><span class="koboSpan" id="kobo.660.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">myapp-role-binding</span></strong><span class="koboSpan" id="kobo.662.1"> role binding exacerbates the issue by referencing </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">myapp-role</span></strong><span class="koboSpan" id="kobo.664.1">, which grants full access to these resources. </span><span class="koboSpan" id="kobo.664.2">As a result, </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">myapp-sa</span></strong><span class="koboSpan" id="kobo.666.1"> is endowed with more permissions than necessary, posing a risk of unauthorized access to </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">sensitive data.</span></span></p>
<p><span class="koboSpan" id="kobo.668.1">Addressing this issue requires the implementation</span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.669.1"> of fine-grained access</span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.670.1"> controls that precisely define permissions for each role and user, adhering to the principle of least privilege. </span><span class="koboSpan" id="kobo.670.2">This entails granting only the level of access required for users to perform their specific tasks. </span><span class="koboSpan" id="kobo.670.3">Regular reviews and updates of RBAC policies are </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">also essential.</span></span></p>
<h2 id="_idParaDest-257"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.672.1">Tagging, labeling, and masking on the client side</span></h2>
<p><span class="koboSpan" id="kobo.673.1">Within a Kubernetes environment, the approach</span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.674.1"> to managing Secrets should be holistic, accounting for not just how Secrets</span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.675.1"> are stored but also how</span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.676.1"> they are managed and interacted with on the client side. </span><span class="koboSpan" id="kobo.676.2">Tagging, labeling, and masking Secrets become pivotal in this context. </span><span class="koboSpan" id="kobo.676.3">The rationale behind adopting these practices is grounded in their ability to enhance security, manageability, and adherence to compliance standards. </span><span class="koboSpan" id="kobo.676.4">By tagging and labeling Secrets, teams embed essential metadata that elucidates the secret’s purpose, associated resources, and lifecycle stage. </span><span class="koboSpan" id="kobo.676.5">This metadata becomes a powerful tool, aiding in implementing granular access controls and simplifying the tracking of secret usage across </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.678.1">When it comes to implementation, these practices should be seamlessly integrated into the development and deployment workflows. </span><span class="koboSpan" id="kobo.678.2">Developers and operators should be encouraged, or even mandated, to include relevant tags and labels as part of their deployment configurations, ensuring that every secret is appropriately annotated from the outset. </span><span class="koboSpan" id="kobo.678.3">Masking, on the other hand, involves obscuring secret values in logs or UIs to preclude accidental exposure, which is a common risk, especially in debugging scenarios. </span><span class="koboSpan" id="kobo.678.4">Systems need to be configured to automatically recognize and redact sensitive information, a task that can be achieved through pattern recognition, checksums, or the explicit marking of sensitive fields in the application’s </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">logging configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.680.1">In the long term, the payoff of these practices is substantial. </span><span class="koboSpan" id="kobo.680.2">The wealth of metadata provided through tagging and labeling facilitates a robust and continuous audit trail, allowing teams to track and manage Secrets effectively over extended periods. </span><span class="koboSpan" id="kobo.680.3">This is crucial not just for day-to-day operational integrity but also for meeting stringent security and compliance requirements. </span><span class="koboSpan" id="kobo.680.4">Any unauthorized access or modifications can be quickly identified and rectified, ensuring that the organization’s Secrets management strategy is both secure and resilient. </span><span class="koboSpan" id="kobo.680.5">Meanwhile, masking ensures that even in scenarios where logs or UIs are exposed, the confidentiality of secret values is maintained, mitigating the risk of </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">accidental exposure.</span></span></p>
<p><span class="koboSpan" id="kobo.682.1">By adopting these client-side practices, organizations</span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.683.1"> lay down a foundation for a comprehensive Secrets</span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.684.1"> management strategy, ensuring that Secrets</span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.685.1"> are managed, tracked, and protected end to end within their Kubernetes environments. </span><span class="koboSpan" id="kobo.685.2">This approach not only fortifies the organization’s security posture but also ensures that its Secrets management practices are aligned with industry best practices and </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">compliance standards.</span></span></p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.687.1">Auditing and monitoring on the server side</span></h2>
<p><span class="koboSpan" id="kobo.688.1">On the server side of Secrets</span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.689.1"> management, regular auditing</span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.690.1"> and robust monitoring play crucial roles in maintaining a secure and compliant Kubernetes environment. </span><span class="koboSpan" id="kobo.690.2">Auditing serves as a necessary practice for ensuring that all interactions with Secrets—be they accesses, modifications, or deletions—are meticulously recorded and reviewed. </span><span class="koboSpan" id="kobo.690.3">This practice is fundamental not just for maintaining the integrity of the Secrets themselves but also for verifying that all access patterns adhere to established security policies and compliance requirements. </span><span class="koboSpan" id="kobo.690.4">By implementing comprehensive auditing, organizations create a secure trail of evidence, facilitating accountability and transparency across all operations involving </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">sensitive information.</span></span></p>
<p><span class="koboSpan" id="kobo.692.1">To achieve this level of oversight, it is imperative to utilize both techniques and tools that are tailored for robust auditing and monitoring. </span><span class="koboSpan" id="kobo.692.2">This includes implementing solutions that can provide real-time alerts and detailed access logs, ensuring that any anomalous or unauthorized activities are promptly detected and addressed. </span><span class="koboSpan" id="kobo.692.3">Tools such as audit logs in Kubernetes, and monitoring solutions such as Prometheus or Grafana, can be configured to work seamlessly within the environment, providing teams with the visibility they need to safeguard</span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.693.1"> their Secrets. </span><span class="koboSpan" id="kobo.693.2">Additionally, integrating these tools with existing </span><strong class="bold"><span class="koboSpan" id="kobo.694.1">security information and event management</span></strong><span class="koboSpan" id="kobo.695.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.696.1">SIEM</span></strong><span class="koboSpan" id="kobo.697.1">) systems can further enhance the organization’s capability to correlate events, identify patterns, and respond to potential threats swiftly </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">and effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.699.1">The importance of consistent auditing for security and adherence to regulations, along with strategies and instruments to enhance thorough auditing, guarantees the proper monitoring of access and changes </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">to Secrets.</span></span></p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.701.1">Ensuring secure Secrets distribution</span></h2>
<p><span class="koboSpan" id="kobo.702.1">Ensuring the secure distribution of Secrets</span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.703.1"> within a Kubernetes environment is paramount, as insecure practices can lead to severe vulnerabilities and security breaches. </span><span class="koboSpan" id="kobo.703.2">When Secrets are distributed in plain text at rest, whether within the host’s filesystem or within a container’s environment, they become susceptible to unauthorized access and potential exploitation. </span><span class="koboSpan" id="kobo.703.3">This vulnerability is especially concerning if an attacker gains access to the host or container, as they could easily retrieve and misuse </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">these Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.705.1">Understanding and establishing clear security boundaries is critical in mitigating these risks. </span><span class="koboSpan" id="kobo.705.2">Organizations must take a proactive stance, implementing stringent controls and adopting a principle of least privilege to minimize the blast radius in the event of a security incident. </span><span class="koboSpan" id="kobo.705.3">This approach involves restricting access to Secrets, ensuring that only the necessary parties have access and that Secrets are not </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">unnecessarily exposed.</span></span></p>
<p><span class="koboSpan" id="kobo.707.1">Building a trust chain during the Secrets distribution process is essential in maintaining the integrity and confidentiality of the Secrets. </span><span class="koboSpan" id="kobo.707.2">This involves verifying the authenticity and integrity of the Secrets at every step of the distribution process, from the moment they are generated or retrieved from the Secrets store, through their transmission, and finally, to their consumption by the intended services or applications. </span><span class="koboSpan" id="kobo.707.3">Various measures can be implemented to ensure this trust chain, including the use of encryption during transit, secure injection methods for Secrets</span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.708.1"> delivery, and utilizing trusted platforms and identities for </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">access control.</span></span></p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.710.1">Decommissioning and revoking Secrets</span></h2>
<p><span class="koboSpan" id="kobo.711.1">Decommissioning and revoking Secrets</span><a id="_idIndexMarker864"/><span class="koboSpan" id="kobo.712.1"> are critical aspects</span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.713.1"> of Secrets lifecycle management, ensuring that outdated, compromised, or otherwise unnecessary Secrets are removed promptly and securely. </span><span class="koboSpan" id="kobo.713.2">Implementing best practices for decommissioning involves safely retiring Secrets and ensuring that they are purged from both the Secrets store and any environments where they may reside. </span><span class="koboSpan" id="kobo.713.3">This process must be thorough and systematic to prevent any potential security risks associated with </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">lingering Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.715.1">Integration of Secrets management into broader service decommission workflows is paramount. </span><span class="koboSpan" id="kobo.715.2">As services are retired or replaced, the associated Secrets should simultaneously undergo decommissioning. </span><span class="koboSpan" id="kobo.715.3">This ensures a cohesive and streamlined process, reducing the risk of oversight and potential security vulnerabilities. </span><span class="koboSpan" id="kobo.715.4">By embedding Secrets considerations directly into service decommissioning processes, organizations can enforce consistency and adherence to </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">security protocols.</span></span></p>
<p><span class="koboSpan" id="kobo.717.1">Revocation protocols play a critical role in both proactive and reactive Secrets management. </span><span class="koboSpan" id="kobo.717.2">Proactively, Secrets should be rotated and revoked according to predefined schedules or triggers, such as the expiration of a certificate or the end of a service’s lifecycle. </span><span class="koboSpan" id="kobo.717.3">Reactively, in the event of a security incident or discovery of a compromised secret, immediate revocation is necessary to mitigate risks and prevent unauthorized access. </span><span class="koboSpan" id="kobo.717.4">Establishing clear and efficient revocation protocols ensures that teams can respond swiftly, minimizing the potential impact of a </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">security breach.</span></span></p>
<p><span class="koboSpan" id="kobo.719.1">Together, these practices fortify the Secrets management lifecycle, ensuring that Secrets are not only generated and used securely but are also retired and revoked with equal diligence. </span><span class="koboSpan" id="kobo.719.2">This comprehensive approach enhances the overall security posture of the Kubernetes environment, safeguarding</span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.720.1"> sensitive information and maintaining</span><a id="_idIndexMarker867"/><span class="koboSpan" id="kobo.721.1"> the integrity of the </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">production system.</span></span></p>
<h2 id="_idParaDest-261"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.723.1">Responsibility, on-call support, penetration testing, and risk evaluation</span></h2>
<p><span class="koboSpan" id="kobo.724.1">The effective management of Secrets within a Kubernetes production environment necessitates a clear delineation of responsibilities, robust on-call support structures, and an ongoing commitment to security through penetration testing and </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">risk evaluation.</span></span></p>
<h3><span class="koboSpan" id="kobo.726.1">Responsibility and on-call support</span></h3>
<p><span class="koboSpan" id="kobo.727.1">The team managing the deployment</span><a id="_idIndexMarker868"/><span class="koboSpan" id="kobo.728.1"> platform must clearly</span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.729.1"> define and distribute the responsibilities associated with both Secrets distribution and Secrets store management. </span><span class="koboSpan" id="kobo.729.2">This encompasses not only the initial setup and distribution of Secrets but also their ongoing management, updates, and rotation. </span><span class="koboSpan" id="kobo.729.3">On-call responsibilities are a critical component of this, ensuring that there is always a knowledgeable and capable team member available to address any issues that may arise, ranging from access issues and misconfigurations to potential security incidents. </span><span class="koboSpan" id="kobo.729.4">These team members must be well versed in both the configuration and debugging of the Secrets management tools and the broader Kubernetes environment to effectively address and resolve incidents. </span><span class="koboSpan" id="kobo.729.5">Additionally, they should be actively involved in enhancement efforts, working to continuously improve the system’s stability, security, </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">and efficiency.</span></span></p>
<h3><span class="koboSpan" id="kobo.731.1">Penetration testing and risk evaluation</span></h3>
<p><span class="koboSpan" id="kobo.732.1">The regular penetration testing</span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.733.1"> of the production Secrets</span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.734.1"> store is paramount in identifying and mitigating potential security risks. </span><span class="koboSpan" id="kobo.734.2">This proactive approach to security helps in uncovering vulnerabilities, assessing the robustness of access policies, and evaluating potential paths through which Secrets could be exposed. </span><span class="koboSpan" id="kobo.734.3">The results of these penetration tests should feed directly into the organization’s broader risk evaluation efforts, helping to build a comprehensive understanding of the system’s security posture and guiding informed decisions around </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">risk mitigation.</span></span></p>
<p><span class="koboSpan" id="kobo.736.1">Penetration testing should not be a one-time effort but rather an ongoing practice, continuously evolving to address new threats and vulnerabilities as they emerge. </span><span class="koboSpan" id="kobo.736.2">It should cover various aspects of the Secrets management lifecycle, from the initial provisioning of Secrets, through their storage, distribution, and </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">eventual decommissioning.</span></span></p>
<p><span class="koboSpan" id="kobo.738.1">By integrating these practices into the organization’s overall risk evaluation framework, teams can ensure that they are not only addressing immediate threats but also building a resilient system capable of withstanding future challenges. </span><span class="koboSpan" id="kobo.738.2">This comprehensive approach to responsibility, on-call support, penetration testing, and risk evaluation forms a critical component of maintaining a secure and efficient Secrets management framework within Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">production environments.</span></span></p>
<h1 id="_idParaDest-262"><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.740.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.741.1">In this chapter, we delved into the intricacies of managing Kubernetes Secrets within production clusters. </span><span class="koboSpan" id="kobo.741.2">We highlighted the qualities necessary for effective Secrets management and examined various deployment strategies and their integration with CI/CD processes. </span><span class="koboSpan" id="kobo.741.3">Additionally, we explored a detailed case study on Keywhiz, which provided a thorough understanding of Secrets management development, emphasizing a holistic approach that covers the entire lifecycle of </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">Secrets management.</span></span></p>
<p><span class="koboSpan" id="kobo.743.1">The next chapter will offer a synthesis of the insights and knowledge we’ve gained throughout the book. </span><span class="koboSpan" id="kobo.743.2">It will also cast a forward-looking perspective on the evolution and future trends in Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">Secrets management.</span></span></p>
</div>
</body></html>