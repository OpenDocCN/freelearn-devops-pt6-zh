- en: '*Chapter 3*: Provisioning Kubernetes Clusters Using AWS and Terraform'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about Kubernetes clusters and infrastructure
    design and how to create a deployment architecture to fulfill best practices and
    standards. There are multiple alternatives when it comes to designing and building
    your Kubernetes platform. Choosing the solution that works for your use case and
    satisfies goals in terms of production readiness is not an easy task. There are
    still challenges and limitations for Kubernetes, the underlying technologies,
    and the surrounding ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will go through the detailed implementation of the infrastructure
    design. Basically, we will learn how to create the Kubernetes infrastructure declaratively
    with Terraform. While provisioning the infrastructure, we will learn about implementation
    best practices, such as the encapsulation of infrastructure components into reusable
    modules, separating Kubernetes clusters per environment without adding an operational
    overhead and complexity. In addition, you will practice rolling out your first
    Kubernetes cluster and group of clusters with simple Terraform commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation principles and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cluster deployment and rollout strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the network infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the cluster infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up and destroying infrastructure resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will need the Terraform tool installed for this chapter as a prerequisite.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this tool, you will need to have an AWS account and user credentials
    ready to use. Please ensure the authentication of the AWS CLI with your AWS credentials.
    You can refer to the AWS documentation for further instructions at [https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html).
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter is located at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter03](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/39Ocoyq](https://bit.ly/39Ocoyq)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terraform binary is a command-line utility that is used to develop **Infrastructure
    as Code** (**IaC**), plan, and execute it to create resources, and manage infrastructure
    providers such as AWS, Azure, GCP, Fastly, OKTA, and more.
  prefs: []
  type: TYPE_NORMAL
- en: You can follow the instructions in the official documentation to download the
    latest version of Terraform at [https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html).
  prefs: []
  type: TYPE_NORMAL
- en: After installing Terraform, you are ready to implement the hands-on exercises
    in the coming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation principles and best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B16192_01_Final_PG_ePub.xhtml#_idTextAnchor014), *Introduction
    to Kubernetes Infrastructure and Production-Readiness*, you learned about the
    12 infrastructure design principles that we will follow during the book. I would
    like to start this chapter by highlighting the principles that drove us to this
    implementation of the cluster infrastructure. The following are the three principles
    that influenced the implementation decisions in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infrastructure as code**: In this chapter, you will write every piece of
    infrastructure code declaratively. You will achieve this by using Terraform.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Go managed**: There are two fundamental ways in which to create a Kubernetes
    cluster – either to build and operate Kubernetes control plane and workers on
    your own (on-prem or on cloud), or to use one of the *managed* Kubernetes services
    in the cloud, such as **Google Kubernetes Engine** (**GKE**), **Azure Kubernetes
    Service** (**AKS**), and AWS **Elastic Kubernetes Service** (**EKS**). In this
    book, I will use EKS as this fulfills the *managed services* principle.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Standardization**: We applied this principle when we selected Terraform as
    our provisioning and IaC tool. Terraform is not the easiest way to bootstrap a
    Kubernetes cluster, and there are other tools that could be faster to use and
    easier to learn. However, we needed to standardize our infrastructure toolset
    around as few tools as possible. Therefore, Terraform makes sense because in most
    use cases, your production environment is not Kubernetes on its own. There are
    databases, caching services, content delivery, load balancers, and so on. These
    types of infrastructure components are easier to create and manage by Terraform.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cluster deployment and rollout strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored different infrastructure design alternatives,
    limitations, and corner cases. We made the architecture decisions that fulfill
    the infrastructure design principles for the production-grade Kubernetes clusters.
    And finally, we came up with a full deployment architecture for our Kubernetes
    infrastructure, which we will build and use over this book. Certainly, while we
    proceed from one chapter to the next, we will keep enhancing our infrastructure
    design and implementation, adding more features, and making it better.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of implementation, we should address how we will roll out the clusters
    and deploy them. Specifically, we are looking for extendibility, simplicity, and
    operational efficiency. We will follow these principles during the implementation
    in the next sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developing generic infrastructure modules**: By encapsulating every infrastructure
    resource in a reusable code module, this will enable us to automate cluster provisioning
    with minimum to zero code changes. It also promotes code reusability practices
    essential for simplifying the IaC and increases operational efficiency.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Supporting single and multiple clusters**: In real life, Kubernetes deployment
    teams require multiple clusters to serve the whole company or a specific product.
    In this chapter, we will follow a strategy that will enable us to create a group
    of clusters with the same infrastructure code and configuration. Also, we will
    create multiple groups of clusters with different configurations. This will help
    us to serve and automate the provisioning and operation of multiple production
    and non-production clusters. This implementation is scalable as we can provision
    many clusters (up to the limit of the underlying IaaS provider) without the need
    to scale your infrastructure teams.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Separating production and non-production environments with minimal changes**:
    One of the recommended practices is to have two separate AWS accounts for production
    and non-production environments, and our implementation also supports this model
    with minimum code changes and administration work.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Automating infrastructure deployment**: Every single piece of infrastructure
    is managed by Terraform, and with a limited number of commands, we can provision
    the entire Kubernetes cluster. We can build automated pipelines for infrastructure
    deployment and testing with traditional CI/CD such as Jenkins.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In fact, cluster deployment is not a one-time task. It is a continuous process
    that affects the cluster's quality, stability, operations, and, moreover, the
    products and services on top of it. So, we are keen to establish a solid infrastructure
    deployment strategy, which we will follow during implementation in this chapter
    and also keep improving throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before creating the Terraform configuration and code for the Kubernetes cluster,
    you need to create a new source code repository for the infrastructure and then
    create the Terraform directory structure. In addition to that, you will learn
    how to configure and use Terraform's shared state, which is an essential best
    practice for managing IaC in production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform directory structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Terraform directory is where all the Terraform source code lives in your
    source code repository. I recommend creating a separate source code repository.
    This repository should contain all the infrastructure code and configuration.
    The following is the directory structure of the Terraform source code that we
    will develop in the forthcoming sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Terraform directory structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16192_03_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Terraform directory structure
  prefs: []
  type: TYPE_NORMAL
- en: Persisting the Terraform state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terraform stores the state of the infrastructure resources under its management
    to be able to map it to the existing resources in the real world. By default,
    the state is stored to local files. However, this is not recommended for production-scale
    infrastructure where preserving consistent state and also sharing it among distributed
    team members are essential.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a recommended Terraform best practice, you should configure Terraform to
    keep the state remote and locked:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remote**: As you already use AWS as an infrastructure provider, you can utilize
    an S3 bucket to remotely store Terraform state files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Locked**: You can achieve Terraform state lock by using a DynamoDB table.
    Then, the Terraform state will get locked for the current user until this user
    finishes up, at which point other users can acquire the lock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Terraform state configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apply the following steps to create the Terraform directory structure and the
    directory for the shared state configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a root directory named `terraform`. This is the root directory for all
    Terraform source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a subdirectory named `shared-state`. This is the directory that will
    contain Terraform source code to provision both the S3 bucket and the DynamoDB
    table. Both of them are used to store the shared state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following steps, you will create the shared state Terraform code under
    the `shared-state` directory with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Shared state directory structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16192_03_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Shared state directory structure
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete source code of the shared state Terraform configuration
    at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter03/terraform/shared-state](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter03/terraform/shared-state).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the Terraform files under the `shared-state` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Terraform can create and manage infrastructure resources from both cloud and
    on-prem, and it can achieve this by communicating with the external infrastructure
    using a provider that is a kind of software plugin that translates Terraform commands
    into the APIs that the infrastructure provider can understand and execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `config.tf` file, you define the provider's configuration that you will
    use in this chapter. For each provider, you need to define its name and the version
    you intend to use. To learn more about defining a "required provider version,"
    visit https://www.terraform.io/docs/configuration/terraform.html#specifying-required-provider-versions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is important to define the version explicitly, especially when Terraform
    is used by multiple users or automation tools. This is to avoid the upgrades to
    newer versions that could break the Terraform state:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code block defines the AWS provider configuration. You only need to specify
    both the AWS region and the provider''s version:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `terraform.tfvars` file, you define the environment variables that Terraform
    needs to use during provisioning of the infrastructure resources. Using Terraform
    `tfvars` files is a good practice to pass environment variables to Terraform.
    This enables you to keep all of the configuration, including the environment variables,
    versioned in your source control as your source of truth:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use `us-east-1` as the default AWS region, but you can use any other region
    as long as you maintain it for the other exercises.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second environment variable is the *clusters name prefix*, which you will
    use for your clusters to identify them as a group of clusters. This name prefix
    could represent your company's name or the product name. However, you are free
    to use any appropriate naming convention.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `variables.tf` file, you define the input variables that Terraform code
    will use. There are two input variables that you will need for the exercises in
    this chapter. The first is the AWS region, and the second is the clusters name
    prefix. Both of them will get their values from the previous `terraform.tfvars`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `tf-state-s3.tf` file, you define two S3 bucket resources. The first
    bucket stores the state for the VPC and network resources, while the second bucket
    stores the state for the Kubernetes cluster resources, such as EKS and workers
    groups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following code snippet uses the Terraform resource called `aws_s3_bucket`,
    which is a built-in resource in the Terraform AWS provider that can be used to
    create AWS S3 buckets and set its configuration parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will use this S3 bucket to persist the Terraform state. And, as you will
    notice in the following code, this S3 bucket has private access to keep it secure
    from the public. It also has deletion prevention enabled to protect it from unplanned
    deletion:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second part of the code is similar to the previous one, but it is used
    to create the S3 bucket for the networking infrastructure or the **virtual private
    cloud** (**VPC**) resources state:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Splitting the infrastructure state into two files, as we did in the previous
    code, is debatable. However, we tend to use a balanced approach as we will not
    use a separate state for a resource unless it has an independent life cycle from
    the Kubernetes cluster. This separation facilitates change management of the resources
    and decouples the critical resources from one another.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `tf-state-dynamodb.tf` file, you create two DynamoDB tables, the first
    for VPC resource state locking, and the second for Kubernetes cluster resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following code snippet uses the Terraform resource called `aws_dynamodb_table`,
    which is a built-in resource in the Terraform AWS provider that is used to create
    an AWS DynamoDB table and set its configuration parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This code creates a DynamoDB table to hold the lock for the shared Terraform
    state for the Kubernetes cluster resources. This lock will protect parallel runs
    against the same state file or the same resources, and this prevents users from
    applying changes to infrastructure at the same time. This could be very dangerous,
    right?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second part of the `tf-state-dynamodb.tf` file creates a DynamoDB table
    to hold the locks for the shared Terraform state for the VPC resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you apply the previous Terraform code file, it will create two DynamoDB
    tables. In the coming sections, we will learn how to configure terraform to use
    them. Then, Terraform will be able to create locks for its shared state files.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning the Terraform state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After creating the previous Terraform code files for the shared state resources.
    You have to perform the following instructions to provision the resources in your
    AWS account:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the Terraform state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `terraform plan` command to validate the planned changes before applying
    them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will get the following output after the `terraform plan` command completes
    successfully. There are four resources to add – two S3 buckets and two DynamoDB
    tables:![Figure 3.3 – Terraform plan command output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16192_03_003.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.3 – Terraform plan command output
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the `terraform apply` command. Enter `yes` when you get a prompt to
    approve execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get the following output after the `terraform apply` command completes
    successfully. By then, Terraform has successfully created four AWS resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Terraform apply command output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16192_03_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Terraform apply command output
  prefs: []
  type: TYPE_NORMAL
- en: Now you have completed provisioning of the AWS resources to persist and manage
    the Terraform shared state. In the next section, you will learn how to provision
    the VPC and the other network resources to run your first Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing Terraform workspaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you learned that Terraform configuration has a backend
    that defines how operations are executed and where the infrastructure state is
    persisted, such as in S3 buckets. Terraform uses workspaces to organize and isolate
    multiple states under a single backend.
  prefs: []
  type: TYPE_NORMAL
- en: This concept becomes useful when the user wants to run multiple instances of
    the same infrastructure without creating multiple backends and state files. Let's
    assume that you want to use Terraform to provision a Kubernetes cluster, ClusterA,
    and you want to use the same configuration to provision a second cluster, ClusterB.
    In this case, workspaces provide an out-of-the-box and scalable solution, as you
    will be able to use a single backend for all of your clusters (*N* clusters),
    but you provision each cluster in its workspace with its own state file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a Terraform configuration with a backend named `k8s_s3_backend`,
    and you want to provision *N* Kubernetes clusters using the same Terraform base
    code, then you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, repeat the same process for every *N* cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Creating the network infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B16192_02_Final_PG_ePub.xhtml#_idTextAnchor051), *Architecting
    Production-Grade Kubernetes Infrastructure*, you learned in detail about the infrastructure
    architecture design recommendations and the technical decisions that you should
    take in relation to the production readiness state for your Kubernetes clusters.
    In this section, you will use Terraform to provision the network layer of your
    Kubernetes production infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the AWS network resources that you will provision with the Terraform
    code in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS VPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private subnets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public subnets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Route tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet and NAT gateways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulating AWS resources into reusable code modules is a recommended IaC
    practice. In the next subsection, you will create a VPC Terraform module that
    includes the previous AWS resources. You can then reuse this module with no code
    changes to provision VPCs for as many Kubernetes clusters as you need.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the VPC Terraform module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Under the `terraform` root directory, create a directory and name it `modules`.
    Then, create a subdirectory and name it `eks-vpc`. This subdirectory will contain
    the following Terraform code files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`variables.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outputs.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are the input variables that are accepted by this module. The module''s
    user should provide the values for each of these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`10.40.0.0/17`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` or another prefix such as `10.40.64.0/20`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` or another prefix such as `10.40.0.0/20`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster name prefix**: The value of the cluster name prefix that is used
    in naming the VPC resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common tags**: Any AWS tags that you want to assign to the VPC resources
    to help identify and classify them later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `variables.tf` file is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The previous code snippet defines five Terraform variable blocks and all of
    the type strings. In the *Creating the cluster VPC* section, you will use this
    VPC module and learn how to pass the values for each of these variables.
  prefs: []
  type: TYPE_NORMAL
- en: Module main resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `main.tf` file defines the network resources that are required to create
    Kubernetes AWS network components, including the public and private subnets, internet
    and NAT gateways, and routing tables.
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet uses the Terraform resource called `aws_vpc`, which
    is a built-in resource in the Terraform AWS provider that can be used to create
    AWS VPC and set its configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, you define the VPC resource, and a data resource
    that is used to retrieve the value of the AWS availability zones that you use
    in the `main.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The following code snippet uses the Terraform resource called `aws_subnet`,
    which is a built-in resource in the Terraform AWS provider that can be used to
    create AWS subnets and set their configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code uses the Terraform built-in `count` construct to create one or more
    subnets according to the number of private subnet prefixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the remaining part of the `main.tf` file, you define an `aws_subnet` resource,
    which is similar to the private subnet resource, but designed for public subnets.
    Also, you create complementary VPC network resources that handle the routing,
    connect the subnets together and with the internet, such as NAT and internet gateways,
    routing tables, and NAT IPs. You can find the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-vpc/main.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-vpc/main.tf).
  prefs: []
  type: TYPE_NORMAL
- en: Output values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `outputs.tf` file defines the output values from the `VPC` module. Terraform
    will need these values to use them as inputs to the Kubernetes cluster module
    when you provision it. There are four outputs from the `VPC` module: the VPC ID;
    the private subnet IDs; the public subnet IDs; and the NAT IPs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `outputs.tf` file is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet defines five Terraform output blocks. In the *Provisioning
    the cluster* section, you will use these outputs as inputs to the Kubernetes terraform
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the cluster VPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Under the `terraform` root directory, create a directory and name it `packtclusters-vpc`.
    This directory will contain the following Terraform code files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`config.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`terraform.tfvars`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variables.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outputs.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous list of Terraform files comprises your Kubernetes cluster VPC.
    You will learn about each code and configuration file in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`config.tf` has the Terraform shared state configuration and the AWS provider
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code block tells Terraform which S3 bucket to use to persist the
    state, and specifies Terraform and AWS provider versions.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `terraform.tfvars` file defines the values of the input variables. These
    values are required by the VPC module to set the values of these inputs: the AWS
    region; the VPC IP CIDR; the private subnet prefix list; and the public subnet
    prefix list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `terraform.tfvars` file is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For the preceding code, you can choose a different CIDR block for the VPC IPs
    range and different subnet prefixes according to your network topology and applications
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should make sure that the VPC CIDR is not used by any other VPCs within
    your own AWS VPC so as to avoid IPs collisions. You should make sure the VPC CIDR
    has a sufficient number of IPs that exceeds the maximum forecasted number of pods
    in your Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Input variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `variables.tf` file defines the five input variables that Terraform will
    use during creation of the VPC module resources. It is very similar to the previous
    `variables.tf` files. You can view its full source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters-vpc/variables.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters-vpc/variables.tf).
  prefs: []
  type: TYPE_NORMAL
- en: The cluster VPC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `main.tf` file has two code blocks: the `vpc` module block, which creates
    an instance of the `eks-vpc` module, and the `locals` code block, which defines
    `common_tags` to be assigned to VPC resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.tf` file is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to Terraform modules, this makes the previous code clean and simple,
    as it hides the complexity of creating the AWS VPC. In the next subsection, you
    will create the Terraform outputs that you will use while creating the cluster
    VPC.
  prefs: []
  type: TYPE_NORMAL
- en: Output values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `outputs.tf` file defines the output values that you need to get after creating
    the cluster VPC. These outputs are the VPC ID, the private subnet IDs, and the
    public subnet IDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `outputs.tf` file is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The outputs from the previous code block are used as the inputs to the Kubernetes
    cluster Terraform modules in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning the cluster VPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have completed development of the VPC Terraform files in the previous
    sections, you can now provision the VPC resources and create them in your AWS
    account:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the Terraform state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the `terraform plan` command to review the planned changes before applying
    them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the `terraform apply` command. Enter `yes` when you get a prompt to
    approve the execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get the following output once the `terraform apply` command completes
    successfully, and by then, Terraform has successfully created 28 network resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – The terraform apply command output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16192_03_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – The terraform apply command output
  prefs: []
  type: TYPE_NORMAL
- en: By completing this section, you should have your Kubernetes cluster VPC and
    its network components successfully created in your AWS account. It is now ready
    to provision the cluster above it, as you will learn in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the cluster infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will develop the following Terraform modules:'
  prefs: []
  type: TYPE_NORMAL
- en: An EKS module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Kubernetes worker module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Kubernetes cluster module that wraps both the EKS control plan and the workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, you will use these modules to Terraform your first cluster, `Packt
    cluster`, and then provision it in your AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the EKS Terraform module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Under the `terraform/modules` directory, create a subdirectory with the name
    `eks-cp`. This directory will contain the following Terraform source code files
    for the EKS control plane module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`variables.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`security-groups.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iam.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outputs.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous list of files together comprises the EKS Terraform module. You
    will learn about each of these code and configuration files in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Input variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `variables.tf` file defines the input variables that are accepted in the
    EKS module. The module user should provide the values for each of these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Full cluster name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cluster Kubernetes version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VPC ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private subnet IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public subnet IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This file is similar to the `variables.tf` file you created in the VPC module.
    You can view its full source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-cp/variables.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-cp/variables.tf).
  prefs: []
  type: TYPE_NORMAL
- en: Module main resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `main.tf` file defines the EKS resources that are required to configure
    and create it. These include the cluster name, version, and cluster IAM role ARN.
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet uses the Terraform resource called `aws_eks_cluster`,
    which is a built-in resource in the Terraform AWS provider that can be used to
    create an AWS EKS cluster and set its configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.tf` file is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, you will notice that the EKS resource references the values
    of the EKS IAM role and the EKS security group. Both of these are created in the
    EKS module, but in two separate Terraform files for better code clarity and organization.
    You will learn about creating EKS security groups and IAM roles in the following
    subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Security groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following code snippet uses the Terraform resource called `aws_security_group`,
    which is a built-in resource in the Terraform AWS provider that can be used to
    create an AWS security group and set its configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `security-groups.tf` file defines a single security group for
    the EKS control plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you notice, the previous security group does not have ingress/egress rules.
    These rules will be defined in the cluster workers module.
  prefs: []
  type: TYPE_NORMAL
- en: IAM roles and policies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `iam.tf` file uses the Terraform resource called `aws_iam_role`, which is
    a built-in resource in the Terraform AWS provider that can be used to create an
    AWS IAM role and set its configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are specific policies that the EKS cluster must acquire in order to operate
    properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AmazonEKSClusterPolicy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AmazonEKSServicePolicy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These policies must be attached to the EKS cluster IAM role that we will create
    in the next code snippet. To learn more about these policies, you can check the
    EKS official documentation at [https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html](https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `iam.tf` file defines an IAM role and associates two policies
    with this role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The two IAM policies in question are `AmazonEKSClusterPolicy` and `AmazonEKSServicePolicy`.
    Both of them are AWS-predefined IAM policies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You need to attach the IAM role defined in the previous code to the EKS cluster
    to enable it to operate within the AWS environment. In the next and final subsection,
    you will define the EKS module outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Output values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `outputs.tf` file defines the output values from the EKS module. There
    are three outputs: the security group ID; the cluster **certificate authority**
    (**CA**); and the cluster API server endpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `outputs.tf` file is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this section, you learned to develop a Terraform module for the EKS. You
    will use it with other modules to compose your cluster infrastructure. In the
    next section, you will learn to develop a Terraform module for the cluster workers.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the workers' Terraform module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Under the `terraform/modules` directory, create a subdirectory and name it
    `eks-workers`. This directory will contain the following Terraform code files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`variables.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`security-groups.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iam.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user-data.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`authconfig.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outputs.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AWS recently introduced the managed EKS node group, which is an EKS service
    to manage workers on your behalf. This is a new service and it lacks important
    features, such as the ability to provide custom user data, which is essential
    when it comes to optimizing workers' performance and `kubelet` arguments. This
    is the reason why the preference is to keep using the self-managed workers until
    AWS implements this feature.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Input variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `variables.tf` file defines the input variables that are required by this
    module. There are multiple inputs for the workers' module, such as the worker
    AMI ID, EC2 instance type, user data, and instance storage size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `variables.tf` file is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: AWS periodically releases optimized AMIs for EKS workers. To choose one of them,
    please check the EKS documentation at [https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html](https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html).
  prefs: []
  type: TYPE_NORMAL
- en: You still can build your own AMI for EKS workers, and you can make use of the
    EKS AMI open source project at [https://github.com/awslabs/amazon-eks-ami](https://github.com/awslabs/amazon-eks-ami).
  prefs: []
  type: TYPE_NORMAL
- en: Please view the remainder of the variables and the full source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-workers/variables.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-workers/variables.tf).
  prefs: []
  type: TYPE_NORMAL
- en: Module main resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `main.tf` file defines the workers'' resources and their properties. This
    module contains two AWS resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Autoscaling group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launch template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The autoscaling group uses the launch template to add worker instances according
    to the launch specs.
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet uses the Terraform resource called `aws_autoscaling_group`,
    which is a built-in resource in the Terraform AWS provider that can be used to
    create an AWS autoscaling group and set its configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.tf` file is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Please view the rest of the `main.tf` source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-workers/main.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-workers/main.tf).
  prefs: []
  type: TYPE_NORMAL
- en: Security groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `security-groups.tf` file defines the workers' security group and the ingress/egress
    rules that control the flow of traffic between workers, and between the control
    plane and the workers.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to [*Chapter 2*](B16192_02_Final_PG_ePub.xhtml#_idTextAnchor051),
    *Architecting Production-Grade Kubernetes Infrastructure*, for more details about
    the security group ingress/egress rules and the permitted ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `security-groups.tf` file is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can view the full source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-workers/security-groups.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-workers/security-groups.tf).
  prefs: []
  type: TYPE_NORMAL
- en: IAM role and policies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following `iam.tf` file defines an IAM role and associates two policies
    with this role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The IAM policies are `AmazonEKSWorkerNodePolicy`, `AmazonEKS_CNI_Policy`, `AmazonEC2ContainerRegistryReadOnly`,
    and `CloudWatchAgentServerPolicy`. All of them are standard predefined IAM policies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You need to attach the IAM role defined in the previous code to the workers
    in order to enable them to operate within the AWS environment.
  prefs: []
  type: TYPE_NORMAL
- en: User data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `user-data.tf` file defines the user data script that is executed while
    the worker instance is booting up.
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet uses a special Terraform code block called `locals`,
    which is used to define a set of key/value configurations. In our solution, we
    use it to construct the worker user data script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `user-data.tf` file is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Later in the book, we will update the previous code to bootstrap `kubelet` with
    optimized arguments for worker performance tuning.
  prefs: []
  type: TYPE_NORMAL
- en: Worker authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes requires workers to be authenticated in order to be able to join
    the cluster and communicate with `kube-api-server`. EKS provides its own solution
    to perform this type of authentication, as it requires the cluster admin to create
    a ConfigMap that contains the workers' IAM role ARN and map it to the Kubernetes
    system node group. By doing that, workers can join the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: To automate this, the `authconfig.tf` file defines the content of the `authconfig`
    YAML file, which you will use to register and authenticate the workers with the
    EKS control plane.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that `authconfig` can be applied separately to the cluster
    using `kubectl`. However, I recommend that you apply it using Terraform to register
    the nodes immediately after EKS is provisioned, and then you can apply it again
    later as part of Kubernetes configuration management, and add more users and groups
    to `authconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `authconfig.tf` file is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In [*Chapter 4*](B16192_04_Final_PG_ePub.xhtml#_idTextAnchor100), *Managing
    Cluster Configuration with Ansible*, we will learn how to extend `aws-auth` to
    authenticate other users with the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Output values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `outputs.tf` file defines the output values from the `Workers` module, such
    as the worker's instance profile ARN, the IAM role ARN, and other outputs. Please
    view the full source code of `outputs.tf` at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-workers/outputs.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-workers/outputs.tf).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned to develop a Terraform module for the cluster workers.
    You will use this with other modules to compose your cluster infrastructure. In
    the next section, you will learn to develop a Terraform module that wraps both
    EKS and workers in a single module that represents the whole Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Kubernetes cluster Terraform module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Under the `terraform/modules` directory, create a subdirectory and name it
    `cluster`. This directory will contain the following Terraform code files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`config.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`terraform.tfvars`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variables.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outputs.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This `cluster` module is a wrapper above both the EKS module and the workers'
    module. You will notice that the inputs and outputs to/from this module are a
    combination of both EKS and worker modules.
  prefs: []
  type: TYPE_NORMAL
- en: Input variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `variables.tf` file defines the input variables that are needed by this
    module. These inputs are a combination of both EKS and worker modules. Please
    view the source code with a full list of variables at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/cluster/variables.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/cluster/variables.tf).
  prefs: []
  type: TYPE_NORMAL
- en: EKS control plane
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `eks-cp.tf` file defines an instance of the EKS module. It is defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The previous code block creates the EKS control plane by creating an instance
    from the EKS module and passing to it the required inputs.
  prefs: []
  type: TYPE_NORMAL
- en: EKS workers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `workers.tf` file defines an instance of the `workers` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The previous code block creates the cluster workers by creating an instance
    from the `workers` module and passing it to the required inputs. Both of the previous
    code files comprise the full Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Output values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `outputs.tf` file contains the output values from the `cluster` module,
    such as the cluster's full name, the cluster endpoint, `authconfig`, and others.
    Please view the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/cluster/outputs.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/cluster/outputs.tf).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned to develop a Terraform module that wraps both EKS
    and workers in a single module that is used to provision the whole Kubernetes
    cluster. In the next section, you will use the previous modules to develop your
    first cluster – the Packt cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Putting all modules together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it is time to bring all the modules together by creating your first cluster
    group, `packtclusters`, and a first cluster, `prod1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the root `terraform` directory, create a subdirectory and name it `packtclusters`.
    Then, under this, create the following Terraform code files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`config.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`terraform.tfvars`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variables.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outputs.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following subsections, you will create the code files in the previous
    list and learn all the details about them.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `config.tf` file contains the Terraform shared state configuration and the
    AWS provider definition. This file is similar to the `config.tf` file you created
    in the *Developing the cluster VPC* section. Please view the complete source code
    at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters/config.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters/config.tf).
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `terraform.tfvars` file defines the input values that are passed to the
    `cluster` module. Some of these values are outputs from the VPC module. To retrieve
    these outputs, you have to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, copy the following output values:'
  prefs: []
  type: TYPE_NORMAL
- en: VPC ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private subnet IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public subnet IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, paste these values into the `terraform.tfvars` file into their corresponding
    placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `terraform.tfvars` file is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Some of the preceding values can be tuned according to your infrastructure requirements,
    specifically, the instance type and the worker instance count min/max limits.
  prefs: []
  type: TYPE_NORMAL
- en: For educational purposes, you can use the existing values in the previous code
    block. However, when you decide to move your cluster to production, please refer
    to the workers' sizing section in [*Chapter 2*](B16192_02_Final_PG_ePub.xhtml#_idTextAnchor051),
    *Architecting Production-Grade Kubernetes Infrastructure*.
  prefs: []
  type: TYPE_NORMAL
- en: Input variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `variables.tf` file defines inputs that Terraform will use while creating
    the `packtclusters-prod1` cluster. You can view the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters/variables.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters/variables.tf).
  prefs: []
  type: TYPE_NORMAL
- en: The cluster main resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `main.tf` file defines the cluster module. It takes the input variables
    required to configure EKS and the workers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.tf` file is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code block, the `cluster_full_name` input is constructed by
    concatenating `cluster_name_prefix`, which is `packtclusters`, and the Terraform
    workspace name, `prod1`. And this is how you can create multiple clusters under
    one cluster group such as `packtclusters`. All you need is to create a new Terraform
    workspace and execute your `terraform plan`.
  prefs: []
  type: TYPE_NORMAL
- en: Output values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `outputs.tf` file defines the outputs from `packtclusters`, primarily `authconfig`,
    which is used to authenticate the workers with the control plane. You can view
    the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters/outputs.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters/outputs.tf).
  prefs: []
  type: TYPE_NORMAL
- en: By completing this section, you have a complete Terraform code base that is
    capable of creating full Kubernetes clusters. In the next section, you will learn
    the Terraform commands to use this code base to provision your first production
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning the cluster infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After you have completed developing the cluster Terraform modules in the previous
    sections, you can now provision your first Kubernetes cluster and create it in
    your AWS account:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the Terraform state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new Terraform workspace for the first cluster and name it `prod1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the `terraform plan` command to review the planned changes before applying
    them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the `terraform plan` command output that you should get:![Figure 3.7
    – Terraform plan command output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16192_03_007.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.7 – Terraform plan command output
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the `terraform apply` command. Enter `yes` when you get a prompt to
    approve the plan execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will get the following output after the `terraform apply` command completes
    successfully. This means that Terraform has successfully created 22 resources:![Figure
    3.8 – Terraform apply command output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16192_03_008.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.8 – Terraform apply command output
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Retrieve the cluster `kubeconfig` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply `authconfig` to authenticate the workers'' nodes with the EKS control
    plane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure that the cluster worker nodes are up and in the ready state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After completing the previous instructions, you have a Kubernetes cluster up
    and running, but it is still not ready to deploy production workloads. In the
    next chapters, you will deploy more services to the cluster, and optimize their
    configurations to make it capable of running your production workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up and destroying infrastructure resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After completing the hands-on exercises in this chapter, you can follow the
    instructions in this section to destroy the Kubernetes cluster and its AWS resources.
  prefs: []
  type: TYPE_NORMAL
- en: You will destroy the resources in reverse order from their creation. First,
    you will destroy the Kubernetes cluster resources, then the VPC resources, and
    finally the shared state resources.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying the cluster resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these Terraform commands to destroy all of the `packtclusters` resources
    that you created in the previous sections of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the Terraform state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the `terraform destroy` command. Enter `yes` when you get a prompt
    to approve the destruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get the following output once the `terraform destroy` command completes
    successfully. This means that Terraform has successfully destroyed the 22 resources
    in the cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.9 – The terraform destroy command output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16192_03_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – The terraform destroy command output
  prefs: []
  type: TYPE_NORMAL
- en: Having observed the previous instructions, `packtclusters-prod1` is completely
    destroyed. In the next subsection, you will destroy the VPC resources.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying the VPC resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these Terraform commands to destroy all of the `packtclusters-vpc` resources
    that you created in the previous sections of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the Terraform state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the `terraform destroy` command. Enter `yes` when you get a prompt
    to approve the destruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get the following output after the `terraform destroy` command completes
    successfully. This means that Terraform has successfully destroyed 28 network
    resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.10 – The terraform destroy command output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16192_03_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – The terraform destroy command output
  prefs: []
  type: TYPE_NORMAL
- en: Having observed the previous instructions, `packtclusters-vpc` is completely
    destroyed. In the next subsection, you will destroy the shared state resources.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying the shared state resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, you do not have to delete the shared state files. However, for educational
    purposes, you can follow these instructions to destroy these resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the shared state S3 buckets have destroy prevention and versioning enabled,
    you should empty and then destroy Terraform shared state S3 buckets first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the Terraform state to destroy the shared state DynamoDB tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the `terraform destroy` command. Enter `yes` when you get a prompt
    to approve the destruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get the following output after the `terraform destroy` command completes
    successfully. By then, Terraform has successfully destroyed both of the DynamoDB
    tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.11 – The terraform destroy command output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16192_03_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – The terraform destroy command output
  prefs: []
  type: TYPE_NORMAL
- en: By now, you have successfully finished destroying your Kubernetes cluster and
    all of its AWS resources in your AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend practicing these instructions and repeating them to provision and
    destroy the cluster, and to create multiple clusters by adding new Terraform workspaces,
    such as prod2 and prod3.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned to develop the infrastructure code for Kubernetes
    clusters using Terraform and AWS. You went through practical steps to implement
    this code. We started by creating the network components, followed by the cluster's
    components, using AWS VPC, EKS, autoscaling groups, and other AWS services.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduced you to Terraform practical development and its usage
    in relation to production infrastructure provisioning. It showed you how to follow
    the best practices of the declarative IaC, and also the best practices of decomposing
    your IaC into modules and combining them to create Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: All of this establishes a foundation for the forthcoming chapters, where we
    will build on the knowledge introduced here to take the Kubernetes cluster to
    the next level of its production-readiness journey.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn in detail about Kubernetes cluster configuration
    management. You will develop a dynamic templating solution that you can apply
    to the cluster-level configurations, and you will learn how to make your solution
    scalable to many clusters without introducing operational overheads and complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following books:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Getting Started with Terraform – Second Edition*: [https://www.packtpub.com/networking-and-servers/getting-started-terraform-second-edition](https://www.packtpub.com/networking-and-servers/getting-started-terraform-second-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Infrastructure Automation with Terraform on AWS*: [https://www.packtpub.com/big-data-and-business-intelligence/hands-infrastructure-automation-terraform-aws-video](https://www.packtpub.com/big-data-and-business-intelligence/hands-infrastructure-automation-terraform-aws-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
