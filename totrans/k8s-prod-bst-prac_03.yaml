- en: '*Chapter 3*: Provisioning Kubernetes Clusters Using AWS and Terraform'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*：使用 AWS 和 Terraform 配置 Kubernetes 集群'
- en: In the previous chapter, we learned about Kubernetes clusters and infrastructure
    design and how to create a deployment architecture to fulfill best practices and
    standards. There are multiple alternatives when it comes to designing and building
    your Kubernetes platform. Choosing the solution that works for your use case and
    satisfies goals in terms of production readiness is not an easy task. There are
    still challenges and limitations for Kubernetes, the underlying technologies,
    and the surrounding ecosystem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了 Kubernetes 集群和基础设施设计，以及如何创建一个部署架构来实现最佳实践和标准。在设计和构建 Kubernetes 平台时有多种选择。选择一个适合你用例并满足生产就绪目标的解决方案并不是一件容易的事。Kubernetes、其底层技术以及周围的生态系统仍然面临着挑战和局限性。
- en: In this chapter, we will go through the detailed implementation of the infrastructure
    design. Basically, we will learn how to create the Kubernetes infrastructure declaratively
    with Terraform. While provisioning the infrastructure, we will learn about implementation
    best practices, such as the encapsulation of infrastructure components into reusable
    modules, separating Kubernetes clusters per environment without adding an operational
    overhead and complexity. In addition, you will practice rolling out your first
    Kubernetes cluster and group of clusters with simple Terraform commands.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细讲解基础设施设计的实现过程。基本上，我们将学习如何使用 Terraform 声明性地创建 Kubernetes 基础设施。在配置基础设施的过程中，我们将学习一些实现最佳实践，例如将基础设施组件封装成可重用的模块、在不增加运维开销和复杂度的情况下按环境分离
    Kubernetes 集群。此外，你还将通过简单的 Terraform 命令，实践如何部署第一个 Kubernetes 集群及集群组。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Implementation principles and best practices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现原则和最佳实践
- en: Cluster deployment and rollout strategy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群部署和发布策略
- en: Preparing Terraform
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备 Terraform
- en: Creating the network infrastructure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建网络基础设施
- en: Creating the cluster infrastructure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建集群基础设施
- en: Cleaning up and destroying infrastructure resources
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理并销毁基础设施资源
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will need the Terraform tool installed for this chapter as a prerequisite.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要提前安装 Terraform 工具。
- en: In addition to this tool, you will need to have an AWS account and user credentials
    ready to use. Please ensure the authentication of the AWS CLI with your AWS credentials.
    You can refer to the AWS documentation for further instructions at [https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个工具，你还需要准备好 AWS 账户和用户凭证。请确保 AWS CLI 已用你的 AWS 凭证进行了身份验证。你可以参考 AWS 文档获取更多说明，网址为[https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html)。
- en: The code for this chapter is located at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter03](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter03).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码位于[https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter03](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter03)。
- en: 'Check out the following link to see the Code in Action video:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问以下链接查看《代码实践》视频：
- en: '[https://bit.ly/39Ocoyq](https://bit.ly/39Ocoyq)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/39Ocoyq](https://bit.ly/39Ocoyq)'
- en: Installing Terraform
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Terraform
- en: Terraform binary is a command-line utility that is used to develop **Infrastructure
    as Code** (**IaC**), plan, and execute it to create resources, and manage infrastructure
    providers such as AWS, Azure, GCP, Fastly, OKTA, and more.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 二进制文件是一个命令行工具，用于开发**基础设施即代码**（**IaC**），并规划和执行资源的创建，管理基础设施提供商，如 AWS、Azure、GCP、Fastly、OKTA
    等。
- en: You can follow the instructions in the official documentation to download the
    latest version of Terraform at [https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据官方文档的说明，在[https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)下载最新版本的
    Terraform。
- en: After installing Terraform, you are ready to implement the hands-on exercises
    in the coming sections.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 Terraform 后，你就可以开始进行接下来的实践操作。
- en: Implementation principles and best practices
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现原则和最佳实践
- en: 'In [*Chapter 1*](B16192_01_Final_PG_ePub.xhtml#_idTextAnchor014), *Introduction
    to Kubernetes Infrastructure and Production-Readiness*, you learned about the
    12 infrastructure design principles that we will follow during the book. I would
    like to start this chapter by highlighting the principles that drove us to this
    implementation of the cluster infrastructure. The following are the three principles
    that influenced the implementation decisions in this chapter:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 1 章*](B16192_01_Final_PG_ePub.xhtml#_idTextAnchor014)，*Kubernetes 基础设施与生产就绪性简介*
    中，你了解了本书中我们将遵循的 12 条基础设施设计原则。我想通过强调推动我们实施集群基础设施的原则来开始本章。以下是影响本章实现决策的三个原则：
- en: '**Infrastructure as code**: In this chapter, you will write every piece of
    infrastructure code declaratively. You will achieve this by using Terraform.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基础设施即代码**：在本章中，你将以声明方式编写每一段基础设施代码。你将通过使用 Terraform 来实现这一目标。'
- en: '**Go managed**: There are two fundamental ways in which to create a Kubernetes
    cluster – either to build and operate Kubernetes control plane and workers on
    your own (on-prem or on cloud), or to use one of the *managed* Kubernetes services
    in the cloud, such as **Google Kubernetes Engine** (**GKE**), **Azure Kubernetes
    Service** (**AKS**), and AWS **Elastic Kubernetes Service** (**EKS**). In this
    book, I will use EKS as this fulfills the *managed services* principle.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Go 管理**：创建 Kubernetes 集群有两种基本方式——要么自己构建并操作 Kubernetes 控制平面和工作节点（在本地或云上），要么使用云中的
    *托管* Kubernetes 服务，如 **Google Kubernetes Engine** (**GKE**)、**Azure Kubernetes
    Service** (**AKS**) 和 AWS **Elastic Kubernetes Service** (**EKS**)。在本书中，我将使用 EKS，因为它符合
    *托管服务* 原则。'
- en: '**Standardization**: We applied this principle when we selected Terraform as
    our provisioning and IaC tool. Terraform is not the easiest way to bootstrap a
    Kubernetes cluster, and there are other tools that could be faster to use and
    easier to learn. However, we needed to standardize our infrastructure toolset
    around as few tools as possible. Therefore, Terraform makes sense because in most
    use cases, your production environment is not Kubernetes on its own. There are
    databases, caching services, content delivery, load balancers, and so on. These
    types of infrastructure components are easier to create and manage by Terraform.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**标准化**：当我们选择 Terraform 作为我们的配置和基础设施即代码（IaC）工具时，我们应用了这一原则。Terraform 并不是启动 Kubernetes
    集群的最简单方式，且有其他工具可能更快速且易于学习。然而，我们需要将我们的基础设施工具集标准化，尽量使用更少的工具。因此，Terraform 是合适的选择，因为在大多数使用场景中，你的生产环境并不仅仅是
    Kubernetes。还有数据库、缓存服务、内容分发、负载均衡等。这些类型的基础设施组件更容易通过 Terraform 创建和管理。'
- en: Cluster deployment and rollout strategy
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群部署和推广策略
- en: In the previous chapter, we explored different infrastructure design alternatives,
    limitations, and corner cases. We made the architecture decisions that fulfill
    the infrastructure design principles for the production-grade Kubernetes clusters.
    And finally, we came up with a full deployment architecture for our Kubernetes
    infrastructure, which we will build and use over this book. Certainly, while we
    proceed from one chapter to the next, we will keep enhancing our infrastructure
    design and implementation, adding more features, and making it better.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们探讨了不同的基础设施设计备选方案、限制和边角情况。我们做出了满足生产级 Kubernetes 集群基础设施设计原则的架构决策。最后，我们提出了一个完整的
    Kubernetes 基础设施部署架构，我们将在本书中构建并使用。当然，在从一章过渡到下一章的过程中，我们将不断完善我们的基础设施设计和实现，增加更多功能，使其更好。
- en: 'In terms of implementation, we should address how we will roll out the clusters
    and deploy them. Specifically, we are looking for extendibility, simplicity, and
    operational efficiency. We will follow these principles during the implementation
    in the next sections:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现方面，我们应该解决如何部署集群并进行推广的问题。具体来说，我们追求的是可扩展性、简洁性和操作效率。在接下来的章节中，我们将遵循这些原则：
- en: '**Developing generic infrastructure modules**: By encapsulating every infrastructure
    resource in a reusable code module, this will enable us to automate cluster provisioning
    with minimum to zero code changes. It also promotes code reusability practices
    essential for simplifying the IaC and increases operational efficiency.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开发通用基础设施模块**：通过将每个基础设施资源封装到可重用的代码模块中，这将使我们能够通过最小或零代码更改来自动化集群的配置。这也促进了代码重用的实践，这对于简化基础设施即代码（IaC）至关重要，并提高了操作效率。'
- en: '**Supporting single and multiple clusters**: In real life, Kubernetes deployment
    teams require multiple clusters to serve the whole company or a specific product.
    In this chapter, we will follow a strategy that will enable us to create a group
    of clusters with the same infrastructure code and configuration. Also, we will
    create multiple groups of clusters with different configurations. This will help
    us to serve and automate the provisioning and operation of multiple production
    and non-production clusters. This implementation is scalable as we can provision
    many clusters (up to the limit of the underlying IaaS provider) without the need
    to scale your infrastructure teams.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**支持单集群和多集群**：在实际应用中，Kubernetes 部署团队需要多个集群来为整个公司或特定产品提供服务。在本章中，我们将采取一种策略，使用相同的基础设施代码和配置创建一组集群。此外，我们还将创建多个不同配置的集群组。这将帮助我们为多个生产和非生产集群提供服务，并自动化其配置和操作。该实现具有可扩展性，因为我们可以根据底层
    IaaS 提供商的限制来配置多个集群，而无需扩展基础设施团队。'
- en: '**Separating production and non-production environments with minimal changes**:
    One of the recommended practices is to have two separate AWS accounts for production
    and non-production environments, and our implementation also supports this model
    with minimum code changes and administration work.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过最小化更改分离生产环境和非生产环境**：推荐的做法之一是为生产环境和非生产环境分别使用两个 AWS 账户，我们的实现也支持这种模型，且仅需最小的代码更改和管理工作。'
- en: '**Automating infrastructure deployment**: Every single piece of infrastructure
    is managed by Terraform, and with a limited number of commands, we can provision
    the entire Kubernetes cluster. We can build automated pipelines for infrastructure
    deployment and testing with traditional CI/CD such as Jenkins.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自动化基础设施部署**：每一块基础设施都由 Terraform 管理，通过少量的命令，我们就可以配置整个 Kubernetes 集群。我们可以使用传统的
    CI/CD 工具（如 Jenkins）来构建自动化的基础设施部署和测试流水线。'
- en: In fact, cluster deployment is not a one-time task. It is a continuous process
    that affects the cluster's quality, stability, operations, and, moreover, the
    products and services on top of it. So, we are keen to establish a solid infrastructure
    deployment strategy, which we will follow during implementation in this chapter
    and also keep improving throughout the book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，集群部署并非一次性任务。它是一个持续的过程，影响集群的质量、稳定性和运营，此外，还会影响其上运行的产品和服务。因此，我们希望建立一个稳固的基础设施部署策略，我们将在本章的实现过程中遵循这一策略，并在全书中持续改进。
- en: Preparing Terraform
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备 Terraform
- en: Before creating the Terraform configuration and code for the Kubernetes cluster,
    you need to create a new source code repository for the infrastructure and then
    create the Terraform directory structure. In addition to that, you will learn
    how to configure and use Terraform's shared state, which is an essential best
    practice for managing IaC in production environments.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Kubernetes 集群的 Terraform 配置和代码之前，你需要为基础设施创建一个新的源代码仓库，并创建 Terraform 目录结构。此外，你还将学习如何配置和使用
    Terraform 的共享状态，这是在生产环境中管理基础设施即代码（IaC）的一个关键最佳实践。
- en: Terraform directory structure
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform 目录结构
- en: 'The Terraform directory is where all the Terraform source code lives in your
    source code repository. I recommend creating a separate source code repository.
    This repository should contain all the infrastructure code and configuration.
    The following is the directory structure of the Terraform source code that we
    will develop in the forthcoming sections:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 目录是你在源代码仓库中存放所有 Terraform 源代码的地方。我建议创建一个独立的源代码仓库，该仓库应包含所有基础设施代码和配置。以下是我们将在接下来的章节中开发的
    Terraform 源代码目录结构：
- en: '![Figure 3.1 – Terraform directory structure'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – Terraform 目录结构'
- en: '](img/B16192_03_001.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16192_03_001.jpg)'
- en: Figure 3.1 – Terraform directory structure
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – Terraform 目录结构
- en: Persisting the Terraform state
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化 Terraform 状态
- en: Terraform stores the state of the infrastructure resources under its management
    to be able to map it to the existing resources in the real world. By default,
    the state is stored to local files. However, this is not recommended for production-scale
    infrastructure where preserving consistent state and also sharing it among distributed
    team members are essential.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 会保存其管理下的基础设施资源的状态，以便能够将其映射到实际世界中的现有资源。默认情况下，状态存储在本地文件中。然而，这不推荐用于生产规模的基础设施，因为在这种情况下，保持一致的状态以及在分布式团队成员之间共享状态是至关重要的。
- en: 'As a recommended Terraform best practice, you should configure Terraform to
    keep the state remote and locked:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 作为推荐的 Terraform 最佳实践，你应该配置 Terraform 使其保持远程状态并加锁：
- en: '**Remote**: As you already use AWS as an infrastructure provider, you can utilize
    an S3 bucket to remotely store Terraform state files.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程**：由于你已经使用 AWS 作为基础设施提供商，你可以利用 S3 存储桶远程存储 Terraform 状态文件。'
- en: '**Locked**: You can achieve Terraform state lock by using a DynamoDB table.
    Then, the Terraform state will get locked for the current user until this user
    finishes up, at which point other users can acquire the lock.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锁定**：你可以通过使用 DynamoDB 表来实现 Terraform 状态锁定。然后，Terraform 状态将在当前用户操作完成之前锁定，直到此用户完成操作，其他用户才能获得锁定。'
- en: Creating Terraform state configuration
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Terraform 状态配置
- en: 'Apply the following steps to create the Terraform directory structure and the
    directory for the shared state configuration:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建 Terraform 目录结构以及共享状态配置的目录：
- en: Create a root directory named `terraform`. This is the root directory for all
    Terraform source code.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `terraform` 的根目录。这是所有 Terraform 源代码的根目录。
- en: Create a subdirectory named `shared-state`. This is the directory that will
    contain Terraform source code to provision both the S3 bucket and the DynamoDB
    table. Both of them are used to store the shared state.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `shared-state` 的子目录。这个目录将包含用于配置 S3 存储桶和 DynamoDB 表的 Terraform 源代码。这两个资源都用于存储共享状态。
- en: 'In the following steps, you will create the shared state Terraform code under
    the `shared-state` directory with the following structure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，你将在 `shared-state` 目录下创建共享状态的 Terraform 代码，目录结构如下：
- en: '![Figure 3.2 – Shared state directory structure'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – 共享状态目录结构'
- en: '](img/B16192_03_002.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16192_03_002.jpg)'
- en: Figure 3.2 – Shared state directory structure
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 共享状态目录结构
- en: Important note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: You can find the complete source code of the shared state Terraform configuration
    at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter03/terraform/shared-state](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter03/terraform/shared-state).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter03/terraform/shared-state](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter03/terraform/shared-state)
    找到共享状态 Terraform 配置的完整源代码。
- en: 'Now, let''s create the Terraform files under the `shared-state` directory:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `shared-state` 目录下创建 Terraform 文件：
- en: Terraform can create and manage infrastructure resources from both cloud and
    on-prem, and it can achieve this by communicating with the external infrastructure
    using a provider that is a kind of software plugin that translates Terraform commands
    into the APIs that the infrastructure provider can understand and execute.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Terraform 可以创建和管理云端以及本地的基础设施资源，它可以通过与外部基础设施的通信来实现这一点，使用的提供商是一种软件插件，可以将 Terraform
    命令翻译为基础设施提供商可以理解和执行的 API。
- en: In the `config.tf` file, you define the provider's configuration that you will
    use in this chapter. For each provider, you need to define its name and the version
    you intend to use. To learn more about defining a "required provider version,"
    visit https://www.terraform.io/docs/configuration/terraform.html#specifying-required-provider-versions
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `config.tf` 文件中，你定义了在本章中将使用的提供商配置。对于每个提供商，你需要定义其名称以及你打算使用的版本。要了解如何定义“所需提供商版本”，请访问
    [Terraform 官方文档](https://www.terraform.io/docs/configuration/terraform.html#specifying-required-provider-versions)
- en: 'It is important to define the version explicitly, especially when Terraform
    is used by multiple users or automation tools. This is to avoid the upgrades to
    newer versions that could break the Terraform state:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 明确地定义版本非常重要，特别是在 Terraform 被多个用户或自动化工具使用时。这是为了避免升级到可能会破坏 Terraform 状态的新版：
- en: '[PRE0]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code block defines the AWS provider configuration. You only need to specify
    both the AWS region and the provider''s version:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个代码块定义了 AWS 提供商的配置。你只需要指定 AWS 区域和提供商的版本：
- en: '[PRE1]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `terraform.tfvars` file, you define the environment variables that Terraform
    needs to use during provisioning of the infrastructure resources. Using Terraform
    `tfvars` files is a good practice to pass environment variables to Terraform.
    This enables you to keep all of the configuration, including the environment variables,
    versioned in your source control as your source of truth:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`terraform.tfvars`文件中，你定义了Terraform在配置基础设施资源时需要使用的环境变量。使用Terraform `tfvars`文件是将环境变量传递给Terraform的良好实践。这样做能让你把所有配置，包括环境变量，版本化存储在源代码控制中，作为你的“真实来源”：
- en: '[PRE2]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We use `us-east-1` as the default AWS region, but you can use any other region
    as long as you maintain it for the other exercises.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`us-east-1`作为默认的AWS区域，但你可以使用任何其他区域，只要你在其他练习中保持一致。
- en: The second environment variable is the *clusters name prefix*, which you will
    use for your clusters to identify them as a group of clusters. This name prefix
    could represent your company's name or the product name. However, you are free
    to use any appropriate naming convention.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个环境变量是*集群名称前缀*，你将使用它为你的集群命名，将它们识别为一组集群。这个名称前缀可以代表你公司的名称或产品的名称，当然，你可以自由使用任何合适的命名约定。
- en: 'In the `variables.tf` file, you define the input variables that Terraform code
    will use. There are two input variables that you will need for the exercises in
    this chapter. The first is the AWS region, and the second is the clusters name
    prefix. Both of them will get their values from the previous `terraform.tfvars`
    file:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`variables.tf`文件中，你定义了Terraform代码将使用的输入变量。你将在本章的练习中使用两个输入变量，第一个是AWS区域，第二个是集群名称前缀。这两个变量的值都来自于前面的`terraform.tfvars`文件：
- en: '[PRE3]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the `tf-state-s3.tf` file, you define two S3 bucket resources. The first
    bucket stores the state for the VPC and network resources, while the second bucket
    stores the state for the Kubernetes cluster resources, such as EKS and workers
    groups.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tf-state-s3.tf`文件中，你定义了两个S3存储桶资源。第一个存储桶存储VPC和网络资源的状态，第二个存储桶存储Kubernetes集群资源的状态，如EKS和工作节点组。
- en: The following code snippet uses the Terraform resource called `aws_s3_bucket`,
    which is a built-in resource in the Terraform AWS provider that can be used to
    create AWS S3 buckets and set its configuration parameters.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码片段使用了一个名为`aws_s3_bucket`的Terraform资源，这是Terraform AWS提供程序中的内置资源，可用于创建AWS
    S3存储桶并设置其配置参数。
- en: 'We will use this S3 bucket to persist the Terraform state. And, as you will
    notice in the following code, this S3 bucket has private access to keep it secure
    from the public. It also has deletion prevention enabled to protect it from unplanned
    deletion:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用这个S3存储桶来持久化Terraform状态。正如你在以下代码中所看到的，这个S3存储桶有私有访问权限，以确保它不被公众访问。它还启用了删除保护，以防止其被意外删除：
- en: '[PRE4]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The second part of the code is similar to the previous one, but it is used
    to create the S3 bucket for the networking infrastructure or the **virtual private
    cloud** (**VPC**) resources state:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的第二部分与之前的部分类似，但它用于创建网络基础设施或**虚拟私有云**（**VPC**）资源状态的S3存储桶：
- en: '[PRE5]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Splitting the infrastructure state into two files, as we did in the previous
    code, is debatable. However, we tend to use a balanced approach as we will not
    use a separate state for a resource unless it has an independent life cycle from
    the Kubernetes cluster. This separation facilitates change management of the resources
    and decouples the critical resources from one another.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将基础设施状态分为两个文件，如我们在前面的代码中所做的，值得商榷。然而，我们倾向于使用一种平衡的方法，除非资源的生命周期与Kubernetes集群独立，否则我们不会为资源使用单独的状态。这种分离有助于资源的变更管理，并且将关键资源解耦。
- en: In the `tf-state-dynamodb.tf` file, you create two DynamoDB tables, the first
    for VPC resource state locking, and the second for Kubernetes cluster resources.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tf-state-dynamodb.tf`文件中，你创建了两个DynamoDB表，第一个用于VPC资源状态锁定，第二个用于Kubernetes集群资源。
- en: The following code snippet uses the Terraform resource called `aws_dynamodb_table`,
    which is a built-in resource in the Terraform AWS provider that is used to create
    an AWS DynamoDB table and set its configuration parameters.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码片段使用了一个名为`aws_dynamodb_table`的Terraform资源，这是Terraform AWS提供程序中的内置资源，用于创建AWS
    DynamoDB表并设置其配置参数。
- en: This code creates a DynamoDB table to hold the lock for the shared Terraform
    state for the Kubernetes cluster resources. This lock will protect parallel runs
    against the same state file or the same resources, and this prevents users from
    applying changes to infrastructure at the same time. This could be very dangerous,
    right?
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码创建了一个 DynamoDB 表，用于存储 Kubernetes 集群资源的共享 Terraform 状态的锁。这个锁将防止多个并行执行的操作对相同的状态文件或相同资源进行修改，从而防止用户同时对基础设施进行变更。这样做可能会非常危险，对吧？
- en: '[PRE6]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second part of the `tf-state-dynamodb.tf` file creates a DynamoDB table
    to hold the locks for the shared Terraform state for the VPC resources:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`tf-state-dynamodb.tf` 文件的第二部分创建了一个 DynamoDB 表，用于存储 VPC 资源的共享 Terraform 状态的锁：'
- en: '[PRE7]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When you apply the previous Terraform code file, it will create two DynamoDB
    tables. In the coming sections, we will learn how to configure terraform to use
    them. Then, Terraform will be able to create locks for its shared state files.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你应用之前的 Terraform 代码文件时，它将创建两个 DynamoDB 表。在接下来的章节中，我们将学习如何配置 Terraform 来使用它们。然后，Terraform
    将能够为其共享状态文件创建锁。
- en: Provisioning the Terraform state
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Terraform 状态
- en: 'After creating the previous Terraform code files for the shared state resources.
    You have to perform the following instructions to provision the resources in your
    AWS account:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在为共享状态资源创建了之前的 Terraform 代码文件之后，你需要执行以下操作来在你的 AWS 账户中配置资源：
- en: 'Initialize the Terraform state:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 Terraform 状态：
- en: '[PRE8]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the `terraform plan` command to validate the planned changes before applying
    them:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `terraform plan` 命令，验证计划的更改，然后再应用它们：
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You will get the following output after the `terraform plan` command completes
    successfully. There are four resources to add – two S3 buckets and two DynamoDB
    tables:![Figure 3.3 – Terraform plan command output
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `terraform plan` 命令成功完成后，你将得到如下输出。需要添加四个资源——两个 S3 存储桶和两个 DynamoDB 表：![图 3.3
    – Terraform plan 命令输出
- en: '](img/B16192_03_003.jpg)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16192_03_003.jpg)'
- en: Figure 3.3 – Terraform plan command output
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.3 – Terraform plan 命令输出
- en: 'Execute the `terraform apply` command. Enter `yes` when you get a prompt to
    approve execution:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `terraform apply` 命令。当系统提示确认执行时，输入 `yes`：
- en: '[PRE10]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will get the following output after the `terraform apply` command completes
    successfully. By then, Terraform has successfully created four AWS resources:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `terraform apply` 命令成功完成后，你将得到如下输出。到那时，Terraform 已成功创建了四个 AWS 资源：
- en: '![Figure 3.4 – Terraform apply command output'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – Terraform apply 命令输出'
- en: '](img/B16192_03_004.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16192_03_004.jpg)'
- en: Figure 3.4 – Terraform apply command output
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Terraform apply 命令输出
- en: Now you have completed provisioning of the AWS resources to persist and manage
    the Terraform shared state. In the next section, you will learn how to provision
    the VPC and the other network resources to run your first Kubernetes cluster.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已完成 AWS 资源的配置，以持久化和管理 Terraform 的共享状态。在接下来的章节中，你将学习如何配置 VPC 和其他网络资源，以运行你的第一个
    Kubernetes 集群。
- en: Utilizing Terraform workspaces
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Terraform 工作区
- en: In the previous section, you learned that Terraform configuration has a backend
    that defines how operations are executed and where the infrastructure state is
    persisted, such as in S3 buckets. Terraform uses workspaces to organize and isolate
    multiple states under a single backend.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了 Terraform 配置有一个后端，它定义了操作是如何执行的，以及基础设施状态存储的位置，比如 S3 存储桶。Terraform
    使用工作区来组织和隔离单个后端下的多个状态。
- en: This concept becomes useful when the user wants to run multiple instances of
    the same infrastructure without creating multiple backends and state files. Let's
    assume that you want to use Terraform to provision a Kubernetes cluster, ClusterA,
    and you want to use the same configuration to provision a second cluster, ClusterB.
    In this case, workspaces provide an out-of-the-box and scalable solution, as you
    will be able to use a single backend for all of your clusters (*N* clusters),
    but you provision each cluster in its workspace with its own state file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户希望运行多个相同基础设施的实例，而不创建多个后端和状态文件时，这个概念变得非常有用。假设你想使用 Terraform 来配置一个 Kubernetes
    集群 ClusterA，并希望使用相同的配置来配置第二个集群 ClusterB。在这种情况下，工作区提供了一种开箱即用且可扩展的解决方案，因为你将能够为所有集群（*N*
    个集群）使用单一后端，但在每个工作区中为每个集群配置独立的状态文件。
- en: 'If you have a Terraform configuration with a backend named `k8s_s3_backend`,
    and you want to provision *N* Kubernetes clusters using the same Terraform base
    code, then you can do the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个名为 `k8s_s3_backend` 的 Terraform 配置后端，并且你希望使用相同的 Terraform 基础代码配置 *N* 个
    Kubernetes 集群，那么你可以执行以下操作：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, repeat the same process for every *N* cluster:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对每个*N*集群重复相同的过程：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating the network infrastructure
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建网络基础设施
- en: In [*Chapter 2*](B16192_02_Final_PG_ePub.xhtml#_idTextAnchor051), *Architecting
    Production-Grade Kubernetes Infrastructure*, you learned in detail about the infrastructure
    architecture design recommendations and the technical decisions that you should
    take in relation to the production readiness state for your Kubernetes clusters.
    In this section, you will use Terraform to provision the network layer of your
    Kubernetes production infrastructure.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B16192_02_Final_PG_ePub.xhtml#_idTextAnchor051)，《*构建生产级Kubernetes基础设施*》中，你详细了解了基础设施架构设计建议以及在Kubernetes集群的生产就绪状态方面应该做出的技术决策。在本节中，你将使用Terraform来配置Kubernetes生产基础设施的网络层。
- en: 'These are the AWS network resources that you will provision with the Terraform
    code in this section:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你将在本节中使用Terraform代码配置的AWS网络资源：
- en: AWS VPC
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS VPC
- en: Private subnets
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有子网
- en: Public subnets
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公有子网
- en: Route tables
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由表
- en: Internet and NAT gateways
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Internet 和 NAT 网关
- en: Encapsulating AWS resources into reusable code modules is a recommended IaC
    practice. In the next subsection, you will create a VPC Terraform module that
    includes the previous AWS resources. You can then reuse this module with no code
    changes to provision VPCs for as many Kubernetes clusters as you need.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将AWS资源封装为可重用的代码模块是一种推荐的IaC实践。在接下来的小节中，你将创建一个包含之前AWS资源的VPC Terraform模块。然后，你可以重复使用该模块，无需修改代码，便可为多个Kubernetes集群配置VPC。
- en: Developing the VPC Terraform module
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发VPC Terraform模块
- en: 'Under the `terraform` root directory, create a directory and name it `modules`.
    Then, create a subdirectory and name it `eks-vpc`. This subdirectory will contain
    the following Terraform code files:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`terraform`根目录下，创建一个名为`modules`的目录。然后，创建一个名为`eks-vpc`的子目录。该子目录将包含以下Terraform代码文件：
- en: '`variables.tf`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variables.tf`'
- en: '`main.tf`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.tf`'
- en: '`outputs.tf`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outputs.tf`'
- en: Input variables
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入变量
- en: 'These are the input variables that are accepted by this module. The module''s
    user should provide the values for each of these variables:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是该模块接受的输入变量。模块的用户应该为这些变量提供相应的值：
- en: '`10.40.0.0/17`.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10.40.0.0/17`。'
- en: '`1` or another prefix such as `10.40.64.0/20`.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 或其他前缀，如 `10.40.64.0/20`。'
- en: '`1` or another prefix such as `10.40.0.0/20`.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 或其他前缀，如 `10.40.0.0/20`。'
- en: '**Cluster name prefix**: The value of the cluster name prefix that is used
    in naming the VPC resources.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群名称前缀**：用于命名VPC资源的集群名称前缀的值。'
- en: '**Common tags**: Any AWS tags that you want to assign to the VPC resources
    to help identify and classify them later.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见标签**：任何你想要分配给VPC资源的AWS标签，以帮助后续识别和分类它们。'
- en: 'The `variables.tf` file is defined as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`variables.tf`文件定义如下：'
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous code snippet defines five Terraform variable blocks and all of
    the type strings. In the *Creating the cluster VPC* section, you will use this
    VPC module and learn how to pass the values for each of these variables.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段定义了五个Terraform变量块及其所有类型字符串。在*创建集群VPC*部分，你将使用这个VPC模块并学习如何传递这些变量的值。
- en: Module main resources
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块主资源
- en: The `main.tf` file defines the network resources that are required to create
    Kubernetes AWS network components, including the public and private subnets, internet
    and NAT gateways, and routing tables.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.tf`文件定义了创建Kubernetes AWS网络组件所需的网络资源，包括公有和私有子网、互联网和NAT网关以及路由表。'
- en: The following code snippet uses the Terraform resource called `aws_vpc`, which
    is a built-in resource in the Terraform AWS provider that can be used to create
    AWS VPC and set its configuration parameters.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段使用了名为`aws_vpc`的Terraform资源，这是Terraform AWS提供程序中的内置资源，可用于创建AWS VPC并设置其配置参数。
- en: 'In the following code block, you define the VPC resource, and a data resource
    that is used to retrieve the value of the AWS availability zones that you use
    in the `main.tf` file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，你定义了VPC资源和一个数据资源，该数据资源用于检索你在`main.tf`文件中使用的AWS可用区的值：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The following code snippet uses the Terraform resource called `aws_subnet`,
    which is a built-in resource in the Terraform AWS provider that can be used to
    create AWS subnets and set their configuration parameters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段使用了名为`aws_subnet`的Terraform资源，这是Terraform AWS提供程序中的内置资源，可用于创建AWS子网并设置其配置参数。
- en: 'This code uses the Terraform built-in `count` construct to create one or more
    subnets according to the number of private subnet prefixes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the remaining part of the `main.tf` file, you define an `aws_subnet` resource,
    which is similar to the private subnet resource, but designed for public subnets.
    Also, you create complementary VPC network resources that handle the routing,
    connect the subnets together and with the internet, such as NAT and internet gateways,
    routing tables, and NAT IPs. You can find the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-vpc/main.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-vpc/main.tf).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Output values
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `outputs.tf` file defines the output values from the `VPC` module. Terraform
    will need these values to use them as inputs to the Kubernetes cluster module
    when you provision it. There are four outputs from the `VPC` module: the VPC ID;
    the private subnet IDs; the public subnet IDs; and the NAT IPs.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'The `outputs.tf` file is defined as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code snippet defines five Terraform output blocks. In the *Provisioning
    the cluster* section, you will use these outputs as inputs to the Kubernetes terraform
    modules.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Developing the cluster VPC
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Under the `terraform` root directory, create a directory and name it `packtclusters-vpc`.
    This directory will contain the following Terraform code files:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '`config.tf`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`terraform.tfvars`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variables.tf`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.tf`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outputs.tf`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous list of Terraform files comprises your Kubernetes cluster VPC.
    You will learn about each code and configuration file in the following subsections.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`config.tf` has the Terraform shared state configuration and the AWS provider
    definition:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code block tells Terraform which S3 bucket to use to persist the
    state, and specifies Terraform and AWS provider versions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `terraform.tfvars` file defines the values of the input variables. These
    values are required by the VPC module to set the values of these inputs: the AWS
    region; the VPC IP CIDR; the private subnet prefix list; and the public subnet
    prefix list.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'The `terraform.tfvars` file is defined as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For the preceding code, you can choose a different CIDR block for the VPC IPs
    range and different subnet prefixes according to your network topology and applications
    needs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: You should make sure that the VPC CIDR is not used by any other VPCs within
    your own AWS VPC so as to avoid IPs collisions. You should make sure the VPC CIDR
    has a sufficient number of IPs that exceeds the maximum forecasted number of pods
    in your Kubernetes cluster.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Input variables
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `variables.tf` file defines the five input variables that Terraform will
    use during creation of the VPC module resources. It is very similar to the previous
    `variables.tf` files. You can view its full source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters-vpc/variables.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters-vpc/variables.tf).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`variables.tf` 文件定义了 Terraform 在创建 VPC 模块资源时将使用的五个输入变量。它与之前的 `variables.tf`
    文件非常相似。您可以在此处查看其完整源代码：[https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters-vpc/variables.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters-vpc/variables.tf)。'
- en: The cluster VPC
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集群 VPC
- en: 'The `main.tf` file has two code blocks: the `vpc` module block, which creates
    an instance of the `eks-vpc` module, and the `locals` code block, which defines
    `common_tags` to be assigned to VPC resources.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.tf` 文件包含两个代码块：`vpc` 模块块，它创建一个 `eks-vpc` 模块的实例，以及 `locals` 代码块，它定义了要分配给
    VPC 资源的 `common_tags`。'
- en: 'The `main.tf` file is defined as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.tf` 文件定义如下：'
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Thanks to Terraform modules, this makes the previous code clean and simple,
    as it hides the complexity of creating the AWS VPC. In the next subsection, you
    will create the Terraform outputs that you will use while creating the cluster
    VPC.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 Terraform 模块，这使得前面的代码变得简洁清晰，因为它隐藏了创建 AWS VPC 的复杂性。在下一小节中，您将创建在创建集群 VPC 时使用的
    Terraform 输出。
- en: Output values
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出值
- en: The `outputs.tf` file defines the output values that you need to get after creating
    the cluster VPC. These outputs are the VPC ID, the private subnet IDs, and the
    public subnet IDs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`outputs.tf` 文件定义了在创建集群 VPC 后需要获取的输出值。这些输出值包括 VPC ID、私有子网 ID 和公共子网 ID。'
- en: 'The `outputs.tf` file is defined as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`outputs.tf` 文件定义如下：'
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The outputs from the previous code block are used as the inputs to the Kubernetes
    cluster Terraform modules in the next section.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个代码块的输出作为下一节 Kubernetes 集群 Terraform 模块的输入。
- en: Provisioning the cluster VPC
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署集群 VPC
- en: 'Once you have completed development of the VPC Terraform files in the previous
    sections, you can now provision the VPC resources and create them in your AWS
    account:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成了前面章节中 VPC Terraform 文件的开发，您现在可以部署 VPC 资源并将其创建到您的 AWS 账户中：
- en: 'Initialize the Terraform state:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 Terraform 状态：
- en: '[PRE21]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Execute the `terraform plan` command to review the planned changes before applying
    them:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `terraform plan` 命令，查看计划中的更改，然后再应用它们：
- en: '[PRE22]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Execute the `terraform apply` command. Enter `yes` when you get a prompt to
    approve the execution:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `terraform apply` 命令。在提示确认执行时，输入 `yes`：
- en: '[PRE23]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You will get the following output once the `terraform apply` command completes
    successfully, and by then, Terraform has successfully created 28 network resources:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `terraform apply` 命令成功完成后，您将获得以下输出，此时 Terraform 已成功创建了 28 个网络资源：
- en: '![Figure 3.6 – The terraform apply command output'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – terraform apply 命令输出]'
- en: '](img/B16192_03_006.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16192_03_006.jpg)'
- en: Figure 3.6 – The terraform apply command output
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – terraform apply 命令输出
- en: By completing this section, you should have your Kubernetes cluster VPC and
    its network components successfully created in your AWS account. It is now ready
    to provision the cluster above it, as you will learn in the next section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本节后，您应该已经成功在 AWS 账户中创建了 Kubernetes 集群 VPC 及其网络组件。现在，它已经准备好部署在其上的集群，您将在下一节中学习如何操作。
- en: Creating the cluster infrastructure
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建集群基础设施
- en: 'In this section, you will develop the following Terraform modules:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将开发以下 Terraform 模块：
- en: An EKS module
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 EKS 模块
- en: A Kubernetes worker module
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Kubernetes 工作节点模块
- en: A Kubernetes cluster module that wraps both the EKS control plan and the workers
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个封装了 EKS 控制平面和工作节点的 Kubernetes 集群模块
- en: After that, you will use these modules to Terraform your first cluster, `Packt
    cluster`, and then provision it in your AWS account.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将使用这些模块来 Terraform 您的第一个集群 `Packt cluster`，并将其部署到您的 AWS 账户中。
- en: Developing the EKS Terraform module
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发 EKS Terraform 模块
- en: 'Under the `terraform/modules` directory, create a subdirectory with the name
    `eks-cp`. This directory will contain the following Terraform source code files
    for the EKS control plane module:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `terraform/modules` 目录下，创建一个名为 `eks-cp` 的子目录。该目录将包含以下 EKS 控制平面模块的 Terraform
    源代码文件：
- en: '`variables.tf`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variables.tf`'
- en: '`main.tf`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.tf`'
- en: '`security-groups.tf`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security-groups.tf`'
- en: '`iam.tf`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iam.tf`'
- en: '`outputs.tf`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outputs.tf`'
- en: The previous list of files together comprises the EKS Terraform module. You
    will learn about each of these code and configuration files in the following subsections.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Input variables
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `variables.tf` file defines the input variables that are accepted in the
    EKS module. The module user should provide the values for each of these variables:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Full cluster name
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cluster Kubernetes version
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VPC ID
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private subnet IDs
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public subnet IDs
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common tags
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This file is similar to the `variables.tf` file you created in the VPC module.
    You can view its full source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-cp/variables.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-cp/variables.tf).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Module main resources
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `main.tf` file defines the EKS resources that are required to configure
    and create it. These include the cluster name, version, and cluster IAM role ARN.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet uses the Terraform resource called `aws_eks_cluster`,
    which is a built-in resource in the Terraform AWS provider that can be used to
    create an AWS EKS cluster and set its configuration parameters.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.tf` file is defined as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the previous code, you will notice that the EKS resource references the values
    of the EKS IAM role and the EKS security group. Both of these are created in the
    EKS module, but in two separate Terraform files for better code clarity and organization.
    You will learn about creating EKS security groups and IAM roles in the following
    subsections.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Security groups
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following code snippet uses the Terraform resource called `aws_security_group`,
    which is a built-in resource in the Terraform AWS provider that can be used to
    create an AWS security group and set its configuration parameters.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `security-groups.tf` file defines a single security group for
    the EKS control plane:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you notice, the previous security group does not have ingress/egress rules.
    These rules will be defined in the cluster workers module.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: IAM roles and policies
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `iam.tf` file uses the Terraform resource called `aws_iam_role`, which is
    a built-in resource in the Terraform AWS provider that can be used to create an
    AWS IAM role and set its configuration parameters.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'There are specific policies that the EKS cluster must acquire in order to operate
    properly:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '`AmazonEKSClusterPolicy`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AmazonEKSServicePolicy`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These policies must be attached to the EKS cluster IAM role that we will create
    in the next code snippet. To learn more about these policies, you can check the
    EKS official documentation at [https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html](https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `iam.tf` file defines an IAM role and associates two policies
    with this role:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The two IAM policies in question are `AmazonEKSClusterPolicy` and `AmazonEKSServicePolicy`.
    Both of them are AWS-predefined IAM policies:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You need to attach the IAM role defined in the previous code to the EKS cluster
    to enable it to operate within the AWS environment. In the next and final subsection,
    you will define the EKS module outputs.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Output values
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `outputs.tf` file defines the output values from the EKS module. There
    are three outputs: the security group ID; the cluster **certificate authority**
    (**CA**); and the cluster API server endpoint.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The `outputs.tf` file is defined as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this section, you learned to develop a Terraform module for the EKS. You
    will use it with other modules to compose your cluster infrastructure. In the
    next section, you will learn to develop a Terraform module for the cluster workers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Developing the workers' Terraform module
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Under the `terraform/modules` directory, create a subdirectory and name it
    `eks-workers`. This directory will contain the following Terraform code files:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '`variables.tf`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.tf`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`security-groups.tf`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iam.tf`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user-data.tf`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`authconfig.tf`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outputs.tf`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AWS recently introduced the managed EKS node group, which is an EKS service
    to manage workers on your behalf. This is a new service and it lacks important
    features, such as the ability to provide custom user data, which is essential
    when it comes to optimizing workers' performance and `kubelet` arguments. This
    is the reason why the preference is to keep using the self-managed workers until
    AWS implements this feature.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Input variables
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `variables.tf` file defines the input variables that are required by this
    module. There are multiple inputs for the workers' module, such as the worker
    AMI ID, EC2 instance type, user data, and instance storage size.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'The `variables.tf` file is defined as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Important note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: AWS periodically releases optimized AMIs for EKS workers. To choose one of them,
    please check the EKS documentation at [https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html](https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: You still can build your own AMI for EKS workers, and you can make use of the
    EKS AMI open source project at [https://github.com/awslabs/amazon-eks-ami](https://github.com/awslabs/amazon-eks-ami).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Please view the remainder of the variables and the full source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-workers/variables.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-workers/variables.tf).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Module main resources
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `main.tf` file defines the workers'' resources and their properties. This
    module contains two AWS resources:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Autoscaling group
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launch template
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The autoscaling group uses the launch template to add worker instances according
    to the launch specs.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet uses the Terraform resource called `aws_autoscaling_group`,
    which is a built-in resource in the Terraform AWS provider that can be used to
    create an AWS autoscaling group and set its configuration parameters.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.tf` file is defined as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Please view the rest of the `main.tf` source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-workers/main.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-workers/main.tf).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Security groups
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `security-groups.tf` file defines the workers' security group and the ingress/egress
    rules that control the flow of traffic between workers, and between the control
    plane and the workers.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to [*Chapter 2*](B16192_02_Final_PG_ePub.xhtml#_idTextAnchor051),
    *Architecting Production-Grade Kubernetes Infrastructure*, for more details about
    the security group ingress/egress rules and the permitted ports.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'The `security-groups.tf` file is defined as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can view the full source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-workers/security-groups.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-workers/security-groups.tf).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: IAM role and policies
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following `iam.tf` file defines an IAM role and associates two policies
    with this role:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The IAM policies are `AmazonEKSWorkerNodePolicy`, `AmazonEKS_CNI_Policy`, `AmazonEC2ContainerRegistryReadOnly`,
    and `CloudWatchAgentServerPolicy`. All of them are standard predefined IAM policies:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You need to attach the IAM role defined in the previous code to the workers
    in order to enable them to operate within the AWS environment.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: User data
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `user-data.tf` file defines the user data script that is executed while
    the worker instance is booting up.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet uses a special Terraform code block called `locals`,
    which is used to define a set of key/value configurations. In our solution, we
    use it to construct the worker user data script.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'The `user-data.tf` file is defined as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Later in the book, we will update the previous code to bootstrap `kubelet` with
    optimized arguments for worker performance tuning.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Worker authentication
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes requires workers to be authenticated in order to be able to join
    the cluster and communicate with `kube-api-server`. EKS provides its own solution
    to perform this type of authentication, as it requires the cluster admin to create
    a ConfigMap that contains the workers' IAM role ARN and map it to the Kubernetes
    system node group. By doing that, workers can join the cluster.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: To automate this, the `authconfig.tf` file defines the content of the `authconfig`
    YAML file, which you will use to register and authenticate the workers with the
    EKS control plane.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that `authconfig` can be applied separately to the cluster
    using `kubectl`. However, I recommend that you apply it using Terraform to register
    the nodes immediately after EKS is provisioned, and then you can apply it again
    later as part of Kubernetes configuration management, and add more users and groups
    to `authconfig`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'The `authconfig.tf` file is defined as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In [*Chapter 4*](B16192_04_Final_PG_ePub.xhtml#_idTextAnchor100), *Managing
    Cluster Configuration with Ansible*, we will learn how to extend `aws-auth` to
    authenticate other users with the cluster.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Output values
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `outputs.tf` file defines the output values from the `Workers` module, such
    as the worker's instance profile ARN, the IAM role ARN, and other outputs. Please
    view the full source code of `outputs.tf` at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-workers/outputs.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/eks-workers/outputs.tf).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned to develop a Terraform module for the cluster workers.
    You will use this with other modules to compose your cluster infrastructure. In
    the next section, you will learn to develop a Terraform module that wraps both
    EKS and workers in a single module that represents the whole Kubernetes cluster.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Kubernetes cluster Terraform module
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Under the `terraform/modules` directory, create a subdirectory and name it
    `cluster`. This directory will contain the following Terraform code files:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '`config.tf`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`terraform.tfvars`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variables.tf`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.tf`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outputs.tf`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This `cluster` module is a wrapper above both the EKS module and the workers'
    module. You will notice that the inputs and outputs to/from this module are a
    combination of both EKS and worker modules.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Input variables
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `variables.tf` file defines the input variables that are needed by this
    module. These inputs are a combination of both EKS and worker modules. Please
    view the source code with a full list of variables at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/cluster/variables.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/cluster/variables.tf).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: EKS control plane
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `eks-cp.tf` file defines an instance of the EKS module. It is defined as
    follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The previous code block creates the EKS control plane by creating an instance
    from the EKS module and passing to it the required inputs.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: EKS workers
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `workers.tf` file defines an instance of the `workers` module:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The previous code block creates the cluster workers by creating an instance
    from the `workers` module and passing it to the required inputs. Both of the previous
    code files comprise the full Kubernetes cluster.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Output values
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `outputs.tf` file contains the output values from the `cluster` module,
    such as the cluster's full name, the cluster endpoint, `authconfig`, and others.
    Please view the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/cluster/outputs.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/modules/cluster/outputs.tf).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned to develop a Terraform module that wraps both EKS
    and workers in a single module that is used to provision the whole Kubernetes
    cluster. In the next section, you will use the previous modules to develop your
    first cluster – the Packt cluster.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Putting all modules together
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it is time to bring all the modules together by creating your first cluster
    group, `packtclusters`, and a first cluster, `prod1`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the root `terraform` directory, create a subdirectory and name it `packtclusters`.
    Then, under this, create the following Terraform code files:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '`config.tf`'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`terraform.tfvars`'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variables.tf`'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.tf`'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outputs.tf`'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following subsections, you will create the code files in the previous
    list and learn all the details about them.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `config.tf` file contains the Terraform shared state configuration and the
    AWS provider definition. This file is similar to the `config.tf` file you created
    in the *Developing the cluster VPC* section. Please view the complete source code
    at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters/config.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters/config.tf).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `terraform.tfvars` file defines the input values that are passed to the
    `cluster` module. Some of these values are outputs from the VPC module. To retrieve
    these outputs, you have to execute the following command:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, copy the following output values:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: VPC ID
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private subnet IDs
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public subnet IDs
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, paste these values into the `terraform.tfvars` file into their corresponding
    placeholders.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'The `terraform.tfvars` file is defined as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Some of the preceding values can be tuned according to your infrastructure requirements,
    specifically, the instance type and the worker instance count min/max limits.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: For educational purposes, you can use the existing values in the previous code
    block. However, when you decide to move your cluster to production, please refer
    to the workers' sizing section in [*Chapter 2*](B16192_02_Final_PG_ePub.xhtml#_idTextAnchor051),
    *Architecting Production-Grade Kubernetes Infrastructure*.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Input variables
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `variables.tf` file defines inputs that Terraform will use while creating
    the `packtclusters-prod1` cluster. You can view the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters/variables.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters/variables.tf).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: The cluster main resources
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `main.tf` file defines the cluster module. It takes the input variables
    required to configure EKS and the workers.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.tf` file is defined as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the previous code block, the `cluster_full_name` input is constructed by
    concatenating `cluster_name_prefix`, which is `packtclusters`, and the Terraform
    workspace name, `prod1`. And this is how you can create multiple clusters under
    one cluster group such as `packtclusters`. All you need is to create a new Terraform
    workspace and execute your `terraform plan`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Output values
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `outputs.tf` file defines the outputs from `packtclusters`, primarily `authconfig`,
    which is used to authenticate the workers with the control plane. You can view
    the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters/outputs.tf](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter03/terraform/packtclusters/outputs.tf).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: By completing this section, you have a complete Terraform code base that is
    capable of creating full Kubernetes clusters. In the next section, you will learn
    the Terraform commands to use this code base to provision your first production
    cluster.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning the cluster infrastructure
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After you have completed developing the cluster Terraform modules in the previous
    sections, you can now provision your first Kubernetes cluster and create it in
    your AWS account:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the Terraform state:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a new Terraform workspace for the first cluster and name it `prod1`:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Execute the `terraform plan` command to review the planned changes before applying
    them:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is the `terraform plan` command output that you should get:![Figure 3.7
    – Terraform plan command output
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16192_03_007.jpg)'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.7 – Terraform plan command output
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the `terraform apply` command. Enter `yes` when you get a prompt to
    approve the plan execution:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You will get the following output after the `terraform apply` command completes
    successfully. This means that Terraform has successfully created 22 resources:![Figure
    3.8 – Terraform apply command output
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16192_03_008.jpg)'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.8 – Terraform apply command output
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Retrieve the cluster `kubeconfig` file:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Apply `authconfig` to authenticate the workers'' nodes with the EKS control
    plane:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Ensure that the cluster worker nodes are up and in the ready state:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: After completing the previous instructions, you have a Kubernetes cluster up
    and running, but it is still not ready to deploy production workloads. In the
    next chapters, you will deploy more services to the cluster, and optimize their
    configurations to make it capable of running your production workloads.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up and destroying infrastructure resources
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After completing the hands-on exercises in this chapter, you can follow the
    instructions in this section to destroy the Kubernetes cluster and its AWS resources.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: You will destroy the resources in reverse order from their creation. First,
    you will destroy the Kubernetes cluster resources, then the VPC resources, and
    finally the shared state resources.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Destroying the cluster resources
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these Terraform commands to destroy all of the `packtclusters` resources
    that you created in the previous sections of this chapter:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the Terraform state:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Execute the `terraform destroy` command. Enter `yes` when you get a prompt
    to approve the destruction:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You will get the following output once the `terraform destroy` command completes
    successfully. This means that Terraform has successfully destroyed the 22 resources
    in the cluster:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.9 – The terraform destroy command output'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16192_03_009.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – The terraform destroy command output
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Having observed the previous instructions, `packtclusters-prod1` is completely
    destroyed. In the next subsection, you will destroy the VPC resources.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Destroying the VPC resources
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these Terraform commands to destroy all of the `packtclusters-vpc` resources
    that you created in the previous sections of this chapter:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the Terraform state:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Execute the `terraform destroy` command. Enter `yes` when you get a prompt
    to approve the destruction:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You will get the following output after the `terraform destroy` command completes
    successfully. This means that Terraform has successfully destroyed 28 network
    resources:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.10 – The terraform destroy command output'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16192_03_010.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – The terraform destroy command output
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Having observed the previous instructions, `packtclusters-vpc` is completely
    destroyed. In the next subsection, you will destroy the shared state resources.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Destroying the shared state resources
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, you do not have to delete the shared state files. However, for educational
    purposes, you can follow these instructions to destroy these resources.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'As the shared state S3 buckets have destroy prevention and versioning enabled,
    you should empty and then destroy Terraform shared state S3 buckets first:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Initialize the Terraform state to destroy the shared state DynamoDB tables:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Execute the `terraform destroy` command. Enter `yes` when you get a prompt
    to approve the destruction:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You will get the following output after the `terraform destroy` command completes
    successfully. By then, Terraform has successfully destroyed both of the DynamoDB
    tables:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.11 – The terraform destroy command output'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16192_03_011.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – The terraform destroy command output
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: By now, you have successfully finished destroying your Kubernetes cluster and
    all of its AWS resources in your AWS account.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: I recommend practicing these instructions and repeating them to provision and
    destroy the cluster, and to create multiple clusters by adding new Terraform workspaces,
    such as prod2 and prod3.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned to develop the infrastructure code for Kubernetes
    clusters using Terraform and AWS. You went through practical steps to implement
    this code. We started by creating the network components, followed by the cluster's
    components, using AWS VPC, EKS, autoscaling groups, and other AWS services.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduced you to Terraform practical development and its usage
    in relation to production infrastructure provisioning. It showed you how to follow
    the best practices of the declarative IaC, and also the best practices of decomposing
    your IaC into modules and combining them to create Kubernetes clusters.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: All of this establishes a foundation for the forthcoming chapters, where we
    will build on the knowledge introduced here to take the Kubernetes cluster to
    the next level of its production-readiness journey.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn in detail about Kubernetes cluster configuration
    management. You will develop a dynamic templating solution that you can apply
    to the cluster-level configurations, and you will learn how to make your solution
    scalable to many clusters without introducing operational overheads and complexity.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following books:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '*Getting Started with Terraform – Second Edition*: [https://www.packtpub.com/networking-and-servers/getting-started-terraform-second-edition](https://www.packtpub.com/networking-and-servers/getting-started-terraform-second-edition)'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Infrastructure Automation with Terraform on AWS*: [https://www.packtpub.com/big-data-and-business-intelligence/hands-infrastructure-automation-terraform-aws-video](https://www.packtpub.com/big-data-and-business-intelligence/hands-infrastructure-automation-terraform-aws-video)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
