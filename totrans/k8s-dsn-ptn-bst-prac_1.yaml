- en: Kubernetes Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 设计模式
- en: Design patterns are the formalization of best practices for everyday problems.
    Using design patterns in everyday, professional life creates a common language
    and communication platform for you to work on. In real life, seasoned engineers
    do not explain how to convert one interface into another; instead, they decide
    to implement an adapter. Design patterns hide the complexity and details of communication
    and create a common platform. In addition, converting business requirements into
    code is more comfortable with the accumulated knowledge of design patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是日常问题最佳实践的形式化。将设计模式应用于日常工作中，为您创建了一个共同的语言和沟通平台。在实际工作中，经验丰富的工程师不会解释如何将一个接口转换为另一个接口；相反，他们会决定实现一个适配器。设计模式隐藏了复杂性和通信细节，并创造了一个共同的平台。此外，通过积累的设计模式知识，将业务需求转化为代码变得更加轻松。
- en: Kubernetes is the uprising and prominent open source container orchestration
    system, designed by Google. Its fundamental features include automation, scaling,
    and scheduling of containerized applications. To have a scalable and reliable
    cloud-native application, Kubernetes is a crucial part of your toolset. All levels
    of companies, from start-ups to large enterprises, are using Kubernetes to install
    and manage cloud-native applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个崛起的、著名的开源容器编排系统，由 Google 设计。它的基本功能包括自动化、扩展和容器化应用程序的调度。为了构建一个可扩展且可靠的云原生应用程序，Kubernetes
    是您工具集中的关键部分。从初创公司到大型企业，各种规模的公司都在使用 Kubernetes 来安装和管理云原生应用程序。
- en: This paradigm shift in software development began by creating microservices
    instead of chunks of large software systems. The "new" best practices have aligned
    with the de facto cloud-native orchestration tool, Kubernetes. Throughout this
    book, Kubernetes design patterns and extension capabilities will be presented.
    The book starts by explaining best practices to show how to create Kubernetes-native
    applications. Following that, accessing Kubernetes itself programmatically and
    enriching the best orchestration tool ever created will be explained. Finally,
    Kubernetes itself will be extended with a higher level of automation. At the end
    of the day, you will have the technical knowledge and hands-on experience to not
    only create applications to run on Kubernetes, but also extend the system itself.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这一软件开发的范式转变始于创建微服务，而不是构建庞大的软件系统块。随着 "新" 最佳实践的出现，它们与事实上的云原生编排工具 Kubernetes 对接。全书将介绍
    Kubernetes 设计模式和扩展能力。书中首先解释最佳实践，展示如何创建 Kubernetes 原生应用程序。接下来，将解释如何通过编程访问 Kubernetes，并丰富这一有史以来最强大的编排工具。最后，将通过更高层次的自动化扩展
    Kubernetes 本身。最终，您将拥有不仅能创建运行在 Kubernetes 上的应用程序的技术知识和实践经验，还能扩展 Kubernetes 系统本身的能力。
- en: In this first chapter, Kubernetes design patterns will be presented, starting
    with the fundamentals of design patterns. Following that, you will build Kubernetes
    solutions using structural patterns, assemble systems with behavioral patterns,
    and finally, install applications according to the deployment strategies.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，将介绍 Kubernetes 设计模式，从设计模式的基础开始。接下来，您将使用结构模式构建 Kubernetes 解决方案，使用行为模式组装系统，最后根据部署策略安装应用程序。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，您将能够：
- en: Define the fundamentals of design patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义设计模式的基本概念
- en: Explain the classification of patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释模式的分类
- en: Use Kubernetes design patterns to solve real-life problems
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 设计模式解决实际问题
- en: Build solutions using structural patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用结构模式构建解决方案
- en: Assemble complex systems with behavioral patterns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用行为模式组装复杂系统
- en: Install applications with deployment strategies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用部署策略安装应用程序
- en: Software Design Patterns
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件设计模式
- en: In software development, a design pattern is a repeatable solution to a widespread
    problem, since it is ubiquitous to solve the same problems you have encountered
    before. There are two main advantages of design patterns. The first advantage
    is that they are proven solutions, and the second one is that they create a communication
    platform between developers. With these advantages, templates and specifications
    have been formalized over the years to create a knowledge and experience pool.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，设计模式是解决广泛问题的可重复解决方案，因为它普遍适用于解决您之前遇到的相同问题。设计模式有两个主要优点。第一个优点是它们是经过验证的解决方案，第二个优点是它们为开发人员之间创造了一个沟通平台。凭借这些优点，模板和规范经过多年的规范化，形成了一个知识和经验池。
- en: Design patterns are not finished designs that can be transformed directly into
    code – they are only best practices and set of approaches.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式并不是可以直接转化为代码的完成设计——它们只是最佳实践和一系列方法。
- en: Software development is seen as a relatively young and evolving field of study;
    however, most of the problems solved in various circumstances are similar. For
    instance, it is common to create a single instance component in various software
    systems, such as payment systems, log managers, **enterprise resource planning**
    (**ERP**) systems, or online games. Therefore, making use of past collected knowledge
    helps development teams to advance rapidly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发被视为一个相对年轻且不断发展的学科领域；然而，在各种情况下解决的大多数问题都是相似的。例如，在各种软件系统中创建单一实例组件是常见的做法，如支付系统、日志管理器、**企业资源规划**
    (**ERP**) 系统或在线游戏。因此，利用过去积累的知识可以帮助开发团队快速进步。
- en: Design patterns and corresponding business requirements could seem artificial
    and only software-related. However, both problems and solutions have roots in
    real life. For instance, the singleton pattern is proposed as a best practice
    for implementing a configuration manager. With the same approach in mind, the
    adapter pattern is proposed as a best practice to work with both versions of the
    APIs. As its name implies, it is a similar approach in real-life to using electrical
    adapters to work with the different plug and socket types in various countries.
    As these examples indicate, software design patterns and the ideas behind them
    all come from real-life experiences.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式和相应的业务需求看起来可能显得人工且仅与软件相关。然而，问题和解决方案的根源实际上源自现实生活。例如，单例模式被提出作为实现配置管理器的最佳实践。采用相同的思路，适配器模式被提出作为与不同版本API协作的最佳实践。正如其名字所示，它类似于在现实生活中使用电气适配器来适配不同国家的插头和插座类型。正如这些例子所示，软件设计模式及其背后的理念都源于现实生活经验。
- en: Uses of Software Design Patterns
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件设计模式的用途
- en: There are two main uses of design patterns. First, design patterns create a
    common platform for developers with their terminology. For example, during a technical
    discussion, let's assume that a design decision is made to use a single instance
    of a component. All other developers, at least the ones that are aware of design
    patterns, will not need any further information considering the properties of
    the singleton pattern. Although this looks trivial, it is an enrichment of communication,
    with the best practices of technical expertise. Secondly, knowing and leveraging
    best practices in engineering makes it easier to advance rapidly. Let's imagine
    that you are designing a car – you should always start by inventing the best wheel
    possible first. This makes the process faster and eliminates the gains of learning
    from past
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式有两个主要用途。首先，设计模式为开发者创建了一个通用的平台，带有专有术语。例如，在一次技术讨论中，假设已经做出了使用组件单例的设计决策。所有其他开发人员，至少是那些了解设计模式的开发人员，将不需要进一步了解单例模式的属性。尽管这看起来微不足道，但它是技术沟通的丰富化，带有最佳实践的技术专业知识。其次，了解并利用工程学中的最佳实践能让开发进程更加迅速。假设你在设计一辆车——你应该始终从发明最好的轮子开始。这使得整个过程更加高效，并且避免了从过去的经验中吸取教训的重复过程。
- en: mistakes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 错误。
- en: Classification of Software Design Patterns
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件设计模式的分类
- en: Design patterns are classified in three ways. With new technologies and programming
    languages always emerging, new groups are proposed, but the main idea of classification
    remains the same – the interaction between their controllers
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式有三种分类方法。随着新技术和编程语言的不断涌现，新的分类方法也被提出，但分类的主要思想保持不变——它们的控制器之间的交互。
- en: 'and other applications:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以及其他应用：
- en: '![](img/0937be66-17ef-44fb-b90c-2a528ff58682.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0937be66-17ef-44fb-b90c-2a528ff58682.png)'
- en: To sum this section up, design patterns are formalized best practices that have
    roots in both real-life and software design. They create a common communication
    platform for developers, and they are a valuable source of knowledge as a collection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这一部分，设计模式是正式化的最佳实践，源于现实生活和软件设计。它们为开发者创造了一个共同的沟通平台，并作为一个知识集合，具有重要的价值。
- en: In the following chapter, design patterns for Kubernetes are presented as best
    practices for creating, managing, and deploying modern cloud-native applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章节中，介绍了Kubernetes的设计模式，作为创建、管理和部署现代云原生应用的最佳实践。
- en: Kubernetes Design Patterns
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 设计模式
- en: The evolution of microservices and container technologies has changed the way
    software applications are designed, developed, and deployed. Nowadays, modern
    cloud-native applications focus on scalability, flexibility, and reliability in
    order to meet business requirements. For instance, the scalability of an application
    with thousands of instances running in a reliable manner was not a concern 10
    years ago. Similarly, self-awareness and self-healing features were out of scope
    when there was no orchestrator for these issues, such as Kubernetes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务和容器技术的发展改变了软件应用程序的设计、开发和部署方式。如今，现代云原生应用程序更加关注可扩展性、灵活性和可靠性，以满足业务需求。例如，十年前，数千个实例可靠运行的应用程序可扩展性并不是一个问题。同样，当没有
    Kubernetes 这种编排工具来处理这些问题时，自我意识和自我修复功能也不在考虑范围之内。
- en: New requirements and cloud-native characteristics unveil their own best practices
    and design patterns. Extensive use and the adoption of Kubernetes by all sorts
    of companies, including start-ups and large enterprises, made it possible to formalize
    and collect best practices. In this section, widely known and essential design
    patterns and deployment strategies in Kubernetes will be described. With the help
    of these patterns, you'll be able to make use of the best practices that have
    been formalized by Kubernetes itself.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 新的需求和云原生特性揭示了它们自身的最佳实践和设计模式。Kubernetes 被各种公司广泛使用并被采纳，包括初创公司和大型企业，这使得最佳实践能够被形式化并汇集起来。在本节中，将描述
    Kubernetes 中广为人知的基本设计模式和部署策略。借助这些模式，你将能够利用 Kubernetes 自身所形式化的最佳实践。
- en: Structural Patterns
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构模式
- en: Structural patterns are focused on the composition of building blocks to create
    higher-level complex resources. In microservice architecture, applications are
    packaged and deployed as containers. This approach makes it easier to scale applications
    with less overhead and more isolation. However, this makes it difficult to schedule
    and run related containers side-by-side, or sequentially in a cluster with thousands
    of nodes. For instance, if you want to run your frontend and backend containers
    together in a cluster, you need to find a mechanism so that you can always schedule
    them to the same nodes. Likewise, if you need to fill in configuration file templates
    before starting your application, there is a need to ensure that configuration
    handler containers are running before the application is.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 结构模式侧重于将构建块组合成更高层次的复杂资源。在微服务架构中，应用程序被打包并作为容器部署。这种方法使得应用程序可以更容易地扩展，减少了开销并增强了隔离性。然而，这也使得在成千上万节点的集群中并排或按顺序运行相关容器变得困难。例如，如果你想将前端和后端容器一起运行在一个集群中，你需要找到一种机制，使得它们始终能够被调度到同一节点上。同样，如果在启动应用程序之前需要填充配置文件模板，那么就需要确保配置处理容器在应用程序之前已经运行。
- en: In Kubernetes, containers are the building blocks that are encapsulated in pods.
    As a container orchestrator, Kubernetes provides built-in functionalities for
    organizing containers within pods. In this section, the sidecar and initialization
    structural design patterns for Kubernetes will be explained.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，容器是被封装在 Pod 中的构建块。作为容器编排工具，Kubernetes 提供了内置功能，用于在 Pod 内组织容器。在本节中，将解释
    Kubernetes 的辅助车模式和初始化结构设计模式。
- en: Pods are the smallest deployable resources in Kubernetes, and they consist of
    one or more containers sharing resources. Pod containers are always scheduled
    to the same node so that they can share resources such as networking and storage.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 是 Kubernetes 中最小的可部署资源，由一个或多个共享资源的容器组成。Pod 中的容器始终被调度到同一节点，以便它们可以共享网络和存储等资源。
- en: 'Further information about the pod concept is available in the official documentation
    of Kubernetes: [https://kubernetes.io/docs/concepts/workloads/pods/pod](https://kubernetes.io/docs/concepts/workloads/pods/pod).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Pod 概念的更多信息可以在 Kubernetes 官方文档中找到：[https://kubernetes.io/docs/concepts/workloads/pods/pod](https://kubernetes.io/docs/concepts/workloads/pods/pod)。
- en: Sidecar Pattern
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辅助车模式
- en: Modern software applications often require external functionalities such as
    monitoring, logging, configuration, and networking. When these functionalities
    are tightly integrated into the application, they can run as a single process.
    However,
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件应用程序通常需要外部功能，如监控、日志记录、配置和网络。当这些功能紧密集成到应用程序中时，它们可以作为单个进程运行。然而，
- en: 'this violates the isolation principle and creates an opportunity for a single
    point of failure. With this idea, containers in cloud-native applications are
    expected to follow the Unix philosophy:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这违反了隔离原则，并且为单点故障提供了机会。基于这一思想，云原生应用中的容器应该遵循Unix哲学：
- en: Containers should have one task
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器应该只有一个任务
- en: Containers should work together
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器应该协同工作
- en: Containers should handle text streams
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器应该处理文本流
- en: The **single point of failure (SPOF)** is a component within a system where
    its failure can cause all systems to fail. To have reliable and scalable cloud-native
    applications, SPOFs are undesirable, and system designs should be checked for
    their existence.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**单点故障（SPOF）**是指系统中的一个组件，其失败可能导致整个系统的崩溃。为了拥有可靠且可扩展的云原生应用程序，SPOF是不可取的，系统设计应该检查是否存在SPOF。'
- en: The Unix philosophy focuses on designing a small operating system with a clean
    service interface. To have such a system, simple, precise, clear, and modular
    software development should be undertaken, taking into consideration the developers
    and maintainers. Besides, the philosophy emphasizes that you should compose subsystems
    instead of creating a big, monolithic design.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Unix哲学专注于设计一个具有清晰服务接口的小型操作系统。为了拥有这样一个系统，应当进行简单、精确、清晰且模块化的软件开发，同时考虑开发人员和维护人员。此外，哲学还强调应该组合子系统，而不是创建一个庞大、单一的设计。
- en: 'With this idea, it is a conventional approach to separate the main application
    and run a couple of sidecars attached, which are provided for extra functionality.
    The main advantages of using a sidecar are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个思想，分离主应用程序并运行一些附加的sidecar容器已成为一种常规方法，这些sidecar提供额外的功能。使用sidecar的主要优势如下：
- en: They have independent programming languages and runtime dependencies
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有独立的编程语言和运行时依赖
- en: They monitor the main application closely and minimize latency
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们密切监控主应用程序，并最小化延迟
- en: They extend black box applications
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们扩展了黑箱应用程序
- en: In the following activity, a web-based game will be installed in Kubernetes.
    As expected, there should be at least one container running the web server. However,
    there is an additional requirement of continuous source code synchronization.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下活动中，将在Kubernetes中安装一个基于Web的游戏。正如预期的那样，应该至少有一个容器在运行Web服务器。然而，还有一个附加要求是持续的源代码同步。
- en: With the Unix philosophy, it is expected to make containers with only one primary
    task. They should also work independently and together to achieve the necessary
    requirements. Finally, these containers should update their statuses, informing
    the console as log lines. All three of these points are covered in the following
    activity.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Unix哲学，期望容器只承担一个主要任务。它们还应该独立工作，并且协同工作以实现必要的需求。最后，这些容器应该更新它们的状态，并将日志信息通知控制台。以下活动将涵盖这三点。
- en: 'Activity: Running a Web Server with Synchronization'
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：运行带同步功能的Web服务器
- en: '**Scenario**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: You are assigned the task of making a Kubernetes installation for a web-based
    2048 game. However, the game is still in development and developers push frequent
    changes throughout the day. In this installation, the game should be frequently
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你被分配的任务是在Kubernetes中部署一个基于Web的2048游戏。然而，游戏仍在开发中，开发人员一天之内会频繁推送更改。在这个安装中，游戏应该经常
- en: updated to include the recent changes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更新以包括最近的更改。
- en: '**Aim**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: With the successful deployment, there should be a pod running in Kubernetes
    with two containers. One of the containers should serve the game and the other
    container, namely the sidecar container, should continuously update the source
    code of the game. Using Kubernetes, you need to create a cloud-native solution
    where the server and synchronization tasks are working together, but not depending
    on each other.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功部署后，Kubernetes中应该有一个Pod正在运行，且包含两个容器。一个容器应该负责提供游戏，另一个容器，即sidecar容器，应该持续更新游戏的源代码。通过Kubernetes，你需要创建一个云原生解决方案，其中服务器和同步任务协同工作，但彼此独立。
- en: '**Prerequisites**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**前提条件**'
- en: Use a git Docker image for continuous synchronization in the sidecar container
    and an open source code repository for the 2048 game.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用git Docker镜像进行sidecar容器中的持续同步，并且使用2048游戏的开源代码库。
- en: '**Steps for Completion**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Create a pod definition.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Pod定义。
- en: 'Include two containers:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括两个容器：
- en: httpd for game serving.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用httpd为游戏提供服务。
- en: git for source code synchronization.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用git进行源代码同步。
- en: Deploy the pod.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署Pod。
- en: Show the logs of the synchronization.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示同步的日志。
- en: Check whether the game has started.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查游戏是否已启动。
- en: All of the code files for the activities in this chapter are provided on GitHub
    in the `Lesson-1` folder at [https://goo.gl/gM8W3p](https://goo.gl/gM8W3p).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码文件都可以在 GitHub 上的 `Lesson-1` 文件夹中找到，网址是 [https://goo.gl/gM8W3p](https://goo.gl/gM8W3p)。
- en: 'You are expected to create a 2048 game, like the one shown in the following
    screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要创建一个 2048 游戏，如下图所示：
- en: '![](img/85de6e3a-ae1c-4611-8483-724a032d8027.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85de6e3a-ae1c-4611-8483-724a032d8027.png)'
- en: Initialization Pattern
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化模式
- en: 'Initialization is a widespread pattern in every part of software engineering,
    including programming languages and operating systems. In order to handle the
    initialization of an application in Kubernetes, initialization containers are
    proposed. Initialization containers, namely **initContainers**, are part of a
    pod''s definition. Separation of concerns is handled by separating the life cycles
    of containers:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化是软件工程各个领域的广泛模式，包括编程语言和操作系统。为了处理 Kubernetes 中应用的初始化，提出了初始化容器。初始化容器，也叫**initContainers**，是
    pod 定义的一部分。通过将容器的生命周期分离来处理关注点分离：
- en: Init containers
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化容器
- en: Main containers
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主容器
- en: 'Containers that are defined as initContainers are executed for completion one
    by one, and they are all expected to exit successfully. After successful completion,
    the main containers are started. Some of the example uses of startup containers
    are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为 initContainers 的容器会依次执行，且都期望成功退出。完成后，主容器将启动。以下是启动容器的一些示例用途：
- en: To create configuration files
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建配置文件
- en: To wait and ensure dependency services are available
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待并确保依赖服务可用
- en: To create volumes and prepare files
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建卷并准备文件
- en: To register services to discovery systems
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务注册到发现系统
- en: In the following activity, a web server will be installed in Kubernetes. As
    expected, there should be at least one container running the web server. However,
    there is an additional requirement of changing the served files before the web
    server starts. The life cycle of these operations is separated into the initialization
    container and the main container. These containers could have different container
    images and executables; however, they are expected to work on a shared resource.
    Life cycle separation and working together issues are handled in the following
    activity, and the initialization pattern is implemented in Kubernetes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的活动中，将在 Kubernetes 中安装一个 Web 服务器。如预期所示，应该至少有一个容器正在运行 Web 服务器。然而，还有一个附加要求，即在
    Web 服务器启动之前更改提供的文件。这些操作的生命周期被分离到初始化容器和主容器中。这些容器可能具有不同的容器镜像和可执行文件；然而，它们预计会在共享资源上工作。生命周期分离和协作问题将在接下来的活动中处理，并在
    Kubernetes 中实现初始化模式。
- en: 'Activity: Running a Web Server after Content Preparation'
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：在内容准备完成后运行 Web 服务器
- en: '**Scenario**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: You are assigned the task of making a Kubernetes installation for a web server.
    However, there are some manual tasks to be carried out to change the files before
    serving them. You need to ensure that changes are always applied before the content
    is served. Besides this, show the status of the initialization and check the final
    output of the web server.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你被分配了一个任务，需要为一个 Web 服务器制作 Kubernetes 安装。然而，在提供服务之前，需要执行一些手动任务来更改文件。你需要确保在内容提供之前始终应用这些更改。此外，还需要显示初始化的状态，并检查
    Web 服务器的最终输出。
- en: '**Aim**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: With the successful deployment, there should be a pod running in Kubernetes
    with one main container and one initialization container. In the initialization
    container, write `Welcome from Packt` to the main index file. This file should
    be served by the main container when started.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功部署后，Kubernetes 中应该有一个 pod 正在运行，包含一个主容器和一个初始化容器。在初始化容器中，将 `Welcome from Packt`
    写入主索引文件。当主容器启动时，该文件应由主容器提供服务。
- en: '**Prerequisites**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**前提条件**'
- en: Use a basic Docker image for the initialization container, such as busybox.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本的 Docker 镜像作为初始化容器，例如 busybox。
- en: For the main container, a web server capable image should be used, such as nginx.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于主容器，应使用一个能够运行 Web 服务器的镜像，例如 nginx。
- en: '**Steps for Completion**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Create a pod definition.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 pod 定义。
- en: 'Include one initialization container:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含一个初始化容器：
- en: Change the content of the files.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改文件的内容。
- en: 'Include one main container:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含一个主容器：
- en: Create a web server.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 Web 服务器。
- en: Deploy the pod.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署 pod。
- en: Check the status of the initialization container.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查初始化容器的状态。
- en: Check the output of the web server.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 Web 服务器的输出。
- en: 'You should see the following output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/97cedeec-3404-425d-a0bb-3f06712a0ff4.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97cedeec-3404-425d-a0bb-3f06712a0ff4.png)'
- en: All of the code files for the activities in this chapter are provided on GitHub
    in the `Lesson-1` folder at [https://goo.gl/gM8W3p](https://goo.gl/gM8W3p).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中活动的所有代码文件都可以在 GitHub 的 `Lesson-1` 文件夹中找到，链接地址：[https://goo.gl/gM8W3p](https://goo.gl/gM8W3p)。
- en: Behavioral Patterns
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为模式
- en: In software development, behavioral design patterns focus on the communication
    and interaction between objects. Interaction and communication includes responsibility
    assignment, the encapsulation of behaviors, and the delegation of requests. With
    the microservice architecture, behavioral patterns focus on the communication
    between microservices and the interaction of services with orchestration tools.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，行为设计模式专注于对象之间的通信和交互。交互和通信包括责任分配、行为封装和请求委托。在微服务架构中，行为模式专注于微服务之间的通信以及服务与编排工具的交互。
- en: For instance, let's consider the execution of a microservice that checks a user's
    quota daily. It can be implemented by an infinite loop that includes 24 hours
    of sleep and the execution of the quota check. Although it works, it consumes
    additional resources during sleep and creates an inefficient architecture. With
    the behavioral pattern of the "scheduled job pattern," orchestration tools could
    handle the scheduling of the microservice and ensure that it runs every 24 hours.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们考虑一个每天检查用户配额的微服务执行。它可以通过一个包含 24 小时睡眠和执行配额检查的无限循环来实现。尽管它有效，但在睡眠期间会消耗额外资源，且创建了低效的架构。通过“定时作业模式”的行为模式，编排工具可以处理微服务的调度，并确保它每
    24 小时执行一次。
- en: In Kubernetes, containers are encapsulated inside pods, which are the primary
    interest of behavioral patterns. Behavioral patterns are focused on the interaction
    and communication of the Kubernetes resources, namely pods, with the Kubernetes
    services. Communication and interaction within the controller system could include
    the distribution of pods to nodes, the scheduling of pods, or metadata distribution
    by the Kubernetes master and node components.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，容器被封装在 Pod 内，Pod 是行为模式的主要关注点。行为模式专注于 Kubernetes 资源之间的交互和通信，即
    Pod 与 Kubernetes 服务之间的交互。控制器系统中的通信和交互可能包括将 Pod 分配到节点、Pod 的调度，或由 Kubernetes 主控和节点组件进行元数据分发。
- en: 'The following behavioral patterns are covered in the following sections:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行为模式将在接下来的章节中介绍：
- en: The job pattern
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作业模式
- en: The scheduled job pattern
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时作业模式
- en: The daemon service pattern
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 守护进程服务模式
- en: The singleton service pattern
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例服务模式
- en: The introspective pattern
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内省模式
- en: Job Pattern
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业模式
- en: The general use case of pods in Kubernetes is that they are used for long-running
    processes that are always up. To this aim, Kubernetes provides higher-level resources
    such as replication sets or deployments. These high-level resources manage the
    life cycles of pods by creating replicas, checking for health statuses, and controlling
    update mechanisms. On the other hand, there is a need for microservices that do
    one job and successfully exit upon completion. For instance, database initializations,
    backups, or converting a video should run once and exit without consuming any
    extra resources. For this requirement, Kubernetes provides a higher-level resource
    named Job. Kubernetes jobs represent an isolated work run until completion and
    are ideal for use cases that are required to only run once.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，Pod 的一般使用场景是用于长时间运行、始终保持启动的进程。为此，Kubernetes 提供了更高级别的资源，如副本集或部署。这些高级资源通过创建副本、检查健康状态和控制更新机制来管理
    Pod 的生命周期。另一方面，微服务有时需要执行一个任务，并在完成后成功退出。例如，数据库初始化、备份或视频转换等应该只执行一次并退出，不消耗额外的资源。针对这种需求，Kubernetes
    提供了一个名为 Job 的高级资源。Kubernetes 作业表示一个独立的工作执行直到完成，非常适合只需要运行一次的用例。
- en: 'The most important difference between jobs and replication-controlled pods
    is the `restartPolicy` field:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作业和由副本控制的 Pod 之间最重要的区别是 `restartPolicy` 字段：
- en: For always running pods, the `restartPolicy` is set to `Always`
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于始终运行的 Pod，`restartPolicy` 被设置为 `Always`
- en: For jobs, the `restartPolicy` could be set as `OnFailure` or `Never`
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于作业，`restartPolicy` 可以设置为 `OnFailure` 或 `Never`
- en: Scheduled Job Pattern
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时作业模式
- en: Distributed systems and the microservices architecture do not rely on temporal
    events for running services; instead, they focus on triggers such as HTTP requests,
    new database entries, or messaging queues. However, scheduling a task and expecting
    it to run at specified intervals are common approaches that are part of the "Scheduled
    Job Pattern". Microservices for maintenance operations, sending daily emails,
    or checking for old files should be scheduled at fixed intervals and must run
    to meet business needs. Kubernetes provides the CronJob resource for creating
    scheduled tasks, and it ensures that these jobs are running.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统和微服务架构不依赖于时间性事件来运行服务；相反，它们关注触发事件，如HTTP请求、新的数据库条目或消息队列。然而，调度任务并期望它在指定时间间隔内运行是“定时作业模式”的常见方法。用于维护操作、发送每日电子邮件或检查过期文件的微服务应按固定间隔调度，并且必须运行以满足业务需求。Kubernetes提供CronJob资源来创建定时任务，并确保这些作业在运行。
- en: Daemon Service Pattern
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 守护进程服务模式
- en: 'Daemon applications are commonly used in operating systems and programming
    languages as long-running applications or threads that run as background processes.
    The names of the daemon applications are httpd, sshd, and containerd; the trailing
    letter indicates that the services are daemons. Within the microservice architecture,
    some services should run and scale without any relation to consumer usage. These
    applications should run on every node in the cluster to ensure the daemon application''s
    requirements, such as:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程应用程序通常用于操作系统和编程语言中，作为长期运行的应用程序或线程，以后台进程的形式运行。守护进程应用程序的名称包括httpd、sshd和containerd；结尾的字母表示这些服务是守护进程。在微服务架构中，有些服务应该独立运行和扩展，而与消费者使用无关。这些应用程序应该在集群中的每个节点上运行，以确保守护进程应用程序的要求，例如：
- en: '**Cluster storage daemons**: glusterd, ceph.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群存储守护进程**：glusterd，ceph。'
- en: '**Log collection daemons**: fluentd, logstash.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志收集守护进程**：fluentd，logstash。'
- en: '**Node monitoring daemons**: collectd, Datadog agent, New Relic agent.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点监控守护进程**：collectd，Datadog代理，New Relic代理。'
- en: In Kubernetes, **DaemonSets** are designed for deploying ongoing background
    tasks that need to run on all or certain nodes. Without any further management
    considerations, Kubernetes handles running these daemon pods on the newly joined
    nodes in the cluster.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，**DaemonSets**旨在部署需要在所有或某些节点上运行的持续后台任务。在没有其他管理考虑的情况下，Kubernetes会自动处理这些守护进程Pod在新加入节点上的运行。
- en: Singleton Service Pattern
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例服务模式
- en: 'Running one – and only one – instance is a requirement for applications, since
    multiple instances could create instability. Although it seems to be against the
    scalable microservice architecture, there are some applications that are required
    to follow the singleton pattern:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一个——且仅有一个——实例是应用程序的要求，因为多个实例可能会导致不稳定。尽管这似乎与可扩展的微服务架构相悖，但仍有一些应用程序需要遵循单例模式：
- en: Database instances and connectors
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库实例和连接器
- en: Configuration managers
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置管理器
- en: Applications that do not scale yet
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尚未扩展的应用程序
- en: Kubernetes StatefulSet with a replica count of 1 ensures that only instances
    of the pod are running in the cluster. With this small configuration, singleton
    services can be created and used in a cloud-native environment. However, having
    only one instance of an application in the cluster comes with its drawbacks. For
    instance, handling the downtime of singleton applications should be handled with
    care. The primary concern for this issue is how to handle downtime due to the
    automatic
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes StatefulSet的副本数为1，确保集群中只运行一个Pod实例。通过这种小型配置，可以在云原生环境中创建并使用单例服务。然而，集群中只有一个应用实例也带来了缺点。例如，应该小心处理单例应用程序的停机问题。这个问题的主要关注点是如何处理由于自动
- en: 'update of Statefulset. There are two possible solutions in Kubernetes:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSet的更新。在Kubernetes中有两种可能的解决方案：
- en: Tolerate occasional downtime during updates
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容忍更新期间的偶尔停机
- en: 'Set `PodDistruptionBudget` with `minAvailable=1`:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置`PodDistruptionBudget`，`minAvailable=1`：
- en: Eliminate the automatic update since `PodDistruptionBudget` is set
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于已设置`PodDistruptionBudget`，取消自动更新
- en: Prepare for disruption by operational steps
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过操作步骤为中断做准备
- en: Delete the `PodDistruptionBudget` resource and let the update continue
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除`PodDistruptionBudget`资源并继续更新
- en: Recreate `PodDistruptionBudget` for the next disruption
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为下次中断重新创建`PodDistruptionBudget`
- en: Introspective Pattern
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内省模式
- en: Applications that run on bare-metal clusters know precisely where they are running,
    the specification of the system, and their network information. This information
    helps them to work in a self-aware environment. For instance, these applications
    can align their resource usage, enhance their logs with more data, or send their
    node-related metric data. In the microservice architecture, applications are considered
    ephemeral with less dependency than the environment they are running on. However,
    self-awareness about runtime information, namely the introspective pattern, could
    increase the utility and discoverability of applications in distributed systems.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在裸金属集群上的应用程序能够准确知道它们运行的位置、系统规格以及网络信息。这些信息帮助它们在自我感知的环境中工作。例如，这些应用可以调整资源使用，增强日志内容，或者发送与节点相关的度量数据。在微服务架构中，应用程序被认为是短暂的，其对环境的依赖较少。然而，对运行时信息的自我感知，即内省模式，可以提高应用在分布式系统中的实用性和可发现性。
- en: 'In Kubernetes, the Downward API ensures that the following environment and
    runtime data is provided for the pods:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，Downward API 确保为 pod 提供以下环境和运行时数据：
- en: '**Environment:** Node name, namespace, CPU, and memory limitations.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境：** 节点名称、命名空间、CPU 和内存限制。'
- en: '**Networking:** Pod IP.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络配置：** Pod IP。'
- en: '**Authorization:** Service account.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权：** 服务账户。'
- en: In the following activity, a simple but self-aware Kubernetes application will
    be created and installed. The application has all of the runtime information,
    which is provided by Kubernetes as environment variables. Being a single application,
    it logs all of these variables to the console. However, the pod definition that's
    developed throughout this activity shows you how to use the Downward API inside
    containers to implement an introspective pattern in Kubernetes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下活动中，将创建并安装一个简单但具备自我感知的 Kubernetes 应用程序。该应用程序拥有所有的运行时信息，这些信息由 Kubernetes 作为环境变量提供。作为单一应用，它将所有这些变量记录到控制台。然而，本活动中开发的
    pod 定义展示了如何在容器内部使用 Downward API 来实现 Kubernetes 中的内省模式。
- en: 'Activity: Injecting Data into Applications'
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：将数据注入应用程序
- en: '**Scenario**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: You are assigned the task of making a Kubernetes installation for a simple application
    with self-awareness. In this installation, the application should collect all
    the runtime information from Kubernetes and write to its logs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你被指派的任务是为一个简单的具备自我感知功能的应用程序做 Kubernetes 安装。在这个安装中，应用程序应收集来自 Kubernetes 的所有运行时信息并写入其日志。
- en: '**Aim**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: With the successful deployment, there should be a pod running in Kubernetes
    with only one container. In this container, all available runtime information
    should be injected as environment variables. Also, the application should log
    runtime information.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功部署后，Kubernetes 中应有一个仅包含一个容器的 pod 在运行。在这个容器中，所有可用的运行时信息应作为环境变量注入。此外，应用程序应记录运行时信息。
- en: '**Prerequisites**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**前提条件**'
- en: Use the Kubernetes Downward API to collect runtime information.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes Downward API 收集运行时信息。
- en: '**Steps for Completion**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: 'Create a pod definition with one container:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含一个容器的 pod 定义：
- en: Define the environment variables from the Downward API.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Downward API 定义环境变量。
- en: Create a shell script to write the environment variables.
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 shell 脚本以写入环境变量。
- en: Deploy the pod.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署 pod。
- en: Check the status of the pod.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 pod 的状态。
- en: Check the logs of the container.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查容器的日志。
- en: All of the code files for the activities in this chapter are provided on GitHub
    in the `Lesson-1` folder at [https://goo.gl/gM8W3p](https://goo.gl/gM8W3p).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本章活动的所有代码文件已上传至 GitHub，位于 `Lesson-1` 文件夹，地址为 [https://goo.gl/gM8W3p](https://goo.gl/gM8W3p)。
- en: Deployment Strategies
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署策略
- en: Designing and developing cloud-native applications with the microservice architecture
    is essential for reliable and scalable applications of the future. Likewise, deploying
    and updating applications in the cloud is as critical as design and development.
    There are various techniques for delivering applications, and therefore choosing
    the right setup is essential to leverage the impact of change on the consumers.
    Using the right subset of Kubernetes resources and choosing an appropriate deployment
    strategy, scalable and reliable cloud-native applications are feasible.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和开发云原生应用程序，并采用微服务架构，对于未来的可靠且可扩展的应用至关重要。同样，云中的应用程序部署和更新与设计和开发一样重要。交付应用程序有多种技术，因此选择合适的配置对于最大限度地利用变更对消费者的影响至关重要。通过使用合适的Kubernetes资源子集并选择合适的部署策略，可以实现可扩展和可靠的云原生应用。
- en: 'In this section, the following deployment strategies are presented, and you
    are expected to complete these exercises so that they can see the Kubernetes resources
    in action:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，介绍了以下部署策略，并且你需要完成这些练习，以便能够看到Kubernetes资源的实际操作：
- en: Recreate strategy
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重建策略
- en: Rolling update strategy
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动更新策略
- en: Blue/green strategy
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝绿策略
- en: A/B testing strategy
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A/B 测试策略
- en: Recreate Strategy
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重建策略
- en: The recreate strategy is based on the idea of closing old version instances
    and then creating the next version's. With this strategy, it is inevitable to
    have downtime, depending on both the shutdown and start duration of applications.
    In Kubernetes, the recreate strategy can be used for creating deployment resources
    with the strategy of recreate.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 重建策略基于关闭旧版本实例，然后创建下一个版本实例的思想。使用这种策略时，停机是不可避免的，这取决于应用程序的关闭和启动时间。在Kubernetes中，可以使用重建策略来创建部署资源，并采用重建策略。
- en: 'The rest of the operations are handled by Kubernetes. Under the hood, the steps
    of the recreate strategy are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的操作由Kubernetes处理。在幕后，重建策略的步骤如下：
- en: 'Requests from users are routed to **V1** instances by using a load balancer:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户请求通过负载均衡器路由到**V1**实例：
- en: '![](img/3fa1ecdc-f978-421f-9b08-34e379187f7c.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fa1ecdc-f978-421f-9b08-34e379187f7c.png)'
- en: '**V1** instances are closed, and downtime has started since there is no available
    instance:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**V1**实例被关闭，且由于没有可用的实例，停机时间已开始：'
- en: '![](img/9a6d3f60-4721-4ddd-80ed-00a168eebd3b.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a6d3f60-4721-4ddd-80ed-00a168eebd3b.png)'
- en: '**V2** instances are created; however, they are not serving to the requests
    until they are ready:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**V2**实例被创建；然而，直到它们准备好之前，不会处理用户请求：'
- en: '![](img/38e97134-fe36-4db0-8736-502a2f511080.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38e97134-fe36-4db0-8736-502a2f511080.png)'
- en: 'Requests from users are routed to **V2** instances:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户请求被路由到**V2**实例：
- en: '![](img/d495b280-8f6c-4d74-98ee-befcbcdb1632.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d495b280-8f6c-4d74-98ee-befcbcdb1632.png)'
- en: The primary benefits of the recreate strategy are that it's straightforward
    and not doesn't have any overhead processes. Besides this, the instances are completely
    renewed with every update, and there is not a time where two versions are running
    together. However, the downside of this strategy is an inevitable downtime during
    the update.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 重建策略的主要优点是其简单明了，并且没有额外的开销。除此之外，每次更新时，实例都会完全重建，并且不会有两个版本同时运行。然而，这种策略的缺点是在更新过程中不可避免地会有停机时间。
- en: Deploying the Application Using the Recreate Strategy
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用重建策略部署应用
- en: You are running a high-available application on Kubernetes that needs a deployment
    strategy to handle updates. This application can resist the short span of downtimes;
    however, there should not be any moment where two versions are running together.
    This application consumes services that cannot handle working with two different
    versions at the same time. We want to run an application with the recreate deployment
    strategy so that updates will be handled by Kubernetes by deleting old instances
    and creating new ones.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在Kubernetes上运行一个高可用性应用，需要一个部署策略来处理更新。这个应用能够承受短暂的停机时间，但不应有任何时候两个版本一起运行。这个应用依赖的服务无法处理同时运行两个不同版本的情况。我们希望使用重建部署策略，这样Kubernetes就能通过删除旧实例并创建新实例来处理更新。
- en: 'You can find the `recreate.yaml` file at: [https://goo.gl/2woHbx](https://goo.gl/2woHbx).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接找到`recreate.yaml`文件：[https://goo.gl/2woHbx](https://goo.gl/2woHbx)。
- en: 'Let''s begin by following these steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始：
- en: 'Create the deployment with the following command:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建部署：
- en: '[PRE0]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In a separate terminal, watch for the deployment changes and wait until all
    three are available:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端中，监控部署变化，直到所有三个实例都可用：
- en: '[PRE1]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Update the version of the deployment:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新部署的版本：
- en: '[PRE2]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the terminal that we opened in *Step 2*, it is expected that you should
    see the deletion of the pods and the downtime, where `Available` reaches zero.
    Afterward, the creation of new instances can be tracked, where `Available` increases
    from `0` to `3`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们在*步骤 2*中打开的终端中，应该能够看到pod的删除和停机情况，此时`Available`为零。之后，可以跟踪新实例的创建，`Available`从`0`增加到`3`：
- en: '![](img/d454aa26-432c-4254-95b7-f6bce2eeeabd.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d454aa26-432c-4254-95b7-f6bce2eeeabd.png)'
- en: 'You can run the following command for cleanup:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以运行以下命令进行清理：
- en: '[PRE3]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Rolling Update Strategy
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动更新策略
- en: The rolling update strategy, which is also known as incremental or ramped, is
    based on the idea of slowly rolling out a version by replacing the previous ones.
    In this strategy, firstly, a pool of applications is running behind a load balancer.
    Then, new version instances are started, and when they are up and running, the
    load balancer redirects requests to the new instances. At the same time, instances
    from the previous versions are shut down. In Kubernetes, the rolling update strategy
    is the default strategy in deployments, so any update on the *deployment* is already
    implementing the rolling update strategy.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动更新策略，也称为增量或逐步更新，是通过替换先前版本来慢慢发布新版本的策略。在此策略中，首先，一组应用程序在负载均衡器后面运行。然后，启动新版本实例，当它们启动并运行时，负载均衡器将请求重定向到新实例。同时，之前版本的实例将被关闭。在Kubernetes中，滚动更新策略是部署的默认策略，因此对*deployment*的任何更新都已经在实施滚动更新策略。
- en: 'While Kubernetes handles this, the steps of the rolling strategy can be tracked
    as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes处理此过程时，滚动更新策略的步骤可以如下跟踪：
- en: 'Requests from users are routed to **V1** instances by using a load balancer:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户的请求通过负载均衡器路由到**V1**实例：
- en: '![](img/0707a0f0-02c2-415c-9215-a3b8c0163a68.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0707a0f0-02c2-415c-9215-a3b8c0163a68.png)'
- en: '**V2** instances are created, and users are directed to them. At the same time,
    **V1** instances are deleted. During this stage, both versions are running and
    serving requests:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**V2**实例被创建，用户被引导到它们，同时，**V1**实例被删除。在这个阶段，两个版本都在运行并提供请求服务：'
- en: '![](img/a5f35b30-2119-44ad-b308-bcfa89c94766.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5f35b30-2119-44ad-b308-bcfa89c94766.png)'
- en: 'Creating **V2** instances and the deletion of **V1** instances is done one
    at a time until there are no **V1** instances left:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**V2**实例的创建和**V1**实例的删除是逐一进行，直到没有**V1**实例剩余：'
- en: '![](img/9462c465-a2ff-48cd-a6c8-3f107f38e8b5.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9462c465-a2ff-48cd-a6c8-3f107f38e8b5.png)'
- en: 'Finally, all requests from all users are routed to **V2** instances:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，所有来自用户的请求都被路由到**V2**实例：
- en: '![](img/1bf167fe-323b-4530-9eff-3680ba2479b5.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bf167fe-323b-4530-9eff-3680ba2479b5.png)'
- en: The main advantage of the rolling update strategy is that it is easy and is
    the default approach of Kubernetes. It is also beneficial for a slow release of
    new versions by balancing the load during the startup of new instances. On the
    other hand, Kubernetes automatically handles rollout and rollback, and the duration
    of these operations are not known. One of the most complicated problems in rolling
    updates is that two versions are running at the same time in the cluster, and
    the traffic is not under control.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动更新策略的主要优点是简单易行，并且是Kubernetes的默认方法。它还有助于通过在新实例启动期间平衡负载，慢慢发布新版本。另一方面，Kubernetes自动处理版本的发布和回滚，且这些操作的持续时间无法预知。滚动更新中最复杂的问题之一是集群中两个版本同时运行，且流量无法控制。
- en: Deploying an Application Using the Rolling Update Strategy
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用滚动更新策略部署应用程序
- en: 'You are running a high-available application on Kubernetes that needs a deployment
    strategy to handle updates. This application, let''s say, the frontend of your
    client''s company, should always be available so that downtime is out of the question.
    Multiple versions of the applications could be working together at any time; however,
    the client does not want to cover the cost of extra resources during the update.
    We''ll run an application with the rolling update deployment strategy so that
    updates will be handled by Kubernetes by incrementally creating new instances
    and deleting old instances, one after another. Let''s begin by following these
    steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在Kubernetes上运行一个高可用的应用程序，需要一个部署策略来处理更新。假设这个应用程序是你客户公司的前端，必须始终保持可用，停机是不可接受的。在任何时候，多个版本的应用程序都可能同时工作；然而，客户不希望在更新过程中增加额外资源的成本。我们将使用滚动更新部署策略来运行应用程序，以便Kubernetes通过增量创建新实例并逐个删除旧实例来处理更新。我们按照以下步骤开始：
- en: 'Create the deployment with the following command:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建部署：
- en: '[PRE4]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In a separate terminal, start a cURL instance in the Kubernetes cluster:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端中，启动Kubernetes集群中的cURL实例：
- en: '[PRE5]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the Command Prompt is ready, watch for the version of the deployment by
    using an HTTP request:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当命令提示符准备好时，通过使用HTTP请求查看部署的版本：
- en: '[PRE6]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Update the version of the deployment with the following command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令更新部署的版本：
- en: '[PRE7]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the terminal that we opened in *Step 2*, it is expected that we should see
    Kubernetes handle an incremental change of versions. During the update, there
    is no interruption of the service. However, both versions are alive and serving
    requests as 1.10.3 and 1.11.13, and are used interchangeably:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们在*步骤 2*中打开的终端中，预计我们应该看到Kubernetes处理版本的增量变化。在更新过程中，服务不会中断。然而，两个版本同时运行，并且处理请求的版本分别是1.10.3和1.11.13，并且它们可以互换使用：
- en: '![](img/d8d68db0-6c48-4443-a634-9be83d2c51cd.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8d68db0-6c48-4443-a634-9be83d2c51cd.png)'
- en: 'For cleanup, stop the cURL command with *Ctrl* + *C* and exit from the pod
    by writing exit. The pod will be deleted by Kubernetes upon exit. Run the following
    command:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理时，使用*Ctrl* + *C*停止cURL命令并通过输入exit退出Pod。退出时，Pod会被Kubernetes删除。运行以下命令：
- en: '[PRE8]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can find the `rolling.yaml` file at: [https://goo.gl/eo8cJw](https://goo.gl/eo8cJw).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下位置找到`rolling.yaml`文件：[https://goo.gl/eo8cJw](https://goo.gl/eo8cJw)。
- en: Blue/Green Strategy
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝绿策略
- en: The blue/green strategy is the idea of having two active production environments,
    namely blue and green. The blue environment is active and serving requests. The
    green environment has the new version, and it is being tested for the update.
    When the tests are completed successfully, the load balancer is switched from
    blue to green instances. In Kubernetes, blue/green deployment is handled by installing
    both versions and then changing the configuration of a service or resource.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿策略的思想是有两个活跃的生产环境，即蓝色和绿色。蓝色环境是活跃的并且在处理请求。绿色环境包含新版本，并且正在进行更新测试。当测试成功完成后，负载均衡器会从蓝色实例切换到绿色实例。在Kubernetes中，蓝绿部署是通过安装两个版本并更改服务或资源的配置来处理的。
- en: 'The main steps of the blue/green strategy can be defined as follows:Both the
    **V1** and **V2** instances are deployed, and the load balancer is configured
    for **V1** instances:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 蓝绿策略的主要步骤可以定义如下：**V1**和**V2**实例都已部署，负载均衡器已为**V1**实例配置：
- en: '![](img/af597763-50de-41f6-ba77-492ff0ccd5bd.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af597763-50de-41f6-ba77-492ff0ccd5bd.png)'
- en: 'After testing, the load balancer is configured for route **V2** instances:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试后，负载均衡器已为**V2**实例配置：
- en: '![](img/aa4fe476-3a42-40f5-a90c-243e8b840c04.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa4fe476-3a42-40f5-a90c-243e8b840c04.png)'
- en: Advantages of the blue/green strategy include instant rollout and rollback,
    and no version mismatch during the update. On the other hand, a drawback of this
    strategy is that you are using double the resources since two environments are
    maintained. It should be noted that exhaustive end-to-end testing of applications
    should be handled before using this strategy.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿策略的优点包括即时的发布和回滚，以及在更新过程中没有版本不匹配。另一方面，这种策略的缺点是你需要使用双倍的资源，因为需要维护两个环境。需要注意的是，在使用此策略之前，应该进行详尽的端到端应用程序测试。
- en: Deploying an Application Using the Blue/Green Strategy
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蓝绿策略部署应用程序
- en: 'You are running a high-available application on Kubernetes that needs a deployment
    strategy to handle updates. This application, for example, a mortgage calculation
    engine API, has different versions, which result in different calculation results.
    Therefore, the client requires extensive testing before release and instant switches
    between the versions. We''ll run an application with blue/green strategy so that
    both versions are running, and Kubernetes service handles instant switch of version.
    We''ll run an application with blue/green strategy so that both versions are running,
    and Kubernetes service handles instant switch of version. Let''s begin by performing
    the following steps:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在 Kubernetes 上运行一个高可用的应用，需要一个部署策略来处理更新。例如，这个应用是一个抵押贷款计算引擎 API，拥有不同版本，因此会导致不同的计算结果。因此，客户端需要在发布前进行广泛的测试，并且能够在版本之间进行即时切换。我们将使用蓝绿部署策略运行一个应用，使得两个版本都在运行，并且
    Kubernetes 服务处理版本的即时切换。让我们开始执行以下步骤：
- en: 'Create both versions of the deployment and the common service with the following
    command:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建部署的两个版本以及公共服务：
- en: '[PRE9]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Check that both versions are deployed on the cluster with the following command:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查集群中是否部署了两个版本：
- en: '[PRE10]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should see the following output:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/f3d121b9-05cb-4d96-b5a1-c5fb200b00bf.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3d121b9-05cb-4d96-b5a1-c5fb200b00bf.png)'
- en: 'In a separate terminal, start a cURL instance in the Kubernetes cluster:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个单独的终端中，启动 Kubernetes 集群中的 cURL 实例：
- en: '[PRE11]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the command prompt is ready, watch for the version of the deployment by
    using an HTTP request:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当命令提示符准备好时，通过使用 HTTP 请求监控部署的版本：
- en: '[PRE12]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Update the service to route traffic to the new version with the following command:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令更新服务，将流量路由到新版本：
- en: '[PRE13]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the terminal that we opened in Step 3, we should see the Kubernetes service
    handling an instant change of versions without any interruption:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们在第 3 步中打开的终端中，我们应该看到 Kubernetes 服务在没有任何中断的情况下处理版本的即时切换：
- en: '![](img/dfd8eddc-0b64-47c8-9d92-f6995b3f476d.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfd8eddc-0b64-47c8-9d92-f6995b3f476d.png)'
- en: 'For cleanup, stop the cURL command with *Ctrl* + *C* and exit from the pod
    by writing exit. The pod will be deleted by Kubernetes upon exit. Run the following
    command:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清理，使用 *Ctrl* + *C* 停止 cURL 命令，并通过输入 exit 退出 pod。退出时，Kubernetes 将删除该 pod。运行以下命令：
- en: '[PRE14]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A/B Testing Strategy
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A/B 测试策略
- en: 'The A/B testing strategy is based on the idea of consumer separation and providing
    different subsets of functionalities. A/B testing allows you to run multiple variants
    of functionality in parallel. With the analytics of user behavior, users can be
    routed to a more appropriate version. The following is a sample list of conditions
    that can be used in order to scatter traffic:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: A/B 测试策略基于消费者分离的思想，并提供不同功能子集。A/B 测试允许你并行运行多个功能变体。通过用户行为分析，可以将用户路由到更合适的版本。以下是可以用于分散流量的条件示例：
- en: Cookies
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cookies
- en: Location
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置
- en: Technology, such as the browser, screen size, and mobility
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术，如浏览器、屏幕大小和移动性
- en: Language
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言
- en: 'In the following image, both versions are installed, and users are routed based
    on their technology characteristics, that is, mobile or desktop:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，两个版本都已安装，用户根据其技术特征（即移动设备或桌面）被路由：
- en: '![](img/4967e855-c0ea-4645-a614-3e5e321fbc9f.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4967e855-c0ea-4645-a614-3e5e321fbc9f.png)'
- en: 'The main advantage of the A/B testing strategy is that you have full control
    over traffic. However, distributing the traffic requires an intelligent load balancer
    other than the regular Kubernetes services. Some of the popular applications for
    this are as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: A/B 测试策略的主要优势在于你可以完全控制流量。然而，分发流量需要一个智能负载均衡器，而不是常规的 Kubernetes 服务。以下是一些流行的应用：
- en: Linkerd
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linkerd
- en: Traefik
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Traefik
- en: NGINX
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NGINX
- en: HAProxy
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HAProxy
- en: Istio
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio
- en: Linkerd, Traefik, NGINX, and HAProxy are data plane applications that focus
    on forwarding and observing network packages between service instances. On the
    other hand, Istio is a control plane application that focuses on the configuration
    and
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Linkerd、Traefik、NGINX 和 HAProxy 是数据平面应用，专注于在服务实例之间转发和观察网络数据包。另一方面，Istio 是一个控制平面应用，专注于配置和
- en: management of proxies that route traffic.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 管理路由流量的代理。
- en: Deployment Strategies Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署策略总结
- en: 'Before choosing a deployment strategy, it should be taken into consideration
    that there is no silver bullet to solve all production environment requirements.
    Therefore, it is crucial to check and compare the advantages and disadvantages
    of strategies and choose the most appropriate one:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择部署策略之前，应该考虑到没有一种“灵丹妙药”能够解决所有生产环境的需求。因此，检查和比较策略的优缺点并选择最合适的方案是至关重要的：
- en: '![](img/701f9765-e455-4e84-8f19-ca2ff8086047.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/701f9765-e455-4e84-8f19-ca2ff8086047.png)'
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, Kubernetes design patterns, which are the best practices for
    cloud-native applications, were presented. Firstly, the idea of design patterns
    was explained by their usage and classification. Following that, Kubernetes design
    patterns were presented, followed by some in-class activities. Kubernetes, being
    the prominent framework for cloud-native applications, has the flexibility and
    coverage to meet every business requirement. However, knowing how to use Kubernetes
    resources compellingly is crucial. This is exactly what we covered in this chapter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Kubernetes 设计模式，这些设计模式是云原生应用程序的最佳实践。首先，通过它们的使用和分类解释了设计模式的概念。接着，介绍了 Kubernetes
    设计模式，并进行了若干课堂活动。作为云原生应用程序的突出框架，Kubernetes 拥有满足所有业务需求的灵活性和覆盖范围。然而，如何有效地使用 Kubernetes
    资源至关重要，这正是本章所讲解的内容。
