- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Demystifying Kubernetes Networking
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密 Kubernetes 网络
- en: This chapter will use the Kubernetes networking model to describe some core
    concepts, as well as how to configure Kubernetes networking on the cluster nodes
    and network policies. We will also learn about how to configure Ingress controllers
    and Ingress resources, how to configure and leverage CoreDNS, and how to choose
    an appropriate container network interface plugin. This content covered in this
    chapter makes up about 20% of the CKA exam.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用 Kubernetes 网络模型描述一些核心概念，以及如何在集群节点上配置 Kubernetes 网络和网络策略。我们还将学习如何配置 Ingress
    控制器和 Ingress 资源，如何配置和利用 CoreDNS，以及如何选择合适的容器网络接口插件。本章内容占 CKA 考试的约 20%。
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将覆盖以下主题：
- en: Understanding the Kubernetes networking model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 网络模型
- en: Configuring Kubernetes networking on the cluster nodes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在集群节点上配置 Kubernetes 网络
- en: Configuring network policies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置网络策略
- en: Configuring Ingress controllers and Ingress resources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Ingress 控制器和 Ingress 资源
- en: Configuring and leveraging CoreDNS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和利用 CoreDNS
- en: Choosing an appropriate container network interface plugin
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的容器网络接口插件
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To get started, we need to make sure your local machine meets the following
    technical requirements:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保您的本地机器满足以下技术要求：
- en: A compatible Linux host. We recommend a Debian-based Linux distribution such
    as Ubuntu 18.04 or later.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个兼容的 Linux 主机。我们推荐使用基于 Debian 的 Linux 发行版，如 Ubuntu 18.04 或更高版本。
- en: Make sure your host machine has at least 2 GB RAM, 2 CPU cores, and about 20
    GB of free disk space.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的主机至少有 2 GB 的内存，2 个 CPU 核心，并且有约 20 GB 的可用磁盘空间。
- en: Understanding the Kubernetes networking model
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 网络模型
- en: Kubernetes is designed to facilitate the desired state management to host containerized
    workloads – these workloads take advantage of sharable compute resources. Kubernetes
    networking resolves the challenge of how to allow different Kubernetes components
    to communicate with each other and applications on Kubernetes to communicate with
    other applications, as well as the services outside of the Kubernetes cluster.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 旨在促进所需状态管理，以托管容器化工作负载——这些工作负载利用了可共享的计算资源。Kubernetes 网络解决了如何允许不同的
    Kubernetes 组件相互通信以及 Kubernetes 上的应用程序如何与其他应用程序通信的问题，还包括 Kubernetes 集群外部的服务。
- en: Hence, the official documentation summarizes those networking challenges as
    container-to-container, pod-to-pod, pod-to-service, external-to-service, and node-to-node
    communications. Now, we are going to break them down one-by-one in this section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，官方文档将这些网络挑战总结为容器间、Pod 间、Pod 与服务、外部与服务、以及节点间通信。现在，我们将在本节中逐一讲解这些内容。
- en: Container-to-container communication
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器间通信
- en: Container-to-container communication mainly refers to the communication between
    containers inside a pod – a multi-container pod is a good example of this. A multi-container
    pod is a pod that contains multiple containers and is seen as a single unit. Within
    a pod, every container shares the networking, which includes the IP address and
    network ports so that those containers can communicate with one another through
    `localhost` or standard **inter-process communications** (**IPC**) such as SystemV
    semaphores or POSIX shared memory. All listening ports are accessible to other
    containers in the pod even if they’re not exposed outside the pod.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 容器间通信主要指的是 Pod 内容器之间的通信——多容器 Pod 是一个很好的例子。多容器 Pod 是一个包含多个容器的 Pod，并视为一个单一单元。在
    Pod 内部，每个容器共享网络，包括 IP 地址和网络端口，使得这些容器可以通过 `localhost` 或标准的 **进程间通信** (**IPC**)
    方式，如 SystemV 信号量或 POSIX 共享内存，彼此通信。即使这些端口没有暴露到 Pod 外部，Pod 内的其他容器仍然可以访问所有监听端口。
- en: 'The following figure shows how those containers share a local network with
    each other inside the same pod:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了这些容器如何在同一个 Pod 内部共享本地网络：
- en: '![Figure 7.1 – Multiple containers sharing the pod networking  ](img/Figure_7.01_B18201.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 多个容器共享 Pod 网络](img/Figure_7.01_B18201.jpg)'
- en: Figure 7.1 – Multiple containers sharing the pod networking
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 多个容器共享 Pod 网络
- en: The following is an example called `multi-container-pod.yaml` that shows how
    to create multi-containers in a pod. In this pod, it contains `nginx` and `busybox`
    – two containers where `busybox` is a sidecar container that calls `nginx` through
    port `80` on `localhost:`
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个名为`multi-container-pod.yaml`的示例，展示了如何在一个Pod中创建多个容器。在这个Pod中，包含了`nginx`和`busybox`两个容器，其中`busybox`是一个sidecar容器，通过`localhost:`上的端口`80`调用`nginx`。
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s deploy this `yaml` file by using the `kubectl apply -f multi-container-pod.yaml`
    command, and the following shows the pod has been created:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`kubectl apply -f multi-container-pod.yaml`命令部署此`yaml`文件，以下内容显示Pod已创建：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can use the following command to check whether we could talk to the `nginx`
    container from the sidecar `busybox` container:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令检查是否能从sidecar容器`busybox`与`nginx`容器通信：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following output proves that both containers can talk to each other:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出证明两个容器可以互相通信：
- en: '![Figure 7.2 – Connecting to the nginx container from the busybox sidecar ](img/Figure_7.02_B18201.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 从`busybox` sidecar容器连接到`nginx`容器](img/Figure_7.02_B18201.jpg)'
- en: Figure 7.2 – Connecting to the nginx container from the busybox sidecar
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 从`busybox` sidecar容器连接到`nginx`容器
- en: Important Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'A quicker way to create a single container pod by command is by using the following
    command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建单容器Pod的快速方式是使用以下命令：
- en: '`kubectl run nginx --image=nginx:latest --port=80`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl run nginx --image=nginx:latest --port=80`'
- en: Then, you can use the `kubectl get pods –o yaml` command to export the YAML
    content, and edit the `yaml` file to add another container.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用`kubectl get pods –o yaml`命令导出YAML内容，并编辑`yaml`文件以添加另一个容器。
- en: 'To double-check that we did indeed get the `nginx` main page from the `busybox`
    sidecar container, we will use the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了再次确认我们是否从`busybox` sidecar容器获取了`nginx`主页，我们将使用以下命令：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output should look similar to what is shown in *Figure 7.3*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应与*图7.3*中显示的类似：
- en: '![Figure 7.3 – Checking out the downloaded html page in the busybox container  ](img/Figure_7.03_B18201.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 检查在`busybox`容器中下载的HTML页面](img/Figure_7.03_B18201.jpg)'
- en: Figure 7.3 – Checking out the downloaded html page in the busybox container
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 检查在`busybox`容器中下载的HTML页面
- en: To learn more about multi-container pods to see how those containers share storage
    and networking, refer to [*Chapter 4*](B18201_04.xhtml#_idTextAnchor080), *Application
    Scheduling and Lifecycle Management*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于多容器Pod的信息，查看这些容器如何共享存储和网络，请参考[*第4章*](B18201_04.xhtml#_idTextAnchor080)，*应用调度与生命周期管理*。
- en: Pod-to-pod communication
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod与Pod之间的通信
- en: In Kubernetes, each pod has been given a unique IP address based on the `podCIDR`
    range of that worker node. Although this IP assignment is not permanent, as the
    pod eventually fails or restarts, the new pod will be assigned a new IP address.
    By default, pods can communicate with all pods on all nodes through pod networking
    without setting up **Network Address Translation** (**NAT**). This is also where
    we set up host networking. All pods can communicate with each other without NAT.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，每个Pod都被分配了基于该工作节点`podCIDR`范围的唯一IP地址。尽管这种IP分配不是永久性的，因为Pod最终会失败或重启，新Pod将分配一个新的IP地址。默认情况下，Pods可以通过Pod网络与所有节点上的所有Pods通信，而无需设置**网络地址转换**（**NAT**）。这也是我们设置主机网络的地方。所有Pods可以相互通信，而无需NAT。
- en: 'Let’s deploy a `nginx` pod by using the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用以下命令部署一个`nginx` Pod：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following output shows the pod has been created:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示Pod已创建：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To verify whether the pod has been assigned an IP address, you can use the
    `kubectl get pod nginx -o wide` command to check the IP address of the `nginx`
    pod. The output is similar to the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证Pod是否已分配IP地址，您可以使用`kubectl get pod nginx -o wide`命令检查`nginx` Pod的IP地址。输出类似于以下内容：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can use the following command to check all pods available in the default
    namespace and their assigned IP addresses:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令检查默认命名空间中所有可用Pod及其分配的IP地址：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice the `IP` column in the following output – it indicates an IP address
    of `172.17.0.3` for the `multi-container-pod` pod and `172.17.0.4` for the `nginx`
    pod. These IP addresses assigned to those pods are in the same `podCIDR`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下输出中的`IP`列，它指示了`multi-container-pod` Pod的IP地址为`172.17.0.3`，`nginx` Pod的IP地址为`172.17.0.4`。这些分配给Pod的IP地址位于相同的`podCIDR`范围内：
- en: '![Figure 7.4 – Checking out the IP addresses of the pods ](img/Figure_7.04_B18201.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 检查Pod的IP地址](img/Figure_7.04_B18201.jpg)'
- en: Figure 7.4 – Checking out the IP addresses of the pods
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 检查Pod的IP地址
- en: 'The preceding screenshot also indicates that both pods are on the same node,
    `minikube`, according to the `NODE` column. We could check the `podCIDR` assigned
    to the pod by using the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图还显示了两个 pod 在同一节点 `minikube` 上，根据 `NODE` 列可以看到这一点。我们可以使用以下命令查看分配给 pod 的
    `podCIDR`：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output, which looks as follows, shows the `podCIDR`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下所示，显示了 `podCIDR`：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'From the preceding command output, we can see it does not have the same CIDR
    as the pods. That’s because we tested on a `minikube` cluster. When we start a
    vanilla `minikube` installation with the `minikube start` command without specifying
    additional parameters for the CNI network plugin, it sets the default value as
    `auto`. It chooses a `kindnet` plugin to use, which creates a bridge and then
    adds the host and the container to it. We’ll get to know how to set up a CNI plugin
    and network policy later in this chapter. To get to know more about `kindnet`,
    visit the following link: [https://github.com/aojea/kindnet](https://github.com/aojea/kindnet).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的命令输出中，我们可以看到它的 CIDR 与 pod 的 CIDR 不同。这是因为我们在 `minikube` 集群上进行了测试。当我们使用 `minikube
    start` 命令启动一个默认的 `minikube` 安装时，未指定 CNI 网络插件的其他参数，它会将默认值设置为 `auto`。它选择了 `kindnet`
    插件来使用，该插件创建了一个桥接，并将主机和容器添加到桥接中。稍后在本章中，我们将学习如何设置 CNI 插件和网络策略。想了解更多关于 `kindnet`
    的信息，可以访问以下链接：[https://github.com/aojea/kindnet](https://github.com/aojea/kindnet)。
- en: 'Kubernetes components such as system daemons and `kubelet` can communicate
    with all pods on the same node. Understanding the connectivity between pods is
    required for the CKA exam. You can check out the official documentation about
    cluster networking if you want to learn more here: [https://kubernetes.io/docs/concepts/cluster-administration/networking/#the-kubernetes-network-model](https://kubernetes.io/docs/concepts/cluster-administration/networking/#the-kubernetes-network-model).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 组件，如系统守护进程和 `kubelet`，可以与同一节点上的所有 pod 进行通信。理解 pod 之间的连接性是 CKA 考试的要求。如果你想了解更多关于集群网络的信息，可以查看官方文档：[https://kubernetes.io/docs/concepts/cluster-administration/networking/#the-kubernetes-network-model](https://kubernetes.io/docs/concepts/cluster-administration/networking/#the-kubernetes-network-model)。
- en: Pod-to-service and external-to-service communications
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod 到服务和外部到服务的通信
- en: Effective communication between pods and services entails letting the service
    expose an application running on a set of pods. The service accepts traffic from
    both inside and outside of the cluster. The set of pods can load - balance across
    them – each pod is assigned its own IP address and a single DNS.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的 pod 和服务之间的通信意味着让服务暴露在一组 pod 上运行的应用程序。该服务接受来自集群内部和外部的流量。该组 pod 可以在它们之间进行负载均衡
    —— 每个 pod 都分配了自己的 IP 地址和一个 DNS。
- en: Similar to pod-to-service, the challenge with external-to-service communication
    challenge is also resolved by the service. Service types such as a `NodePort`
    or a `LoadBalancer` can receive traffic from outside the Kubernetes cluster.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与 pod 到服务通信类似，外部到服务的通信挑战也由服务来解决。`NodePort` 或 `LoadBalancer` 等服务类型可以接收来自 Kubernetes
    集群外部的流量。
- en: Let’s now take a look at different *service types* and *endpoints*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下不同的 *服务类型* 和 *端点*。
- en: An overview of Kubernetes service types
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes 服务类型概述
- en: 'There are a few types of publishing services in the Kubernetes networking space
    that are very important. This is different from a headless service. You can visit
    this link if you want to learn about headless services, which is out of the scope
    of the CKA exam: [https://kubernetes.io/docs/concepts/services-networking/service/#headless-services](https://kubernetes.io/docs/concepts/services-networking/service/#headless-services).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 网络空间中，有几种发布服务类型非常重要。这与无头服务不同。如果你想了解有关无头服务的内容，可以访问这个链接（这不在 CKA 考试的范围内）：[https://kubernetes.io/docs/concepts/services-networking/service/#headless-services](https://kubernetes.io/docs/concepts/services-networking/service/#headless-services)。
- en: 'The following are the most important types of publishing services that frequently
    appear in the CKA exam:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 CKA 考试中最常见的几种发布服务类型：
- en: '| **Service type** | **Description** | **Example** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **服务类型** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ClusterIP` | A default service type for Kubernetes. For internal communications,
    exposing the service makes it reachable within the cluster. | Checking out the
    pod address by using the `kubectl get pod mypod -o wide` – the internal IP is
    `172.17.0.4` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `ClusterIP` | Kubernetes 的默认服务类型。对于内部通信，暴露该服务使其在集群内可访问。 | 使用 `kubectl get
    pod mypod -o wide` 查看 pod 地址 - 内部 IP 是 `172.17.0.4` |'
- en: '| `NodePort` | For both internal and external communication. `NodePort` exposes
    the service on a static port on each worker node – meanwhile, a `ClusterIP` is
    created for it, and it is used for internal communication, requesting the IP address
    of the node with an open port – for example, `<nodeIP>:<port>` for external communication.
    | Connecting to a worker node VM with the public IP address `192.0.2.0` from port
    `80` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `NodePort` | 用于内部和外部通信。`NodePort` 在每个工作节点上暴露服务的静态端口——与此同时，会为其创建 `ClusterIP`，并用于内部通信，要求访问节点的
    IP 地址和开放端口——例如，`<nodeIP>:<port>` 用于外部通信。 | 连接到具有公共 IP 地址 `192.0.2.0` 的工作节点虚拟机，端口为
    `80` |'
- en: '| `LoadBalancer` | This works for cloud providers, as it’s backed by their
    respective load balancer offerings. Underneath `LoadBalancer`, `ClusterIP` and
    `NodePort` are created, which are used for internal and external communication.
    | Checking out the services for a Kubernetes distribution from a cloud provider
    such as `kubectl get service mysvc -n mynamespace` – the internal IP is `172.17.0.4`
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `LoadBalancer` | 适用于云提供商，因为它由各自的负载均衡器提供支持。在 `LoadBalancer` 下，创建了 `ClusterIP`
    和 `NodePort`，分别用于内部和外部通信。 | 查看来自云提供商的 Kubernetes 分发版的服务，如 `kubectl get service
    mysvc -n mynamespace` – 内部 IP 地址为 `172.17.0.4` |'
- en: '| `ExternalName` | Maps the service to the contents with a CNAME record with
    its value. It allows external traffic access through it. | For example, `my.packt.example.com`
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `ExternalName` | 使用 CNAME 记录将服务映射到其内容，并允许外部流量通过该记录访问。 | 例如，`my.packt.example.com`
    |'
- en: 'To learn more about the differences between publishing services and headless
    services, check here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types.
    Now, let’s take a look at each of those services in this section.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关发布服务和无头服务之间的差异，请查看此链接：https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types。现在，让我们来看看这一节中的每个服务。
- en: ClusterIP
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ClusterIP
- en: '`ClusterIP` is the default Kubernetes service type for internal communications.
    In the case of a pod or `ClusterIP`, the pod is reachable inside the Kubernetes
    cluster. However, it is still possible to allow external traffic to access the
    `ClusterIP` via `kube-proxy`, which creates `iptables` entries. It comes in handy
    in some use cases, such as displaying Kubernetes dashboards. *Figure 7.5* describes
    how the network traffic load - balances (round-robin) and routes to the pod. Then,
    it goes through `ClusterIP` or other services before hitting the pods:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClusterIP` 是 Kubernetes 的默认服务类型，用于内部通信。在 pod 或 `ClusterIP` 的情况下，pod 只在 Kubernetes
    集群内可达。然而，仍然可以通过 `kube-proxy` 允许外部流量访问 `ClusterIP`，它会创建 `iptables` 条目。这在一些使用场景中非常有用，比如展示
    Kubernetes 仪表板。*图 7.5* 描述了网络流量如何负载均衡（轮询）并路由到 pod。然后，它会通过 `ClusterIP` 或其他服务到达 pod：'
- en: '![Figure 7.5 – ClusterIP and kube-proxy  ](img/Figure_7.05_B18201.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – ClusterIP 和 kube-proxy](img/Figure_7.05_B18201.jpg)'
- en: Figure 7.5 – ClusterIP and kube-proxy
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – ClusterIP 和 kube-proxy
- en: 'Through the preceding diagram, we get a first look at how the service works
    with the pods. Let’s go ahead and deploy an application and do a deeper dive.
    To create a deployment called `nginx` and with the `replicas` number of `2`, use
    the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的图示，我们首次了解了服务如何与 pod 一起工作。接下来，让我们部署一个应用程序并深入研究。要创建一个名为 `nginx` 的部署，并将 `replicas`
    数量设置为 `2`，请使用以下命令：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can track down the process of deployment by the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令追踪部署过程：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once we do, we should be able to see the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成，我们应该能够看到以下输出：
- en: '![Figure 7.6 – The available nginx replica counts ](img/Figure_7.06_B18201.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 可用的 nginx 副本数量](img/Figure_7.06_B18201.jpg)'
- en: Figure 7.6 – The available nginx replica counts
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 可用的 nginx 副本数量
- en: From the preceding output, we can see that two copies of the `nginx` pod are
    up and running, just to get a better understanding of those pods. We can see how
    those `nginx` pods are presented in the default namespace.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到有两个 `nginx` pod 正在运行，以便更好地理解这些 pod。我们可以看到这些 `nginx` pod 在默认命名空间中的展示情况。
- en: 'Note that we’re doing the test in the `default` namespace for simplicity. You
    can add the `-n` flag to work with deployment and pods in a different namespace.
    Refer to [*Chapter 4*](B18201_04.xhtml#_idTextAnchor080), *Application Scheduling
    and Lifecycle Management,* to see how the application deployment in Kubernetes
    works. Go and try the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了简便起见，我们在`default`命名空间中进行测试。你可以添加`-n`标志，以便在其他命名空间中处理部署和 pods。请参阅[*第 4 章*](B18201_04.xhtml#_idTextAnchor080)，*应用调度与生命周期管理*，了解
    Kubernetes 中应用部署的工作原理。接下来，尝试执行以下命令：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output will return all the available pods in the `default` namespace:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将返回`default`命名空间中所有可用的 pods：
- en: '![Figure 7.7 – The available nginx pods in the default namespace ](img/Figure_7.07_B18201.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 默认命名空间中的可用 nginx pods](img/Figure_7.07_B18201.jpg)'
- en: Figure 7.7 – The available nginx pods in the default namespace
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 默认命名空间中的可用 nginx pods
- en: 'Now, we’re exposing these pods to the Kubernetes cluster. We’re using the following
    command to create a service called `melon-service`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将这些 pods 暴露到 Kubernetes 集群中。我们使用以下命令创建一个名为`melon-service`的服务：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From the preceding command, we can see that we have created a `ClusterIP` type
    of service. We can specify the following flags:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的命令中，我们可以看到我们已经创建了一个`ClusterIP`类型的服务。我们可以指定以下标志：
- en: '`type` is the type of service – in our case, it is `ClusterIP`. We’ll take
    a look at `NodePort` and `LoadBalancer` in the next sections of this chapter.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`是服务的类型——在我们的例子中，它是`ClusterIP`。我们将在本章接下来的部分中了解`NodePort`和`LoadBalancer`。'
- en: '`port` is the port that the service serves on.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`是服务提供的端口。'
- en: '`target-port` is the port on the container to which the service redirects the
    traffic.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target-port`是容器上将流量重定向到的端口。'
- en: Important Note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Understanding those command flags will help you use them smoothly; I recommend
    remembering this command so that you can quickly recall it during the actual CKA
    exam. You can also refer to the following link ([https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#expose](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#expose))
    to understand whether other flags will help you along the way.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些命令标志将帮助你更顺畅地使用它们；我建议你记住这个命令，以便在实际的 CKA 考试中能够快速回忆起来。你也可以参考以下链接（[https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#expose](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#expose)）来了解其他标志是否能帮助你。
- en: 'The output of the previous command should look similar to the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出应该类似于以下内容：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding command is executed successfully based on this output. Now, let’s
    go to the default namespace and check out all the available services using the
    `kubectl get svc` command – this will give you the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个输出，前面的命令成功执行。现在，让我们进入默认命名空间，使用`kubectl get svc`命令查看所有可用的服务——这将给出以下输出：
- en: '![Figure 7.8 – The available nginx pods in the default namespace ](img/Figure_7.08_B18201.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 默认命名空间中的可用 nginx pods](img/Figure_7.08_B18201.jpg)'
- en: Figure 7.8 – The available nginx pods in the default namespace
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 默认命名空间中的可用 nginx pods
- en: The preceding output shows the `ClusterIP` type has been created with an IP
    address of `10.102.194.57` and this service serves on a port of `8080`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示，已创建了`ClusterIP`类型的服务，IP 地址为`10.102.194.57`，该服务在`8080`端口上提供服务。
- en: 'What we did in this section to create a new `ClusterIP` service by using the
    `kubectl expose` command can also be done using the following YAML manifest file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中所做的通过使用`kubectl expose`命令创建一个新的`ClusterIP`服务，也可以通过以下的 YAML 清单文件完成：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'From the preceding YAML definition, we can see there’s a section called `selector`.
    This section has a key-value pair, `app:nginx`, that has a label sector. Usually,
    we use a selector to map the service with the pods. Here’s the YAML definition
    of the `nginx` deployment if we didn’t go for the `kubectl` command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的 YAML 定义中，我们可以看到有一个叫做`selector`的部分。这个部分有一个键值对`app:nginx`，它是一个标签选择器。通常，我们使用选择器将服务与
    pods 关联起来。如果我们没有使用`kubectl`命令，这里是`nginx`部署的 YAML 定义：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'From the preceding YAML definition, we can see that there is a section to specify
    the selector and we used the same key-value pair, `app: nginx`, to map the `ClusterIP`
    specification so that it worked as expected. Refer to [*Chapter 4*](B18201_04.xhtml#_idTextAnchor080)*,
    Application Scheduling and Lifecycle Management,* to learn more about label sectors.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '从前面的 YAML 定义中，我们可以看到有一个部分用于指定选择器，我们使用相同的键值对 `app: nginx` 来映射 `ClusterIP` 规范，以便它按预期工作。参考[*第
    4 章*](B18201_04.xhtml#_idTextAnchor080)*，应用调度与生命周期管理，*了解更多关于标签选择器的信息。'
- en: Important Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As we mentioned before, the CKA exam is about time management, so it will be
    much more efficient to use commands to achieve the goal.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，CKA 考试强调时间管理，因此使用命令来实现目标会更加高效。
- en: 'A corresponding endpoints object can achieve what we have discussed without
    using a selector. You can use the following commands to get the endpoints of `melon-service`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相应的 endpoints 对象可以在不使用选择器的情况下实现我们所讨论的内容。你可以使用以下命令来获取 `melon-service` 的 endpoints：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is the output of the preceding command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面命令的输出：
- en: '![Figure 7.9 – Display the endpoints of the nginx pods in the default namespace
    ](img/Figure_7.09_B18201.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 显示默认命名空间中 nginx pods 的 endpoints](img/Figure_7.09_B18201.jpg)'
- en: Figure 7.9 – Display the endpoints of the nginx pods in the default namespace
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 显示默认命名空间中 nginx pods 的 endpoints
- en: 'As you can see, there’s nothing specific in the YAML definition file that we
    defined here. We can compare the service definition by exporting its YAML definition
    using the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这里我们定义的 YAML 文件中并没有什么特别的内容。我们可以通过使用以下命令导出其 YAML 定义来对比服务定义：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will be able to see the exported output as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够看到导出的输出，如下所示：
- en: '![Figure 7.10 – The definition of the nginx service in the default namespace
    ](img/Figure_7.10_B18201.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 默认命名空间中 nginx 服务的定义](img/Figure_7.10_B18201.jpg)'
- en: Figure 7.10 – The definition of the nginx service in the default namespace
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 默认命名空间中 nginx 服务的定义
- en: Comparing this exported definition with what we have walked through in this
    section using `kubectl` and a YAML definition will help you understand the services
    in Kubernetes better. Now, let’s take a look at another important service in Kubernetes,
    called `NodePort`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将导出的定义与我们在本节中使用 `kubectl` 和 YAML 定义所讲解的内容进行比较，将有助于你更好地理解 Kubernetes 中的服务。现在，让我们来看看
    Kubernetes 中另一个重要的服务——`NodePort`。
- en: NodePort
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NodePort
- en: '`NodePort` opens ports on the Kubernetes nodes, which usually are de facto
    virtual machines. `NodePort` exposes access through the IP of the nodes and, with
    the opened port, makes the application accessible from outside of the Kubernetes
    cluster. The network traffic is forwarded from the ports to the service. `kube-proxy`
    allocates a port in the range `30000` to `32767` on every node – it works as shown
    in the following figure:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`NodePort` 在 Kubernetes 节点上打开端口，这些节点通常是虚拟机。`NodePort` 通过节点的 IP 暴露访问，并通过打开的端口使应用程序可以从
    Kubernetes 集群外部访问。网络流量从端口转发到服务。`kube-proxy` 在每个节点上分配一个 `30000` 到 `32767` 范围内的端口——其工作方式如图所示：'
- en: '![Figure 7.11 – A NodePort in Kubernetes ](img/Figure_7.11_B18201.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – Kubernetes 中的 NodePort](img/Figure_7.11_B18201.jpg)'
- en: Figure 7.11 – A NodePort in Kubernetes
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – Kubernetes 中的 NodePort
- en: 'With the preceding diagram, we get a closer look at how `NodePort` works with
    the pods. Let’s go ahead and create a deployment called `webfront-app` with a
    `replicas` number of `2` using the following command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的图示，我们更深入地了解了 `NodePort` 如何与 pods 一起工作。接下来，我们使用以下命令创建一个名为 `webfront-app`、`replicas`
    数量为 `2` 的部署：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If it’s created successfully, you will see the following output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建成功，你将看到以下输出：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we can go ahead and use the following command to expose a web frontend
    using `NodePort`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令通过 `NodePort` 暴露一个 Web 前端：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following output shows that we have exposed `webfront-app` successfully:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示我们已成功暴露 `webfront-app`：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that if you don’t provide a target port, it is assumed to be the same as
    the container port. Also note that if you don’t provide a node port, a free port
    in the range between `30000` and `32767` is automatically allocated.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你没有提供目标端口，则假定它与容器端口相同。还要注意，如果没有提供节点端口，系统会自动分配一个在 `30000` 到 `32767` 范围内的空闲端口。
- en: 'Now, let’s check all the services that we have just created. As we didn’t specify
    the name in the previous command, the service name is presumed to be the same
    as the application name:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一下我们刚刚创建的所有服务。由于我们在之前的命令中没有指定名称，服务名称假定与应用程序名称相同：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output should look as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 7.12 – The webfront-app NodePort in the default namespace ](img/Figure_7.12_B18201.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 默认命名空间中的 webfront-app NodePort](img/Figure_7.12_B18201.jpg)'
- en: Figure 7.12 – The webfront-app NodePort in the default namespace
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 默认命名空间中的 webfront-app NodePort
- en: 'From the preceding output, we can see the port is exposed at `31400`, which
    is in the range of `30000` to `32767` on the node, and the target port is `80`,
    which is opened at the container level. So, let’s get the node IP by using the
    following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到端口暴露在`31400`，这个端口位于节点的`30000`到`32767`范围内，目标端口是`80`，它在容器级别已开启。因此，使用以下命令获取节点
    IP：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The key part of your output is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的关键部分如下：
- en: '![Figure 7.13 – The internal IP of the webfront-app NodePort  ](img/Figure_7.13_B18201.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – webfront-app NodePort 的内部 IP](img/Figure_7.13_B18201.jpg)'
- en: Figure 7.13 – The internal IP of the webfront-app NodePort
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – webfront-app NodePort 的内部 IP
- en: 'From the preceding output, we are getting the internal IP of the node, as we’re
    testing locally, so we can use the internal IP and port in conjunction to connect
    to `webfront-app`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们获取的是节点的内部 IP，由于我们在本地进行测试，所以可以将内部 IP 和端口结合使用来连接到`webfront-app`：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s deploy a new `nginx` pod called `sandbox-nginx` to test out the connectivity
    by using the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令，我们来部署一个名为`sandbox-nginx`的新`nginx` pod，测试连接性：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is similar to the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 输出类似于以下内容：
- en: '![Figure 7.14 – The internal IP of the webfront-app NodePort ](img/Figure_7.14_B18201.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.14 – webfront-app NodePort 的内部 IP](img/Figure_7.14_B18201.jpg)'
- en: Figure 7.14 – The internal IP of the webfront-app NodePort
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – webfront-app NodePort 的内部 IP
- en: 'In the actual CKA exam, you’ll be working on a few different VMs. In case you
    need to connect to the application deployed on that node, you can use the following
    command to get the external IPs of all nodes:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的 CKA 考试中，你将会在几个不同的虚拟机上进行操作。如果你需要连接到该节点上部署的应用程序，可以使用以下命令获取所有节点的外部 IP：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Similarly, if you want to get the internal IPs of all nodes, you can use the
    following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果你想获取所有节点的内部 IP，可以使用以下命令：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the actual exam, you can also connect to that node using the internal IP,
    and then use the following command, which will give you the same result:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际考试中，你还可以使用内部 IP 连接到该节点，然后使用以下命令，它会给你相同的结果：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the case that you have a public IP address of the node VM that you can ping
    from your local environment, you can use the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个可以从本地环境 ping 通的节点虚拟机的公共 IP 地址，你可以使用以下命令：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tips and Tricks
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 提示与技巧
- en: 'Some important `JSONPath` commands can be found on the Kubernetes cheat sheets
    here if you need some help: [https://kubernetes.io/docs/reference/kubectl/cheatsheet/#viewing-finding-resources](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#viewing-finding-resources).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助，可以参考 Kubernetes 备忘单上的一些重要的 `JSONPath` 命令：[https://kubernetes.io/docs/reference/kubectl/cheatsheet/#viewing-finding-resources](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#viewing-finding-resources)。
- en: 'What we did in this section to create a new `NodePort` service by using the
    `kubectl expose` command can also be done using the following YAML manifest file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中通过使用 `kubectl expose` 命令创建新 `NodePort` 服务的操作，也可以使用以下 YAML 清单文件来完成：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Public cloud providers often support an external load balancer, which we can
    define as `LoadBalancer` when working with Kubernetes. Now, let’s take a look
    at it in the following section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 公有云服务提供商通常支持外部负载均衡器，在使用 Kubernetes 时，我们可以将其定义为 `LoadBalancer`。现在，让我们在以下部分了解一下它。
- en: LoadBalancer
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LoadBalancer
- en: '`LoadBalancer` is a standard way to connect a service from outside of the cluster.
    In this case, a network load balancer redirects all external traffic to a service,
    as shown in the following figure, and each service gets its own IP address. It
    allows the service to load - balance the network traffic across applications:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadBalancer` 是一种将服务从集群外部连接的标准方式。在这种情况下，网络负载均衡器将所有外部流量重定向到一个服务，如下图所示，每个服务都有自己的
    IP 地址。它允许服务在应用程序之间进行网络流量负载均衡：'
- en: '![Figure 7.15 – LoadBalancer in Kubernetes ](img/Figure_7.15_B18201.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.15 – Kubernetes 中的 LoadBalancer](img/Figure_7.15_B18201.jpg)'
- en: Figure 7.15 – LoadBalancer in Kubernetes
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – Kubernetes 中的 LoadBalancer
- en: '`LoadBalancer` is not a popular topic in the CKA exam, as it only works in
    a cloud environment or another environment that supports external load balancers.
    Deploying the `LoadBalancer` service to get a public IP is commonly used in managed
    Kubernetes distributions such as `LoadBalancer` is the default outbound type for
    AKS – the following is a sample YAML definition in that regard:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadBalancer`不是CKA考试中的热门话题，因为它仅在云环境或其他支持外部负载均衡器的环境中工作。将`LoadBalancer`服务部署以获取公共IP通常用于像AKS这样的托管Kubernetes发行版
    – 以下是相关的YAML示例定义：'
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We could also use the `kubectl expose` command to do so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`kubectl expose`命令来执行此操作：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出如下所示：
- en: '![Figure 7.16 – LoadBalancer output in Kubernetes ](img/Figure_7.16_B18201.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图7.16 – Kubernetes中的LoadBalancer输出](img/Figure_7.16_B18201.jpg)'
- en: Figure 7.16 – LoadBalancer output in Kubernetes
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 – Kubernetes中的LoadBalancer输出
- en: 'Since I was testing LoadBalancer in Docker Desktop with WSL2, it was not supported
    – the preceding output shows that `EXTERNAL-IP` is `localhost`. Although, when
    I was working on AKS, it showed the real public IP address. Refer to this link
    to see what worked out for me: [https://docs.microsoft.com/en-us/azure/aks/load-balancer-standard](https://docs.microsoft.com/en-us/azure/aks/load-balancer-standard).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我在WSL2上的Docker Desktop中测试LoadBalancer时，它不受支持 – 前面的输出显示`EXTERNAL-IP`为`localhost`。然而，当我在AKS上工作时，它显示了真实的公共IP地址。请参考此链接查看对我有用的内容：[https://docs.microsoft.com/en-us/azure/aks/load-balancer-standard](https://docs.microsoft.com/en-us/azure/aks/load-balancer-standard)。
- en: ExternalName
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ExternalName
- en: '`ExternalName` maps the service to the contents with a CNAME record with its
    value. It allows external traffic to access it. The following is the sample YAML
    definition for `ExternalName`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExternalName`将服务映射到其值的CNAME记录的内容。它允许外部流量访问该服务。以下是`ExternalName`的示例YAML定义：'
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that the preceding `ExternalName` type is defined as `my.melonapp.packt.com`
    – we could use the `nslookup` command to check `my-packt-svc.default,svc.cluster.local`.
    This returns the CNAME record for `my.melonapp.packt.com`. We’ll dive deeper into
    how the DNS in Kubernetes works later in this chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的`ExternalName`类型定义为`my.melonapp.packt.com` – 我们可以使用`nslookup`命令来检查`my-packt-svc.default,svc.cluster.local`。这将返回`my.melonapp.packt.com`的CNAME记录。我们将在本章稍后深入探讨Kubernetes中的DNS是如何工作的。
- en: Check services and endpoints
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查服务和端点
- en: 'In this section, we have worked on all four of the common service types in
    Kubernetes. In case we need to quickly check all the services across all namespaces,
    we can use the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已介绍了Kubernetes中的四种常见服务类型。如果我们需要快速检查所有命名空间中的所有服务，可以使用以下命令：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Alternatively, we can use the following command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用以下命令：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following shows the output for the preceding command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了前一个命令的输出：
- en: '![Figure 7.17 – Getting all the services across different namespaces  ](img/Figure_7.17_B18201.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图7.17 – 获取跨不同命名空间的所有服务](img/Figure_7.17_B18201.jpg)'
- en: Figure 7.17 – Getting all the services across different namespaces
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17 – 获取跨不同命名空间的所有服务
- en: 'The preceding screenshot lists services across namespaces, as well as their
    `ClusterIP` and port information. If you want to check out a specific service,
    you can use the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图列出了跨命名空间的服务，以及它们的`ClusterIP`和端口信息。如果你想查看特定的服务，可以使用以下命令：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The example of the preceding command is `kubectl get svc kube-dns -n kube-system`,
    which will give you the service information. You can also go one step further
    to check the details by using the `kubectl describe svc` command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的示例是`kubectl get svc kube-dns -n kube-system`，它会返回服务信息。你还可以通过使用`kubectl
    describe svc`命令进一步查看详细信息：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出如下所示：
- en: '![Figure 7.18 – Checking the service details  ](img/Figure_7.18_B18201.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图7.18 – 检查服务详细信息](img/Figure_7.18_B18201.jpg)'
- en: Figure 7.18 – Checking the service details
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18 – 检查服务详细信息
- en: 'For the endpoints, we can use the following command to check the endpoint of
    the service:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于端点，我们可以使用以下命令来检查服务的端点：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It can also be as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以如下所示：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In case we’d like to check out all the endpoints across the different namespaces,
    we have the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想查看不同命名空间中的所有端点，可以使用以下命令：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output of the preceding command will list all the endpoints across different
    namespaces:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出将列出跨不同命名空间的所有端点：
- en: '![Figure 7.19 – Getting all the endpoints across different namespaces  ](img/Figure_7.19_B18201.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.19 – 获取跨不同命名空间的所有端点](img/Figure_7.19_B18201.jpg)'
- en: Figure 7.19 – Getting all the endpoints across different namespaces
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19 – 获取跨不同命名空间的所有端点
- en: 'The same principle also applies to listing all the endpoints by namespace.
    When you want to check out a specific service, you can use the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原理也适用于按命名空间列出所有端点。当你想查看特定服务时，可以使用以下命令：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We have talked about how to work with services and endpoints in Kubernetes,
    which covers pod-to-service communication. Now, let’s get into node-to-node communication
    in the next section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何在 Kubernetes 中处理服务和端点，涉及了 pod 到服务的通信。现在，让我们进入下一节，讨论节点间的通信。
- en: Node-to-node communication
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点间通信
- en: Within a cluster, each node is registered by the `kubelet` agent to the master
    node, and each node is assigned a node IP address so they can communicate with
    each other.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个集群内，每个节点都会通过`kubelet`代理注册到主节点，并且每个节点会被分配一个节点 IP 地址，以便它们之间能够进行通信。
- en: 'To verify this, you can use the `kubectl get node -o wide` command to check
    the internal IP of each node. The output is similar to the following, in which
    you’ll notice an `internal-IP` for the worker node:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证这一点，可以使用`kubectl get node -o wide`命令查看每个节点的内部 IP。输出结果类似于以下内容，在其中你会注意到工作节点的`internal-IP`：
- en: '![Figure 7.20 – Checking out the node IP and further information  ](img/Figure_7.20_B18201.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.20 – 查看节点 IP 及更多信息](img/Figure_7.20_B18201.jpg)'
- en: Figure 7.20 – Checking out the node IP and further information
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20 – 查看节点 IP 及更多信息
- en: From the preceding screenshot, we can see the internal IP of the current node
    is `192.168.49.2`. In the case that we have multiple nodes, we can ping each node
    from the node within the same network. We need to ensure the connectivity between
    master nodes and worker nodes, so the workloads get to be scheduled to the worker
    node. In this regard, a good understanding of how to configure the hosting network
    for Kubernetes nodes is very important. So, let’s have a look at the container
    network interface plugin next.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的截图中，我们可以看到当前节点的内部 IP 地址是`192.168.49.2`。如果我们有多个节点，我们可以在同一网络内从一个节点 ping 其他节点。我们需要确保主节点与工作节点之间的连通性，以便工作负载能够被调度到工作节点。因此，理解如何为
    Kubernetes 节点配置托管网络非常重要。接下来，我们来看一下容器网络接口插件。
- en: Choosing an appropriate Container Network Interface plugin
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择合适的容器网络接口插件
- en: In [*Chapter 2*](B18201_02.xhtml#_idTextAnchor035), *Installing and Configuring
    Kubernetes Clusters*, we talked about how to use the Calico plugin as the overlay
    network for our Kubernetes cluster. We can enable the **Container Network Interface**
    (**CNI**) for pod-to-pod communication. The CNI plugins conform to the CNI specification.
    Once the CNI is set up on the Kubernetes cluster, it will allocate the IP address
    per pod.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B18201_02.xhtml#_idTextAnchor035)《*安装与配置 Kubernetes 集群*》中，我们讨论了如何使用
    Calico 插件作为 Kubernetes 集群的覆盖网络。我们可以启用**容器网络接口**（**CNI**）以实现 pod 到 pod 的通信。CNI
    插件符合 CNI 规范。一旦 CNI 在 Kubernetes 集群中配置完成，它将为每个 pod 分配 IP 地址。
- en: CNI networking in Kubernetes
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 中的 CNI 网络
- en: 'There’s a wide range of networking plugins working with Kubernetes on today’s
    market, including popular open source frameworks such as Calico, Flannel, Weave
    Net, and more. For more options, check out the official documentation here: [https://kubernetes.io/docs/concepts/cluster-administration/addons/](https://kubernetes.io/docs/concepts/cluster-administration/addons/).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当前市场上有多种网络插件可与 Kubernetes 配合使用，包括 Calico、Flannel、Weave Net 等流行的开源框架。更多选项，请查看官方文档：[https://kubernetes.io/docs/concepts/cluster-administration/addons/](https://kubernetes.io/docs/concepts/cluster-administration/addons/)。
- en: 'Taking Flannel as an example, Flannel is focused on configuring a Layer 3 network
    fabric designed for Kubernetes, mainly for routing packets among different containers.
    Flannel runs a single binary agent called `flanneld` on each host, which is responsible
    for allocating a subnet preconfigured address space to each host, as in the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以 Flannel 为例，Flannel 专注于为 Kubernetes 配置一个三级网络架构，主要用于在不同容器之间路由数据包。Flannel 在每个主机上运行一个名为`flanneld`的单一二进制代理，负责为每个主机分配一个预配置的子网地址空间，如下所示：
- en: '![Figure 7.21 – CNI networking in Kubernetes  ](img/Figure_7.21_B18201.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.21 – Kubernetes 中的 CNI 网络](img/Figure_7.21_B18201.jpg)'
- en: Figure 7.21 – CNI networking in Kubernetes
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21 – Kubernetes 中的 CNI 网络
- en: The preceding figure demonstrates how Flannel CNI networking works. There are
    many options in the community – let’s take a look at the decision metrics about
    choosing the CNI plugin.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图演示了 Flannel CNI 网络如何工作。社区中有许多选项——让我们来看看选择 CNI 插件的决策指标。
- en: Decision metrics
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决策指标
- en: 'To make a good choice of an appropriate CNI plugin that fits your requirements,
    you can refer to the following table of different features from each of the CNI
    providers mentioned:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择适合您需求的合适 CNI 插件，您可以参考下表，了解每个 CNI 提供商的不同功能：
- en: '|  | **Provider networking** | **Encapsulation and routing** | **Support for
    network policies** | **Datastore** | **Encryption** | **Ingress / Egress** |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|  | **提供商网络** | **封装与路由** | **网络策略支持** | **数据存储** | **加密** | **Ingress / Egress**
    |'
- en: '| `Flannel` | Layer 3 | VxLAN | No | ETCD | Yes | No |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `Flannel` | 第三层 | VxLAN | 否 | ETCD | 是 | 否 |'
- en: '| `Calico` | Layer 3 | BGP, eBPF | Yes | ETCD | Yes | Yes |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `Calico` | 第三层 | BGP, eBPF | 是 | ETCD | 是 | 是 |'
- en: '| `Weavenet` | Layer 2 | VxLAN | Yes | NO | Yes | Yes |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `Weavenet` | 第二层 | VxLAN | 是 | 否 | 是 | 是 |'
- en: '| `Canal` | Layer 2 | VxLAN | Yes | ETCD | No | Yes |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `Canal` | 第二层 | VxLAN | 是 | ETCD | 否 | 是 |'
- en: For quick testing, Flannel is simple to set up. Calico and Weave Net are better
    options for enterprise-grade customers, as they have a wide range of capabilities.
    In real life, it is possible to use multiple CNI solutions in a single environment
    to fulfill some complex networking requirements. However, that’s out of reach
    of the CKA certification exam.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于快速测试，Flannel 的设置非常简单。Calico 和 Weave Net 是更适合企业级客户的选择，因为它们具有广泛的功能。在实际应用中，可能会在一个环境中使用多个
    CNI 解决方案来满足一些复杂的网络需求。不过，这超出了 CKA 认证考试的范畴。
- en: Now let’s take a look at the Ingress controller in the next section.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看下一部分的 Ingress 控制器。
- en: Configuring Ingress controllers and Ingress resources
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Ingress 控制器和 Ingress 资源
- en: One of the challenges of Kubernetes networking is about managing internal traffic,
    which is also known as east-west traffic, and external traffic, which is known
    as north-south traffic.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 网络管理面临的挑战之一是管理内部流量，也就是所谓的东西向流量，以及外部流量，也就是北南向流量。
- en: There are a few different ways of getting external traffic into a Kubernetes
    cluster. When it comes to Layer 7 networking, Ingress exposes HTTP and HTTPS at
    Layer 7 routes from outside the cluster to the services within the cluster.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的方式将外部流量引入 Kubernetes 集群。当涉及到第七层网络时，Ingress 会在第七层路由上暴露 HTTP 和 HTTPS，将集群外部的流量路由到集群内的服务。
- en: How Ingress and an Ingress controller works
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ingress 和 Ingress 控制器的工作原理
- en: Ingress acts as a router to route traffic to services via an Ingress-managed
    load balancer – then, the service distributes the traffic to different pods. From
    that point of view, the same IP address can be used to expose multiple services.
    However, our application can become more complex, especially when we need to redirect
    the traffic to its subdomain or even a wild domain. Ingress is here to address
    these challenges.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Ingress 充当路由器，通过 Ingress 管理的负载均衡器将流量路由到服务，然后该服务将流量分发到不同的 Pod。从这个角度来看，同一个 IP
    地址可以用于暴露多个服务。然而，随着应用程序的复杂性增加，特别是当我们需要将流量重定向到其子域名甚至是通配符域时，Ingress 就能解决这些挑战。
- en: 'Ingress works with an Ingress controller to evaluate the defined traffic rules
    and then determine how the traffic is being routed. The process works as shown
    in *Figure 7.22*:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Ingress 与 Ingress 控制器一起评估定义的流量规则，然后确定流量如何路由。该过程如*图7.22*所示：
- en: '![Figure 7.22 – Ingress resources in Kubernetes ](img/Figure_7.22_B18201.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图7.22 – Kubernetes中的Ingress资源](img/Figure_7.22_B18201.jpg)'
- en: Figure 7.22 – Ingress resources in Kubernetes
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22 – Kubernetes中的Ingress资源
- en: In addition to what we see here in *Figure 7.22*, Ingress also provides some
    key capabilities such as load balancing, SSL termination, and name-based virtual
    hosting.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在*图7.22*中看到的内容，Ingress 还提供了一些关键功能，如负载均衡、SSL 终止和基于名称的虚拟主机。
- en: 'We need to deploy an Ingress controller in the Kubernetes cluster and then
    create Ingress resources. We are using `ingress-nginx` as an example in this section.
    We have a wide range of options for Ingress controllers on the market nowadays.
    Check out the official documentation here to get more details: [https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/](https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 Kubernetes 集群中部署一个 Ingress 控制器，然后创建 Ingress 资源。在本节中，我们以 `ingress-nginx`
    为例。如今市场上有许多 Ingress 控制器可供选择。请查看这里的官方文档以获取更多细节：[https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/](https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/)。
- en: Using multiple Ingress controllers
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个 Ingress 控制器
- en: 'Note that it is also possible to deploy multiple Ingress controllers by using
    the Ingress class within a Kubernetes cluster. Refer to this article to get more
    details: [https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#using-multiple-ingress-controllers](https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#using-multiple-ingress-controllers).'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，也可以通过在 Kubernetes 集群中使用 Ingress 类来部署多个 Ingress 控制器。请参考这篇文章了解更多细节：[https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#using-multiple-ingress-controllers](https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#using-multiple-ingress-controllers)。
- en: Work with Ingress resources
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Ingress 资源配合使用
- en: As mentioned, the `nginx` Ingress controller is one of the most popular in today’s
    market, so we are using it as the main example in this section. We need to deploy
    an Ingress controller in the Kubernetes cluster and create Ingress resources.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`nginx` Ingress 控制器是当今市场上最受欢迎的控制器之一，因此我们在本节中将其作为主要示例。我们需要在 Kubernetes 集群中部署一个
    Ingress 控制器，并创建 Ingress 资源。
- en: 'Here, we are defining a minimal `nginx` resource with the following YAML definition:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个最小的 `nginx` 资源，使用以下 YAML 定义：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: From the preceding YAML definition, we know that the `apiVersion`, `kind`, `metadata`,
    and `spec` fields are mandatory. Then, we also need an Ingress object, which contains
    a valid DNS subdomain name.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的 YAML 定义中，我们知道 `apiVersion`、`kind`、`metadata` 和 `spec` 字段是必填的。接下来，我们还需要一个
    Ingress 对象，其中包含有效的 DNS 子域名。
- en: 'A default `IngressClass` would look as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 `IngressClass` 如下所示：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To learn more about how to work with Ingress, check out the official documentation:
    [https://kubernetes.io/docs/concepts/services-networking/ingress/](https://kubernetes.io/docs/concepts/services-networking/ingress/).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用 Ingress，查看官方文档：[https://kubernetes.io/docs/concepts/services-networking/ingress/](https://kubernetes.io/docs/concepts/services-networking/ingress/)。
- en: Ingress annotations and rewrite-target
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ingress 注解和 rewrite-target
- en: 'You can add Kubernetes annotations to specific Ingress objects so that you
    can customize their behaviors. These annotation keys and values can only be strings.
    The following is an example of how to add annotations to Ingress resources using
    `nginx` as an example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为特定的 Ingress 对象添加 Kubernetes 注解，以便自定义它们的行为。这些注解的键和值只能是字符串。以下是如何以 `nginx`
    为例，向 Ingress 资源添加注解的示例：
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'There are many annotations available for `nginx` – you can check them out by
    visiting the following page: [https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`nginx` 有许多可用的注解——你可以通过访问以下页面来查看它们：[https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/)。'
- en: 'Different Ingress controllers provide different capabilities, often using annotations
    and `rewrite-target` to rewrite the default behavior. You can check out here to
    learn how to rewrite behaviors for `nginx` Ingress controllers: [https://kubernetes.github.io/ingress-nginx/examples/rewrite/#rewrite-target](https://kubernetes.github.io/ingress-nginx/examples/rewrite/#rewrite-target).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的 Ingress 控制器提供不同的功能，通常使用注解和 `rewrite-target` 来重写默认行为。你可以在这里查看如何为 `nginx`
    Ingress 控制器重写行为：[https://kubernetes.github.io/ingress-nginx/examples/rewrite/#rewrite-target](https://kubernetes.github.io/ingress-nginx/examples/rewrite/#rewrite-target)。
- en: 'We touched on the domain name and subdomain name in this section. Now, it’s
    a good time to talk about how the DNS domain hostname works in Kubernetes. Let’s
    get right into it in the next section:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中提到了域名和子域名。现在，是时候谈谈 Kubernetes 中 DNS 域名主机名的工作原理了。让我们在下一节中详细讨论：
- en: Configuring and leveraging CoreDNS
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和利用 CoreDNS
- en: As mentioned earlier in this chapter, nodes, pods, and services are assigned
    their own IP addresses in the Kubernetes cluster. Kubernetes runs a **Domain Name
    System** (**DNS**) server implementation that maps the name of the service to
    its IP address via DNS records. So, you can reach out to the services with a consistent
    DNS name instead of using its IP address. This comes in very handy in the context
    of microservices. All microservices running in the current Kubernetes cluster
    can reference the service name to communicate with each other.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面提到的，节点、Pod 和服务在 Kubernetes 集群中会分配自己的 IP 地址。Kubernetes 运行一个 **域名系统**（**DNS**）服务器实现，通过
    DNS 记录将服务名称映射到其 IP 地址。因此，你可以使用一致的 DNS 名称访问服务，而无需使用其 IP 地址。在微服务架构中，这非常有用。当前 Kubernetes
    集群中运行的所有微服务可以通过引用服务名称相互通信。
- en: 'The DNS server mainly supports the following three types of DNS records, which
    are also the most common ones:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 服务器主要支持以下三种类型的 DNS 记录，这些也是最常见的记录类型：
- en: '**A** or **AAAA records** for forward lookups that map a DNS name to an IP
    address. A record maps a DNS name to an IPv4 address, whereas an AAAA record allows
    mapping a DNS name to an IPv6 address.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A** 或 **AAAA 记录**用于正向查找，将 DNS 名称映射到 IP 地址。A 记录将 DNS 名称映射到 IPv4 地址，而 AAAA
    记录则允许将 DNS 名称映射到 IPv6 地址。'
- en: '**SRV records** for port lookups so that connections are established between
    a service and a hostname.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SRV 记录**用于端口查找，以便在服务和主机名之间建立连接。'
- en: '`172.0\. 0.10` would be stored under the `10.0\. 0.172.in-addr.arpa` DNS zone.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`172.0\. 0.10` 将存储在 `10.0\. 0.172.in-addr.arpa` DNS 区域下。'
- en: Knowing these basic DNS concepts will help us get a better understanding of
    DNS in Kubernetes.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些基本的 DNS 概念将帮助我们更好地理解 Kubernetes 中的 DNS。
- en: 'In Kubernetes 1.21, `kubeadm` removed support for `kube-dns` for DNS replication.
    CoreDNS is now becoming the default DNS service. CoreDNS is an extensible DNS
    server that can serve as a Kubernetes cluster DNS. It is a `kubeadm` for Kubernetes
    in the past from here: [https://github.com/coredns/deployment/blob/master/kubernetes/CoreDNS-k8s_version.md](https://github.com/coredns/deployment/blob/master/kubernetes/CoreDNS-k8s_version.md).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 1.21 中，`kubeadm` 移除了对 `kube-dns` 的支持，以进行 DNS 复制。CoreDNS 现在成为默认的
    DNS 服务。CoreDNS 是一个可扩展的 DNS 服务器，可以作为 Kubernetes 集群的 DNS。它是过去 Kubernetes 使用的 `kubeadm`，可以从这里查看：[https://github.com/coredns/deployment/blob/master/kubernetes/CoreDNS-k8s_version.md](https://github.com/coredns/deployment/blob/master/kubernetes/CoreDNS-k8s_version.md)。
- en: 'If your Kubernetes cluster is not on CoreDNS yet, here is an official end-to-end
    guide to help you migrate to CoreDNS smoothly and avoid backward - incompatible
    configuration issues: [https://github.com/coredns/deployment/blob/master/kubernetes/Upgrading_CoreDNS.md](https://github.com/coredns/deployment/blob/master/kubernetes/Upgrading_CoreDNS.md).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Kubernetes 集群还没有使用 CoreDNS，这里有一个官方的端到端指南，帮助你顺利迁移到 CoreDNS，并避免配置兼容性问题：[https://github.com/coredns/deployment/blob/master/kubernetes/Upgrading_CoreDNS.md](https://github.com/coredns/deployment/blob/master/kubernetes/Upgrading_CoreDNS.md)。
- en: Check whether the CoreDNS server is up and running
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 CoreDNS 服务器是否已启动并正常运行
- en: 'The Kubernetes DNS server schedules a DNS pod and service on the Kubernetes
    cluster to check whether the DNS server is up and running on your cluster. To
    do this, you can simply use the following command:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes DNS 服务器在 Kubernetes 集群中调度一个 DNS Pod 和服务，以检查 DNS 服务器是否已启动并正常运行。为此，你可以使用以下命令：
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Normally, you should be able to see an output similar to the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应该能看到类似于以下内容的输出：
- en: '![Figure 7.23 – When multi-container pods share a network  ](img/Figure_7.23_B18201.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.23 – 当多个容器的 Pod 共享网络时](img/Figure_7.23_B18201.jpg)'
- en: Figure 7.23 – When multi-container pods share a network
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23 – 当多个容器的 Pod 共享网络时
- en: 'When you’re certain that you’re on CoreDNS, you can also use the following
    command:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当你确定已经切换到 CoreDNS 时，你还可以使用以下命令：
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output is similar to the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 输出类似于以下内容：
- en: '[PRE48]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'From the previous output, you may have noticed that we have two replicas of
    the CoreDNS pod. The intention was to set the default value to two copies for
    high availability when installing CoreDNS. To prove this, you can check out the
    CoreDNS deployment settings by using the `kubectl describe` command as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，你可能注意到我们有两个 CoreDNS Pod 的副本。其目的是在安装 CoreDNS 时将默认值设置为两个副本，以确保高可用性。为了验证这一点，你可以使用
    `kubectl describe` 命令查看 CoreDNS 的部署设置，如下所示：
- en: '[PRE49]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output should look similar to the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '![Figure 7.24 – When multi-container pods share a network  ](img/Figure_7.24_B18201.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.24 – 当多个容器的 Pod 共享网络时](img/Figure_7.24_B18201.jpg)'
- en: Figure 7.24 – When multi-container pods share a network
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.24 – 当多个容器共享一个网络时
- en: 'As it’s a deployment, we could use a typical `kubectl scale` command to scale
    the CoreDNS deployment out and in. This comes in handy when you want to economize
    some cluster resources. You can scale it down to one replica using the following
    command:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个部署，我们可以使用典型的`kubectl scale`命令来扩展或缩减CoreDNS部署。这在你想节省一些集群资源时非常有用。你可以使用以下命令将其缩减到一个副本：
- en: '[PRE50]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output should look as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE51]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can then use the `kubectl get deploy` command to check out the number of
    replicas currently available in the cluster:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用`kubectl get deploy`命令查看当前集群中可用的副本数量：
- en: '[PRE52]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Similarly, when you want it to be more resilient by scheduling more replicas,
    you can use the following command to get more replicas:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，当你想要通过调度更多副本来提高其弹性时，可以使用以下命令来获取更多副本：
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Alternatively, we can go back to check the number of the replicas by using
    the following command:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用以下命令回去检查副本的数量：
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As the following screenshot shows, we managed to increase the number of replicas
    of `coredns` from one to four:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，我们成功地将`coredns`的副本数从1个增加到4个：
- en: '![Figure 7.25 – When multi-container pods share a network  ](img/Figure_7.25_B18201.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图7.25 – 当多个容器共享一个网络时](img/Figure_7.25_B18201.jpg)'
- en: Figure 7.25 – When multi-container pods share a network
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.25 – 当多个容器共享一个网络时
- en: 'The previous examples also demonstrate that those four replicas of CoreDNS
    are identical. We can use the `kubectl describe` command to take a closer look
    at either of those four `coredns` pods. The following command is an example:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例还演示了那四个CoreDNS副本是相同的。我们可以使用`kubectl describe`命令仔细查看这四个`coredns` pod中的任何一个。以下命令为示例：
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output should look as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 7.26 – When multi-container pods share a network  ](img/Figure_7.26_B18201.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图7.26 – 当多个容器共享一个网络时](img/Figure_7.26_B18201.jpg)'
- en: Figure 7.26 – When multi-container pods share a network
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.26 – 当多个容器共享一个网络时
- en: 'From the preceding output, we can see CoreDNS using `Corefile` for configurations.
    It is located in the following location:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述输出中，我们可以看到CoreDNS正在使用`Corefile`进行配置。它位于以下位置：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can use the `kubectl get configmaps` command to inspect the content of `Corefile`.
    Here’s how it can be done:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kubectl get configmaps`命令来检查`Corefile`的内容。以下是操作步骤：
- en: '[PRE57]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output should be as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 7.27 – When multi-container pods share a network  ](img/Figure_7.27_B18201.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图7.27 – 当多个容器共享一个网络时](img/Figure_7.27_B18201.jpg)'
- en: Figure 7.27 – When multi-container pods share a network
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.27 – 当多个容器共享一个网络时
- en: 'The preceding command shows there is `configmap` named `coredns`, so let’s
    use the `kubectl describe configmap` command to check out its content:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令显示有一个名为`coredns`的`configmap`，所以我们可以使用`kubectl describe configmap`命令来查看其内容：
- en: '[PRE58]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The following output will show how `Corefile` looks:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出将展示`Corefile`的样子：
- en: '![Figure 7.28 – Corefile for CoreDNS ](img/Figure_7.28_B18201.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图7.28 – CoreDNS的Corefile](img/Figure_7.28_B18201.jpg)'
- en: Figure 7.28 – Corefile for CoreDNS
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.28 – CoreDNS的Corefile
- en: '`Corefile` is very useful when you need to customize the DNS resolution process
    in your Kubernetes cluster. Check out the official documentation about customizing
    the DNS service here: [https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/#coredns-configmap-options](https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/#coredns-configmap-options).'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`Corefile`在你需要自定义Kubernetes集群中的DNS解析过程时非常有用。查看关于自定义DNS服务的官方文档：[https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/#coredns-configmap-options](https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/#coredns-configmap-options)。'
- en: Note that the Kubernetes DNS service is registered to the `kubelet` agent, so
    the Pods running on the cluster use the DNS server’s IP address to resolve the
    DNS names. `kubelet` sets the `/etc/resolv.conf` file for each pod – a DNS query
    for a `myapp` pod from the `my-packt-apps` namespace can be resolved using either
    `myapp.my-packt-apps` or `myapp.my-packt-apps.svc.cluster.local`. Now, let’s take
    a closer look at how the DNS hostname works for a pod in a Kubernetes cluster.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Kubernetes DNS服务已注册到`kubelet`代理，因此在集群上运行的Pods会使用DNS服务器的IP地址来解析DNS名称。`kubelet`为每个Pod设置`/etc/resolv.conf`文件——从`my-packt-apps`命名空间的`myapp`
    Pod进行的DNS查询可以使用`myapp.my-packt-apps`或`myapp.my-packt-apps.svc.cluster.local`进行解析。现在，让我们更详细地了解Kubernetes集群中Pod的DNS主机名是如何工作的。
- en: Pod IPs and DNS hostnames
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod IP和DNS主机名
- en: 'Kubernetes creates DNS records for pods. You can contact a pod with fully qualified,
    consistent DNS hostnames instead of its IP address. For a pod in Kubernetes, the
    DNS name follows this pattern:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 为 Pod 创建 DNS 记录。你可以通过完全限定的、持续一致的 DNS 主机名来访问 Pod，而不需要使用其 IP 地址。对于
    Kubernetes 中的 Pod，DNS 名称遵循以下模式：
- en: '[PRE59]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let’s deploy a pod named `nginx` using the following command:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令部署一个名为`nginx`的Pod：
- en: '[PRE60]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We’ll see that the pod has been deployed successfully if you have an output
    similar to the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到类似以下内容的输出，说明 Pod 已成功部署：
- en: '[PRE61]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let’s take a closer look at this pod:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这个 Pod：
- en: '[PRE62]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output should look as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 7.29 – When a multi-container pod shares a network  ](img/Figure_7.29_B18201.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.29 – 当多容器 Pod 共享一个网络时](img/Figure_7.29_B18201.jpg)'
- en: Figure 7.29 – When a multi-container pod shares a network
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.29 – 当多容器 Pod 共享一个网络时
- en: 'From the figure, we know the IP address for the `nginx` pod is `10.1.0.9` within
    the cluster. From the preceding pattern, we could assume that the DNS name of
    this pod would look as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中，我们知道`nginx` Pod 在集群中的 IP 地址是`10.1.0.9`。根据前面的模式，我们可以推测这个 Pod 的 DNS 名称如下所示：
- en: '[PRE63]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Important Note
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Note that in practice, each pod in a StatefulSet derives the hostname from
    the StatefulSet name. The name domain managed by this service follows this pattern:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，实际上，每个 StatefulSet 中的 Pod 会从 StatefulSet 的名称派生主机名。此服务管理的名称域遵循以下模式：
- en: '`$(service name).$(namespace).svc.cluster.local`'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(service name).$(namespace).svc.cluster.local`'
- en: 'Check out the official documentation to know more: [https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-id](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-id).'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅官方文档以了解更多：[https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-id](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-id)。
- en: 'Alternatively, in order to get the IP address of the `nginx` pod, you can use
    the `kubectl describe pod nginx` command, which will open the live detailed spec
    of your `nginx` pod. The section called `IP` is where you can find the pod’s IP,
    as in the following figure:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，为了获取 `nginx` Pod 的 IP 地址，你可以使用 `kubectl describe pod nginx` 命令，这将打开你 `nginx`
    Pod 的实时详细规格。在名为 `IP` 的部分，你可以找到 Pod 的 IP 地址，如下图所示：
- en: '![Figure 7.30 – When multi-container pods share a network  ](img/Figure_7.30_B18201.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.30 – 当多容器 Pod 共享一个网络时](img/Figure_7.30_B18201.jpg)'
- en: Figure 7.30 – When multi-container pods share a network
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.30 – 当多容器 Pod 共享一个网络时
- en: 'You can deploy a pod named `busybox` with the latest Busybox container image
    in the `default` namespace and then execute the `nslookup` command to check out
    the DNS address of the `nginx` pod, as shown in the following:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`default`命名空间中使用最新的Busybox容器镜像部署一个名为`busybox`的Pod，然后执行`nslookup`命令检查`nginx`
    Pod的DNS地址，如下所示：
- en: '[PRE64]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The output should look as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 7.31 – When multi-container pods share a network  ](img/Figure_7.31_B18201.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.31 – 当多容器 Pod 共享一个网络时](img/Figure_7.31_B18201.jpg)'
- en: Figure 7.31 – When multi-container pods share a network
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.31 – 当多容器 Pod 共享一个网络时
- en: 'Alternatively, you can also use the following command to achieve the same outcome.
    Note that we are adding two `rm` flags in the command, which will make sure the
    pod is deleted once we exit the shell. We also use `--` to execute the `nslookup`
    command directly. In this way, it allows us to do a quick test, which comes in
    very handy in the actual CKA exam. The command would look as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用以下命令来实现相同的结果。请注意，我们在命令中添加了两个`rm`标志，这将确保一旦退出 shell，Pod 被删除。我们还使用`--`直接执行`nslookup`命令。这样，它允许我们进行快速测试，在实际的
    CKA 考试中非常有用。命令如下所示：
- en: '[PRE65]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output should look as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 7.32 – When multi-container pods share a network  ](img/Figure_7.32_B18201.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.32 – 当多容器 Pod 共享一个网络时](img/Figure_7.32_B18201.jpg)'
- en: Figure 7.32 – When multi-container pods share a network
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.32 – 当多容器 Pod 共享一个网络时
- en: We notice that the only difference is that we get the `pod "sandbox" deleted`
    message, which indicates a pod named `sandbox` gets deleted once we exit the shell.
    The preceding output shows the DNS name of the `nginx` pod with the IP address
    `10.96.0\. 10`. The PTR record returns the DNS name of this pod as `10-1-0-9.default.pod.cluster.local`
    just as we expected.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到唯一的不同是，我们得到了`pod "sandbox" deleted`的消息，这表明一旦退出 shell，名为`sandbox`的 Pod 会被删除。前面的输出显示了`nginx`
    Pod 的 DNS 名称，并且 IP 地址为`10.96.0.10`。PTR 记录将这个 Pod 的 DNS 名称返回为`10-1-0-9.default.pod.cluster.local`，正如我们预期的那样。
- en: 'Now, let’s get the A record of the `nginx` pod in the `default` namespace by
    using the following command:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下命令获取 `default` 命名空间中 `nginx` Pod 的 A 记录：
- en: '[PRE66]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output is as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE67]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The preceding output proves that the DNS server returns the A record of the
    `nginx` pod. Let’s deploy a new `nginx` pod called `test-nginx` to test out the
    connectivity by using the following command:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的输出证明了 DNS 服务器返回了 `nginx` Pod 的 A 记录。接下来，我们通过以下命令部署一个新的 `nginx` Pod，名为 `test-nginx`，来测试连接性：
- en: '[PRE68]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The output will look as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 7.33 – When multi-container pods share a network  ](img/Figure_7.33_B18201.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.33 – 当多容器 Pod 共享网络时](img/Figure_7.33_B18201.jpg)'
- en: Figure 7.33 – When multi-container pods share a network
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.33 – 当多容器 Pod 共享网络时
- en: The preceding screenshot with 200 responses proves that the connectivity between
    the `test-nginx` pod and `nginx` pod is good and we managed to use the `curl`
    command on the main page of `nginx` with the DNS name of the `nginx` pod.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示 200 响应，证明 `test-nginx` Pod 与 `nginx` Pod 之间的连接良好，我们成功地使用 `curl` 命令通过
    `nginx` Pod 的 DNS 名称访问了 `nginx` 的主页。
- en: Up until this point, we have done a thorough run-through of how IP addresses
    and DNS work for the pods in a Kubernetes cluster. As we mentioned earlier in
    this chapter, Kubernetes creates DNS records not only for pods but also for services.
    Now, let’s take a look at how the service IP and DNS work in Kubernetes in the
    next section.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经全面了解了在 Kubernetes 集群中，IP 地址和 DNS 是如何为 Pod 工作的。正如我们在本章前面提到的，Kubernetes
    不仅为 Pod 创建 DNS 记录，还为服务创建 DNS 记录。接下来，让我们看看在 Kubernetes 中服务的 IP 和 DNS 是如何工作的。
- en: Service IPs and DNS hostnames
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务 IP 和 DNS 主机名
- en: 'The DNS service in Kubernetes creates DNS records for services so you can contact
    services with consistent fully qualified DNS hostnames instead of IP addresses.
    Similarly, for a service in Kubernetes, the DNS follows the following pattern:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的 DNS 服务为服务创建 DNS 记录，这样你可以通过一致的完全限定 DNS 主机名来访问服务，而不是使用 IP 地址。类似地，在
    Kubernetes 中，服务的 DNS 遵循以下模式：
- en: '[PRE69]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Knowing that the DNS server is located in the `kube-system` namespace, we can
    check it out by using the following command:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 既然 DNS 服务器位于 `kube-system` 命名空间中，我们可以通过以下命令查看它：
- en: '[PRE70]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The output is as follows, where we can get a look at the IP address of the
    DNS server in Kubernetes:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下，其中我们可以看到 Kubernetes 中 DNS 服务器的 IP 地址：
- en: '![Figure 7.34 – When multi-container pods share a network ](img/Figure_7.34_B18201.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.34 – 当多容器 Pod 共享网络时](img/Figure_7.34_B18201.jpg)'
- en: Figure 7.34 – When multi-container pods share a network
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.34 – 当多容器 Pod 共享网络时
- en: 'The preceding screenshot shows the IP address of the DNS server is `10.96.0.10`.
    Now, let’s check out whether we can get the DNS name of the current DNS server
    by using the following command:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示了 DNS 服务器的 IP 地址是 `10.96.0.10`。现在，让我们检查是否可以通过以下命令获取当前 DNS 服务器的 DNS 名称：
- en: '[PRE71]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output should be as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 7.35 – When multi-container pods share a network ](img/Figure_7.35_B18201.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.35 – 当多容器 Pod 共享网络时](img/Figure_7.35_B18201.jpg)'
- en: Figure 7.35 – When multi-container pods share a network
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.35 – 当多容器 Pod 共享网络时
- en: 'The preceding screenshot proves that the DNS name for the DNS server follows
    the aforementioned pattern from this section. Here is how it looks:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图证明了 DNS 服务器的 DNS 名称遵循本节前述的模式。它看起来是这样的：
- en: '[PRE72]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let’s now take a look at exposing a service for the `nginx` pod. We’re using
    the following command to expose the `ClusterIP` service of the `nginx` pod on
    port `80`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何暴露 `nginx` Pod 的服务。我们使用以下命令将 `nginx` Pod 的 `ClusterIP` 服务暴露在端口 `80`
    上：
- en: '[PRE73]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The following output shows that it has been exposed successfully:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示服务已成功暴露：
- en: '[PRE74]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Based on the previous experiment with the `kube-dns` service DNS name, we can
    expect the `nginx-svc` service to follow the general service DNS name pattern,
    which will look as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 基于之前使用 `kube-dns` 服务 DNS 名称的实验，我们可以预期 `nginx-svc` 服务将遵循一般的服务 DNS 名称模式，结果将如下所示：
- en: '[PRE75]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, let’s take a look at the services currently in the `default` namespace
    of our Kubernetes cluster by using the following command:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下命令查看 Kubernetes 集群中 `default` 命名空间下当前的服务：
- en: '[PRE76]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We can see an output similar to the following:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到类似如下的输出：
- en: '![Figure 7.36 – The services in the Kubernetes default namespace  ](img/Figure_7.36_B18201.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.36 – Kubernetes 默认命名空间中的服务](img/Figure_7.36_B18201.jpg)'
- en: Figure 7.36 – The services in the Kubernetes default namespace
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.36 – Kubernetes 默认命名空间中的服务
- en: 'From the preceding output, we can get a closer look at `nginx-svc` by using
    the `kubectl get svc nginx-svc -o wide` command. The output is as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The preceding command shows that the IP address of `nginx-svc` is `10.107.75.83`,
    so let’s use the `nslookup` command to check out its DNS name. Use the following
    command:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The preceding command will give you the following output:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.37 – Returning the DNS name for nginx-svc by looking up the IP address
    ](img/Figure_7.37_B18201.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
- en: Figure 7.37 – Returning the DNS name for nginx-svc by looking up the IP address
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the preceding output, we can see that the DNS name for `nginx-svc`
    is `nginx-svc.default.svc.cluster.local`, which proves our assumption. Let’s get
    the DNS A record of `nginx-service` from the default namespace using the following
    command:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'You’ll see the output is similar to the following:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The preceding output shows the DNS server, which was what we saw earlier in
    this section – the `kube-dns` service with the IP address `10.96.0.10` and under
    the `kube-dns.kube-system.svc.cluster.local` DNS name. Also, for our `nginx-svc`,
    we get an IP address of `10.107.75.83` in return.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, similar to how we tested the `nginx` pod, let’s test out the connectivity
    of the `nginx` service. We can use a pod called `challenge-nginx` and then run
    the `curl` command to see what’s coming back. The complete command is as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The preceding command leads to the following output:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.38 – Returning the DNS name for nginx-svc by looking up the IP address
    ](img/Figure_7.38_B18201.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
- en: Figure 7.38 – Returning the DNS name for nginx-svc by looking up the IP address
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot with 200 responses proves the connectivity between
    the `nginx-challenge` pod and the `nginx-svc` service is good, and we managed
    to use the `curl` command on the main page of `nginx` with the DNS name of the
    `nginx` service. Knowing the `nginx` service is exposed from a `nginx` pod, in
    real life, we could deploy a number of replicas of this `nginx` pod, and expose
    them with one service. The traffic is distributed through the service to each
    pod.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered Kubernetes networking. It covered the Kubernetes networking
    model and core networking concepts, as well as how to choose CNI plugins. Working
    with the Ingress controller and configuring and leveraging CoreDNS in Kubernetes
    helps you understand how to manage cluster networking and controller access to
    the applications in Kubernetes.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have practiced these examples as you will encounter them often.
    Notice that this chapter covers 20% of the CKA exam content. Practicing the `kubectl`
    commands will help you with better time management, which leads to a greater chance
    of success in the CKA exam. Together with what we’ll talk about in the next chapter
    about monitoring and logging Kubernetes clusters and applications, you will get
    a better idea of how to manage Kubernetes clusters in your daily job as a Kubernetes
    administrator. Stay tuned!
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Mock CKA scenario-based practice test
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have two virtual machines, `master-0` and `worker-0`; please complete the
    following mock scenarios.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 1
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deploy a new deployment, `nginx`, with the latest image of `nginx` for two replicas
    in a namespace called `packt-app`. The container is exposed on port `80`. Create
    a service type of `ClusterIP` within the same namespace. Deploy a `sandbox-nginx`
    pod and make a call using `curl` to verify the connectivity to the `nginx` service.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 2
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Expose the `nginx` deployment with the `NodePort` service type; the container
    is exposed on port `80`. Use the `test-nginx` pod to make a call using `curl`
    to verify the connectivity to the `nginx` service.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 3
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make a call using `wget` or `curl` from the machine within the same network
    as that node, to verify the connectivity with the `nginx` `NodePort` service through
    the correct port.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 4
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `sandbox-nginx` pod and `nslookup` for the IP address of the `nginx`
    `NodePort` service. See what is returned.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 5
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `sandbox-nginx` pod and `nslookup` for the DNS domain hostname of the
    `nginx` `NodePort` service. See what is returned.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 6
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `sandbox-nginx` pod and `nslookup` for the DNS domain hostname of the
    `nginx` pod. See what is returned.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the scenario resolutions in [*Appendix*](B18201_Appendix_A.xhtml#_idTextAnchor386)
    *- Mock CKA scenario-based practice test resolutions* of this book.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: FAQs
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Where can I find the latest updates about Kubernetes networking while working
    with Kubernetes?*'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Kubernetes networking **Special Interest Group** (**SIG**) has a GitHub
    repository that you can follow here: [https://github.com/kubernetes/community/blob/master/sig-network/README.md](https://github.com/kubernetes/community/blob/master/sig-network/README.md).'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '*What is the recommended official Kubernetes article for Kubernetes networking?*'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I recommend bookmarking the official documentation about the following topics:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'Network policy: [https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/)'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ingress: [https://kubernetes.io/docs/concepts/services-networking/ingress/](https://kubernetes.io/docs/concepts/services-networking/ingress/)'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Troubleshooting'
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part covers Kubernetes troubleshooting-related topics ranging from cluster-
    and application-level logging and monitoring to cluster components and application
    troubleshooting, security, and networking troubleshooting. This part covers about
    30% of the CKA exam's content.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分涵盖与Kubernetes故障排除相关的主题，包括集群级和应用程序级的日志记录和监控，集群组件和应用程序故障排除，安全性以及网络故障排除。本部分内容大约占CKA考试内容的30%。
- en: 'This part of the book comprises the following chapters:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的这一部分包含以下章节：
- en: '[*Chapter 8*](B18201_08.xhtml#_idTextAnchor293), *Monitoring and Logging Kubernetes
    Clusters and Applications*'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18201_08.xhtml#_idTextAnchor293)，*监控和日志记录Kubernetes集群和应用程序*'
- en: '[*Chapter 9*](B18201_09.xhtml#_idTextAnchor340), *Troubleshooting Cluster Components
    and Applications*'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18201_09.xhtml#_idTextAnchor340)，*集群组件和应用程序故障排除*'
- en: '[*Chapter 10*](B18201_10.xhtml#_idTextAnchor366), *Troubleshooting Security
    and Networking*'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18201_10.xhtml#_idTextAnchor366)，*安全性和网络故障排除*'
