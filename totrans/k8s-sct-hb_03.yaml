- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encrypting Secrets the Kubernetes-Native Way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, we have reviewed together the foundational knowledge
    regarding the architecture, implementation, and usage of `Secret` objects within
    the Kubernetes architecture and design. We also established that `Secret` objects
    are not safe as-is within Kubernetes platforms due to their unencrypted nature,
    both in terms of key-value pair and the etcd data file, resulting in major security
    exposures for your business.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will get closer to both Kubernetes and etcd, understanding
    their associated security weaknesses and how we can mitigate or reduce them. While
    these responses could be considered tightly coupled with the container platform
    deployment, thanks to the open source nature of the operating system and Kubernetes
    distribution, most if not all can be applied widely.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on an in-platform approach, starting with the Kubernetes-native
    encryption design, including the possibility to connect with a **Key Management
    Service** (**KMS**), and concluding with an etcd hardening overview.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Native encryption without any external components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native encryption with an external component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption at rest of etcd and other components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To link concepts with hands-on examples, we are leveraging a series of tools
    and platforms commonly used to interact with containers, Kubernetes, and Secrets
    management. For this chapter, we are continuing with the same set of tools used
    in the earlier chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`systemd` at the user level to autostart containers/Pods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Podman Desktop** ([https://podman-desktop.io](https://podman-desktop.io))
    is an open source software providing a graphical user interface to build, start,
    and debug containers, run local Kubernetes instances, ease the migration from
    container to Pod, and even connect with remote platforms such as Red Hat OpenShift,
    Azure Kubernetes Engine, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Golang** ([https://go.dev](https://go.dev)) or Go is a programming language
    used within our examples. Note that Kubernetes and most of its third-party components
    are written in Go.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git** ([https://git-scm.com](https://git-scm.com)) is a version control system
    that we will be using to recover the book examples and also leverage in our discovery
    of Secrets management solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, the following tools will be looked at:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HashiCorp Vault** ([https://www.vaultproject.io/community](https://www.vaultproject.io/community))
    is a community vault with an enterprise offering to safely store credentials,
    tokens, and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trousseau** ([https://trousseau.io](https://trousseau.io)) is a KMS provider
    plugin to leverage external KMSs such as HashiCorp Vault, Azure Key Vault, or
    an AWS equivalent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following link gives you access to the digital material linked to this
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The GitHub repository: [https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes-native encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Data in payloads written in etcd is not encrypted but encoded in base64, which
    is almost equivalent to clear text. Encrypting the data contained in the payload
    will protect from the aforementioned protection mechanisms, but not* *replace
    them!*'
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly enough, we have established that our Kubernetes key-value store,
    also known as etcd, does not provide any encryption capabilities except for the
    networking part, nor does Kubernetes provide advanced KMS capabilities as HashiCorp
    Vault or Azure Key Vault would.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the Kubernetes project has designed a KMS framework within `kube-apiserver`,
    the service validating and configuring data for the API objects, to leverage one
    of the following encryption providers:'
  prefs: []
  type: TYPE_NORMAL
- en: The `identity` provider is the default configuration, meaning no encryption
    is applied to the data field encoded in base64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `aes` provider, with two options being `aesgcm` or `aescbc`, leverages the
    local encryption capabilities with a random encryption key generated by the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `kms` provider plugin connects `kube-apiserver` with an external KMS to
    leverage an envelope encryption principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way the KMS provider framework is configured is by enabling its capability
    at the `kube-apiserver` Pod’s (re)start time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We enable `kube-apiserver` with this capability as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We reference `kube-apiserver` with two configuration flags; one to enable the
    capability and reference a configuration file, and one to enable auto-reload when
    the changes are applied to the configuration file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A configuration file is to be deployed on every control plane node where the
    path and the name are defined within the configuration flag itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start with the configuration file, which is based on a YAML manifest
    referencing the `EncryptionConfiguration` API object and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This YAML manifest is an actual explicit version of what `kube-apiserver` is
    configured with by default, even when the capability is disabled. The manifest
    can be read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `resources` list; a reference to the Kubernetes API objects to encrypt being
    either `Secrets`, `ConfigMap`, or custom resources starting within Kubernetes
    version 1.25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `providers` list with precedence; a reference to the encryption mechanism
    being either `identity`, `aesgcm`, `aescbc`, or `kms`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned, the `providers` list has a precedence construct. This means that
    `kube-apiserver` will parse the list in a sequential way, which could have an
    impact on your operations. This will be illustrated within the hands-on examples.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way, to begin with, is to use the preceding default definition to
    set up our first `EncryptionConfiguration` file and to make sure that it is properly
    deployed on every control plane node.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This deployment, apart from the location and method, is heavily dependent on
    your Kubernetes distribution and we strongly invite you to verify the respective
    project/vendor documentation.
  prefs: []
  type: TYPE_NORMAL
- en: When using Kind from the Kubernetes projects, it can be simply referenced with
    an extra volume definition that we will illustrate within the hands-on examples.
    To ease this process, the file will be called `configuration.yaml` and deployed
    within the `/``etc/kubernetes/encryption` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve had a look at the `EncryptionConfiguration` file, let’s have
    a look at the flags to enable `kube-apiserver` with the provider(s) referenced
    within our configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an overview of the flags to enable the `kube-apiserver` Pod with encryption
    capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The flag to enable and reference the configuration file is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The flag, available since Kubernetes 1.26, to automatically reload the changes
    applied to the configuration file without restarting `kube-apiserver` is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following Pod definition snippet shows where to place these two flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have taken a look at how to enable these capabilities, let’s deep
    dive into the provider options.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone native encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The native encryption can be enabled without the need for any additional software,
    either on the control plane or externally to the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: identity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This provider is the default `kube-apiserver` configuration, which is equivalent
    to not transforming any data field payload to an encrypted one before storing
    it within etcd.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram provides an overview of the encryption workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Kubernetes workflow for the KMS identity provider](img/B20970_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Kubernetes workflow for the KMS identity provider
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram flow can be read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A user creates a `Secret` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kube-apiserver` checks the `EncryptionConfiguration` provider list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The provider refers to `identity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kube-apiserver` stores the base64-encoded `Secret` in etcd.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This provider doesn’t encrypt any of the `Secret` data field payload and is
    the default Kubernetes behavior at installation time. It can also be used to replace
    any encrypted Secrets with the following providers if needed.
  prefs: []
  type: TYPE_NORMAL
- en: aesgcm and aescbc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This provider uses the Golang AES encryption libraries to transform the data
    field payload of the listed resources to an encrypted one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The provider leverages the **Advanced Encryption Standard** (**AES**) and offers
    two modes:'
  prefs: []
  type: TYPE_NORMAL
- en: CBC, considered weak but fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCM, considered faster and less weak when key rotation is implemented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From an implementation perspective, we follow the same principles with both:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a 32-byte (or more) random encryption key encoded in base64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up the provider of your choice, `aescbc` or `aesgcm`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference the key within the `EncryptionConfiguration` configuration file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restart `kube-apiserver` if auto-reload is not enabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is fairly simple, both from a process and a `configuration.yaml` perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram provides an overview of the encryption workflow when
    a new `Secret` object is being created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Kubernetes workflow for the KMS aesgcm/aescbc provider](img/B20970_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Kubernetes workflow for the KMS aesgcm/aescbc provider
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram flow can be read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A user creates a `Secret` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kube-apiserver` checks the `EncryptionConfiguration` provider list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The provider refers to `aesgcm`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kube-apiserver` encrypts the data field payload with the provided key within
    the provider definition.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kube-apiserver` stores the encrypted `Secret` object in etcd.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `aesgcm` and `aescbc` providers are easy-to-implement solutions to encrypt
    the data field payload from the listed resources.
  prefs: []
  type: TYPE_NORMAL
- en: However, this simplicity comes with a trade-off; this solution leverages an
    encryption key that is again encoded in base64, referenced in a YAML manifest
    file, and stored on the local filesystem of each control plane node. With a system
    or a disk/filesystem breach, a malicious hacker can retrieve the encryption key
    and decrypt the payloads within the etcd data file.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, these providers are subject to multiple vulnerabilities, ranging from
    padding oracle attacks to birthday attacks or the ability to *guess* encryption
    keys based on the number of times that keys have been used to write encrypted
    payloads, enhancing the need for a proper automated key rotation strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Native encryption with an external component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The native encryption can be enabled by leveraging additional software, either
    on the control plane or externally to the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: kms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Kubernetes `kms` provider is a response to the security key exposure from
    the previous `aescbc` and `aesgcm` encryption providers by calling for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An external KMS, such as Azure Key Vault, HashiCorp Vault, or AWS Vault, to
    leverage the construct of the envelope encryption scheme.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A plugin, called Kubernetes KMS provider plugin, to interconnect `kube-apiserver`
    with one or multiple external KMSs. This approach reduces the `kube-apiserver`
    development, integration, and maintenance that would be required to support every
    KMS vendor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The KMS encryption is designed with an envelope encryption scheme using a two-key
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: A `kube-apiserver` and linked to the Kubernetes clusters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **key encryption key**, also known as a **KEK**, to encrypt the DEK. A KEK
    is generated and hosted remotely on the KMS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important notes
  prefs: []
  type: TYPE_NORMAL
- en: While it is possible to have a single KEK hosted on a remote KMS to address
    multiple Kubernetes clusters, this is not recommended as it would become a single
    point of failure and security exposure if the remote KMS was compromised. It is
    advised to consider one dedicated KEK per Kubernetes cluster and potentially multiple
    remote KMSs.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about the multi-tenancy requirement, it would make sense to even have
    a dedicated KEK per tenant, a feature that is currently not (yet) implemented
    at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the Kubernetes project has introduced KMSv2, the latest
    implementation of the KMS provider for `kube-apiserver`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the high-level functional purpose is identical, the design and implementation
    are slightly different. These differences could be impacting your compliance and
    regulation needs:'
  prefs: []
  type: TYPE_NORMAL
- en: In KMSv1, each `Secret` object creation generates a dedicated DEK during the
    transaction with each DEK being encrypted with the KEK calling the KMS, which
    impacts the performance when operating a large Kubernetes cluster environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In KMSv2, `kube-apiserver` generates a DEK at startup (or at the `EncryptionConfiguration`
    reload time), calls the KMS plugin to encrypt it using the remote KEK from the
    KMS server, caches the DEK, performs the encryption and decryption from memory,
    and will call the KMS for encryption only at restart or during key rotation. This
    redesign greatly improves the performance and resilience at a large scale.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram provides an overview of the encryption workflow for KMSv1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Kubernetes workflow for the KMS plugin v1 provider](img/B20970_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Kubernetes workflow for the KMS plugin v1 provider
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram flow can be read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A user creates a `Secret` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kube-apiserver` checks the `EncryptionConfiguration` provider list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The provider refers to KMSv1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kube-apiserver` generates a DEK.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kube-apiserver` encrypts the data field payload with the DEK.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kube-apiserver` requests the DEK encryption to the KMS plugin.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The KMS plugin requests the KMS to encrypt the DEK with the KEK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The KMS encrypts the DEK with the KEK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The KMS plugin returns the encrypted DEK to `kube-apiserver`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kube-apiserver` stores the encrypted `Secret` and DEK in etcd.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram provides an overview of the encryption workflow for KMSv2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Kubernetes workflow for the KMS plugin v2 provider](img/B20970_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Kubernetes workflow for the KMS plugin v2 provider
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram flow can be read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A user creates a `Secret` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kube-apiserver` checks the `EncryptionConfiguration` provider list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The provider refers to KMSv2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is no existing DEK, `kube-apiserver` will generate one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a DEK was generated, `kube-apiserver` requests the DEK encryption to the
    KMS plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The KMS plugin requests the KMS to encrypt the DEK with the KEK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The KMS encrypts the DEK with the KEK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The KMS plugin returns the encrypted DEK to `kube-apiserver`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kube-apiserver` stores the encrypted DEK in etcd.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kube-apiserver` encrypts the data field payload with the DEK.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kube-apiserver` stores the encrypted `Secret` in etcd.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `kms` provider adds complexity in terms of configuration. This method complies
    with all regulations requiring external key management while addressing most if
    not all of our onion layers.
  prefs: []
  type: TYPE_NORMAL
- en: KMS provider plugin example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As described earlier, the `kms` provider requires an additional third-party
    software called a `kms` provider plugin to connect `kube-apiserver` with an external
    KMS, such as HashiCorp Vault or any other KMS supported by the plugin being used.
  prefs: []
  type: TYPE_NORMAL
- en: The plugin will be deployed on the control plane nodes as a local UNIX socket
    to interact directly with `kube-apiserver` without going through the network,
    which could be a potential security exposure.
  prefs: []
  type: TYPE_NORMAL
- en: A community project such as *Trousseau* ([https://trousseau.io](https://trousseau.io)),
    among others, provides this capability to extend the `kube-apiserver` capabilities
    with HashiCorp Vault, Azure Key Vault, and AWS KMS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting hands-on with key-value data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Within the Git repository, in the `ch03` folder, you will find a walkthrough
    to deploy a new Kind cluster using Podman or Docker, using a specific cluster
    configuration file to get a ready-to-use instance with the default `EncryptionConfiguration`
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The how-to includes a quick intro to the Kind configuration file allowing us
    to enable specific flags for `kube-apiserver`, and explains how to mount a specific
    folder to the Pod with a configuration file. This will help you in the future
    to interact with other Kubernetes distributions leveraging the same principles.
  prefs: []
  type: TYPE_NORMAL
- en: From there, you will have a chance to implement each provider and create and
    replace `Secret` objects with their new revisions being encrypted with the provider
    in question. This approach will highlight the capability to move from one provider
    to another without a major operational burden.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the hands-on examples will help you to verify that each `Secret` object
    has been encrypted with the appropriate combination of provider, key, and version
    if applied by dumping the entries directly from the etcd data store.
  prefs: []
  type: TYPE_NORMAL
- en: Precedence
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As previously mentioned, the provider list has a precedence evaluation or,
    in other words, a sequential order to consider during implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: When creating a new `Secret`, `kube-apiserver` will use the first provider listed
    to encrypt or not, if the provider is `identity`, the data field payload for the
    listed resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When reading an existing `Secret`, `kube-apiserver` will check the Secret header
    to define the KMS provider, its version, and the associated key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is a match, it will try to decrypt the `Secret` data field payload
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no match, an error will be returned
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All existing Secrets could be replaced with a newer revision by changing the
    provider list order. The most common example would be to introduce a new KMS provider,
    such as `aesgcm`, and replace all unencrypted Secrets with a newer revision that
    will be encrypted with the `aesgcm` provider. This particular case is illustrated
    within the hands-on example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This implementation example of a `kms` provider showcases the usage of an external
    KMS service. Note that the `kms` v1 provider is deprecated with version 1.28 of
    Kubernetes in favor of a more resilient `kms` v2 that’s capable of sustaining
    network partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: Going further with securing etcd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section described the native encryption capabilities provided by
    Kubernetes at the application layer or, in other words, how to secure sensitive
    data from `Secret` and `ConfigMap` objects being processed by the Kubernetes API
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the deployment type, whether on-premises or in the cloud, other
    layers can benefit from encryption to avoid or reduce security exposures:'
  prefs: []
  type: TYPE_NORMAL
- en: When self-deploying on-premises or in the cloud using physical or virtual machines,
    the Kubernetes `EncryptionConfiguration` API object is stored as a file on disk;
    accessing this configuration file, as well as the etcd data file, will compromise
    all sensitive data recorded as part of the API objects in etcd.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When consuming a managed Kubernetes instance from a cloud provider, the control
    plane becomes their responsibility. However, not all services are equal and some
    require a thorough review of the configuration to ensure that the cloud provider
    you are selecting is handling the encryption at rest on its infrastructure level
    and allows you to enable the Kubernetes native encryption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Considering the following onion diagram, we can list the illustrated components
    as potential exposure points to be addressed to mitigate unauthorized access to
    the data within etcd, including Secrets and ConfigMaps. This section provides
    you with an analysis of each component in terms of security risk and related mitigation(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – The etcd security exposure presented as onion layers](img/B20970_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – The etcd security exposure presented as onion layers
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the numerous combinations of Linux and Kubernetes distributions, not
    to even mention the extensive cloud provider offerings, this chapter provides
    an extensive hands-on section on the key-value data while sharing guidance on
    all other components, for which the following references will help you with implementing
    a security and hardening profile for your systems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tevault, Donald A. (2023). *Mastering Linux Security and Hardening: A Practical
    Guide to Protecting Your Linux System from Cyber Attacks* by *Packt Publishing*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kalsi, Tajinder. (2018). *Practical Linux Security Cookbook: Secure Your Linux
    Environment from Modern-Day Attacks with Practical Recipes* by *Packt Publishing*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also worth noting that cloud providers are doing most of the heavy lifting
    to encrypt at-rest disks and filesystems to mitigate related attack vectors. However,
    all of them advise leveraging the Kubernetes `EncryptionConfiguration` API server
    configuration for end-to-end encryption.
  prefs: []
  type: TYPE_NORMAL
- en: Linux system hardening
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*The art of operating system hardening is to reduce the access breach exploits
    to zero. From our context, it means no remote access via the operating system
    to the etcd* *data file.*'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to appreciate the effort from Linux distributions to include
    the concept of security profiles, leveraging standards such as SCAP at the early
    stage of system installation, and helping with relevant and consistent hardening
    based on your organization’s needs. A series of industry-specific profiles, such
    as CIS Benchmarking and NIST, are offered at the deployment time, helping to configure
    the operating system with the necessary rules to comply with the chosen regulation.
    These rules are explained when using the graphical user interface or can be found
    within the vendor documentation. No matter your preferred installation method
    – text, graphical, or kickstart – all can benefit from such hardening automation.
  prefs: []
  type: TYPE_NORMAL
- en: This approach helps to reduce the pressure on the Ops team. By automating the
    relevant 100+ specific configuration rules, complying with a regulatory profile
    such as PCI-DSS can easily be achieved without reading its 360 pages of requirements.
    This would complement the 190+ pages of the Red Hat Security Hardening reference
    guide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the system has been deployed with the appropriate security policy relevant
    to your organization’s industry, the OpenSCAP bench toolset can be used to scan
    your entire install base to provide you with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A tailor-fit audit per Linux distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shareable audit file including a risk-scoring system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mitigation strategy with the most common toolsets (Shell script, Puppet, Ansible,
    and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the following for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenSCAP: [https://www.open-scap.org/](https://www.open-scap.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenSCAP PCI-DSS rules: [http://static.open-scap.org/ssg-guides/ssg-rhel9-guide-pci-dss.html](http://static.open-scap.org/ssg-guides/ssg-rhel9-guide-pci-dss.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Red Hat Enterprise Linux security hardening: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html-single/security_hardening](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html-single/security_hardening)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardening a Linux system includes tasks pre- and post-installation. To avoid
    redeploying your operating system, enable the appropriate security profile and
    disk encryption during the installation process. Most Linux distributions, such
    as the Red Hat Enterprise Linux 9, have a graphical user interface to set a specific
    security profile and provide you with a list of mandatory configuration changes
    to comply with the chosen profile.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository has two examples within the `ch03` folder demonstrating
    the hardening of a Linux system using the installer graphical interface and a
    kickstart file.
  prefs: []
  type: TYPE_NORMAL
- en: Linux data encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Stealing a disk or a server is a serious concern, and it happens more often
    than we could believe. But it is not only for on-premises infrastructure; cloud
    virtual disks could be stolen too thanks to hypervisor exploits that could leak
    the disk file, which means all your business-critical systems have their credentials*
    *leaked too.*'
  prefs: []
  type: TYPE_NORMAL
- en: Since etcd does not offer any encryption capabilities (at the time of writing),
    the data file that will be stored on the control plane node filesystem can be
    accessed and easily read to recover our `Secret` object payload, as shown in [*Chapter
    1*](B20970_01.xhtml#_idTextAnchor015), *Understanding Kubernetes Secrets Management*.
    This means that any physical deployment scenarios colocated on-premises and with
    edge computing would result in security exposures when an attacker steals the
    disk(s) or node(s).
  prefs: []
  type: TYPE_NORMAL
- en: To address this concern, the disk and filesystem will need to be encrypted.
    Why both, you ask? While a `Secret` objects used to access your cloud, application,
    and storage accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Disk encryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FDE, sometimes referred to as **self-encrypting disk** (**SED**), is an interesting
    starting point to provide a fully offloaded encryption process from the host,
    reducing the attack surface. It is transparent to both the operating system and
    the applications (no drivers or libraries to maintain). FDE guarantees a high
    level of compatibility, supportability, and portability across different hardware
    and software combinations.
  prefs: []
  type: TYPE_NORMAL
- en: All FDE/SED disks are delivered with a zero-length authentication key/password
    to ease the initial setup, especially if there is no user requirement to do so.
    When defining an authentication key or password, the DEK is stored on the disk
    and protected with the defined custom user key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of this workflow are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Protection from physical theft of the disk(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting the data even before boot time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling re-key options for compelling events and compliance purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pitfalls are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Booting requires user interaction to input the authentication key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Losing the key means losing the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hacking is still a possibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Indeed, the effectiveness of these disks could be challenged, with different
    approaches demonstrating how to access and compromise the data on these disks
    provided by these two references:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Hardware-based Full Disk Encryption (In)Security* by Tilo Müller, Tobias Latzo,
    and Felix C. Freilling from System Security Group at Friedrich-Alexander Universität:
    [https://www.cs1.tf.fau.de/research/system-security-group/sed-insecurity/](https://www.cs1.tf.fau.de/research/system-security-group/sed-insecurity/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perform an internet search with the following terms: `NSA disk` `firmware hack`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that most professional-grade disks (mechanical or chip-based) offered in
    servers and storage arrays are delivered with such technology. This is the first
    hardware layer of protection to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem encryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it comes to encrypting a Linux filesystem, multiple approaches could be
    considered, including both open source and proprietary options. For this section,
    we will have a look at three open source solutions, from easy to complex, from
    the perspective of requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Plain device-mapper encryption
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The usage of device-mapper encryption with `dm-crypt` is an obvious and simple
    choice as it performs a block-level encryption on an unpartitioned disk. This
    technique provides disk-level encryption that could be accessible with a so-called
    garbage random data introducing a deniable encryption method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of using device-mapper encryption are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Full disk encryption is provided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No partition tables are exposed, nor are the UUID or LABEL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a robust solution in case of a disaster (in a LUKS setup, if the
    header is destroyed, the data is lost)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pitfalls are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A high level of mastery of device mapping is required to ensure proper configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single passphrase with no key rotation is a potential issue with specific
    compliance/regulation requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no key derivation function that would reduce the vulnerability to brute-force
    attacks when passphrases are generated with a lack of entropy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no support for the TRIM command on solid-state drives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the following for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project: [https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/dm-crypt.html](https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/dm-crypt.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementation on Arch Linux: [https://wiki.archlinux.org/title/Dm-crypt](https://wiki.archlinux.org/title/Dm-crypt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux Unified Key Setup (LUKS)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'LUKS can be considered as a universal disk encryption software with secure
    password management implemented in its core. This allows us to overcome some if
    not all of the pitfalls linked to key derivation, rotation, and multiple passphrase
    capabilities. Along with these, LUKS is compatible with the **logical volume management**
    (**LVM**) and software RAID scenario for interesting solutions that would address
    different needs and compliance/regulation requirements. Here are a few examples
    where LUKS can be integrated with other solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: LUKS on a partition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LVM on LUKS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LUKS on LVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LUKS with software RAID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LUKS can also be complementary to other solutions to provide additional security
    responses. A plain device mapper and a headerless LUKS implementation would set
    up a deniable encrypted device (no header). This method would also address the
    key rotation requirement with capabilites for key derivation and multiple passphrases.
    This could be the best of both worlds, a solution that I would appreciate the
    most when no external KMS is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project: [https://gitlab.com/cryptsetup/cryptsetup/blob/master/README.md](https://gitlab.com/cryptsetup/cryptsetup/blob/master/README.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementation on Red Hat Enterprise Linux: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/encrypting-block-devices-using-luks_security-hardening](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/encrypting-block-devices-using-luks_security-hardening)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device mapper with LVM and LUKS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As listed in the LUKS section, there are multiple combinations to implement
    disk encryption using LUKS. However, each setup comes with benefits and trade-offs,
    sometimes major ones, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: LVM on LUKS would ease the partitioning and protect the volume layout when locked,
    but relies on a single encryption key with all volumes being encrypted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LUKS on LVM provides flexibility to support un/encrypted volumes while being
    complex to maintain and less secure by exposing the volume layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For both the device mapper and LUKS solutions, the usage of TRIM with solid-state
    drives could be a security exposure or a security response.
  prefs: []
  type: TYPE_NORMAL
- en: With a plain mode `dm-crypt`, if TRIM is enabled, it will eventually expose
    the encryption and could leak enough data from freed blocks to discover the encryption
    pattern. However, if there is no hard requirement for both data and deniable encryption,
    then it can be safely enabled as there will be a significant performance improvement.
  prefs: []
  type: TYPE_NORMAL
- en: With LUKS, the header is stored at the beginning of the device. If there is
    a passphrase rotation, the previous one will be revoked and TRIM will help to
    free the blocks. If not, then an attacker could research the device to get the
    old header and decrypt the disk.
  prefs: []
  type: TYPE_NORMAL
- en: For increased security with LUKS, the usage of a (virtual) **Trusted Platform
    Module** (**TPM**) can be leveraged to store and handle the automatic unlocking
    of the drives while booting. This removes the manual typing of the passphrase
    but could expose the key and thus the data if the server is stolen.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid complexity, rely on the risk analysis approach to define the needs
    regarding your specific environment and how to comply with your regulations. Then,
    select a filesystem encryption method that addresses your requirements and the
    operational team’s skills.
  prefs: []
  type: TYPE_NORMAL
- en: Network-bound disk encryption (NBDE)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Key management services, also called key escrow in this context, offload the
    encryption key to a remote service to avoid some of the pitfalls listed in the
    previous solutions. Keys are stored in a vault-like data store and thus require
    high availability and backup strategies to guarantee the availability and survival
    of the encryption keys. If not, the data on the disk will be lost forever. Note
    that backups also need to be secured to avoid any key leaks from side channels
    or opportunistic hacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **network-bound disk encryption** (**NBDE**) solution solves these challenges
    by introducing a multilayering of security:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses the HTTP/HTTPS protocol to ease the network configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of servers created with a predefined quorum to provide encryption/decryption
    capabilities. If the quorum is not met, the decryption will not happen until that
    instance is back online. This creates the notion of network dependencies, or the
    network on which the disk should be connected to access all NBDE servers before
    allowing the exposure of its content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symmetric encryption keys being split across all the NBDE servers with an easy-to-(re)distribute
    public key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce key management, no vault, and no high availability and backup necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow transparent reboot when all conditions are met.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protect against a disk or server and its disks being stolen, unless the entire
    NBDE setup is stolen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This solution is not as hard as it sounds to implement. Such implementation
    can be put in place in no time while addressing the most rigid compliance and
    regulation requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example of a project for a resilient KMS for NBDE: [https://github.com/latchset/tang](https://github.com/latchset/tang)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example of an NBDE implementation on Red Hat Enterprise Linux: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption_security-hardening](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption_security-hardening)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example of NBDE with Tang server implementation on Red Hat OpenShift: [https://docs.openshift.com/container-platform/4.13/security/network_bound_disk_encryption/nbde-about-disk-encryption-technology.html](https://docs.openshift.com/container-platform/4.13/security/network_bound_disk_encryption/nbde-about-disk-encryption-technology.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*The entire Kubernetes design is based on API-driven architecture. This means
    that any exchange of payloads needs to be done through a secure channel using
    Transport Layer Security (TLS). If not, exchanges with etcd will be readable from
    the wire, including sensitive data from* *the Secrets.*'
  prefs: []
  type: TYPE_NORMAL
- en: Most Kubernetes distributions have TLS enabled by default and provide Ops with
    TLS security profile options to guarantee compatibility between services and applications
    interacting with each other. In Red Hat OpenShift, a granular approach allows
    the Ops to configure a specific TLS security profile for the ingress, the kubelet,
    and the control plane components, the latter including etcd.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the service endpoint could also be enforced with a TLS termination
    handled by external network equipment or software, such as a load balancer. While
    this approach would secure network flow from the end user accessing the API server
    with a fully qualified domain name, this will not protect the internal Kubernetes
    network flow if left without any TLS termination. Both should be considered to
    guarantee an improved security posture.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'etcd transport security model: [https://etcd.io/docs/v3.5/op-guide/security/](https://etcd.io/docs/v3.5/op-guide/security/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Red Hat OpenShift: [https://docs.openshift.com/container-platform/4.13/security/tls-security-profiles.html#tls-profiles-kubernetes-configuring_tls-security-profiles](https://docs.openshift.com/container-platform/4.13/security/tls-security-profiles.html#tls-profiles-kubernetes-configuring_tls-security-profiles)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While security measures depend on the organization’s compliance and regulation
    requirements, a risk-based assessment will define the appropriate actions to harden
    your information systems. However, securing Kubernetes Secrets is not optional
    but a must.
  prefs: []
  type: TYPE_NORMAL
- en: Given the current trend of adopting hybrid multi-cloud patterns, having one
    cluster’s etcd compromised, whether it is on the cloud or self-managed, could
    lead to compromising the entire environment. These types of attack leverage in-cluster
    network connections or a fleet management tool for which the token would be recorded
    within the compromised etcd. Such a scenario would lead to a viral attack infecting
    every connected endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: As a remediation, the native Kubernetes encryption – more specifically, the
    `kms` provider – is a best practice security pattern supported by all the major
    cloud and software providers.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, security is not a finite game but a continuous effort. Regular audits
    and scans of your ever-changing environment will provide you with the most current
    state of compliance. They will also help to build a backlog of tasks to mitigate
    known vulnerabilities and misconfigurations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the debugging and troubleshooting techniques
    to analyze unexpected behaviors when configuring and consuming Kubernetes Secrets.
  prefs: []
  type: TYPE_NORMAL
