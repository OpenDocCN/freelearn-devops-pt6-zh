- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Cloud Secret Store on GCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we did a deep dive into Azure Key Vault. We managed to store Secrets
    securely on Key Vault and utilized it as a key management service for the Secrets
    that will reside on etcd. In this chapter, we will focus on the Google Cloud Platform
    and will utilize the Secret Manager of Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of GCP Secret Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workload Identity on GKS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GKE and GCP Secret Manager integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auditing and logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GKE and KMS integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we should be able to store our Secrets to GCP Secret
    Manager securely, monitor secret access through auditing, and add an extra layer
    of security by encrypting the Secrets on etcd.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To link concepts with hands-on examples, we are leveraging a series of tools
    and platforms commonly used to interact with the Google Cloud API and Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**gcloud CLI** ([https://cloud.google.com/sdk/gcloud#download_and_install_the](https://cloud.google.com/sdk/gcloud#download_and_install_the))
    is a set of tools to create and manage Google Cloud resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terraform** ([https://www.terraform.io/](https://www.terraform.io/)) is infrastructure-as-code
    software that can be used to provision and manage infrastructure on the cloud'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kubectl** ([https://kubernetes.io/docs/reference/kubectl/](https://kubernetes.io/docs/reference/kubectl/))
    is the command-line tool used for communicating with a Kubernetes cluster through
    the Kubernetes API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of GCP Secret Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GCP Secret Manager is the secret manager solution provided by Google Cloud.
    Provided that we have an application that has the need to store Secrets, the Secret
    Manager can be utilized. The application can be deployed on Compute Engine, Kubernetes,
    Cloud Functions, or any other legitimate form of deployment on Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this service is managed by Google Cloud, there are some features offered
    by default. We can summarize them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: IAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging and auditing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with other Google Cloud components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s have a deep dive into each one.
  prefs: []
  type: TYPE_NORMAL
- en: IAM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google Cloud comes with **identity access management** (**IAM**). Certain IAM
    permissions take effect on an organizational level, allowing us to manage an organization’s
    resources. Then we have IAM permissions that apply project-wide, thus they are
    permissions assigned to target specific resources throughout a GCP project. The
    most granular level is resource-based IAM permissions. When we create a resource,
    we can have permissions only for that specific resource. The identities can be
    either users, Google Groups, or service accounts. Permissions for a specific resource
    can be assigned to a specific identity.
  prefs: []
  type: TYPE_NORMAL
- en: High availability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Secret Manager is a highly available solution and covers disaster recovery scenarios.
    By default, the Secrets can be accessed globally from different regions of Google
    Cloud. Behind the scenes, the Secrets are replicated in multiple regions unless
    specified otherwise. A reason to specify the regions is data residency limitations.
    If a secret cannot be stored in a certain region, we can define the regions we
    want the secret to be stored in and exclude any regions that should not contain
    any of our data.
  prefs: []
  type: TYPE_NORMAL
- en: Logging, auditing, and monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google Cloud has, by default, a logging solution that is used for application
    logs but also for audit logs. There is a distinction between application logs
    and audit logs. To be able to access audit logs on a GCP project, you need to
    have the Private Logs Viewer permission.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with other Google Cloud components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As expected, Secret Manager is integrated with other Google Cloud components.
  prefs: []
  type: TYPE_NORMAL
- en: We can use a **key management service** (**KMS**) to encrypt the Secrets on
    Secret Manager and we can integrate Secret Manager with Kubernetes. As we have
    seen in [*Chapter 8*](B20970_08.xhtml#_idTextAnchor157), *Exploring Cloud Secret
    Store on AWS*, the integration with Secret Manager on Kubernetes happens through
    the CSI plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Workload Identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Workload Identity on Kubernetes Engine on GCP enables us to assign permissions
    to Kubernetes workloads that can interact with Google Cloud resources. Google
    Cloud has the concept of service accounts. Service accounts are used for machines
    to interact with resources. A compute engine, a lambda function, or even an App
    Engine on Google Cloud can be assigned with a service account that has permissions
    to interact with Google Cloud resources. With Workload Identity, we can map service
    accounts on GCP with service accounts on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: In Kubernetes, we might use several types of deployments for our applications.
    We can use `Deployment`, `StatefulSet`, `DaemonSet`, and more. Behind the scenes,
    a Pod will be created, which is the base component for running applications on
    Kubernetes. The Pod can be assigned a service account. By using Workload Identity
    on Kubernetes and binding a Kubernetes service account to a Google Cloud service
    account, the Pod with the Kubernetes service account attached shall be able to
    interact with Google Cloud resources based on the permissions we granted on the
    GCP service account.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, this concept will help us with GCP Secret Manager. The access from
    our Kubernetes workload to Secret Manager will be authorized and feasible, thanks
    to the integration of Kubernetes CSI and the Workload Identity.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how Kubernetes and Secret Manager on Google Cloud work
    together, we will focus on implementing a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating GKE and GCP Secret Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to the CSI Secret Store plugins, we can integrate Secret Manager solutions
    with our Kubernetes cluster. The Kubernetes offering on Google Cloud is the Google
    Kubernetes engine. We will use this Kubernetes cluster offering to integrate with
    Secret Manager.
  prefs: []
  type: TYPE_NORMAL
- en: There are several options to create a cluster. We will provide the Terraform
    code for the scope of creating the cluster. Also, we will provide other commands
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Terraform project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to configure the Terraform provider. It will point to the GCP credentials
    file and also to the GCP project and the region.
  prefs: []
  type: TYPE_NORMAL
- en: 'The provider configuration should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize, we need to run the `init` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When we run the `init` command when a credentials file is not specified, the
    credentials by default will be the credentials of the user who logged in when
    we used the `gcloud auth login` command. Alternatively, we can specify a service
    account file.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning the network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We shall proceed with provisioning the network. On Google Cloud, a network is
    a global resource, whereas the subnets of a network are regional resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the network, and as expected, no region will be specified since
    VPC is a global resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The subnetwork will be created to host the nodes on Kubernetes. It will be
    mapped to the region specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can now focus on creating Secrets on Secret Manager.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning a secret on Secret Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GCP Secret Manager is a service; to use Secret Manager on GCP, we do not need
    to create a resource. Instead, we create the Secrets that will be hosted on Secret
    Manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will get started by provisioning a secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We purposefully specified the region where the replicas will reside. The secret
    will be hosted in two regions, making our secret usage resilient, even during
    a region outage.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created the secret, but we did not assign a specific value. For a secret,
    we specify a version of that secret. Let us proceed with adding the version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we would like to provision a service account with permissions to retrieve
    the secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The secret is provisioned, and we have a service account to be used for retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s go ahead and create the GKE cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning the GKE cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the GKE cluster we need to create the master, and we will also create
    a default node pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When creating a cluster, GKE forces us to create an initial node pool by default.
    We can create another node pool of our choice using the `google_container_node_pool`
    resource. This way, we can tune more parameters of a GKE node pool in Terraform
    and separate the cluster and the node pool definitions. Once the new node pool
    is created, provided we have the `remove_default_node_pool` setting set to `true`,
    Terraform will remove the initial node pool. This will keep the costs low since
    only one node pool will be operational.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary node pool will be targeted toward keeping the costs low:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We have been successful in creating the cluster. We can also log in to the
    cluster and issue some `kubectl` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our GKE cluster is operational and ready to serve our workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the CSI plugin for Kubernetes Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have an operational cluster; therefore, we will focus on setting up the CSI
    plugin. On a standard GKE cluster, the CSI plugin has to be installed. When it
    comes to GKE Autopilot, a GKE version that manages many aspects of Kubernetes
    out-of-the-box, the CSI plugin is installed by default.
  prefs: []
  type: TYPE_NORMAL
- en: Take note that the CSI plugin is not officially supported by Google.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install the plugin to the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we should create a service account. The Kubernetes service account will
    be annotated with the ID of the GCP service account that we want our workloads
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This way, the service account of Kubernetes will act on behalf of the service
    account we created previously. The service account is able to retrieve the Secrets
    from Secret Manager.
  prefs: []
  type: TYPE_NORMAL
- en: '`SecretProviderClass` is a custom resource type providing driver configurations
    and parameters to the CSI driver. We shall specify `SecretProviderClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to create a Pod. The Pod will use the Workload Identity and
    act on behalf of the `read-secrets-service-account` GCP account. Also, the Pod
    will use `SecretProviderClass` we created previously and mount the Secrets to
    the Pod as a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: What we have achieved is to mount the secret to the Pod using the CSI plugin.
    We can now focus on monitoring the usage of Secrets. Auditing and logging play
    a crucial role in identifying operations on a cloud resource or Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing and logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Google Cloud comes with logging and auditing out-of-the-box. Once we provision
    a Kubernetes cluster, all the operations will be visible through the logging console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we create a secret on the cluster we provisioned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This action will be logged on the audit logs of GKE, and all we must do is
    search the logging console on GCP using the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, we should see all the operations upon accessing Secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Kubernetes audit logs on GKE](img/B20970_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Kubernetes audit logs on GKE
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from audit logs on Kubernetes, we can also utilize the audit logs on
    Secret Manager. On the logging screen of GCP, we can search specifically for audit
    logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This GCP log query filter will enable us to see the logs related to Secret Manager.
  prefs: []
  type: TYPE_NORMAL
- en: GKE security posture dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another notable tool provided by GCP to improve the security posture of a GKE
    cluster is the **GKE security posture** dashboard. The GKE security posture dashboard
    is a set of features in the Google Cloud console scanning GKE clusters and workloads,
    offering opinionated, actionable recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: 'GKE security posture focuses on two sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes security posture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workload vulnerability scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Through the Kubernetes security posture dashboard, when a vulnerability is
    discovered, it is automatically displayed on the dashboard with the clusters and
    workloads affected in order to enable us to proceed with further actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – GKE security posture](img/B20970_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – GKE security posture
  prefs: []
  type: TYPE_NORMAL
- en: Through workload vulnerability scanning, the container images running in the
    clusters are scanned for vulnerabilities. Also, there is support for scanning
    the actual programming language packages for vulnerabilities, making the workloads
    even more secure.
  prefs: []
  type: TYPE_NORMAL
- en: As expected, the findings of the GKE security posture are integrated with other
    cloud components such as logging and monitoring, thus making it feasible to have
    alerts and enable automation when it comes to tackling any security incidents.
  prefs: []
  type: TYPE_NORMAL
- en: Now that auditing and logging are in place, we can proceed with the more advanced
    concept of encrypting Secrets by integrating GKE and KMS.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating GKE and KMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is feasible to use KMS to encrypt the Secrets on the Google Kubernetes Container
    Engine. By default, GKE will encrypt data at rest, and the encryption is managed
    by GCP. Apart from this secure handling of our data, we might want to have more
    control over the encryption of the data. In this case, we have the option to encrypt
    the data residing on Kubernetes by using a KMS key that we provision and maintain
    in our GCP project. We shall start by provisioning the KMS key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also assign permissions in order for the Kubernetes service account
    to be able to perform encryption and decryption. Take note that on GKE, the master
    is managed by GCP, and the service account that the master nodes use is not a
    service account residing on our Google Cloud project, thus we need to assign permission
    to a service account that is not part of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We just created the KMS. In our cluster configuration, let’s enable the database
    encryption option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Instead of GCP using its own KMS key, we supply our own **customer-managed key**
    (**CMK**). Our Secrets on Kubernetes will be encrypted by using the KMS key we
    provided.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we had a deep dive into Secrets management on Google Cloud
    and GKE. We learned about Secret Manager, the GCP offering for Secrets management,
    and the features that come with it such as availability, auditing, and integration
    with other Google Cloud components. We then proceeded to provision a Kubernetes
    Engine on GCP using the GKE offering and integrated it with Secret Manager. Then
    we used KMS to encrypt the Secrets on Kubernetes at rest. Finally, by using Google
    Cloud monitoring, we managed to keep track of the secret operations on Kubernetes,
    Secret Manager, and the KMS. In the next chapter, we will focus on the non-cloud-based
    secret managers: HashiCorp Vault and CyberArk Conjur.'
  prefs: []
  type: TYPE_NORMAL
