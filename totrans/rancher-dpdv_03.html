<html><head></head><body>
		<div id="_idContainer008">
			<h1 id="_idParaDest-26"><em class="italic"><a id="_idTextAnchor025"/>Chapter 2</em>: Rancher and Kubernetes High-Level Architecture</h1>
			<p>This chapter will cover the high-level processes of <strong class="bold">Rancher</strong>, <strong class="bold">Rancher Kubernetes Engine</strong> (<strong class="bold">RKE</strong>), <strong class="bold">RKE2</strong> (also known as <strong class="bold">RKE Government</strong>), <strong class="bold">K3s</strong>, and <strong class="bold">RancherD</strong>. We will discuss the core design philosophy of each of these products and explore the ways in which they are different. We'll dive into Rancher's high-level architecture and see how Rancher server pods communicate with downstream clusters using the Cattle agents, which include both the Cattle-cluster-agent and the Cattle-node-agent. We'll also look at how the Rancher server uses RKE and how Rancher-machine provisions downstream nodes and Kubernetes (<strong class="bold">K8s</strong>) clusters. After that, we'll cover the high-level architecture of K8s, including <strong class="bold">kube-api-server</strong>, <strong class="bold">kube-controller-manager</strong>, and <strong class="bold">kube-scheduler</strong>. We'll also discuss how each of these components maintains the state of the cluster. Finally, we'll examine how an end user can change the desired state and how the controllers can update the current state.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>What is the Rancher server?</li>
				<li>What are RKE and RKE2?</li>
				<li>What is K3s (five less than K8s)?</li>
				<li>What is RancherD?</li>
				<li>What controllers run inside the Rancher server pods?</li>
				<li>What does the Cattle agent do?</li>
				<li>How does Rancher provision nodes and clusters?</li>
				<li>What are kube-apiserver, kube-controller-manager, kube-scheduler, etcd, and kubelet?</li>
				<li>How do the current state and the desired state work?</li>
			</ul>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>What is the Rancher server?</h1>
			<p>The <strong class="bold">Rancher server</strong> forms the core of the Rancher ecosystem, and it contains almost everything needed by any <a id="_idIndexMarker047"/>other component, product, or tool depending on or connecting to the Rancher server via the Rancher API. The <em class="italic">Rancher server</em> is usually shortened to just <em class="italic">Rancher</em>, and in this section, when I say <em class="italic">Rancher</em>, I will be talking about the <em class="italic">Rancher server</em>.</p>
			<p>The heart of Rancher is its API. The <strong class="bold">Rancher API</strong> is built on a custom API framework called <strong class="bold">Norman</strong> that acts as a <a id="_idIndexMarker048"/>translation layer between the Rancher API and the K8s API. Everything in <a id="_idIndexMarker049"/>Rancher uses the Rancher or K8s API to communicate. This includes <a id="_idIndexMarker050"/>the Rancher <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>), which is 100% API-driven. </p>
			<p>So, how do you connect to the Rancher API? The Rancher API is a standard <strong class="bold">RESTful API</strong>. This means that a <a id="_idIndexMarker051"/>request flows from an external HTTP or TCP load balancer into the ingress controller, and then the request is routed to one of the Rancher server pods. Norman then translates the request into a K8s request, which then calls a <strong class="source-inline">CustomResource</strong> object. Of course, because everything is being stored in a <strong class="source-inline">CustomResource</strong> object in K8s, the Rancher request flow is stateless and doesn't require session persistence. Finally, once the <strong class="source-inline">CustomResource</strong> object is created, changed, or deleted, the controller for the object type will take over and process that request. We'll go deeper into the different controllers later in this chapter.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>What are RKE and RKE2?</h1>
			<p>What do I need, RKE or RKE2? Traditionally, when building a K8s cluster, you would need to carry out several steps. First, you'd need to generate a root <strong class="bold">CA key</strong> as well as the certificates for the <a id="_idIndexMarker052"/>different K8s components and push them out to every server that <a id="_idIndexMarker053"/>was part of the cluster. Second, you'd then install/configure <strong class="bold">etcd</strong>, and this would include setting up the <strong class="bold">systemd</strong> service on your management nodes. Next, you would need to bootstrap <a id="_idIndexMarker054"/>the etcd cluster and verify that all etcd nodes were communicating and replicating correctly. At this point, you would install kube-apiserver and connect it back to your etcd cluster. Finally, you would need to install kube-controller-manager and kube-scheduler and connect them back to the kube-apiserver objects. If you wanted to bring up the control plane for your cluster, even more steps would be needed to join your worker nodes to the cluster.</p>
			<p>This process is called <em class="italic">K8s the hard way</em>, and it's called that for a reason, as this process can be very complicated <a id="_idIndexMarker055"/>and can change over time. And in the early days of K8s, this was the <a id="_idIndexMarker056"/>only way to create K8s clusters. Because of this, users needed to make large scripts or <strong class="bold">Ansible Playbooks</strong> to create their K8s clusters. These scripts would need lots of care and feeding to get up and running, with even more work required to keep them working as K8s continually changed. </p>
			<p>Rancher saw this issue and knew that for K8s to become mainstream, it needed to be <em class="italic">crazy easy</em> to build clusters for both end users and the Rancher server. Initially, in the Rancher v1.6 days, Rancher would build K8s clusters on its container clustering software called <strong class="bold">Cattle</strong>. Because of this, everything <a id="_idIndexMarker057"/>needed had to run as a container, and this was the starting point of RKE.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>So, what is RKE? </h2>
			<p>RKE is Rancher's cluster orchestration <a id="_idIndexMarker058"/>tool for creating and managing <strong class="bold">Cloud Native Computing Foundation</strong> (<strong class="bold">CNCF</strong>)-certified K8s clusters on a wide range of operating <a id="_idIndexMarker059"/>systems with a range of configurations. The core concept of RKE is that everything that makes up the K8s cluster should run entirely within <strong class="bold">Docker</strong> containers. Because of this, RKE doesn't care what operating system it's deployed on, as long as it's within a Docker container. This is because RKE is not installing binaries on the host, configuring services, or anything similar to this.</p>
			<h3>How does RKE work? </h3>
			<p>RKE is a <strong class="bold">Golang</strong> application that runs on most <strong class="bold">Linux</strong>/<strong class="bold">Unix</strong>-based systems. When a user wants to <a id="_idIndexMarker060"/>create a K8s cluster using RKE, they must first define the <a id="_idIndexMarker061"/>cluster using a file called <strong class="source-inline">cluster.yml</strong> (see <em class="italic">Figure 2.1</em>). RKE then uses that configuration file to create all of the containers needed to start the cluster, that is, etcd, kube-apiserver, kube-controller-manager, kube-scheduler, and kubelet. Please see the <em class="italic">How does Rancher provision nodes and clusters?</em> section in this chapter for further details on nodes and clusters.</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B18053_02_01.jpg" alt="Figure 2.1 – A code snippet from the cluster.yaml file"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – A code snippet from the cluster.yaml file</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>What is RKE2? </h2>
			<p>RKE2 is Rancher's next-generation K8s solution and is also known as RKE Government. RKE2 was designed to update <a id="_idIndexMarker062"/>and address some of the shortfalls of RKE, and it also brought the <em class="italic">crazy easy</em> setup methods from K3s to improve its functionality. RKE2 is also a fully CNCF-certified K8s distribution. But RKE2 was created specifically for Rancher's US federal government and their customers, as they have several special requirements for their K8s use – the first being that it is highly secure by default. </p>
			<p>When setting up RKE, you must follow a hardening guide and take several manual steps to comply with <strong class="bold">CIS benchmarks</strong>. RKE2, on the other hand, is designed to be secure with little to <a id="_idIndexMarker063"/>no action required by the cluster administrator. US federal customers need their K8s clusters to be <strong class="bold">FIPS-enabled</strong> (<strong class="bold">FIPS</strong> stands for the United States <strong class="bold">Federal Information Processing Standards</strong>). Also, because RKE2 is built on K3s, it <a id="_idIndexMarker064"/>inherits a number of its features – the first being the support of <strong class="bold">ARM64</strong>-based systems. So, you could set up RKE2 on <a id="_idIndexMarker065"/>a <strong class="bold">Raspberry Pi</strong> if you chose to. This provides users with the flexibility to mix and <a id="_idIndexMarker066"/>match ARM64 and <strong class="bold">AMD64</strong> nodes in the same cluster and that means <a id="_idIndexMarker067"/>customers can run workloads such as multiple arch builds using the <strong class="bold">Drone Continuous Integration (CI)</strong> platform inside their cluster. This also <a id="_idIndexMarker068"/>provides support for low-power and cost-effective ARM64 nodes.</p>
			<p>The second feature inherited from K3s is <strong class="bold">self-bootstrapping</strong>. In RKE, you would need to define the <a id="_idIndexMarker069"/>cluster as YAML and then use the RKE binary to try to create and manage the cluster. But with RKE2, once the first node has been created, all of the other nodes simply join the cluster using a registration endpoint running on the master nodes. Note that this does require an external load balancer or a round-robin DNS record to be successful. Because RKE2 can manage itself, it allows you to do very cool tasks, such as defining a K8s upgrade with kubectl and just letting the cluster take care of it for you.</p>
			<p>The third feature that RKE2 inherited from K3s was built-in <strong class="bold">Helm</strong> support. This is because RKE2 was built with Rancher's <strong class="bold">fleet</strong> feature in mind, where all of the cluster services (such as cert-manager, <strong class="bold">Open Policy Agent</strong> (<strong class="bold">OPA</strong>) <strong class="bold">Gatekeeper</strong>, and more) should be deployed <a id="_idIndexMarker070"/>in an automated process using Helm. But the most significant change from RKE in RKE2 was the move from Docker to <strong class="bold">containerd</strong>. With RKE, you must have Docker installed on all nodes before RKE can manage them. This is <a id="_idIndexMarker071"/>because the core K8s components like etcd and kube-apiserver are static containers that are deployed outside the K8s cluster. RKE2 leverages what are known as <strong class="bold">static pods</strong>. These are unique pods that <a id="_idIndexMarker072"/>are managed directly by kubelet and not by kube-controller-manager or kube-scheduler. Because these pods don't require the K8s cluster to be up and running in order to start, the core K8s components such as etcd and kube-apiserver can just be pods – just like any other application in <a id="_idIndexMarker073"/>the cluster. This means that if you run <strong class="source-inline">kubectl -n kube-system get pods</strong>, you can see your etcd containers, and you can even open a shell to them or capture logs, just like you would with any other pod.</p>
			<p>Last but not the least, the most crucial feature of RKE2 is that it's fully open source with no paywall – just like every other Rancher product.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>What is K3s (five less than K8s)?</h1>
			<p>K3s is a fully CNCF-certified K8s distribution. This means that in K3s, the YAML you would deploy is just a <a id="_idIndexMarker074"/>standard K8s cluster deployed in a K3s cluster. K3s was created because traditional K8s clusters – or even RKE clusters – were designed to run at scale, meaning that they would require three etcd nodes, two control plane nodes, and three or more worker nodes for a standard configuration. In this case, the minimum size for nodes would be around four cores, with 8 gigabits of RAM for the etcd objects and control plane nodes, with the worker nodes having two cores and 4 gigabits of RAM. These would just be the background requirements when talking about K8s clusters at the scale of an IE 50 node cluster, with the worker nodes having 64 cores and 512 GB of RAM. But when you start looking at deploying K8s at the edge, where physical space, power, and compute resources are all at a premium, standard K8s and RKE are just too big. So, the question is: <em class="italic">how do we shrink K8s?</em> </p>
			<p>K3s was based on the following core principles: no legacy code, duplicate code, or extras. With RKE and other standard K8s distributions, each component exists as its separate code with its own runtime. At Rancher, they asked themselves a question: </p>
			<p><em class="italic">Hey, there is a lot of duplicate code running here. What if we just merged kube-apiserver, kube-controller-manager, kube-scheduler, and kubelet into a single binary?</em></p>
			<p>And that was how K3s was born. K3s only has <em class="italic">master</em> and <em class="italic">worker</em> nodes, with the master node running all of the <a id="_idIndexMarker075"/>core components. The next big breakthrough was what they did with etcd. The etcd object is not small. It eats memory like it's going out of style and doesn't play nice when it's in a cluster of one. This is where <strong class="bold">kind</strong> comes into the picture.</p>
			<p>The kind database adapter makes standard <strong class="bold">SQL</strong> databases such as <strong class="bold">SQLite3</strong>, <strong class="bold">MySQL</strong>, or <strong class="bold">Postgres</strong> look like <a id="_idIndexMarker076"/>an etcd database. So, as far as kube-apiserver knows, it's talking <a id="_idIndexMarker077"/>to an etcd cluster. The CPU <a id="_idIndexMarker078"/>and memory footprint is much smaller because you can run a database like SQLite3 in place of etcd. It is important to note that Rancher does not customize any of the standard K8s libraries in the core components. This allows K3s to stay up to date with upstream K8s. The next big area of saving in K3s was in-tree storage drivers and cloud providers. Upstream K8s has several storage drivers built into the core components. For example, RKE has storage drivers to allow K8s to connect to the <strong class="bold">AWS</strong> API and use <strong class="bold">Amazon</strong> <strong class="bold">EBS</strong> volumes to provide <a id="_idIndexMarker079"/>storage directly to pods. This is great if you are running in AWS, but if you are running in <strong class="bold">VMware</strong> then this code is just wasting resources. It's the <a id="_idIndexMarker080"/>same the other way round, with VMware's <strong class="bold">vSphere</strong> having a storage <a id="_idIndexMarker081"/>provider for mounting <strong class="bold">Virtual Machine Disks (VMDKs)</strong> to nodes. The idea was that most of these storage and cloud providers are not used. For example, if I'm <a id="_idIndexMarker082"/>running a cluster on Amazon, why do I need libraries and tools for Azure? Plus there are out-of-tree alternatives that can be deployed as pods instead of being baked in. Also, most of the major storage providers are moving to out-of-tree provisioning anyway. So, K3s removes them. This eliminates a significant overhead. Because of all these optimizations, K3s clusters can fit on a 40 MB binary file and run on a node with only 512 MB of RAM.</p>
			<p>The other significant change in K3s to K8s was the idea that it should be <em class="italic">crazy easy</em> to spin up a K3s cluster. For example, creating a single-node K3s cluster only requires the <strong class="source-inline">curl -sfL https://get.k3s.io | sh -</strong> command to run, with the only dependency being that it's within a Linux ARM64 or AMD64 operating system with <strong class="source-inline">curl</strong> installed. Because of this ease of use, K3s is frequently deployed in single-node clusters where a user wants to use all of the management tools that K8s provides but without the scale. For example, a developer might spin up a K3s cluster on their laptop using a <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>) to deploy their application just as they would in their production K8s cluster.</p>
			<p>Another great use case for K3s is deploying to a retail environment where you might have hundreds or even thousands of locations all over the country (or world) and have a single K3s node running <a id="_idIndexMarker083"/>on a small PC at each location. K3s helps in this situation because it is so tiny, so common problems such as slow internet connections are not that big of a problem, and also K3s can keep running even if it loses its connection back to a corporate data center. An even more extraordinary kind of deployment for K3s is a wind turbine in the middle of nowhere with only a <strong class="bold">Long-Term Evolution</strong> (<strong class="bold">LTE</strong>) connection <a id="_idIndexMarker084"/>for internet access. These are the kinds of deployments K3s was built for.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>What is RancherD?</h1>
			<p><strong class="bold">RancherD</strong> is a marriage between Rancher and K3s/RKE2. Initially, when you wanted to install Rancher, you would first be required to create a K8s cluster using RKE, and then you would be required to <a id="_idIndexMarker085"/>install Rancher by using Helm on the RKE cluster. RancherD takes a lot of the ideas from K3s and RKE2 but is built for Rancher specifically. In a similar vein to K3s and RKE2, RancherD is a single binary that can be easily installed using the <strong class="source-inline">curl -sfL https://get.rancher.io | sh –</strong> command on a Linux AMD64 or ARM64 server. This binary is similar to RKE2 but has been optimized to host the Rancher server. RancherD also includes extra tools to support the Rancher server application. For example, the <strong class="source-inline">rancherd reset-admin</strong> command will reset the administrator password for the Rancher server.</p>
			<p>To change this password with a normal RKE or RKE2 cluster, you would need to find the Rancher server pod and open a shell into the container. Then you would run the <strong class="source-inline">reset-admin</strong> command. The main idea behind RancherD is to make it very easy to manage Rancher. It does this by using the RKE2 Helm operator to handle deploying the Rancher server pods. And because it uses the same Helm chart that you would use in an RKE cluster, all of the customization options are still available (the best feature being the ease of management of SSL certificates). In a standard Rancher server deployment, you must configure and manage the SSL certificates that support the Rancher API. This can be a pain when using internally signed certificates, as you need to edit a secret inside the cluster, which can be difficult for new K8s users. RancherD solves this problem by simply having the user drop the certificate files into <strong class="source-inline">/etc/rancher/ssl/</strong> on one of the RancherD nodes, at which point it takes over the process and handles the update for you. Most of the time, you'll use RancherD when you don't want to manage the K8s cluster that hosts Rancher <a id="_idIndexMarker086"/>but can't use a hosted K8s option such as <strong class="bold">AWS</strong> <strong class="bold">EKS</strong>, <strong class="bold">Azure</strong> <strong class="bold">AKS</strong>, or <strong class="bold">Google</strong> <strong class="bold">GKE</strong>, or if you <a id="_idIndexMarker087"/>need to manage a large number of different Rancher <a id="_idIndexMarker088"/>installations. For example, if you were running a hosted environment <a id="_idIndexMarker089"/>where you were providing <em class="italic">Rancher as a service</em>, you might use RancherD to simplify the management of these clusters at scale.</p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>What controllers run inside the Rancher server pods?</h1>
			<p>Rancher is made of a set of pods – three pods by default – that run in a K8s cluster. These pods can service requests from the ingress controller – <strong class="bold">ingress-nginx</strong> by default – using Norman to <a id="_idIndexMarker090"/>translate the Rancher API requests into the K8s API requests to access the custom resource objects that Rancher uses. But the Rancher server pods also host several controllers, with the primary controllers as follows:</p>
			<ul>
				<li><strong class="bold">Rancher Authentication Controller</strong>: This controller is responsible for managing the <a id="_idIndexMarker091"/>users and permissions in Rancher and the downstream clusters that Rancher manages. This controller is required for Rancher to manage and synchronize <a id="_idIndexMarker092"/>a user's/group's permissions to the downstream K8s clusters. Rancher needs to provide this service because – by default – K8s doesn't have integrations with external authentication providers such as <strong class="bold">GitHub</strong> or <strong class="bold">Okta</strong>, as most of the current external authentication <a id="_idIndexMarker093"/>providers are <a id="_idIndexMarker094"/>built on top of <strong class="bold">webhooks,</strong> for example, <strong class="bold">Lightweight Directory Access Protocol (LDAP)</strong>. By default, kube-apiserver <a id="_idIndexMarker095"/>doesn't know or understand <a id="_idIndexMarker096"/>what LDAP is. If you want to use LDAP as your external authentication provider, you are required to stand up a Go webhook service to listen for <strong class="source-inline">TokenReview</strong> requests from K8s. This service then calls the LDAP server and validates the username and password. If it passes the validation, the service will respond with a <strong class="source-inline">200 OK</strong> response, with all other response codes representing a failed authentication. Because of this, the setup process can be very complex and unreliable. As a result, Rancher chose the approach of building its controller to validate the username and password with external authentication providers such as LDAP, AD, GitHub, Okta, and more. Once the user has been validated, Rancher will give <a id="_idIndexMarker097"/>the user a bearer token that they can use to authenticate directly to the K8s API. The controller does this by creating matching service accounts, roles, and role <a id="_idIndexMarker098"/>bindings on the downstream clusters ahead of time. The controller also provides some higher-level controls via the Rancher concept of <em class="italic">projects</em>. You can define a group of namespaces called a <em class="italic">project</em> and manage permissions at the project level <a id="_idIndexMarker099"/>instead of managing them only at the cluster or namespace level. </li>
				<li><strong class="bold">Rancher Catalog Controller</strong>: This controller is responsible for managing the catalogs inside Rancher. But what is a <em class="italic">catalog</em>? Rancher uses the concept of <em class="italic">catalogs</em> that <a id="_idIndexMarker100"/>are <a id="_idIndexMarker101"/>repositories for Helm charts. Rancher calls them <a id="_idIndexMarker102"/>catalogs because they give users a catalog of applications <a id="_idIndexMarker103"/>to deploy to their cluster. The default catalogs have several great applications including <strong class="bold">WordPress</strong>, <strong class="bold">MySQL</strong>, <strong class="bold">Rancher</strong> <strong class="bold">Longhorn</strong>, the <strong class="bold">Datadog</strong> <strong class="bold">Cluster Agent</strong>, and many more. All of these catalogs come <a id="_idIndexMarker104"/>together in Rancher under what is called the <strong class="bold">Apps and Marketplace</strong> feature, allowing users to deploy Helm-based applications <a id="_idIndexMarker105"/>to your cluster. You can also add your repository <a id="_idIndexMarker106"/>as a catalog, which is excellent for DevOps teams that want to provide their application teams with standardized toolsets. For example, if an application team wanted their own monitoring systems, they could modify and tune the system based on their preferences. You might create a <strong class="bold">Prometheus</strong> Helm chart with a basic configuration <a id="_idIndexMarker107"/>that the application team could simply click to deploy on their cluster.</li>
			</ul>
			<p>Another great example of the use of a Helm chart is for environments where there might be one primary application – for example, the core application for the business that other teams must write their applications to connect to and work with. You can create a Helm chart for the monolithic application that an application team can quickly spin up to <a id="_idIndexMarker108"/>do integration <a id="_idIndexMarker109"/>testing with and then spin down to save costs. In this case, all of this would be managed by the Rancher catalog controller, which handles caching the catalogs (for speed reasons) and for legacy applications, deploying the application, that is, running the <strong class="source-inline">helm install</strong> command inside the Rancher server pod. </p>
			<p>But with Rancher v2.6, this process has been moved over to Fleet to handle the deployment process, where Fleet will spin up a Helm operator pod on the downstream cluster and run the Helm commands. Note that this is excellent for speed, scalability, and flexibility, as Fleet gives you many options for customizing the Helm chart and is part of Rancher's DevOps at scale. Fleet is designed to manage up to a million clusters at once. It is important to note that the Rancher catalog controller only runs on the Rancher leader pod. If that is deleted or lost, the cache will need to be rebuilt, but this process usually only takes a few minutes. This controller also synchronizes the cache on a schedule (6 hours by default), but the syncing process can be forced to update, with this process running the <strong class="source-inline">helm repo update…</strong> command but as Go code instead.</p>
			<ul>
				<li><strong class="bold">Rancher Cluster Controller</strong>: This controller is responsible for managing any RKE cluster that Rancher has provisioned. This includes custom clusters and Rancher-deployed <a id="_idIndexMarker110"/>clusters with this controller <a id="_idIndexMarker111"/>being built on top of the Go code that makes up RKE. This controller manages your <strong class="source-inline">cluster.yaml</strong> and <strong class="source-inline">cluster.rkestate</strong> files for you and handles running <strong class="source-inline">rke up</strong> from inside the Rancher leader pod. Note that when troubleshooting the cluster if it is stuck when updating status issues, this is the controller we'll look at the most. Please see the <em class="italic">How does Rancher provision nodes and clusters?</em> section later in this chapter for more details on how this controller works.</li>
				<li><strong class="bold">Rancher Node Controller</strong>: This controller is responsible for managing the Rancher-provisioned <a id="_idIndexMarker112"/>nodes. This controller <a id="_idIndexMarker113"/>is only used for Rancher-provisioned clusters on virtualized platforms such as <strong class="bold">Amazon</strong> <strong class="bold">EC2</strong>, <strong class="bold">Google</strong> <strong class="bold">GCP</strong>, VMware vSphere, and so on. This controller is built on top of the Go code that <a id="_idIndexMarker114"/>makes up a Rancher machine, which in turn is built <a id="_idIndexMarker115"/>on top of <strong class="bold">Docker Machine</strong>. This controller's main function <a id="_idIndexMarker116"/>is to handle the creation and deletion of VMs in a node pool. Please see the <em class="italic">How does Rancher provision nodes and clusters?</em> section <a id="_idIndexMarker117"/>later in this chapter for more details about this process. Note, when troubleshooting <a id="_idIndexMarker118"/>node provisioning errors such as SSH timeout or configuration validation errors, this is the controller we'll look at the most.</li>
				<li><strong class="bold">Rancher Pipeline Controller</strong>: This controller manages Rancher's built-in <strong class="bold">CI</strong>/<strong class="bold">CD</strong> pipeline system, which is built on top of <strong class="bold">Jenkins</strong>. This controller is mostly used as a <a id="_idIndexMarker119"/>wrapper for handling the creation and deployment of Jenkins on the cluster along <a id="_idIndexMarker120"/>with handling the configuration of webhooks <a id="_idIndexMarker121"/>and code repositories such as GitHub, <strong class="bold">GitLab</strong>, and <strong class="bold">Bitbucket</strong>. The heavy <a id="_idIndexMarker122"/>lifting of running jobs is done by Jenkins, but the <a id="_idIndexMarker123"/>Rancher UI integrations allow users to manage and review their pipelines without going into the Jenkins UI. Rancher also provides Jenkins with access to the K8s cluster to deploy workloads. The controller handles querying the code repository and using the <strong class="source-inline">rancher-pipelines.yml</strong> file to configure the pipeline. <p class="callout-heading">Note</p><p class="callout">As of Rancher v2.5, Git-based deployment pipelines are now recommended to handle Rancher Continuous Delivery, powered by Fleet. As a result, this controller was removed in Rancher v2.6.</p></li>
				<li><strong class="bold">Rancher Monitoring Controller</strong>: This controller manages the integration between the <a id="_idIndexMarker124"/>monitoring <a id="_idIndexMarker125"/>systems in the Rancher UI and the rancher-monitoring application, which is built on top of <strong class="bold">Prometheus</strong>, <strong class="bold">Grafana</strong>, <strong class="bold">Alertmanager</strong>, <strong class="bold">Prometheus</strong> <strong class="bold">Operator</strong>, and <strong class="bold">Prometheus</strong> <strong class="bold">Adapter</strong>. The rancher-monitoring application allows you to monitor the state of <a id="_idIndexMarker126"/>your cluster and its nodes, along with the K8s <a id="_idIndexMarker127"/>components (etcd, kube-apiserver, and so on) and your application <a id="_idIndexMarker128"/>deployments. Because of this, you can create alerts based on <a id="_idIndexMarker129"/>metrics collected by Prometheus, which can be <a id="_idIndexMarker130"/>sent to alert services such as <strong class="bold">Slack</strong>, <strong class="bold">PagerDuty</strong>, email, and <a id="_idIndexMarker131"/>more. Also, because the rancher-monitoring application <a id="_idIndexMarker132"/>deploys the custom metrics API adapter from <a id="_idIndexMarker133"/>Prometheus, you can use custom metrics such as application response times <a id="_idIndexMarker134"/>or work queue depths for your <strong class="bold">Horizontal Pod Autoscaler (HPA</strong>) to scale up and down your applications using metrics outside of CPU and memory <a id="_idIndexMarker135"/>usage. This controller primarily handles syncing the settings and configurations between Rancher and the rancher-monitoring application. Note that in Rancher v2.5 and the rancher-monitoring application v2 this process is changing to use a <strong class="source-inline">vanilla</strong> upstream Prometheus monitoring stack deployment instead of a Rancher customized Prometheus deployment.</li>
				<li><strong class="bold">Rancher Logging Controller</strong>: This controller manages the integration between the logging <a id="_idIndexMarker136"/>systems in the Rancher UI and the <strong class="bold">Banzai Cloud</strong> <strong class="bold">Logging</strong> operator. This <a id="_idIndexMarker137"/>controller is a translation layer that allows <a id="_idIndexMarker138"/>users to define logging Flows and ClusterFlows via the Rancher UI, which get translated into <strong class="bold">Custom Resource Definition</strong> (<strong class="bold">CRD</strong>) objects that the Banzai Cloud Logging operator uses for configuring both <a id="_idIndexMarker139"/>applications and cluster-level <a id="_idIndexMarker140"/>logging. Before <a id="_idIndexMarker141"/>Rancher v2.5, Rancher used several <a id="_idIndexMarker142"/>different logging <a id="_idIndexMarker143"/>providers, including <strong class="bold">Syslog</strong>, <strong class="bold">Splunk</strong>, <strong class="bold">Apache</strong> <strong class="bold">Kafka</strong>, and <strong class="bold">Fluentd</strong>. However, this was a custom Rancher solution <a id="_idIndexMarker144"/>and wasn't very flexible. So, as part of the logging v2 migration, everything was moved <a id="_idIndexMarker145"/>over to Banzai to be better aligned with where the industry is heading to.</li>
				<li><strong class="bold">Rancher Istio Controller</strong>: This controller manages the integration between the Rancher UI and the <strong class="bold">Istio</strong> deployment on the downstream cluster. This is needed because Istio has <a id="_idIndexMarker146"/>migrated away from using Helm for installation to using the <strong class="source-inline">istioctl</strong> binary <a id="_idIndexMarker147"/>or the Istio operator. This controller also handles deploying <strong class="bold">Kiali</strong> for graphing traffic flows throughout the service mesh. This <a id="_idIndexMarker148"/>allows users to see what applications connect to other applications, including the traffic rates and latencies between pods. This can be extremely valuable for application owners and teams.</li>
				<li><strong class="bold">Rancher CIS Scan Controller</strong>: This controller handles installing and configuring the <strong class="bold">rancher-cis-benchmark</strong> tool that is built on top of kube-bench, an open source <a id="_idIndexMarker149"/>tool from <strong class="bold">Aqua Security</strong>. This tool is used to check that your K8s cluster is compliant <a id="_idIndexMarker150"/>with the CIS standards. It does this by <a id="_idIndexMarker151"/>using the <strong class="bold">Sonobuoy</strong> plugin to collect the <a id="_idIndexMarker152"/>configuration settings of the different K8s components, for example, if you have the <strong class="source-inline">--insecure-bind-address</strong> flag set to something besides <strong class="source-inline">localhost</strong> on kube-apiserver. Note that this setting allows requests to bypass the authentication and authorization modules, and they must not be exposed outside the node. In this case, Sonobuoy would collect this setting and then kube-bench would flag that value as a failed check. Finally, the <strong class="bold">rancher-cis-benchmark</strong> tool would collect all of the checks together in an excellent report that can be sent off by email to the security team.</li>
			</ul>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>What do the Cattle agents do?</h1>
			<p>The Cattle agents that Rancher deploys on downstream clusters (that is, clusters that Rancher is managing) provide Rancher <a id="_idIndexMarker153"/>with access to the cluster and its nodes. This is done using two different sets of pods:</p>
			<ul>
				<li><strong class="bold">Cattle-cluster-agent</strong>: This runs as a deployment with a scale of one on your workers. When this pod starts up, it creates a <strong class="bold">WebSocket</strong> connection to the Rancher API. Once that connection is made, the Cattle-cluster-agent will create a TCP tunneled <a id="_idIndexMarker154"/>connection over the WebSocket connection back <a id="_idIndexMarker155"/>to the Rancher leader pod. Inside that pod, it will bind to a random port on <strong class="source-inline">localhost</strong>. This tunnel will then allow connections for the Rancher server pod to the downstream cluster. Because of this, Rancher does not need firewall rules to open from the Rancher servers to the downstream cluster, including the need to port-forward, which can be a security issue. This WebSocket connection is held open by Rancher and the Cattle-cluster-agent, as if this connection drops, Rancher will lose access to the cluster until the connection can be restored.</li>
				<li><strong class="bold">Cattle-node-agent</strong>: This runs as a <strong class="bold">DaemonSet</strong> on all nodes with a toleration that ignores just about everything. This pod uses the same kind of WebSocket connection as the <a id="_idIndexMarker156"/>previous example, with a TCP tunnel back to Rancher. Still, RKE uses <a id="_idIndexMarker157"/>this connection inside the Rancher server pod to provide a socket connection to the Docker Engine running on the node. This is needed for RKE to spin up the non-K8s containers that make up an RKE cluster. <p class="callout-heading">Note</p><p class="callout">Cattle-node-agent is only used in clusters where Rancher manages the cluster, that is, when Rancher built the cluster using RKE. For imported clusters, such as an Amazon EKS cluster, the Cattle-node-agent is not needed.</p></li>
			</ul>
			<p>Both agents use HTTPS to connect to the Rancher API. They do this by passing some environment variables <a id="_idIndexMarker158"/>into the pods. The first variable is <strong class="source-inline">CATTLE_SERVER</strong>; this variable is the hostname of the Rancher API. An example hostname is <strong class="source-inline">rancher.example.com</strong>. Note that there is no HTTP or HTTPS in this variable, as it is a requirement for the agents to connect to Rancher over an HTTPS connection. The second variable is <strong class="source-inline">CATTLE_CA_CHECKSUM</strong>, a <strong class="bold">SHA-256</strong> checksum of the certificate chain for the Rancher API. If you use a self-signed or internally signed certificate as a default, the <a id="_idIndexMarker159"/>pod will not trust that certificate, as the image will not have that root CA certificate stored inside it. The agents work around this issue by decoding the certificate chain from the Rancher API and hashing it using SHA-256. Then, by comparing the hash to the <strong class="source-inline">CATTLE_CA_CHECKSUM</strong> variable, so long as they match, the agents will trust that HTTPS connection. It's important to note that if you renew the certificate in place, that is, without changing the chain, the <strong class="source-inline">CATTLE_CA_CHECKSUM</strong> variable will not change if you change certificates to a different authority – for example, if you are switching from a self-signed certificate to a publicly signed certificate from a company such as <strong class="bold">DigiCert</strong>, <strong class="bold">GoDaddy</strong>, and so on. This will cause the <strong class="source-inline">CATTLE_CA_CHECKSUM</strong> variable to have longer matches, thereby requiring manual work to update the agents. This process is documented at <a href="https://github.com/rancherlabs/support-tools/tree/master/cluster-agent-tool">https://github.com/rancherlabs/support-tools/tree/master/cluster-agent-tool</a>.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>How does Rancher provision nodes and clusters?</h1>
			<p>Rancher can provision a number of different nodes and clusters using the following methods. There are <a id="_idIndexMarker160"/>three main types of clusters in Rancher. <em class="italic">Rancher-created clusters using RKE</em>, <em class="italic">Rancher-created clusters using a hosted provider</em>, and <em class="italic">imported clusters</em>. Each of <a id="_idIndexMarker161"/>these types has subtypes, which we will describe in detail here.</p>
			<p>The Rancher-created clusters using RKE are as follows:</p>
			<ul>
				<li><strong class="bold">Rancher-created nodes</strong>: One of the great things about Rancher is that if you choose Rancher, it can build <a id="_idIndexMarker162"/>the cluster for you, and they can manage the VMs themselves. This is done by using a tool called <strong class="bold">Rancher-machine</strong>. This tool is based <a id="_idIndexMarker163"/>on Docker Machine, which lets you create VMs and install Docker. Docker Machine does this by using driver plugins. These driver plugins act as a translation layer between Docker Machine and the virtualization <a id="_idIndexMarker164"/>provider – for <a id="_idIndexMarker165"/>example, <strong class="bold">Amazon AWS</strong>, <strong class="bold">Linode</strong>, <strong class="bold">OVHcloud</strong>, or VMware <a id="_idIndexMarker166"/>vSphere. </li>
			</ul>
			<p>How Docker Machine works is that you give it credentials to your virtualization provider and define <a id="_idIndexMarker167"/>the specifications on the VM, such as how many cores, how much RAM, and so on. Then, the driver plugin takes over to call the cloud provider's API endpoint to provision the VM. Docker Machine then creates an SSH key pair for each VM and then uses the driver plugin to push the SSH key to the VM. It then waits for the SSH connection to become available.</p>
			<p>Once the SSH connection has been created, Docker Machine then installs Docker. This is where Rancher-machine comes into the picture. Rancher-machine builds on top of Docker Machine by adding additional driver plugins such as <strong class="bold">DigitalOcean</strong> and <strong class="bold">Rackspace</strong>. It then provides additional features such as implementing <a id="_idIndexMarker168"/>cloud-init. You can run other steps during the node <a id="_idIndexMarker169"/>provisioning process such as creating a filesystem for Docker or applying customizations to Docker Engine. Rancher provides higher-level functions such as defining node templates to deploy nodes in a repeatable process that is expanded even more by defining node pools (a group of nodes using node templates). Node pools allow Rancher to add and remove nodes from the group at will. For example, if a node crashes in the pool and doesn't recover during the default 15-minute timeout (customized), Rancher can create a new replacement VM and destroy the crashed node. This process can also be used to perform a rolling replacement of nodes for use cases where you don't want to <em class="italic">patch in place</em> but want to update your base image and recreate all of your nodes in a rolling fashion.</p>
			<ul>
				<li><strong class="bold">Bring your own nodes</strong>: These nodes are for use cases where you would like or need to create the VMs yourself or use physical servers. In this case, you will define your <a id="_idIndexMarker170"/>cluster configuration in Rancher. Then, Rancher will create a command for you to run that looks like the following:<p class="source-code">docker run -d --privileged --restart=unless-stopped --net=host -v /etc/kubernetes:/etc/kubernetes -v /var/run:/var/run  rancher/rancher-agent:v2.6.0 --server https://rancher-lab.support.tools --token abcdefghijkmn123456789 --etcd --controlplane --worker.</p></li>
			</ul>
			<p>Let's break down this command. First, this is a Docker command that can run on any Linux host that has Docker installed. The next part is <strong class="source-inline">run</strong>, which says to create a new container, with the next flag being <strong class="source-inline">-d</strong>, which says to run in <em class="italic">detached</em> mode. This will start the container and put it in the background. The <strong class="source-inline">–privileged</strong> flag then tells Docker that it will be a privileged container – meaning that this container can access all of the devices on the host. Think of it like running the process directly on the host operating system with little to no limits. The <strong class="source-inline">--restart=unless-stopped</strong> flag just tells Docker to keep restarting this container until we tell it to stop. Next is the <strong class="source-inline">--net=host</strong> flag, which gives the container the same network as the host. Therefore, the container's IP will be the host's IP. The next two flags pass the <strong class="source-inline">/etc/kubernetes</strong> and <strong class="source-inline">//var/run</strong> directories inside the container. The <strong class="source-inline">/etc/kubernetes</strong> directory is used to <a id="_idIndexMarker171"/>store node-level configuration files and, most importantly, the SSL certificates used for the K8s components.</p>
			<p>The following section is the container image and tag. This image will match the Rancher version, and this image includes all of the binaries that will be needed to bootstrap this node. The <strong class="source-inline">--server</strong> flag is the Rancher API server path. This will be passed into the container, creating and tunneling back to the Rancher leader pod (please see the <em class="italic">What do the Cattle agents do?</em> section earlier in this chapter for more details). Next, we have the <strong class="source-inline">–token</strong> flag. This is used to authenticate the agent to the Rancher server and tie this agent to a cluster. Each cluster will have a unique token, but all of the agents in a cluster will share the same token. Finally, we have the <strong class="source-inline">role</strong> flags. These flags are used to assign the different roles of the RKE cluster to the node. Note that nodes can have more than one role, but a cluster requires at least one node for each role: one etcd node, one control plane, and one worker node. You can mix and match roles as you choose, but there are best practices for this that should be followed.</p>
			<p>In both Rancher-created nodes and <em class="italic">bring your own nodes</em>, once the bootstrap agent has been successfully started on the node, the agent will tunnel back to the Rancher leader pod and register the new node in Rancher RKE. It then uses the registered nodes to dynamically create the <strong class="source-inline">cluster.yaml</strong> file using the registered or registering nodes to the cluster. If this cluster has already been successfully started once before, Rancher will also pull <strong class="source-inline">cluster.rkestate</strong> from the CRD <strong class="source-inline">clusters.management.cattle.io</strong> object. This file includes the current state of the cluster, the root and server certificates, and the authentication tokens that RKE will use to communicate to the cluster. Then, the cluster controller will use the port binding on the Rancher leader <a id="_idIndexMarker172"/>pod to connect the Docker engines on the nodes. At this <a id="_idIndexMarker173"/>point, RKE will create the certificates and configuration files, deploy them to the nodes, and start creating/updating the etcd cluster. RKE performs this process in a serial fashion, working on only one node at a time, and if RKE runs into any issues, it will throw an error and exit the function. Also, an etcd backup is taken on each etcd node for existing clusters before making any changes. Once the etcd plane has been successfully started, RKE will begin working on the control plane, where RKE will start up the kube-apiserver objects, kube-controller-manager, and kube-scheduler, working again in a serial fashion by running one node at a time and running health checks as it goes. And again, if any step in this process fails, RKE will fail too. Finally, RKE will come to the worker plane. This process is different, because it is designed to create a parallel to doing multiple worker nodes at once, and it will continue even if a failure happens, so long as the settings defined in the <strong class="source-inline">zero downtime</strong> configuration have not been violated. The default settings are only one etcd or control plane node down at any given time, with up to 10% of the worker nodes down. Note, this number is rounded down to the nearest node, with a minimum of one node per batch:</p>
			<ul>
				<li><strong class="bold">Rancher-created clusters using a hosted provider</strong>: One of the nice things about Rancher <a id="_idIndexMarker174"/>is you can use a hosted K8s cluster such as AWS EKS, Google GKE, or Azure AKS if you don't want to deal with VMs and just want to let your cloud provider manage the VMs for you. Rancher <a id="_idIndexMarker175"/>can help by using the cloud provider's <strong class="bold">software development kit</strong> (<strong class="bold">SDK</strong>) to provide the cluster for you. This is mainly for reasons of convenience and consistency, as there are no unique or hidden options that Rancher has that you can't do yourself. As part of its new hosted cluster option in v2, Rancher also allows <a id="_idIndexMarker176"/>for the three-way synchronization of configurations between Rancher, the cloud provider, and the end user. What is remarkable is that if you want to change some settings for your AWS EKS cluster, you can manage it directly in the AWS console and your changes will be reflected in Rancher. Note that this can be done for RKE clusters too but requires a few extra steps.</li>
				<li><strong class="bold">Imported K8s clusters</strong>: Finally, if you don't want Rancher to manage your clusters whatsoever, but you <a id="_idIndexMarker177"/>do want Rancher to be a friendly web UI for your cluster, you can utilize the excellent <em class="italic">convenience features</em> of Rancher such as <strong class="bold">Active Directory</strong> (<strong class="bold">AD</strong>) authentication, web kube-proxy access, and more. You can import the cluster where Rancher will deploy the cluster-Cattle-agent <a id="_idIndexMarker178"/>on the cluster but will not have access to items such as etcd, kubelet, the Docker CLI, and more. In this instance, Rancher will only be able to access the kube-apiserver endpoint. Note that Rancher supports any certificated K8s distribution for the imported cluster option, and this can include <em class="italic">K8s the hard way</em>, EKS, a self-managed RKE cluster, or even a K3s/RKE2 cluster. As of Rancher v2.6.0, K3s and RKE2 clusters are unique in that they can be imported into Rancher and Rancher can then take over management of the cluster moving forward. Please note that this is still a new process and has its limitations and bugs.</li>
			</ul>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>What are kube-apiserver, kube-controller-manager, kube-scheduler, etcd, and kubelet?</h1>
			<p>The etcd object is a distributed and consistent key-value pair database. <strong class="bold">CoreOS</strong> initially developed <a id="_idIndexMarker179"/>etcd to handle OS <a id="_idIndexMarker180"/>upgrades in cluster management systems and store configuration files in 2013. Because of this, etcd needed to be highly available and consistent. The etcd object is currently affiliated with the CNCF and has been widely adopted in the industry. An etcd cluster is based on the idea of maintaining consistency <a id="_idIndexMarker181"/>across nodes – most clusters contain three or five nodes, and there is a requirement that there be an odd number of nodes. This is due to the requirements of the Raft consensus algorithm. This algorithm selects a master node, which etcd calls the <em class="italic">leader</em>. This node is responsible for synchronizing data between nodes. If the leader node fails, another election will happen, and another node will take over this role. The idea here is that etcd is built on the concept of a <em class="italic">quorum</em>. This means that more than half of the nodes in the cluster must be in consensus. In a standard three-node cluster, the etcd cluster will continue to accept writes if a single node fails, but if two nodes fail, the surviving etcd node will take the safest option and go into read-only mode until a quorum can be restored in the cluster. A five-node cluster is the same, but it requires three of the five nodes to fail to lose service. All write processes go to the etcd leader node, which are written to the Raft log and then broadcast to all cluster nodes during operations. Once the majority of the nodes have successfully acknowledged the write (that is, two nodes in a three-node cluster and threes nodes in a five-node cluster), the Raft log entry is committed, and the write is acknowledged back to the client. If a majority of the nodes do not acknowledge the write, then the write will fail and will not be committed. Because of Raft, adding more nodes to the cluster will increase the fault tolerance, but this also increases the load on the leader node without improving performance.</p>
			<p>For now, etcd stores the data because etcd is built on top of <strong class="bold">BoltDB</strong>, which writes its data into a single <a id="_idIndexMarker182"/>memory-mapped file. This means the operating system is responsible for handling the data caching and will keep as much data in memory as possible – this is why <a id="_idIndexMarker183"/>etcd can be a <em class="italic">memory hog</em> and requires a high-speed disk, preferably an <strong class="bold">SSD</strong> or <strong class="bold">NVME</strong>. Then for the data, etcd uses <strong class="bold">multiversion concurrency control</strong> (<strong class="bold">MVCC</strong>) to handle concurrent write operations safely. The MVCC works in <a id="_idIndexMarker184"/>conjunction with Raft, where every write is tracked by a revision. By keeping <a id="_idIndexMarker185"/>a history of the revisions, etcd can provide the version history of all of the keys. This impacts read performance because key-value pairs are written to disk in the order created in the transaction log, not by an index (as in a traditional database). This means that key-value pairs written simultaneously are faster to read than key-value pairs written at different times. However, with etcd keeping revisions over time, the disk and memory usage can grow very large. Even if you delete a large number of keys from etcd, the space will continue to grow since the prior history of those keys will still be retained. This is where etcd compaction and defragmenting come into the picture wherein etcd will drop superseded revisions, that is, older data that has been <em class="italic">overwritten,</em> where the memory-mapped file will have several holes so etcd will then run a defrag to release free pages back to the operating system. However, it is essential to note that all incoming reads and writes will be blocked during a defragmentation.</p>
			<p>kube-apiserver is a critical component in a K8s cluster, as it is the server that provides the REST API endpoint for the whole cluster. kube-apiserver is the only K8s component that <a id="_idIndexMarker186"/>connects to the etcd cluster and acts as an access point for all of the other K8s components. Now, kube-apiserver is intended to be relatively simple, with most of the business logic being done by other controllers and plugins. But one of its primary responsibilities is authentication and <strong class="bold">RBAC</strong> (<strong class="bold">role-based access control</strong>). The default access control behavior is that all clients should be authenticated <a id="_idIndexMarker187"/>to interact with kube-apiserver.</p>
			<p>The other central role that kube-apiserver serves is managing secret encryption. By default, K8s stores secrets in plain text inside the etcd database. This can be a security issue, as secrets store items like passwords, database connection strings, and so on. To protect secrets, kube-apiserver supports an encryption provider. What happens is, any time a secret is created or updated, kube-apiserver will call the encryption provider to access the encryptions algorithm and keys to encrypt the data, then send this data to the etcd cluster. Then whenever a secret is read from the etcd cluster, kube-apiserver uses the reverse process to decrypt the data before sending the response back to the client. Because of this, the clients are unaware that secrets are encrypted, with the only impact being performance. The standard for Rancher is to use <strong class="source-inline">aescbc</strong> for its encryption algorithm, as this provides a good balance between performance and strength, and also has the added benefit that most modern CPUs support AES with CBC mode in hardware. As a result, encryption and decryption performance are usually not an issue.</p>
			<p>Another one of the critical things to remember about kube-apiserver is that it's stateless; besides some in-memory caching, kube-apiserver stores no data. This means kube-apiserver is great for horizontal scaling. It also has no leader election process as there is no leader node. So, typically, clusters will have at least two nodes running kube-apiserver, but you can have more with larger clusters. You also don't have the limitation of old numbers of nodes in the way you do with etcd. The kube-apiserver is also where a lot of core cluster configuring happens. For example, when using a cloud provider such as AWS or VMware vSphere, you need to create a configure file and pass that file path into the kube-apiserver component as a command-line flag. Note, kube-apiserver does not support hot changing settings and requires a restart to alter its configurations.</p>
			<p>The K8s controller manager, kube-controller-manager, is the core controller for K8s and is typically called the <em class="italic">controller for controllers</em>, as its main job is to sit in a non-terminating loop that <a id="_idIndexMarker188"/>regulates the state of the cluster. It connects to the kube-apiserver component and creates several watch handles that monitor the current state of the cluster and compare it to the desired state. The kube-controller-manager component does this by having several smaller controllers.</p>
			<p>The first of these smaller controllers is the <em class="italic">replication controller</em>. This controller ensures that the <a id="_idIndexMarker189"/>specified number of pods in a <strong class="bold">ReplicaSet</strong> are running at any <a id="_idIndexMarker190"/>given time. An example of this is if a ReplicaSet has five pods in the desired state, but it only has hour pods in the current state. The replication controller will create a new pod object in the unscheduled state, thereby bringing the ReplicaSet back up to the required five pods. Another example is when a node fails – here, the replication controller will see that the pod has been disabled, deleted, or terminated, and it will create a new pod object again. The replication controller also handles terminating pods when the current state is greater than the desired state. There is some business logic built inside the termination process. Here, the main rule is that pods that are currently not in the ready status, that is, they are pending or failed, are the first pods to be set for terminations, with the oldest pods being the next in line. Note that the replication controller does not delete pods or call nodes directly, or even connect to other controllers. All communication happens between the controller and kube-apiserver.</p>
			<p>The second controller is the <em class="italic">endpoints controller</em>, which is responsible for maintaining the endpoints that join <a id="_idIndexMarker191"/>services and their assigned pods, with endpoint and service records being part of the cluster DNS system. K8s needs to track pods being created and deleted in the cluster to update those records with the correct IP addresses.</p>
			<p>The third controller is the <em class="italic">service account and token controller</em>. This controller is responsible for creating <a id="_idIndexMarker192"/>and managing service accounts in the cluster and creating tokens for the service accounts to use to authenticate the kube-apiserver component. Note that the tokens are stored as secrets in the namespace where the service accounts are hosted.</p>
			<p>The fourth controller is the <em class="italic">node controller</em>. This controller is responsible for watching the status of the nodes in the cluster by watching the node leases that kubelet is periodically <a id="_idIndexMarker193"/>updating by sending a heartbeat. Suppose a node lease violates the node timeout that is five minutes by default. The node controller will decide that this node must be down and start the pod eviction process wherein the controller updates the pods running on that node with the status of <strong class="source-inline">Unknown</strong> and will taint the node object with the taint of <strong class="source-inline">unschedulable</strong>. This will trigger the replication controller to begin deleting pods that cannot tolerate that taint. It is essential to remember the following things about this process. First, K8s has no way of knowing if a node is genuinely down or if it's just having issues communicating with the kube-apiserver, which means if a kubelet on the node crashes or locks up, then the pods running on the node will continue to run without issue, even though the node controller has flagged them and the replication controller has deleted them. And also, because K8s has no way for the cluster to block I/O to the failed node, you could run into a split-brain issue with the same pod/application running in two locations simultaneously. You also must remember that pods that have tolerations for the <strong class="source-inline">unschedulable</strong> taint will not be rescheduled.</p>
			<p>An example of this is a canal pod that has a toleration for any taint placed on a node, meaning this pod will be scheduled on a node no matter what. The next thing to remember is that the eviction process does have rate limiting, which, by default, will evict pods at a rate of ten pods per second. This is to prevent a flood of pods from being rescheduled in the cluster. Finally, only a single kube-controller-manager is allowed to be active at any one time. It does this by using a leader election process. All kube-controller-manager processes try to grab a lease in kube-apiserver. One process becomes the leader, allowing the other controllers to start taking action in the cluster. The leader will continue to refresh this lease while the other nodes continue monitoring the lease, comparing the last renewal timestamp to the expiration timestamp. If the lease is ever allowed to expire, the standby kube-controller-manager will race to become the new leader. All this being said, scaling the kube-controller-manager horizontally only improves fault tolerance and will not improve performance.</p>
			<p>kube-scheduler is the controller that handles assigning pods to nodes. It does this by watching for unscheduled pods, at which point kube-scheduler is evaluating nodes. kube-scheduler <a id="_idIndexMarker194"/>first builds a list of nodes that meets all of the requirements. For example, if a pod requires a node selector rule, only nodes with that label will be added to the node candidate list. Next, kube-scheduler will evaluate the taints and tolerations of the nodes and pods. For example, by default, a pod will not tolerate the node with taint scheduling disabled. This taint is typically applied to master, etcd, or control-plane nodes. In this case, the node wouldn't be added to the node candidate list. Next, kube-scheduler will create what it calls a node <em class="italic">score</em>. This score is based on the availability of the resources, such as CPU, memory, disk, network, and more, that are available on the node. For example, a node that is underutilized, that is, with a lot of CPU and memory available will score higher than a node that is highly utilized, that is, with little to no CPU or memory available. Once all of the scores are calculated, kube-scheduler will sort them from the highest to lowest. If there is only one node with the highest score, then that node wins. If there is a tie, kube-scheduler will randomly pick a winner from the nodes that tied. Finally, kube-scheduler will update the pod object in kube-apiserver with its node assignment. An important thing to remember is kube-scheduler can be tuned and even replaced with other third-party schedulers. This is mainly done for environments with burst workloads where many pods will be created at once. This is because kube-scheduler doesn't know about resource utilization and its pods over time. It only gets whatever the current value is at scheduling. So, what can happen is one node will get flooded with new pods and fall over. Those pods are then rescheduled on a new node, which in turn knocks that node over as well. But during that event, the first node is recovered, and so now all of the new pods will go to that node because it is empty, and the process repeats repeatedly. There is also an essential idea to understand here, kube-scheduler only touches a pod at the time of creation. Once the pod has been scheduled to a node, that's it. The kube-scheduler component does not rebalance or move pods around. There are also tools like kube-descheduler that can fill in this gap and help you balance your cluster.</p>
			<p>In simple terms, kubelet is the node agent in K8s. kubelet runs on every worker node, and in the <a id="_idIndexMarker195"/>case of RKE, all nodes. kubelet has several different roles and responsibilities. The first is taking the pod specifications in kube-apiserver that have the node assignments of the node where kubelet is running. kubelet then compares that pod specification to the current state of the node. kubelet does this by connecting to Docker or containerd to gather what containers are currently running on the node. Then, if there is a difference, kubelet will create or destroy the containers for them to match. The kubelet component's second responsibility is <em class="italic">pod health</em>.</p>
			<p>Pods can have <em class="italic">probes</em> defined as a part of their specifications. These include <em class="italic">liveness probes</em>, which are responsible <a id="_idIndexMarker196"/>for checking whether the application inside a pod is healthy. These checks <a id="_idIndexMarker197"/>are simple <strong class="bold">Bash</strong> commands or HTTP requests that run inside kubelet. An example of these checks could be if you had an NGINX web server running inside a pod and you wanted to perform an <strong class="source-inline">HTTP GET</strong> request to <strong class="source-inline">/</strong> every 5 seconds to confirm that NGINX is up and responding to requests.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">kubelet</strong> component only accepts <strong class="source-inline">200 OK</strong> responses as evidence of a healthy request. All other response codes will return a failure. Another type of probe is called the <em class="italic">startup probe</em>. This probe is similar to the <a id="_idIndexMarker198"/>liveness probe but mainly tells <strong class="source-inline">kubelet</strong> that a pod has successfully started.</p>
			<p>An example might be a database inside a pod where the database could take a few minutes to fully start up. If you just used the liveness probes, you would need to space out your schedule to allow the database to start before kubelet killed the pod entirely. So, you'd want to use a <em class="italic">startup probe</em> with a delay of a minute or two, then, once that is successful, the liveness probe could take over and run every few seconds. Finally, the <em class="italic">readiness probe</em> is very similar to the startup probe, but it is used for controlling when K8s can start sending traffic <a id="_idIndexMarker199"/>to a pod. An example of this could be a web server that might start up and be healthy but can't connect to a backend database. In this case, you don't want kubelet to kill the pod, as it is fine, but you also don't want to start sending traffic to the pod until it can connect to the database.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>How do the current state and the desired state work?</h1>
			<p><strong class="bold">Desired state</strong> is one of the core concepts of Rancher and K8s. The idea is that you should declare the state of an object (for example, a pod, deployment, or volume) as you would like it to be. Then, the cluster should report the current state of the object, at which point it's <a id="_idIndexMarker200"/>the role of the controller (the kube-controller-manager <a id="_idIndexMarker201"/>component in the case of most of K8s core objects) to compare these two states. If no difference is found, don't do anything, but if a discrepancy is found, the controller's job is to create a <em class="italic">plan</em> for making the current state match the desired state.</p>
			<p>For example, if you had a deployment with a replica of three pods deployed in a cluster, the ReplicaSet controller will see that the replica count is set to three (desired state) with an image of <em class="italic">v2</em>. The controller will then call the kube-apiserver component and pull a copy of the current and desired state for that ReplicaSet at which point, the controller will start comparing settings. In this example, the current state will now have three healthy pods using the <em class="italic">v1</em> image tag, because pods can't be modified after being created. The controller <a id="_idIndexMarker202"/>will need to create new replacement pods and will need to destroy the old pods. It does this by creating a new pod object with the updated image tag. This <a id="_idIndexMarker203"/>pod object will have the status of <em class="italic">waiting to be scheduled</em>. At this point, kube-scheduler takes over to assign that pod to a node. Then, kubelet takes over to create the container(s), IP address, mount volumes, and so on that are needed for the pod. Then, once everything has been started and the probes are successful, kubelet will update the pod object to the state of <strong class="source-inline">Ready</strong>. This takes us back to the ReplicaSet controller, which will then detect that one of the number pods has successfully been started. If yes, pick the oldest pod that doesn't meet the spec and terminate that pod by setting the status to terminating. This will trigger kubelet to destroy the pod and its resources. Then, once everything is cleaned up, kube-controller-manager will remove the terminated pod object in kube-apiserver. This process then starts again and will repeat until all of the pods in the ReplicaSet match the desired state.</p>
			<p>The controllers are designed to always aim to have the current state matching the desired state. If the controllers run into an issue, such as the new pods keep crashing, the image can't be pulled, or a <strong class="source-inline">configmap</strong> object is missing, then after several failed attempts, the controller will keep trying, but it will put that object in a <strong class="bold">CrashLooping</strong> status. This tells the controller to stop fixing that state for a set amount of time (the default is 5 minutes). The <a id="_idIndexMarker204"/>controller does this to prevent spamming the cluster with requests for failing resources (for example, if you had entered a typo in the image tag). We don't want the controller to keep creating and deleting the same pod over and over again as fast as it can, as this will put a load on kube-apiserver, etcd, kube-scheduler, and so on, which would create an extreme case of a large number of pods all crashlooping at the same time, and this could take the cluster down.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Summary</h1>
			<p>In this chapter, we learned about Rancher, RKE, RKE2, K3s, and RancherD. We went over some of the pros and cons of each product. We then went over how they were designed and how they work. Next, we covered all of the controllers that make up Rancher and explored how they work behind the scenes. After that, we dove into how Rancher uses its Cattle agents for communicating with its clusters and nodes. Finally, we went into detail on the different core components of K8s, including kube-apiserver, kube-controller-manager, and kube-scheduler.</p>
			<p>In the next chapter, we will see how to install Rancher in a single-node environment.</p>
		</div>
	</body></html>