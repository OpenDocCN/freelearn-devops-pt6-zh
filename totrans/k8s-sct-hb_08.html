<html><head></head><body>
<div id="_idContainer041">
<h1 class="chapter-number" id="_idParaDest-146"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-147"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.2.1">Exploring Cloud Secret Store on AWS</span></h1>
<p><span class="koboSpan" id="kobo.3.1">A very common way to store Secrets in the cloud is to utilize the infrastructure that is provided by cloud providers. </span><span class="koboSpan" id="kobo.3.2">The major cloud providers have two essential pieces of infrastructure that help us with efficient Secrets management on Kubernetes: Secret Storage </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">and KMS.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we shall examine AWS Secrets Manager, </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Elastic Kubernetes Service</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">EKS</span></strong><span class="koboSpan" id="kobo.9.1">) integration, and secret encryption with KMS. </span><span class="koboSpan" id="kobo.9.2">Specifically, we will cover </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">these topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Overview of AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Secrets Manager</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Secrets Store </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">CSI Driver</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">AWS EKS clusters and AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Secrets Manager</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">KMS for AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Kubernetes encryption</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.19.1">By the end of the chapter, we should be able to use AWS Secrets Manager as an external Kubernetes secret store, encrypt Secrets on Kubernetes using AWS KMS, and search audit logs on secret operations using AWS CloudTrail and </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">AWS CloudWatch.</span></span></p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">To link concepts with practice, we will use a series of tools and platforms that are commonly used to interact with the AWS API </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">and Kubernetes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.24.1">An AWS Free Tier account is required. </span><span class="koboSpan" id="kobo.24.2">The free tier is available to new AWS customers for a limited period. </span><span class="koboSpan" id="kobo.24.3">Once the period expires or the usage exceeds the free tier usage limits, pay-as-you-go service </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">rates apply.</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.27.1">AWS CLI</span></strong><span class="koboSpan" id="kobo.28.1"> (</span><a href="https://aws.amazon.com/cli/"><span class="koboSpan" id="kobo.29.1">https://aws.amazon.com/cli/</span></a><span class="koboSpan" id="kobo.30.1">) is a</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.31.1"> unified tool for managing your AWS services. </span><span class="koboSpan" id="kobo.31.2">Commands executed through the AWS CLI are transformed into API calls toward the </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">AWS API.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.33.1">Terraform</span></strong><span class="koboSpan" id="kobo.34.1"> (</span><a href="https://www.terraform.io/"><span class="koboSpan" id="kobo.35.1">https://www.terraform.io/</span></a><span class="koboSpan" id="kobo.36.1">) is infrastructure-as-code software that can be used to </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.37.1">provision and manage infrastructure in </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">the cloud.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.39.1">kubectl</span></strong><span class="koboSpan" id="kobo.40.1"> (</span><a href="https://kubernetes.io/docs/reference/kubectl/"><span class="koboSpan" id="kobo.41.1">https://kubernetes.io/docs/reference/kubectl/</span></a><span class="koboSpan" id="kobo.42.1">) is a command-line tool used for communicating </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.43.1">with a Kubernetes cluster through the </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">Kubernetes API.</span></span></li>
</ul>
<h1 id="_idParaDest-149"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.45.1">Overview of AWS Secrets Manager</span></h1>
<p><span class="koboSpan" id="kobo.46.1">A secret</span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.47.1"> is a concept that exists outside the realm of Kubernetes. </span><span class="koboSpan" id="kobo.47.2">Any type of application will at some point require sensitive information to be integrated with each deployment. </span><span class="koboSpan" id="kobo.47.3">An application deployed in the cloud requires secure secret handling. </span><span class="koboSpan" id="kobo.47.4">For this reason, cloud providers offer components for </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">secret storage.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">When it comes to Kubernetes, we saw in </span><a href="B20970_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.50.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.51.1">, </span><em class="italic"><span class="koboSpan" id="kobo.52.1">Understanding Kubernetes Secrets Management</span></em><span class="koboSpan" id="kobo.53.1">, that secret information is stored on etcd. </span><span class="koboSpan" id="kobo.53.2">Essentially, etcd</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.54.1"> is the default secret store of Kubernetes. </span><span class="koboSpan" id="kobo.54.2">The crucial question is whether it is possible to have external storage for Secrets on Kubernetes apart </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">from etcd.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">This is feasible provided you actively use a cloud providerâ€™s secret storage, or you consider taking advantage of it and utilizing it on Kubernetes. </span><span class="koboSpan" id="kobo.56.2">Thanks to the Container Storage Interface and the workload identity, we can utilize the available </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">secret stores.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">AWS Secrets Manager (</span><a href="https://aws.amazon.com/secrets-manager/"><span class="koboSpan" id="kobo.59.1">https://aws.amazon.com/secrets-manager/</span></a><span class="koboSpan" id="kobo.60.1">) is the secret store provided by</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.61.1"> AWS. </span><span class="koboSpan" id="kobo.61.2">With </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.62.1">AWS Secrets Manager, we can store several types of credentials, such as database credentials, application credentials, and secure tokens. </span><span class="koboSpan" id="kobo.62.2">We will now focus on the features that make AWS Secrets Manager a good option for handling Secrets, starting </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">with encryption.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.64.1">Encryption</span></h2>
<p><span class="koboSpan" id="kobo.65.1">AWS Secrets Manager has encryption</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.66.1"> at rest as well as in transit. </span><span class="koboSpan" id="kobo.66.2">It uses AWS KMS to perform envelope encryption. </span><span class="koboSpan" id="kobo.66.3">The values stored in AWS Secrets Manager are encrypted using a data key, and the data key is encrypted using AWS KMS. </span><span class="koboSpan" id="kobo.66.4">The data encryption key is an AES-256 key. </span><span class="koboSpan" id="kobo.66.5">When a value changes on AWS Secrets Manager, a new data encryption key is generated and is used to encrypt the new value. </span><span class="koboSpan" id="kobo.66.6">We can also configure AWS Secrets Manager to use a different KMS key. </span><span class="koboSpan" id="kobo.66.7">AWS Secrets</span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.67.1"> Manager also provides encryption in transit. </span><span class="koboSpan" id="kobo.67.2">The API calls toward Secrets Manager happen through secure private endpoints, and each call is required to be signed using X.509 certificates or a Secrets Manager secret </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">access key.</span></span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.69.1">Versioning</span></h2>
<p><span class="koboSpan" id="kobo.70.1">Versioning</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.71.1"> is another benefit of using AWS Secrets Manager. </span><span class="koboSpan" id="kobo.71.2">If we create a secret in AWS Secrets Manager, the secret will be stored, and a version will be assigned to it. </span><span class="koboSpan" id="kobo.71.3">This will be the first version of the secret. </span><span class="koboSpan" id="kobo.71.4">Once we update that secret, we will have an updated version of the secret, and the old version will still be available. </span><span class="koboSpan" id="kobo.71.5">When we access the secret, the latest version of it will be retrieved. </span><span class="koboSpan" id="kobo.71.6">The previous version can be configured to be automatically deleted at a certain date. </span><span class="koboSpan" id="kobo.71.7">This will make it impossible to retrieve it. </span><span class="koboSpan" id="kobo.71.8">If we want to retrieve the previous version, we must remove it from </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">pending deletion.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.73.1">Rotation</span></h2>
<p><span class="koboSpan" id="kobo.74.1">AWS Secrets Manager </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.75.1">also permits rotation. </span><span class="koboSpan" id="kobo.75.2">An AWS Lambda function can be configured to execute a scheduled key rotation; the AWS documentation has a detailed guide (</span><a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets.html"><span class="koboSpan" id="kobo.76.1">https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets.html</span></a><span class="koboSpan" id="kobo.77.1">). </span><span class="koboSpan" id="kobo.77.2">On invocation, the Lambda function will rotate the key based on a custom code snippet that we provided; the function templates can be found on GitHub (</span><a href="https://github.com/aws-samples/aws-secrets-manager-rotation-lambdas"><span class="koboSpan" id="kobo.78.1">https://github.com/aws-samples/aws-secrets-manager-rotation-lambdas</span></a><span class="koboSpan" id="kobo.79.1">). </span><span class="koboSpan" id="kobo.79.2">During the rotation, the latest version of the key will be tested. </span><span class="koboSpan" id="kobo.79.3">On failure, the rotation will </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">be retried.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.81.1">Cloud-based features</span></h2>
<p><span class="koboSpan" id="kobo.82.1">Apart from tackling </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.83.1">the storage needs of sensitive</span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.84.1"> information, AWS Secrets Manager is a managed AWS component. </span><span class="koboSpan" id="kobo.84.2">Every AWS component comes with </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">certain features:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.86.1">AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">IAM integration</span></span></li>
<li><span class="koboSpan" id="kobo.88.1">Logging and auditing </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">on usage</span></span></li>
<li><span class="koboSpan" id="kobo.90.1">High availability and </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">disaster recovery</span></span></li>
<li><span class="koboSpan" id="kobo.92.1">Integration with other </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">AWS components</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.94.1">Letâ€™s look at each of </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">these features.</span></span></p>
<h3><span class="koboSpan" id="kobo.96.1">AWS IAM integration</span></h3>
<p><span class="koboSpan" id="kobo.97.1">With AWS </span><strong class="bold"><span class="koboSpan" id="kobo.98.1">Identity and Access Management</span></strong><span class="koboSpan" id="kobo.99.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.100.1">IAM</span></strong><span class="koboSpan" id="kobo.101.1">), we can specify entities that can access</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.102.1"> services and resources in AWS. </span><span class="koboSpan" id="kobo.102.2">Those entities can be AWS users or </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">AWS roles.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">AWS users are intended to be associated with an actual human user who wants to interact with an AWS service and provision resources. </span><span class="koboSpan" id="kobo.104.2">AWS roles are a more flexible identity. </span><span class="koboSpan" id="kobo.104.3">AWS roles are used to delegate access to services, EC2 machines, and </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">Kubernetes workloads.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">The identities on AWS can be granted fine-grained permissions on </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">AWS services.</span></span></p>
<h3><span class="koboSpan" id="kobo.108.1">Logging and auditing</span></h3>
<p><span class="koboSpan" id="kobo.109.1">AWS comes with </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.110.1">CloudWatch, which is a monitoring and observability solution. </span><span class="koboSpan" id="kobo.110.2">CloudWatch collects real-time logs and metrics from other AWS components. </span><span class="koboSpan" id="kobo.110.3">In our case, with CloudWatch we can identify Kubernetes operations through logging; also, we can create custom alerts and dashboards based on the metrics provided out of </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">the box.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">CloudTrail is an AWS service targeted toward auditing. </span><span class="koboSpan" id="kobo.112.2">With CloudTrail, we can track actions taken by an AWS user or an AWS role. </span><span class="koboSpan" id="kobo.112.3">Those operations will be recorded and will be accessible through AWS CloudTrail. </span><span class="koboSpan" id="kobo.112.4">Take, for example, a secret retrieval by a role attached to an EC2 machine. </span><span class="koboSpan" id="kobo.112.5">The code running on the EC2 machine is granted permission to receive the secret, the secret is retrieved, and this action is logged to AWS CloudTrail. </span><span class="koboSpan" id="kobo.112.6">The EC2 machine has a role assigned with permissions to interact with AWS Secrets Manager; the role is an AWS identity, just like an AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">console user.</span></span></p>
<p><span class="koboSpan" id="kobo.114.1">In the following screenshot, we can see the CloudTrail screen displaying </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">auditing information:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.116.1"><img alt="Figure 8.1 â€“ AWS CloudTrail screen" src="image/B20970_08_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.117.1">Figure 8.1 â€“ AWS CloudTrail screen</span></p>
<p><span class="koboSpan" id="kobo.118.1">Thanks to</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.119.1"> CloudTrail, we can identify the action that took place in AWS Secrets Manager, the identity that executed it, and at </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">what time.</span></span></p>
<h3><span class="koboSpan" id="kobo.121.1">High availability and disaster recovery</span></h3>
<p><span class="koboSpan" id="kobo.122.1">Secrets provisioned on Secrets </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.123.1">Manager are regionally highly available. </span><span class="koboSpan" id="kobo.123.2">This means that the secret operations will span the three availability zones that an AWS region consists of. </span><span class="koboSpan" id="kobo.123.3">If an availability zone becomes unavailable, requests for a secret will be served by another </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">availability zone.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">Also, with AWS Secrets</span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.126.1"> Manager, we can achieve disaster recovery. </span><span class="koboSpan" id="kobo.126.2">By default, when we create a secret, we choose an availability zone, where this secret will reside. </span><span class="koboSpan" id="kobo.126.3">To protect our workloads from situations where a region is lost, we provision our infrastructure in a way that disaster recovery is feasible. </span><span class="koboSpan" id="kobo.126.4">AWS Secrets Manager makes this easy by enabling us to replicate a secret to </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">another region.</span></span></p>
<h3><span class="koboSpan" id="kobo.128.1">Integration with other AWS components</span></h3>
<p><span class="koboSpan" id="kobo.129.1">A benefit of using the </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.130.1">components provided by the cloud providers is how well they are integrated. </span><span class="koboSpan" id="kobo.130.2">AWS Secrets Manager can be integrated with other AWS components easily. </span><span class="koboSpan" id="kobo.130.3">In our case, we are interested in EKS, which is the managed version of Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">on AWS.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">We had an </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.133.1">overview of AWS Secrets Manager and saw how it can be integrated with other AWS components. </span><span class="koboSpan" id="kobo.133.2">We shall proceed with integrating AWS Secrets Manager with EKS. </span><span class="koboSpan" id="kobo.133.3">To achieve this, we will have an overview of the tool that facilitates this integration, Secrets Store </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">CSI Driver.</span></span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.135.1">Secrets Store CSI Driver</span></h1>
<p><span class="koboSpan" id="kobo.136.1">Kubernetes CSI is a standardized</span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.137.1"> interface for Kubernetes that enables us to utilize different storage providers with Kubernetes. </span><span class="koboSpan" id="kobo.137.2">Instead of being limited to using the default storage on Kubernetes, we have an interface providing a specification upon which we can build storage drivers. </span><span class="koboSpan" id="kobo.137.3">This way we can use several types of storage by implementing a new driver that complies with the </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">CSI interface.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">Here are some popular drivers </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">for CSI:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.141.1">AWS Elastic </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">File System</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.143.1">Azure File</span></span></li>
<li><span class="koboSpan" id="kobo.144.1">Google </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">Cloud Filestore</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.146.1">This is feasible for several forms of storage and is also applicable to the Secrets storage components provided by the </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">cloud providers.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">CSI drivers are provided for secret storage by the cloud providers. </span><span class="koboSpan" id="kobo.148.2">Secrets Store CSI Driver is a CSI interface that targets Secrets management. </span><span class="koboSpan" id="kobo.148.3">We can use it to mount Secrets on Kubernetes through another form of storage. </span><span class="koboSpan" id="kobo.148.4">Instead of consuming Secrets from etcd, thanks to Secrets Store CSI Driver, we can consume the Secrets from various external sources, and in our case, those sources are the very Secrets Storage solutions that are provided by the </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">cloud providers.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">In this section, we will focus on AWS Secrets Manager and examine how we can integrate a Kubernetes cluster into AWS to consume Secrets from the native cloud provider solution for Secrets management by using the corresponding Secrets Store </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">CSI Driver.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.152.1">How Secrets Store CSI Driver works</span></h2>
<p><span class="koboSpan" id="kobo.153.1">We</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.154.1"> have an application to be hosted on Kubernetes. </span><span class="koboSpan" id="kobo.154.2">That application will have to use a secret that resides on the Secrets storage solution of the cloud provider. </span><span class="koboSpan" id="kobo.154.3">The application will reside on a Pod since the Pod is the main compute building block </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">of Kubernetes.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">Once a Pod is created, started, or restarted, Secrets Store CSI Driver through the Secret Store CSI provider will communicate with the cloud providerâ€™s Secrets storage and retrieve the credentials. </span><span class="koboSpan" id="kobo.156.2">The credentials will be mounted to the Pod as a volume. </span><span class="koboSpan" id="kobo.156.3">The volume mounted will be attached to a </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">directory specified.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">The next question is how Secret Store CSI </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">Driver works.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">Secret Store CSI Driver is</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.161.1"> a </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">DaemonSet</span></strong><span class="koboSpan" id="kobo.163.1">. </span><span class="koboSpan" id="kobo.163.2">A DaemonSet exists on Kubernetes on every node. </span><span class="koboSpan" id="kobo.163.3">A DaemonSet can consist of more than </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">one Pod.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">In the case of Secret Store CSI Driver, we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">following Pods:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">node-driver-registrar</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">secrets-store</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">liveness-probe</span></strong></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.170.1">node-driver-registrar</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">node-driver-registrar</span></strong><span class="koboSpan" id="kobo.172.1"> will </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.173.1">register the CSI driver with the kubelet. </span><span class="koboSpan" id="kobo.173.2">A registration socket is created and exposed via the host path in the kubelet </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">plugin registry.</span></span></p>
<h3><span class="koboSpan" id="kobo.175.1">secrets-store</span></h3>
<p><span class="koboSpan" id="kobo.176.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">secrets-store</span></strong><span class="koboSpan" id="kobo.178.1"> component </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.179.1">is responsible for mounting secret volumes during Pod creation as well as unmounting volumes during Pod deletion. </span><span class="koboSpan" id="kobo.179.2">It is based on gRPC implementing the CSI node service from the </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">CSI specification.</span></span></p>
<h3><span class="koboSpan" id="kobo.181.1">liveness-probe</span></h3>
<p><span class="koboSpan" id="kobo.182.1">This Pod </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.183.1">monitors the health of the CSI driver. </span><span class="koboSpan" id="kobo.183.2">The health liveness probe will detect any issues with the driver and will restart the Pod in order to fix the issue. </span><span class="koboSpan" id="kobo.183.3">In the following diagram, we can see how all the components </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">come together:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.185.1"><img alt="Figure 8.2 â€“ Secrets Store CSI and AWS Secrets Manager integration" src="image/B20970_08_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.186.1">Figure 8.2 â€“ Secrets Store CSI and AWS Secrets Manager integration</span></p>
<p><span class="koboSpan" id="kobo.187.1">Now that we know about the CSI driver, we shall proceed with integrating it </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">with EKS.</span></span></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.189.1">Integrating AWS Secrets Manager with EKS</span></h1>
<p><span class="koboSpan" id="kobo.190.1">To integrate AWS Secrets Manager with Kubernetes, we shall utilize the Secrets Store CSI Driver . </span><span class="koboSpan" id="kobo.190.2">As expected, AWS provides us with Secrets Store CSI Driver (</span><a href="https://github.com/aws/secrets-store-csi-driver-provider-aws"><span class="koboSpan" id="kobo.191.1">https://github.com/aws/secrets-store-csi-driver-provider-aws</span></a><span class="koboSpan" id="kobo.192.1">). </span><span class="koboSpan" id="kobo.192.2">To integrate the driver with Kubernetes, we will create a </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">Kubernetes cluster.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.194.1">EKS cluster on AWS</span></h2>
<p><span class="koboSpan" id="kobo.195.1">As defined earlier, </span><strong class="bold"><span class="koboSpan" id="kobo.196.1">EKS</span></strong><span class="koboSpan" id="kobo.197.1"> in AWS stands</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.198.1"> for </span><strong class="bold"><span class="koboSpan" id="kobo.199.1">Elastic Kubernetes Service</span></strong><span class="koboSpan" id="kobo.200.1">. </span><span class="koboSpan" id="kobo.200.2">We have the option to set up a Kubernetes cluster on the AWS cloud just like </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.201.1">every other cloud. </span><span class="koboSpan" id="kobo.201.2">We will focus on the managed service offering for the purpose of this chapter because it requires less maintenance and </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">setup overhead.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">If there is already an existing EKS cluster available, the Terraform setup instructions can be ignored since the corresponding command-line arguments for AWS will </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">be provided.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">Implementing a Kubernetes cluster on AWS can require different amounts of effort based on the installation you want to achieve. </span><span class="koboSpan" id="kobo.205.2">One option is to create fully private clusters with no connectivity to the internet and everything being served internally from AWS. </span><span class="koboSpan" id="kobo.205.3">Another option is a cluster on a public network. </span><span class="koboSpan" id="kobo.205.4">A quite common option nowadays is to deploy the nodes of the cluster on subnets that are private and ensure that the connectivity to the internet happens through a NAT gateway. </span><span class="koboSpan" id="kobo.205.5">This is the option we </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">shall follow.</span></span></p>
<h3><span class="koboSpan" id="kobo.207.1">Configuring the Terraform project</span></h3>
<p><span class="koboSpan" id="kobo.208.1">A Terraform project</span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.209.1"> on AWS requires us to store the state. </span><span class="koboSpan" id="kobo.209.2">We can store the state locally on our filesystem, but this is not a viable option for infrastructure as code targeting a production environment. </span><span class="koboSpan" id="kobo.209.3">Our option is to use a </span><strong class="bold"><span class="koboSpan" id="kobo.210.1">Secure Storage Service</span></strong><span class="koboSpan" id="kobo.211.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.212.1">S3</span></strong><span class="koboSpan" id="kobo.213.1">) bucket</span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.214.1"> to store </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">the state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.216.1">
terraform {
...
</span><span class="koboSpan" id="kobo.216.2">Â Â backend "s3" {
Â Â Â Â bucket = "state-bucket"
Â Â Â Â keyÂ Â Â Â = "eks-state"
Â Â Â Â region = "eu-west-1"
Â Â }</span></pre> <p><span class="koboSpan" id="kobo.217.1">By default, the Terraform code base will use the default credentials that are configured for the </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">AWS CLI.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">We first need to initialize the Terraform project </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">init</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.223.1">
$ terraform init</span></pre> <p><span class="koboSpan" id="kobo.224.1">This command will initialize </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">our project.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">With</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.227.1"> Terraform, we have the option of </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">plan</span></strong><span class="koboSpan" id="kobo.229.1">, which is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">dry-run</span></strong><span class="koboSpan" id="kobo.231.1"> command from kubectl. </span><span class="koboSpan" id="kobo.231.2">Instead of creating the resources, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">plan</span></strong><span class="koboSpan" id="kobo.233.1"> and identify what the state of the infrastructure would be like if the Terraform scripts had </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">been applied:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.235.1">
$ terraform plan</span></pre> <p><span class="koboSpan" id="kobo.236.1">To apply the infrastructure, we shall use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">apply</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.238.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.239.1">
$ terraform apply</span></pre> <h4><span class="koboSpan" id="kobo.240.1">Terraform basics</span></h4>
<p><span class="koboSpan" id="kobo.241.1">When using</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.242.1"> Terraform, infrastructure is defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">.tf</span></strong><span class="koboSpan" id="kobo.244.1"> files. </span><span class="koboSpan" id="kobo.244.2">A Terraform project involves the </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">following operations:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">init</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">plan</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">apply</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">destroy</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.250.1">So far, we have seen </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">init</span></strong><span class="koboSpan" id="kobo.252.1">, which is used to initialize the project and download the existing state; </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">plan</span></strong><span class="koboSpan" id="kobo.254.1">, which is used to evaluate the changes we perform; and </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">apply</span></strong><span class="koboSpan" id="kobo.256.1">, which is the command used to carry out the changes. </span><span class="koboSpan" id="kobo.256.2">To destroy the provisioned resource, we can use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">destroy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.258.1"> command.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">These operations can be carried out on the project or can target a specific resource defined in the </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">Terraform files:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.261.1">
$ terraform apply -target=aws_kms_key.a</span></pre> <p><span class="koboSpan" id="kobo.262.1">In the case of existing resources, there is the option to import those resources in the Terraform state and provide them with a resource definition on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">tf</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.265.1"> files:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.266.1">
$ terraform import aws_kms_key.a 136c1dcb-42b0-4b9a-a569-152b9aba63e1</span></pre> <p><span class="koboSpan" id="kobo.267.1">There is a recommended structure for Terraform projects. </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">main.tf</span></strong><span class="koboSpan" id="kobo.269.1"> is the primary entry point to define resources. </span><span class="koboSpan" id="kobo.269.2">As the complexity of the infrastructure increases, more </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">.tf</span></strong><span class="koboSpan" id="kobo.271.1"> files can be used. </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">variables.tf</span></strong><span class="koboSpan" id="kobo.273.1"> contains variables that we want to be dynamic when provisioning the infrastructure and </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">outputs.tf</span></strong><span class="koboSpan" id="kobo.275.1"> should contain the information we want to extract when we provision infrastructure </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">with Terraform.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">The Terraform </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.278.1">project is set up, so we shall proceed with setting the VPC </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">through Terraform.</span></span></p>
<h3><span class="koboSpan" id="kobo.280.1">Creating the VPC</span></h3>
<p><span class="koboSpan" id="kobo.281.1">Our cluster nodes will reside on AWS VPC. </span><span class="koboSpan" id="kobo.281.2">We shall use the VPC module</span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.282.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">terraform-aws-modules</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.284.1">project (</span></span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">https://registry.terraform.io/modules/terraform-aws-modules/vpc/aws/latest</span></span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
module "eks_ksm_vpc" {
Â Â sourceÂ Â = "terraform-aws-modules/vpc/aws"
Â Â version = "5.0.0"
Â Â name = "eks-ksm-vpc"
Â Â cidr = "10.0.0.0/16"
Â Â azsÂ Â = slice(var.availability_zones, 0, 3)
Â Â private_subnets = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
Â Â public_subnetsÂ Â = ["10.0.4.0/24", "10.0.5.0/24", "10.0.6.0/24"]
Â Â enable_nat_gatewayÂ Â Â = true
Â Â single_nat_gatewayÂ Â Â = true
Â Â enable_dns_hostnames = true
...
</span><span class="koboSpan" id="kobo.287.2">}</span></pre> <p><span class="koboSpan" id="kobo.288.1">With this configuration, we will span a VPC among three availability zones, thus enabling us to have a highly </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">available cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">We shall create a private subnet in each zone as well as </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">public subnets.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">The Kubernetes</span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.293.1"> workloads will be hosted on the private subnets and external traffic will reach the Kubernetes workloads through the public network. </span><span class="koboSpan" id="kobo.293.2">To provide access to the internet from within the Kubernetes cluster, a NAT gateway will </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">be configured.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">Since we have the VPC configured we can now proceed and configure the </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">EKS cluster.</span></span></p>
<h3><span class="koboSpan" id="kobo.297.1">Provisioning the EKS cluster</span></h3>
<p><span class="koboSpan" id="kobo.298.1">We have provisioned the </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.299.1">VPC, so now we shall proceed with provisioning the EKS cluster. </span><span class="koboSpan" id="kobo.299.2">We will pick the EKS module from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">terraform-aws-modules</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.301.1">project (</span></span><a href="https://registry.terraform.io/modules/terraform-aws-modules/eks/aws/latest"><span class="No-Break"><span class="koboSpan" id="kobo.302.1">https://registry.terraform.io/modules/terraform-aws-modules/eks/aws/latest</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.303.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
module "eks" {
Â Â sourceÂ Â = "terraform-aws-modules/eks/aws"
Â Â ...
</span><span class="koboSpan" id="kobo.304.2">Â Â cluster_nameÂ Â Â Â = var.cluster_name
Â Â vpc_idÂ Â Â Â Â Â Â Â Â Â = module.eks_ksm_vpc.vpc_id
Â Â subnet_idsÂ Â Â Â Â Â = module.eks_ksm_vpc.private_subnets
Â Â cluster_endpoint_public_access = true
Â Â eks_managed_node_group_defaults = {
Â Â Â Â ami_type = "AL2_x86_64"
Â Â }
Â Â create_cloudwatch_log_group = true
Â Â eks_managed_node_groups = {
Â Â Â Â one = {
Â Â Â Â Â Â ...
</span><span class="koboSpan" id="kobo.304.3">Â Â Â Â Â Â min_sizeÂ Â Â Â Â = 1
Â Â Â Â }
Â Â }
}</span></pre> <p><span class="koboSpan" id="kobo.305.1">This will create an EKS cluster. </span><span class="koboSpan" id="kobo.305.2">The master is managed by AWS. </span><span class="koboSpan" id="kobo.305.3">By creating the cluster, we specified that the nodes span the private subnets we specified previously in the VPC section. </span><span class="koboSpan" id="kobo.305.4">We will also create a separate log group for the </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">EKS cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">To make it easy to interact with the EKS master, we shall configure the cluster endpoint to be publicly accessible. </span><span class="koboSpan" id="kobo.307.2">The option can be fine-tuned and specify a restricted number of IPs to be able to interact with the cluster through the </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">kubectl tool.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">Once the cluster is up and running, we can test and even run some </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">kubectl commands.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">To authenticate to </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.312.1">the cluster, we shall use the </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.314.1">
$ aws eks --region eu-west-1 update-kubeconfig --name eks-ksm-cluster</span></pre> <p><span class="koboSpan" id="kobo.315.1">The command will differ depending on the cluster name and the region we choose. </span><span class="koboSpan" id="kobo.315.2">Once this is done, we can use kubectl to point to the recently </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">provisioned cluster:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.317.1">
$ kubectl get nodes
NAMEÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â STATUSÂ Â Â ROLESÂ Â Â Â AGEÂ Â Â Â VERSION
ip-10-0-2-231.eu-west-1.compute.internalÂ Â Â ReadyÂ Â Â Â &lt;none&gt;Â Â Â 6m5sÂ Â Â v1.24.15-eks-a5565ad</span></pre> <p><span class="koboSpan" id="kobo.318.1">Now that we have provisioned the EKS cluster, we can proceed to work with AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">Secrets Manager.</span></span></p>
<h3><span class="koboSpan" id="kobo.320.1">Creating Secrets on Secrets Manager</span></h3>
<p><span class="koboSpan" id="kobo.321.1">Letâ€™s </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.322.1">create a</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.323.1"> secret using AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">Secrets Manager:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.325.1">
resource "aws_secretsmanager_secret" "ksm_service_token" {
Â Â name = "service-token"
Â Â replica {
Â Â Â Â region = "eu-central-1"
Â Â }
Â Â recovery_window_in_days {
Â Â Â Â ...
</span><span class="koboSpan" id="kobo.325.2">Â Â }
}</span></pre> <p><span class="koboSpan" id="kobo.326.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">replica</span></strong><span class="koboSpan" id="kobo.328.1"> block, we specify the region in which we will replicate the secret. </span><span class="koboSpan" id="kobo.328.2">This will give us</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.329.1"> disaster recovery capabilities. </span><span class="koboSpan" id="kobo.329.2">Also, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">recovery_window_in_days</span></strong><span class="koboSpan" id="kobo.331.1"> block defines within how many days we can recover a </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.332.1">secret after we set it </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">for deletion.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">Now, letâ€™s add a version for the secret </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">we specified:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.336.1">
resource "aws_secretsmanager_secret_version" "ksm_service_token_first_version" {
Â Â secret_idÂ Â Â Â Â = aws_secretsmanager_secret.ksm_service_token.id
Â Â secret_string = "a-service-token"
}</span></pre> <p><span class="koboSpan" id="kobo.337.1">This is our first interaction with AWS Secrets Manager. </span><span class="koboSpan" id="kobo.337.2">We have created a secret and a version of the secret containing </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">a string.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">We will also create a role with the required </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">IAM bindings:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.341.1">
resource "aws_iam_role" "eks_secret_reader_role" {
Â Â name = "eks-secret-reader"
Â Â assume_role_policy = jsonencode({
Â Â Â Â Version = "2012-10-17",
Â Â Â Â Statement = [
Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Effect = "Allow",
Â Â Â Â Â Â Â Â "Principal": {
Â Â Â Â Â Â Â Â Â Â "Federated": "arn:aws:iam::${data.aws_caller_identity.current.account_id}:oidc-provider/${module.ksm_eks.oidc_provider}"
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â "Action": "sts:AssumeRoleWithWebIdentity",
Â Â Â Â Â Â Â Â "Condition": {
Â Â Â Â Â Â Â Â Â Â "StringEquals": {
Â Â Â Â Â Â Â Â Â Â Â Â "${module.ksm_eks.oidc_provider}:aud": "sts.amazonaws.com",
Â Â Â Â Â Â Â Â Â Â Â Â "${module.ksm_eks.oidc_provider}:sub": "system:serviceaccount:default:service-token-reader"
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â }
Â Â Â Â Â Â }
Â Â Â Â ]
Â Â })
}
resource "aws_iam_role_policy_attachment" "esrrs" {
Â Â policy_arn = aws_iam_policy.ksm_service_token_reader.arn
Â Â roleÂ Â Â Â Â Â Â = aws_iam_role.eks_secret_reader_role.name
}</span></pre> <p><span class="koboSpan" id="kobo.342.1">Pay close </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.343.1">attention to the role. </span><span class="koboSpan" id="kobo.343.2">It is very different from</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.344.1"> what we are used to. </span><span class="koboSpan" id="kobo.344.2">This role is created with EKS in mind. </span><span class="koboSpan" id="kobo.344.3">This role is a workload identity mapped to a role in the </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">The role is limited in what it can do. </span><span class="koboSpan" id="kobo.346.2">We cannot use the role to perform operations on other </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">AWS resources.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">Alternatively, we can provision the Secrets using the </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">AWS CLI:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.350.1">
$ aws secretsmanager create-secret --name service-token --secret-string a-service-tokenÂ Â --add-replica-regions Region=eu-central-1</span></pre> <p><span class="koboSpan" id="kobo.351.1">This will create a secret and </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">a version.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">We can also create the role and the policy using the </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">AWC CLI:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.355.1">
...
</span><span class="koboSpan" id="kobo.355.2">$ aws iam create-role --role-name eks-secret-reader --assume-role-policy-document file://eks-reader-trust-policy.json
...
</span><span class="koboSpan" id="kobo.355.3">$ aws iam create-policy --policy-name get-service-token --policy-documentÂ Â file://policy.json
...
</span><span class="koboSpan" id="kobo.355.4">$ aws iam attach-role-policy --role-name eks-secret-reader --policy-arn arn:aws:iam::$account_id:policy/get-service-token</span></pre> <p><span class="koboSpan" id="kobo.356.1">We have a</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.357.1"> role that can be attached to Kubernetes </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.358.1">and retrieve Secrets from Secrets Manager. </span><span class="koboSpan" id="kobo.358.2">Our next step is to install the </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">CSI plugin.</span></span></p>
<h3><span class="koboSpan" id="kobo.360.1">AWS Secrets Manager provider for CSI on EKS</span></h3>
<p><span class="koboSpan" id="kobo.361.1">It is now time to</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.362.1"> install the AWS Secrets Manager CSI provider on EKS. </span><span class="koboSpan" id="kobo.362.2">The first thing to do is to add the Secrets Store CSI Driver plugin to the </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">EKS installation.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">Letâ€™s start by installing the driver on EKS, since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">secrets-store-csi</span></strong><span class="koboSpan" id="kobo.366.1"> driver is not available as </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">an add-on:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.368.1">
$ helm repo add secrets-store-csi-driver https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts
$ helm install -n kube-system csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver
$ helm repo add aws-secrets-manager https://aws.github.io/secrets-store-csi-driver-provider-aws $ helm install -n kube-system secrets-provider-aws aws-secrets-manager/secrets-store-csi-driver-provider-aws</span></pre> <p><span class="koboSpan" id="kobo.369.1">The</span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.370.1"> following will install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">secret-store-csi-driver</span></strong><span class="koboSpan" id="kobo.372.1"> DaemonSet. </span><span class="koboSpan" id="kobo.372.2">We can validate the installation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">secret-store-csi-driver</span></strong><span class="koboSpan" id="kobo.374.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.376.1">
$ kubectl get daemonset -n kube-system
NAMEÂ Â Â Â Â Â Â Â Â DESIREDÂ Â Â CURRENTÂ Â Â READYÂ Â Â UP-TO-DATEÂ Â Â AVAILABLEÂ Â Â NODE SELECTORÂ Â Â Â Â Â Â Â Â Â Â Â Â Â AGEÂ Â Â &lt;none&gt;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 47m
...
</span><span class="koboSpan" id="kobo.376.2">secrets-provider-aws-secrets-store-csi-driver-provider-awsÂ Â Â 1Â Â Â Â Â Â Â Â Â 1Â Â Â Â Â Â Â Â Â 1Â Â Â Â Â Â Â 1Â Â Â Â Â Â Â Â Â Â Â Â 1Â Â Â Â Â Â Â Â Â Â Â kubernetes.io/os=linuxÂ Â Â Â Â 44s</span></pre> <p><span class="koboSpan" id="kobo.377.1">We can proceed with fetching the credentials from the secret store </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">through Kubernetes.</span></span></p>
<h3><span class="koboSpan" id="kobo.379.1">Fetching Secrets from Kubernetes</span></h3>
<p><span class="koboSpan" id="kobo.380.1">First, we want to map the secret </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.381.1">through a secret provider class. </span><span class="koboSpan" id="kobo.381.2">In the </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.382.1">object, we specify the name of the secret we want </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">to fetch:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.384.1">
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
Â Â name: service-token
spec:
Â Â provider: aws
Â Â parameters:
Â Â Â Â objects: |
Â Â Â Â Â Â Â Â - objectName: "arn:aws:secretsmanager:eu-west-1:1111111:secret:service_token-IJ2VLg"</span></pre> <p><span class="koboSpan" id="kobo.385.1">We map </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.386.1">a Kubernetes secret to a secret provided by </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.387.1">AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">Secrets Manager.</span></span></p>
<p><span class="koboSpan" id="kobo.389.1">Now we need a Kubernetes service account with permission to retrieve </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">this secret:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.391.1">
apiVersion: v1
kind: ServiceAccount
metadata:
Â Â annotations:
Â Â Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.392.1">eks.amazonaws.com/role-arn</span></strong><span class="koboSpan" id="kobo.393.1">: "arn:aws:iam::11111:role/eks-secret-reader"
Â Â name: service-token-reader
Â Â namespace: default</span></pre> <p><span class="koboSpan" id="kobo.394.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">eks.amazonaws.com/role-arn</span></strong><span class="koboSpan" id="kobo.396.1"> section, we specify the AWS role with </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">the permissions.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">As we can see, the service account is annotated with an AWS role, which is the AWS role we </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">created previously.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">This service account, provided it is attached to a Pod, will assume this role identity by using the Kubernetes OIDC provider. </span><span class="koboSpan" id="kobo.400.2">More on OIDC and Kubernetes service accounts can be found in the official </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">documentation (</span></span><a href="https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html"><span class="No-Break"><span class="koboSpan" id="kobo.402.1">https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.403.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">When the Pod is created, it will use that service account and mount that secret </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">upon it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.406.1">
kind: Pod
apiVersion: v1
metadata:
Â Â name: nginx
spec:
Â Â serviceAccountName: service-token-reader
Â Â containers:
Â Â - image: nginx
Â Â Â Â name: nginx
Â Â Â Â volumeMounts:
Â Â Â Â - name: secret-from-asm
Â Â Â Â Â Â mountPath: "/mnt/secrets-store"
Â Â Â Â Â Â readOnly: true
Â Â volumes:
Â Â Â Â - name: secret-from-asm
Â Â Â Â Â Â csi:
Â Â Â Â Â Â Â Â driver: secrets-store.csi.k8s.io
Â Â Â Â Â Â Â Â readOnly: true
Â Â Â Â Â Â Â Â volumeAttributes:
Â Â Â Â Â Â Â Â Â Â secretProviderClass: "service-token"</span></pre> <p><span class="koboSpan" id="kobo.407.1">We can test this </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.408.1">by printing</span><a id="_idIndexMarker495"/> <span class="No-Break"><span class="koboSpan" id="kobo.409.1">the secret:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.410.1">
$ kubectl exec -it nginx cat /mnt/secrets-store/arn:aws:secretsmanager:eu-west-1:274402012893:secret:service_token-IJ2VLg</span></pre> <p><span class="koboSpan" id="kobo.411.1">To summarize, we created a Pod with a service account, which was mapped to an AWS role. </span><span class="koboSpan" id="kobo.411.2">This service account had permission to interact with AWS Secrets Manager. </span><span class="koboSpan" id="kobo.411.3">As a result, we see the secret that we mounted previously. </span><span class="koboSpan" id="kobo.411.4">In the next section, we will focus on how we can track the actions that take place in AWS Secrets Manager, </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">through auditing.</span></span></p>
<h1 id="_idParaDest-158"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.413.1">Auditing</span></h1>
<p><span class="koboSpan" id="kobo.414.1">We</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.415.1"> have successfully created Secrets and made sure we received them securely by utilizing AWS IAM. </span><span class="koboSpan" id="kobo.415.2">Since secure access has been tackled and we have fine-grained permissions, we are interested in also logging the usage of and access to our Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">management instance.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">There are two ways to evaluate the secret access that occurs </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">in Kubernetes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.419.1">Kubernetes Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">access logs</span></span></li>
<li><span class="koboSpan" id="kobo.421.1">AWS Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">Manager logs</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.423.1">When auditing occurs, a log message is printed in the output of a program. </span><span class="koboSpan" id="kobo.423.2">This is integrated with CloudWatch, the logging solution provided by AWS, and CloudTrail, the auditing solution that </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">AWS provides.</span></span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.425.1">Kubernetes logs on CloudWatch</span></h2>
<p><span class="koboSpan" id="kobo.426.1">By using CloudWatch, we</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.427.1"> can browse the Kubernetes logs. </span><span class="koboSpan" id="kobo.427.2">Suppose we created a secret called </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">audit-test</span></strong><span class="koboSpan" id="kobo.429.1">. </span><span class="koboSpan" id="kobo.429.2">We can search for any operations on Logs Insights (</span><a href="https://console.aws.amazon.com/cloudwatch/home?logsV2%3Alogs-insights=#logsV2:logs-insights"><span class="koboSpan" id="kobo.430.1">https://console.aws.amazon.com/cloudwatch/home?logsV2%3Alogs-insights=#logsV2:logs-insights</span></a><span class="koboSpan" id="kobo.431.1">). </span><span class="koboSpan" id="kobo.431.2">We can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">following log:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.433.1">
fields @timestamp, @message, @logStream, @log
| filter @message like 'audit-test'
| sort @timestamp desc
| limit 20</span></pre> <p><span class="koboSpan" id="kobo.434.1">The result entries will show the </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">actual results:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.436.1">Field</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.437.1">Value</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">message</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">{"kind":"Event",...,"verb":"get","user":{"username":"kubernetes-admin", "uid":"aws-iam-authenticator:274402012893:AIDAILH3OPGRUQEOHAR3O", "groups":["system:masters","system:authenticated"], "extra":{"accessKeyId": ["AKIAI5INYQBL233Y7J6Q"],"arn": ["arn:aws:iam::274402012893: user/ gkatzioura"],"canonicalArn": ["arn:aws:iam:: 274402012893: user/gkatzioura"], "principalId": ["AIDAILH3OPGRUQEOHAR3O"],"sessionName": [""]}},"sourceIPs":["90.221.185.67"],"userAgent": "kubectl/v1.25.4  (darwin/arm64) kubernetes/872a965","objectRef":{"resource": "secrets","namespace":"default", "</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">name":"audit-test", "apiVersion":"v1"},"responseStatus":{"metadata":...}</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">timestamp</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">1692687754591</span></strong></span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.445.1">This result looks familiar. </span><span class="koboSpan" id="kobo.445.2">It is the log we saw previously in </span><a href="B20970_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.446.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.447.1">, </span><em class="italic"><span class="koboSpan" id="kobo.448.1">Walking through Kubernetes Secrets Management Concepts</span></em><span class="koboSpan" id="kobo.449.1">, when we were auditing </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">Kubernetes Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">Also, CloudWatch </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.452.1">gives us the option to create alarms. </span><span class="koboSpan" id="kobo.452.2">If there are unexpected log entries that indicate access or access attempts to a secret, we can configure CloudWatch to create an alert and notify us through the communication channel of our choice, for </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">example, email.</span></span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.454.1">AWS Secrets Manager logs on AWS CloudTrail</span></h2>
<p><span class="koboSpan" id="kobo.455.1">AWS CloudTrail</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.456.1"> is a service specifically for audit logs. </span><span class="koboSpan" id="kobo.456.2">With CloudTrail, we can identify the retrieval of </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">Kubernetes </span></span><span class="No-Break"><a id="_idIndexMarker500"/></span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">For example, we can use this URL to view the Secrets that have been recently retrieved in our AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">account: </span></span><a href="https://console.aws.amazon.com/cloudtrail/home?#/events?EventName=GetSecretValue"><span class="No-Break"><span class="koboSpan" id="kobo.461.1">https://console.aws.amazon.com/cloudtrail/home?#/events?EventName=GetSecretValue</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.462.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">If we navigate to</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.464.1"> the URL, the retrieval information from AWS Secrets Manager will </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">be displayed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.466.1">
{
Â Â Â Â "userIdentity": {
Â Â Â Â Â Â Â Â "type": "AssumedRole",
Â Â Â Â Â Â Â Â "principalId": "id:secrets-store-csi-driver-provider-aws",
Â Â Â Â Â Â Â Â "arn": "arn:aws:sts::1111111:assumed-role/eks-secret-reader/secrets-store-csi-driver-provider-aws",
Â Â Â Â ...
</span><span class="koboSpan" id="kobo.466.2">Â Â Â Â Â Â Â Â }
Â Â Â Â },
Â Â Â Â "eventSource": "secretsmanager.amazonaws.com",
Â Â Â Â "eventName": "GetSecretValue",
Â Â Â Â ...
</span><span class="koboSpan" id="kobo.466.3">Â Â Â Â "requestParameters": {
Â Â Â Â Â Â Â Â "secretId": "arn:aws:secretsmanager:eu-west-1:11111111:secret:service_token-93z7he"
Â Â Â Â },
Â Â Â Â "responseElements": null,
Â Â Â Â ...
</span><span class="koboSpan" id="kobo.466.4">}</span></pre> <p><span class="koboSpan" id="kobo.467.1">The user</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.468.1"> identity is the AWS role we created previously. </span><span class="koboSpan" id="kobo.468.2">The event name is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">GetSecretValue</span></strong><span class="koboSpan" id="kobo.470.1"> event. </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">r</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">equestParameters</span></strong><span class="koboSpan" id="kobo.473.1"> is the resource the operation is </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">executed on.</span></span></p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.475.1">KMS for AWS Secrets encryption</span></h1>
<p><span class="koboSpan" id="kobo.476.1">Kubernetes gives us the option to</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.477.1"> specify certain encryption providers when storing the Secrets on etcd. </span><span class="koboSpan" id="kobo.477.2">AWS KMS can be used as an encryption provider to encrypt the Secrets hosted </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">on etcd.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.479.1">Provisioning KMS</span></h2>
<p><span class="koboSpan" id="kobo.480.1">We shall provision a</span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.481.1"> KMS key </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">using Terraform:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.483.1">
resource "aws_kms_key" "ksm_kms_key" {
Â Â descriptionÂ Â Â Â Â Â Â Â Â Â Â Â Â = "ksm_kms_key"
Â Â deletion_window_in_days = 30
Â Â enable_key_rotationÂ Â Â Â Â = true
}</span></pre> <p><span class="koboSpan" id="kobo.484.1">That key is </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.485.1">now ready to be used standalone or with other </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">AWS components.</span></span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.487.1">Using KMS with EKS</span></h2>
<p><span class="koboSpan" id="kobo.488.1">Having created the</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.489.1"> EKS cluster, we can now specify the credentials that will decrypt </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">the Secrets:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.491.1">
module "ksm_eks" {
Â Â Â Â ...
</span><span class="koboSpan" id="kobo.491.2">Â Â create_kms_key = false
Â Â cluster_encryption_config = {
Â Â Â Â resources = ["secrets"]
Â Â Â Â provider_key_arn = aws_kms_key.ksm_kms_key.arn
Â Â }
Â Â ...
</span><span class="koboSpan" id="kobo.491.3">}</span></pre> <p><span class="koboSpan" id="kobo.492.1">If we try to fetch the credentials from Kubernetes, the Secrets will be decrypted using the KMS we specified. </span><span class="koboSpan" id="kobo.492.2">We can use AWS CloudTrail to identify the usage. </span><span class="koboSpan" id="kobo.492.3">We can access CloudTrail events by following this </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">link: </span></span><a href="https://console.aws.amazon.com/cloudtrail/home?#/events?EventName=Decrypt"><span class="No-Break"><span class="koboSpan" id="kobo.494.1">https://console.aws.amazon.com/cloudtrail/home?#/events?EventName=Decrypt</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.495.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">If we navigate to the </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.497.1">page, the decryption operation will be displayed onscreen. </span><span class="koboSpan" id="kobo.497.2">Also, it will display the user responsible for the decryption operation that took place, which in our case is the role associated with the </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">The information will be in </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">JSON format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.501.1">
{
Â Â Â Â "eventSource": "kms.amazonaws.com",
Â Â Â Â "eventName": "Decrypt",
Â Â Â Â "awsRegion": "eu-west-1",
Â Â Â Â "sourceIPAddress": "secretsmanager.amazonaws.com",
Â Â Â Â "userAgent": "secretsmanager.amazonaws.com",
Â Â Â Â "requestParameters": {
Â Â Â Â Â Â Â Â "encryptionContext": {
Â Â Â Â Â Â Â Â Â Â Â Â "SecretARN": "arn:aws:secretsmanager:eu-west-1:1212222223:secret:service_token-93z7he",
Â Â Â Â Â Â Â Â Â Â Â Â "SecretVersionId": "278A157C-EA85-4211-9854-D329D3C9089F"
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â "encryptionAlgorithm": "SYMMETRIC_DEFAULT"
Â Â Â Â },
Â Â Â Â "resources": [
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â "ARN": "arn:aws:kms:eu-west-1:111111111:key/aaaaaaa-aaaa-458f-b8d1-aefa58b68d8a"
Â Â Â Â Â Â Â Â }
Â Â Â Â ],
Â Â Â Â "eventType": "AwsApiCall",
}</span></pre> <p><span class="koboSpan" id="kobo.502.1">We</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.503.1"> managed to store our Secrets encrypted on </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">etcd</span></strong><span class="koboSpan" id="kobo.505.1"> using AWS KMS. </span><span class="koboSpan" id="kobo.505.2">Our secret residing on etcd will be encrypted and we should be able to monitor any </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">encryption/decryption operations.</span></span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.507.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.508.1">In this chapter, we created a VPC network that spans three availability zones. </span><span class="koboSpan" id="kobo.508.2">On top of that network, we provisioned an EKS cluster. </span><span class="koboSpan" id="kobo.508.3">We managed to integrate the EKS cluster with AWS Secrets Manager. </span><span class="koboSpan" id="kobo.508.4">This was done securely by implementing a fine-grained role on AWS mapped to our Kubernetes workloads. </span><span class="koboSpan" id="kobo.508.5">We then proceeded to identify the operations that took place with regard to the Secrets stored on AWS Secrets Manager by checking CloudWatch and CloudTrail logs. </span><span class="koboSpan" id="kobo.508.6">Lastly, we encrypted the Secrets residing on an EKS cluster by using a managed KMS. </span><span class="koboSpan" id="kobo.508.7">In the next chapter, we shall focus on another popular cloud provider and its secret-handling capabilities: </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">Microsoft Azure.</span></span></p>
</div>
</body></html>