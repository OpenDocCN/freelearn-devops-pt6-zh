- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Strict Confinement for Isolated Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how to build secure containers using Kata
    Containers and how to improve workload isolation with hardware virtualization
    technology. We also discussed the best practices for securing your production-grade
    cluster with containers. The MicroK8s add-on option has also made it easier to
    activate Kata Containers, which can significantly increase the security and isolation
    of your container operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at another approach to isolation using
    snap confinement options to run containers in complete isolation, meaning no access
    to files, networks, processes, or any other system resource without requesting
    specific access via an interface. Confinement models describe how much access
    a particular snap has to a user’s machine. There are currently three choices available,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The *strict* confinement level operates in complete isolation, with access limited
    to a level that is always regarded as safe. As a result, without requesting particular
    access via an interface, strictly limited snaps cannot access your files, network,
    processes, or any other system resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *classic* confinement level is similar to conventional Linux packages and
    can access a system’s resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *devmode* confinement level runs in a limited environment with full access
    to system resources and generates debug output to locate unidentified interfaces.
    This is specifically designed for snap creators and developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we discussed in [*Chapter 2*](B18115_02.xhtml#_idTextAnchor030), *Introducing
    MicroK8s*, MicroK8s is a snap, and we employed the classic confinement model throughout
    this book. The interface of each snap is carefully chosen by the author to enable
    specialized access to a resource in accordance with the snap’s requirements. For
    example, network access, desktop access, and audio access are all provided by
    common interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of Snap, Snapcraft, and Ubuntu Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Ubuntu Core on a Raspberry Pi board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up MicroK8s on Ubuntu Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a sample containerized application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of Snap, Snapcraft, and Ubuntu Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before going into detail about how strict confinement snaps offer isolation
    to applications, we will delve into a little bit of history on how embedded Linux
    development was handled before the advent of snaps.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, getting software to embedded Linux systems has proven difficult.
    There were different Linux packaging formats (RPM, DEB, and so on) and there is
    no standardization of formats. Furthermore, software packages frequently necessitate
    sophisticated code to manage installation and updates that are incompatible with
    one another, have unmet dependencies, or write to the entire system.
  prefs: []
  type: TYPE_NORMAL
- en: Snaps were envisioned to answer the concerns of embedded Linux developers seeking
    a secure environment and precise configuration to run their applications. They
    allow software publishers and developers to manage the binary that is supplied
    and the exact version that their users have access to.
  prefs: []
  type: TYPE_NORMAL
- en: Snaps are easy to create, build, and deploy as compared to standard Linux software
    distribution. Snaps get automatically updated **over the air** (**OTA**) and via
    deltas, keeping the functionality of an embedded Linux device always fresh and
    reducing the risk of breaking. Snaps are compatible with all major Linux distributions
    and may be used on any type of device from desktop to cloud and IoT devices.
  prefs: []
  type: TYPE_NORMAL
- en: Snapcraft ([https://snapcraft.io/](https://snapcraft.io/)) is a framework for
    creating and distributing snaps by bringing together different components of the
    application into a single, cohesive bundle. Developers submit their snaps to a
    central repository known as Snap Store—a universal app store that allows users
    to publish, browse, install, distribute, and deploy apps in the cloud, on desktops,
    and on IoT devices from any Linux distribution.
  prefs: []
  type: TYPE_NORMAL
- en: The Ubuntu Core embedded OS ([https://ubuntu.com/core](https://ubuntu.com/core))
    is built on snaps and is free and open source. In Ubuntu Core, everything is a
    snap. Even the kernel is a snap. In Ubuntu Core, only snaps that use the strict
    confinement model can be installed. It is a cutting-edge new operating system
    (OS) designed from the ground up with zero-trust security in mind. It efficiently
    decouples the base system and OS from the installed apps by containerizing the
    Linux kernel and runtime environments. Containerization allows you to separate
    and provide lockdown functionality, with applications running in a security sandbox
    by default (kernel features such as AppArmor, seccomp, security policies, and
    device permissions are leveraged).
  prefs: []
  type: TYPE_NORMAL
- en: MicroK8s and Ubuntu Core share characteristics including self-healing, high
    availability, automatic OTA updates, reliability, and security. Running MicroK8s
    on Ubuntu Core provides Kubernetes with the benefits of a solid computing foundation.
    Furthermore, combining Ubuntu Core and MicroK8s offers a streamlined, embedded
    Kubernetes experience for IoT and Edge applications, with a small footprint and
    performance efficiency optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will go over the procedures for setting up a Kubernetes
    Raspberry Pi cluster with snap strict confinement.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Ubuntu Core on a Raspberry Pi board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are clear on the snap confinement concepts, we will delve into the
    steps of creating a Kubernetes Raspberry Pi cluster that uses snap strict confinement.
  prefs: []
  type: TYPE_NORMAL
- en: What we are trying to achieve
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll list down the steps that we’re seeking to work through in this section
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an Ubuntu Core image to SD card
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an Ubuntu SSO account
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generating an SSH key pair
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Booting Ubuntu Core on Raspberry Pi
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Raspberry Pi cluster that we will build in this step is depicted in *Figure
    15.1* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – The Raspberry Pi cluster that uses snap strict confinement
    ](img/Figure_15.01_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – The Raspberry Pi cluster that uses snap strict confinement
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what we want to do, let’s look at the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the prerequisites for building the Ubuntu Core Raspberry
    Pi Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: A microSD card (4 GB minimum; 8 GB recommended)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A computer with a microSD card drive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi 2, 3, or 4 (1 or more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A micro-USB power cable (USB-C for the Pi 4)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Wi-Fi network or an Ethernet cable with an internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optional) A monitor with an HDMI interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optional) An HDMI cable for Pi 2 and 3 and a micro-HDMI cable for Pi 4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optional) A USB keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve established the requirements, we’ll move on to the step-by-step
    instructions on how to create a Kubernetes Raspberry Pi cluster that uses snap
    strict confinement.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – Setting up an Ubuntu Core image to an SD card
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to install an Ubuntu Core image to the microSD card. To do
    that, we will be using the **Raspberry Pi Imager tool** to install an OS image
    to a microSD card that can then be used with Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Download and install **Raspberry Pi Imager** from the Raspberry Pi website on
    a computer equipped with an SD card reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'As depicted in *Figure 15.2*, run Raspberry Pi Imager with the microSD card
    and open the **CHOOSE OS** menu as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – Raspberry Pi Imager ](img/Figure_15.02_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2 – Raspberry Pi Imager
  prefs: []
  type: TYPE_NORMAL
- en: 'From the OS menu, choose **Other general purpose OS** from the options listed,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – Raspberry Pi Imager OS options ](img/Figure_15.03_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.3 – Raspberry Pi Imager OS options
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose the **Ubuntu Core** **64-bit version** that works with Raspberry Pi
    2,3, 3, and 4 from the options listed (refer to *Figure 15.4*) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – Choose Ubuntu Core 64-bit version ](img/Figure_15.04_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4 – Choose Ubuntu Core 64-bit version
  prefs: []
  type: TYPE_NORMAL
- en: 'As depicted in *Figure 15.5*, open the **Storage** menu after selecting **Ubuntu
    Core 64-bit image**. Choose the micro SD card that you’ve inserted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – Raspberry Pi Imager write operation ](img/Figure_15.05_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.5 – Raspberry Pi Imager write operation
  prefs: []
  type: TYPE_NORMAL
- en: Finally, click on **Write** to start the operation and Raspberry Pi Imager will
    wipe your micro SD card data; you will be prompted to confirm this procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Post confirmation, Raspberry Pi Imager will start flashing OS images to the
    micro SD card. It will take a while to finish.
  prefs: []
  type: TYPE_NORMAL
- en: Once finished, continue with the creation of an Ubuntu Single Sign-On (SSO)
    account.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Creating an Ubuntu SSO account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Ubuntu **SSO** account needs to be created so that Secure shell (SSH) public
    keys can be stored and linked to an email address. This allows Ubuntu Core devices
    to only permit SSH connections from the devices that have public keys that match
    those in your SSO account.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://login.ubuntu.com/](https://login.ubuntu.com/) and fill in the
    relevant information, and after the SSO account has been created, generate the
    SSH key pair as explained in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – Generating an SSH key pair
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SSH**, as we know, is a popular way to connect to remote Linux servers. The
    authentication process involves the pairing of a private local key with a public
    remote key, which is used to secure communication from your device to Linux servers
    that are hosting the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the free and open source OpenSSH software included in Windows 10, SSH
    keys can be generated. SSH keys can also be generated through the PuTTYgen utility,
    which has support for various platforms. We’re going to use the built-in Windows
    OpenSSH client for the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the PowerShell window, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step asks where you would like to save the key, and you can accept
    the default answer by pressing `Return`, as shown in the command execution output
    in *Figure 15.6*. The passphrase is requested in the second step. When a passphrase
    is entered, it is required to use the passphrase each time the key is accessed.
    The passphrase is optional; pressing `Return` twice will create a key pair without
    requiring a passphrase, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – SSH key generation ](img/Figure_15.06_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.6 – SSH key generation
  prefs: []
  type: TYPE_NORMAL
- en: 'The private key and the public key can be found in the same folder once the
    process is complete, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7 – Private and public keys generated ](img/Figure_15.07_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.7 – Private and public keys generated
  prefs: []
  type: TYPE_NORMAL
- en: We can now use the generated public and private keys for Ubuntu Core installation.
    The following step is to add the public key to an Ubuntu SSO account so that it
    could be used to permit connections from the devices that have public keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Ubuntu SSO account login, under the `ubuntu-core-rpi.pub` (public
    key) file to import the public key as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8 – Import SSH keys ](img/Figure_15.08_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.8 – Import SSH keys
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows that the public key has been imported successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9 – SSH keys imported ](img/Figure_15.09_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.9 – SSH keys imported
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have imported SSH keys to the Ubuntu SSO account, the following
    step is to power Raspberry Pi and boot Ubuntu Core.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – Booting Ubuntu Core on Raspberry Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extract the SD card from your laptop and insert it into Raspberry Pi. Before
    powering the Pi, connect an HDMI screen and a USB keyboard. Power on the Pi and
    you will be able to see the boot process on the screen. It typically takes less
    than 5 minutes to complete the booting process.
  prefs: []
  type: TYPE_NORMAL
- en: When the boot process is complete, you will see instructions for configuring
    the network and creating an administrator account on Ubuntu Core. In this configuration,
    you will be able to configure Wi-Fi settings, and the following step will require
    you to provide the email address associated with your SSO account. Once configured,
    the device will automatically update and, if necessary, restart.
  prefs: []
  type: TYPE_NORMAL
- en: After you provide your email and the Pi connects to your account, you will be
    able to use any SSH client, for example, PuTTY, to connect to your Pi.
  prefs: []
  type: TYPE_NORMAL
- en: '*Success! You are now connected to Ubuntu Core running on your Raspberry Pi.*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve finished configuring the settings and we are ready to go on to the following
    step of installing and configuring the MicroK8s snap with strict confinement.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MicroK8s on Ubuntu Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SSH into your control plane node and install the latest version of the MicroK8s
    snap with strict confinement as in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output after the execution of the preceding command, which
    confirms that the MicroK8s snap with strict confinement was successfully configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10 – Successful MicroK8s snap installation  ](img/Figure_15.10_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.10 – Successful MicroK8s snap installation
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have installed the MicroK8s snap, let’s run the `microk8s status`
    command to verify its running state as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output after the execution of the preceding command, which
    confirms that the MicroK8s snap with strict confinement is running successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11 – MicroK8s snap is running ](img/Figure_15.11_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.11 – MicroK8s snap is running
  prefs: []
  type: TYPE_NORMAL
- en: Strict confinement *locks down* the apps in the snap using Linux kernel security
    capabilities. Access will be extremely constrained for a highly contained application
    without any stated interfaces. MicroK8s running successfully indicates that all
    necessary interfaces are specified and application access requirements are met.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the MicroK8s snap interfaces, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output after the execution of the preceding command, which
    lists interfaces of the MicroK8s snap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12 – MicroK8s snap interfaces ](img/Figure_15.12_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.12 – MicroK8s snap interfaces
  prefs: []
  type: TYPE_NORMAL
- en: In the end, all snaps would need to aim for a strict confinement level, using
    only the APIs required for the application to run properly, and nothing else.
    Additionally, Ubuntu Core necessitates that snaps are on a strict confinement
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about interfaces and confinement in the Snapcraft documentation at
    [https://docs.snapcraft.io](https://docs.snapcraft.io).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have installed MicroK8s, let’s verify whether the node status is
    `Ready` using the `kubectl get nodes` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If the installation is successful, then you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.13 – Verifying whether the node is in a Ready state ](img/Figure_15.13_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.13 – Verifying whether the node is in a Ready state
  prefs: []
  type: TYPE_NORMAL
- en: Since MicroK8s is packaged as a snap, it will automatically upgrade to newer
    point releases. Also, the strictly confined MicroK8s version of the snap is currently
    on a dedicated snap channel that is synchronized with the latest version of upstream
    of Kubernetes, that is, an open source version of Kubernetes managed and maintained
    by the Cloud Native Computing Foundation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on MicroK8s releases, channels are formed of a track (or series) and
    an anticipated level of stability (*stable*, *candidate*, *beta*, and *edge*).
    For more information about releases and channels, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output after the execution of the preceding command, which
    shows the list of channels (*stable*, *candidate*, *beta*, and *edge*) and their
    release dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.14 – MicroK8s list of channels (stable, candidate, beta, and edge)
    and the release dates ](img/Figure_15.14_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.14 – MicroK8s list of channels (stable, candidate, beta, and edge)
    and the release dates
  prefs: []
  type: TYPE_NORMAL
- en: Repeat the MicroK8s installation process on the other nodes as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the command for the MicroK8s installation on the worker node
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15 – Successful MicroK8s snap installation on the worker1 node  ](img/Figure_15.15_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.15 – Successful MicroK8s snap installation on the worker1 node
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `microk8s status` command execution output confirms that MicroK8s
    is running successfully on the worker node as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.16 – Verifying whether MicroK8s is running ](img/Figure_15.16_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.16 – Verifying whether MicroK8s is running
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that MicroK8s is running, the following step is to check whether the `kubectl
    get nodes` command displays the node in a `Ready` state as indicated in the command
    execution output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.17 – Verifying whether the node is in a Ready state ](img/Figure_15.17_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.17 – Verifying whether the node is in a Ready state
  prefs: []
  type: TYPE_NORMAL
- en: 'We have completed the installation of MicroK8s on all boards. The following
    step is to add the worker node to the control plane node. Open the PuTTY shell
    to the control plane node and run the following command to generate the connection
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output after the execution of the preceding command. It
    validates that the command was successfully executed and provides instructions
    for generating the connection string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.18 – Generating the connection string for adding nodes ](img/Figure_15.18_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.18 – Generating the connection string for adding nodes
  prefs: []
  type: TYPE_NORMAL
- en: As indicated by the preceding command execution output, the connection string
    is generated in the form of `<control plane_ip>:<port>/<token>`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the worker node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have the connection string to join with the control plane node. Open
    the PuTTY shell to the worker node and run the `join` command to add it to the
    cluster, as can be seen in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The command was successfully executed, and the node has joined the cluster,
    as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.19 – Add worker#1 node to the cluster ](img/Figure_15.19_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.19 – Add worker#1 node to the cluster
  prefs: []
  type: TYPE_NORMAL
- en: As indicated by the command execution output shown in *Figure 15.19*, you should
    be able to see the new node in a few seconds on the control plane node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to verify whether the new node is added to the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output shows that the control plane and `worker1`
    nodes are part of the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.20 – The cluster is ready and the control plane and worker1 nodes
    are part of the cluster ](img/Figure_15.20_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.20 – The cluster is ready and the control plane and worker1 nodes
    are part of the cluster
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have a fully functional multi-node Kubernetes cluster with
    strict confinement enabled. To summarize, we have installed the MicroK8s snap
    on the Raspberry Pi boards running Ubuntu Core and joined multiple deployments
    to form the cluster. We’ve seen how to add nodes to the cluster as well. In the
    following section, we are going to deploy a sample application on the MicroK8s
    cluster that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a sample containerized application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be deploying one of the nginx deployments from the
    Kubernetes examples repository on our MicroK8s cluster setup, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output after the execution of the preceding command. It
    indicates that there is no error in the deployment, and in the following steps,
    we can verify whether the deployment is successful using the `get pods` command
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.21 – Sample application deployment ](img/Figure_15.21_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.21 – Sample application deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the status of the pods to verify whether the application has been deployed
    and is running as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output after the execution of the preceding command, which
    indicates that pods are created and that their status is `Running`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.22 – Checking whether pods have a Running status ](img/Figure_15.22_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.22 – Checking whether pods have a Running status
  prefs: []
  type: TYPE_NORMAL
- en: '*Great! We have just deployed and examined our sample application deployment
    on the Raspberry multi-node cluster running Ubuntu Core.*'
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, embedded Linux development utilizing snaps, Snapcraft, and Ubuntu
    Core is a lot quicker, safer, and more reliable than the current options available
    in the market. As it can package, distribute, and update any app through the global
    Snap Store, Snapcraft makes it simpler to find new software for your embedded
    devices. Additionally, the application updates either completely succeed or are
    not deployed at all. During both application and system updates, your embedded
    device running Ubuntu Core stays fully functional.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to install the MicroK8s snap with the strict
    confinement option, monitored the installation’s progress, and managed the Kubernetes
    cluster running on Ubuntu Core. We also deployed a sample application and examined
    whether the application is able to run on a strict confinement-enabled Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: We also introduced a new embedded OS, Ubuntu Core, which complies with enterprise
    standards by enabling automated updates, app stores, and software management.
    We also learned that it is built from the ground up to be the most secure platform
    for connected devices. Furthermore, Ubuntu Core provides a modular design based
    on snaps, bullet-proof application updates, a seamless developer experience via
    Snapcraft, and built-in security to handle the challenges of embedded Linux development.
  prefs: []
  type: TYPE_NORMAL
- en: In this and earlier chapters, we have covered most of the implementation aspects
    that are required for your IoT/Edge computing applications using MicroK8s in detail;
    this includes running your applications on a multi-node Raspberry Pi cluster,
    configuring load balancing mechanisms, installing/configuring different CNI plugins
    for network connectivity, configuring logging, monitoring, and alerting options
    for your cluster, and building/deploying machine learning models and serverless
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we have looked at setting up storage replication for your stateful
    applications, implementing a service mesh for your cross-cutting concerns, setting
    up a high-availability cluster to withstand component failure and continue to
    serve workloads without interruption, configuring containers with workload isolation,
    and running secured containers with isolation from a host system. In the following
    chapter, we’ll look at how MicroK8s is uniquely positioned for accelerating IoT
    and Edge deployments and also key trends that are shaping up our new future.
  prefs: []
  type: TYPE_NORMAL
