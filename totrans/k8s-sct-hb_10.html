<html><head></head><body>
<div id="_idContainer047">
<h1 class="chapter-number" id="_idParaDest-182"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-183"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.2.1">Exploring Cloud Secret Store on GCP</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Previously, we did a deep dive into Azure Key Vault. </span><span class="koboSpan" id="kobo.3.2">We managed to store Secrets securely on Key Vault and utilized it as a key management service for the Secrets that will reside on etcd. </span><span class="koboSpan" id="kobo.3.3">In this chapter, we will focus on the Google Cloud Platform and will utilize the Secret Manager of </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">Google Cloud.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We will be covering the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Overview of GCP </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">Secret Manager</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Workload Identity </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">on GKS</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">GKE and GCP Secret </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Manager integration</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Auditing </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">and logging</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">GKE and </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">KMS integration</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">By the end of this chapter, we should be able to store our Secrets to GCP Secret Manager securely, monitor secret access through auditing, and add an extra layer of security by encrypting the Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">on etcd.</span></span></p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">To link concepts with hands-on examples, we are leveraging a series of tools and platforms commonly used to interact with the Google Cloud API </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">and Kubernetes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.22.1">gcloud CLI</span></strong><span class="koboSpan" id="kobo.23.1"> (</span><a href="https://cloud.google.com/sdk/gcloud#download_and_install_the"><span class="koboSpan" id="kobo.24.1">https://cloud.google.com/sdk/gcloud#download_and_install_the</span></a><span class="koboSpan" id="kobo.25.1">) is a set of tools to </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.26.1">create and manage Google </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Cloud resources</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.28.1">Terraform</span></strong><span class="koboSpan" id="kobo.29.1"> (</span><a href="https://www.terraform.io/"><span class="koboSpan" id="kobo.30.1">https://www.terraform.io/</span></a><span class="koboSpan" id="kobo.31.1">) is infrastructure-as-code software that can be used to </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.32.1">provision and manage infrastructure on </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">the cloud</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.34.1">kubectl</span></strong><span class="koboSpan" id="kobo.35.1"> (</span><a href="https://kubernetes.io/docs/reference/kubectl/"><span class="koboSpan" id="kobo.36.1">https://kubernetes.io/docs/reference/kubectl/</span></a><span class="koboSpan" id="kobo.37.1">) is the command-line tool used for communicating</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.38.1"> with a Kubernetes cluster through the </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">Kubernetes API</span></span></li>
</ul>
<h1 id="_idParaDest-185"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.40.1">Overview of GCP Secret Manager</span></h1>
<p><span class="koboSpan" id="kobo.41.1">GCP Secret Manager</span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.42.1"> is the secret manager solution provided by Google Cloud. </span><span class="koboSpan" id="kobo.42.2">Provided that we have an application that has the need to store Secrets, the Secret Manager can be utilized. </span><span class="koboSpan" id="kobo.42.3">The application can be deployed on Compute Engine, Kubernetes, Cloud Functions, or any other legitimate form of deployment on </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">Google Cloud.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Since this service is managed by Google Cloud, there are some features offered by default. </span><span class="koboSpan" id="kobo.44.2">We can summarize them </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.46.1">IAM</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.47.1">High availability</span></span></li>
<li><span class="koboSpan" id="kobo.48.1">Logging </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">and auditing</span></span></li>
<li><span class="koboSpan" id="kobo.50.1">Integration with other Google </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">Cloud components</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.52.1">Let’s have a deep dive into </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">each one.</span></span></p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.54.1">IAM</span></h2>
<p><span class="koboSpan" id="kobo.55.1">Google Cloud </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.56.1">comes with </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">identity access management</span></strong><span class="koboSpan" id="kobo.58.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.59.1">IAM</span></strong><span class="koboSpan" id="kobo.60.1">). </span><span class="koboSpan" id="kobo.60.2">Certain IAM permissions take effect on an </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.61.1">organizational level, allowing us to manage an organization’s resources. </span><span class="koboSpan" id="kobo.61.2">Then we have IAM permissions that apply project-wide, thus they are permissions assigned to target specific resources throughout a GCP project. </span><span class="koboSpan" id="kobo.61.3">The most granular level is resource-based IAM permissions. </span><span class="koboSpan" id="kobo.61.4">When we create a resource, we can have permissions only for that specific resource. </span><span class="koboSpan" id="kobo.61.5">The identities can be either users, Google Groups, or service accounts. </span><span class="koboSpan" id="kobo.61.6">Permissions for a specific resource can be assigned to a </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">specific identity.</span></span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.63.1">High availability</span></h2>
<p><span class="koboSpan" id="kobo.64.1">Secret Manager is a </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.65.1">highly available solution and covers disaster recovery scenarios. </span><span class="koboSpan" id="kobo.65.2">By default, the Secrets can be accessed globally from different regions of Google Cloud. </span><span class="koboSpan" id="kobo.65.3">Behind the scenes, the Secrets are replicated in multiple regions unless specified otherwise. </span><span class="koboSpan" id="kobo.65.4">A reason to specify the regions is data residency limitations. </span><span class="koboSpan" id="kobo.65.5">If a secret cannot be stored in a certain region, we can define the regions we want the secret to be stored in and exclude any regions that should not contain any of </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">our data.</span></span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.67.1">Logging, auditing, and monitoring</span></h2>
<p><span class="koboSpan" id="kobo.68.1">Google Cloud has, by default, a logging</span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.69.1"> solution that is used for application logs but also for audit</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.70.1"> logs. </span><span class="koboSpan" id="kobo.70.2">There is a distinction between </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.71.1">application logs and audit logs. </span><span class="koboSpan" id="kobo.71.2">To be able to access audit logs on a GCP project, you need to have the Private Logs </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">Viewer permission.</span></span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.73.1">Integration with other Google Cloud components</span></h2>
<p><span class="koboSpan" id="kobo.74.1">As expected, Secret Manager</span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.75.1"> is integrated with other Google </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">Cloud components.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">We can use</span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.78.1"> a </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">key management service</span></strong><span class="koboSpan" id="kobo.80.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.81.1">KMS</span></strong><span class="koboSpan" id="kobo.82.1">) to encrypt the Secrets on Secret Manager and we can integrate Secret Manager with Kubernetes. </span><span class="koboSpan" id="kobo.82.2">As we have seen in </span><a href="B20970_08.xhtml#_idTextAnchor157"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.83.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.84.1">, </span><em class="italic"><span class="koboSpan" id="kobo.85.1">Exploring Cloud Secret Store on AWS</span></em><span class="koboSpan" id="kobo.86.1">, the integration with Secret Manager on Kubernetes happens through the </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">CSI plugin.</span></span></p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.88.1">Introduction to Workload Identity</span></h1>
<p><span class="koboSpan" id="kobo.89.1">Workload Identity on </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.90.1">Kubernetes Engine on GCP enables us to assign permissions to Kubernetes workloads that can interact with Google Cloud resources. </span><span class="koboSpan" id="kobo.90.2">Google Cloud has the concept of service accounts. </span><span class="koboSpan" id="kobo.90.3">Service accounts are used for machines to interact with resources. </span><span class="koboSpan" id="kobo.90.4">A compute engine, a lambda function, or even an App Engine on Google Cloud can be assigned with a service account that has permissions to interact with Google Cloud resources. </span><span class="koboSpan" id="kobo.90.5">With Workload Identity, we can map service accounts on GCP with service accounts </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">on Kubernetes.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">In Kubernetes, we might use several types of deployments for our applications. </span><span class="koboSpan" id="kobo.92.2">We can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">Deployment</span></strong><span class="koboSpan" id="kobo.94.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">StatefulSet</span></strong><span class="koboSpan" id="kobo.96.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">DaemonSet</span></strong><span class="koboSpan" id="kobo.98.1">, and more. </span><span class="koboSpan" id="kobo.98.2">Behind the scenes, a Pod will be created, which is the base component for running applications on Kubernetes. </span><span class="koboSpan" id="kobo.98.3">The Pod can be assigned a service account. </span><span class="koboSpan" id="kobo.98.4">By using Workload Identity on Kubernetes and binding a Kubernetes service account to a Google Cloud service account, the Pod with the Kubernetes service account attached shall be able to interact with Google Cloud resources based on the permissions we granted on the GCP </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">service account.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">Therefore, this</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.101.1"> concept will help us with GCP Secret Manager. </span><span class="koboSpan" id="kobo.101.2">The access from our Kubernetes workload to Secret Manager will be authorized and feasible, thanks to the integration of Kubernetes CSI and the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">Workload Identity.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">Now that we understand how Kubernetes and Secret Manager on Google Cloud work together, we will focus on implementing a </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">Kubernetes cluster.</span></span></p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.105.1">Integrating GKE and GCP Secret Manager</span></h1>
<p><span class="koboSpan" id="kobo.106.1">Thanks to the </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.107.1">CSI Secret Store plugins, we can integrate Secret Manager solutions with our Kubernetes cluster. </span><span class="koboSpan" id="kobo.107.2">The Kubernetes offering on Google Cloud is the Google Kubernetes engine. </span><span class="koboSpan" id="kobo.107.3">We will use this Kubernetes cluster offering to integrate with </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">Secret Manager.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">There are several options to create a cluster. </span><span class="koboSpan" id="kobo.109.2">We will provide the Terraform code for the scope of creating the cluster. </span><span class="koboSpan" id="kobo.109.3">Also, we will provide other </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">commands needed.</span></span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.111.1">Configuring the Terraform project</span></h2>
<p><span class="koboSpan" id="kobo.112.1">We need to </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.113.1">configure the Terraform provider. </span><span class="koboSpan" id="kobo.113.2">It will point to the GCP credentials file and also to the GCP project and </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">the region.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">The provider configuration should be </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.117.1">
provider "google" {
  credentials = "/path/to/credentials/file"
  project     = "your-gcp-project"
  region      = "us-central1"
}</span></pre> <p><span class="koboSpan" id="kobo.118.1">To initialize, we need to run the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">init</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.120.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.121.1">
$ terraform init</span></pre> <p><span class="koboSpan" id="kobo.122.1">When we</span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.123.1"> run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">init</span></strong><span class="koboSpan" id="kobo.125.1"> command when a credentials file is not specified, the credentials by default will be the credentials of the user who logged in when we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">gcloud auth login</span></strong><span class="koboSpan" id="kobo.127.1"> command. </span><span class="koboSpan" id="kobo.127.2">Alternatively, we can specify a service </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">account file.</span></span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.129.1">Provisioning the network</span></h2>
<p><span class="koboSpan" id="kobo.130.1">We shall proceed with provisioning the</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.131.1"> network. </span><span class="koboSpan" id="kobo.131.2">On Google Cloud, a network is a global resource, whereas the subnets of a network are </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">regional resources.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">We will create the network, and as expected, no region will be specified since VPC is a </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">global resource:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.135.1">
resource "google_compute_network" "vpc" {
  name                    = "${var.project_id}-vpc"
  auto_create_subnetworks = "false"
  project = var.project_id
}</span></pre> <p><span class="koboSpan" id="kobo.136.1">The subnetwork will be created to host the nodes on Kubernetes. </span><span class="koboSpan" id="kobo.136.2">It will be mapped to the </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">region specified:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.138.1">
resource "google_compute_subnetwork" "subnet" {
  name          = "${var.project_id}-subnet"
  region        = var.region
  network       = google_compute_network.vpc.name
  ip_cidr_range = "10.10.0.0/24"
  project = var.project_id
}</span></pre> <p><span class="koboSpan" id="kobo.139.1">We can now focus on creating Secrets on </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">Secret Manager.</span></span></p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.141.1">Provisioning a secret on Secret Manager</span></h2>
<p><span class="koboSpan" id="kobo.142.1">GCP Secret Manager is a</span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.143.1"> service; to use Secret Manager on GCP, we do not need to create a resource. </span><span class="koboSpan" id="kobo.143.2">Instead, we create the Secrets that will be hosted on </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">Secret Manager.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">We will get started by provisioning </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">a secret:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.147.1">
resource "google_secret_manager_secret" "my_secret" {
  secret_id = "my-secret"
  user_managed {
      replicas {
        location = var.location
      }
      replicas {
        location = "us-east1"
      }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.148.1">We purposefully specified the region where the replicas will reside. </span><span class="koboSpan" id="kobo.148.2">The secret will be hosted in two regions, making our secret usage resilient, even during a </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">region outage.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">We created the secret, but we did not assign a specific value. </span><span class="koboSpan" id="kobo.150.2">For a secret, we specify a version of that secret. </span><span class="koboSpan" id="kobo.150.3">Let us proceed with adding </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">the version:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
resource "google_secret_manager_secret_version" "my_secret_version" {
  secret = google_secret_manager_secret.my_secret.id
  secret_data = "secret-data"
}</span></pre> <p><span class="koboSpan" id="kobo.153.1">Also, we would like to </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.154.1">provision a service account with permissions to retrieve </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">the secret:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.156.1">
resource "google_service_account" "my_service_account" {
  account_id   = "read-secrets-service-account"
}
resource "google_secret_manager_secret_iam_binding" "my_secret_reader" {
  role   = "roles/secretmanager.secretAccessor"
  secret_id = google_secret_manager_secret.my_secret.id
  members = [
    "serviceAccount:${google_service_account.my_service_account.email}"
  ]
}</span></pre> <p><span class="koboSpan" id="kobo.157.1">The secret is provisioned, and we have a service account to be used </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">for retrieval.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">Now, let’s go ahead and create the </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">GKE cluster.</span></span></p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.161.1">Provisioning the GKE cluster</span></h2>
<p><span class="koboSpan" id="kobo.162.1">To create the GKE cluster we need to </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.163.1">create the master, and we will also create a default </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">node pool:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.165.1">
resource "google_container_cluster" "gke_cluster" {
  name     = "secrets-cluster"
  location = var.region
  remove_default_node_pool = true
  initial_node_count       = 1
  network    = google_compute_network.vpc.name
  subnetwork = google_compute_subnetwork.subnet.name
  ...
</span><span class="koboSpan" id="kobo.165.2">  workload_identity_config {
    workload_pool = "kube-secrets-book.svc.id.goog"
  }
}</span></pre> <p><span class="koboSpan" id="kobo.166.1">When creating a cluster, GKE forces us to create an initial node pool by default. </span><span class="koboSpan" id="kobo.166.2">We can create another node pool of our choice using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">google_container_node_pool</span></strong><span class="koboSpan" id="kobo.168.1"> resource. </span><span class="koboSpan" id="kobo.168.2">This way, we can tune more parameters of a GKE node pool in Terraform and separate the cluster and the node pool definitions. </span><span class="koboSpan" id="kobo.168.3">Once the new node pool is created, provided we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">remove_default_node_pool</span></strong><span class="koboSpan" id="kobo.170.1"> setting set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">true</span></strong><span class="koboSpan" id="kobo.172.1">, Terraform will remove the initial node pool. </span><span class="koboSpan" id="kobo.172.2">This will keep the costs low since only one node pool will </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">be operational.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">The primary node pool</span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.175.1"> will be targeted toward keeping the </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">costs low:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.177.1">
resource "google_container_node_pool" "primary_nodes" {
  name       = google_container_cluster.gke_cluster.name
  cluster    = google_container_cluster.gke_cluster.name
  version = data.google_container_engine_versions.gke_version.release_channel_latest_version["STABLE"]
  node_count = 1
  node_config {
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
    ]
    machine_type = "n1-standard-1"
    tags         = ["gke-node", "${var.project_id}-gke"]
    disk_size_gb = 10
    metadata = {
      disable-legacy-endpoints = "true"
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.178.1">We have been successful in </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.179.1">creating the cluster. </span><span class="koboSpan" id="kobo.179.2">We can also log in to the cluster and issue some </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">kubectl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.181.1"> commands:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.182.1">
$ gcloud container clusters get-credentials secrets-cluster --region us-central1 --project kube-secrets-book
$ kubectl get node
NAME                    STATUS   ROLES    AGE     VERSION
gke-secrets-cluster-secrets-cluster-9e54b21e-5kxw   Ready    &lt;none&gt;   9m41s   v1.27.3-gke.1700
gke-secrets-cluster-secrets-cluster-b969915f-rfjz   Ready    &lt;none&gt;   9m35s   v1.27.3-gke.1700
...</span></pre> <p><span class="koboSpan" id="kobo.183.1">Our GKE cluster is operational and ready to serve </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">our workloads.</span></span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.185.1">Adding the CSI plugin for Kubernetes Secrets</span></h2>
<p><span class="koboSpan" id="kobo.186.1">We have an </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.187.1">operational cluster; therefore, we will focus on setting up the CSI plugin. </span><span class="koboSpan" id="kobo.187.2">On a standard GKE cluster, the CSI plugin has to be installed. </span><span class="koboSpan" id="kobo.187.3">When it comes to GKE Autopilot, a GKE version that manages many aspects of Kubernetes out-of-the-box, the CSI plugin is installed </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">by default.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">Take note that the CSI plugin is not officially supported </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">by Google.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">First, we need to </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.192.1">install the plugin to </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">the cluster:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.194.1">
$ helm repo add secrets-store-csi-driver https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts
$ helm install csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver --namespace kube-system
$ kubectl apply -f https://raw.githubusercontent.com/GoogleCloudPlatform/secrets-store-csi-driver-provider-gcp/main/deploy/provider-gcp-plugin.yaml</span></pre> <p><span class="koboSpan" id="kobo.195.1">Then we should create a service account. </span><span class="koboSpan" id="kobo.195.2">The Kubernetes service account will be annotated with the ID of the GCP service account that we want our workloads </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">to use:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.197.1">
$ kubectl create serviceaccount read-secret --namespace=default
$ kubectl annotate serviceaccount read-secret \
    --namespace=default \
    iam.gke.io/gcp-service-account=read-secrets-service-account@test-gcp-project.iam.gserviceaccount.com</span></pre> <p><span class="koboSpan" id="kobo.198.1">This way, the service account of Kubernetes will act on behalf of the service account we created previously. </span><span class="koboSpan" id="kobo.198.2">The service account is able to retrieve the Secrets from </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">Secret Manager.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">SecretProviderClass</span></strong><span class="koboSpan" id="kobo.201.1"> is a custom resource type providing driver configurations and parameters to the CSI driver. </span><span class="koboSpan" id="kobo.201.2">We shall </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">specify </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">SecretProviderClass</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.205.1">
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: app-secrets
spec:
  provider: gcp
  parameters:
    secrets: |
      - resourceName: "projects/project-i/secrets/my-secret/versions/latest"
        path: "good1.txt"</span></pre> <p><span class="koboSpan" id="kobo.206.1">The last step is </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.207.1">to create a Pod. </span><span class="koboSpan" id="kobo.207.2">The Pod will use the Workload Identity and act on behalf of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">read-secrets-service-account</span></strong><span class="koboSpan" id="kobo.209.1"> GCP account. </span><span class="koboSpan" id="kobo.209.2">Also, the Pod will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">SecretProviderClass</span></strong><span class="koboSpan" id="kobo.211.1"> we created previously and mount the Secrets to the Pod as </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">a file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.213.1">
apiVersion: v1
kind: Pod
metadata:
...
</span><span class="koboSpan" id="kobo.213.2">spec:
  serviceAccountName: mypodserviceaccount
  containers:
  - ...
</span><span class="koboSpan" id="kobo.213.3">    volumeMounts:
      - mountPath: "/var/secrets"
        name: mysecret
  volumes:
  - name: mysecret
    csi:
      driver: secrets-store.csi.k8s.io
      readOnly: true
      volumeAttributes:
        secretProviderClass: "app-secrets"</span></pre> <p><span class="koboSpan" id="kobo.214.1">What we have </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.215.1">achieved is to mount the secret to the Pod using the CSI plugin. </span><span class="koboSpan" id="kobo.215.2">We can now focus on monitoring the usage of Secrets. </span><span class="koboSpan" id="kobo.215.3">Auditing and logging play a crucial role in identifying operations on a cloud resource </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">or Kubernetes.</span></span></p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.217.1">Auditing and logging</span></h1>
<p><span class="koboSpan" id="kobo.218.1">Google </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.219.1">Cloud comes with logging</span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.220.1"> and auditing out-of-the-box. </span><span class="koboSpan" id="kobo.220.2">Once we provision a Kubernetes cluster, all the operations will be visible through the </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">logging console.</span></span></p>
<p><span class="koboSpan" id="kobo.222.1">Suppose we create a secret on the cluster we </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">provisioned previously:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.224.1">
$ kubectl create secret generic empty-secret</span></pre> <p><span class="koboSpan" id="kobo.225.1">This action will be logged on the audit logs of GKE, and all we must do is search the logging console on GCP using the </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">following query:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
protoPayload.methodName="io.k8s.core.v1.secrets.create"
protoPayload.@type="type.googleapis.com/google.cloud.audit.AuditLog"
resource.type="k8s_cluster"</span></pre> <p><span class="koboSpan" id="kobo.228.1">As a result, we should see all the operations upon </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">accessing Secrets:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.230.1"><img alt="Figure 10.1 – Kubernetes audit logs on GKE" src="image/B20970_10_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.231.1">Figure 10.1 – Kubernetes audit logs on GKE</span></p>
<p><span class="koboSpan" id="kobo.232.1">Apart from audit </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.233.1">logs on Kubernetes, we can also utilize the audit logs on Secret Manager. </span><span class="koboSpan" id="kobo.233.2">On the </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.234.1">logging screen of GCP, we can search specifically for </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">audit logs:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.236.1">
resource.type="audited_resource" AND
resource.labels.service="secretmanager.googleapis.com"</span></pre> <p><span class="koboSpan" id="kobo.237.1">This GCP log query filter will enable us to see the logs related to </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">Secret Manager.</span></span></p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.239.1">GKE security posture dashboard</span></h2>
<p><span class="koboSpan" id="kobo.240.1">Another notable tool provided </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.241.1">by GCP to improve the security posture of a GKE cluster is the </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">GKE security posture</span></strong><span class="koboSpan" id="kobo.243.1"> dashboard. </span><span class="koboSpan" id="kobo.243.2">The GKE security posture dashboard is a set of features in the Google Cloud console scanning GKE clusters and workloads, offering opinionated, </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">actionable recommendations.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">GKE security posture focuses on </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">two sections:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.247.1">Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">security posture</span></span></li>
<li><span class="koboSpan" id="kobo.249.1">Workload </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">vulnerability scanning</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.251.1">Through the </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.252.1">Kubernetes security posture dashboard, when a vulnerability is discovered, it is automatically displayed on the dashboard with the clusters and workloads affected in order to enable us to proceed with </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">further actions:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.254.1"><img alt="Figure 10.2 – GKE security posture" src="image/B20970_10_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.255.1">Figure 10.2 – GKE security posture</span></p>
<p><span class="koboSpan" id="kobo.256.1">Through workload vulnerability scanning, the container images running in the clusters are scanned for vulnerabilities. </span><span class="koboSpan" id="kobo.256.2">Also, there is support for scanning the actual programming language packages for vulnerabilities, making the workloads even </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">more secure.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">As expected, the findings of the GKE security posture are integrated with other cloud components such as logging and monitoring, thus making it feasible to have alerts and enable automation</span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.259.1"> when it comes to tackling any </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">security incidents.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">Now that auditing and logging are in place, we can proceed with the more advanced concept of encrypting Secrets by integrating GKE </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">and KMS.</span></span></p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.263.1">Integrating GKE and KMS</span></h1>
<p><span class="koboSpan" id="kobo.264.1">It is feasible to use </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.265.1">KMS to encrypt the Secrets on the Google Kubernetes Container Engine. </span><span class="koboSpan" id="kobo.265.2">By default, GKE will encrypt data at rest, and the encryption is managed by GCP. </span><span class="koboSpan" id="kobo.265.3">Apart from this secure handling of our data, we might want to have more control over the encryption of the data. </span><span class="koboSpan" id="kobo.265.4">In this case, we have the option to encrypt the data residing on Kubernetes by using a KMS key that we provision and maintain in our GCP project. </span><span class="koboSpan" id="kobo.265.5">We shall start by provisioning the </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">KMS key:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.267.1">
resource "google_kms_key_ring" "ksm_key_ring" {
  name     = "ksm-key-ring"
  location = var.region
}
resource "google_kms_crypto_key" "ksm_secret_key" {
  name = "ksm-secret-encryption"
  key_ring = google_kms_key_ring.ksm_key_ring.id
  lifecycle {
    prevent_destroy = false
  }
}</span></pre> <p><span class="koboSpan" id="kobo.268.1">We should also assign permissions in order for the Kubernetes service account to be able to perform encryption and decryption. </span><span class="koboSpan" id="kobo.268.2">Take note that on GKE, the master is managed by GCP, and the service account that the master nodes use is not a service account residing on our Google Cloud project, thus we need to assign permission to a service account that is not part of </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">our project:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.270.1">
data "google_project" "project" {}
resource "google_kms_crypto_key_iam_binding" "ksm_secret_key_encdec" {
  crypto_key_id = google_kms_crypto_key.ksm_secret_key.id
  role          = "roles/cloudkms.cryptoKeyEncrypterDecrypter"
  members = [
 "serviceAccount:service-${data.google_project.project.number}@container-engine-robot.iam.gserviceaccount.com"
  ]
}</span></pre> <p><span class="koboSpan" id="kobo.271.1">We just created the</span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.272.1"> KMS. </span><span class="koboSpan" id="kobo.272.2">In our cluster configuration, let’s enable the database </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">encryption option:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.274.1">
resource "google_container_cluster" "gke_cluster" {
  name     = "secrets-cluster"
  location = var.region
...
</span><span class="koboSpan" id="kobo.274.2">  database_encryption {
    key_name = google_kms_crypto_key.ksm_secret_key.id
    state = "ENCRYPTED"
  }
 }</span></pre> <p><span class="koboSpan" id="kobo.275.1">Instead of GCP using its own KMS key, we supply </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.276.1">our own </span><strong class="bold"><span class="koboSpan" id="kobo.277.1">customer-managed key</span></strong><span class="koboSpan" id="kobo.278.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.279.1">CMK</span></strong><span class="koboSpan" id="kobo.280.1">). </span><span class="koboSpan" id="kobo.280.2">Our Secrets on Kubernetes will be encrypted by using the KMS key </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">we provided.</span></span></p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.282.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.283.1">In this chapter, we had a deep dive into Secrets management on Google Cloud and GKE. </span><span class="koboSpan" id="kobo.283.2">We learned about Secret Manager, the GCP offering for Secrets management, and the features that come with it such as availability, auditing, and integration with other Google Cloud components. </span><span class="koboSpan" id="kobo.283.3">We then proceeded to provision a Kubernetes Engine on GCP using the GKE offering and integrated it with Secret Manager. </span><span class="koboSpan" id="kobo.283.4">Then we used KMS to encrypt the Secrets on Kubernetes at rest. </span><span class="koboSpan" id="kobo.283.5">Finally, by using Google Cloud monitoring, we managed to keep track of the secret operations on Kubernetes, Secret Manager, and the KMS. </span><span class="koboSpan" id="kobo.283.6">In the next chapter, we will focus on the non-cloud-based secret managers: HashiCorp Vault and </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">CyberArk Conjur.</span></span></p>
</div>
</body></html>