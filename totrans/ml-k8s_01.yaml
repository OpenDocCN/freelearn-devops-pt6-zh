- en: '*Chapter 3*: Exploring Kubernetes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*: 探索 Kubernetes'
- en: Now that you have seen that Kubernetes will form the basis of your `minikube`
    instance either in your local machine or in the cloud. This is a single-node Kubernetes
    cluster that you will use as the base infrastructure to build and run the ML platform.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到，Kubernetes 将成为你在本地计算机或云端的 `minikube` 实例的基础。这个是一个单节点的 Kubernetes 集群，你将使用它作为构建和运行
    ML 平台的基础设施。
- en: 'In this particular order, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下顺序覆盖以下主题：
- en: Exploring Kubernetes major components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Kubernetes 的主要组件
- en: Becoming cloud-agnostic through Kubernetes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Kubernetes 实现云中立性
- en: Understanding Operators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解操作符（Operators）
- en: Setting up your local Kubernetes environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置本地 Kubernetes 环境
- en: (Optional) Provisioning a **virtual machine** (**VM**) on **google cloud platform**
    (**GCP**)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可选）在**谷歌云平台**（**GCP**）上配置**虚拟机**（**VM**）
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter includes some hands-on setup. You will be setting up a Kubernetes
    cluster, and for this, you will need a machine with the following hardware specifications:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括一些动手操作。你将设置一个 Kubernetes 集群，为此，你需要一台符合以下硬件规格的机器：
- en: A **central processing unit** (**CPU**) with at least four cores; eight are
    recommended
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少四个核心的**中央处理单元**（**CPU**）；推荐八个核心
- en: Memory of at least 16 **gigabytes** (**GB**); 32 GB is recommended
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少 16 **吉字节**（**GB**）的内存；推荐 32 GB
- en: Disk with available space of at least 60 GB
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少 60 GB 可用空间的磁盘
- en: This can be a physical machine such as a laptop, a server, or a VM running in
    the cloud that supports nested virtualization.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是物理机器，如笔记本电脑、服务器，或者是支持嵌套虚拟化的云端虚拟机（VM）。
- en: Exploring Kubernetes major components
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Kubernetes 主要组件
- en: There are many definitions of Kubernetes available on the web. We assume that,
    as a Kubernetes user, you already have a favorite pick. Therefore, in this section,
    you will see some basic concepts to refresh your Kubernetes knowledge. This section
    is by no means a reference or tutorial for the Kubernetes system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上有许多 Kubernetes 的定义。我们假设，作为 Kubernetes 用户，你已经有了自己偏好的定义。因此，在本节中，你将看到一些基本概念来刷新你对
    Kubernetes 的知识。本节绝不是 Kubernetes 系统的参考资料或教程。
- en: 'From [*Chapter 2*](B18332_02_ePub.xhtml#_idTextAnchor027), *Understanding MLOps*,
    you have seen that Kubernetes provides the means for your ML platform to perform
    the following capabilities:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*第二章*](B18332_02_ePub.xhtml#_idTextAnchor027)，《理解 MLOps》中，你已经看到 Kubernetes
    为你的 ML 平台提供了以下能力：
- en: '**Provide a declarative style of running software components**: This capability
    will help your teams to be autonomous.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供声明式的软件组件运行方式**：这一能力将帮助你的团队实现自主性。'
- en: '**Provide an abstraction layer for hardware resources**: Through this capability,
    you can run your ML platform on a variety of hardware and provide on-demand resource
    scheduling.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供硬件资源的抽象层**：通过这个能力，你可以在各种硬件上运行 ML 平台，并提供按需的资源调度。'
- en: '**Provide an application programming interface (API) to interact with it**:
    This will enable you to bring the automation for running different components
    onto your ML platform.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供应用程序接口（API）以进行交互**：这将使你能够将自动化引入到运行不同组件的 ML 平台中。'
- en: 'Let''s start by defining the major components of the Kubernetes platform: the
    control plane and the worker nodes.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义 Kubernetes 平台的主要组件开始：控制平面和工作节点。
- en: Control plane
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制平面
- en: 'The **control plane** is a set of components that form the *brains* of the
    Kubernetes. It consists of an API server, a key-value database, a scheduler, and
    a set of controllers. Let''s define each of these components, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制平面**是一组组件，构成了 Kubernetes 的*大脑*。它由 API 服务器、键值数据库、调度器和一组控制器组成。让我们分别定义这些组件：'
- en: '**API server**: This component provides a set of **REpresentational State Transfer**
    (**REST**) APIs to interact with the Kubernetes system. Everyone interacts with
    Kubernetes through this API. As a developer or operations engineer, you use the
    API, and internal Kubernetes components talk to the API server to perform different
    activities.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 服务器**：该组件提供了一组**表征状态传输**（**REST**）API，用于与 Kubernetes 系统交互。每个人都通过这个 API
    与 Kubernetes 进行交互。作为开发人员或运维工程师，你使用 API，而 Kubernetes 内部组件通过 API 服务器进行通信，执行不同的活动。'
- en: '`etcd`. No other component of the Kubernetes system talks to this value store
    directly—this is only accessible by the API server.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd`。Kubernetes 系统的其他组件不会直接与这个值存储交互——它只能通过 API 服务器访问。'
- en: '**Scheduler**: The scheduler component dictates where an application instance
    would be running. The scheduler selects the most suitable worker node based on
    the policy defined by the Kubernetes administrator.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controllers**: There are multiple controllers running in the control plane.
    Each controller has a set task; for example, a node controller is responsible
    for monitoring the state of the nodes.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the interaction between multiple control-plane
    components:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Kubernetes control-plane components'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_001.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Kubernetes control-plane components
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The control plane orchestrates the creation, update, and deletion of objects.
    It monitors and maintains the healthy state of the Kubernetes cluster. The control
    plane runs workloads that keep the cluster running. But what about the application
    workloads?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Worker nodes
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the name suggests, workers are a set of nodes that host the application
    software. For example, all ML platform components will be executed on the worker
    nodes. However, worker nodes also run a couple of Kubernetes components that make
    the communication channel between the control plane and the worker and manage
    running applications on the worker node. These are the key components running
    on the worker nodes besides the applications:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**Kube proxy**: Its primary role is to manage network communications rules
    for your applications running on the node.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubelet**: Think of the Kubelet software component as an agent running on
    each node. The primary role of this agent is to talk to the control-plane API
    server and manage applications running on the node. The agent also captures and
    sends the status of the node and the applications back to the control plane via
    the API.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container runtime**: The container runtime component is responsible for running
    containers that host applications, as directed by the Kubelet. *Docker* is one
    such example; however, Kubernetes has defined a **container runtime interface**
    (**CRI**). CRI defines interfaces that Kubernetes uses and the Kubernetes administrator
    can choose any container runtime that is compatible with the CRI.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the interaction between multiple worker-node components:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Kubernetes worker components'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_002.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Kubernetes worker components
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Worker nodes, also known as compute nodes, do the actual work of running the
    application workloads in the cluster. Running application workloads requires you
    to interact with the control plane using Kubernetes objects or resources.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes objects required to run an application
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s define a set of Kubernetes **objects** that are commonly required
    to run an application on the Kubernetes system. When you build the components
    for your ML platform, you will be using these Kubernetes objects to run applications
    on top of Kubernetes. The objects are listed here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '**Namespace**: One Kubernetes cluster is shared by multiple teams and projects.
    Namespaces provide a way to isolate Kubernetes resources. This isolation allows
    different teams, different environments, or even different applications to share
    the same cluster while keeping different configurations, network policies, resource
    quotas, and access control. It is like having a logical sub-cluster within the
    same Kubernetes cluster.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间**：一个Kubernetes集群由多个团队和项目共享。命名空间提供了一种隔离Kubernetes资源的方式。通过这种隔离，不同的团队、不同的环境，甚至不同的应用程序可以共享同一个集群，同时保持不同的配置、网络策略、资源配额和访问控制。这就像在同一个Kubernetes集群内拥有一个逻辑上的子集群。'
- en: '**Container image**: When you want to run an application on Kubernetes, you
    need to package the application in a standard format. This packaged format, which
    consists of your application and all its dependencies, is called a container image,
    and the running instance of this image is called a **container**. It contains
    your application and all the dependencies, including the operating system resources
    and your application needs, in one common bundle.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器镜像**：当你想在Kubernetes上运行一个应用程序时，你需要将应用程序打包成标准格式。这个打包格式包含了你的应用程序及其所有依赖项，称为容器镜像，而这个镜像的运行实例称为**容器**。它将你的应用程序及所有依赖项，包括操作系统资源和应用程序所需的资源，打包成一个共同的单元。'
- en: '**Deployment**: This Kubernetes object represents an application''s desired
    state on the cluster. A Deployment object contains information such as which container
    image you want to run and how many instances or *replicas* of containers you require.
    Kubernetes is periodically comparing the current cluster state to the desired
    state defined in the Deployment object. When Kubernetes finds that the current
    state is different from the desired state, it will then apply the necessary updates
    to the cluster to achieve the desired state. These updates include spinning up
    new containers with the container image defined in the Deployment object, stopping
    containers, and configuring network and other resources required by the Deployment
    object.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**：这个Kubernetes对象代表了集群中应用程序的期望状态。一个部署对象包含了诸如你希望运行的容器镜像以及你需要多少个容器实例或*副本*等信息。Kubernetes会定期将当前集群状态与部署对象中定义的期望状态进行对比。当Kubernetes发现当前状态与期望状态不符时，它会应用必要的更新来使集群达到期望状态。这些更新包括根据部署对象中定义的容器镜像启动新的容器、停止容器以及配置部署对象所需的网络和其他资源。'
- en: '**Pods**: A Pod is a fundamental unit of running applications in Kubernetes.
    It is also the smallest schedulable unit of deployment. It can contain one or
    more containers. Containers inside the pod share networking and disk resources.
    Containers running in a single pod are scheduled together on the same node while
    also having local communication with each other.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod**：Pod是Kubernetes中运行应用程序的基本单元。它也是最小的可调度部署单元。Pod可以包含一个或多个容器。Pod内的容器共享网络和磁盘资源。运行在同一个Pod中的容器会一起调度到同一个节点，并且能够彼此进行本地通信。'
- en: '**Services**: How do pods communicate with each other? Pods communicate through
    the cluster network, and each pod has its own **Internet Protocol** (**IP**) address.
    However, pods may come and go. Kubernetes may restart a pod due to node health
    or scheduling changes, and when this happens, the pod''s IP address will change.
    Furthermore, if the Deployment object is configured to run multiple replicas of
    the same pods, this means each replica will have its own IP address.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：Pod之间是如何通信的呢？Pod通过集群网络进行通信，每个Pod都有自己的**互联网协议**（**IP**）地址。然而，Pod是可能会变动的。Kubernetes可能会因为节点健康状况或调度变化而重启一个Pod，当这种情况发生时，Pod的IP地址会发生变化。此外，如果部署对象配置为运行多个相同Pod的副本，这意味着每个副本都会有自己的IP地址。'
- en: A service, in Kubernetes, exposes a set of pods as a single abstracted network
    service. It provides a single consistent IP address and **Domain Name System**
    (**DNS**) name that can route traffic and perform load balancing on pods. Think
    of a service as a load-balanced reverse proxy to your running pods.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，服务将一组Pod暴露为一个抽象的网络服务。它提供一个一致的IP地址和**域名系统**（**DNS**）名称，可以对Pod进行流量路由并执行负载均衡。可以把服务看作是一个负载均衡的反向代理，指向你正在运行的Pod。
- en: '**ConfigMaps and Secrets**: We have our application packaged as a container
    image and running as a pod. The same pod will get deployed in multiple environments
    such as Dev, Test, and Production. However, each environment will have a different
    configuration, such as the database location or others. Hardcoding such a configuration
    into a container image is not the right approach. One reason is that the container
    image may be deployed in multiple environments with different environment settings.
    There must be a way to define configuration outside of the container image and
    inject this configuration onto our container at runtime!'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置映射和密钥**：我们将应用程序打包成容器镜像并作为 pod 运行。相同的 pod 将在多个环境中部署，例如开发环境、测试环境和生产环境。然而，每个环境将有不同的配置，比如数据库位置等。将这种配置硬编码到容器镜像中不是正确的做法。一个原因是容器镜像可能会在多个环境中部署，而这些环境的设置是不同的。必须有一种方法可以在容器镜像之外定义配置，并在运行时将该配置注入到容器中！'
- en: ConfigMaps and Secrets provide a way to store configuration data in Kubernetes.
    Once you have these objects defined, they can be injected into your running pods
    either as a file within the pod's filesystem or as a set of environment variables.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 配置映射和密钥提供了一种在 Kubernetes 中存储配置信息的方式。一旦定义了这些对象，它们可以作为文件或一组环境变量注入到运行中的 pod 中。
- en: A ConfigMap is used to store and access configuration data. However, for sensitive
    configurations such as passwords and private keys, Kubernetes provides a special
    object for this purpose, known as a Secret. Just as with ConfigMaps, Secrets can
    be mounted either as files or as environment variables into pods.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 配置映射（ConfigMap）用于存储和访问配置信息。然而，对于敏感的配置，如密码和私钥，Kubernetes 提供了一种特殊的对象来处理这些内容，称为密钥（Secret）。与配置映射类似，密钥也可以作为文件或环境变量挂载到
    pod 中。
- en: 'The following diagram shows a logical relationship between Deployments, pods,
    ConfigMaps, and Services. A Deployment object provides an abstraction of a containerized
    application. This hides the complexity behind running **replication controllers**
    and pods. Deployments help you in running your application as a pod or group of
    pods, ConfigMaps provide an environment-specific configuration for your pods,
    and Services expose the pods in your deployment as a single network service:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了部署、pod、配置映射和服务之间的逻辑关系。部署对象提供了一个容器化应用程序的抽象，它隐藏了运行**副本控制器**和 pod 的复杂性。部署帮助你将应用程序作为单个
    pod 或 pod 组运行，配置映射为你的 pod 提供环境特定的配置，而服务将部署中的 pod 作为一个单一的网络服务暴露出来：
- en: '![Figure 3.3 – Storage provisioning in Kubernetes'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – Kubernetes 中的存储配置'
- en: '](img/B18332_03_003.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_03_003.jpg)'
- en: Figure 3.3 – Storage provisioning in Kubernetes
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – Kubernetes 中的存储配置
- en: '**Storage (PersistentVolume and PersistentVolumeClaim (PV and PVC))**: Pods
    are ephemeral. Once they are destroyed, all the local resources of the pod are
    gone. More often, applications deployed as pods may need access to storage to
    read and write persistent data that can outlive pods.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储（持久卷和持久卷声明（PV 和 PVC））**：Pod 是短暂的。一旦它们被销毁，所有本地资源都会丧失。通常，作为 pod 部署的应用程序可能需要访问存储，以读取和写入能够超越
    pod 存活周期的持久数据。'
- en: Kubernetes promises to be the infrastructure abstraction layer on top of many
    hardware vendors and cloud providers. However, the way to request storage resources
    or provision disks is different with the various cloud providers and on-premises
    systems. This calls for a need to request storage resources in a consistent manner
    across different hardware vendors and cloud providers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 承诺成为许多硬件供应商和云提供商之上的基础设施抽象层。然而，不同云提供商和本地系统请求存储资源或配置磁盘的方式是不同的。这要求在不同的硬件供应商和云提供商之间以一致的方式请求存储资源。
- en: Kubernetes solution to this is to split storage resources into two Kubernetes
    objects. A PV is an object that defines a physical storage volume. It contains
    the details of the underlying storage infrastructure. A PVC, on the other hand,
    is an abstracted pointer to a PV. A PVC indicates that the owner has a claim on
    a specific PV. Pods storage resources are associated with PVCs and never directly
    with the PV; this way, the underlying storage definition is abstracted from the
    application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的解决方案是将存储资源分为两个 Kubernetes 对象。持久卷（PV）是定义物理存储卷的对象。它包含底层存储基础设施的详细信息。而持久卷声明（PVC）则是一个抽象的指针，指向一个
    PV。PVC 表明所有者对特定 PV 的占用权。pod 的存储资源与 PVC 相关联，而不是直接与 PV 相关联；通过这种方式，底层存储定义从应用程序中抽象出来。
- en: 'The following diagram shows the relation between pods, PVCs, and PVs. The pod
    mounts a PVC as a volume; the PVC works as an abstraction layer for the pod to
    request a physical volume to be associated with the pod; the PVC is bound to a
    PV that provides specifics of the disks:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Storage provisioning in Kubernetes (continued)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_004.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Storage provisioning in Kubernetes (continued)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '**Ingress**: Services enable access to pods within the Kubernetes cluster.
    For scenarios in which you need access to a pod from outside the Kubernetes cluster,
    Ingress is the answer. Ingress provides a way for you to expose a particular service
    to be accessible from outside the cluster. This enables you to map a **HyperText
    Transfer Protocol** (**HTTP**)-based **Uniform Resource Locator** (**URL**) that
    points to a service. Ingress may also use **Secure Sockets Layer** (**SSL**) on
    the exposed URL and can be configured to terminate SSL for traffic within the
    cluster. This way, the transport layer will be encrypted all the way up to the
    Ingress, while forwarding the traffic to the pod in plain HTTP. It is also worth
    noting that Kubernetes allows traffic to be encrypted all the way to the pod if
    needed.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how Ingress enables pods to be accessible from
    outside the Kubernetes cluster:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – The Ingress object in the Kubernetes cluster'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_005.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – The Ingress object in the Kubernetes cluster
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have refreshed your understanding of Kubernetes, let's see how
    Kubernetes allows you to run your platform anywhere.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Becoming cloud-agnostic through Kubernetes
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key aspects of the ML platform we are building is that it enables
    the organization to run on any cloud or data center. However, each cloud has its
    own proprietary APIs to manage resources and deploy applications. For example,
    the **Amazon Web Services** (**AWS**) API uses an **Elastic Compute Cloud** (**EC2**)
    instance (a server) when provisioning a server, while Google Cloud's API uses
    a **Google** **Compute Engine** (**GCE**) VM (a server). Even the names of the
    resources are different! This is where Kubernetes plays a key role.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The wide adoption of Kubernetes has forced major cloud vendors to come up with
    tight integration solutions with Kubernetes. This allows anyone to spin up a Kubernetes
    cluster in AWS, GCP, or Azure in a matter of minutes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes API enables you to manage cloud resources. Using the standard
    Kubernetes API, you can deploy applications on any major cloud provider without
    needing to learn about the cloud provider's API. The Kubernetes API has become
    the abstraction layer to manage workloads in the cloud. The ML platform you will
    build in this book will exclusively use Kubernetes APIs to deploy and run applications.
    This includes the software components that make up the ML platform.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how Kubernetes allows you to become cloud-agnostic.
    You interact with Kubernetes through the Kubernetes API, which eliminates or reduces
    the need to interact directly with the cloud vendor''s API. In other words, Kubernetes
    provides a consistent way of interacting with your environment regardless of which
    cloud or data center it is running on:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 Kubernetes 如何帮助你实现云无关性。你通过 Kubernetes API 与 Kubernetes 交互，从而避免或减少直接与云提供商
    API 的交互。换句话说，Kubernetes 提供了一种一致的方式来与环境交互，无论它运行在哪个云平台或数据中心：
- en: '![Figure 3.6 – Kubernetes acting as a shim to cloud providers APIs'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – Kubernetes 作为云提供商 API 的适配层'
- en: '](img/B18332_03_006.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_03_006.jpg)'
- en: Figure 3.6 – Kubernetes acting as a shim to cloud providers APIs
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – Kubernetes 作为云提供商 API 的适配层
- en: Another important thing that came out of the Kubernetes community is **Operators**.
    You will be using Kubernetes Operators to deploy most of the components of the
    ML platform. Let's dig in.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 Kubernetes 社区推出的重要概念是 **操作员**。你将使用 Kubernetes 操作员来部署大多数机器学习平台的组件。我们来深入了解一下。
- en: Understanding Operators
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解操作员
- en: In traditional **information technology** (**IT**) organizations, specialized
    and dedicated teams were required to maintain applications and other software
    components such as databases, caches, and messaging components. Those teams were
    continuously observing the software ecosystem and doing specific things such as
    taking backups for databases, upgrading and patching newer versions of software
    components, and more.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的**信息技术**(**IT**) 组织中，需要专门的团队来维护应用程序和其他软件组件，如数据库、缓存和消息组件。这些团队不断监控软件生态系统，并执行特定任务，例如备份数据库、升级和修补软件组件的新版本等。
- en: '**Operators** are like system administrators or engineers, continuously monitoring
    applications running on the Kubernetes environment and performing operational
    tasks associated with the specific component. In other words, an Operator is an
    automated software manager that manages the installation and life cycle of applications
    on Kubernetes.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作员**就像系统管理员或工程师一样，持续监控 Kubernetes 环境中运行的应用程序，并执行与特定组件相关的运维任务。换句话说，操作员是一个自动化的软件管理器，负责管理
    Kubernetes 上应用程序的安装和生命周期。'
- en: Put simply, instead of you creating and updating Kubernetes Objects (Deployment,
    Ingress, and so on), the Operator takes this responsibility based on the configuration
    you provide. The configuration that directs the Operator to perform certain tasks
    is called a **custom resource** (**CR**), and the structure or schema for a CR
    is defined by an object called a **CR definition** (**CRD**).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，操作员负责基于你提供的配置来创建和更新 Kubernetes 对象（如部署、入口等），而不是你自己来执行这些任务。指示操作员执行特定任务的配置叫做
    **自定义资源** (**CR**)，而 CR 的结构或模式由一个叫做 **CR 定义** (**CRD**) 的对象来定义。
- en: 'The following diagram shows how an Operator automates application operations
    activities. In the traditional approach, the developer builds and develops the
    application, and then an application operations team provides support to run the
    application. One of the Kubernetes Operator''s aims is to automate activities
    that operations people perform:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了操作员如何自动化应用程序的运维活动。在传统的方法中，开发人员构建和开发应用程序，然后由应用运维团队提供支持以运行该应用程序。Kubernetes
    操作员的目标之一是自动化运维人员执行的任务：
- en: '![Figure 3.7 – An Operator is a software that automates tasks of the operations
    team'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 操作员是一种自动化运维团队任务的软件'
- en: '](img/B18332_03_007.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_03_007.jpg)'
- en: Figure 3.7 – An Operator is a software that automates tasks of the operations
    team
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 操作员是一种自动化运维团队任务的软件
- en: Kubernetes Operators can be complex. There are Operators that manage instances
    of databases, while some manage clusters of pods that work together. Some Operators
    own just 1 or 2 CRDs, while others could own more than 10 CRDs. The **Operator
    Lifecycle Manager** (**OLM**) simplifies the installation and management of Kubernetes
    Operators. Let's dig a little bit deeper into this.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 操作员可能很复杂。有些操作员管理数据库实例，而有些则管理协同工作的 Pod 集群。一些操作员只拥有 1 或 2 个 CRD，而另一些则可能拥有超过
    10 个 CRD。**操作员生命周期管理器** (**OLM**) 简化了 Kubernetes 操作员的安装和管理。我们来更深入地了解一下。
- en: 'In OLM, there are multiple stages required to install an Operator: creating
    a Deployment object for the Operator, configuring the required permissions to
    run an Operator (because it needs to observe changes in the Kubernetes cluster),
    and creating a CRD. To reduce the complexity of installing an Operator, a management
    layer may come in handy. OLM fulfills this role.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OLM 中，安装 Operator 需要多个步骤：为 Operator 创建部署对象，配置运行 Operator 所需的权限（因为它需要观察 Kubernetes
    集群中的变化），以及创建 CRD。为了减少安装 Operator 的复杂性，可能需要一个管理层来帮助完成这些任务。OLM 就是完成这个角色的工具。
- en: 'OLM standardizes interactions with Operators. It requires that all interactions
    with the Operator be done through the Kubernetes API. OLM makes it easy to manage
    the life cycle of multiple Operators through a single standard interface—the Kubernetes
    API. Our ML platform will make use of a few Operators, and therefore it is useful
    to understand OLM and objects related to it. Let''s look at them in more detail
    here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: OLM 标准化了与 Operators 的交互。它要求所有与 Operator 的交互都通过 Kubernetes API 完成。OLM 使得通过单一标准接口——Kubernetes
    API 来管理多个 Operator 的生命周期变得更加简单。我们的 ML 平台将使用几个 Operators，因此了解 OLM 和与之相关的对象是很有用的。让我们在这里更详细地了解它们：
- en: '`ClusterServiceVersion`: This object defines metadata about an Operator. It
    includes the name and version of the Operator, along with the installation information
    and required permissions. It also describes the CRD owned and required by the
    Operator.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClusterServiceVersion`：此对象定义了有关 Operator 的元数据。它包括 Operator 的名称和版本，以及安装信息和所需权限。它还描述了
    Operator 所拥有和所需的 CRD。'
- en: '`Subscription`: The `Subscription` object allows the user to install and update
    the Operator. OLM uses this object to install and configure Operators, CRDs, and
    related access-control objects.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subscription`：`Subscription` 对象允许用户安装和更新 Operator。OLM 使用此对象来安装和配置 Operators、CRDs
    以及相关的访问控制对象。'
- en: '`OperatorGroup`: `OperatorGroup` provides a way to associate your Operator
    with a specific set of namespaces. `OperatorGroup` defines a set of namespaces
    to which the associated Operator will react. If we do not define a set of namespaces
    in the `OperatorGroup` definition, then the Operator will run globally across
    all namespaces.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OperatorGroup`：`OperatorGroup` 提供了一种将您的 Operator 与特定命名空间集合关联的方法。`OperatorGroup`
    定义了一组命名空间，关联的 Operator 将对这些命名空间作出反应。如果我们在 `OperatorGroup` 定义中没有定义命名空间集合，那么 Operator
    将在所有命名空间中全局运行。'
- en: In the next section, you will get to install and configure your local Kubernetes
    environment and install OLM on the Kubernetes cluster.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将安装和配置本地的 Kubernetes 环境，并在 Kubernetes 集群上安装 OLM。
- en: Setting up your local Kubernetes environment
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置本地 Kubernetes 环境
- en: Now that we have refreshed some basic Kubernetes concepts, it's time for the
    rubber to hit the road. In this section, we will prepare and validate our local
    Kubernetes clusters. The cluster we set up here will be used to host the ML platform
    in later chapters.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经回顾了一些基础的 Kubernetes 概念，是时候开始实际操作了。在这一章节中，我们将准备并验证我们的本地 Kubernetes 集群。我们在这里设置的集群将用于在后续章节中托管
    ML 平台。
- en: Installing kubectl
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 kubectl
- en: '`kubectl` is a command-line tool that assists in running commands against a
    Kubernetes cluster. You can create Kubernetes objects, view logs, and monitor
    the progress of your actions through this utility. The following steps will install
    `kubectl` on your machine.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 是一个命令行工具，帮助您在 Kubernetes 集群中运行命令。您可以通过这个工具创建 Kubernetes 对象、查看日志并监控操作进展。以下步骤将帮助您在机器上安装
    `kubectl`。'
- en: Installing kubectl on Linux
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 kubectl
- en: 'First, let''s see the process for installing `kubectl` on a machine running
    Linux. Follow these next steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看在运行 Linux 的机器上安装 `kubectl` 的过程。请按照以下步骤操作：
- en: Create or **Secure Shell** (**SSH**) to a Terminal session on your Linux computer.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或 **安全外壳**（**SSH**）到您 Linux 计算机的终端会话。
- en: 'Download the `kubectl`. Kubernetes `1.22.4` throughout the book. The following
    two lines of code are one command:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 `kubectl`。本书中使用的 Kubernetes 版本为 `1.22.4`。以下两行代码是一条命令：
- en: '[PRE0]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Install the `kubectl` CLI by running the following command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装 `kubectl` CLI：
- en: '[PRE1]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Validate that it is installed by running the following command:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令验证它是否已安装：
- en: '[PRE2]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see the following response to the `version` command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下对 `version` 命令的响应：
- en: '![Figure 3.8 – Output of the kubectl version command in Linux'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.8 – 在 Linux 中运行 kubectl version 命令的输出'
- en: '](img/B18332_03_008.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_03_008.jpg)'
- en: Figure 3.8 – Output of the kubectl version command in Linux
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 在 Linux 中运行 kubectl version 命令的输出
- en: You should now have `kubectl` running on your Linux machine.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Installing kubectl on macOS
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s see the process for installing `kubectl` on a machine running
    macOS. Follow these steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Create or `SSH` to a Terminal session on your Mac computer.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `kubectl` Kubernetes CLI. We will be using version *1.22.4* throughout
    the book.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Intel Macs, run the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For Apple M1 Macs, run the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Install the `kubectl` CLI by running the following command:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Validate that it is installed by running the following command:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should see the following response to the `version` command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Output of the kubectl version command in macOS'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_009.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Output of the kubectl version command in macOS
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: You should now have `kubectl` running on macOS.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Installing kubectl on Windows
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, let''s go through the steps for Windows, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Run **PowerShell** as **Administrator**.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the `kubectl` Kubernetes CLI binary by running the following command.
    We will be using version *1.22.4* throughout the book:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Copy the `kubectl.exe` file to `c:\kubectl` by running the following commands:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add `c:\kubectl` to the `PATH` environment variable by running the following
    command and then restart your PowerShell Terminal:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Validate that it is installed by running the following command:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should see the following response to the `version` command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Output of kubectl version command in Windows'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_010.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Output of kubectl version command in Windows
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: You have just installed the `kubectl` Kubernetes CLI. The next step is to install
    `minikube`, a local, single-node Kubernetes cluster.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Installing minikube
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`minikube` provides a way to run a local Kubernetes cluster with ease. This
    is a minimal cluster, and it is intended to be only used for local development
    or experimentation. Running Kubernetes in production environments is beyond the
    scope of this book.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: As with `kubectl`, let's go through the installation for different types of
    operating systems.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Installing minikube on Linux
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow these steps to install `minikube` on Linux:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Create a Terminal session or `SSH` to your Linux computer.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install `podman` for `minikube` using the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Download `minikube` from this location. We are using version `1.24.0` of `minikube`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Install the `minikube` utility, as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Validate the `minikube` version, like this:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see the following response:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Output of the minikube version command on Linux'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_011.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Output of the minikube version command on Linux
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: You have just installed `kubectl` and `minikube` on Linux. These two command-line
    tools will help you to set up a local Kubernetes cluster.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Installing minikube on macOS
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although our preferred operating system is Linux for this book, we are providing
    steps to install `minikube` on macOS too. A lot of developers use the macOS system,
    and it would be beneficial to provide details for the operating system from Apple.
    Follow these next steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and install Docker Desktop from the Docker website or by accessing
    the following web page: [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop).'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once Docker is available, make sure that it is installed correctly by running
    the following command. Make sure that Docker is running before running this command:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should see the following response. If you get an error, please make sure
    that Docker is running:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Output of the docker version command on macOS'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_012.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – Output of the docker version command on macOS
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Open a Terminal on your macOS computer.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download `minikube` by running one of the following commands. You will be using
    version 1.24.0 of Minikube:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you have an Intel Mac, run the following command:'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you have an M1 Mac (Apple silicon), run this command instead:'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Move the downloaded file to the `/usr/local/bin` folder and make the downloaded
    file an executable by using the following commands:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Validate the `minikube` version, as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should see the following response:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Output of the minikube version command'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_013.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Output of the minikube version command
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: You have just installed `kubectl` and `minikube` on macOS. These two command-line
    tools will help you set up a local Kubernetes cluster.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Installing minikube on Windows
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with macOS, a substantial number of developers use Windows. It would be
    fair to provide steps on how to run the exercises on the operating system from
    Microsoft, the mighty Windows. Let''s dig in on how to run `minikube` on Windows
    using `Hyper-V`, the Microsoft virtualization layer. Please note that `Hyper-V`
    is available on all Windows except Windows Home. Follow these steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Run **PowerShell** as **Administrator**.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the PowerShell console, run the following command to enable `Hyper-V`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should see the following response if `Hyper-V` is not enabled. If it is
    enabled already, the command will just print the status. Press *Y* to continue:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Output of the command for enabling Hyper-V on Windows'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_014.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Output of the command for enabling Hyper-V on Windows
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Restart the computer, if needed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the `minikube` installer by opening the following link in the browser:
    [https://github.com/kubernetes/minikube/releases/download/v1.24.0/minikube-installer.exe](https://github.com/kubernetes/minikube/releases/download/v1.24.0/minikube-installer.exe).'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the downloaded installer. You should see the language setup screen, as
    shown in the following screenshot. Click **OK**:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Language selection dialog of the minikube installer'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_015.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – Language selection dialog of the minikube installer
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'The installer will present the following welcome screen. Click **Next >**,
    as illustrated in the following screenshot:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.16 – The minikube installer wizard'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_016.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – The minikube installer wizard
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'The installer will present the following **License Agreement** screen. Click
    **I Agree**:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.17 – License Agreement screen of the minikube installer'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_017.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 – License Agreement screen of the minikube installer
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'On this screen, select the location where you want to install `minikube` and
    then click **Install**, as illustrated in the following screenshot:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Install location screen of the minikube installer'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_018.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 – Install location screen of the minikube installer
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation may take a few minutes. Once the installation is successful,
    you should see the following screen. Click **Next >**:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Successful installation screen of the minikube installer'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_019.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.19 – Successful installation screen of the minikube installer
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the last screen in your `minikube` setup process. Click **Finish**
    to complete it:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.20 – Final screen of the minikube installer'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_020.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.20 – Final screen of the minikube installer
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in the PowerShell console, set the virtualization driver for `minikube`
    to `hyperv`. You can do this by running the following command:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should see the following response:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Output of the minikube config command'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_021.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.21 – Output of the minikube config command
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations—you have set up the `minikube` program on your Windows machine!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Over the preceding sections, you have installed the `kubectl` and `minikube`
    tools to set up your Kubernetes cluster. In the next section, you will set up
    a Kubernetes cluster.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a local Kubernetes cluster
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we will set up a Kubernetes cluster on your local machine. As mentioned
    in the technical requirements, we will need a minimum of 4 CPU cores or **virtual
    CPUs** (**vCPUs**), 60 GB of available disk, and at least 16 GB of memory to be
    allocated to the Kubernetes cluster. Our recommended configuration is 8 CPUs and
    64 GB of memory with 60 GB of disk space. If you do not have these resources available
    locally, you can provision a Linux host in the cloud. We will describe in the
    next section how to provision a host on Google Cloud. Proceed as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the `minikube` configuration for CPU, disk, and memory through the following
    commands:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Validate if the configuration is set correctly via the following command:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should see the following response:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – Output of the minikube config command'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_022.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.22 – Output of the minikube config command
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, start the Kubernetes cluster by running the following command:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You should see the following response:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 – Partial output of the minikube start command'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_023.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.23 – Partial output of the minikube start command
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the start process is completed, you should see a successful message like
    this after the Kubernetes platform is available:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24 – Output after the successful start of minikube'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_024.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.24 – Output after the successful start of minikube
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Validate that all the pods are in the **Running** state through the following
    command on Linux or macOS. Note that it may take a few minutes for the pods to
    be in the *Running* state:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Or, run this command in Windows PowerShell:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should see the following response:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25 – Validating the Kubernetes pods have started successfully'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_025.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.25 – Validating the Kubernetes pods have started successfully
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You just installed and validated your new Kubernetes cluster.
    The next step is to install components that will allow you to run Operators on
    your new Kubernetes cluster.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Installing OLM
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After you have validated that all pods are running for the local Kubernetes
    cluster, you will now install **OLM**. The process for installing OLM or any other
    applications inside Kubernetes is the same for all operating systems types. Proceed
    as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install the CRD for the OLM:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You should see the following response:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26 – Validating OLM CRs have been created successfully'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_026.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.26 – Validating OLM CRs have been created successfully
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install OLM on Kubernetes:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should see the following response:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.27 – Creating OLM objects in Kubernetes'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_027.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.27 – Creating OLM objects in Kubernetes
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Validate if all OLM pods are in the *Running* state by running this command
    on Linux or macOS:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or, run this command in Windows PowerShell:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should see the following response:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.28 – Validating resources for OLM have been created successfully'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_028.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.28 – Validating resources for OLM have been created successfully
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Validate that `catalogsource` is available by issuing the following command:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should see the following response:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.29 – Validating Operator catalog has been installed'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_029.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.29 – Validating Operator catalog has been installed
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You now have a local version of the Kubernetes cluster running
    and you have installed OLM on it. Your cluster is now ready to install Kubernetes
    Operators. Some of you may not have an access to a machine with the required minimum
    hardware requirements to run the ML platform, but don't worry—we've got you covered.
    The following section will help you provision the VM that you need in Google Cloud.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning a VM on GCP
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is always preferable to have a local environment that you can use to work
    on the exercises in this book. However, we understand that not everyone has the
    required compute resources available in their local machines. So, let's go to
    the cloud! You can provision just the right machine that you need for the exercises,
    in the cloud, and for free. For instance, Google Cloud gives **United States dollars**
    (**USD**) $300 worth of credit to new accounts. Other cloud providers such as
    AWS and Azure also give a similar free tier account, and it is up to you to select
    the cloud provider of your choice. For provisioning the VM we need for this book,
    however, we will use Google Cloud.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the account details sorted, use the following steps to provision
    a VM in your account. Just do not forget to stop the VM instance after you have
    completed a session to avoid getting billed for the hours that you are not using
    your machine.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'The following instruction will guide you through the process of provisioning
    a VM in Google Cloud:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: First, register for a new account at [https://cloud.google.com](https://cloud.google.com).
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `gcloud` **software development kit** (**SDK**) by following the
    steps at [https://cloud.google.com/sdk/docs/install](https://cloud.google.com/sdk/docs/install).
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Log in to Google Cloud using the following command. This command will open
    a browser instance where you provide login credentials for your Google Cloud account:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should see the following response:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.30 – Output for the login command'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_030.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.30 – Output for the login command
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, it will take you to the browser where you will authenticate. Once the
    browser completes the authentication steps, you will see the following output
    in the command line:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.31 – Output of a successful login to the gcloud account'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_031.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.31 – Output of a successful login to the gcloud account
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project in Google Cloud, as follows. Your VM will belong to this
    project. Note that the project name must be globally unique in GCP, so please
    change it as per your preference:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You should see the following response:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.32 – Output of the create project command in Google Cloud'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_032.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.32 – Output of the create project command in Google Cloud
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Projects in GCP
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Project `mlops-kube`. Choose a different project name of your choice for this
    command to work. You also need to use the chosen project name for subsequent commands
    where the `mlops-kube` project name is specified.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you are in the right project by issuing the following command:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should see the following response:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.33 – Output of the command for setting the current project context'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_033.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.33 – Output of the command for setting the current project context
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the right region and zone as per your location. You can get a list of all
    zones via the `gcloud compute zones list` command, as shown here:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should see the following response:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.34 – Output after setting up the gcloud region'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_034.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.34 – Output after setting up the gcloud region
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You should then see the following response:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.35 – Output after setting up the gcloud zone'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_035.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.35 – Output after setting up the gcloud zone
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable the Compute Engine API, as follows. This step is required to provision
    the Linux VM via APIs:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Disable **OS Login** because you only connect via SSH, as follows:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, create a VM within this project by running the following command:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output of the command should display the machine details, as illustrated
    here:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.36 – Output of the create VM command on Google Cloud'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_036.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.36 – Output of the create VM command on Google Cloud
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a firewall rule to allow access to the instance via port `22` for SSH,
    as follows. This is a lenient rule and should *NOT* be used in production:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You should see the following response:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.37 – Output of the firewall rule command'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_037.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.37 – Output of the firewall rule command
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH to the machine using the `gcloud` SSH capability, as follows. This will
    give the command line, and you can call the Kubernetes command mentioned in the
    preceding section:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Delete the instance after you have completed the session, as follows:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should see the following response:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.38 – Deleting the machine on Google Cloud'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_038.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.38 – Deleting the machine on Google Cloud
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you can use this `gcloud` VM as the host machine for your Kubernetes
    cluster. Following the previous sections, you should now know how to install `kubectl`
    and `minikube` and how to set up a local Kubernetes cluster in this VM.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have reviewed some basic Kubernetes concepts and gone through
    the Operator ecosystem in the Kubernetes universe. If you want to learn more about
    Kubernetes, *The Kubernetes Workshop* by Packt is a good place to start.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: You have installed the tooling required to set up a local Kubernetes cluster.
    You have seen the instructions to do it in other environments such as Linux, macOS,
    and Windows. You have set up a VM on Google Cloud in case you do not want to use
    your local computer for the exercises. You have configured OLM to manage Operators
    on your Kubernetes cluster. These technologies will form the infrastructure foundation
    of our ML platform, which you will start to shape up in the next chapter.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
