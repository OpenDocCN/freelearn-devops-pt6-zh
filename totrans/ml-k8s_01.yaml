- en: '*Chapter 3*: Exploring Kubernetes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have seen that Kubernetes will form the basis of your `minikube`
    instance either in your local machine or in the cloud. This is a single-node Kubernetes
    cluster that you will use as the base infrastructure to build and run the ML platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this particular order, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Kubernetes major components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Becoming cloud-agnostic through Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your local Kubernetes environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optional) Provisioning a **virtual machine** (**VM**) on **google cloud platform**
    (**GCP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter includes some hands-on setup. You will be setting up a Kubernetes
    cluster, and for this, you will need a machine with the following hardware specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: A **central processing unit** (**CPU**) with at least four cores; eight are
    recommended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory of at least 16 **gigabytes** (**GB**); 32 GB is recommended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk with available space of at least 60 GB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can be a physical machine such as a laptop, a server, or a VM running in
    the cloud that supports nested virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Kubernetes major components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many definitions of Kubernetes available on the web. We assume that,
    as a Kubernetes user, you already have a favorite pick. Therefore, in this section,
    you will see some basic concepts to refresh your Kubernetes knowledge. This section
    is by no means a reference or tutorial for the Kubernetes system.
  prefs: []
  type: TYPE_NORMAL
- en: 'From [*Chapter 2*](B18332_02_ePub.xhtml#_idTextAnchor027), *Understanding MLOps*,
    you have seen that Kubernetes provides the means for your ML platform to perform
    the following capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Provide a declarative style of running software components**: This capability
    will help your teams to be autonomous.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provide an abstraction layer for hardware resources**: Through this capability,
    you can run your ML platform on a variety of hardware and provide on-demand resource
    scheduling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provide an application programming interface (API) to interact with it**:
    This will enable you to bring the automation for running different components
    onto your ML platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by defining the major components of the Kubernetes platform: the
    control plane and the worker nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: Control plane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **control plane** is a set of components that form the *brains* of the
    Kubernetes. It consists of an API server, a key-value database, a scheduler, and
    a set of controllers. Let''s define each of these components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API server**: This component provides a set of **REpresentational State Transfer**
    (**REST**) APIs to interact with the Kubernetes system. Everyone interacts with
    Kubernetes through this API. As a developer or operations engineer, you use the
    API, and internal Kubernetes components talk to the API server to perform different
    activities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etcd`. No other component of the Kubernetes system talks to this value store
    directly—this is only accessible by the API server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduler**: The scheduler component dictates where an application instance
    would be running. The scheduler selects the most suitable worker node based on
    the policy defined by the Kubernetes administrator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controllers**: There are multiple controllers running in the control plane.
    Each controller has a set task; for example, a node controller is responsible
    for monitoring the state of the nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the interaction between multiple control-plane
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Kubernetes control-plane components'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Kubernetes control-plane components
  prefs: []
  type: TYPE_NORMAL
- en: The control plane orchestrates the creation, update, and deletion of objects.
    It monitors and maintains the healthy state of the Kubernetes cluster. The control
    plane runs workloads that keep the cluster running. But what about the application
    workloads?
  prefs: []
  type: TYPE_NORMAL
- en: Worker nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the name suggests, workers are a set of nodes that host the application
    software. For example, all ML platform components will be executed on the worker
    nodes. However, worker nodes also run a couple of Kubernetes components that make
    the communication channel between the control plane and the worker and manage
    running applications on the worker node. These are the key components running
    on the worker nodes besides the applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kube proxy**: Its primary role is to manage network communications rules
    for your applications running on the node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubelet**: Think of the Kubelet software component as an agent running on
    each node. The primary role of this agent is to talk to the control-plane API
    server and manage applications running on the node. The agent also captures and
    sends the status of the node and the applications back to the control plane via
    the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container runtime**: The container runtime component is responsible for running
    containers that host applications, as directed by the Kubelet. *Docker* is one
    such example; however, Kubernetes has defined a **container runtime interface**
    (**CRI**). CRI defines interfaces that Kubernetes uses and the Kubernetes administrator
    can choose any container runtime that is compatible with the CRI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the interaction between multiple worker-node components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Kubernetes worker components'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Kubernetes worker components
  prefs: []
  type: TYPE_NORMAL
- en: Worker nodes, also known as compute nodes, do the actual work of running the
    application workloads in the cluster. Running application workloads requires you
    to interact with the control plane using Kubernetes objects or resources.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes objects required to run an application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s define a set of Kubernetes **objects** that are commonly required
    to run an application on the Kubernetes system. When you build the components
    for your ML platform, you will be using these Kubernetes objects to run applications
    on top of Kubernetes. The objects are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Namespace**: One Kubernetes cluster is shared by multiple teams and projects.
    Namespaces provide a way to isolate Kubernetes resources. This isolation allows
    different teams, different environments, or even different applications to share
    the same cluster while keeping different configurations, network policies, resource
    quotas, and access control. It is like having a logical sub-cluster within the
    same Kubernetes cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container image**: When you want to run an application on Kubernetes, you
    need to package the application in a standard format. This packaged format, which
    consists of your application and all its dependencies, is called a container image,
    and the running instance of this image is called a **container**. It contains
    your application and all the dependencies, including the operating system resources
    and your application needs, in one common bundle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment**: This Kubernetes object represents an application''s desired
    state on the cluster. A Deployment object contains information such as which container
    image you want to run and how many instances or *replicas* of containers you require.
    Kubernetes is periodically comparing the current cluster state to the desired
    state defined in the Deployment object. When Kubernetes finds that the current
    state is different from the desired state, it will then apply the necessary updates
    to the cluster to achieve the desired state. These updates include spinning up
    new containers with the container image defined in the Deployment object, stopping
    containers, and configuring network and other resources required by the Deployment
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pods**: A Pod is a fundamental unit of running applications in Kubernetes.
    It is also the smallest schedulable unit of deployment. It can contain one or
    more containers. Containers inside the pod share networking and disk resources.
    Containers running in a single pod are scheduled together on the same node while
    also having local communication with each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services**: How do pods communicate with each other? Pods communicate through
    the cluster network, and each pod has its own **Internet Protocol** (**IP**) address.
    However, pods may come and go. Kubernetes may restart a pod due to node health
    or scheduling changes, and when this happens, the pod''s IP address will change.
    Furthermore, if the Deployment object is configured to run multiple replicas of
    the same pods, this means each replica will have its own IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A service, in Kubernetes, exposes a set of pods as a single abstracted network
    service. It provides a single consistent IP address and **Domain Name System**
    (**DNS**) name that can route traffic and perform load balancing on pods. Think
    of a service as a load-balanced reverse proxy to your running pods.
  prefs: []
  type: TYPE_NORMAL
- en: '**ConfigMaps and Secrets**: We have our application packaged as a container
    image and running as a pod. The same pod will get deployed in multiple environments
    such as Dev, Test, and Production. However, each environment will have a different
    configuration, such as the database location or others. Hardcoding such a configuration
    into a container image is not the right approach. One reason is that the container
    image may be deployed in multiple environments with different environment settings.
    There must be a way to define configuration outside of the container image and
    inject this configuration onto our container at runtime!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ConfigMaps and Secrets provide a way to store configuration data in Kubernetes.
    Once you have these objects defined, they can be injected into your running pods
    either as a file within the pod's filesystem or as a set of environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: A ConfigMap is used to store and access configuration data. However, for sensitive
    configurations such as passwords and private keys, Kubernetes provides a special
    object for this purpose, known as a Secret. Just as with ConfigMaps, Secrets can
    be mounted either as files or as environment variables into pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a logical relationship between Deployments, pods,
    ConfigMaps, and Services. A Deployment object provides an abstraction of a containerized
    application. This hides the complexity behind running **replication controllers**
    and pods. Deployments help you in running your application as a pod or group of
    pods, ConfigMaps provide an environment-specific configuration for your pods,
    and Services expose the pods in your deployment as a single network service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Storage provisioning in Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Storage provisioning in Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: '**Storage (PersistentVolume and PersistentVolumeClaim (PV and PVC))**: Pods
    are ephemeral. Once they are destroyed, all the local resources of the pod are
    gone. More often, applications deployed as pods may need access to storage to
    read and write persistent data that can outlive pods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes promises to be the infrastructure abstraction layer on top of many
    hardware vendors and cloud providers. However, the way to request storage resources
    or provision disks is different with the various cloud providers and on-premises
    systems. This calls for a need to request storage resources in a consistent manner
    across different hardware vendors and cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes solution to this is to split storage resources into two Kubernetes
    objects. A PV is an object that defines a physical storage volume. It contains
    the details of the underlying storage infrastructure. A PVC, on the other hand,
    is an abstracted pointer to a PV. A PVC indicates that the owner has a claim on
    a specific PV. Pods storage resources are associated with PVCs and never directly
    with the PV; this way, the underlying storage definition is abstracted from the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the relation between pods, PVCs, and PVs. The pod
    mounts a PVC as a volume; the PVC works as an abstraction layer for the pod to
    request a physical volume to be associated with the pod; the PVC is bound to a
    PV that provides specifics of the disks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Storage provisioning in Kubernetes (continued)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Storage provisioning in Kubernetes (continued)
  prefs: []
  type: TYPE_NORMAL
- en: '**Ingress**: Services enable access to pods within the Kubernetes cluster.
    For scenarios in which you need access to a pod from outside the Kubernetes cluster,
    Ingress is the answer. Ingress provides a way for you to expose a particular service
    to be accessible from outside the cluster. This enables you to map a **HyperText
    Transfer Protocol** (**HTTP**)-based **Uniform Resource Locator** (**URL**) that
    points to a service. Ingress may also use **Secure Sockets Layer** (**SSL**) on
    the exposed URL and can be configured to terminate SSL for traffic within the
    cluster. This way, the transport layer will be encrypted all the way up to the
    Ingress, while forwarding the traffic to the pod in plain HTTP. It is also worth
    noting that Kubernetes allows traffic to be encrypted all the way to the pod if
    needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how Ingress enables pods to be accessible from
    outside the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – The Ingress object in the Kubernetes cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – The Ingress object in the Kubernetes cluster
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have refreshed your understanding of Kubernetes, let's see how
    Kubernetes allows you to run your platform anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Becoming cloud-agnostic through Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key aspects of the ML platform we are building is that it enables
    the organization to run on any cloud or data center. However, each cloud has its
    own proprietary APIs to manage resources and deploy applications. For example,
    the **Amazon Web Services** (**AWS**) API uses an **Elastic Compute Cloud** (**EC2**)
    instance (a server) when provisioning a server, while Google Cloud's API uses
    a **Google** **Compute Engine** (**GCE**) VM (a server). Even the names of the
    resources are different! This is where Kubernetes plays a key role.
  prefs: []
  type: TYPE_NORMAL
- en: The wide adoption of Kubernetes has forced major cloud vendors to come up with
    tight integration solutions with Kubernetes. This allows anyone to spin up a Kubernetes
    cluster in AWS, GCP, or Azure in a matter of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes API enables you to manage cloud resources. Using the standard
    Kubernetes API, you can deploy applications on any major cloud provider without
    needing to learn about the cloud provider's API. The Kubernetes API has become
    the abstraction layer to manage workloads in the cloud. The ML platform you will
    build in this book will exclusively use Kubernetes APIs to deploy and run applications.
    This includes the software components that make up the ML platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how Kubernetes allows you to become cloud-agnostic.
    You interact with Kubernetes through the Kubernetes API, which eliminates or reduces
    the need to interact directly with the cloud vendor''s API. In other words, Kubernetes
    provides a consistent way of interacting with your environment regardless of which
    cloud or data center it is running on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Kubernetes acting as a shim to cloud providers APIs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Kubernetes acting as a shim to cloud providers APIs
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing that came out of the Kubernetes community is **Operators**.
    You will be using Kubernetes Operators to deploy most of the components of the
    ML platform. Let's dig in.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In traditional **information technology** (**IT**) organizations, specialized
    and dedicated teams were required to maintain applications and other software
    components such as databases, caches, and messaging components. Those teams were
    continuously observing the software ecosystem and doing specific things such as
    taking backups for databases, upgrading and patching newer versions of software
    components, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '**Operators** are like system administrators or engineers, continuously monitoring
    applications running on the Kubernetes environment and performing operational
    tasks associated with the specific component. In other words, an Operator is an
    automated software manager that manages the installation and life cycle of applications
    on Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: Put simply, instead of you creating and updating Kubernetes Objects (Deployment,
    Ingress, and so on), the Operator takes this responsibility based on the configuration
    you provide. The configuration that directs the Operator to perform certain tasks
    is called a **custom resource** (**CR**), and the structure or schema for a CR
    is defined by an object called a **CR definition** (**CRD**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how an Operator automates application operations
    activities. In the traditional approach, the developer builds and develops the
    application, and then an application operations team provides support to run the
    application. One of the Kubernetes Operator''s aims is to automate activities
    that operations people perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – An Operator is a software that automates tasks of the operations
    team'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – An Operator is a software that automates tasks of the operations
    team
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Operators can be complex. There are Operators that manage instances
    of databases, while some manage clusters of pods that work together. Some Operators
    own just 1 or 2 CRDs, while others could own more than 10 CRDs. The **Operator
    Lifecycle Manager** (**OLM**) simplifies the installation and management of Kubernetes
    Operators. Let's dig a little bit deeper into this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In OLM, there are multiple stages required to install an Operator: creating
    a Deployment object for the Operator, configuring the required permissions to
    run an Operator (because it needs to observe changes in the Kubernetes cluster),
    and creating a CRD. To reduce the complexity of installing an Operator, a management
    layer may come in handy. OLM fulfills this role.'
  prefs: []
  type: TYPE_NORMAL
- en: 'OLM standardizes interactions with Operators. It requires that all interactions
    with the Operator be done through the Kubernetes API. OLM makes it easy to manage
    the life cycle of multiple Operators through a single standard interface—the Kubernetes
    API. Our ML platform will make use of a few Operators, and therefore it is useful
    to understand OLM and objects related to it. Let''s look at them in more detail
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ClusterServiceVersion`: This object defines metadata about an Operator. It
    includes the name and version of the Operator, along with the installation information
    and required permissions. It also describes the CRD owned and required by the
    Operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subscription`: The `Subscription` object allows the user to install and update
    the Operator. OLM uses this object to install and configure Operators, CRDs, and
    related access-control objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OperatorGroup`: `OperatorGroup` provides a way to associate your Operator
    with a specific set of namespaces. `OperatorGroup` defines a set of namespaces
    to which the associated Operator will react. If we do not define a set of namespaces
    in the `OperatorGroup` definition, then the Operator will run globally across
    all namespaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, you will get to install and configure your local Kubernetes
    environment and install OLM on the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your local Kubernetes environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have refreshed some basic Kubernetes concepts, it's time for the
    rubber to hit the road. In this section, we will prepare and validate our local
    Kubernetes clusters. The cluster we set up here will be used to host the ML platform
    in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Installing kubectl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`kubectl` is a command-line tool that assists in running commands against a
    Kubernetes cluster. You can create Kubernetes objects, view logs, and monitor
    the progress of your actions through this utility. The following steps will install
    `kubectl` on your machine.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing kubectl on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s see the process for installing `kubectl` on a machine running
    Linux. Follow these next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create or **Secure Shell** (**SSH**) to a Terminal session on your Linux computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the `kubectl`. Kubernetes `1.22.4` throughout the book. The following
    two lines of code are one command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the `kubectl` CLI by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Validate that it is installed by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response to the `version` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Output of the kubectl version command in Linux'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Output of the kubectl version command in Linux
  prefs: []
  type: TYPE_NORMAL
- en: You should now have `kubectl` running on your Linux machine.
  prefs: []
  type: TYPE_NORMAL
- en: Installing kubectl on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s see the process for installing `kubectl` on a machine running
    macOS. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create or `SSH` to a Terminal session on your Mac computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `kubectl` Kubernetes CLI. We will be using version *1.22.4* throughout
    the book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Intel Macs, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For Apple M1 Macs, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `kubectl` CLI by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Validate that it is installed by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response to the `version` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Output of the kubectl version command in macOS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Output of the kubectl version command in macOS
  prefs: []
  type: TYPE_NORMAL
- en: You should now have `kubectl` running on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Installing kubectl on Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, let''s go through the steps for Windows, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Run **PowerShell** as **Administrator**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the `kubectl` Kubernetes CLI binary by running the following command.
    We will be using version *1.22.4* throughout the book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy the `kubectl.exe` file to `c:\kubectl` by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `c:\kubectl` to the `PATH` environment variable by running the following
    command and then restart your PowerShell Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Validate that it is installed by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response to the `version` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Output of kubectl version command in Windows'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Output of kubectl version command in Windows
  prefs: []
  type: TYPE_NORMAL
- en: You have just installed the `kubectl` Kubernetes CLI. The next step is to install
    `minikube`, a local, single-node Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing minikube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`minikube` provides a way to run a local Kubernetes cluster with ease. This
    is a minimal cluster, and it is intended to be only used for local development
    or experimentation. Running Kubernetes in production environments is beyond the
    scope of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: As with `kubectl`, let's go through the installation for different types of
    operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Installing minikube on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow these steps to install `minikube` on Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Terminal session or `SSH` to your Linux computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install `podman` for `minikube` using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Download `minikube` from this location. We are using version `1.24.0` of `minikube`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the `minikube` utility, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Validate the `minikube` version, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Output of the minikube version command on Linux'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Output of the minikube version command on Linux
  prefs: []
  type: TYPE_NORMAL
- en: You have just installed `kubectl` and `minikube` on Linux. These two command-line
    tools will help you to set up a local Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing minikube on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although our preferred operating system is Linux for this book, we are providing
    steps to install `minikube` on macOS too. A lot of developers use the macOS system,
    and it would be beneficial to provide details for the operating system from Apple.
    Follow these next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and install Docker Desktop from the Docker website or by accessing
    the following web page: [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once Docker is available, make sure that it is installed correctly by running
    the following command. Make sure that Docker is running before running this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response. If you get an error, please make sure
    that Docker is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Output of the docker version command on macOS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – Output of the docker version command on macOS
  prefs: []
  type: TYPE_NORMAL
- en: Open a Terminal on your macOS computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download `minikube` by running one of the following commands. You will be using
    version 1.24.0 of Minikube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you have an Intel Mac, run the following command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have an M1 Mac (Apple silicon), run this command instead:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Move the downloaded file to the `/usr/local/bin` folder and make the downloaded
    file an executable by using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Validate the `minikube` version, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Output of the minikube version command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Output of the minikube version command
  prefs: []
  type: TYPE_NORMAL
- en: You have just installed `kubectl` and `minikube` on macOS. These two command-line
    tools will help you set up a local Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing minikube on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with macOS, a substantial number of developers use Windows. It would be
    fair to provide steps on how to run the exercises on the operating system from
    Microsoft, the mighty Windows. Let''s dig in on how to run `minikube` on Windows
    using `Hyper-V`, the Microsoft virtualization layer. Please note that `Hyper-V`
    is available on all Windows except Windows Home. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run **PowerShell** as **Administrator**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the PowerShell console, run the following command to enable `Hyper-V`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response if `Hyper-V` is not enabled. If it is
    enabled already, the command will just print the status. Press *Y* to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Output of the command for enabling Hyper-V on Windows'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Output of the command for enabling Hyper-V on Windows
  prefs: []
  type: TYPE_NORMAL
- en: Restart the computer, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the `minikube` installer by opening the following link in the browser:
    [https://github.com/kubernetes/minikube/releases/download/v1.24.0/minikube-installer.exe](https://github.com/kubernetes/minikube/releases/download/v1.24.0/minikube-installer.exe).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the downloaded installer. You should see the language setup screen, as
    shown in the following screenshot. Click **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Language selection dialog of the minikube installer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – Language selection dialog of the minikube installer
  prefs: []
  type: TYPE_NORMAL
- en: 'The installer will present the following welcome screen. Click **Next >**,
    as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.16 – The minikube installer wizard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – The minikube installer wizard
  prefs: []
  type: TYPE_NORMAL
- en: 'The installer will present the following **License Agreement** screen. Click
    **I Agree**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.17 – License Agreement screen of the minikube installer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_017.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 – License Agreement screen of the minikube installer
  prefs: []
  type: TYPE_NORMAL
- en: 'On this screen, select the location where you want to install `minikube` and
    then click **Install**, as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Install location screen of the minikube installer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_018.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 – Install location screen of the minikube installer
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation may take a few minutes. Once the installation is successful,
    you should see the following screen. Click **Next >**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Successful installation screen of the minikube installer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_019.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.19 – Successful installation screen of the minikube installer
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the last screen in your `minikube` setup process. Click **Finish**
    to complete it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.20 – Final screen of the minikube installer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_020.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.20 – Final screen of the minikube installer
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in the PowerShell console, set the virtualization driver for `minikube`
    to `hyperv`. You can do this by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Output of the minikube config command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_021.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.21 – Output of the minikube config command
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations—you have set up the `minikube` program on your Windows machine!
  prefs: []
  type: TYPE_NORMAL
- en: Over the preceding sections, you have installed the `kubectl` and `minikube`
    tools to set up your Kubernetes cluster. In the next section, you will set up
    a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a local Kubernetes cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we will set up a Kubernetes cluster on your local machine. As mentioned
    in the technical requirements, we will need a minimum of 4 CPU cores or **virtual
    CPUs** (**vCPUs**), 60 GB of available disk, and at least 16 GB of memory to be
    allocated to the Kubernetes cluster. Our recommended configuration is 8 CPUs and
    64 GB of memory with 60 GB of disk space. If you do not have these resources available
    locally, you can provision a Linux host in the cloud. We will describe in the
    next section how to provision a host on Google Cloud. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the `minikube` configuration for CPU, disk, and memory through the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Validate if the configuration is set correctly via the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – Output of the minikube config command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_022.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.22 – Output of the minikube config command
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, start the Kubernetes cluster by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 – Partial output of the minikube start command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_023.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.23 – Partial output of the minikube start command
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the start process is completed, you should see a successful message like
    this after the Kubernetes platform is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24 – Output after the successful start of minikube'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_024.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.24 – Output after the successful start of minikube
  prefs: []
  type: TYPE_NORMAL
- en: 'Validate that all the pods are in the **Running** state through the following
    command on Linux or macOS. Note that it may take a few minutes for the pods to
    be in the *Running* state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or, run this command in Windows PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25 – Validating the Kubernetes pods have started successfully'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_025.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.25 – Validating the Kubernetes pods have started successfully
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You just installed and validated your new Kubernetes cluster.
    The next step is to install components that will allow you to run Operators on
    your new Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing OLM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After you have validated that all pods are running for the local Kubernetes
    cluster, you will now install **OLM**. The process for installing OLM or any other
    applications inside Kubernetes is the same for all operating systems types. Proceed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install the CRD for the OLM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26 – Validating OLM CRs have been created successfully'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_026.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.26 – Validating OLM CRs have been created successfully
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install OLM on Kubernetes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.27 – Creating OLM objects in Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_027.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.27 – Creating OLM objects in Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: 'Validate if all OLM pods are in the *Running* state by running this command
    on Linux or macOS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or, run this command in Windows PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.28 – Validating resources for OLM have been created successfully'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_028.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.28 – Validating resources for OLM have been created successfully
  prefs: []
  type: TYPE_NORMAL
- en: 'Validate that `catalogsource` is available by issuing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.29 – Validating Operator catalog has been installed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_029.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.29 – Validating Operator catalog has been installed
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You now have a local version of the Kubernetes cluster running
    and you have installed OLM on it. Your cluster is now ready to install Kubernetes
    Operators. Some of you may not have an access to a machine with the required minimum
    hardware requirements to run the ML platform, but don't worry—we've got you covered.
    The following section will help you provision the VM that you need in Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning a VM on GCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is always preferable to have a local environment that you can use to work
    on the exercises in this book. However, we understand that not everyone has the
    required compute resources available in their local machines. So, let's go to
    the cloud! You can provision just the right machine that you need for the exercises,
    in the cloud, and for free. For instance, Google Cloud gives **United States dollars**
    (**USD**) $300 worth of credit to new accounts. Other cloud providers such as
    AWS and Azure also give a similar free tier account, and it is up to you to select
    the cloud provider of your choice. For provisioning the VM we need for this book,
    however, we will use Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the account details sorted, use the following steps to provision
    a VM in your account. Just do not forget to stop the VM instance after you have
    completed a session to avoid getting billed for the hours that you are not using
    your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following instruction will guide you through the process of provisioning
    a VM in Google Cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: First, register for a new account at [https://cloud.google.com](https://cloud.google.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `gcloud` **software development kit** (**SDK**) by following the
    steps at [https://cloud.google.com/sdk/docs/install](https://cloud.google.com/sdk/docs/install).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Log in to Google Cloud using the following command. This command will open
    a browser instance where you provide login credentials for your Google Cloud account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.30 – Output for the login command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_030.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.30 – Output for the login command
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, it will take you to the browser where you will authenticate. Once the
    browser completes the authentication steps, you will see the following output
    in the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.31 – Output of a successful login to the gcloud account'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_031.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.31 – Output of a successful login to the gcloud account
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project in Google Cloud, as follows. Your VM will belong to this
    project. Note that the project name must be globally unique in GCP, so please
    change it as per your preference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.32 – Output of the create project command in Google Cloud'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_032.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.32 – Output of the create project command in Google Cloud
  prefs: []
  type: TYPE_NORMAL
- en: Projects in GCP
  prefs: []
  type: TYPE_NORMAL
- en: Project `mlops-kube`. Choose a different project name of your choice for this
    command to work. You also need to use the chosen project name for subsequent commands
    where the `mlops-kube` project name is specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you are in the right project by issuing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.33 – Output of the command for setting the current project context'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_033.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.33 – Output of the command for setting the current project context
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the right region and zone as per your location. You can get a list of all
    zones via the `gcloud compute zones list` command, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.34 – Output after setting up the gcloud region'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_034.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.34 – Output after setting up the gcloud region
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You should then see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.35 – Output after setting up the gcloud zone'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_035.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.35 – Output after setting up the gcloud zone
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable the Compute Engine API, as follows. This step is required to provision
    the Linux VM via APIs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Disable **OS Login** because you only connect via SSH, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a VM within this project by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the command should display the machine details, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.36 – Output of the create VM command on Google Cloud'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_036.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.36 – Output of the create VM command on Google Cloud
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a firewall rule to allow access to the instance via port `22` for SSH,
    as follows. This is a lenient rule and should *NOT* be used in production:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.37 – Output of the firewall rule command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_037.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.37 – Output of the firewall rule command
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH to the machine using the `gcloud` SSH capability, as follows. This will
    give the command line, and you can call the Kubernetes command mentioned in the
    preceding section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete the instance after you have completed the session, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.38 – Deleting the machine on Google Cloud'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18332_03_038.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.38 – Deleting the machine on Google Cloud
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you can use this `gcloud` VM as the host machine for your Kubernetes
    cluster. Following the previous sections, you should now know how to install `kubectl`
    and `minikube` and how to set up a local Kubernetes cluster in this VM.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have reviewed some basic Kubernetes concepts and gone through
    the Operator ecosystem in the Kubernetes universe. If you want to learn more about
    Kubernetes, *The Kubernetes Workshop* by Packt is a good place to start.
  prefs: []
  type: TYPE_NORMAL
- en: You have installed the tooling required to set up a local Kubernetes cluster.
    You have seen the instructions to do it in other environments such as Linux, macOS,
    and Windows. You have set up a VM on Google Cloud in case you do not want to use
    your local computer for the exercises. You have configured OLM to manage Operators
    on your Kubernetes cluster. These technologies will form the infrastructure foundation
    of our ML platform, which you will start to shape up in the next chapter.
  prefs: []
  type: TYPE_NORMAL
