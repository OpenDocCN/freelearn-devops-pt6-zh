- en: Kubernetes on AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using Kubernetes on the public cloud is flexible and scalable for your application.
    AWS is one of the most popular services in the public cloud industry. In this
    chapter, you''ll learn what AWS is and how to set up Kubernetes on AWS along with
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the public cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using and understanding AWS components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Amazon EKS to set up a Kubernetes cluster on AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using EKS to manage Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you run your application on the public network, you need an infrastructure
    such as networks, Virtual Machines (VMs), and storage. Obviously, companies borrow
    or build their own data center to prepare those infrastructures, and then hire
    data center engineers and operators to monitor and manage those resources.
  prefs: []
  type: TYPE_NORMAL
- en: However, purchasing and maintaining those assets requires a large capital expense
    as well as an operational expense for data center engineers/operators. You also
    need a lead time to fully set up those infrastructures, such as buying a server,
    mounting to a data center rack, cabling a network, and then the initial configuration/installation
    of the OS and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, rapidly allocating an infrastructure with appropriate resource
    capacity is one of the important factors that dictates the success of your business.
  prefs: []
  type: TYPE_NORMAL
- en: To make infrastructure management easier and quicker, there's a lot that technology
    can do to help data centers, for example, for virtualization, **Software Defined
    Network** (**SDN**) and **Storage Area Network** (**SAN**). But combining this
    technology has some sensitive compatibility issues and is difficult to stabilize;
    therefore it's necessary to hire experts in this industry, which makes operation
    costs higher eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Public cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some companies that have provided an online infrastructure service.
    AWS is a well known service that provides online infrastructure, which is called
    cloud or **public cloud**. Back in the year 2006, AWS officially launched the
    virtual machine service, which was called **Elastic Computing Cloud** (**EC2**);
    an online object store service, which was called **Simple Storage Service** (**S3**);
    and an online messaging queue service, which was called **Simple Queue Service**
    (**SQS**).
  prefs: []
  type: TYPE_NORMAL
- en: These services are simple enough, but from a data center management point of
    view, they relieve infrastructure pre-allocation and reduce read time, because
    of pay-as-you-go pricing models (paying hourly or yearly for usage to AWS). Consequently,
    AWS is getting so popular that many companies have switched from their own data
    centers to the public cloud.
  prefs: []
  type: TYPE_NORMAL
- en: An antonym of the public cloud, your own data center is referred to as **on-premises**.
  prefs: []
  type: TYPE_NORMAL
- en: API and infrastructure as code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the unique benefits of using a public cloud instead of on-premises data
    centers is that public cloud provides an API to control infrastructure. AWS provides
    command-line tools (**AWS CLI**) to control AWS infrastructure. For example, after
    signing up to AWS ([https://aws.amazon.com/free/](https://aws.amazon.com/free/)),
    install AWS CLI ([http://docs.aws.amazon.com/cli/latest/userguide/installing.html](http://docs.aws.amazon.com/cli/latest/userguide/installing.html));
    then, if you want to launch one virtual machine (EC2 instance), use the AWS CLI
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/851f14a5-046d-4fc1-b37c-930e58b471f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, it only takes a few minutes to access your virtual machine
    after signing up to AWS. On the other hand, what if you set up your own on-premises
    data center from scratch? The following diagram shows a comparison of what happens
    if you use on-premises data centers or if you use the public cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d22cf5f-a01a-4c42-8608-23e445209f95.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the public cloud is very simple and quick; this is why it's
    flexible and convenient, not only for emerging, but also for permanent usage.
  prefs: []
  type: TYPE_NORMAL
- en: AWS components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS has some components to configure network and storage. These are important
    for understanding how the public cloud works as well as how to configure Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: VPC and subnet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On AWS, first of all you need to create your own network. This is called a **Virtual
    Private Cloud** (**VPC**), which uses SDN technology. AWS allows you to create
    one or more VPC on AWS. Each VPC may connect with each other as required. When
    you create a VPC, just define one network CIDR block and AWS region, for example,
    the `10.0.0.0/16` CIDR on `us-east-1`. No matter whether you have access to a
    public network or not, you can define any network address range (between `/16`
    to `/28` netmask range). VPC creation is very quick; once done creating a VPC,
    you need to create one or more subnets within the VPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, one VPC is created via the AWS command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A subnet is a logical network block. This must belong to one VPC as well as
    one availability zone, for example, the `vpc-0ca37d4650963adbb` VPC and `us-east-1b`.
    Then, the network CIDR must be within the VPC's CIDR. For example, if the VPC
    CIDR is `10.0.0.0/16` (`10.0.0.0`–`10.0.255.255`), then one subnet CIDR could
    be `10.0.1.0/24` (`10.0.1.0`–`10.0.1.255`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we''ll create two subnets on the `us-east-1a` availability
    zone and another two subnets on the `us-east-1b` availability zone. Therefore,
    a total of four subnets will be created on `vpc-0ca37d4650963adbb` according to
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the first subnet, `10.0.1.0/24`, on the `us-east-1a` availability zone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a second subnet, `10.0.2.0/24`, on the `us-east-1b` availability zone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a third subnet, `10.0."3".0/24`, on `us-east-1b` again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a fourth subnet, `10.0.4.0/24`, on `us-east-1a` again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's make the first two subnets public-facing ones and the last two subnets
    private ones. This means the public-facing subnet can be accessible from the internet,
    which allows it to have a public IP address. On the other hand, the private subnet
    doesn't have a reachability from the internet. To do that, you need to set up
    gateways and routing tables.
  prefs: []
  type: TYPE_NORMAL
- en: Internet gateways and NAT-GW
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, your VPC needs to have a connection with the public internet.
    In this case, you need to create an **Internet Gateway** (**IGW**) to attach to
    your VPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, an IGW is created and attached to `vpc-0ca37d4650963adbb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once the IGW is attached, set a routing table (default gateway) for a subnet
    that points to the IGW. If a default gateway points to an IGW, this subnet is
    able to have a public IP address and access from/to the internet. Therefore, if
    the default gateway doesn't point to IGW, it's determined as a private subnet,
    which means no public access.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, a routing table is created that points to IGW and
    is set to the public subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, the private subnet doesn't need a public IP address. However,
    a private subnet sometimes needs to access the internet, for example, to download
    some packages and access the AWS service. In this case, we still have an option
    to connect to the internet. This is called a **Network Address Translation Gateway**
    (**NAT-GW**).
  prefs: []
  type: TYPE_NORMAL
- en: A NAT-GW allows private subnets to access the public internet through the NAT-GW.
    Consequently, the NAT-GW must be located at a public subnet, and the private subnet
    routing table points to the NAT-GW as a default gateway. Note that in order to
    access a NAT-GW on the public network, it needs an **Elastic IP** (**EIP**) attached
    to the NAT-GW.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, a NAT-GW is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Unlike an IGW, you can deploy a NAT-GW on single **Availability Zone** (**AZ**).
    If you need a high availability NAT-GW, you need to deploy a NAT-GW on each AZ. However,
    AWS charges you an additional hourly cost for an Elastic IP and NAT-GW. Therefore,
    if you wish to save costs, launch a single NAT-GW on a single AZ, as in the preceding
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a NAT-GW takes a few minutes. Once it's created, update a private subnet
    routing table that points to the NAT-GW, and then any EC2 instances are able to
    access the internet; again, however, due to no public IP address on the private
    subnet, there's no chance of access from the public internet to the private subnet
    EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, an update routing table for the private subnet points
    to a NAT-GW as the default gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Overall, there are four subnets that have been configured as two public subnets
    and two private subnets. Each subnet has a default route to use IGW and NAT-GW
    as follows. Note that the ID varies because AWS assigns a unique identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Types of subnet** | **CIDR block** | **Availability zone** | **Subnet ID**
    | **Route table ID** | **Default gateway** | **Assign Public IP while EC2 launches**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Public | 10.0.1.0/24 | us-east-1a | `subnet-``09f8f7f06c27cb0a0` | `rtb-``0f45fc46edec61d8f`
    | `igw-``01769bff334dcc035` (IGW) | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Private | 10.0.2.0/24 | us-east-1b | `subnet-``04b78ed9b5f96d76e` | `rtb-``08572c332e7e4f14e`
    | `nat-``05e34091f53f10172` (NAT-GW) | No (default) |'
  prefs: []
  type: TYPE_TB
- en: '| Public | 10.0.3.0/24 | us-east-1b | `subnet-``026058e32f09c28af` | `rtb-``0f45fc46edec61d8f`
    | `igw-``01769bff334dcc035` (IGW) | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Private | 10.0.4.0/24 | us-east-1a | `subnet-``08e16157c15cefcbc` | `rtb-``08572c332e7e4f14e`
    | `nat-``05e34091f53f10172` (NAT-GW) | No (default) |'
  prefs: []
  type: TYPE_TB
- en: Technically, you can still assign a public IP to a private subnet EC2 instance,
    but there's no default gateway to the internet (IGW). Therefore, a public IP will
    just be wasted and it won't have connectivity from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Now if you launch an EC2 instance on the public subnet, it becomes public facing,
    so you can serve your application from this subnet.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you launch an EC2 instance on the private subnet, it can
    still access the internet through the NAT-GW, but there will be no access from
    the internet. However, it can still access it from the EC2 host on the public
    subnet. So, ideally, you can deploy internal services such as databases, middleware,
    and monitoring tools on the private subnet.
  prefs: []
  type: TYPE_NORMAL
- en: Security group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once VPC and subnets with related gateways/routes are ready, you can create
    EC2 instances. However, at least one access control needs to be created beforehand;
    this is called a **security group**. It can define ingress (incoming network access)
    and egress (outgoing network access) firewall rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, a security group and a rule for `public` subnet hosts
    are created that allows SSH from your machine''s IP address, as well as open HTTP
    (`80/tcp`) world-wide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a security group for a `private` subnet host that allows SSH from
    the `public` subnet host. In this case, specifying a public subnet security group
    ID (`sg-03973d9109a19e592`) instead of a CIDR block is convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When you define a security group for a public subnet, it's highly recommended
    that it's reviewed by a security expert. This is because, once you deploy an EC2
    instance onto the public subnet, it has a public IP address and then everyone
    including crackers and bots are able to access your instances directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, there are two security groups that have been created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Security group ID** | **Allow ssh (22/TCP)** | **Allow HTTP
    (80/TCP)** |'
  prefs: []
  type: TYPE_TB
- en: '| Public | `sg-03973d9109a19e592` | Your machine `(98.234.106.21)` | `0.0.0.0/0`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Private | `sg-0f4058a729e2c207e` | `public sg (sg-03973d9109a19e592)` | `public
    sg (sg-03973d9109a19e592)` |'
  prefs: []
  type: TYPE_TB
- en: EC2 and EBS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EC2 is one important service in AWS that you can use to launch a VM on your
    VPC. Based on hardware spec (CPU, memory, and network), there are several types
    of EC2 instances that are available on AWS. When you launch an EC2 instance, you
    need to specify VPC, subnet, security group, and SSH keypair. Consequently, all
    of these must be created beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of previous examples, the only last step is `ssh-keypair`. Let''s make
    `ssh-keypair`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few minutes, check the EC2 instance''s status on the AWS web console;
    this shows a `public` subnet host that has a public IP address. On the other hand,
    a private subnet host doesn''t have a public IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fe63571-abd1-42bd-bc2e-a14fe5cf10cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s use your SSH private key to log in to the EC2 instance using the IPv4
    public IP address, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you''re in the public subnet host (`54.208.77.168`), but this host also
    has an internal (private) IP address because it''s deployed in the `10.0.1.0/24`
    subnet, therefore the private address range must be `10.0.1.1`—`10.0.1.254`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s install the `nginx` web server on the public host as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, go back to your machine and check the website for `54.208.77.168`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, within the same VPC, there''s reachability for other availability
    zones; therefore, you can SSH from the EC2 host on the public subnet to the private
    subnet host (`10.0.2.116`). Note that we''re using the `ssh -A` option that forwards
    `ssh-agent`, so there''s no need to create a `~/.ssh/id_rsa` file on the EC2 host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In addition to EC2, there's another important functionality named disk management.
    AWS provides a flexible disk management service called **Elastic Block Store**
    (**EBS**). You may create one or more persistent data storage that can attach
    to an EC2 instance. From an EC2 point of view, EBS is one of HDD/SSD. Once you
    terminate (delete) an EC2 instance, EBS and its contents may remain and then reattach
    to another EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, one volume that has 40 GB capacity is created and
    then attached to a public subnet host (instance ID, `i-0f2750f65dd857e54`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After attaching the EBS volume to the EC2 instance, the Linux kernel recognizes
    `/dev/xvdh` as specified, and then you need to do partitioning in order to use
    this device, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/455be1b3-53f8-42c3-ac89-885db824cd05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we made one partition as `/dev/xvdh1`, so you can create a
    filesystem in `ext4` format on `/dev/xvdh1` and then you can mount to use this
    device on an EC2 instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99c77560-f363-4c26-b0ec-f5ff734a8252.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After unmounting the volume, you are free to detach this volume and then re-attach
    it whenever needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: ELB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS provides a powerful software-based load balancer called **classic load balancer**.
    This was known as **Elastic Load Balancer** (**ELB**), which allows you to load
    balance network traffic to one or multiple EC2 instances. In addition, ELB can
    offload SSL/TLS encryption/decryption and it supports multi-availability zone.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, why is it a classic load balancer in particular? This is because AWS introduced
    new types of load balancers: network load balancer (for L4) and application load
    balancer (for L7). Therefore, ELB became classic. However, while ELB is stable
    and robust, Amazon EKS will use load balancer by default, so we keep using ELB.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, an ELB is created and associated with a public subnet
    host, `nginx` (`80/TCP`). Because ELB also needs a security group, create a new
    one for this, first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Overall, we''ve discussed how to configure AWS components. The following is
    a summary and diagram about major components and relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: One VPC that has an **Internet Gateway** (**IGW**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two subnets (public and private) on `us-east-1a`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two subnets (public and private) on `us-east-1b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One NAT-GW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One public EC2 instance on public subnet with EBS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One private EC2 instance on private subnet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ELB that forwards the traffic to a public EC2 instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/842d8b03-f45c-405b-a3ac-e006629cce9d.png)'
  prefs: []
  type: TYPE_IMG
- en: Amazon EKS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've discussed some AWS components that are quite easy for setting up networks,
    virtual machines, storage, and load balancers. Consequently, there are a variety
    of ways to set up Kubernetes on AWS such as kubeadm ([https://github.com/kubernetes/kubeadm](https://github.com/kubernetes/kubeadm)),
    kops ([https://github.com/kubernetes/kops](https://github.com/kubernetes/kops)),
    and kubespray ([https://github.com/kubernetes-sigs/kubespray](https://github.com/kubernetes-sigs/kubespray)).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, since June 2018, AWS starts to provide a new Service, which is
    called Amazon Elastic Container Service for Kubernetes ([https://aws.amazon.com/eks/](https://aws.amazon.com/eks/)),
    in short **EKS**. This is similar to Google Kubernetes Engine ([https://cloud.google.com/kubernetes-engine/](https://cloud.google.com/kubernetes-engine/))
    and Azure Kubernetes Service ([https://docs.microsoft.com/en-us/azure/aks/](https://docs.microsoft.com/en-us/azure/aks/)),
    the managed Kubernetes service.
  prefs: []
  type: TYPE_NORMAL
- en: AWS also provides another container orchestration service that's called Amazon
    **Elastic Container Service** (**ECS**) [https://aws.amazon.com/ecs/](https://aws.amazon.com/ecs/).
    AWS ECS isn't a Kubernetes service, but it's fully integrated into AWS components
    to launch your container application.
  prefs: []
  type: TYPE_NORMAL
- en: AWS EKS uses AWS components such as VPC, security groups, EC2 instance, EBS,
    ELB, IAM, and so on, to set up a Kubernetes cluster. This also manages the Kubernetes
    cluster that patches and replaces the problematic component 24/7\. As a result
    of the constant management, the user will offload the efforts of installation,
    configuration and monitoring to the Kubenetes cluster, while only needing to pay
    AWS on an hourly basis.
  prefs: []
  type: TYPE_NORMAL
- en: It's beneficial for the user that AWS provides a fully tested combination of
    AWS components and Kubernetes versions. This means that the user can start to
    use the production grade of Kubernetes on AWS within minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore AWS EKS to learn how AWS integrates Kubernetes into AWS components.
  prefs: []
  type: TYPE_NORMAL
- en: Deep dive into AWS EKS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AWS EKS has two main components. These components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Control plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Worker nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control Plane is the managed Kubernetes master by AWS, which includes an `etcd`
    database. AWS helps to deploy the Kubernetes master on multiple availability zones.
    A user can monitor and access the control plane via the AWS Web Console or AWS
    CLI. As well as this, a user can gain access to Kubernetes API server via Kubernetes
    clients such as the `kubectl` command.
  prefs: []
  type: TYPE_NORMAL
- en: As of December 2018, AWS only provides a custom **Amazon Machine Images** (**AMI**)
    for worker nodes. AWS provides neither Web Console nor AWS CLI to create and configure
    the worker nodes yet. Therefore, the user needs to use that AMI to launch EC2
    instance(s) to configure worker nodes manually.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon and Weaveworks made an open source project named `eksctl` ([https://eksctl.io/](https://eksctl.io/)).
    It's easier to deploy an EKS cluster than AWS CLI and some manual steps.
  prefs: []
  type: TYPE_NORMAL
- en: If you have difficulty understanding AWS basics and EKS provisioning, it's recommended
    to use `eksctl` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, AWS provides a CloudFormation template that''s easy to use to
    launch and configure worker nodes, so let''s extend the previous example of VPC
    to set up Amazon EKS. To do that, you need to prepare the following settings beforehand:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the IAM Service Role (defines which AWS user can create EKS resources)
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up the security group (assign to `Control Plane`, then worker nodes use
    this security group to allow access from `Control Plane`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Tag this to a private subnet (to tell Internal ELB that this is a private subnet):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Launching the EKS control plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The EKS control plane is a managed Kubernetes master; you just need to use
    the AWS CLI to specify your IAM, subnets, and security group. This example also
    specifies the Kubernetes version as 1.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This takes around 10 minutes to complete. You can check the status by typing
    `aws eks describe-cluster --name chap10`. Once your control plane status is `ACTIVE`,
    you can start to set up `kubeconfig` to access your Kubernetes API server.
  prefs: []
  type: TYPE_NORMAL
- en: However, AWS integrates Kubernetes API access control with AWS IAM credentials.
    So, you need to use `aws-iam-authenticator` ([https://github.com/kubernetes-sigs/aws-iam-authenticator](https://github.com/kubernetes-sigs/aws-iam-authenticator))
    to generate a token when you run the `kubectl` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simply downloads an `aws-iam-authenticator` binary and installs it to
    the default command search path (for example, `/usr/local/bin`), then verifies
    whether `aws-iam-authenticator` works or not, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you see the `authenticator` token, run the AWS CLI to generate `kubeconfig`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you succeed in creating `kubeconfig`, you can check whether you can access
    the Kubernetes master using the `kubectl` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: At this moment, you don't see any Kubernetes nodes (`kubectl get nodes` returns
    empty). So, you need one more step to add worker nodes (Kubernetes nodes).
  prefs: []
  type: TYPE_NORMAL
- en: You must use the same IAM user that creates a control plane and access the API
    server with `aws-iam-authenticator`. For example, it won't work if you create
    an EKS control plane by the AWS root account and then access the API server through
    one of the IAM users. You can see an error such as You must be logged in to the
    server (Unauthorized) when using kubectl.
  prefs: []
  type: TYPE_NORMAL
- en: Adding worker nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed, AWS doesn't allow the AWS CLI to set up EKS worker nodes. Instead,
    use CloudFormation. This creates the necessary AWS component for worker nodes,
    such as security groups, AutoScaling groups, and IAM Instance Roles. Furthermore,
    the Kubernetes master needs an IAM Instance Role when a worker node joins the
    Kubernetes cluster. It's highly recommended to use the CloudFormation template
    to launch worker nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'CloudFormation execution steps are simple and follow the AWS EKS documentation, [https://docs.aws.amazon.com/eks/latest/userguide/launch-workers.html](https://docs.aws.amazon.com/eks/latest/userguide/launch-workers.html).
    Use the S3 template URL, [https://amazon-eks.s3-us-west-2.amazonaws.com/cloudformation/2018-12-10/amazon-eks-nodegroup.yaml](https://amazon-eks.s3-us-west-2.amazonaws.com/cloudformation/2018-12-10/amazon-eks-nodegroup.yaml),
    and then specify the parameters as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `Stack name` | `chap10-worker` |'
  prefs: []
  type: TYPE_TB
- en: '| `ClusterName` | `chap10 (must be match to EKS control plane name)` |'
  prefs: []
  type: TYPE_TB
- en: '| `ClusterControlPlaneSecurityGroup` | `sg-0fbac0a39bf64ba10 (eks-control-plane)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `NodeGroupName` | `chap10 EKS worker node (any name)` |'
  prefs: []
  type: TYPE_TB
- en: '| `NodeImageId` | `ami-027792c3cc6de7b5b (version 1.10.x)` |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyName` | `my-key` |'
  prefs: []
  type: TYPE_TB
- en: '| `VpcId` | `vpc-0ca37d4650963adbb` |'
  prefs: []
  type: TYPE_TB
- en: '| `Subnets` |'
  prefs: []
  type: TYPE_TB
- en: '`subnet-04b78ed9b5f96d76e (10.0.2.0/24)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subnet-08e16157c15cefcbc (10.0.4.0/24)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**: only private subnets |'
  prefs: []
  type: TYPE_NORMAL
- en: 'CloudFormation execution takes around five minutes to complete, and then you
    need to get the `NodeInstanceRole` value from Outputs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c444c84d-3fe8-4ff8-8db2-ca05f93e4419.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, you can add these nodes to your Kubernetes cluster by adding `ConfigMap`.
    You can download a `ConfigMap` template from [https://amazon-eks.s3-us-west-2.amazonaws.com/cloudformation/2018-12-10/aws-auth-cm.yaml](https://amazon-eks.s3-us-west-2.amazonaws.com/cloudformation/2018-12-10/aws-auth-cm.yaml)
    and then fill out the Instance Role ARN, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few minutes, the worker nodes will be registered to your Kubernetes
    master, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now you can start to use your own Kubernetes cluster on AWS. Deploy your application
    to take a look at this. Note that, based on the preceding instruction, we deployed
    the worker nodes on a private subnet, so if you want to deploy an internet-facing
    Kubernetes Service, you need to use `type:LoadBalancer`. We'll explore this in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud provider on EKS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS EKS integrates Kubernetes cloud provider into AWS components, for instance,
    elastic load balancer and Elastic Block Store. This section explores how EKS integrates
    into AWS components.
  prefs: []
  type: TYPE_NORMAL
- en: Storage class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As of December 2018, if you deploy Kubernetes version 1.10, EKS doesn''t create
    storage classes by default. On the other hand, in version 1.11 or above, EKS creates
    default storage classes automatically. Using the following command, you can check
    whether a storage class exists or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you need to create a storage class to make a storage class. Note
    that AWS EBS and EC2 are zone sensitive. Therefore, EBS and EC2 must be located
    on the same availability zone. Therefore, it''s recommended to create `StorageClass`
    for each availability zone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`PersistentVolumeClaim` can then specify either `gp2-us-east-1a` or `gp2-us-east-1b`
    storage class to provision the persistent volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that worker nodes have a label of `failure-domain.beta.kubernetes.io/zone`,
    so you can specify a `nodeSelector` to deploy the pod to the desired availability
    zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Load balancer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EKS also integrates Kubernetes Service into classic load balancer (also known
    as ELB). When you create a Kubernetes Service by specifying `type:LoadBalancer`,
    EKS creates the Classic ELB instance and security group, and then associates between
    ELB and worker nodes automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you can either create an internet-facing (on the public subnet)
    or internal (on the private subnet) load balancer. If you don't need to serve
    traffic to the external internet, you should use an internal load balancer for
    security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Internal load balancer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create an internal load balancer for the previous `nginx` pod. In order
    to use an internal load balancer, you need to add an annotation (`service.beta.kubernetes.io/aws-load-balancer-internal:
    0.0.0.0/0`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the EKS Cloud provider will create and configure a classic ELB as in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee2077b8-085d-41de-a5c0-dd8f91cb9ff0.png)'
  prefs: []
  type: TYPE_IMG
- en: Since it's an internal ELB, you can't gain access to the ELB from outside of
    the AWS network, for example, from your laptop. However, it's useful to expose
    your application to the outside of the Kubernetes cluster within VPC.
  prefs: []
  type: TYPE_NORMAL
- en: The AWS charges ELB per hour. If your Kubernetes Service serves within Kubernetes
    cluster pods, you may consider using `type:ClusterIP`.
  prefs: []
  type: TYPE_NORMAL
- en: Internet-facing load balancer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating an internet-facing load balancer consists of the same steps as an
    internal load balancer, but there''s no need for an annotation (`service.beta.kubernetes.io/aws-load-balancer-internal:
    0.0.0.0/0`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When you check the AWS Web Console, you can see that Scheme is internet-facing
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b03609b5-46cc-4e08-abae-f62750bd4384.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can access the ELB from your laptop as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f790dfd-bfdb-4ffe-86f4-f937f3e872a1.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screenshots, the EKS cloud provider is integrated
    into Kubernetes Service, which launches a classic ELB. This feature is very powerful
    for scaling out the traffic volume that dispatches to multiple pods.
  prefs: []
  type: TYPE_NORMAL
- en: EKS has also already begun to support the use of **Network Load Balancer** (**NLB**),
    the new version of L4 load balancer in AWS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use NLB, you need an additional annotation. This annotation is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Updating the Kubernetes version on EKS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Kubernetes releases a new version, EKS will follow and provide the latest
    version of Kubernetes for the user in a timely manner. In previous examples, we've
    used Kubernetes version 1.10\. As of December 2018, EKS also supports version
    1.11\. Let's perform the upgrade to see how EKS handles cluster updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical upgrade steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Upgrade the Kubernetes master via the AWS CLI
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new version of worker nodes via CloudFormation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add new worker nodes to the Kubernetes cluster (both old and new worker nodes
    co-exist at this time)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate pods from the old worker node to the new one
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mostly, the worker nodes upgrade requires some manual steps. We'll explore this
    step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading the Kubernetes master
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Upgrading the Kubernetes master involves the simple step of specifying your
    EKS name and desired new version, as shown in the following. This takes around
    30 minutes to complete, based on the condition. Meanwhile, accessing Kubernetes
    API server (via `kubectl`) might fail. Although pods and Services won''t be affected,
    you need to leave enough time to perform this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, the `aws eks update-cluster-version`
    command returns update `id`. You can use this ID to check the upgrade status,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the status changes from `InProgress` to `Successful`, you can see the
    newer version of the API server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Based on differences between older and newer versions of Kubernetes, there are
    some additional migration steps that we might need to follow. For example, change
    the DNS service from `kube-dns` to `core-dns`. You need to follow these steps
    if AWS EKS provides some instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading worker nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After upgrading the Kubernetes master, you can start to upgrade the worker
    nodes. However, again, there''s no AWS CLI support yet, so you need some manual
    steps to upgrade worker nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: Create new worker nodes using the same steps as earlier using CloudFormation.
    However, here, you'll specify the new version of AMI, such as `ami-0b4eb1d8782fc3aea`.
    You can get an AMI ID list from the AWS documentation via [https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html](https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update a security group for both old and new worker nodes to allow network
    traffic between them. You can find a security group ID via the AWS CLI or AWS
    Web Console. For more details on this, please visit the AWS documentation: [https://docs.aws.amazon.com/eks/latest/userguide/migrate-stack.html](https://docs.aws.amazon.com/eks/latest/userguide/migrate-stack.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update `ConfigMap` to add (not replace) new worker nodes Instance ARNs, as
    in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Taint and drain the old nodes to move the pod to the new node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove old nodes from the cluster and update `ConfigMap` again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Upgrading a Kubernetes version is an annoying topic for Kubernetes administrators.
    This is because of Kubernetes' release cycle (which usually occurs every three
    months) and the need to carry out enough compatibility testing.
  prefs: []
  type: TYPE_NORMAL
- en: The EKS upgrade procedure requires AWS knowledge and understanding. This consists
    of many steps and involves some technical difficulty, but it should not be too
    difficult. Because EKS is still a newer service in AWS, it'll keep improving and
    providing easier options to the user in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the public cloud. AWS is the most popular public
    cloud service and it gives APIs the ability to control AWS infrastructure programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, AWS EKS makes it easy to deploy Kubernetes on AWS. Furthermore,
    the control plane manages the master and `etcd` with high availability design
    that offloads huge management efforts.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you need to be aware of AWS basics such as availability zone
    awareness between pod (EC2) and persistent volume (EBS). In addition, you need
    intermediate AWS knowledge such as IAM credentials to gain access to an API server
    and use a worker node Instance Role ARN to register the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, using ALB as ingress controller is available as of December 2018
    ([https://aws.amazon.com/blogs/opensource/kubernetes-ingress-aws-alb-ingress-controller/](https://aws.amazon.com/blogs/opensource/kubernetes-ingress-aws-alb-ingress-controller/)),
    but it also requires additional effort to configure this.
  prefs: []
  type: TYPE_NORMAL
- en: Although AWS keeps improving functionality, open source tools such as `eksctl` indicate EKS
    still requires more improvement for easier use of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 11](d4de05e3-eb24-4e8e-bfd3-e68819b5e66c.xhtml), *Kubernetes on
    GCP*, we'll introduce Google Cloud Platform and Kubernetes Engine, which is a
    pioneer for making a hosted Kubernetes service on Cloud. This is more mature than
    AWS EKS.
  prefs: []
  type: TYPE_NORMAL
