- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitOps with OpenShift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delve into the world of **GitOps** within the context of
    **Red Hat OpenShift**, an approach that revolutionizes the way we deploy, manage,
    and operate containerized applications.
  prefs: []
  type: TYPE_NORMAL
- en: As we journey through this chapter, we will explore the foundational principles
    of GitOps, highlighting how they seamlessly integrate with the robust features
    of Red Hat OpenShift. This combination not only enhances the efficiency and reliability
    of deployments but also aligns with modern DevOps practices, fostering collaboration
    between development and operations teams.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by setting up a local OpenShift environment using **CodeReady
    Containers** (**CRC**), providing a hands-on approach to understanding how OpenShift
    operates and how it can be managed using GitOps principles. From there, we will
    dive into practical examples and best practices, including configuring automated
    deployments, managing application configurations, and ensuring high availability
    and security within your OpenShift cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you are new to OpenShift or looking to enhance your existing workflows,
    this exploration into GitOps will provide valuable insights and techniques for
    optimizing your cloud-native development processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll focus on these key areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Red Hat OpenShift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up GitOps in Red Hat OpenShift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging Red Hat OpenShift’s CI/CD for GitOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation and configuration best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Kubernetes-Red Hat OpenShift comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, ensure you have access to a Red Hat OpenShift cluster or a
    local setup via Red Hat OpenShift Local. Familiarity with GitOps practices and
    tools such as Argo CD, as well as basic development tools such as Git and a code
    editor, is necessary. A foundational understanding of container technology, Kubernetes
    architecture, and YAML syntax will aid in following the practical exercises. Ensure
    a stable internet connection for tool downloads and cluster access. If running
    OpenShift locally, your machine should ideally have at least 16 GB of RAM and
    sufficient storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relevant code and resource files for this chapter can be found in the `Chapter08`
    folder of our dedicated GitHub repository: [https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes](https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Red Hat OpenShift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenShift ([https://www.redhat.com/en/technologies/cloud-computing/openshift](https://www.redhat.com/en/technologies/cloud-computing/openshift)),
    developed by Red Hat, is a leading enterprise Kubernetes platform that offers
    a comprehensive suite of features designed to streamline the deployment, scaling,
    and operations of containerized applications. It extends Kubernetes by simplifying
    many of the complex tasks associated with deploying and managing a containerized
    infrastructure, making it an ideal choice for enterprises looking to implement
    modern DevOps and GitOps practices.
  prefs: []
  type: TYPE_NORMAL
- en: One of the core strengths of OpenShift is its focus on **developer productivity**
    and **operational efficiency**. It provides a rich set of developer tools and
    a user-friendly console that makes it easier for developers to build, deploy,
    and manage their applications. OpenShift’s **integrated development environment**
    (**IDE**) and built-in CI/CD capabilities enable developers to automate much of
    the software delivery process, from code build through to testing, deployment,
    and monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: '**Security** is another area where OpenShift shines. It incorporates built-in
    security features at every level of the application stack, from the **operating
    system** (**OS**) to the network, and up to the application services. This integrated
    approach ensures that security is not an afterthought but is woven into the very
    fabric of the application life cycle. Features such as **Security-Enhanced Linux**
    (**SELinux**) enforced isolation, automated vulnerability scanning, and default
    secure configurations help to protect applications and data from external threats
    and internal misconfigurations.'
  prefs: []
  type: TYPE_NORMAL
- en: SELinux
  prefs: []
  type: TYPE_NORMAL
- en: SELinux is a kernel-integrated security feature that enforces **mandatory access
    control** (**MAC**) policies to enhance system security. It operates on the principle
    of least privilege, restricting system processes and users to the minimal permissions
    needed for their functions. SELinux helps prevent unauthorized access and can
    operate in enforcing mode, where it blocks and logs unauthorized actions, or in
    permissive mode, where it only logs violations without blocking them. This adds
    an important layer of security to Linux-based systems, including OpenShift, by
    controlling access with greater granularity than traditional access controls.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, OpenShift is designed to support a wide range of workloads, from
    traditional monolithic applications to microservices and serverless functions.
    Its flexible architecture supports a variety of programming languages, frameworks,
    and databases, allowing teams to use the tools and technologies that best fit
    their needs. Additionally, OpenShift’s container-native storage and networking
    solutions provide the scalability and performance required for high-demand applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of GitOps, OpenShift provides a powerful platform for implementing
    declarative, version-controlled workflows for infrastructure and application deployment.
    By leveraging OpenShift’s capabilities, teams can achieve higher levels of **automation**,
    **repeatability**, and **consistency**, which are central to the GitOps philosophy.
    With its robust ecosystem, OpenShift enables organizations to streamline their
    deployment pipelines, enhance security, and improve operational efficiency, making
    it an excellent choice for adopting GitOps methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: Red Hat OpenShift environment setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When setting up an OpenShift cluster for learning, testing, or development
    purposes, you have several options to consider, each with its own set of advantages.
    Understanding these alternatives will help you choose the best fit based on your
    objectives, available resources, and technical comfort level:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer Sandbox for OpenShift**: This is an excellent starting point for
    beginners or for those looking to test out OpenShift features without any setup.
    The Developer Sandbox ([https://developers.redhat.com/developer-sandbox](https://developers.redhat.com/developer-sandbox))
    provides a free, pre-configured OpenShift environment. All you need to do is register
    to gain 30 days of free access to a shared OpenShift and Kubernetes cluster. This
    option is ideal for users who prefer to avoid the complexities of manual setup
    and are looking for a quick way to start experimenting with OpenShift capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud-based OpenShift cluster**: Setting up an OpenShift cluster in the cloud
    (Azure, AWS, or GCP) is a robust solution that offers scalability and real-world
    applicability. This approach is suitable for users looking to simulate a production
    environment or to work on larger, more complex projects. However, it’s important
    to note that running a cluster in the cloud can incur costs, depending on the
    cloud provider and the resources consumed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bare metal setup**: Setting up OpenShift Local on bare metal is a challenging
    and resource-intensive task. Unlike in cloud environments, you must manually manage
    networking, storage, and hardware compatibility, requiring a high level of technical
    expertise. The system demands significant memory, multiple CPU cores, and substantial
    storage, which can be daunting for environments not initially designed for such
    loads. While a bare metal installation offers greater control and potential performance
    benefits, it comes with complexities and potential hurdles that need careful planning
    and understanding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Red Hat OpenShift Local**: For those who prefer a local solution, setting
    up an OpenShift cluster on your machine using Red Hat CRC, can be an effective
    approach. This method allows for a more hands-on experience and works well for
    individual learning and development scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red Hat OpenShift Local provides a fast and straightforward method for initiating
    OpenShift cluster construction. Tailored for local machine operation, it streamlines
    the setup and testing process, offering a cloud-like development environment right
    on your desktop. This tool supports various programming languages and simplifies
    the development of container-based applications by providing a minimal, pre-configured
    OpenShift cluster that requires no server-based infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: OpenShift Local enables the creation, building, and deployment of microservices
    directly into Kubernetes-hosted containers, supporting a range of OSs including
    Linux, macOS, and Windows 10\. This makes it an ideal platform for local development
    and testing, mirroring a real OpenShift cluster’s environment.
  prefs: []
  type: TYPE_NORMAL
- en: For the remainder of this chapter, we have chosen to utilize OpenShift Local
    due to its convenience and relevance to local development scenarios. It’s crucial
    to note that running the examples effectively requires a minimum hardware allocation
    of 6 virtual CPUs and 12 GB of memory for the local cluster to operate correctly.
    This requirement ensures that users can experience the full capabilities of OpenShift
    Local in a GitOps context without significant performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, navigate to [https://developers.redhat.com/products/openshift-local/overview](https://developers.redhat.com/products/openshift-local/overview)
    and click on **Install OpenShift on your laptop**, as shown in *Figure 8**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – The Red Hat OpenShift Local (CRC) homepage](img/B22100_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – The Red Hat OpenShift Local (CRC) homepage
  prefs: []
  type: TYPE_NORMAL
- en: To proceed with the setup of the cluster, it is necessary to download the installer
    by creating a Red Hat account if you do not already have one. From the displayed
    page (*Figure 8**.2*), choose the installer corresponding to your OS (Linux, Windows,
    or macOS) where you plan to install the cluster. Additionally, make sure to select
    the **Download pull secret** or **Copy pull secret** option, as the pull secret
    will be required during the installation process. Remember, you can always return
    to this page if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Starting web page for downloading the CRC installer based on
    the target OS](img/B22100_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Starting web page for downloading the CRC installer based on the
    target OS
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it’s important to note that a detailed step-by-step guide for
    installation is beyond the scope of this text. However, you can find comprehensive
    instructions in the official documentation provided by Red Hat.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete walkthrough, please visit the following link: https://access.redhat.com/documentation/en-us/red_hat_codeready_containers/1.0/html/getting_started_guide/getting-started-with-codeready-containers_gsg#doc-wrapper.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This resource outlines all necessary steps to establish your local OpenShift
    cluster. As a standard procedure to verify the correctness of the installation,
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Troubleshooting OpenShift CRC setup issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting up your environment can be an elaborate process with potential difficulties.
    It requires careful attention to detail and an understanding of system configurations
    and dependencies. While following the provided guidelines and documentation can
    streamline the process, you may still encounter unexpected challenges. It’s important
    to approach this setup with patience and be prepared to engage in some troubleshooting
    to address any issues that arise. Remember to properly start the cluster by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This command ensures that your CRC instance starts with the specified amount
    of computational resources: 6 CPUs and 12288 MB (approximately 12 GB) of memory.
    These settings are important for the optimal performance of your OpenShift cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you experience any issues during the setup process, try executing the following
    sequence of commands to troubleshoot and reset your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`crc delete -f`: This forcefully *deletes* the existing CRC instance, clearing
    any current configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crc cleanup`: This command helps *clean up* any residual files or configurations
    left from previous instances, ensuring a clean slate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crc setup`: Re-run the setup command to configure your system again for CRC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crc config unset proxy-ca-file`: This removes any proxy configuration settings
    that might be causing issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crc start --log-level debug`: Start the CRC instance again, this time with
    debug logging enabled. This will provide more detailed output, which can be helpful
    in identifying where the setup process is encountering problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To finalize the setup of our cluster, an additional crucial step is required:
    the installation of the OpenShift `oc`. This tool is essential for interacting
    with OpenShift clusters, allowing users to perform various tasks via the command
    line, such as deploying applications, inspecting cluster resources, and managing
    administrative activities. The `oc` CLI is specifically designed for developers
    and system administrators, offering advanced functionalities that surpass the
    basic features found in Kubernetes. This makes the `oc` CLI a vital component
    for those looking to automate processes via scripts or manage their clusters more
    directly, ensuring efficient operation within the OpenShift ecosystem.'
  prefs: []
  type: TYPE_NORMAL
- en: Detailed steps for installing the `oc` CLI can be found in the official documentation.
    Please visit `oc` CLI for managing your OpenShift clusters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check that `oc` is correctly installed by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output of the preceding command should be like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that our cluster setup is complete, we are ready to progress to the next
    section, where we will focus on setting up GitOps in our Red Hat OpenShift cluster.
  prefs: []
  type: TYPE_NORMAL
- en: By applying GitOps, we can leverage the full potential of our newly configured
    OpenShift environment, ensuring a more efficient and automated operational framework.
    Let’s move forward and explore the exciting capabilities of GitOps within OpenShift.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up GitOps in Red Hat OpenShift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Begin by installing the necessary GitOps tools. Argo CD (see the *Argo CD*
    section in [*Chapter 4*](B22100_04.xhtml#_idTextAnchor065)) is a popular choice
    for OpenShift, as it integrates seamlessly with the Kubernetes environment. You
    can install Argo CD directly into your OpenShift cluster using **OperatorHub**,
    which offers an easy installation process and automatic management of the application
    life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the address of your local OpenShift cluster running on CRC, use the
    following command in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'INFO Loading bundle: crc_vfkit_4.14.12_arm64...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: INFO A CRC VM for OpenShift 4.14.12 is already running
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Started the OpenShift cluster.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The server is accessible via web console at:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: https://console-openshift-console.apps-crc.testing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Log in as administrator:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Username: kubeadmin'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Password: C57Yw-465gL-NXcpv-nri5w'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Log in as user:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Username: developer'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Password: developer'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the ''oc'' command line interface:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ eval $(crc oc-env)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ oc login -u developer https://api.crc.testing:6443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Navigate to [https://console-openshift-console.apps-crc.testing](https://console-openshift-console.apps-crc.testing)
    and log in as `crc start` command, as illustrated in *Figure 8**.3*. This will
    give you full access to the OpenShift cluster’s administrative functionalities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The Cluster page in the Administrator mode](img/B22100_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – The Cluster page in the Administrator mode
  prefs: []
  type: TYPE_NORMAL
- en: In the OpenShift web console, navigate to the left-hand panel and expand the
    **Operators** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on `OpenShift GitOps` to locate the relevant operator for installation.
    This action will bring up the OpenShift GitOps operator, which you can then proceed
    to install on your cluster (refer to *Figure 8**.4* for guidance).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OpenShift Operators
  prefs: []
  type: TYPE_NORMAL
- en: An **OpenShift Operator** is a method of packaging, deploying, and managing
    a Kubernetes application. OpenShift Operators extend the Kubernetes API to create,
    configure, and manage instances of complex stateful applications on behalf of
    a Kubernetes user. They automate the entire life cycle of the software they manage,
    from initial deployment to upgrade to everyday operations, following best practices.
    This approach simplifies the management of complex applications and services,
    allowing developers and operators to focus on the specifics of their applications
    while leveraging the scalability and reliability of Kubernetes systems. Essentially,
    Operators encapsulate the human operational knowledge required to run services
    and provide a more efficient and reliable way to manage applications in a cloud-native
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Navigating to OperatorHub and searching for OpenShift GitOps
    Operator](img/B22100_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Navigating to OperatorHub and searching for OpenShift GitOps Operator
  prefs: []
  type: TYPE_NORMAL
- en: Once you have located the Red Hat OpenShift GitOps operator, click on it to
    view more details. Then, proceed to click on the **Install** button. When prompted,
    leave the default values as they are and continue with the installation process
    (see *Figure 8**.5*). This will initiate the setup of the OpenShift GitOps operator
    on your cluster, equipping your environment with the necessary tools for GitOps
    workflows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – A panel displaying details prior to operator installation](img/B22100_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – A panel displaying details prior to operator installation
  prefs: []
  type: TYPE_NORMAL
- en: For **Installation mode**, select **All namespaces on the cluster (default)**
    to allow the operator to operate across all namespaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Installed Namespace**, choose **Operator recommended Namespace openshift-gitops-operator**,
    which is specifically suggested for the GitOps operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Install** and wait for the installation operations to be completed.
    This might take a few moments. After the installation is finished, click on **View
    Operator** to verify the installation’s success, and ensure everything is set
    up correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While remaining in the **Administrator** mode within the web console, navigate
    to **Create Project** to start a new project. Fill in the project creation form
    with the necessary information, following the guidelines or specifics you have
    for your project (*Figure 8**.6*). This will establish a dedicated namespace for
    your GitOps deployments and related resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Red Hat OpenShift – Create Project](img/B22100_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Red Hat OpenShift – Create Project
  prefs: []
  type: TYPE_NORMAL
- en: Be aware!
  prefs: []
  type: TYPE_NORMAL
- en: The display name of your project can be adjusted according to your preferences,
    but it’s important to remember this name as you will need to use it consistently
    in subsequent steps. Ensure that the name you choose is memorable and relevant
    to your project to avoid confusion later.
  prefs: []
  type: TYPE_NORMAL
- en: Once the project is created, the dashboard for your newly established project
    should appear in the OpenShift web console, as illustrated in *Figure 8**.7*.
    It will provide an overview of your project’s resources, activities, and status.
    Make sure the details align with your expectations and configurations, as this
    dashboard will be central to managing and monitoring your project’s components
    in the upcoming steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Dashboard for the newly created project](img/B22100_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Dashboard for the newly created project
  prefs: []
  type: TYPE_NORMAL
- en: In the OpenShift web console, go to **Operators** | **Installed Operators**.
    Find and click on **Red Hat OpenShift GitOps**, then select **All Instances**
    to view and manage your GitOps operator instances (refer to *Figure 8**.8* for
    guidance).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.8 – List of instances where the operator has been installed and
    its status](img/B22100_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – List of instances where the operator has been installed and its
    status
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the project selected on the top-left is `gitopsk8sdeployments` before
    proceeding. Then, navigate to **Create new** and select **Argo CD** to set up
    a new instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the form that appears, enter `argocd-for-gitops-deployments` into the name
    input box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create an external route for accessing the Argo CD server, click on **Server**
    | **Route** and ensure that **Enabled** is checked. This will allow you to access
    the Argo CD interface externally from your OpenShift cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the **Status** value to change to **Available** as in *Figure 8**.9*.
    This indicates that your Argo CD instance is fully deployed and ready for use
    within your OpenShift cluster. The status change might take a few minutes as the
    system finalizes the setup and deployment processes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.9 – New item displaying the created Argo CD instance for the specific
    namespace](img/B22100_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – New item displaying the created Argo CD instance for the specific
    namespace
  prefs: []
  type: TYPE_NORMAL
- en: Switch to the **Developer** mode in the OpenShift web console and click on **Topology**.
    This view will give you a graphical representation of the resources deployed so
    far, allowing you to visually understand the structure and relationships of your
    applications and services within the selected project.Top of Form
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – A graphical representation of the resources deployed](img/B22100_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – A graphical representation of the resources deployed
  prefs: []
  type: TYPE_NORMAL
- en: 'To further test that Argo CD has been correctly set up, you can use `oc` and
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: NAME                                                     READY   STATUS    RESTARTS   AGE
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: argocd-for-gitops-deployments-application-controller-0       1/1      Running   0          6m1s
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: argocd-for-gitops-deployments-redis-6c9476c7dc-76c6n         1/1      Running   0          6m1s
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: argocd-for-gitops-deployments-repo-server-65cdc966d4-qzpvt   1/1      Running   0          6m1s
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have successfully set up Argo CD and verified its correct installation,
    we are ready to proceed with the deployment. Let’s move forward to the next steps
    where we will utilize our GitOps workflow within the OpenShift environment to
    manage and deploy our applications efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Red Hat OpenShift’s CI/CD for GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we delve into leveraging Red Hat OpenShift’s CI/CD capabilities
    for GitOps. Specifically, we will apply these principles to deploy the weather
    application, which was introduced previously in the *My city weather app* section
    in [*Chapter 4*](B22100_04.xhtml#_idTextAnchor065). Utilizing a deployment YAML
    file, we will orchestrate the application’s rollout on the OpenShift cluster through
    our Argo CD instance, targeting the `gitopsk8sdeployments` namespace. This practical
    example will demonstrate how OpenShift’s CI/CD tools, combined with GitOps methodologies,
    streamline and automate the deployment processes, ensuring a consistent, traceable,
    and efficient application delivery pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore how to integrate these powerful technologies to deploy our weather
    application seamlessly:'
  prefs: []
  type: TYPE_NORMAL
- en: In the OpenShift web console, ensure you are in the **Administrator** mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, navigate to `argocd-for-gitops-deployments-server` in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Routes section of the Administrator mode](img/B22100_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Routes section of the Administrator mode
  prefs: []
  type: TYPE_NORMAL
- en: Click on the URL provided in the `gitopsk8sdeployments` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12 – The login page for the created Argo CD instance for our demo
    project](img/B22100_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – The login page for the created Argo CD instance for our demo project
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve the admin credentials, switch to the **Developer** mode in the OpenShift
    web console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on `argocd-for-gitops-deployments-cluster`. Within this secret’s
    details, find and copy the value of the `admin.password` entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Secrets section of the gitopsk8sdeployments project](img/B22100_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Secrets section of the gitopsk8sdeployments project
  prefs: []
  type: TYPE_NORMAL
- en: Once you access the Argo CD interface, the application list should initially
    be empty, as illustrated in *Figure 8**.14*, since no applications have been deployed
    yet using Argo CD. At this point, you’re ready to create a new application. This
    step will involve defining the source repository, the path within the repository
    where your Kubernetes manifests are located, and the destination where your application
    should be deployed, in this case, the OpenShift local cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Initial empty application list of the Argo CD instance](img/B22100_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – Initial empty application list of the Argo CD instance
  prefs: []
  type: TYPE_NORMAL
- en: To create a new Argo CD application, you have the option to either use the Argo
    CD web UI or the `oc` CLI. If opting for the CLI, as demonstrated in an earlier
    section, you can apply a deployment file (e.g., `argocd-deployment.yaml`) that
    specifies the application’s configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Utilizing the code provided in the repository accompanying this chapter, you
    can create the new application by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'apiVersion: argoproj.io/v1alpha1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kind: Application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: my-weather-app'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'spec:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'destination:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: '''''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'namespace: gitopsk8sdeployments'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'server: ''https://kubernetes.default.svc'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'source:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'path: deployment/base'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'repoURL: ''https://github.com/pietrolibro/gitops-k8s-deployments-book-weather-app.git'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'targetRevision: main'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'sources: []'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'project: default'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'syncPolicy:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'automated: null'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'CreateNamespace: true'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 8.15 – Argo CD instance populated with the newly created application](img/B22100_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – Argo CD instance populated with the newly created application
  prefs: []
  type: TYPE_NORMAL
- en: The app will initially appear in an **OutofSync** status, indicating that the
    actual state of the cluster does not match the desired state defined in the Git
    repository. To resolve this, click on **Sync** to synchronize the app with the
    desired state outlined in your repository. This action will start the deployment
    process according to the configurations defined in your Git repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the application is synchronized, *Figures 8.16-17*, it will align with
    the configurations defined in the manifest. This includes the deployment of two
    replicas, as specified in the manifest settings. The application’s status should
    reflect that it is now in sync with the desired state, with the two replicas running
    as intended within your OpenShift cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Application panel after successful synchronization](img/B22100_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – Application panel after successful synchronization
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Detailed status of deployed resources after synchronization](img/B22100_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.17 – Detailed status of deployed resources after synchronization
  prefs: []
  type: TYPE_NORMAL
- en: To test the GitOps CI/CD method of deployment, you can pull the repository locally
    using Git and then modify the number of replicas specified in the deployment file.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the application code alone will not cause the sync status to be marked
    as out of sync. The sync status is only affected by changes related to the deployment
    (e.g., YAML configuration files). GitOps tools such as Argo CD monitor the state
    of the configuration files in the repository. If there is a discrepancy between
    the desired state defined in the configuration files and the actual state in the
    Kubernetes cluster, it will be marked as out of sync. Therefore, only modifications
    to deployment files (such as YAML files) will impact the sync status, not changes
    to the application code itself.
  prefs: []
  type: TYPE_NORMAL
- en: This action embodies the iterative and controlled changes typical in GitOps
    workflows. If using Git directly is not your preference, you have the alternative
    to edit the file directly on GitHub, which simplifies the process while achieving
    the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have made and committed your changes, the application status in Argo
    CD will shift to **Out of Sync**. This indicates that the actual deployment no
    longer matches the desired state as defined in your Git repository. In our demonstration,
    we are operating under a manual sync approach, meaning that after any changes,
    you will need to manually trigger a sync in Argo CD. This step is essential to
    apply the new configurations, highlighting the GitOps principle where updates
    are made through version-controlled files, with manual intervention kept to a
    minimum to ensure deliberate and recorded changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Application in the OutOfSync status after changes to the manifest
    files](img/B22100_08_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.18 – Application in the OutOfSync status after changes to the manifest
    files
  prefs: []
  type: TYPE_NORMAL
- en: To resynchronize the application and apply the updated configurations, simply
    click the **Sync** button in the Argo CD dashboard. After initiating the sync,
    monitor the process to ensure it completes successfully. Once the synchronization
    is successful, the application’s status will update to reflect that it is now
    in sync with the desired state as defined in your Git repository, incorporating
    the changes you made, such as the updated number of replicas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we transition from understanding the foundational aspects of Red Hat OpenShift
    and Kubernetes, we now shift our focus toward applying automation and configuration
    best Practices within these environments.
  prefs: []
  type: TYPE_NORMAL
- en: Automation and configuration best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenShift is widely adopted for hosting critical applications globally. As such,
    applications are expected to meet high availability standards, often aiming for
    five nines (99.999%) to ensure continuous service delivery. OpenShift assists
    in deploying applications in a highly available manner to mitigate outages, even
    when instances or infrastructure are compromised.
  prefs: []
  type: TYPE_NORMAL
- en: 'This summary outlines some key practices for deploying highly available applications
    on OpenShift:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple replicas**: Deploying multiple pod instances ensures that the deletion
    or failure of a single pod doesn’t lead to downtime. A recommended practice is
    to have at least two replicas for each application to ensure continuity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RollingUpdate` is recommended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`terminationGracePeriodSeconds` as needed to give your applications sufficient
    time to close out tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Probes**: Use **liveness**, **readiness**, and **startup** probes to monitor
    application health. Liveness probes help restart applications in a failed state,
    readiness probes manage traffic flow to the application, and startup probes allow
    time for initial app startup before other probes start monitoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initContainers` or `startupProbes` to ensure dependencies are ready before
    starting your main application and employ readiness probes to maintain health
    checks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PodDisruptionBudgets (PDBs)**: Implement PDBs to limit the number of pods
    that can be simultaneously unavailable during maintenance, thus preserving application
    availability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Autoscaling**: Utilize **HorizontalPodAutoscaler** (**HPA**) and **VerticalPodAutoscaler**
    (**VPA**) to dynamically adjust the number of pod replicas or resources per pod
    based on the current load, ensuring that your application can handle varying levels
    of traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pod topology spread constraints**: Spread your pod replicas across different
    failure domains (e.g., nodes, racks, or zones) to avoid simultaneous downtime
    and ensure better availability and resilience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment strategies**: Use blue/green or canary deployment strategies to
    minimize disruptions during application updates. These strategies enable safer
    rollouts and easier rollback in case of issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For critical applications hosted on OpenShift, adopting these best practices
    will significantly boost availability, resilience, and continuous service delivery,
    meeting and even exceeding enterprise-level expectations and **service-level**
    **agreements** (**SLAs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, factors such as node sizing, resource allocation, and scheduling
    strategies play a vital role in enhancing the performance and dependability of
    your OpenShift framework. Regarding application security, we strongly recommend
    adhering to the following best practices to fortify the security posture of your
    applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Utilize trusted base container images**: Prioritize the use of official or
    vendor-provided container images, as they are rigorously tested, secured, and
    maintained. If you opt for community-supported images, ensure they are from reputable
    sources. Avoid images from unknown origins found in public registries such as
    Docker Hub, as they may pose security risks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regularly update base container images**: Staying updated with the latest
    versions of container images is crucial, as they include the most recent security
    patches and fixes. Implement automated processes in your CI pipeline to pull the
    latest base images during the build process and to trigger rebuilds of your application
    images when new base image updates are released.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Differentiate between build and runtime images**: Separate your build and
    runtime environments by using distinct images for each phase. The build image
    should contain only what is necessary for compiling and building the application,
    while the runtime image should be slimmed down to include only the essentials
    needed for running the application. This approach minimizes the attack surface
    by reducing unnecessary dependencies and vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adhere to restricted security context constraints (SCCs)**: Whenever feasible,
    configure your container images to comply with OpenShift’s restricted SCC. This
    constraint enforces stringent security policies, limiting the potential for security
    breaches. Adapting your applications to operate under the restricted SCC maximizes
    the security level, safeguarding the cluster in the event of an application compromise.
    Refer to OpenShift’s documentation on supporting arbitrary user IDs for additional
    guidance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure inter-component communications**: Ensure that communication between
    application components is secured, particularly if sensitive data is being transmitted.
    While OpenShift’s network is designed to be secure, using **Transport Layer Security**
    (**TLS**) adds an extra layer of protection. For a more streamlined approach,
    consider utilizing **OpenShift Service Mesh**, which can manage TLS, taking the
    burden off individual applications and providing centralized control over security
    policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having explored key practices to enhance application availability, resilience,
    and security within OpenShift, we conclude this section. These guidelines provide
    a foundation for maintaining robust, secure applications that meet enterprise
    standards. As we transition, the forthcoming section will delve into a comparative
    analysis between Kubernetes and Red Hat OpenShift. This comparison will illuminate
    the distinct features and benefits of each platform, helping you understand their
    unique advantages in various operational environments. Let’s proceed to uncover
    the differences and similarities that define Kubernetes and Red Hat OpenShift,
    setting the stage for informed decision making in your container orchestration
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: A comparison of Kubernetes Red Hat OpenShift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Table 8.1* provides a high-level comparison between Kubernetes and OpenShift.
    While Kubernetes offers a flexible and widely adopted container orchestration
    platform, OpenShift provides a more integrated and security-focused enterprise
    solution with extensive support and built-in features for developer productivity
    and operational efficiency.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature/Aspect** | **Kubernetes** | **OpenShift** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Origin** | Open-source project by Google | Red Hat’s enterprise Kubernetes
    distribution |'
  prefs: []
  type: TYPE_TB
- en: '| **Installation** | Manual, requires setup of networking, storage, etc. |
    Streamlined with automated setups and configurations |'
  prefs: []
  type: TYPE_TB
- en: '| **Web UI** | Basic dashboard available | Comprehensive and user-friendly
    console with advanced features |'
  prefs: []
  type: TYPE_TB
- en: '| **Security** | Basic security features: additional tools are often needed
    | Enhanced security with built-in authentication and authorization, SELinux integration
    |'
  prefs: []
  type: TYPE_TB
- en: '| **CI/CD integration** | Plugins and third-party tools required | Built-in
    CI/CD tools such as OpenShift Pipelines and **Source-to-Image** (**S2I**) |'
  prefs: []
  type: TYPE_TB
- en: '| **Networking** | Pluggable **Container Network** **Interface** (**CNI**)
    | Default SDN with additional networking features |'
  prefs: []
  type: TYPE_TB
- en: '| **Storage** | Supports PersistentVolumes with manual configuration | Simplified
    storage integration with automatic provisioning |'
  prefs: []
  type: TYPE_TB
- en: '| **Developer tools** | Limited in-built tools | Extensive tools including
    OpenShift Do (`odo`), S2I, and DevSpaces |'
  prefs: []
  type: TYPE_TB
- en: '| **Monitoring** **and logging** | Basic with third-party integration (e.g.,
    Prometheus) | Integrated monitoring and logging stack |'
  prefs: []
  type: TYPE_TB
- en: '| **Registry** | Requires external or third-party registry | Integrated container
    image registry |'
  prefs: []
  type: TYPE_TB
- en: '| **Enterprise support** | Available through third-party providers | Direct
    support from Red Hat |'
  prefs: []
  type: TYPE_TB
- en: '| **Community** **and support** | Large open-source community | Strong open-source
    community with enterprise support |'
  prefs: []
  type: TYPE_TB
- en: '| **Pricing** | Free, costs associated with cloud providers or infrastructure
    | Subscription-based with various plans for enterprise use |'
  prefs: []
  type: TYPE_TB
- en: Table 8.1 – A Kubernetes and Red Hat OpenShift feature/aspect comparison
  prefs: []
  type: TYPE_NORMAL
- en: In concluding our comparison between Kubernetes and Red Hat OpenShift, we’ve
    uncovered the distinct features, advantages, and considerations of each platform.
    This analysis equips you with the knowledge to make informed decisions based on
    your specific operational needs and goals. As we move forward, let’s apply this
    understanding to further enhance our deployment strategies and operational efficiencies
    within the context of container orchestration and cloud-native development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we embarked on an in-depth exploration of leveraging GitOps
    within the Red Hat OpenShift environment, highlighting the integration of automation
    and configuration best practices to enhance operational efficiency and security.
    We began by setting up a local OpenShift cluster using CRC, providing a sandbox
    for readers to apply real-world applications of GitOps principles. This practical
    approach demystified the process of deploying and managing containerized applications
    using declarative configurations and automated workflows.
  prefs: []
  type: TYPE_NORMAL
- en: We delved into various best practices, from using trusted base images and setting
    appropriate resource limits to implementing robust security measures such as TLS
    for inter-component communication. Each practice was designed to fortify the deployment
    process, reduce vulnerabilities, and ensure applications remain resilient and
    available. By comparing Kubernetes with Red Hat OpenShift, we provided insights
    into how OpenShift extends Kubernetes capabilities, offering enhanced features
    that cater to enterprise needs.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the chapter, the emphasis was placed on hands-on examples, ensuring
    that readers not only understand theoretical concepts but also how to apply them
    effectively in their own OpenShift environments. As we conclude, the knowledge
    and strategies discussed here pave the way for more secure, efficient, and reliable
    application deployments, reflecting the evolving landscape of cloud-native development
    and the increasing importance of GitOps methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the integration of GitOps practices within
    Azure and AWS, unveiling advanced strategies for cloud-native deployments.
  prefs: []
  type: TYPE_NORMAL
