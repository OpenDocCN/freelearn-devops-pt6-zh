- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Using Helm with the Operator Framework
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Helm 与操作符框架
- en: One of the advantages of using Helm is the ability to declaratively define an
    application’s desired state. With Helm, the desired state is managed with templates
    and Helm values, which, when provided using the `install` or `upgrade` commands,
    apply the values to synchronize the live state in a Kubernetes cluster. In previous
    chapters, this was performed by invoking those commands manually. Most recently,
    in [*Chapter 10*](B17979_10.xhtml#_idTextAnchor241), *Automating Helm with CD
    and GitOps*, we used Argo CD as a method of state synchronization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Helm 的一个优势是能够声明式地定义应用程序的期望状态。通过 Helm，期望的状态通过模板和 Helm 值进行管理，当通过 `install`
    或 `upgrade` 命令提供时，这些值会应用于同步 Kubernetes 集群中的实时状态。在前面的章节中，这是通过手动调用这些命令来执行的。最近，在
    [*第 10 章*](B17979_10.xhtml#_idTextAnchor241)，*使用 CD 和 GitOps 自动化 Helm* 中，我们使用
    Argo CD 作为一种状态同步的方法。
- en: Another way changes can be synchronized to a Kubernetes cluster is to use a
    controller that checks periodically that the desired state matches the current
    configuration in the environment. If the state does not match, the application
    can automatically modify the environment to match the desired state. This controller
    is the foundation of applications and is referred to as a **Kubernetes operator**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将更改同步到 Kubernetes 集群的方法是使用一个控制器，该控制器定期检查期望的状态是否与环境中的当前配置匹配。如果状态不匹配，应用程序可以自动修改环境以匹配期望的状态。这个控制器是应用程序的基础，通常被称为**Kubernetes
    操作符**。
- en: In this chapter, we will create a Helm-based operator that helps ensure that
    the desired state always matches the live state of the cluster. If it does not,
    the operator will execute the appropriate Helm commands to reconcile the state
    of the environment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个基于 Helm 的操作符，帮助确保期望的状态始终与集群的实时状态匹配。如果不匹配，操作符将执行相应的 Helm 命令以协调环境的状态。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding Kubernetes operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 操作符
- en: Understanding the Guestbook operator control loop
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Guestbook 操作符控制循环
- en: Using Helm to manage operators, **Custom Resource Definitions** (**CRDs**),
    and **Custom Resources** (**CRs**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Helm 管理操作符，**自定义资源定义**（**CRDs**）和**自定义资源**（**CRs**）
- en: Cleaning up
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need to have the following technologies installed
    on your local machine:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你需要在本地机器上安装以下技术：
- en: minikube
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: minikube
- en: Helm
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm
- en: kubectl
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl
- en: In addition to these tools, you should find the Packt repository containing
    resources associated with the examples on GitHub at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm).
    This repository will be referenced throughout this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些工具之外，你还应该在 GitHub 上找到包含与示例相关资源的 Packt 仓库，网址为 [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm)。本章将会多次引用这个仓库。
- en: Understanding Kubernetes operators
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 操作符
- en: One of the fundamental principles of Kubernetes is that the current state of
    resources within the cluster matches the desired state, a process known as the
    **control loop**. The control loop is an ongoing, non-terminating pattern of monitoring
    the state of the cluster through the use of controllers. Kubernetes includes numerous
    controllers that are native to the platform, with examples ranging from admission
    controllers that intercept requests made to the API server to replication controllers
    that ensure the configuration of pod replicas.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的基本原则之一是集群中资源的当前状态与期望状态相匹配，这个过程被称为**控制循环**。控制循环是一种持续不断的模式，通过使用控制器监控集群的状态。Kubernetes
    包含多个原生控制器，例子包括从拦截请求的准入控制器到确保 Pod 副本配置的复制控制器。
- en: As interest in Kubernetes began to grow, the combination of providing users
    with the ability to extend the capabilities of the platform, as well as a way
    to provide more intelligence around managing the life cycle of applications, led
    to the creation of a couple of important features to support Kubernetes development.
    First, the introduction of CRDs enabled users the ability to extend the default
    Kubernetes API in order to create and register new types of resources. Registering
    a new CRD creates a new resource path on the Kubernetes API server. For example,
    registering a new CRD for an object type called `kubectl get Guestbook` can now
    be used to view all Guestbook objects that are currently available. With this
    new capability realized, developers could now create controllers of their own
    to monitor these types of CRs and manage the lifecycle of applications through
    the use of CRDs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Another major feature that helped to shape the developer experience in Kubernetes
    included advances in the types of applications deployed to Kubernetes. Instead
    of small and simple applications, more complex and stateful applications were
    being deployed more frequently. Typically, these types of advanced applications
    require a higher level of management and maintenance, such as *day 2* activities
    including backups, restorations, and upgrades. These tasks extend beyond the typical
    types of controllers that are found natively in Kubernetes, as deep knowledge
    related to the application being managed must be embedded within. This pattern
    of using a CR to manage applications and their components is known as the **Operator**
    pattern. First coined by the software company **CoreOS** in 2016, operators aim
    to capture the knowledge that a human operator would have for managing the lifecycle
    of an application. Operators are packaged as normal containerized applications,
    deployed within pods, that react on changes to the API against CRs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators are commonly written using a framework called **kubebuilder**, which
    contains features that simplify the creation of CRs and the interaction with a
    Kubernetes environment. Several additional frameworks have since been created
    to further extend the capabilities to support operator development. One such popular
    toolkit is the **Operator Framework**, which provides end users with the ability
    to create operators using one of the following three technologies:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**Go**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ansible**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Helm**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go-based operators leverage the Go programming language to implement control
    loop logic. Ansible-based operators leverage the Ansible CLI tool and Ansible
    playbooks to manage the state of resources. Ansible is a popular open source configuration
    management tool.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on Helm-based operators. Helm operators base
    their control loop logic on Helm charts and a subset of features provided by the
    Helm CLI. As a result, they represent an easy way for Helm users to implement
    their own operators.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of operators, let’s continue by creating our own operator
    using Helm.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Guestbook operator control loop
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will write a Helm-based operator that will be used to install
    the Guestbook Helm chart. This chart can be found in the Packt repository at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/helm-charts/charts/guestbook](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/helm-charts/charts/guestbook).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates how the Guestbook operator will function
    once it has been deployed:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_11.01_B17979.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The Guestbook operator control loop
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The Guestbook operator constantly watches for the creation, deletion, or modification
    of Guestbook CRs. When a Guestbook CR is created, the operator will install the
    Guestbook Helm chart, and when the CR is modified, it upgrades the release accordingly
    so that the state of the cluster matches the desired intent as defined by the
    CR. Similarly, when the CR is deleted, the operator uninstalls the release.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of how the operator’s control loop will function, let’s
    set up an environment where the operator can be built and deployed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a local development environment
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to create a Helm operator, you will need the following CLI tools at
    a minimum:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '`operator-sdk`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A container management tool, such as `docker`, `podman`, or `buildah`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `operator-sdk` CLI is a toolkit used to help develop Kubernetes operators.
    It contains inherent logic to simplify the operator development process. Under
    the hood, `operator-sdk` requires a container management tool that it can use
    to build the operator image. The supported container management tools are `docker`,
    `podman`, and `buildah`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Installing the `operator-sdk` CLI is easy, as you can simply download a release
    from GitHub at [https://github.com/operator-framework/operator-sdk/releases](https://github.com/operator-framework/operator-sdk/releases).
    However, the process used to install `docker`, `podman`, or `buildah` varies greatly
    depending on your operating system; not to mention, Windows users will not be
    able to use the `operator-sdk` toolkit natively.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the minikube `operator-sdk` toolkit onto minikube and use the minikube
    VM as an environment to create the operator.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start the minikube VM:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the VM has started, proceed by following these steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Access the VM by running the `minikube ssh` command:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once inside the VM, you need to download the `operator-sdk` CLI. This can be
    accomplished using the `curl` command. Note that the `operator-sdk` version used
    during writing was version `v1.20.0`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To download this version of the `operator-sdk` CLI, run the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once downloaded, you will need to change the permission of the `operator-sdk`
    binary to be user-executable. Run the `chmod` command to make this modification:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, move the `operator-sdk` binary to a location managed by the `PATH` variable,
    such as `/usr/local/bin`. Because this operation requires root privileges, you
    will need to run the `mv` command using `sudo`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, verify your `operator-sdk` installation by running the `operator-sdk
    version` command:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As an additional step, you should also clone the Packt repository in your minikube
    VM since we will need it later to build our Helm operator. Run the following commands
    to install `git` and clone the repository in your VM (notice that we will also
    install `make`, which is necessary for building our operator image later):'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that you have a local development environment created in the minikube VM,
    let’s begin writing the Guestbook operator. Note that an example of the operator
    code is located in the Packt repository at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter11/guestbook-operator](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter11/guestbook-operator).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding the operator file structure
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to Helm charts themselves, Helm operators built by the `operator-sdk`
    binary have a specific file structure that must be adhered to. The file structure
    is explained in the following table:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '| **File/folder** | **Definition** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| `Dockerfile` | Used to build the operator image |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| `Makefile` | Provides a convenient set of targets for building the operator
    image and deploying it to Kubernetes |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| `PROJECT` | Provides `operator-sdk` metadata |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| `config/` | Contains Kubernetes resource manifests for CRDs, CRs, and the
    operator instance |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| `helm-charts/` | Contains the Helm charts that the operator is in charge
    of installing |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| `watches.yaml` | Defines the CRs that the operator is in charge of monitoring
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: Table 11.1 – The operator-sdk file structure
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'This file structure can be easily created using the `operator-sdk init` and
    `operator-sdk create api` commands. Let’s walk through this process to create
    a `Guestbook` kind of a custom API version, `demo.example.com/v1alpha1`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new folder for the operator and `cd` inside the newly created
    directory:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, use the `operator-sdk init` command to initialize the project:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice the usage of the `--plugins helm` parameter. This specifies that our
    project is a Helm operator and provides the necessary project scaffolding. The
    `–domain example.com` parameter specifies the Kubernetes API group that will be
    used for the CR. However, the command has not yet created the Guestbook CRD and
    control loop logic. This will be handled in the next step.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `operator-sdk create api` command to create the Guestbook CRD and associated
    manifests:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You might see a warning about RBAC rules, but this can safely be ignored for
    this example. In practice, you should always ensure that the RBAC rules follow
    the principle of least privilege.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: With the Guestbook operator successfully scaffolded, let’s build the operator
    and push it to a container registry, where we will later pull the image for deployment.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Building the operator image
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the files generated by `operator-sdk` was `Makefile`, which contains
    targets for building your operator image and pushing it to a container registry.
    However, before we can build our image, we need to have access to a container
    registry.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B17979_08.xhtml#_idTextAnchor210), *Publishing to a Helm Chart
    Repository*, we used the GitHub container registry located at `ghcr.io` to publish
    images. We will use the same registry for publishing our Guestbook operator.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: In order to publish to `ghcr.io`, you need to have first created a **Personal
    Access Token** (**PAT**). If you have already created one in [*Chapter 8*](B17979_08.xhtml#_idTextAnchor210),
    *Publishing to a Helm Chart Repository*, you do not need to create a new one (unless
    it has expired or you have misplaced the token).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you do need to create a PAT, you can follow these steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Log into GitHub. Once you are logged in, from the upper-right corner of the
    page, select your profile picture and click on **Settings** from the drop-down
    menu.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Developer Settings** and select **Personal Account Token**.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Generate New Token** button to initiate the token creation process.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a unique name for the token, such as `Learn Helm`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the date the token will expire. It is a recommended practice to specify
    an expiration date as it follows security best practices.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the scopes (permissions) granted to the token. The following scopes
    are required for managing content within the container registry:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`read:packages`'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`write:packages`'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`delete:packages`'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Generate Token** button to create the token.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to copy the token before navigating away from the page. If you navigate
    away from the page before noting the content of the token, it can be regenerated
    at any time. However, the previously specified value will no longer be valid.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created your PAT and copied the access token, you can log into
    the `ghcr.io` registry from within your minikube VM by using the `docker login`
    command. For the `Username` prompt, provide your GitHub username, and for `Password`,
    paste the PAT token:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once you have logged into the registry, you can continue by building and deploying
    your operator image. To do this, we can use the `make` utility to run different
    Makefile targets:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define the image name. The Makefile defaults the image name
    to `controller:latest`. We can give a more descriptive name by setting the `IMG`
    environment variable:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Be sure to substitute your GitHub username when setting the `IMG` variable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can begin the image build using the `docker-build` Makefile target:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the build is successful, you will see the `Successfully tagged` message
    followed by the container image name and tag. Additionally, you can use the `docker
    images` command to verify the image was created:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we can push our image using the `docker-push` target:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By default, your image will be private after you successfully push to `ghcr.io`.
    To avoid requiring the need for specifying a Kubernetes pull secret to access
    the image, we can update the image settings to make the image publicly available.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in GitHub, select your profile picture from the upper-right corner of
    the page, and choose `guestbook-operator` image (the guestbook image from [*Chapter
    8*](B17979_08.xhtml#_idTextAnchor210), *Publishing to a Helm Chart Repository*,
    is visible in the screenshot, too):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – The GitHub Packages page'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.02_B17979.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – The GitHub Packages page
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Next, select the `guestbook-operator` package. On the far right of the screen,
    select **Package Settings**, then update the **Change Visibility** setting to
    **Public**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: If you were able to update your image’s visibility to **Public**, then you have
    successfully pushed your image and can now access it without requiring credentials.
    Let’s continue by deploying your operator to Kubernetes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the Guestbook operator
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to building the operator, the deployment of our Guestbook operator
    can be performed using a set of Makefile targets. The Makefile generated by `operator-sdk`
    contains four targets related to the installation or removal of the operator:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '`install`: This installs CRDs onto the Kubernetes cluster. This target adds
    the Guestbook API to the cluster.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uninstall`: This uninstalls CRDs from the Kubernetes cluster. This target
    removes the Guestbook API from the cluster.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deploy`: This installs CRDs and deploys the Guestbook operator to the Kubernetes
    cluster. We’ll use this target later for the deployment.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`undeploy`: This undeploys (or removes) the CRDs and Guestbook operator instance
    from the Kubernetes cluster.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under the hood, each target uses `kubectl` and a configuration management tool
    called `config` folder. Kustomize is a tool that, at a high level, uses `kustomization.yaml`
    files that specify the Kubernetes manifests that will be applied. Also, it adds
    patches and common configurations to each manifest, such as the target namespace
    and resource names.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the `config` folder contents are shown in the following table:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '| **Folder** | **Definition** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| `config/crd/` | Contains the CRDs for extending the Kubernetes API. For our
    Guestbook operator, there is only one CRD. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| `config/default/` | Contains a parent `kustomization.yaml` file for applying
    CRD, RBAC, and operator (also referred to as *manager*) resources. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| `config/manager/` | Contains a deployment resource for creating the operator
    (or `manage`r) instance. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| `config/manifests/` | A superset of the `config/default/` folder. Here, `config/manifests`
    applies CRD, RBAC, and operator resources, but it also applies an example Guestbook
    CR and a *scorecard*, which is used for testing the operator. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `config/manifests/` | `config/default/` 文件夹的超集。在这里，`config/manifests` 应用
    CRD、RBAC 和操作器资源，还应用了一个示例 Guestbook CR 和一个 *scorecard*，用于测试操作器。 |'
- en: '| `config/prometheus/` | Contains a Prometheus `ServiceMonitor` resource for
    tracking metrics. This is disabled by default but can be enabled in the `kustomization.yaml`
    file located under `config/default/`. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `config/prometheus/` | 包含用于跟踪指标的 Prometheus `ServiceMonitor` 资源。默认情况下禁用，但可以在位于
    `config/default/` 下的 `kustomization.yaml` 文件中启用。 |'
- en: '| `config/rbac/` | Contains `Role`, `RoleBinding`, and `ServiceAccount` resources.
    These grant the operator permission to manage Guestbook resources. They also create
    Guestbook editor and viewer roles for users throughout the Kubernetes cluster.
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `config/rbac/` | 包含 `Role`、`RoleBinding` 和 `ServiceAccount` 资源。这些资源授予操作器管理
    Guestbook 资源的权限。它们还为 Kubernetes 集群中的用户创建 Guestbook 编辑和查看角色。 |'
- en: '| `config/samples/` | Contains an example Guestbook manifest. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `config/samples/` | 包含一个示例 Guestbook 清单。 |'
- en: '| `config/scorecard/` | Contains manifests for testing the operator. They are
    unused by default. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `config/scorecard/` | 包含用于测试操作器的清单。默认情况下未使用。 |'
- en: Figure 11.4 – The contents of the config folder
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 配置文件夹的内容
- en: 'When we run the `make` deploy command, Kustomize targets the `kustomization.yaml`
    file from `config/default/` to apply resources from the `config/crd/`, `config/manager/`,
    and `config/rbac/` directories. Then, when the operator is installed, we will
    apply the Guestbook CR, which is located at `config/samples/demo_v1alpha1_guestbook.yaml`.
    Let’s take a look at a snippet from the `demo_v1alpha1_guestbook.yaml` file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `make deploy` 命令时，Kustomize 会定位 `config/default/` 中的 `kustomization.yaml`
    文件，并应用 `config/crd/`、`config/manager/` 和 `config/rbac/` 目录中的资源。然后，当操作器安装完成后，我们将应用位于
    `config/samples/demo_v1alpha1_guestbook.yaml` 的 Guestbook CR。让我们来看一下 `demo_v1alpha1_guestbook.yaml`
    文件中的一个片段：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Does the preceding YAML look familiar? Each of the entries under the `spec`
    stanza reference default values from the Guestbook chart’s `values.yaml` file.
    This is how values are provided when using a Helm operator. Rather than providing
    a `values.yaml` file, users write values in the Guestbook CR. Then, when the resource
    is applied, the operator consumes the values and deploys the application accordingly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的 YAML 看起来熟悉吗？`spec` 部分下的每个条目引用了 Guestbook chart 中 `values.yaml` 文件中的默认值。这是使用
    Helm 操作器时提供值的方式。用户并不提供一个 `values.yaml` 文件，而是在 Guestbook CR 中写入值。然后，当资源应用时，操作器会消费这些值并相应地部署应用程序。
- en: 'With a basic understanding of the operator’s `config/` folder and `Makefile`
    targets, let’s deploy the Guestbook operator by following these steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 基于对操作器 `config/` 文件夹和 `Makefile` 目标的基本理解，我们可以通过以下步骤部署 Guestbook 操作器：
- en: In order to deploy the Guestbook operator, we need to be authenticated to the
    Kubernetes cluster. Because the minikube VM does not have `kubectl` installed,
    nor `kubeconfig`, which we can use for authentication, it will be simpler to deploy
    the operator from your host machine.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了部署 Guestbook 操作器，我们需要认证到 Kubernetes 集群。由于 minikube 虚拟机中没有安装 `kubectl`，也没有
    `kubeconfig`，我们可以用来进行身份验证，因此从主机机器部署操作器会更简单。
- en: 'Exit the minikube VM by running the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令退出 minikube 虚拟机：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The resources we created in the minikube VM are also located in the Packt repository
    under the `chapter11/guestbook-operator/` folder. You can clone this repository
    and navigate to the `guestbook-operator` folder by running the following commands:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 minikube 虚拟机中创建的资源也位于 Packt 仓库中的 `chapter11/guestbook-operator/` 文件夹。你可以克隆该仓库并通过运行以下命令进入
    `guestbook-operator` 文件夹：
- en: '[PRE17]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The files from the Packt repository are the same as the ones you created in
    the minikube VM with one exception. As you might recall from previous chapters,
    the Guestbook Helm chart contains hooks for backing up and restoring the Redis
    database. These hooks require the operator to have permission to manage the `Job`
    and `PersistentVolumeClaim` resources. Because the role generated by `operator-sdk`
    does not include these resources, we added them at the end of the role definition
    located at `chapter11/guestbook-operator/config/rbac/role.yaml`. Here are the
    permissions that we added:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we will use the `make` command to deploy the Guestbook CRD and operator
    to the Kubernetes cluster. Note that Windows users might need to install `make`
    first, which can be done by using the Chocolatey package manager:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Proceed with the operator deployment by setting the `IMG` environment variable
    and running the following `make` command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The operator was installed in a namespace called `guestbook-operator-system`.
    Verify that the pod was deployed successfully in this namespace:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that the operator has been deployed, let’s use it to install the Guestbook
    Helm chart.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the Guestbook application
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using Helm normally as a standalone CLI tool, you would install a Helm
    chart by running the `helm install` command. With a Helm operator, you can install
    a Helm chart by creating a CR.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new namespace for our deployment:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, using the CR located in the Packt repository at `chapter11/guestbook-operator/config/samples/demo_v1alpha1_guestbook.yaml`,
    install the Guestbook Helm chart:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the installation is complete, you’ll see each pod in the ready state:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you created the CR, the operator executed the `helm install` command against
    the Guestbook Helm chart. You can confirm the release was created by running `helm
    list`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Upgrades are performed by reapplying the CR with a different set of values.
    A modified CR is located in the Packt repository at `chapter11/guestbook-operator/config/samples/upgrade-example.yaml`.
    In this file, the `replicaCount` value has been changed to `2`, as opposed to
    `1` in the original CR.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the updated CR by running the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This modification of the Guestbook CR causes the operator to trigger `helm
    upgrade` against the `guestbook-sample` release. As you might recall from [*Chapter
    7*](B17979_07.xhtml#_idTextAnchor196), *Helm Lifecycle Hooks*, the Guestbook chart
    contains an upgrade hook that initiates a Redis backup. If you watch the pods
    in the `chapter11` namespace after modifying the CR, you will see the backup job
    begin, and then you will shortly see two Guestbook pods appear. You will also
    notice that the revision number of the release increased to `2`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Although the revision number increased to `2`, as of writing, one limitation
    of Helm operators is that you cannot initiate a rollback to a previous version
    as you can do when using the CLI. If you attempt to run `helm history` against
    the `guestbook-sample` release, you will notice that only the current revision
    is available in the release history:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is an important difference between using Helm regularly with the CLI and
    using Helm as an operator. Because the release history is not retained, Helm operators
    do not allow you to perform explicit rollbacks. However, `helm rollback` will
    be run implicitly in situations where upgrades fail. This would also trigger any
    rollback hooks that might be defined in the chart.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Helm operators do not retain the release history, one area where they
    excel is in synchronizing the desired and live states of an application. This
    is because the operator constantly watches the state of the Kubernetes environment
    and ensures that the application is always configured to match the CR. In other
    words, if one of the Guestbook application’s resources has been modified, the
    operator will immediately revert the change to synchronize it with the configuration
    defined within the CR. You can see this in action by modifying one of the live
    resources. As an example, we will change the Guestbook deployment’s replica count
    from `2` to `3` and watch the operator revert this change back to `2` immediately
    to resync the state to match the CR. Run the following `kubectl patch` command
    to change the replica count on the deployment from `2` to `3`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Normally, this would create an additional Guestbook pod replica. However, because
    the Guestbook CR currently defines only `2` replicas, the operator quickly changes
    the replica count back to `2` and terminates the additional pod that was created.
    If you actually wanted to increase the replica count to `3`, you would need to
    update the `replicaCount` value on the CR. This process provides the advantage
    of ensuring the desired state matches the live state at all times.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Uninstalling releases created by the Helm operator is as simple as removing
    the CR. Delete the `guestbook-sample` CR to uninstall the release:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can also remove the Guestbook operator and its resources since we will
    not need them in the next section. You can do this by running another `make` command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In general, you should always make sure that you delete the CR first before
    deleting the operator. If you delete the operator before the CR, then the operator
    will not be able to automatically run `helm uninstall`, and you would have to
    run it manually from the command line.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of this chapter, you created a Helm operator and learned how
    to install a Helm chart using an operator-based approach. In the next section,
    we will continue our discussion on operators by investigating how they can be
    managed using Helm.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Using Helm to manage operators, CRDs, and CRs
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we installed the Guestbook operator and CRD by using the `Makefile`
    instance generated by `operator-sdk`. Then, we installed a Guestbook CR using
    `kubectl apply`. While this is an acceptable way of creating these resources,
    we could also install the operator, CRD, and CR by using Helm charts to provide
    a more repeatable solution for installing and managing an operator.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Helm allows you to create CRDs by adding them to a directory called `crds/`
    in your Helm chart. Helm creates CRDs before any of the other resources defined
    under the `templates/` folder, making it simpler to install applications such
    as operators that depend on CRDs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The following file structure depicts a Helm chart that could be used to install
    the Guestbook operator:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Upon installation, this Helm chart will first install the Guestbook CRD. If
    the CRD is already present in the cluster, it will skip the CRD creation and go
    straight into installing the templates. Note that while CRDs can be convenient
    to include in a Helm chart, there are a couple of limitations to be aware of.
    First, Helm does not allow CRDs to contain any Go templating, so CRDs do not benefit
    from parameterization as opposed to typical resources. Also, CRDs cannot be upgraded,
    rolled back, or deleted. Finally, including CRDs in your chart would require the
    user to have elevated cluster-level privileges within the Kubernetes cluster.
    Often, it is administrators who perform operator installations, so this is likely
    to be an acceptable approach.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'The Helm chart that we described earlier could be used to install the Guestbook
    operator, but this is only half of the equation, as end users must still be able
    to create CRs that deploy the Guestbook application. To address this limitation,
    you could create a separate Helm chart that is used for templating a Guestbook
    CR. An example layout for this type of Helm chart is shown in the following file
    structure:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Unlike CRDs, CRs underneath the `templates/` folder benefit from Go templating
    and lifecycle management, as do all other resources. This methodology provides
    the most value when the CR contains complex fields or when other resources must
    be installed alongside the CR. You would also be able to manage the lifecycle
    of your CR with this method, and you would also be able to maintain a history
    of revisions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: However, users would need to be given permission to install Guestbook CRs, since
    this permission would not be included in Kubernetes by default. These permissions
    can be easily added by applying the `guestbook_editor_role.yaml` file under the
    operator’s `config/rbac/` folder. Then, you can create a `RoleBinding` resource
    to assign the editor role to the appropriate users or groups.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an understanding of how operators, CRDs, and CRs can be managed
    with Helm, let’s close out the chapter by cleaning up the Kubernetes environment.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, delete the `chapter11` namespace:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, run the `minikube stop` command to stop your minikube VM.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operators are important for ensuring that the desired state always matches the
    live state. Such a feat allows users to more easily maintain a source of truth
    for resource configuration. Users can leverage a Helm operator to provide this
    type of resource reconciliation, and it is easy to get started because it uses
    Helm charts as its deployment mechanism. When a CR is created, the Helm operator
    installs the associated Helm chart to create a new release. Subsequent upgrades
    are performed when the CR is modified, and the release is uninstalled when the
    CR has been deleted.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: To manage the operator, cluster administrators can create a separate Helm chart
    for creating the operator’s resources and CRDs. Also, end users can create a separate
    Helm chart for creating CRs and other related resources.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss best practices and topics around security
    within the Helm ecosystem.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more about operators and their origins, check out the Kubernetes documentation
    at [https://kubernetes.io/docs/concepts/extend-kubernetes/operator/](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/).
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To discover other operators that have been developed throughout the community,
    check out *OperatorHub* at [https://operatorhub.io](https://operatorhub.io) or
    the *Operators* section of *ArtifactHub* at [https://artifacthub.io](https://artifacthub.io).
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is an operator? How does an operator work at a high level?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between installing a Helm chart with the Helm CLI versus
    a Helm operator?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What toolkit can you use to create Helm operators?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the `install`, `upgrade`, `rollback`, and `uninstall` hooks function
    with a Helm operator?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `crds/` folder in a Helm chart?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
