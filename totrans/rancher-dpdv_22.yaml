- en: '*Chapter 17*: Creating and Using Helm Charts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers Helm, how Helm is used as a package manager for a Kubernetes
    cluster, and how it works. We then will be diving into creating a Helm chart from
    scratch, after which we'll be covering how to publish our new chart to a Kubernetes
    cluster. Finally, we'll cover taking a publicly available chart and customizing
    it to fit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a Helm chart?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does Helm work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do I create a Helm chart?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a Helm chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing a public Helm chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a Helm chart?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm is a package management tool for Kubernetes deployments. Helm is similar
    to packagers such as `deb`/`dpkg` for Debian/Ubuntu-based systems. In that sense,
    a Helm chart is a set of Kubernetes deployment files that have been packaged into
    a single templatized file. In this section, we will cover why we need Helm and
    how it works behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the questions that come up a lot when people start working with Kubernetes
    and Rancher is this: *Why do we need Helm?* But to answer this question, we need
    to understand how deployment was carried out before Helm, which was to have our
    developments as `ingress-nginx` on all your clusters using the same settings,
    images, and so on. Having that as just a flat YAML file that you deploy using
    `kubectl apply -f deployment.yaml` may work fine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The issue that comes into play is this: what happens if one of your clusters
    is different? For example, you have a **Google Kubernetes Engine** (**GKE**) cluster
    and a **Rancher Kubernetes Engine** (**RKE**) cluster that might require different
    images; that is, GKE will use the public Docker Hub image, with your on-premises
    RKE cluster needing to come from a private registry. Without Helm, you are now
    going to need two different YAML files while also ensuring that they both stay
    in sync. Of course, you''ll need more than two different deployment files in the
    real world, so managing these files and keeping them in sync can become a nightmare.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some people tried to solve this problem by writing scripts to find and replace
    values in deployments before deploying them—for example, your master deployment
    files might have their image value being set to something such as `ImageTagPlaceHolder`.
    Then, the script would look for this value and replace it using the `sed` command,
    like so: `` sed ''s/ImageTagPlaceHolder/my-private-registry/g` ``. This process
    works okay if you only update a couple of values, but the process starts breaking
    down once you need to do more complicated customizations. For example, an ingress
    for your `dev.example.com` defined in the `host` section, but in your production
    environment, you''ll need SSL certificate-defined, multiple hosts—that is, `www.example.com`,
    `example.com`, and so on. Doing this with Bash scripting becomes too crazy and,
    more importantly, error-prone.'
  prefs: []
  type: TYPE_NORMAL
- en: Helm addresses this issue by having you define your deployment files as YAML
    files but with variables and `if` statements. The point is that you don't hardcode
    something such as your image tag in your deployment files; instead, you set it
    as a variable (that is, the `image` tag). Then, at the time of deployment, you
    feed values for those variables, and Helm takes care of building the final YAML
    files and then publishing them to the cluster. At the same time, Helm gives us
    the ability to define `if` statements in our deployment file, allowing us to modify
    the deployment based on user and cluster input. We'll be covering how this works
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How does Helm work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have found that the best way to understand how Helm works is to start by understanding
    the directory structure, but first, we need to remember that most public Helm
    charts come as TGZ files, which is a compressed directory. Helm's first step is
    to download this file from a repository and decompress it into the directory structure
    shown in *Figure 17.1*. Note that we'll be covering more about public Helm charts
    later in this chapter under the *Customizing a public Helm chart* section, but
    in this section, we will cover what each of the four directories and files is
    for. We'll then tie them together and walk through how Helm uses them to deploy
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view an example of a Helm chart directory structure here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1 – Helm chart directory structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18053_17_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.1 – Helm chart directory structure
  prefs: []
  type: TYPE_NORMAL
- en: '`Chart.yaml` is a file that defines a chart as a whole, including the name
    of the chart, its version, a description, and more. You can find an example in
    *Figure 17.2* and at [https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch17/hello-world/Chart.yaml](https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch17/hello-world/Chart.yaml).
    As we can see, this file is mainly used to set the metadata for the chart, including
    the name of the chart, a description, keywords, sources, maintainers, and an icon.
    Rancher uses all this data to build its catalog page, which allows you to search
    by keyword and see icons for each chart in a repository. Rancher also expands
    this file using a set of annotations under the `catalog.cattle.io` path to add
    data such as `catalog.cattle.io/certified: rancher`, which tells the user that
    this is a certified chart that is covered under Rancher''s **service-level agreement**
    (**SLA**) and support. You can find an example of Rancher''s monitoring chart
    at [https://github.com/rancher/charts/blob/release-v2.6/charts/rancher-monitoring/100.1.2%2Bup19.0.3/Chart.yaml](https://github.com/rancher/charts/blob/release-v2.6/charts/rancher-monitoring/100.1.2%2Bup19.0.3/Chart.yaml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the `Chart.yaml` example shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2 – Chart.yaml example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18053_17_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.2 – Chart.yaml example
  prefs: []
  type: TYPE_NORMAL
- en: The `templates` directory is one of the most critical parts of a Helm chart
    because this directory is where Helm stores all the template files for an application.
    It is important to note that all files inside this directory should be YAML files.
    Mixing other files into this directory has been known to cause weird bugs in Helm.
    By default, this directory is flat, with each object type being its own file—for
    example, you might have a file called `services.yaml` that includes all service
    records that need to be created, and another file called `ingress.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that resources in a file need to be separated by three
    hyphens (`---`) per the YAML standard. This is great for simple deployments with
    one or two resources per type, but having all your resources in a single file
    can be challenging to manage at scale because the Helm/`kubectl` errors you get
    will have a line number; still, that line number will not be the line file in
    the file but will be the line number for that section. For example, suppose you
    have 10 ingresses defined in a single file, making the total file around 100 lines.
    Suppose you have an issue with the third ingress on *line 2* of that section.
    Your error message is only going to say `error located on line 2`, but you won't
    know which line 2\. Because of this, it is common to break up your template files
    into nested directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might create a folder for each resource type and then create
    a file for each resource (please see *Figure 17.3* for an example). Another example
    is breaking our folders down by component—we might create a folder for our frontend
    application and then have all resources that have made up that component: deployment,
    service, service account, **persistent volume claim** (**PVC**), and so on (please
    see *Figure 17.4*). I prefer sorting by component for any multi-tier application
    so that when I''m working on that component, everything for that component is
    in one spot. It also makes adding new components easy because I''ll just clone
    that whole folder, then go into the folder and start running find and replace
    commands but scoped to the folder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, you can see that in this Helm chart we are grouping
    by component type, meaning that all deployments are in the same folder together,
    the same with all ingresses, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.3 – Helm folder structure by resource type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18053_17_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.3 – Helm folder structure by resource type
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, you'll see that instead of grouping by *type*, we
    are grouping the different parts of the application. For example, we have the
    `apiserver` folder, which includes all resources that make up that component—that
    is, the deployment, ingress, and service. Then, we are repeating this process
    for each of these components of the application—that is, the frontend and the
    reporting service in this example. Personally, this is how I build Helm charts
    as I find it much easier to read, along with making it much easier to copy a component
    from one application to another. For example, I might reuse the frontend `frontend`
    folder into a new chart and start customizing it to fit the new application. The
    grouping-by-resource-type folder structure requires me to go into each folder
    and find all resources that make up that component. This process is, of course,
    error-prone as I might miss a resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the structure here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.4 – Helm folder structure by component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18053_17_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.4 – Helm folder structure by component
  prefs: []
  type: TYPE_NORMAL
- en: 'The file you will be using the most as an end user is `values.yaml`; this is
    because this file sets the default values for the chart. Of course, this can range
    from setting global values such as the repository and the image pull policy to
    custom settings, such as setting database connection strings that will become
    a secret. We''ll be covering this file more in the next section, but the key thing
    to understand is that this file is the configuration file for the chart, and therefore
    having good documentation inside this file is very important. Also, this file
    is designed to be customizable, meaning you can add your own sections and settings.
    For example, you might add a section for each component—that is, for `frontend`,
    `apiserver`, `reporting`, and so on, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.5 – Helm custom values for each component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18053_17_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.5 – Helm custom values for each component
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last important directory is `charts`. This directory greatly expands
    Helm's abilities by allowing you to define dependencies for other charts. For
    example, if we go back to our three-tier application and need a MySQL database
    as part of our deployment, we don't want to write and manage all the different
    resource files that a database running in Kubernetes might need when someone else
    has done all that work for us already. So, in the `charts` directory, we can add
    the official MySQL chart as a subfolder. This sub-folder is handled just like
    a normal Helm folder, meaning it has `Chart.yaml`, `templates`, `values.yaml`,
    and so on. You can, of course, define a dependency inside the `Chart.yaml` file
    using the `helm dependency` command, which handles downloading and updating subcharts
    in the `charts` directory, and this is the preferred method over manually merging
    changes from an external repository into your Helm chart, which—of course—is error-prone
    and time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that if you need to customize a chart outside the
    `values.yaml` file—that is, changing a template file to work around a bug—then
    the `helm dependency` command will overwrite your changes, so it is recommended
    in that case to download the chart into that folder manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we understand the different parts that make up a Helm chart.
    Now, it''s time to walk through a deployment to understand how Helm works. This
    is what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: Helm takes the `values.yaml` file and uses that as a base for its variables,
    at which point any command-line values using the `--set` option will overwrite
    those variables. The critical item here to understand is that any command-line
    setting overwrites anything with `values.yaml` and is only used for settings not
    set via the command-line options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Helm then starts processing the template files, replacing all variables with
    static values. As a part of this step, any `if` statements will be resolved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Helm resolves any flow controls, including `if`/`else` statements. This allows
    you to add/remove sections of your configuration files using `if` statements.
    For example, you might wrap your ingress configuration in an `if` statement, allowing
    you to disable and enable it via the `values.yaml` file. Note that for ingresses,
    this is very common in most public charts. The other most common `if` statement
    is around Kubernetes versions as Kubernetes `if` statements, such as the following:
    if the Kubernetes version is v1.19 or below, use this section; else, use this
    section. This allows your chart to support a wide range of Kubernetes versions.
    You can see an example of this in action by looking at Rancher''s official chart
    template [https://github.com/rancher/rancher/blob/release/v2.6/chart/templates/ingress.yaml](https://github.com/rancher/rancher/blob/release/v2.6/chart/templates/ingress.yaml)
    or by looking at the following screenshot. I would also recommend looking at Helm''s
    official documentation, located at [https://helm.sh/docs/chart_template_guide/control_structures/](https://helm.sh/docs/chart_template_guide/control_structures/):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.6 – Rancher server Helm chart ingress example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18053_17_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.6 – Rancher server Helm chart ingress example
  prefs: []
  type: TYPE_NORMAL
- en: Helm is ready to start making changes to your cluster, but it is important to
    note if you do an air-gapped deployment, it will simply output all the YAML files
    into a directory. You can find an example of this kind of deployment in the Rancher
    install documentation, located at [https://rancher.com/docs/rancher/v2.6/en/installation/other-installation-methods/air-gap/install-rancher/](https://rancher.com/docs/rancher/v2.6/en/installation/other-installation-methods/air-gap/install-rancher/).
    But if you are carrying out a standard install, Helm will start applying changes
    to the cluster in a set order, which can be found at [https://github.com/helm/helm/blob/release-3.0/pkg/releaseutil/kind_sorter.go#L27](https://github.com/helm/helm/blob/release-3.0/pkg/releaseutil/kind_sorter.go#L27).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The vital part of understanding this step is to understand that Helm uses a
    set of ownership labels/annotations to know which objects are under the control
    of that Helm release. Helm automatically applies an `app.kubernetes.io/managed-by:`
    label and `meta.helm.sh/release-name` and `meta.helm.sh/release-namespace` annotations
    to every resource it creates. If these are missing or different from Helm''s expectations,
    Helm will error out with an error message such as the one listed in the following
    screenshot. If you get this error, you have conflicts somewhere between charts—that
    is, two charts are trying to *own* the same object, which is not supported. To
    resolve this, you''ll need to update the labels and annotations to the correct
    release to modify your charts to prevent future conflicts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.7 – Helm ownership error message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18053_17_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.7 – Helm ownership error message
  prefs: []
  type: TYPE_NORMAL
- en: After Helm has run the equivalent of `kubectl apply`, your application should
    start. You can run a post-install hook that runs a job or creates a ConfigMap/Secret
    with most charts running a job that might ping their application in a loop until
    it comes online, at which point the job will complete successfully. You can read
    more about this process in the official documentation at [https://helm.sh/docs/topics/charts_hooks/](https://helm.sh/docs/topics/charts_hooks/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we understand how an install works, the only other item is a Helm upgrade,
    which follows the same process but allows the object that already exists without
    erroring out. However, I usually recommend running Helm with the `helm upgrade
    –i` and `--install` flags, which allows you to use the same command to install
    and upgrade a Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we understand how a Helm chart works. In the next section, we
    are going to create a Helm chart, and in the section after that, we are going
    to deploy the chart.
  prefs: []
  type: TYPE_NORMAL
- en: How do I create a Helm chart?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm makes creating charts very easy by using the `helm create mychart` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will create all base files needed to run a basic Helm chart. You
    can find an example output listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.8 – helm create mychart command creates an example chart'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18053_17_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.8 – helm create mychart command creates an example chart
  prefs: []
  type: TYPE_NORMAL
- en: By default, this command will create a directory with the same name as the chart.
    When adding a Helm chart to a Git repository, it is widespread to rename this
    directory just `chart`, or if this application will have multiple charts from
    the same repository, you'll want to create a `charts` directory and move your
    new chart into that directory, keeping the name something easy to read/understand.
    This, of course, is a personal preference, with some teams choosing to move their
    Helm charts to their own repository.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, your job is to start moving your deployment files into the template
    files. This is where you need to set all your variables that look like `{{ .Values.image.repository
    }}`. This variable suggests starting with the root `values` file. Then, go to
    the `image` section and grab the value for the repository `undertake` section.
    You can, of course, hardcode these values in the template file, but it is highly
    recommended to limit hardcoding values whenever possible and have the values defined
    in your `values.yaml` file. This is a must for any public Helm charts as there
    will be someone who needs to customize these values for their environment, and
    hardcoding the values just makes it harder for them. This is one of the reasons
    that default template files have a lot of settings defined. For example, the `nodeSelector`
    and `tolerations` settings are set up, even though a good number of people will
    never use these settings.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the default template files do not cover all the different types of
    resources, so you might need to create your own. The process that I usually follow
    is to find a public chart with the resource type that I need, then simply copy
    and paste and modify it to suit my needs. Of course, as you create your chart,
    you'll need to test it, which is what we'll be covering in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Helm chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we covered in the last section, now that we have created our Helm chart,
    we need to deploy it to our cluster. This is done in two different ways, with
    the first one being a local chart and the second one being a remote chart—both
    of which we'll be covering in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before publishing it, we need to have the chart files downloaded for local
    Helm charts, which are commonly used while testing a new chart. You''ll run a
    command such as `helm upgrade --install mychart ./chart --namespace mynamespace
    -f ./chart/values.yaml`. The important part of this command is the `./chart/`
    part, which tells Helm where the chart is located—in this example, it can be found
    in the `./chart/` directory. This, of course, should be the root directory of
    the chart—that is, where the `chart.yaml` file, `values.yaml` file, and so on
    are located. This kind of install is also common for use in **continuous integration/continuous
    deployment** (**CI/CD**) pipelines where you want to use Helm to templatize your
    deployments but don''t need to publish them for public/end-user consumption. An
    example of this is being used in the Drone pipeline shown in the following screenshot.
    As you can see, it is using an overwrite value of the Drone build number to set
    the image tag and pass the ingress host as a variable set at the pipeline level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.9 – Helm install locally in a Drone pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18053_17_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.9 – Helm install locally in a Drone pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the Drone pipeline using the Helm command listed in *Figure
    17.9*. For this step, I''m using a custom image that I have created called `supporttools/kube-builder`,
    which handles setting up `kubeconfig` and includes some standard tools such as
    `kubectl` and `helm`. You can see an illustration of this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.10 – kube-builder example Drone step'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18053_17_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.10 – kube-builder example Drone step
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete example pipeline at [https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch17/drone-pipeline-example](https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch17/drone-pipeline-example).
  prefs: []
  type: TYPE_NORMAL
- en: The other Helm deployment type is a remote chart. The main difference is the
    fact that you'll be pointing Helm to a repository (Git or `helm repo update` command.
    Now, in the next section, we'll be covering how to customize a public Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing a public Helm chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the tasks that everyone has to do someday when working with public Helm
    charts is to customize them to add some feature or setting that you need, or—in
    a more likely scenario—fix a bug. For example, some public Helm charts don't include
    the required settings to support **Pod Security Policy** (**PSP**) as enterprises
    and high-secure environments are mainly the only ones that use PSPs in the first
    place. It's something that some community members just don't test. There are,
    of course, many ways to make these kinds of changes to a public Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: But the primary way that I recommend is to fork the GitHub repository, create
    a new branch, and apply any needed changes. In this example, you'll want to add
    a section in the deployment to configure the `securityContext` section of the
    deployment(s) files and add the required `rbac.enable=false` and/or `psp.enabled=false`
    in the `values.yaml` file to allow users to enable and disable this feature as
    needed. Then, once you have made these changes, you'll want to create a **pull
    request** (**PR**) to merge this into the upstream repository. But in the meantime,
    you can deploy using the Helm local install option.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to give back to the open source community when the PR is merged.
    Switching back to the public chart is a simple edit to the Helm command by swapping
    out the local path of the repository name. Of course, make sure you are updating
    documentation and command examples as part of your PR request.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter went over what Helm is and how it takes template files along with
    a set of values to create final deployment files that Helm can publish to a cluster.
    We then dove into creating a Helm chart and some of the best practices for structuring
    your chart for ease of use. We then went over how to install our newly created
    chart and integrate this process into a Drone pipeline. We then covered the topic
    of public Helm charts and how to customize them.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover cluster resource management and capacity planning;
    as we all know, running **development-operations** (**DevOps**) workloads can
    quickly get out of control in terms of resource spending, and in the next chapter
    will cover how to monitor and control costs in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
