- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Demystifying Kubernetes Storage
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the core concept of Kubernetes storage for
    stateful workloads and shows how to configure applications with mounted storage
    and dynamically persistent storage. This chapter covers 10% of the **Certified
    Kubernetes Administrator** (**CKA**) exam content.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Stateful versus stateless workloads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes volumes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes StorageClasses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volume modes, access modes, and reclaim policies for volumes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an application with mounted storage
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an application with persistent storage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, we need to make sure your local machine meets the following
    technical requirements:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: A compatible Linux host – we recommend a Debian-based Linux distribution such
    as Ubuntu 18.04 or later
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure your host machine has at least 2 GB RAM, 2 CPU cores, and about 20
    GB of free disk space
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateful versus stateless workloads
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is designed for both stateful and stateless applications. To maintain
    stateless workloads in Kubernetes, we can freely delete and replace containers
    without any additional concerns. The stateful application usually has storage
    attached either locally or in a remote location, as it needs to hold client data.
    That data could be short-lived or *non-persistent* storage, which means that it
    is just maintained until the expiration of a session. An example of this is the
    Redis cache on Kubernetes. Another use case is when the data needs to be held
    for long enough by using persistent storage so that it can be used on-demand.
    An example of the latter is the MongoDB operator for Kubernetes. The whole story
    is much more complicated than it seems but it all starts with Kubernetes volumes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes volumes represent the concept of storage in Kubernetes. As mentioned
    in [*Chapter 1*](B18201_01.xhtml#_idTextAnchor015), *Kubernetes Overview*, the
    volumes in Kubernetes are managed by storage drivers tailored by storage vendors.
    This part is no longer part of Kubernetes source code after the **Container Storage
    Interface** (**CSI**) was introduced.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'A volume can support local storage, on-premises software-defined storage, cloud-based
    storage (such as blob, block, or file storage), or a **network file system** (**NFS**)
    as shown in *Figure 5.1*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – A CSI ](img/Figure_5.01_B18201.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – A CSI
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Then, users can use CSI-compatible volume drivers and CSI volumes to attach
    or directly mount the pods up and running in the Kubernetes cluster.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes volumes
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ephemeral volumes and persistent volumes are two main types of volumes in Kubernetes.
    We’ll take a look at each of them. Some of them may not be covered in the CKA
    exam, but it is important to know, as whichever organization you work in will
    have embarked on its journey with one of those public cloud providers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Ephemeral storage
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ephemeral volumes targeted to the application need to hold the data, but they
    don’t care about data loss in the case that the pod fails or restarts – the lifecycle
    of the ephemeral volume is aligned with the pod lifecycle. With that in mind,
    mounted storage is usually ephemeral, as it shares the same lifecycle as your
    containers. As long as the container is stopped or destroyed during the process
    of restarting the pod, any internal storage is completely removed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是应用程序需要保存数据的临时卷，但如果 Pod 失败或重启，它们不关心数据丢失——临时卷的生命周期与 Pod 的生命周期一致。考虑到这一点，挂载的存储通常是临时的，因为它与容器共享相同的生命周期。只要容器在重启
    Pod 的过程中停止或销毁，任何内部存储都会被完全移除。
- en: Another use case is when a pod contains multiple containers. It is possible
    to mount that storage to the containers and allow those containers to share the
    same volume so that they interact with the same shared filesystem.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用场景是当一个 Pod 包含多个容器时。可以将存储挂载到这些容器，并允许它们共享相同的卷，从而在共享的文件系统上进行交互。
- en: Ephemeral volumes have several types, which we will cover one by one.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 临时卷有几种类型，我们将逐一介绍。
- en: emptyDir
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: emptyDir
- en: emptyDir is one of the most common types of ephemeral storage and will appear
    in the CKA exam. It usually serves as an empty directory when the pod starts,
    and it shares the same lifecycle with the Pod, meaning it only exists as long
    as a pod is up and running, and the data in the emptyDir is deleted permanently
    when the pod stops or restarts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: emptyDir 是最常见的临时存储类型之一，并且会出现在 CKA 考试中。它通常作为 Pod 启动时的一个空目录，并与 Pod 共享相同的生命周期，这意味着它只存在于
    Pod 运行时，并且当 Pod 停止或重启时，emptyDir 中的数据会被永久删除。
- en: 'When it comes to multi-containers in the same pod, it can be shared across
    containers, although each container can mount the emptyDir in a different repository,
    as shown in *Figure 5.2*:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到同一 Pod 中的多个容器时，它们可以共享存储卷，尽管每个容器可以将 emptyDir 挂载到不同的目录，如 *图 5.2* 所示：
- en: '![Figure 5.2 – Multi-containers in a pod sharing storage volumes ](img/Figure_5.02_B18201.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – Pod 中多个容器共享存储卷](img/Figure_5.02_B18201.jpg)'
- en: Figure 5.2 – Multi-containers in a pod sharing storage volumes
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – Pod 中多个容器共享存储卷
- en: 'The following is an example YAML definition of an emptyDir mounted to a pod:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个将 emptyDir 挂载到 Pod 的 YAML 示例定义：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Through the preceding example, you can see how to mount shared volumes between
    two containers, which would come in handy when you want those two containers to
    consume the same data source.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的示例，你可以看到如何在两个容器之间挂载共享卷，当你希望这两个容器共享相同的数据源时，这会非常有用。
- en: CSI ephemeral volumes
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSI 临时卷
- en: 'CSI ephemeral volumes are CSI driver-compatible volumes that serve as temporary
    storage. For a very long time in the past, CSI volumes provided by an external
    storage driver in Kubernetes were used as persistent volumes, with the goal of
    not sharing a lifecycle with the pod. Starting from Kubernetes 1.15, CSI drivers
    can also be used for such ephemeral inline volumes. The following is an example
    of using CSI ephemeral volumes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: CSI 临时卷是与 CSI 驱动程序兼容的卷，作为临时存储使用。在过去的很长一段时间里，Kubernetes 中由外部存储驱动程序提供的 CSI 卷被用作持久卷，目的是不与
    Pod 共享生命周期。从 Kubernetes 1.15 开始，CSI 驱动程序也可以用于此类临时内联卷。以下是使用 CSI 临时卷的示例：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These CSI storage drivers are generally third-party, such as Azure Disk, Azure
    File, AWS EBS, and DellEMC unity – you can find a complete list of CSI drivers
    at [https://kubernetes-csi.github.io/docs/drivers.xhtml](https://kubernetes-csi.github.io/docs/drivers.xhtml).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 CSI 存储驱动程序通常是第三方的，例如 Azure Disk、Azure File、AWS EBS 和 DellEMC Unity——你可以在
    [https://kubernetes-csi.github.io/docs/drivers.xhtml](https://kubernetes-csi.github.io/docs/drivers.xhtml)
    找到完整的 CSI 驱动程序列表。
- en: Generic ephemeral volumes
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用临时卷
- en: 'Generic ephemeral volumes are general drivers with some additional features
    available such as snapshotting, storage cloning, storage resizing, and storage
    capacity tracking. The following is an example of using CSI ephemeral volumes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通用临时卷是具有一些附加功能的通用驱动程序，如快照、存储克隆、存储调整大小和存储容量跟踪。以下是使用 CSI 临时卷的示例：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Generic ephemeral volumes work with all storage drivers that support dynamic
    provisioning, including some third-party CSI storage drivers. Now that we have
    a good understanding of ephemeral volumes, we’ll have a look at projected volumes
    and see how they work with Kubernetes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通用临时卷可以与所有支持动态供应的存储驱动程序一起使用，包括一些第三方 CSI 存储驱动程序。现在我们已经对临时卷有了较好的理解，我们将看看投影卷，并了解它们如何与
    Kubernetes 一起工作。
- en: Projected volumes
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Configuration data is mounted to the Kubernetes pods – this data was injected
    into a pod through the sidecar pattern. We covered `ConfigMap` and `Secret` objects
    in [*Chapter 4*](B18201_04.xhtml#_idTextAnchor080), *Application Scheduling and
    Lifecycle Management,* which fall under this category. More specifically, they
    are also called **projected volumes** because they represent a volume that maps
    several existing volumes into the same directory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Besides ConfigMap and Secret, projected volumes also consist of **downwardAPI**
    volumes and **service account tokens**. We’ll take a closer look at them here
    with some examples.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: A `downwardAPI` volume is designed to make downward API data available to applications.
    Similarly, it also mounts as a directory and then writes the data in plain-text
    files. The downward API allows containers to consume cluster or pod information
    without using the Kubernetes API server or through the client.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows you how to mount `downwardAPI` as a projected volume:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A service account token type of projected volume is designed to make downward
    API data available to applications. Similarly, it also mounts as a directory and
    then writes the data in plain-text files.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows you how to mount a service account token as a projected
    volume:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s wrap up what we covered in this section about `downwardAPI` and service
    account token volumes, as well as recall what we learned about ConfigMap and Secret
    objects in [*Chapter 4*](B18201_04.xhtml#_idTextAnchor080), *Application Scheduling
    and Lifecycle Management*, by looking at the following. This is an all-in-one
    example to help you understand how to work with all of them in one encounter:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All the projected volumes, `configMap`, `downwardAPI`, `secret`, plus `emptyDir`,
    are provided as local ephemeral storage. On each node, `kubelet` is in charge
    of provisioning and managing pods, and managing the local ephemeral storage.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the mounted storage serving as internal storage, in some use cases,
    we also need persistent data outside the life of the container itself that continues
    to exist even if the container stops or is replaced. This raises the requirement
    to have permanent external storage assigned to our pods. We’ll take a look at
    persistent volumes in the next section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Persistent storage
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to ephemeral volumes, persistent volumes have a lifecycle that is independent
    of the Kubernetes pods. State persistence means keeping some data or information
    to continue beyond the life of the container when the container is deleted or
    replaced. However, it can be modified or updated by the containers while it’s
    running.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'The mechanism of working with persistent volume in Kubernetes takes advantage
    of the exposed API, which abstracts technical details of how the external storage
    is provided, as well as how it is consumed. Kubernetes allows us to work with
    persistent storage through the notion of persistent volumes and persistent volume
    claims:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: A **PersistentVolume** (**PV**) is a storage resources provisioned dynamically
    based on the storage classes with a set of features to fulfill the user’s requirements.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **PersistentVolumeClaim** (**PVC**) is the abstraction layer between the pod
    and the PV requested by the user, with a set of requirements including the specific
    level of resources and the access modes.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As shown in the following, *Figure 5.3*, the PV and PVC are defined in the
    Kubernetes cluster, while the physical storage is outside of the Kubernetes cluster:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The PV and PVC ](img/Figure_5.03_B18201.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The PV and PVC
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Equally, note that the PV can be bound to a PVC, and it is a cluster-wide resource,
    while the PVC is namespaced.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Let’s cover some other important concepts with regards to working with a PV
    and PVC before we dive into *how*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The StorageClass
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `StorageClass` resource in Kubernetes classifies the Kubernetes storage
    class. As a matter of fact, a `StorageClass` contains a `provisioner`, `parameters`,
    and `reclaimPolicy` field.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'The provisioner represents which CSI volume plugin is being used to provision
    the PVs. Examples of different provisioners are Azure Disk, AWS EBS, and Glusterfs.
    You can find a complete list of supported `StorageClass` resources here: [https://kubernetes.io/docs/concepts/storage/storage-classes/](https://kubernetes.io/docs/concepts/storage/storage-classes/).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to define the storage class in the PVC and the definition of storage
    classes includes the provisioner and the reclaim policy. Their relationship is
    shown in *Figure 5.3*:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – A StorageClass resource ](img/Figure_5.04_B18201.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – A StorageClass resource
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when the reclaim policy is not specified, it defaults to `Delete`,
    which means if a user deletes the PVC that is bound to this PV, the PVC itself
    gets deleted too. You can also set it to `Retain`, which means it will be retained
    and that you will need to manually delete the data that resides in it. Another
    case would be to set it to `Recycle`. In this case, the PV will be recycled, deprecated,
    and replaced by dynamic provisioning, which will depend on the provisioner. The
    DefaultStorageClass admission controller on the Kubernetes API server will also
    need to be enabled – this is out of the scope of the CKA exam but I think it’s
    still worth a mention here.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example `StorageClass` definition, using an Azure Disk-managed
    disk to define a `StorageClass` resource with a YAML definition:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Interestingly, despite the fact that local volumes don’t support dynamic provisioning,
    they can still be created and bound when the pod is scheduled. We can set `volumeBindingMode`
    to `WaitForFirstConsumer`, which is shown as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Learning about storage class in Kubernetes will help you work with different
    storage in real life, going above and beyond what’s required in the current CKA
    exam. Please feel free to check out the official documentation – it will be updated
    whenever a new supported storage class is added and will provide useful examples:
    [https://kubernetes.io/docs/concepts/storage/storage-classes/](https://kubernetes.io/docs/concepts/storage/storage-classes/).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a look at another important concept called volume modes next.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Volume modes
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Volume modes indicate the type of consumption of the volume – this can either
    be a filesystem or a block device. When `volumeMode` is set to `Filesystem`, it
    mounts into the pods as a directory. When `volumeMode` is set to `Block`, we use
    it as a raw block.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Access modes
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a PV is mounted to a pod, we can specify different access modes. The access
    modes represent the way that the data in the storage resources is being consumed.
    They can be summarized as shown in the following table:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '| **Access modes** | **Definition** | **Abbreviated** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| `ReadWriteOnce` | The volume can be mounted as read-write by one node. |
    `RWO` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| `ReadOnlyMany` | The volume can be mounted as read-only by multiple nodes.
    | `ROX` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| `ReadWriteMany` | The volume can be mounted as read-write by multiple nodes.
    | `RWX` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| `ReadWriteOncePod` | The volume can be mounted as read-write by one pod.
    This is a feature supported by Kubernetes, starting from Kubernetes 1.22. | `RWOP`
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: 'To learn more about access modes, you can find the official documentation here:
    [https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the access modes is important, as they’re used all the time when working
    with Kubernetes storage. Now, let’s take a look at the PV and PVC next, and see
    how these concepts work together with Kubernetes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: A PV
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s first take a look at how to create a PV. You do so using the following
    YAML definition:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To learn more about how PVs work with Kubernetes, check out this article: [https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistent-volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistent-volumes).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Knowing about PVs on their own is not enough – we need to learn about how PVCs
    work alongside them within Kubernetes storage, which is what we’ll get into next.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: PVCs
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most interesting things about the PVC is that users don’t need to
    worry about the details of where the storage is located. They only need to know
    about the `StorageClass` and `accessMode`. PVCs will automatically bind themselves
    to a PV that has a compatible `StorageClass` and `accessMode`. The following is
    an example of a PVC:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can learn more about the PVC from the official Kubernetes documentation
    here: [https://kubernetes.io/docs/concepts/storage/persistent-volumes/#lifecycle-of-a-volume-and-claim](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#lifecycle-of-a-volume-and-claim).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a PV and PVC that will define the Kubernetes storage, the next
    step is to assign the storage to your applications deployed on top of Kubernetes.
    As we explained, Kubernetes is also capable of dealing with stateful workloads,
    so we’ll have a look at how to mount storage to a stateful application in Kubernetes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Cracking stateful applications in Kubernetes
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn about how to work with storage for stateful
    applications in Kubernetes. The considerations within this part are often seen
    as high-value and low-effort in terms of the CKA exam. Make sure you keep practicing
    them until you feel you know them confidently:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Mounting storage to a stateful application
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically provisioning storage to a stateful application
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an application with mounted storage
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to create a new YAML definition where you write up the specification
    of the Kubernetes pod and then set up emptyDir volumes for the pod. Kubernetes
    creates empty storage on a node after the pod is scheduled to a specific worker
    node:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether you currently have any nodes available to schedule a pod by using
    the following command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, you can use the simplified version of the previous command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the status of any of your nodes shows `Ready`, as in the following figure,
    that means you can proceed to the next step:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Checking the available nodes ](img/Figure_5.05_B18201.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Checking the available nodes
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the Vim editor to create a new YAML definition file called `pod-volume.yaml`,
    and when you enter Vim, press the *Insert* key on your keyboard and let the current
    `edit` mode switch to `INSERT`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Inserting a YAML spec with Vim   ](img/Figure_5.06_B18201.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Inserting a YAML spec with Vim
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, put the following in the YAML definition:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, save your edits and quit Vim. Press the *Esc* key, type `:wq!` at the
    bottom of the editor, and then press *Enter* to take you back to the terminal:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Saving the YAML definition in Vim ](img/Figure_5.07_B18201.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Saving the YAML definition in Vim
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re on the terminal, use the following command to deploy the .`yaml`
    file:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, it should display a message that the pod has been created successfully,
    something similar to the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can go ahead and check whether the pod is now running by using the `kubectl
    get pods` command and the command comes back with the following output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Checking whether the pod is running ](img/Figure_5.08_B18201.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Checking whether the pod is running
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you have deployed a pod with mounted storage. If you run the following
    command, you’ll be able to check out further details, including configuration
    information, resource requirements, the labels of the pods, and events information
    about this pod and the mounted storage:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of this command should be similar to the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Checking the pod configurations and status ](img/Figure_5.09_B18201.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Checking the pod configurations and status
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: From the output, we can see the pod has been mounted on a volume called `my-volume`
    just as we specified in the YAML definition. `Type` has been specified as `EmptyDir`,
    so it’s a temporary directory that shares the pod’s lifecycle. The bottom of the
    screenshot also shows the relevant events when provisioning this pod.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an application with persistent storage
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this case, you need to create a new YAML definition where you write up the
    specification of the Kubernetes PV – Kubernetes will assign the storage based
    on the PVC bound to the PV on a node after the pod has been scheduled to a specific
    worker node.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Creating your PV
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can start by checking whether you currently have any nodes available to
    schedule a pod by using `kubectl get nodes` or `kubectl get no`. Make sure that
    the status of one of your nodes is `Ready`, as in the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Checking the available nodes ](img/Figure_5.10_B18201.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Checking the available nodes
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, we’re creating a new PV by going through the following steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Use Vim to write up the following YAML definition called `data-pv.yaml`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When you’re on the terminal, use the following command to deploy the .`yaml`
    file:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, it will display a message that the PV has been created successfully,
    something similar to the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding YAML definition means that there is 1 GB of storage allocated
    as local storage. You can define a PVC of 1 G storage bound to that PV. However,
    in the theoretical case that you had two claims of 500 MB each, the PV could also
    be split during the allocation process. Under the hood, those two PVCs are bound
    to the same PV, and from there, they share the amount of storage.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to check the PV’s status:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You’ll get the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Checking whether the PV is available ](img/Figure_5.11_B18201.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Checking whether the PV is available
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the status is `available`, meaning that this PV is currently not
    bound to a PVC and is available to be bound with a new PVC, which we’re about
    to create in the next step.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Creating your PVC
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From here, we’re creating a new PVC by going through the following steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Use Vim to write up the following YAML definition called `data-pvc.yaml`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you’re on the terminal, use the following command to deploy the `yaml`
    file:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The PVC is created successfully and gives an output similar to the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use the following command to check the PVC’s status:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You’ll get the following output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Checking the PVC   ](img/Figure_5.12_B18201.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Checking the PVC
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that the status of this PVC is `Bound`, which means that it is
    bound to a PV.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'To double-check whether it is bound to the PV that you desire, you can use
    `kubectl get pv command` to check back:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Check whether the PVC is bound to the PV ](img/Figure_5.13_B18201.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Check whether the PVC is bound to the PV
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows the `Bound` status of our PV, which means it has
    been bound successfully.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the pod to consume the PV
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From here, we’re configuring the pod to consume the PV by going through the
    following steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Use Vim to write up the following YAML definition called `data-pod.yaml` where
    we’re about to create a pod to consume the targeted PV:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '2\. When you’re on the terminal, use the following command to deploy the `yaml`
    file:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The pod is successfully created with an output similar to the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can use the `kubectl get pods` command to verify whether your pod is up
    and running. If you want your command to watch the status of the pod, you can
    use the `-w` flag in your command; it should look as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output would look as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Checking whether the pod is up and running   ](img/Figure_5.14_B18201.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Checking whether the pod is up and running
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command to check out further details, including configuration
    information, resource requirements, labels of the pods, and event information
    about this pod and the dynamically allocated storage:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of this command should be similar to the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Checking the pod’s detailed configuration and events ](img/Figure_5.15_B18201.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Checking the pod’s detailed configuration and events
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: From the output, we can see the pod has been dynamically attached to persistent
    storage called `temp-data`, which was expected, as we defined it in the YAML definition.
    The bottom of the screenshot also shows the relevant events while provisioning
    this pod.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The preceding is an example of using a PVC as a volume – this allows pods to
    access storage by using the claim as a volume. In that case, the claim must exist
    in the same namespace in which the pods will be using them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: We also noticed that, in some cases, people use `hostPath` to mount volumes,
    which simply allocates local storage of that node of the cluster so that the pod
    consumes the storage where the pod lives.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '`hostPath` also easily causes security issues, so we should avoid using it
    as much as possible. While using it, we can specify `volumeMounts` as `ReadOnly`
    and only make it available to a specific file or repository.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that `hostPath` works for a single node only, and if you’re on a multi-node
    cluster, a local volume is the way to go. You can find more details about local
    storage at [https://kubernetes.io/docs/concepts/storage/volumes/#local](https://kubernetes.io/docs/concepts/storage/volumes/#local).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers one of the highest-value topics in the CKA exam, which is
    Kubernetes storage. Over the last three years, the CKA exam has raised more and
    more attention toward Kubernetes storage, where it previously only scratched the
    surface and now focuses on various use cases of the stateful application deployment.
    Learning this part may not seem the most crucial for Kubernetes administrators
    at the moment, but it will take off more quickly once we have more and more cloud-native
    databases adopted by enterprise-grade customers. Having a solid knowledge of storage
    will add value to your existing Kubernetes administration skills. If you can confidently
    play with the exercises in this chapter, it will increase your success rate in
    the actual CKA exam, as storage-related questions are usually simpler but higher
    value compared to other cluster maintenance task-related questions in the previous
    chapters.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Securing Kubernetes*, we will dive into some important
    Kubernetes security concepts, which will help you not only set up a solid foundation
    for the CKA exam but also potentially help you for the **Certified Kubernetes
    Security Specialist** (**CKS**) exam in the future – stay tuned!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Mock CKA scenario-based practice test
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have two virtual machines, `master-0` and `worker-0`. Please complete the
    following mock scenarios.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 1
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new PV called `packt-data-pv` to store 2 GB, and two PVCs each requesting
    1 GB of local storage.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 2
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Provision a new pod called `pack-storage-pod` and assign an available PV to
    this Pod.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the scenario resolutions in [*Appendix*](B18201_Appendix_A.xhtml#_idTextAnchor386)
    *- Mock CKA scenario-based practice test resolutions* of this book.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: FAQs
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Where can I find the latest updates about the supported CSI drivers while
    working with Kubernetes?*'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Kubernetes CSI **Special Interest Group** (**SIG**) has a GitHub-based
    documentation website where you can find all the latest drivers, with tutorials
    from their main page: [https://kubernetes-csi.github.io/docs](https://kubernetes-csi.github.io/docs).
    More specifically, you can find all available supported CSI drivers at the following
    link: [https://kubernetes-csi.github.io/docs/drivers.xhtml](https://kubernetes-csi.github.io/docs/drivers.xhtml).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '*What is the recommended official Kubernetes article to refer to for configuring
    ephemeral storage?*'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I recommend bookmarking the official documentation about ephemeral volumes:
    [https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/](https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '*What is the recommended official Kubernetes article to refer to for configuring
    persistent storage?*'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I recommend bookmarking this article, *Configure a Pod to Use a Persistent
    Volume for Storage*, where you can find all the key steps and processes: [https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
