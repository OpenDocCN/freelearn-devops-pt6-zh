- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Demystifying Kubernetes Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the core concept of Kubernetes storage for
    stateful workloads and shows how to configure applications with mounted storage
    and dynamically persistent storage. This chapter covers 10% of the **Certified
    Kubernetes Administrator** (**CKA**) exam content.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Stateful versus stateless workloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes StorageClasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volume modes, access modes, and reclaim policies for volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an application with mounted storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an application with persistent storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, we need to make sure your local machine meets the following
    technical requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: A compatible Linux host – we recommend a Debian-based Linux distribution such
    as Ubuntu 18.04 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure your host machine has at least 2 GB RAM, 2 CPU cores, and about 20
    GB of free disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateful versus stateless workloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is designed for both stateful and stateless applications. To maintain
    stateless workloads in Kubernetes, we can freely delete and replace containers
    without any additional concerns. The stateful application usually has storage
    attached either locally or in a remote location, as it needs to hold client data.
    That data could be short-lived or *non-persistent* storage, which means that it
    is just maintained until the expiration of a session. An example of this is the
    Redis cache on Kubernetes. Another use case is when the data needs to be held
    for long enough by using persistent storage so that it can be used on-demand.
    An example of the latter is the MongoDB operator for Kubernetes. The whole story
    is much more complicated than it seems but it all starts with Kubernetes volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes volumes represent the concept of storage in Kubernetes. As mentioned
    in [*Chapter 1*](B18201_01.xhtml#_idTextAnchor015), *Kubernetes Overview*, the
    volumes in Kubernetes are managed by storage drivers tailored by storage vendors.
    This part is no longer part of Kubernetes source code after the **Container Storage
    Interface** (**CSI**) was introduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'A volume can support local storage, on-premises software-defined storage, cloud-based
    storage (such as blob, block, or file storage), or a **network file system** (**NFS**)
    as shown in *Figure 5.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – A CSI ](img/Figure_5.01_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – A CSI
  prefs: []
  type: TYPE_NORMAL
- en: Then, users can use CSI-compatible volume drivers and CSI volumes to attach
    or directly mount the pods up and running in the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ephemeral volumes and persistent volumes are two main types of volumes in Kubernetes.
    We’ll take a look at each of them. Some of them may not be covered in the CKA
    exam, but it is important to know, as whichever organization you work in will
    have embarked on its journey with one of those public cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: Ephemeral storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ephemeral volumes targeted to the application need to hold the data, but they
    don’t care about data loss in the case that the pod fails or restarts – the lifecycle
    of the ephemeral volume is aligned with the pod lifecycle. With that in mind,
    mounted storage is usually ephemeral, as it shares the same lifecycle as your
    containers. As long as the container is stopped or destroyed during the process
    of restarting the pod, any internal storage is completely removed.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case is when a pod contains multiple containers. It is possible
    to mount that storage to the containers and allow those containers to share the
    same volume so that they interact with the same shared filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Ephemeral volumes have several types, which we will cover one by one.
  prefs: []
  type: TYPE_NORMAL
- en: emptyDir
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: emptyDir is one of the most common types of ephemeral storage and will appear
    in the CKA exam. It usually serves as an empty directory when the pod starts,
    and it shares the same lifecycle with the Pod, meaning it only exists as long
    as a pod is up and running, and the data in the emptyDir is deleted permanently
    when the pod stops or restarts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to multi-containers in the same pod, it can be shared across
    containers, although each container can mount the emptyDir in a different repository,
    as shown in *Figure 5.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Multi-containers in a pod sharing storage volumes ](img/Figure_5.02_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Multi-containers in a pod sharing storage volumes
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example YAML definition of an emptyDir mounted to a pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Through the preceding example, you can see how to mount shared volumes between
    two containers, which would come in handy when you want those two containers to
    consume the same data source.
  prefs: []
  type: TYPE_NORMAL
- en: CSI ephemeral volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CSI ephemeral volumes are CSI driver-compatible volumes that serve as temporary
    storage. For a very long time in the past, CSI volumes provided by an external
    storage driver in Kubernetes were used as persistent volumes, with the goal of
    not sharing a lifecycle with the pod. Starting from Kubernetes 1.15, CSI drivers
    can also be used for such ephemeral inline volumes. The following is an example
    of using CSI ephemeral volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These CSI storage drivers are generally third-party, such as Azure Disk, Azure
    File, AWS EBS, and DellEMC unity – you can find a complete list of CSI drivers
    at [https://kubernetes-csi.github.io/docs/drivers.xhtml](https://kubernetes-csi.github.io/docs/drivers.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Generic ephemeral volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Generic ephemeral volumes are general drivers with some additional features
    available such as snapshotting, storage cloning, storage resizing, and storage
    capacity tracking. The following is an example of using CSI ephemeral volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Generic ephemeral volumes work with all storage drivers that support dynamic
    provisioning, including some third-party CSI storage drivers. Now that we have
    a good understanding of ephemeral volumes, we’ll have a look at projected volumes
    and see how they work with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Projected volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Configuration data is mounted to the Kubernetes pods – this data was injected
    into a pod through the sidecar pattern. We covered `ConfigMap` and `Secret` objects
    in [*Chapter 4*](B18201_04.xhtml#_idTextAnchor080), *Application Scheduling and
    Lifecycle Management,* which fall under this category. More specifically, they
    are also called **projected volumes** because they represent a volume that maps
    several existing volumes into the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: Besides ConfigMap and Secret, projected volumes also consist of **downwardAPI**
    volumes and **service account tokens**. We’ll take a closer look at them here
    with some examples.
  prefs: []
  type: TYPE_NORMAL
- en: A `downwardAPI` volume is designed to make downward API data available to applications.
    Similarly, it also mounts as a directory and then writes the data in plain-text
    files. The downward API allows containers to consume cluster or pod information
    without using the Kubernetes API server or through the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows you how to mount `downwardAPI` as a projected volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A service account token type of projected volume is designed to make downward
    API data available to applications. Similarly, it also mounts as a directory and
    then writes the data in plain-text files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows you how to mount a service account token as a projected
    volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s wrap up what we covered in this section about `downwardAPI` and service
    account token volumes, as well as recall what we learned about ConfigMap and Secret
    objects in [*Chapter 4*](B18201_04.xhtml#_idTextAnchor080), *Application Scheduling
    and Lifecycle Management*, by looking at the following. This is an all-in-one
    example to help you understand how to work with all of them in one encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All the projected volumes, `configMap`, `downwardAPI`, `secret`, plus `emptyDir`,
    are provided as local ephemeral storage. On each node, `kubelet` is in charge
    of provisioning and managing pods, and managing the local ephemeral storage.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the mounted storage serving as internal storage, in some use cases,
    we also need persistent data outside the life of the container itself that continues
    to exist even if the container stops or is replaced. This raises the requirement
    to have permanent external storage assigned to our pods. We’ll take a look at
    persistent volumes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to ephemeral volumes, persistent volumes have a lifecycle that is independent
    of the Kubernetes pods. State persistence means keeping some data or information
    to continue beyond the life of the container when the container is deleted or
    replaced. However, it can be modified or updated by the containers while it’s
    running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mechanism of working with persistent volume in Kubernetes takes advantage
    of the exposed API, which abstracts technical details of how the external storage
    is provided, as well as how it is consumed. Kubernetes allows us to work with
    persistent storage through the notion of persistent volumes and persistent volume
    claims:'
  prefs: []
  type: TYPE_NORMAL
- en: A **PersistentVolume** (**PV**) is a storage resources provisioned dynamically
    based on the storage classes with a set of features to fulfill the user’s requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **PersistentVolumeClaim** (**PVC**) is the abstraction layer between the pod
    and the PV requested by the user, with a set of requirements including the specific
    level of resources and the access modes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As shown in the following, *Figure 5.3*, the PV and PVC are defined in the
    Kubernetes cluster, while the physical storage is outside of the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The PV and PVC ](img/Figure_5.03_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The PV and PVC
  prefs: []
  type: TYPE_NORMAL
- en: Equally, note that the PV can be bound to a PVC, and it is a cluster-wide resource,
    while the PVC is namespaced.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s cover some other important concepts with regards to working with a PV
    and PVC before we dive into *how*.
  prefs: []
  type: TYPE_NORMAL
- en: The StorageClass
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `StorageClass` resource in Kubernetes classifies the Kubernetes storage
    class. As a matter of fact, a `StorageClass` contains a `provisioner`, `parameters`,
    and `reclaimPolicy` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The provisioner represents which CSI volume plugin is being used to provision
    the PVs. Examples of different provisioners are Azure Disk, AWS EBS, and Glusterfs.
    You can find a complete list of supported `StorageClass` resources here: [https://kubernetes.io/docs/concepts/storage/storage-classes/](https://kubernetes.io/docs/concepts/storage/storage-classes/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to define the storage class in the PVC and the definition of storage
    classes includes the provisioner and the reclaim policy. Their relationship is
    shown in *Figure 5.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – A StorageClass resource ](img/Figure_5.04_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – A StorageClass resource
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when the reclaim policy is not specified, it defaults to `Delete`,
    which means if a user deletes the PVC that is bound to this PV, the PVC itself
    gets deleted too. You can also set it to `Retain`, which means it will be retained
    and that you will need to manually delete the data that resides in it. Another
    case would be to set it to `Recycle`. In this case, the PV will be recycled, deprecated,
    and replaced by dynamic provisioning, which will depend on the provisioner. The
    DefaultStorageClass admission controller on the Kubernetes API server will also
    need to be enabled – this is out of the scope of the CKA exam but I think it’s
    still worth a mention here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example `StorageClass` definition, using an Azure Disk-managed
    disk to define a `StorageClass` resource with a YAML definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, despite the fact that local volumes don’t support dynamic provisioning,
    they can still be created and bound when the pod is scheduled. We can set `volumeBindingMode`
    to `WaitForFirstConsumer`, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Learning about storage class in Kubernetes will help you work with different
    storage in real life, going above and beyond what’s required in the current CKA
    exam. Please feel free to check out the official documentation – it will be updated
    whenever a new supported storage class is added and will provide useful examples:
    [https://kubernetes.io/docs/concepts/storage/storage-classes/](https://kubernetes.io/docs/concepts/storage/storage-classes/).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a look at another important concept called volume modes next.
  prefs: []
  type: TYPE_NORMAL
- en: Volume modes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Volume modes indicate the type of consumption of the volume – this can either
    be a filesystem or a block device. When `volumeMode` is set to `Filesystem`, it
    mounts into the pods as a directory. When `volumeMode` is set to `Block`, we use
    it as a raw block.
  prefs: []
  type: TYPE_NORMAL
- en: Access modes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a PV is mounted to a pod, we can specify different access modes. The access
    modes represent the way that the data in the storage resources is being consumed.
    They can be summarized as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Access modes** | **Definition** | **Abbreviated** |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadWriteOnce` | The volume can be mounted as read-write by one node. |
    `RWO` |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadOnlyMany` | The volume can be mounted as read-only by multiple nodes.
    | `ROX` |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadWriteMany` | The volume can be mounted as read-write by multiple nodes.
    | `RWX` |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadWriteOncePod` | The volume can be mounted as read-write by one pod.
    This is a feature supported by Kubernetes, starting from Kubernetes 1.22. | `RWOP`
    |'
  prefs: []
  type: TYPE_TB
- en: 'To learn more about access modes, you can find the official documentation here:
    [https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes).'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the access modes is important, as they’re used all the time when working
    with Kubernetes storage. Now, let’s take a look at the PV and PVC next, and see
    how these concepts work together with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: A PV
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s first take a look at how to create a PV. You do so using the following
    YAML definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To learn more about how PVs work with Kubernetes, check out this article: [https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistent-volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistent-volumes).'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing about PVs on their own is not enough – we need to learn about how PVCs
    work alongside them within Kubernetes storage, which is what we’ll get into next.
  prefs: []
  type: TYPE_NORMAL
- en: PVCs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most interesting things about the PVC is that users don’t need to
    worry about the details of where the storage is located. They only need to know
    about the `StorageClass` and `accessMode`. PVCs will automatically bind themselves
    to a PV that has a compatible `StorageClass` and `accessMode`. The following is
    an example of a PVC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can learn more about the PVC from the official Kubernetes documentation
    here: [https://kubernetes.io/docs/concepts/storage/persistent-volumes/#lifecycle-of-a-volume-and-claim](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#lifecycle-of-a-volume-and-claim).'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a PV and PVC that will define the Kubernetes storage, the next
    step is to assign the storage to your applications deployed on top of Kubernetes.
    As we explained, Kubernetes is also capable of dealing with stateful workloads,
    so we’ll have a look at how to mount storage to a stateful application in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Cracking stateful applications in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn about how to work with storage for stateful
    applications in Kubernetes. The considerations within this part are often seen
    as high-value and low-effort in terms of the CKA exam. Make sure you keep practicing
    them until you feel you know them confidently:'
  prefs: []
  type: TYPE_NORMAL
- en: Mounting storage to a stateful application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically provisioning storage to a stateful application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an application with mounted storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to create a new YAML definition where you write up the specification
    of the Kubernetes pod and then set up emptyDir volumes for the pod. Kubernetes
    creates empty storage on a node after the pod is scheduled to a specific worker
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether you currently have any nodes available to schedule a pod by using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, you can use the simplified version of the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If the status of any of your nodes shows `Ready`, as in the following figure,
    that means you can proceed to the next step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Checking the available nodes ](img/Figure_5.05_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Checking the available nodes
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the Vim editor to create a new YAML definition file called `pod-volume.yaml`,
    and when you enter Vim, press the *Insert* key on your keyboard and let the current
    `edit` mode switch to `INSERT`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Inserting a YAML spec with Vim   ](img/Figure_5.06_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Inserting a YAML spec with Vim
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, put the following in the YAML definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, save your edits and quit Vim. Press the *Esc* key, type `:wq!` at the
    bottom of the editor, and then press *Enter* to take you back to the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Saving the YAML definition in Vim ](img/Figure_5.07_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Saving the YAML definition in Vim
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re on the terminal, use the following command to deploy the .`yaml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, it should display a message that the pod has been created successfully,
    something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can go ahead and check whether the pod is now running by using the `kubectl
    get pods` command and the command comes back with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Checking whether the pod is running ](img/Figure_5.08_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Checking whether the pod is running
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you have deployed a pod with mounted storage. If you run the following
    command, you’ll be able to check out further details, including configuration
    information, resource requirements, the labels of the pods, and events information
    about this pod and the mounted storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Checking the pod configurations and status ](img/Figure_5.09_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Checking the pod configurations and status
  prefs: []
  type: TYPE_NORMAL
- en: From the output, we can see the pod has been mounted on a volume called `my-volume`
    just as we specified in the YAML definition. `Type` has been specified as `EmptyDir`,
    so it’s a temporary directory that shares the pod’s lifecycle. The bottom of the
    screenshot also shows the relevant events when provisioning this pod.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an application with persistent storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this case, you need to create a new YAML definition where you write up the
    specification of the Kubernetes PV – Kubernetes will assign the storage based
    on the PVC bound to the PV on a node after the pod has been scheduled to a specific
    worker node.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your PV
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can start by checking whether you currently have any nodes available to
    schedule a pod by using `kubectl get nodes` or `kubectl get no`. Make sure that
    the status of one of your nodes is `Ready`, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Checking the available nodes ](img/Figure_5.10_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Checking the available nodes
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, we’re creating a new PV by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use Vim to write up the following YAML definition called `data-pv.yaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you’re on the terminal, use the following command to deploy the .`yaml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, it will display a message that the PV has been created successfully,
    something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding YAML definition means that there is 1 GB of storage allocated
    as local storage. You can define a PVC of 1 G storage bound to that PV. However,
    in the theoretical case that you had two claims of 500 MB each, the PV could also
    be split during the allocation process. Under the hood, those two PVCs are bound
    to the same PV, and from there, they share the amount of storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to check the PV’s status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Checking whether the PV is available ](img/Figure_5.11_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Checking whether the PV is available
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the status is `available`, meaning that this PV is currently not
    bound to a PVC and is available to be bound with a new PVC, which we’re about
    to create in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your PVC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From here, we’re creating a new PVC by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use Vim to write up the following YAML definition called `data-pvc.yaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you’re on the terminal, use the following command to deploy the `yaml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The PVC is created successfully and gives an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to check the PVC’s status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Checking the PVC   ](img/Figure_5.12_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Checking the PVC
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that the status of this PVC is `Bound`, which means that it is
    bound to a PV.
  prefs: []
  type: TYPE_NORMAL
- en: 'To double-check whether it is bound to the PV that you desire, you can use
    `kubectl get pv command` to check back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Check whether the PVC is bound to the PV ](img/Figure_5.13_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Check whether the PVC is bound to the PV
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows the `Bound` status of our PV, which means it has
    been bound successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the pod to consume the PV
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From here, we’re configuring the pod to consume the PV by going through the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use Vim to write up the following YAML definition called `data-pod.yaml` where
    we’re about to create a pod to consume the targeted PV:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2\. When you’re on the terminal, use the following command to deploy the `yaml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The pod is successfully created with an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `kubectl get pods` command to verify whether your pod is up
    and running. If you want your command to watch the status of the pod, you can
    use the `-w` flag in your command; it should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Checking whether the pod is up and running   ](img/Figure_5.14_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Checking whether the pod is up and running
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command to check out further details, including configuration
    information, resource requirements, labels of the pods, and event information
    about this pod and the dynamically allocated storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Checking the pod’s detailed configuration and events ](img/Figure_5.15_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Checking the pod’s detailed configuration and events
  prefs: []
  type: TYPE_NORMAL
- en: From the output, we can see the pod has been dynamically attached to persistent
    storage called `temp-data`, which was expected, as we defined it in the YAML definition.
    The bottom of the screenshot also shows the relevant events while provisioning
    this pod.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding is an example of using a PVC as a volume – this allows pods to
    access storage by using the claim as a volume. In that case, the claim must exist
    in the same namespace in which the pods will be using them.
  prefs: []
  type: TYPE_NORMAL
- en: We also noticed that, in some cases, people use `hostPath` to mount volumes,
    which simply allocates local storage of that node of the cluster so that the pod
    consumes the storage where the pod lives.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '`hostPath` also easily causes security issues, so we should avoid using it
    as much as possible. While using it, we can specify `volumeMounts` as `ReadOnly`
    and only make it available to a specific file or repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that `hostPath` works for a single node only, and if you’re on a multi-node
    cluster, a local volume is the way to go. You can find more details about local
    storage at [https://kubernetes.io/docs/concepts/storage/volumes/#local](https://kubernetes.io/docs/concepts/storage/volumes/#local).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers one of the highest-value topics in the CKA exam, which is
    Kubernetes storage. Over the last three years, the CKA exam has raised more and
    more attention toward Kubernetes storage, where it previously only scratched the
    surface and now focuses on various use cases of the stateful application deployment.
    Learning this part may not seem the most crucial for Kubernetes administrators
    at the moment, but it will take off more quickly once we have more and more cloud-native
    databases adopted by enterprise-grade customers. Having a solid knowledge of storage
    will add value to your existing Kubernetes administration skills. If you can confidently
    play with the exercises in this chapter, it will increase your success rate in
    the actual CKA exam, as storage-related questions are usually simpler but higher
    value compared to other cluster maintenance task-related questions in the previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Securing Kubernetes*, we will dive into some important
    Kubernetes security concepts, which will help you not only set up a solid foundation
    for the CKA exam but also potentially help you for the **Certified Kubernetes
    Security Specialist** (**CKS**) exam in the future – stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: Mock CKA scenario-based practice test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have two virtual machines, `master-0` and `worker-0`. Please complete the
    following mock scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new PV called `packt-data-pv` to store 2 GB, and two PVCs each requesting
    1 GB of local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Provision a new pod called `pack-storage-pod` and assign an available PV to
    this Pod.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the scenario resolutions in [*Appendix*](B18201_Appendix_A.xhtml#_idTextAnchor386)
    *- Mock CKA scenario-based practice test resolutions* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: FAQs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Where can I find the latest updates about the supported CSI drivers while
    working with Kubernetes?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Kubernetes CSI **Special Interest Group** (**SIG**) has a GitHub-based
    documentation website where you can find all the latest drivers, with tutorials
    from their main page: [https://kubernetes-csi.github.io/docs](https://kubernetes-csi.github.io/docs).
    More specifically, you can find all available supported CSI drivers at the following
    link: [https://kubernetes-csi.github.io/docs/drivers.xhtml](https://kubernetes-csi.github.io/docs/drivers.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: '*What is the recommended official Kubernetes article to refer to for configuring
    ephemeral storage?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I recommend bookmarking the official documentation about ephemeral volumes:
    [https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/](https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/).'
  prefs: []
  type: TYPE_NORMAL
- en: '*What is the recommended official Kubernetes article to refer to for configuring
    persistent storage?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I recommend bookmarking this article, *Configure a Pod to Use a Persistent
    Volume for Storage*, where you can find all the key steps and processes: [https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/).'
  prefs: []
  type: TYPE_NORMAL
