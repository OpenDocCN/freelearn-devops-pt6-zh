<html><head></head><body>
		<div id="_idContainer090">
			<h1 id="_idParaDest-93"><em class="italic"><a id="_idTextAnchor092"/>Chapter 6</em>: More Crossplane Patterns</h1>
			<p>Following the previous chapter, we will continue to discover more Crossplane patterns that are key to building a state-of-the-art infrastructure automation platform. We will cover different topics, such as managing dependencies between resources, propagating secrets, using the Crossplane Helm provider, trade-off points in defining the XR API boundary, and monitoring the Crossplane control plane using Prometheus. Throughout the chapter, we will use examples with a hands-on journey to understand these concepts. We have been using GCP in all the previous chapters. In this chapter, we will use both GCP and AWS to learn Crossplane. Finally, we will learn more debugging skills, which are vital for day-to-day platform development and operations.</p>
			<p>The following are the topics covered in the chapter:</p>
			<ul>
				<li>AWS provider setup</li>
				<li>Managing dependencies</li>
				<li>Secret propagation hands-on</li>
				<li>Helm provider hands-on</li>
				<li>Defining API boundaries</li>
				<li>Alerts and monitoring</li>
				<li>More troubleshooting patterns</li>
			</ul>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/>AWS provider setup</h1>
			<p>Some of the examples in this chapter will use AWS as the cloud provider. Apart from GCP, we are covering <a id="_idIndexMarker275"/>AWS to establish what it takes to work with a new cloud provider. It will help us realize how working with one cloud provider will enable us to be competent enough to handle any cloud provider in Crossplane. We can look at the AWS provider setup in the following three steps:</p>
			<ol>
				<li>Creating an AWS account and IAM user</li>
				<li>Creating the Kubernetes secret</li>
				<li>Provider and ProviderConfig setup</li>
			</ol>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Creating an AWS account and IAM user</h2>
			<p>You can register <a id="_idIndexMarker276"/>with AWS and use some of its <a id="_idIndexMarker277"/>services free, provided you have a credit card. You can <a id="_idIndexMarker278"/>read more about the AWS free tier at <a href="https://aws.amazon.com/free/free-tier-faqs/">https://aws.amazon.com/free/free-tier-faqs/</a>. Once you have the free account created, the next <a id="_idIndexMarker279"/>step is to create a new IAM user. The following screenshots will cover the different stages in the IAM user creation. Go to the <strong class="bold">IAM</strong> section in the AWS web console and click <strong class="bold">Add a user</strong>. Select the credentials type as an access key shown in the following screenshot:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B17830_06_01.jpg" alt="Figure 6.1 – Creating a user&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Creating a user</p>
			<p>The next step is to add the user to an access group. If you don’t have a user group already, you can use the <strong class="bold">Create group</strong> button and create a new group with appropriate access control. Alternatively, we can attach an existing access policy to the user or copy permissions from a current user. Ensure that you have added the required permissions for the resources provisioned through Crossplane. I have provided an <strong class="bold">AdministratorAccess</strong> role to provide full access to all AWS resources.</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B17830_06_02.jpg" alt="Figure 6.2 – Add user to group&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Add user to group</p>
			<p>Now you will <a id="_idIndexMarker280"/>have the access ID and secret of the <a id="_idIndexMarker281"/>new IAM user in the AWS console, which will be <a id="_idIndexMarker282"/>helpful for Crossplane AWS Provider configuration:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B17830_06_03.jpg" alt="Figure 6.3 – New IAM user&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – New IAM user</p>
			<p>The next step is to use the access key ID and the secret key of the IAM user to configure the Kubernetes secret. </p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Creating the Kubernetes secret</h2>
			<p>Creating the <a id="_idIndexMarker283"/>Kubernetes secret starts with <a id="_idIndexMarker284"/>setting up the AWS CLI in your local environment. It will be a simple step to download the installable and perform the installation. Follow the installation instructions at <a href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html">https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html</a>. Next, we can create the AWS login profile using the <strong class="source-inline">aws configure --profile default</strong> command. It will ask for the access key ID, secret access key, default region, and output format. The access key ID and the secret key are what we got while creating the IAM user. You can ignore the default region and output format.</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B17830_06_04.jpg" alt="Figure 6.4 – Login profile&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Login profile</p>
			<p>The next step is <a id="_idIndexMarker285"/>to create the Kubernetes secret <a id="_idIndexMarker286"/>using the preceding profile. Execute the following commands: </p>
			<pre class="source-code"># Set a variable with the profile name</pre>
			<pre class="source-code">AWS_PROFILE=default</pre>
			<pre class="source-code"># Create a configuration file with profile data</pre>
			<pre class="source-code">echo -e "[$AWS_PROFILE]\naws_access_key_id = $(aws configure get aws_access_key_id --profile $AWS_PROFILE)\naws_secret_access_key = $(aws configure get aws_secret_access_key --profile $AWS_PROFILE)" &gt; aws-credentials.conf</pre>
			<pre class="source-code"># Create kubernetes secret from the configuration file</pre>
			<pre class="source-code">kubectl create secret generic aws-credentials -n crossplane-system --from-file=creds=./aws-credentials.conf</pre>
			<p>Refer to the following screenshot where the Kubernetes secret is created:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B17830_06_05.jpg" alt="Figure 6.5 – Kubernetes secret creation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – Kubernetes secret creation</p>
			<p>We are now done with the creation of Kubernetes secrets. The following section will look at the AWS provider installation and setup in the Crossplane environment.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/>AWS provider and ProviderConfig setup</h2>
			<p>Install Crossplane <a id="_idIndexMarker287"/>AWS provider by applying the following YAML to the cluster. The configuration has two parts to it. The provider configuration will <a id="_idIndexMarker288"/>install the AWS provider, and <strong class="source-inline">ControllerConfig</strong> enables debugging mode to the provider pod logs. It is not mandatory <a id="_idIndexMarker289"/>to have the <strong class="source-inline">ControllerConfig</strong> configuration. The example here will be helpful when you want to debug an issue. Note that the <strong class="source-inline">ControllerConfig</strong> name refers to the provider configuration:</p>
			<pre class="source-code">apiVersion: pkg.crossplane.io/v1alpha1</pre>
			<pre class="source-code">kind: ControllerConfig</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: debug-config</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  args:</pre>
			<pre class="source-code">    - --debug</pre>
			<pre class="source-code">---</pre>
			<pre class="source-code">apiVersion: pkg.crossplane.io/v1</pre>
			<pre class="source-code">kind: Provider</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: provider-aws</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  package: "crossplane/provider-aws:v0.23.0"</pre>
			<pre class="source-code">  controllerConfigRef:</pre>
			<pre class="source-code">    name: debug-config</pre>
			<p>Finally, apply the following provider configuration YAML referring to the secret:</p>
			<pre class="source-code">apiVersion: aws.crossplane.io/v1beta1</pre>
			<pre class="source-code">kind: ProviderConfig</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: aws-credentials</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  credentials:</pre>
			<pre class="source-code">    source: Secret</pre>
			<pre class="source-code">    secretRef:</pre>
			<pre class="source-code">      namespace: crossplane-system</pre>
			<pre class="source-code">      name: aws-credentials</pre>
			<pre class="source-code">      key: creds</pre>
			<p>We are ready to <a id="_idIndexMarker290"/>create the resources from the AWS free tier and <a id="_idIndexMarker291"/>experiment. All the setup instructions are available at <a href="https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter06/Hand-on-examples/aws-setup">https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter06/Hand-on-examples/aws-setup</a>. Execute the <strong class="source-inline">rds.yaml</strong> file to validate whether the AWS provider setup is down proper. The following screenshot refers to the successful provisioning of an RDS resource from AWS:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B17830_06_06.jpg" alt="Figure 6.6 – RDS provisioning&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – RDS provisioning</p>
			<p>This completes the AWS setup activities. The following section will look at resource referencing to manage dependencies between the resources.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>Managing dependencies</h1>
			<p>One external <a id="_idIndexMarker292"/>resource referencing another resource is a recurring pattern in infrastructure. For example, we may want to provision our Kubernetes cluster <a id="_idIndexMarker293"/>in a specific <strong class="bold">Virtual Private Network</strong> (<strong class="bold">VPN</strong>). The S3 bucket policy definition referring to the S3 bucket is another example. We could go on with many such examples. From the perspective of building an XR API, there will be a requirement to establish dependencies between external resources within <a id="_idIndexMarker294"/>a given XR or in a nested XRs scenario, or between resources in independent XRs. Crossplane offers three different ways to refer one resource from another. Each of these options has its use case:</p>
			<ul>
				<li><strong class="bold">Direct reference</strong>: This configuration option refers to the resources directly with a unique identifier <a id="_idIndexMarker295"/>such as a resource name or an <strong class="bold">Amazon Resource Name</strong> (<strong class="bold">ARN</strong>) or other identifier based on the specific <a id="_idIndexMarker296"/>cloud provider and resource type. For example, consider the AWS resource <strong class="source-inline">UserPolicyAttachment</strong>. It can attach an IAM user to a <strong class="source-inline">Policy</strong> object. Here, the reference to the <strong class="source-inline">Policy</strong> object can be done using the attribute called <strong class="source-inline">PolicyARN</strong> (ARN reference). Similarly, a <strong class="source-inline">User</strong> object reference can be executed using the <strong class="source-inline">UserName</strong> attribute (name reference).</li>
				<li><strong class="bold">Selector reference within the XR</strong>: This option refers to the resources within the XR using a <strong class="source-inline">selector</strong> attribute. <strong class="source-inline">selector</strong> is an attribute that instructs Crossplane to look for the referring resources based on the conditions specified in its sub-attributes. <strong class="source-inline">MatchControllerRef</strong> and <strong class="source-inline">MatchLabels</strong> are the sub-attributes of the <strong class="source-inline">selector</strong> attribute. The <strong class="source-inline">MatchControllerRef</strong> value will be <strong class="source-inline">true</strong>, guiding Crossplane to look for the referring resources within the XR. The second attribute, <strong class="source-inline">MatchLabels</strong>, drives Crossplane to look for referring resources with the specified labels. If the selector identifies more than one recourse, one of the resources is selected randomly. If the direct reference attribute discussed in the previous option is present in the configuration, the <strong class="source-inline">selector</strong> attributes will be ignored.</li>
				<li><strong class="bold">Selector reference outside the XR</strong>: Its behavior is the same as option two, excluding the false <strong class="source-inline">MatchControllerRef</strong> value. It guides the Crossplane to look for matching resources outside the XR.<p class="callout-heading">Tip</p><p class="callout">We can use two strategies to identify the value for direct reference configuration. We can create the resources with a predictable name to reconstruct them again at the reference point. It is similar to what we discussed about external resource names in the last chapter. If the unique identifier is a cloud-generated ID such as ARN, copy the identifier to a custom-defined status attribute (XR API response) for usage at a later point in time.</p></li>
			</ul>
			<p>Don’t worry if it’s <a id="_idIndexMarker297"/>confusing. Let’s look at the resource reference with a couple of hands-on examples. The first example will cover the direct and selector configurations within and nested XR.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Resource reference within and nested XR</h2>
			<p>The example <a id="_idIndexMarker298"/>will be a real-world scenario. We will create an S3 <a id="_idIndexMarker299"/>bucket with a specific IAM policy and create an IAM user who can access the bucket. The following are the managed resources involved in the example:</p>
			<ul>
				<li><strong class="source-inline">Bucket</strong>: This is an MR to create an S3 bucket. We will use this to provision the bucket in a specific region.</li>
				<li><strong class="source-inline">Policy</strong>: This is the MR part of the AWS IAM resources list. It is helpful in defining usage guidelines for a given resource. In the example here, we will create a policy with full access to read and edit all objects in the bucket.</li>
				<li><strong class="source-inline">User</strong>: The MR represents the AWS IAM user. We will create a new user to access the created bucket.</li>
				<li><strong class="source-inline">UserPolicyAttachment</strong>: This is again part of the list of resources under AWS IAM. This MR will attach a policy to a user. We will link the bucket policy we created to the user.</li>
			</ul>
			<p>You can see that there is a requirement for referring one resource from another. For example, a <strong class="source-inline">Policy</strong> resource would have to refer to the bucket name to build the policy configuration. Another example is <strong class="source-inline">UserPolicyAttachment</strong>, referring to the <strong class="source-inline">Policy</strong> and <strong class="source-inline">User</strong> resources to attach them. The following diagram will represent the relation between the resources, their reference option, and the XR boundary:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B17830_06_07.jpg" alt="Figure 6.7 – Resource reference within and nested XR&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – Resource reference within and nested XR</p>
			<p>The complete example with XRD, composition, and Claim is available at <a href="https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter06/Hand-on-examples/same-nested-xr-reference">https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter06/Hand-on-examples/same-nested-xr-reference</a>. Let’s look at some of the <a id="_idIndexMarker300"/>essential code snippets to get comfortable with <a id="_idIndexMarker301"/>the example and the concept. Bucket name reference within the policy document is the first snippet we will see. Both <strong class="source-inline">Policy</strong> and <strong class="source-inline">Bucket</strong> MRs are in the same composition. The requirement is to refer to the bucket ARN name within the policy document JSON. Thankfully ARN identifiers have a predictable format, and we can construct the ARN from the bucket’s name. The bucket’s name is already available as both MRs are in the same composition, and the bucket name is an XR API input. Following is the code snippet showing the resource reference discussed. It patches the policy document attribute using the <strong class="source-inline">CombineFromComposite</strong> patch type. Here, the bucket name is embedded directly using an <strong class="source-inline">fmt</strong> string operation:</p>
			<pre class="source-code">- type: CombineFromComposite</pre>
			<pre class="source-code">  toFieldPath: spec.forProvider.document</pre>
			<pre class="source-code">  combine:</pre>
			<pre class="source-code">    variables:</pre>
			<pre class="source-code">    - fromFieldPath: spec.parameters.bucketName</pre>
			<pre class="source-code">    - fromFieldPath: spec.parameters.bucketName</pre>
			<pre class="source-code">    strategy: string</pre>
			<pre class="source-code">    string:</pre>
			<pre class="source-code">      fmt: |</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">          "Version": "2012-10-17",</pre>
			<pre class="source-code">          "Statement": [</pre>
			<pre class="source-code">            {</pre>
			<pre class="source-code">              "Effect": "Allow",</pre>
			<pre class="source-code">              "Action": [ "s3:*" ],</pre>
			<pre class="source-code">              "Resource": [</pre>
			<pre class="source-code">                "arn:aws:s3:::%s",</pre>
			<pre class="source-code">                "arn:aws:s3:::%s/*"</pre>
			<pre class="source-code">              ]</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">          ]</pre>
			<pre class="source-code">        }</pre>
			<p>Next, we will <a id="_idIndexMarker302"/>look at how the <strong class="source-inline">Policy</strong> resource ARN is <a id="_idIndexMarker303"/>extracted to pass it on to the inner nested <strong class="source-inline">XR - XIAMResourceUser</strong>. It works in two steps:</p>
			<ol>
				<li value="1">Patch the ARN identifier of the <strong class="source-inline">Policy</strong> object back into the API response attribute.</li>
				<li>Patch the extracted ARN identifier as an API input to the nested XR (<strong class="source-inline">XIAMResourceUser</strong>).</li>
			</ol>
			<p>Note that initially, <strong class="source-inline">XIAMResourceUser</strong> will fail till the <strong class="source-inline">Policy</strong> object is wholly created and ARN is available. It is the typical control-plane behavior to make the resources eventually consistent. Following is the code snippet of the ARN patching from two resources, <strong class="source-inline">Policy</strong> and <strong class="source-inline">XIAMResourceUser</strong>:</p>
			<pre class="source-code"># Policy - Patch API response with ARN</pre>
			<pre class="source-code">- type: ToCompositeFieldPath</pre>
			<pre class="source-code">  fromFieldPath: status.atProvider.arn</pre>
			<pre class="source-code">  toFieldPath: status.policyARN</pre>
			<pre class="source-code"># XIAMResourceUser - patch the policy arn as API input</pre>
			<pre class="source-code">- fromFieldPath: status.policyARN</pre>
			<pre class="source-code">  toFieldPath: spec.parameters.policyARN</pre>
			<p>Finally, we will look at the code snippet of the <strong class="source-inline">UserPolicyAttachment</strong> resource, where we have <a id="_idIndexMarker304"/>two external resources (<strong class="source-inline">User</strong> and <strong class="source-inline">Policy</strong>) using <a id="_idIndexMarker305"/>the different referencing methods. The policy reference will be made directly with the ARN identifier, and the user reference will be made using the selector. Refer to the following code:</p>
			<pre class="source-code">- base:</pre>
			<pre class="source-code">  apiVersion: iam.aws.crossplane.io/v1beta1</pre>
			<pre class="source-code">  kind: UserPolicyAttachment</pre>
			<pre class="source-code">  spec:</pre>
			<pre class="source-code">    providerConfigRef:</pre>
			<pre class="source-code">      name: aws-credentials</pre>
			<pre class="source-code">    forProvider:</pre>
			<pre class="source-code">    # Selectors refer to the User from the same composition </pre>
			<pre class="source-code">      userNameSelector:</pre>
			<pre class="source-code">        matchControllerRef: true</pre>
			<pre class="source-code">  patches:</pre>
			<pre class="source-code">  # Patch the resource name</pre>
			<pre class="source-code">  # &lt;Type&gt;-&lt;Parent Type&gt;-&lt;Parent Resource Name&gt;</pre>
			<pre class="source-code">  - type: CombineFromComposite</pre>
			<pre class="source-code">    toFieldPath: metadata.name</pre>
			<pre class="source-code">    combine:</pre>
			<pre class="source-code">      variables:</pre>
			<pre class="source-code">      - fromFieldPath: spec.parameters.resourceType</pre>
			<pre class="source-code">      - fromFieldPath: spec.parameters.resourceName</pre>
			<pre class="source-code">      strategy: string</pre>
			<pre class="source-code">      string:</pre>
			<pre class="source-code">        fmt: "policy-attachement-%s-%s"</pre>
			<pre class="source-code">  # Patch the policy ARN reference</pre>
			<pre class="source-code">  - toFieldPath: spec.forProvider.policyArn</pre>
			<pre class="source-code">    fromFieldPath: spec.parameters.policyARN</pre>
			<p>To execute the <a id="_idIndexMarker306"/>example yourself and validate the <a id="_idIndexMarker307"/>references, follow the next steps:</p>
			<ol>
				<li value="1">Apply XRDs and compositions to the target Crossplane.</li>
				<li>Next, apply the Claim configuration. It will create all the required resources and establish the required dependencies.</li>
			</ol>
			<p>The following screenshot shows successful bucket creation in AWS:</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B17830_06_08.jpg" alt="Figure 6.8 – S3 bucket provisioned&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – S3 bucket provisioned</p>
			<p>The following screenshot shows all the execution steps of the example:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B17830_06_09.jpg" alt="Figure 6.9 – Example execution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9 – Example execution</p>
			<p>Also, note that the <strong class="source-inline">User</strong> object <a id="_idIndexMarker308"/>is created with the <strong class="source-inline">Policy</strong> resource <a id="_idIndexMarker309"/>attached in the AWS console:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B17830_06_10.jpg" alt="Figure 6.10 – Created user execution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10 – Created user execution</p>
			<p>Finally, refer to the screenshot showing the events where <strong class="source-inline">XIAMResourceUser</strong> fails owing to the <a id="_idIndexMarker310"/>unavailability of the policy ARN. It will work <a id="_idIndexMarker311"/>automatically once the policy ARN is available:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B17830_06_11.jpg" alt="Figure 6.11 – XIAMResourceUser failure event&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11 – XIAMResourceUser failure event</p>
			<p class="callout-heading">Information</p>
			<p class="callout">Please note that we have not used <strong class="source-inline">MatchLabels</strong> in our selector reference. Only <strong class="source-inline">MatchControllerRef</strong> was used with <strong class="source-inline">true</strong> as the value. In this case, there was only one <strong class="source-inline">User</strong> object in the same composition, which can be referred to without any issue. We will use <strong class="source-inline">MatchLabels</strong> if we have more than one <strong class="source-inline">User</strong> object within the composition or if we want to refer to a recourse external to the current composition.</p>
			<p>We are done with the exploration of referring resources within and nested XR. We will refer to a resource outside the composition in the following section.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Referring to an outside resource</h2>
			<p>To refer to a <a id="_idIndexMarker312"/>resource outside the composition, we will use <strong class="source-inline">MatchLabels</strong> and <strong class="source-inline">MatchControllerRef</strong>. <strong class="source-inline">MatchControllerRef</strong> should be specified as <strong class="source-inline">false</strong>. This would refer to an outside resource, MR, or another resource inside a Claim/XR. We will modify the last example into two independent XRs and ensure that the <strong class="source-inline">UserPolicyAttachment</strong> object can refer to the <strong class="source-inline">Policy</strong> object from an independent XR using label selectors. The following diagram will represent the relation between the resources, their reference option, and the XR boundary:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B17830_06_12.jpg" alt="Figure 6.12 – Referring to an outside resource&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12 – Referring to an outside resource</p>
			<p>Note that the XRs are not nested here. The <strong class="source-inline">XMyBucket</strong> XR will not have <strong class="source-inline">XIAMResourceUser</strong> as one <a id="_idIndexMarker313"/>of the resources. Providing a scenario where both XRs are independent, the <strong class="source-inline">Policy</strong> object must refer to the XR using a label selector. Let’s look at a couple of essential code snippets that reference resources using selector labels. Following is the code that adds a couple of labels to the <strong class="source-inline">Policy</strong> resource. The first label, <strong class="source-inline">resourceType</strong>, is added directly to the metadata. The second label, <strong class="source-inline">resourceName</strong>, is patched using the bucket name, which is the input parameter for the XR:</p>
			<pre class="source-code">- base:</pre>
			<pre class="source-code">  apiVersion: iam.aws.crossplane.io/v1beta1</pre>
			<pre class="source-code">  kind: Policy</pre>
			<pre class="source-code">  metadata:</pre>
			<pre class="source-code">    # Add labels one as the resource type</pre>
			<pre class="source-code">    labels:</pre>
			<pre class="source-code">      resourceType: bucket</pre>
			<pre class="source-code">  spec:</pre>
			<pre class="source-code">    providerConfigRef:</pre>
			<pre class="source-code">      name: aws-credentials</pre>
			<pre class="source-code">    forProvider:</pre>
			<pre class="source-code">      path: "/"</pre>
			<pre class="source-code">  patches:</pre>
			<pre class="source-code">  # patch labels two from the resource name</pre>
			<pre class="source-code">  - fromFieldPath: spec.parameters.bucketName</pre>
			<pre class="source-code">    toFieldPath: metadata.labels[resourceName]</pre>
			<p>The next part of the code will patch both <strong class="source-inline">resourceName</strong> and <strong class="source-inline">resourceType</strong> labels to the <strong class="source-inline">UserPolicyAttachment</strong> resource. It will be patched under policyArnSelector’s <strong class="source-inline">MatchLabels</strong> attribute. Both label values are part of the XR API input. You can <a id="_idIndexMarker314"/>decide on your predictable labeling strategy to make this discovery process standard. Note that the <strong class="source-inline">MatchControllerRef</strong> value is <strong class="source-inline">true</strong> for the <strong class="source-inline">User</strong> object reference within the XR and <strong class="source-inline">false</strong> for the <strong class="source-inline">Policy</strong> object reference across the XR:</p>
			<pre class="source-code">- base:</pre>
			<pre class="source-code">  apiVersion: iam.aws.crossplane.io/v1beta1</pre>
			<pre class="source-code">  kind: UserPolicyAttachment</pre>
			<pre class="source-code">  spec:</pre>
			<pre class="source-code">    providerConfigRef:</pre>
			<pre class="source-code">      name: aws-credentials</pre>
			<pre class="source-code">    forProvider:</pre>
			<pre class="source-code">      # refer to the IAM user from the same composition </pre>
			<pre class="source-code">      userNameSelector:</pre>
			<pre class="source-code">        matchControllerRef: true</pre>
			<pre class="source-code">      policyArnSelector:</pre>
			<pre class="source-code">        matchControllerRef: false</pre>
			<pre class="source-code">  patches:</pre>
			<pre class="source-code">  # Patch the policy ARN lable 1</pre>
			<pre class="source-code">  - toFieldPath: spec.forProvider.policyArnSelector.matchLabels.resourceName</pre>
			<pre class="source-code">    fromFieldPath: spec.parameters.resourceName</pre>
			<pre class="source-code">  # Patch the policy ARN lable 2</pre>
			<pre class="source-code">  - toFieldPath: spec.forProvider.policyArnSelector.matchLabels.resourceType</pre>
			<pre class="source-code">    fromFieldPath: spec.parameters.resourceType</pre>
			<p>The example discussed is available at <a href="https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter06/Hand-on-examples/different-xr-reference">https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter06/Hand-on-examples/different-xr-reference</a>. To fully experience resource provisioning, apply <strong class="source-inline">composition-IAM.yaml</strong>, <strong class="source-inline">composition-bucket.yaml</strong>, <strong class="source-inline">xrd-IAM.yaml</strong>, and <strong class="source-inline">xrd-bucket.yaml</strong> to the target Crossplane cluster. It will create both XRs and their respective <a id="_idIndexMarker315"/>compositions. Then, apply <strong class="source-inline">claim-bucket.yaml</strong> and <strong class="source-inline">claim-iam.yaml</strong> to create the resources. The following screenshot covers full execution of the example:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B17830_06_13.jpg" alt="Figure 6.13 – Referring to an outside resource – Example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.13 – Referring to an outside resource – Example</p>
			<p>Like <em class="italic">Figure 6.10</em>, the <strong class="source-inline">User</strong> object will be created with the <strong class="source-inline">Policy</strong> resource attached in the AWS console. We have now completed our exploration of resource references. The following section will look at secret propagation with a hands-on example.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor100"/>Secret propagation hands-on</h1>
			<p>Secret propagation is a critical Crossplane pattern, as all resources provisioned generally require credentials <a id="_idIndexMarker316"/>to access the resource. We covered the same topic in <a href="B17830_04_ePub.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a>, as theory. Now, we will go through a hands-on journey using a real-world example. Before jumping into the example, let’s brush up on the concept quickly in <a id="_idIndexMarker317"/>a few points:</p>
			<ul>
				<li>Define the list of secret keys in XRD using the <strong class="source-inline">ConnectionSecretKeys</strong> attribute.</li>
				<li>Define the namespace and secret name under the respective resource using the <strong class="source-inline">WriteConnectionSecretToRef</strong> configuration.</li>
				<li>Finally, populate the secret keys defined in the XRD using the <strong class="source-inline">ConnectionDetails</strong> configuration.</li>
			</ul>
			<p>We will expand the hands-on example used for resource reference with nested XR to learn configurations for storing the secret. We created an S3 bucket, its policy, and an IAM user to access the bucket in that specific example. The example will not be fully finished until we extract the bucket details and IAM credentials into secrets. That is what we will exactly try to do in this example. The bucket details are already available in the Bucket resource, but we need to create a new resource named <strong class="source-inline">AccessKey</strong> attached to the created user for IAM credentials. The following diagram will represent the two XRs, their resources, and the secret key storage structure:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B17830_06_14.jpg" alt="Figure 6.14 – Secret propagation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.14 – Secret propagation</p>
			<p>Let’s look at some <a id="_idIndexMarker318"/>of the critical code snippets from the example. Following is the code from <strong class="source-inline">XIAMWithCredential</strong> and <strong class="source-inline">XBucketWithCredential</strong> to list the secret keys:</p>
			<pre class="source-code"># List of secrets defined in XRD - XBucketWithCredential</pre>
			<pre class="source-code">connectionSecretKeys:</pre>
			<pre class="source-code">  - bucket_url</pre>
			<pre class="source-code"># List of secrets defined in XRD - XIAMWithCredential</pre>
			<pre class="source-code">connectionSecretKeys:</pre>
			<pre class="source-code">  - iam_username</pre>
			<pre class="source-code">  - iam_password</pre>
			<p>It was a simple list of secret keys under the <strong class="source-inline">ConnectionSecretKeys</strong> attribute in the XRD YAML. The secret name and storage namespace must be pushed to the resource to copy the secret key. Note that the namespace for the secret is automatically extracted out of the Claim. Following is the code from <strong class="source-inline">AccessKey</strong> and the <strong class="source-inline">Bucket</strong> resource to <a id="_idIndexMarker319"/>define the secret name and storage namespace:</p>
			<pre class="source-code"># Secret name and namespace patching for Bucket resource</pre>
			<pre class="source-code"># Namespace to save the secret same as the resource namespace</pre>
			<pre class="source-code">- fromFieldPath: spec.claimRef.namespace</pre>
			<pre class="source-code">  toFieldPath: spec.writeConnectionSecretToRef.namespace</pre>
			<pre class="source-code"># Generate and patch the kubernete secret name </pre>
			<pre class="source-code">- fromFieldPath: spec.parameters.bucketName</pre>
			<pre class="source-code">  toFieldPath: spec.writeConnectionSecretToRef.name</pre>
			<pre class="source-code">  transforms:</pre>
			<pre class="source-code">  - type: string</pre>
			<pre class="source-code">    string:</pre>
			<pre class="source-code">      fmt: "details-bucket-%s"</pre>
			<pre class="source-code"># Secret name and namespace patching for AccessKey resource</pre>
			<pre class="source-code"># Namespace to save the secret is the same as the resource</pre>
			<pre class="source-code">- fromFieldPath: spec.parameters.secretNamespace</pre>
			<pre class="source-code">  toFieldPath: spec.writeConnectionSecretToRef.namespace</pre>
			<pre class="source-code"># Generate and patch the kubernete secret name </pre>
			<pre class="source-code">- type: CombineFromComposite</pre>
			<pre class="source-code">  toFieldPath: spec.writeConnectionSecretToRef.name</pre>
			<pre class="source-code">  combine:</pre>
			<pre class="source-code">    variables:</pre>
			<pre class="source-code">    - fromFieldPath: spec.parameters.resourceType</pre>
			<pre class="source-code">    - fromFieldPath: spec.parameters.resourceName</pre>
			<pre class="source-code">    strategy: string</pre>
			<pre class="source-code">    string:</pre>
			<pre class="source-code">      fmt: "credentials-%s-%s"</pre>
			<p>The final <a id="_idIndexMarker320"/>configuration we will look at is the actual copy of secrets into the keys defined at XRD. The following is the code from <strong class="source-inline">AccessKey</strong> and the <strong class="source-inline">Bucket</strong> resource to perform the same:</p>
			<pre class="source-code"># Populate the connection secret keys from AccessKey secrets</pre>
			<pre class="source-code">connectionDetails:</pre>
			<pre class="source-code">- name: iam_username</pre>
			<pre class="source-code">  fromConnectionSecretKey: username</pre>
			<pre class="source-code">- name: iam_password</pre>
			<pre class="source-code">  fromConnectionSecretKey: password</pre>
			<pre class="source-code"># Copy the endpoint secret key to bucketURL for </pre>
			<pre class="source-code">connectionDetails:</pre>
			<pre class="source-code">- name: bucketURL</pre>
			<pre class="source-code">  fromConnectionSecretKey: endpoint</pre>
			<p>The example discussed is available at <a href="https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter06/Hand-on-examples/secret-propagation">https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter06/Hand-on-examples/secret-propagation</a>. To fully experience the secret creation in the Kubernetes cluster, create the XR, composition, and Claim from the preceding link. The following screenshot covers the complete example execution:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B17830_06_15.jpg" alt="Figure 6.15 – Secret propagation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.15 – Secret propagation</p>
			<p>Once the resources are created in their entirety, you will see that the secrets are available <a id="_idIndexMarker321"/>inside the alpha namespace:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B17830_06_16.jpg" alt="Figure 6.16 – Created secret&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.16 – Created secret</p>
			<p class="callout-heading">Information</p>
			<p class="callout">May organizations prefer to store secrets in a key vault rather than Kubernetes secrets. There is an example on the Crossplane website to execute this integration at <a href="https://crossplane.io/docs/v1.6/guides/vault-injection.html">https://crossplane.io/docs/v1.6/guides/vault-injection.html</a>. The Crossplane team is working on a more straightforward way to do this using an MR. The MR will represent the specific external vault resource and push the secrets accordingly. Keep watching the Crossplane release.</p>
			<p>This concludes our exploration of secrets. The next section of this chapter will use the Crossplane Helm provider to deploy an application in a remote Kubernetes cluster. It will continue what we looked at in <a href="B17830_05_ePub.xhtml#_idTextAnchor074"><em class="italic">Chapter 5</em></a>, in the <em class="italic">Managing external software resources </em>section.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/>Helm provider hands-on</h1>
			<p>It is exciting to introduce this aspect of Crossplane. It is precisely the crossroads where it unifies infrastructure <a id="_idIndexMarker322"/>automation and application automation. After creating an infrastructure resource, we would be interested in doing additional operations. For example, after deploying a Kubernetes cluster, we would be interested in setting up Prometheus or deploying an application in the remote Kubernetes cluster. Helm Crossplane provider can perform this operation.</p>
			<p>Similarly, after provisioning a database, we will be interested in creating tables. SQL provider can perform these activities from Crossplane. The examples open a way to define all application dependencies in Crossplane and package them along with infrastructure. This section will go through a hands-on journey to experiment with Crossplane Helm provider. We will use GCP to create a Kubernetes cluster. It will fit well within the free tier limits. The following diagram represents how the Helm provider works inside the Crossplane ecosystem to manage application deployment in a remote Kubernetes cluster:</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B17830_06_17.jpg" alt="Figure 6.17 – Helm provider and GKE&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.17 – Helm provider and GKE</p>
			<p>Let’s look at the details of how different components work together to manage applications using Helm in a few steps:</p>
			<ol>
				<li value="1">With your <a id="_idIndexMarker323"/>existing GCP provider and provider configuration, we can create a <strong class="bold">Google Kubernetes Engine</strong> (<strong class="bold">GKE</strong>) using the <strong class="source-inline">Cluster.container.gcp.crossplane.io</strong> MR.</li>
				<li>Define the namespace and secret name in the MR to store the remote cluster credentials.</li>
				<li>Install the Helm provider in the <a id="_idIndexMarker324"/>Crossplane control plane using the respective configuration YAML.</li>
				<li>Next, set up the provider configuration for Helm provider using the Kubernetes credentials and GCP credentials stored in the Kubernetes secrets.</li>
				<li>Now we can create the Helm releases in the remote GKE cluster using the <strong class="source-inline">Release.helm.crossplane.io</strong> MR.</li>
			</ol>
			<p>Refer to the following code for the Helm provider configuration YAML:</p>
			<pre class="source-code">apiVersion: pkg.crossplane.io/v1</pre>
			<pre class="source-code">kind: Provider</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: provider-helm</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  package: crossplane/provider-helm:master</pre>
			<p>The following is the configuration for the Helm provider GKE. It requires credentials from both the Kubernetes cluster and the cloud provider. The secret reference under the credentials section refers to a specific Kubernetes cluster. The secret reference under the identity section refers to the GCP cloud credentials. The identity section of credentials may not be available for other cloud providers. Ensure that the Kubernetes APIs are enabled for the GCP cloud credentials:</p>
			<pre class="source-code">apiVersion: helm.crossplane.io/v1beta1</pre>
			<pre class="source-code">kind: ProviderConfig</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: helm-provider</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  # GKE credentials </pre>
			<pre class="source-code">  credentials:</pre>
			<pre class="source-code">    source: Secret</pre>
			<pre class="source-code">    secretRef:</pre>
			<pre class="source-code">      name: secret-gke-for-helm-deployment</pre>
			<pre class="source-code">      namespace: crossplane-system</pre>
			<pre class="source-code">      key: kubeconfig</pre>
			<pre class="source-code">  # GCP credentials</pre>
			<pre class="source-code">  identity:</pre>
			<pre class="source-code">    type: GoogleApplicationCredentials</pre>
			<pre class="source-code">    source: Secret</pre>
			<pre class="source-code">    secretRef:</pre>
			<pre class="source-code">      name: gcp-account</pre>
			<pre class="source-code">      namespace: crossplane-system</pre>
			<pre class="source-code">      key: service-account</pre>
			<p>Before applying the provider configuration, we must ensure that the GKE cluster is created and <a id="_idIndexMarker325"/>that its credentials are stored secretly. All examples of the Helm provider experiment are available at <a href="https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter06/Hand-on-examples/helm-provider">https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter06/Hand-on-examples/helm-provider</a>. Apply <strong class="source-inline">GKE.yaml</strong> to create the cluster. Refer to the following screenshot of GKE cluster creation, Helm provider installation, and provider configuration setup:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B17830_06_18.jpg" alt="Figure 6.18 – GKE and Helm provider setup&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.18 – GKE and Helm provider setup</p>
			<p>Now we can start managing application deployment in the GKE cluster using Helm. The release is the <a id="_idIndexMarker326"/>MR construct available in Helm provider used to manage applications. Release MR has the following vital configurations:</p>
			<ul>
				<li>The <strong class="source-inline">spec.forProvider.chart</strong> configuration will hold basic information about the chart, such as the repository name, chart name, and version.</li>
				<li><strong class="source-inline">spec.forProvider.valuesFrom</strong>, <strong class="source-inline">spec.forProvider.values</strong>, and <strong class="source-inline">spec.forProvider.set</strong> are the three different ways to provide the values for the Helm templated variables. If we set the values for the same variable in multiple ways, then the order of preference will be the same as the order mentioned previously.</li>
				<li><strong class="source-inline">spec.forProvider.patchesFrom</strong> will be helpful in specifying post-rendering patches to override values at the last mile before deployment.</li>
			</ul>
			<p>Refer to a simple <strong class="source-inline">Release</strong> configuration:</p>
			<pre class="source-code">apiVersion: helm.crossplane.io/v1beta1</pre>
			<pre class="source-code">kind: Release</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: redis-crossplane-example</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  providerConfigRef:</pre>
			<pre class="source-code">    name: helm-provider</pre>
			<pre class="source-code">  forProvider:</pre>
			<pre class="source-code">    chart:</pre>
			<pre class="source-code">      name: hello</pre>
			<pre class="source-code">      repository: https://www.kleinloog.ch/hello-helm/</pre>
			<pre class="source-code">      version: 0.3.0</pre>
			<pre class="source-code">    namespace: default</pre>
			<p>Applying the preceding configuration will create the hello world example in the GKE cluster. Refer to the following screenshot with application deployment:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B17830_06_19.jpg" alt="Figure 6.19 – Crossplane Helm deployment&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.19 – Crossplane Helm deployment</p>
			<p>The same <strong class="source-inline">Release</strong> MR from the Crossplane Helm provider also handles upgrades to our initial release of the Helm chart. We can change the required chart information, values, or patches <a id="_idIndexMarker327"/>and re-apply the YAML to upgrade our release. Apply <strong class="source-inline">Helm-test-deploy-upgrade.yaml</strong>, which changes the container version to move our release version. Before creating an upgraded release, the <strong class="source-inline">Release controller</strong> MR checks any actual change to the configuration. It will make sure that there are no unnecessary releases. Refer to the following screenshot showing an upgraded release:</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B17830_06_20.jpg" alt="Figure 6.20 – Crossplane Helm release upgrade&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.20 – Crossplane Helm release upgrade</p>
			<p>This concludes our Helm experimentation for now. The following section will rescue us from code and help us learn some guiding principles to define the XR API boundaries.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">In all our examples, we referred to composition directly with its name in the Claim/XRs. We can also refer to the composition using label selectors after adding the respective labels in the composition metadata.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor102"/>Defining API boundaries</h1>
			<p>We expect platform engineers to compose all the infrastructure and application automation <a id="_idIndexMarker328"/>concerns in XR APIs. How to define an API boundary is a bit tricky. It’s because many conflicting trade-off points are influencing the API boundaries. Let’s start with the fact that we wanted to compose every resource required for an application and its infrastructure in a single composition. Here are some considerations that will not allow us to do that:</p>
			<ul>
				<li>There would be many security and architecture policies that need to centralize. We cannot add them again and again in multiple compositions.</li>
				<li>Some resources may have compliance requirements and must be composed separately for audit purposes.</li>
				<li>Overly big compositions are difficult to read, understand, debug, and refactor.</li>
				<li>Testing a bulk composition is difficult.</li>
				<li>Every application will require some customization to the infrastructure recipe, provided we have a bulk composition. We will fork the main code for customization. It will be challenging to maintain as we grow.</li>
				<li>Specific infrastructure such as the network layer is owned by a particular team. It must be composed separately and referred to in the required XR.</li>
			</ul>
			<p>There could be more reasons depending upon your organization’s realities. In summary, we must build small XR APIs and organize them together with resource references and nested XRs. As soon as we talk about small XR APIs, API boundary questions arise. Which are the resources that make sense to be composed together? It is something like what we do in the world of microservices. A merge versus a split trade-off is something that we always do in microservices.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">It’s challenging to get the boundary correct on the first go. We should do our initial trade-off analysis, which provides an initial boundary and then evolves in iterations based on real-world experience.</p>
			<p>Earlier in our S3 bucket example, we composed the bucket and its policy in a single XR. The second <a id="_idIndexMarker329"/>nested XR was holding the IAM user and policy attachment resource. This design can ensure that the IAM XR can be used with other resources.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">Later in <a href="B17830_10_ePub.xhtml#_idTextAnchor154"><em class="italic">Chapter 10</em></a>, <em class="italic">Onboarding Applications with Crossplane</em>, we will do a trade-off analysis of a hands-on journey example to analyze the impact of different API boundaries.</p>
			<p>The following diagram covers different factors influencing the trade-off analysis:</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B17830_06_21.jpg" alt="Figure 6.21 – Crossplane Helm release upgrade&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.21 – Crossplane Helm release upgrade</p>
			<p>This concludes <a id="_idIndexMarker330"/>the API boundary discussion. In the following section of the chapter, we will explore monitoring the Crossplane control plane.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Alerts and monitoring</h1>
			<p>Prometheus and <a id="_idIndexMarker331"/>Grafana, the popular tools in the Kubernetes <a id="_idIndexMarker332"/>world, can be used for Crossplane monitoring as well. Before starting, we should ensure that the Crossplane pod can emit metrics. It is as simple as setting the metrics parameter to <strong class="source-inline">true</strong> (<strong class="source-inline">--set metrics.enabled=true</strong>) during the Helm deployment of Crossplane. We can do it either at the first Crossplane release or upgrade the Helm release using the following command:</p>
			<pre class="source-code"># Fresh install with metrics enables</pre>
			<pre class="source-code">helm install crossplane --namespace crossplane-system crossplane-stable/crossplane --set args='{--debug}' --set metrics.enabled=true</pre>
			<pre class="source-code"># Helm upgrade with metrics enables</pre>
			<pre class="source-code">helm upgrade crossplane --namespace crossplane-system crossplane-stable/crossplane --set args='{--debug}' --set metrics.enabled=true</pre>
			<p>We can split the <a id="_idIndexMarker333"/>monitoring and alert setup into three <a id="_idIndexMarker334"/>parts:</p>
			<ul>
				<li>Enable Prometheus to scrape metrics.</li>
				<li>Set up monitoring alerts.</li>
				<li>Enable the Grafana dashboard.</li>
			</ul>
			<p>We can start first with metric scraping.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>Enabling Prometheus to scrape metrics</h2>
			<p>First, we must <a id="_idIndexMarker335"/>set up <a id="_idIndexMarker336"/>Prometheus in the Kubernetes control plane. We will do this installation using the Prometheus operator. You can look at the quick start guide at <a href="https://prometheus-operator.dev/docs/prologue/quick-start/">https://prometheus-operator.dev/docs/prologue/quick-start/</a>. The following <a id="_idIndexMarker337"/>are the simple steps to get the Prometheus operator installed:</p>
			<pre class="source-code"># Step 1: Clone the Prometheus operator repository and switch to the folder</pre>
			<pre class="source-code">git clone https://github.com/prometheus-operator/kube-prometheus.git</pre>
			<pre class="source-code">cd kube-prometheus</pre>
			<pre class="source-code"># Step 2: Execute the initial setup instructions</pre>
			<pre class="source-code">kubectl create -f manifests/setup</pre>
			<pre class="source-code"># Step 3: Install the operator</pre>
			<pre class="source-code">kubectl create -f manifests/</pre>
			<pre class="source-code"># Step 4: Once the pods are up and running, view the dashboard after the port forward </pre>
			<pre class="source-code">kubectl --namespace monitoring port-forward svc/Prometheus-k8s 9090</pre>
			<pre class="source-code">http://localhost:9090/</pre>
			<p>All configurations required for the monitoring example are available at <a href="https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter06/Hand-on-examples/monitoring">https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter06/Hand-on-examples/monitoring</a>. Once you have Prometheus installed, the next step is to ask Prometheus to scrape the metrics from the Crossplane <a id="_idIndexMarker338"/>and GCP provider <a id="_idIndexMarker339"/>pods. We need to add <strong class="source-inline">ControllerConfig</strong> to the GCP provider to define the metrics port. Configuration of the same is available in <strong class="source-inline">GCP-Provider.yaml</strong>. Then, we can configure <strong class="source-inline">PodMonitor</strong>, which instructs Prometheus to scrape metrics from a specific POD at a given port. Configuration of the same is available in <strong class="source-inline">monitor.yaml</strong>. Once these steps are done, we can start looking at the controller reconciliation metrics in the Prometheus console. Create a GCP <strong class="source-inline">CloudSQLInstance</strong> instance with an incorrect configuration, which will not reconcile, and look at the reconciliation failure metrics. The following is the Prometheus query for the reconciliation failure metrics from <strong class="source-inline">CloudSQLInstance</strong>:</p>
			<pre class="source-code">sum_over_time(controller_runtime_reconcile_errors_total{namespace="crossplane-system", controller="managed/cloudsqlinstance.database.gcp.crossplane.io"}[5m])</pre>
			<p>Refer to the following screenshot where we are looking at the reconciliation failure metrics for <strong class="source-inline">CloudSQLInstance</strong>:</p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B17830_06_22.jpg" alt="Figure 6.22 – Metrics&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.22 – Metrics</p>
			<p>The next step <a id="_idIndexMarker340"/>is to set up <a id="_idIndexMarker341"/>monitoring alerts for the reconciliation failure scenarios.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>Setting up monitoring alerts</h2>
			<p>We can also set up alerts for this reconciliation error using the following configuration. It may be too <a id="_idIndexMarker342"/>much to trigger alerts for <a id="_idIndexMarker343"/>every reconciliation failure. Additionally, some of the reconciliation errors are expected scenarios. For example, if one resource is referring to another, the referring resource will fail to reconcile until the referred resource is provisioned. The following alert configuration is configured to throw an alert only if the reconciliation error exceeds 20 times within a 5-minute window:</p>
			<pre class="source-code">apiVersion: monitoring.coreos.com/v1</pre>
			<pre class="source-code">kind: PrometheusRule</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: sql-alerts</pre>
			<pre class="source-code">  namespace: crossplane-system</pre>
			<pre class="source-code">  labels:</pre>
			<pre class="source-code">    app.kubernetes.io/part-of: crossplane</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  groups:</pre>
			<pre class="source-code">  - name: Crossplane</pre>
			<pre class="source-code">    rules:</pre>
			<pre class="source-code">    - alert: ReconciliationFailure</pre>
			<pre class="source-code">      expr: sum_over_time(controller_runtime_reconcile_errors_total{namespace="crossplane-system", controller="managed/cloudsqlinstance.database.gcp.crossplane.io"}[5m]) &gt; 20</pre>
			<pre class="source-code">      for: 5m</pre>
			<pre class="source-code">      labels:</pre>
			<pre class="source-code">        severity: page</pre>
			<pre class="source-code">      annotations:</pre>
			<pre class="source-code">summary: '{{ $labels.controller }} reconciliation has been failing for more than 20 time in the last 5 minutes.'</pre>
			<p>Refer to the following <a id="_idIndexMarker344"/>screenshot <a id="_idIndexMarker345"/>where we are looking at the reconciliation failure alert:</p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B17830_06_23.jpg" alt="Figure 6.23 – Alerts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.23 – Alerts</p>
			<p class="callout-heading">Information</p>
			<p class="callout">The list of metrics emitted by Crossplane is an area to be improved. We should get detailed metrics around compositions and Claims. We can expect more enhancements happening soon from the Crossplane community.</p>
			<p>The final step involves setting up the Grafana dashboard to visualize the metrics and errors better.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Enabling the Grafana dashboard</h2>
			<p>Finally, we can set up <a id="_idIndexMarker346"/>a Grafana dashboard to visualize the <a id="_idIndexMarker347"/>metrics, logs, and alerts. The Grafana dashboard will already be installed in the cluster as part of the Prometheus Operator. What we must do additionally is to set up a dashboard for the Crossplane control plane. At <strong class="source-inline">grafana.json</strong> in the Git repository, I have added a sample dashboard configuration from the Crossplane community. Import the JSON into Grafana and look through the metrics. Refer to the following Grafana screenshot, which indicates that CloudSQLInstance is the active controller running the reconciliation loop:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B17830_06_24.jpg" alt="Figure 6.24 – Grafana metrics view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.24 – Grafana metrics view</p>
			<p>We will conclude <a id="_idIndexMarker348"/>the monitoring concepts here and move on to the <a id="_idIndexMarker349"/>final section of the chapter, which covers a few troubleshooting patterns.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>More troubleshooting patterns</h1>
			<p>We explored different troubleshooting patterns in the last couple of chapters and earlier in this chapter. It covered ways to look at resource references in the resource description to <a id="_idIndexMarker350"/>move from composition to the MR, using the event logs in the resource description, and enabling Crossplane/provider pod logs to debug. This section will add a couple more debugging skills to enhance our platform development skills. The following are the new patterns we will look at:</p>
			<ul>
				<li><strong class="bold">Pause the Crossplane</strong>: Sometimes, there may be a requirement to stop the controller <a id="_idIndexMarker351"/>reconciliation loop in order to debug resource issues. We <a id="_idIndexMarker352"/>can simply edit the Crossplane deployment to make the replication count to zero. This is the simplest way to pause Crossplane during our debug window. Once our debugging is done, we can restore the replication count. Similarly, we can also pause <a id="_idIndexMarker353"/>the Providers. We reduce the provider replication count to <a id="_idIndexMarker354"/>zero using <strong class="source-inline">ControllerConfig</strong> (the configuration we used earlier to enable debugging and expose the metrics port). </li>
				<li><strong class="bold">Hung resources</strong>: Sometimes, we may notice that the resources are hung, and we cannot delete them. It should be because of the finalizers. We should patch the resource with an empty finalizer and delete it again. This will guarantee resource <a id="_idIndexMarker355"/>deletion only in the Crossplane <a id="_idIndexMarker356"/>control plane. It is not <a id="_idIndexMarker357"/>guaranteed that the resource is deleted from the external provider. We must visit the external provider console to validate whether the resources are deleted. The following code will render the finalizers empty:<p class="source-code">kubectl patch &lt;resource-type&gt; &lt;resource-name&gt; -p '{"metadata":{"finalizers": []}}' --type=merge</p></li>
			</ul>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Summary</h1>
			<p>This chapter covered many new Crossplane patterns required to build the state-of-the-art resource composing control plane. I am explicitly mentioning the resource composing control plane instead of the infrastructure composing control plane because we no longer compose only external cloud provider resources. We experimented with resource referencing, secret propagation, and Helm deployment with the help of hands-on examples. We also looked at setting up monitoring with another hands-on example. In addition to these hands-on journeys, we also learned some debugging skills and ways to define our API boundaries.</p>
			<p>The next chapter will cover different ways to extend and scale Crossplane.</p>
		</div>
	</body></html>