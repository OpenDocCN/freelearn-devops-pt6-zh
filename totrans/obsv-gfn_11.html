<html><head></head><body>
		<div id="_idContainer159">
			<h1 id="_idParaDest-206" class="chapter-number"><a id="_idTextAnchor218"/>11</h1>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor219"/>Architecting an Observability Platform</h1>
			<p>This chapter covers several topics related to <strong class="bold">architecting</strong> a great observability platform for teams in an organization to use. We will discuss how to structure data into <strong class="bold">domains</strong> to help find relevant data quickly in even the largest organizations, and how that relates to other aspects of the business, such as financial reporting and <strong class="bold">business intelligence</strong> (<strong class="bold">BI</strong>). Then, we will discuss architecting the four main system components of an observability platform: <strong class="bold">data production</strong>, <strong class="bold">data collection</strong>, <strong class="bold">data storage</strong>, and data uses such as <strong class="bold">visualization</strong> and <strong class="bold">alerting</strong>. We will cover how to link the architecture with the IaC tools that were discussed in <a href="B18277_10.xhtml#_idTextAnchor204"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>. After that, we will discuss how to use various easily available tools to validate a design with local testing. These tools can also be used in CI/CD pipelines<a id="_idIndexMarker932"/> to validate the platform after a change has been implemented. We will discuss the <strong class="bold">role-based access controls</strong> (<strong class="bold">RBACs</strong>) that are implemented in Grafana and how to set them up to provide least-privilege access. Finally, we will briefly discuss how to architect connections with other systems<a id="_idIndexMarker933"/> that make use of the same telemetry, such as <strong class="bold">security information and event management</strong> (<strong class="bold">SIEM</strong>) or BI systems. This chapter is aimed at a senior technical audience who has experience in architecting platforms <span class="No-Break">and systems.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Architecting your <span class="No-Break">observability platform</span></li>
				<li>Proving theoretical designs (proof <span class="No-Break">of concept)</span></li>
				<li>Setting the right <span class="No-Break">access levels</span></li>
				<li>Sending telemetry to <span class="No-Break">other consumers</span></li>
			</ul>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor220"/>Architecting your observability platform</h1>
			<p>Understanding and articulating<a id="_idIndexMarker934"/> the problem(s) your organization is trying to solve is the most critical and undervalued aspect of a well-architected observability platform. There are some common problems that organizations are trying to solve with observability, but every organization is different, and working with people such as <em class="italic">Masha</em> (senior leadership, as introduced in <a href="B18277_01.xhtml#_idTextAnchor018"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>) to understand the business needs is a step that is often missed and can lead to complex problems in <span class="No-Break">the future.</span></p>
			<p>Here are some common problems<a id="_idIndexMarker935"/> that organizations face that can be solved<a id="_idIndexMarker936"/> with an <span class="No-Break">observability platform:</span></p>
			<ul>
				<li><strong class="bold">Customer-affecting incidents</strong>: These types of incidents could range from downtime to data breaches. These pose a compliance, operational, and reputational risk to the organization. The customers could be internal or external to <span class="No-Break">the organization.</span></li>
				<li><strong class="bold">Understanding the organization’s key performance indicators (KPIs)</strong>: Organizations often want to have a clear understanding of the current state of their KPIs. These KPIs articulate whether the organization is doing well or whether something <span class="No-Break">needs addressing.</span></li>
				<li><strong class="bold">Understanding how customers use products</strong>: Understanding how customers interact with an organization’s products can identify pain points and help guide a better experience. Offering great products gives the organization a <span class="No-Break">competitive advantage.</span></li>
				<li><strong class="bold">Understanding the financial costs of serving customers</strong>: This<a id="_idIndexMarker937"/> is commonly<a id="_idIndexMarker938"/> known as the <strong class="bold">cost of goods sold</strong> (<strong class="bold">COGS</strong>) and <strong class="bold">operating </strong><span class="No-Break"><strong class="bold">expenses</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">OPEX</strong></span><span class="No-Break">).</span></li>
			</ul>
			<p>In this section, we will consider how to architect the data structures used in an observability platform to support the organization’s goals. We’ll talk about the process of designing a system architecture and the considerations you should make to support the operational needs of the organization. Finally, we will think about designing management and automation processes so that following the best practices you establish becomes the easiest path for teams <span class="No-Break">to take.</span></p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor221"/>Defining a data architecture</h2>
			<p>A data architecture defines an organization’s data assets<a id="_idIndexMarker939"/> and maps how data flows through the organization’s systems. Most organizations will already have a data architecture in place, so it is worth discussing with the team responsible. In this section, we will discuss how the field names and data types in the observability platform need to match or be translatable into common fields across <span class="No-Break">the organization.</span></p>
			<p>Observability systems are inherently data systems. They collect, process, move, store, and use data. The data in an observability system is most valuable to the wider organization when it is compatible with other data systems so the organization can merge datasets. The crux of this is that when embarking on this journey, talk to people throughout the organization and find out who is responsible for the data architecture of the whole organization. If no one exists in that position, it can be raised with senior leadership as a hindrance to solving the problems they are trying to address. For example, when I was a junior engineer, I remember having many meetings discussing whether <strong class="source-inline">tenantID</strong> and <strong class="source-inline">customerID</strong> were different fields or not as there were two systems that used different names. Ultimately, it was decided they were different concepts so the business could capture the idea of principal and subsidiary organizations that were customers of the company. However, both systems then needed months of work to implement this wider concept. The logging platform also needed a lot of data model rebuilding to capture this new concept. This work would have been entirely avoidable by having someone responsible for the data model and defining the requirements <span class="No-Break">early on.</span></p>
			<p>It is common to use data models from other areas of the organization when implementing an observability platform. There is a step that should be completed by an architect where they translate external requirements into a requirements document detailing where fields should be recorded. For example, it may be a requirement of the financial data model to record cost centers. There are many ways to achieve this, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li>Requiring every log line, every metric, and every trace to include <span class="No-Break">this information</span></li>
				<li>Requiring every service to be tagged with an <span class="No-Break"><strong class="source-inline">organization.costcenter</strong></span><span class="No-Break"> label</span></li>
				<li>Maintaining a lookup table of service name ↔ <span class="No-Break">cost center</span></li>
			</ul>
			<p>The requirements guide<a id="_idIndexMarker940"/> should be clear on how this will be achieved for teams who will be meeting the requirements. We recommend a document structure such as <strong class="bold">MoSCoW</strong>, which stands for <strong class="bold">Must have, Should have, Could have, </strong><span class="No-Break"><strong class="bold">Won’t have</strong></span><span class="No-Break">.</span></p>
			<p>Different telemetry types are best suited for different data types. Observability systems are also packed with features to gather data from other systems, such as Kubernetes object labels and cloud tags. These should form part of the data architecture. Here are some telemetry types<a id="_idIndexMarker941"/> and what they are best <span class="No-Break">suited for:</span></p>
			<ul>
				<li><strong class="bold">Log fields in Loki</strong>: Log fields are best suited to string data such as <span class="No-Break">the following:</span><ul><li>Application state fields in string format, such as <em class="italic">error</em> or <em class="italic">warn</em> states, for example, if an application queries data from another service and <span class="No-Break">cannot connect</span></li><li>Organizational or business data fields, such as service name, customer ID, user ID, and <span class="No-Break">so on</span></li><li>Low- to medium-cardinality <span class="No-Break">indexed fields</span></li><li>High-cardinality <span class="No-Break">unindexed fields</span></li><li>Link from application state to system state <span class="No-Break">in traces</span></li></ul></li>
				<li><strong class="bold">Metric fields in Prometheus or Mimir</strong>: Metric fields are best suited to numeric data such as <span class="No-Break">the following:</span><ul><li>Application state fields in numeric format, such as the count of records processed <span class="No-Break">since startup</span></li><li>Organizational or business data fields, including labels containing the service name, hostname, and <span class="No-Break">so on</span></li><li>Low- to medium-cardinality fields, such as HTTP methods (GET, POST, <span class="No-Break">PUT, etc.)</span></li></ul></li>
				<li><strong class="bold">Trace fields in Tempo</strong>: Trace fields are a complex data type that can handle data such as <span class="No-Break">the following:</span><ul><li>System <span class="No-Break">state fields</span></li><li><span class="No-Break">High-cardinality fields</span></li><li>Organizational or business data fields when added as an attribute, such as customer ID and <span class="No-Break">user ID</span></li><li><span class="No-Break">Cross-system fields</span></li><li>Links to application state by using <span class="No-Break">trace metrics</span></li></ul></li>
				<li><strong class="bold">Kubernetes labels</strong>: These are Kubernetes key-value pair data objects. They are used to record information such as <span class="No-Break">the following:</span><ul><li>Core organization fields, such as ownership and <span class="No-Break">cost allocation</span></li><li>Linking the application to <span class="No-Break">the infrastructure</span></li><li>These labels can be added to log, metric, and trace data as it <span class="No-Break">is collected</span></li></ul></li>
				<li><strong class="bold">Cloud vendor tags</strong>: These are tags applied to infrastructure in a cloud vendor system. They can be used to record information such as <span class="No-Break">the following:</span><ul><li>Core organization fields, such as ownership and <span class="No-Break">cost allocation</span></li><li>These labels can be added to log, metric, and trace data as it <span class="No-Break">is collected</span></li></ul></li>
			</ul>
			<p>A lot of this data is standard<a id="_idIndexMarker942"/> across many organizations and industries, and the libraries that produce the data are well tested. There is one area of data production that is not tested by these tools though, and that is organization-specific fields. These are always organization-specific, but some common examples are user ID or customer ID. These fields, when used by the organization, can be very important, even being reviewed regularly by executive leaders. It is important that these are tested as bad data can lead to bad decisions. Any data architecture documents should highlight this need. There is a lot of technical detail in achieving this goal, which we will not go into in this book, but we would recommend this article from Martin Fowler, which gives clear instructions<a id="_idIndexMarker943"/> on producing organizational data in a testable <span class="No-Break">way: </span><a href="https://martinfowler.com/articles/domain-oriented-observability.html"><span class="No-Break">https://martinfowler.com/articles/domain-oriented-observability.html</span></a><span class="No-Break">.</span></p>
			<p>We’ve now seen how to work within the organization to have a coherent data architecture that works with the infrastructure layer, the application layer, the observability layer, and the business layer. Let’s now consider how to have a great system architecture<a id="_idIndexMarker944"/> for your organization’s <span class="No-Break">observability platform.</span></p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor222"/>Establishing system architecture</h2>
			<p>In this section, we will consider<a id="_idIndexMarker945"/> the aspects of building a great observability system. We will see how to help software engineers with producing data. Then, we will consider how to collect that data, while providing engineers with a stable API. Finally, we’ll discuss the storage and visualization of the data. The following list presents some questions to consider relating to <span class="No-Break">these topics:</span></p>
			<ul>
				<li>How will data <span class="No-Break">be produced?</span><ul><li>What telemetry types (logs, metrics, traces, or others) <span class="No-Break">are used?</span></li><li>Will developers such as <em class="italic">Diego</em> be given standards <span class="No-Break">for libraries?</span></li><li>Should <em class="italic">system</em> or <em class="italic">state</em> data be separated from <span class="No-Break"><em class="italic">business</em></span><span class="No-Break"> data?</span></li></ul></li>
				<li>How will data <span class="No-Break">be collected?</span><ul><li>What systems do you need to collect <span class="No-Break">data from?</span></li><li>If a tool is changed, will every application need to <span class="No-Break">be updated?</span></li><li>How much data will <span class="No-Break">be collected?</span></li></ul></li>
				<li>How will data <span class="No-Break">be stored?</span><ul><li>Will any local storage be provided? If so, how will the scale and cost of this <span class="No-Break">be managed?</span></li><li>Is the storage managed per cluster or environment, or as a <span class="No-Break">centralized system?</span></li><li>Will a third-party solution such as Grafana Cloud be used? If so, how is the <span class="No-Break">cost allocated?</span></li></ul></li>
				<li>How will visualizations <span class="No-Break">be managed?</span><ul><li>Will the system be fully open, so anyone can submit changes for <span class="No-Break">any dashboard?</span></li><li>Will each team be responsible for <span class="No-Break">their dashboards?</span></li><li>Will IaC tools be provided to help teams manage <span class="No-Break">their dashboards?</span></li></ul></li>
				<li>An additional question to consider for all of these is how the system employed <span class="No-Break">handles failure</span></li>
			</ul>
			<p>Let’s cover these considerations<a id="_idIndexMarker946"/> in more detail, starting with architecting how applications <span class="No-Break">produce data.</span></p>
			<h3>Data production</h3>
			<p>Data production details how applications<a id="_idIndexMarker947"/> and services produce data. Teams responsible<a id="_idIndexMarker948"/> for observability platforms should assist the teams who produce data in doing so with all the correct fields, practices, and standards. Common topics to cover are <span class="No-Break">the following:</span></p>
			<ul>
				<li>Which telemetry types must be produced and which should or may <span class="No-Break">be produced?</span></li>
				<li>Is organizational or business data being collected from the observability systems? If it is, what are the fields? Is a data domain used (e.g., <strong class="source-inline">acme.cost_center</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">acme.department</strong></span><span class="No-Break">)?</span></li>
				<li>Are developers expected to use libraries from a <span class="No-Break">pre-approved list?</span></li>
				<li>What standards are used by applications to <span class="No-Break">present data?</span></li>
			</ul>
			<p>OpenTelemetry, while relatively young, is emerging as the standard in observability, with adoption across most vendors and systems. A suggested best practice for an application is to add instrumentation using the relevant OpenTelemetry SDK, as shown in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer154" class="IMG---Figure">
					<img src="image/B18277_11_1.jpg" alt="Figure 11.1 – Proposed application data production standard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Proposed application data production standard</p>
			<p>Here, logs are produced on <strong class="source-inline">stdout</strong> and <strong class="source-inline">stderr</strong>. Metrics are published both to a Prometheus scrape endpoint and to an OpenTelemetry receiver via either gRPC on port <strong class="source-inline">4317</strong> or HTTP on port <strong class="source-inline">4318</strong>. Traces are also pushed to the OpenTelemetry receiver using the <span class="No-Break">same ports.</span></p>
			<p>Producing data is only part of the picture<a id="_idIndexMarker949"/> for a well-architected<a id="_idIndexMarker950"/> system. Next, let’s look at how to design a system to collect all this data so it is useful to <span class="No-Break">the organization.</span></p>
			<h3>Data collection</h3>
			<p>The data collection agents we have discussed<a id="_idIndexMarker951"/> in previous chapters can collect data<a id="_idIndexMarker952"/> in many formats. Managing infrastructure that collects data in every format is a cumbersome challenge and prone to failure and errors. The system architecture needs to detail which protocols are preferred and which can be accepted. For mature organizations, start with which protocols are currently in use and set end-of-life dates for any protocols the organization wishes to remove. It is strongly recommended to stick with default ports where they exist, and where applicable in <span class="No-Break">the environment.</span></p>
			<p>Another consideration is whether data will be stored locally, remotely, or both. Local storage adds management overhead and cost but may be a requirement in some environments. Having remote storage reduces management costs, but it can remove the option of using the metrics from an application<a id="_idIndexMarker953"/> to make environment choices. An example of this would be the Prometheus <strong class="bold">HorizontalPodAutoscaler</strong> (<strong class="bold">HPA</strong>). We’ll discuss this in a little bit more detail in the <em class="italic">Management and automation</em> section. The authors have used short-lived, volatile local storage for such considerations in the past, while using a remote, third-party-provided infrastructure for long-lived storage, and such a setup <span class="No-Break">works well.</span></p>
			<p>OpenTelemetry offers several<a id="_idIndexMarker954"/> configurations. The following reference architectures are designed<a id="_idIndexMarker955"/> to give a starting point for readers who need to architect <span class="No-Break">a system.</span></p>
			<p>For instance, the simplest way to architect data collection is for each application to send data <em class="italic">directly</em> to the backends, <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer155" class="IMG---Figure">
					<img src="image/B18277_11_2.jpg" alt="Figure 11.2 – Agentless configuration"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Agentless configuration</p>
			<p>For demonstrations or small installations, this architecture is perfectly fine. However, each application needs to be aware of each backend service, which means that this installation type does not scale <span class="No-Break">very well.</span></p>
			<p>Adding a <strong class="bold">local agent</strong> to the application adds a small amount<a id="_idIndexMarker956"/> of complexity but removes a lot of overhead for the team managing the application itself. Such an installation looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer156" class="IMG---Figure">
					<img src="image/B18277_11_3.jpg" alt="Figure 11.3 – Local agent only"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Local agent only</p>
			<p>Running a local agent<a id="_idIndexMarker957"/> is a very common pattern, and this pattern is great for many<a id="_idIndexMarker958"/> environments. As the number of instances of the agent grows, the agent configuration should be deployed using some form of configuration-as-code setup, such as Ansible, Salt, or Helm in a <span class="No-Break">Kubernetes environment.</span></p>
			<p>Adding a <strong class="bold">gateway service</strong> is another common architecture. This type of installation<a id="_idIndexMarker959"/> looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer157" class="IMG---Figure">
					<img src="image/B18277_11_4.jpg" alt="Figure 11.4 – Gateway agent only"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Gateway agent only</p>
			<p><strong class="bold">Gateway architectures</strong> are perfect in a couple <span class="No-Break">of</span><span class="No-Break"><a id="_idIndexMarker960"/></span><span class="No-Break"> situations:</span></p>
			<ul>
				<li>When the number of local instances is high, it can cause strain on the backend system by having a lot of open connections. Tthe gateway architecture resolves this by spreading this load over multiple instances of <span class="No-Break">the agent.</span></li>
				<li>Gateway architectures are very good for installations where the collection of data from SNMP<a id="_idIndexMarker961"/> or similar systems is <span class="No-Break">a goal.</span></li>
			</ul>
			<p>It is best practice to put some<a id="_idIndexMarker962"/> form of load balancer in front of gateway architectures, and where<a id="_idIndexMarker963"/> possible to <span class="No-Break">implement autoscaling.</span></p>
			<p>Kubernetes introduces its own challenges to data collection architecture; this next diagram tries to capture the most common tools needed to collect data across the cluster <span class="No-Break">and node:</span></p>
			<div>
				<div id="_idContainer158" class="IMG---Figure">
					<img src="image/B18277_11_5.jpg" alt="Figure 11.5 – A more complex Kubernetes architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – A more complex Kubernetes architecture</p>
			<p>A simple way to think of this configuration is to break it up into <span class="No-Break">three parts:</span></p>
			<ul>
				<li>There is a <strong class="bold">local agent</strong> configuration on each node. This is configured to receive OTLP metrics on gRPC or HTTP. The local agent <a id="_idIndexMarker964"/>is also configured to query the kubelet for stats related to the Kubernetes node. It also has a host receiver configured to collect metrics; this would only be needed in a <span class="No-Break">physical installation.</span></li>
				<li>A <strong class="bold">gateway agent</strong> is also configured. This collects data from each node and from the cluster agent. Using a gateway agent<a id="_idIndexMarker965"/> here also allows for processing to be done in <span class="No-Break">the gateway.</span></li>
				<li>The final component is the <strong class="bold">cluster agent</strong>. This is a standalone instance of the agent configured to collect data<a id="_idIndexMarker966"/> from the Kubernetes API service. If this task were delegated to all node or gateway agents, the data would be collected by each instance, duplicating the data in the backend. By using a standalone instance, we get a single data stream, and this instance can leverage the gateway in the same way that the node <span class="No-Break">agent can.</span></li>
			</ul>
			<p>There are many more configurations that could be used, and we have not discussed the topic of using multiple different agents. However, this should give us a foundation to <span class="No-Break">work from.</span></p>
			<p>We have now looked at producing<a id="_idIndexMarker967"/> and collecting data. These systems will be similar<a id="_idIndexMarker968"/> for all organizations. Let’s have a look at architecting data storage <span class="No-Break">systems next.</span></p>
			<h3>Data storage and data visualization</h3>
			<p>There is one key question<a id="_idIndexMarker969"/> to ask regarding data storage or visualization layers<a id="_idIndexMarker970"/> for observability platforms. Who is responsible? With Grafana tools, it is easily achievable to deploy a local storage solution. By doing this, the responsibility<a id="_idIndexMarker971"/> for maintaining that platform is with an internal team. The alternative<a id="_idIndexMarker972"/> is to use a third party with whom your organization has a contractual relationship. This relationship is a very helpful thing to have when something <span class="No-Break">goes wrong.</span></p>
			<p>We considered the architectures for Loki, Mimir, and Tempo in <em class="italic">Chapters 4</em>, <em class="italic">5</em>, and <em class="italic">6</em>, so we will not show the specific architectures of each tool. Let’s consider how to deploy these tools if you have reason to manage your <span class="No-Break">own storage.</span></p>
			<p>Grafana Mimir, Loki, and Tempo offer multiple <span class="No-Break">deployment modes:</span></p>
			<ul>
				<li><strong class="bold">Monolithic mode</strong>: In monolithic mode, all of the microservices<a id="_idIndexMarker973"/> are deployed as a single instance and connected to an object store. Monolithic mode can be horizontally scaled by deploying more instances. This scaling method can provide a highly available platform with lower complexity but has the drawback of not allowing for independent scaling of read and write paths. This deployment mode is also not recommended for <span class="No-Break">production environments.</span></li>
				<li><strong class="bold">Microservices mode</strong>: This mode deploys and scales<a id="_idIndexMarker974"/> each component of the system independently. This adds complexity but also allows the system to cater to the actual load that is placed on it. This mode is the recommended deployment mode for production use of Mimir <span class="No-Break">and Tempo.</span></li>
				<li><strong class="bold">Simple scalable mode (only available in Loki)</strong>: This mode strikes a balance between monolithic<a id="_idIndexMarker975"/> and microservices mode by allowing the independent deployment and scaling of write targets, read targets, and backend targets. These targets contain all the services needed for their role. This mode is the recommended deployment mode for the production use <span class="No-Break">of Loki.</span></li>
			</ul>
			<p>For all three of the storage platforms, deployment is carried out using a Helm chart for Kubernetes deployments. Packages are also supplied for deployments to Linux operating systems. These deployments can be automated using the provided Puppet or <span class="No-Break">Tanka packages.</span></p>
			<p>When you wish to manage your own<a id="_idIndexMarker976"/> data visualization layer, the Grafana application<a id="_idIndexMarker977"/> needs to be installed. This is available<a id="_idIndexMarker978"/> as a package for Linux, macOS, or Windows operating<a id="_idIndexMarker979"/> systems. Grafana also provides Docker images and detailed guidance on deploying to Kubernetes <span class="No-Break">using Helm.</span></p>
			<h3>Handling system failure</h3>
			<p>A big consideration for a data collection<a id="_idIndexMarker980"/> architecture is how it handles failure. For agent failure, the only real option is to restart the agent. However, when the collection pipeline fails, this can be handled by buffering in memory or on disk. Each collector in the system is capable of buffering by configuring the batch processor for memory and the file storage extension for disk storage. The main thing to consider when designing a buffering solution is how long the system will need to tolerate failure. This, along with the throughput of data, dictates how much memory or disk space<a id="_idIndexMarker981"/> must be available to the instances. Reporting this calculation as a <strong class="bold">service-level indicator</strong> (<strong class="bold">SLI</strong>) for the data collection layer is a good practice, as it makes the resilience of the system <span class="No-Break">publicly available.</span></p>
			<p>We’ve now looked at how to architect the data that an observability system will collect, and we’ve looked at how to architect a system to collect that data. Let’s now consider how to architect the system to account for management tools and <span class="No-Break">automation tools.</span></p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor223"/>Management and automation</h2>
			<p>We discussed using IaC in <a href="B18277_10.xhtml#_idTextAnchor204"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>; when designing<a id="_idIndexMarker982"/> the system architecture, the use of IaC should manage<a id="_idIndexMarker983"/> the four systems (production, collection, storage, and visualization) as <span class="No-Break">separate concerns:</span></p>
			<ul>
				<li><strong class="bold">Data </strong><span class="No-Break"><strong class="bold">production system</strong></span><span class="No-Break">:</span><ul><li>This should be managed<a id="_idIndexMarker984"/> by each <span class="No-Break">application independently</span></li><li>Guidance should <span class="No-Break">be provided</span></li></ul></li>
				<li><strong class="bold">Data </strong><span class="No-Break"><strong class="bold">collection system</strong></span><span class="No-Break">:</span><ul><li>This is usually managed<a id="_idIndexMarker985"/> by an infrastructure, platform, observability, or <span class="No-Break">similar team</span></li><li>This should have published SLIs and SLOs like any <span class="No-Break">other component</span></li></ul></li>
				<li><strong class="bold">Data </strong><span class="No-Break"><strong class="bold">storage system</strong></span><span class="No-Break">:</span><ul><li>This is usually managed<a id="_idIndexMarker986"/> by an infrastructure, platform, observability, or <span class="No-Break">similar team</span></li><li>It is common to use a third-party tool (such as <span class="No-Break">Grafana Cloud)</span></li><li>Grafana Cloud stacks are a great tool for separating storage where necessary, for example, for CI/CD platforms<a id="_idIndexMarker987"/> or <span class="No-Break">performance testing</span></li></ul></li>
				<li><strong class="bold">Data </strong><span class="No-Break"><strong class="bold">visualization system</strong></span><span class="No-Break">:</span><ul><li>The system itself would usually<a id="_idIndexMarker988"/> be managed by an infrastructure, platform, observability, or <span class="No-Break">similar team</span></li><li>The dashboards and other artifacts related to an application should be managed by each application <span class="No-Break">team independently</span></li><li>IaC can be provided to teams to <span class="No-Break">manage deployment</span></li></ul></li>
			</ul>
			<p>Architecting for automation does not stop <a id="_idIndexMarker989"/>with the observability platform. Applications deployed to Kubernetes should be able to scale automatically as needed. When suggesting an ideal application pattern in the <em class="italic">Data production</em> section, keen-eyed readers may have seen that we recommended publishing metrics via a Prometheus endpoint as well as via OTLP export. This recommendation was made for autoscaling. While this book is concerned with observability in Grafana, a truly observable system can self-correct, such as the steam engine governor shown in <a href="B18277_01.xhtml#_idTextAnchor018"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. The Kubernetes HPA allows for the scaling of Pods based on CPU and memory usage. This is fine for some cases, but it is common for application teams to want to scale on metrics such as the rate of requests or number of sessions. The Prometheus community provides an adapter for Kubernetes Metrics APIs, which allows for querying a Prometheus endpoint to enable these types of scaling operations. An important question for an organization’s architecture is whether this type of instrumentation would be managed <a id="_idIndexMarker990"/>by a central team or by each application<a id="_idIndexMarker991"/> team, perhaps with a default configuration offered for teams <span class="No-Break">to consume.</span></p>
			<p>We’ve looked at how to create an architectural design. There are a lot of tools available to test those designs in practice to prove they work. Let’s have a look at proving <span class="No-Break">the architecture.</span></p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor224"/>Developing a proof of concept</h1>
			<p>The best place to prove a theoretical design<a id="_idIndexMarker992"/> is in an environment that has customers actually interacting with it, that is, a <strong class="bold">production environment</strong>. This is because any other environment is a mock environment<a id="_idIndexMarker993"/> and may miss some nuance of customer interactions. This is a recommendation to get the pathway to production created early and use it regularly. Having made that recommendation, it is still very important to have spaces for <span class="No-Break">testing designs.</span></p>
			<p>We will discuss compute containerization and virtualization tools, as well as simulated data production tools, which can be used to validate <span class="No-Break">designs quickly.</span></p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor225"/>Containerization and virtualization</h2>
			<p>Using containerization and virtualization locally and as part of a deployment pipeline can be a huge boost to provide quick feedback on whether a collection or storage architecture is achievable. Let’s consider some of the tools that will help in <span class="No-Break">this space:</span></p>
			<ul>
				<li><strong class="bold">Containerization</strong>: The tools <strong class="bold">k3d</strong>, <strong class="bold">KinD</strong>, <strong class="bold">MicroK8s</strong>, and <strong class="bold">minikube</strong> can be used for<a id="_idIndexMarker994"/> containerization<a id="_idIndexMarker995"/> for the<a id="_idIndexMarker996"/> <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker997"/></span><span class="No-Break"> reasons:</span><ul><li>These four tools<a id="_idIndexMarker998"/> all offer the ability to run a Kubernetes <span class="No-Break">cluster locally</span></li><li>KinD, k3d, and minikube can run using Docker or <span class="No-Break">Podman drivers</span></li><li>minikube also offers a VM driver, which can be useful for certain <span class="No-Break">local installations</span></li><li>For data collection architecture and pipelines, the authors have used KinD to deliver very <span class="No-Break">good results</span></li></ul></li>
				<li><strong class="bold">Virtualization</strong>: <strong class="bold">Vagrant</strong> can be used with several virtualization<a id="_idIndexMarker999"/> tools, including <strong class="bold">Hyper-V</strong>, <strong class="bold">VMware</strong>, <strong class="bold">VirtualBox</strong>, <strong class="bold">Xen</strong>, <strong class="bold">QEMU</strong>, and <strong class="bold">libvirt</strong>. This is for the <span class="No-Break">following reasons:</span><ul><li>Vagrant offers <a id="_idIndexMarker1000"/>the ability to define virtual machines<a id="_idIndexMarker1001"/> and virtual networking and deploy these definitions on different virtualization tools <span class="No-Break">using providers</span></li><li>This is a valuable feature for providing a reference virtual infrastructure for experimenting and use in <span class="No-Break">a pipeline</span></li></ul></li>
			</ul>
			<p>These tools provide the capability to build reference infrastructure on which to deploy data collectors. They also provide the ability to document architectural requirements and diagrams using a real setup that is <span class="No-Break">deployed locally.</span></p>
			<p>Deploying infrastructure and data collectors is one part of the process of proving a design. Having tools to produce test data is also vital to check that the design is right. Let’s have a look at these <span class="No-Break">tools now.</span></p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor226"/>Data production tools</h2>
			<p>There are a couple of ways<a id="_idIndexMarker1002"/> of testing data production – using a sample application (such as the OpenTelemetry Demo application) or replaying <span class="No-Break">pre-recorded datasets:</span></p>
			<ul>
				<li><strong class="bold">Demo applications</strong>: These applications can be used to generate<a id="_idIndexMarker1003"/> real observability data to test observability systems. Take the <span class="No-Break">following examples:</span><ul><li><strong class="bold">OpenTelemetry Demo application</strong>: This is a full retail application that we have used to provide demo data throughout <span class="No-Break">this book.</span></li><li><strong class="bold">One Observability Workshop applications</strong>: These applications are provided by AWS and demo how to push data into AWS <span class="No-Break">observability tools.</span></li><li><strong class="bold">mythical-creatures application</strong>: This is an application written by Heds Simons for an interview with Grafana (he got the job). This application outputs metrics, logs, and traces. It’s a simpler application than the OTEL demo, which can be <span class="No-Break">an advantage.</span></li></ul></li>
				<li><strong class="bold">Pre-recorded datasets</strong>: These applications can be used to produce<a id="_idIndexMarker1004"/> a predefined set of data to test observability systems. The process of replaying pre-recorded datasets crosses over very strongly with load-testing and packet capture tools. Tools such as <strong class="bold">k6</strong>, <strong class="bold">Locust</strong>, <strong class="bold">Postman</strong>, <strong class="bold">Insomnia</strong>, and <strong class="bold">GHZ</strong> can be used to send predefined data blobs<a id="_idIndexMarker1005"/> to the data collection<a id="_idIndexMarker1006"/> endpoints of your collection<a id="_idIndexMarker1007"/> tools and validate<a id="_idIndexMarker1008"/> the output. As observability<a id="_idIndexMarker1009"/> tools use specific protocols, it’s important to look for features that match the organization’s production of data. Some examples are <span class="No-Break">the following:</span><ul><li>The ability to send gRPC data as this is a common format <span class="No-Break">for OpenTelemetry</span></li><li>The ability to send other protocols such as SNMP if they <span class="No-Break">are used</span></li></ul><p class="list-inset">Tools such as <strong class="bold">Fiddler</strong> and <strong class="bold">Wireshark</strong>, as well as other network analyzers or HTTP(S) debuggers, can be used<a id="_idIndexMarker1010"/> to record wire data<a id="_idIndexMarker1011"/> to build up a library <a id="_idIndexMarker1012"/>of <span class="No-Break">reference data.</span></p></li>
			</ul>
			<p>We will discuss in greater detail, in <a href="B18277_14.xhtml#_idTextAnchor254"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, how these tools can be integrated into <span class="No-Break">CI/CD pipelines.</span></p>
			<p>We’ve now seen how to architect<a id="_idIndexMarker1013"/> the different components of an observability platform and how to validate those designs. Another important architectural consideration is getting the access levels correct. Let’s look at <span class="No-Break">that now.</span></p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor227"/>Setting the right access levels</h1>
			<p>We have talked about the data<a id="_idIndexMarker1014"/> in observability systems and how to architect the actual systems for producing, collecting, storing, and visualizing the data. A significant element of the architecture of the system that we have not discussed <span class="No-Break">is RBAC.</span></p>
			<p>There are two places where RBAC can <span class="No-Break">be applied:</span></p>
			<ul>
				<li><strong class="bold">Grafana Cloud</strong>: Administration of the deployed<a id="_idIndexMarker1015"/> Grafana stacks <span class="No-Break">and billing.</span></li>
				<li><strong class="bold">Grafana instances</strong>: Access to data and visualizations. These instances<a id="_idIndexMarker1016"/> can be deployed to Grafana Cloud <span class="No-Break">or on-premises.</span></li>
			</ul>
			<p>Let’s start by looking at the permissions currently available<a id="_idIndexMarker1017"/> in <span class="No-Break">Grafana Cloud:</span></p>
			<table id="table001-8" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Permission/Role</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Admin</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Editor</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Viewer</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>View <span class="No-Break">API keys</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Manage <span class="No-Break">API keys</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>View organization <span class="No-Break">billing information</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Manage organization <span class="No-Break">billing information</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Manage Grafana <span class="No-Break">Cloud subscription</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>View Grafana <span class="No-Break">instance plugins</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Manage Grafana <span class="No-Break">instance plugins</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">View stacks</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Manage stacks</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Manage <span class="No-Break">organization members</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">View invoices</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Pay invoices</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>View <span class="No-Break">Enterprise licenses</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>View <span class="No-Break">OAuth clients</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Manage <span class="No-Break">OAuth clients</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>View <span class="No-Break">support tickets</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Open <span class="No-Break">support tickets</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>✓</p>
						</td>
						<td class="No-Table-Style">
							<p>×</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.1 – Grafana Cloud RBAC</p>
			<p>These Grafana Cloud roles are focused on managing a Grafana Cloud instance. For most users, using and editing items in one or more Grafana instances is more applicable to their daily work. Grafana offers a rich permission set that breaks down into <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Basic roles</strong>: The basic roles have very broad privileges. This<a id="_idIndexMarker1018"/> is great for small organizations and having easy access to new installations. Assigning a basic role with least privilege to users is good practice. The basic roles are a default set of fixed role definitions, which we’ll discuss in the next point. Basic roles include <span class="No-Break">the following:</span><ul><li><strong class="bold">Admin</strong>: An admin for a <span class="No-Break">Grafana organization.</span></li><li><strong class="bold">Editor</strong>: A user who has access to edit objects in <span class="No-Break">the organization.</span></li><li><strong class="bold">Viewer</strong>: A user who has access to <span class="No-Break">view objects.</span></li><li><strong class="bold">None</strong>: A role that has minimal privileges for use with <span class="No-Break">service accounts</span></li><li><strong class="bold">Grafana Admin</strong>: A special admin account for all the Grafana organizations in an on-premises instance. As we have mainly discussed Grafana Cloud, let’s clarify what a Grafana <span class="No-Break">organization is:</span><ul><li>Organizations are a method to separate Grafana resources in a <span class="No-Break">single instance.</span></li><li>In Grafana Cloud, organizations are not available to use. Stacks are a better way to separate parts of the organization as a dedicated Grafana instance will be used<a id="_idIndexMarker1019"/> in <span class="No-Break">each stack.</span></li></ul></li></ul></li>
				<li><strong class="bold">Fixed role definitions</strong>: Fixed roles can be used to expand the privileges assigned via basic roles. Fixed roles<a id="_idIndexMarker1020"/> contain specific permission assignments that can be added to <span class="No-Break">a subject.</span></li>
				<li><strong class="bold">Custom roles</strong>: Custom roles allow for the creation<a id="_idIndexMarker1021"/> of roles that have specific permissions, actions, and scopes assigned to them. Custom roles can only be created via the API, but Terraform can be used to manage these <span class="No-Break">with IaC.</span></li>
			</ul>
			<p>Permissions can also be assigned<a id="_idIndexMarker1022"/> at the data source, team, dashboard, and folder levels. This can allow for structures such as giving management capabilities to all dashboards in a folder assigned to a specific team, but not granting management to other team folders. All the permission<a id="_idIndexMarker1023"/> structures can also be managed using IaC, which we discussed in <a href="B18277_10.xhtml#_idTextAnchor204"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>. Grafana provides a helpful guide on planning an RBAC rollout strategy <span class="No-Break">here: </span><a href="https://grafana.com/docs/grafana/latest/administration/roles-and-permissions/access-control/plan-rbac-rollout-strategy/"><span class="No-Break">https://grafana.com/docs/grafana/latest/administration/roles-and-permissions/access-control/plan-rbac-rollout-strategy/</span></a><span class="No-Break">.</span></p>
			<p>Let’s consider how we might configure roles for some of the personas we have – <em class="italic">Diego Developer</em>, <em class="italic">Steven Service</em>, and <span class="No-Break"><em class="italic">Pelé Product</em></span><span class="No-Break">:</span></p>
			<ul>
				<li>As a member of a team responsible for a service, <em class="italic">Diego</em> will need to be able to read dashboards to understand how other services may be behaving. He will also need to have write access for dashboards and alerts, but is limited to the folder that contains the application he is <span class="No-Break">responsible for.</span></li>
				<li><em class="italic">Steven</em> needs to be able to view dashboards but not edit them. However, he does need to be able to view and manage on-call schedules and <span class="No-Break">silence alerts.</span></li>
				<li><em class="italic">Pelé</em> has a couple of distinct needs. For most day-to-day processes, he needs to be able to view dashboards, incident history, and query data about the applications he is the product owner for. However, he also needs a service account to run specific queries for business metrics and load the data into the BI platform that is used with <em class="italic">Masha Manager</em> to analyze whether the teams need any help with delivering great products. He worked on setting up this service account with limited permission with <em class="italic">Ophelia</em>, the admin of the <span class="No-Break">Grafana system.</span></li>
			</ul>
			<p>For most users, once a role is created, it is simply a case of assigning the role to the individual user. Special consideration should be made for service accounts. Some service accounts, such as those used by the team managing the provisioning of Grafana tools, will need significant access and should be thoroughly audited. Other accounts, such as those used by an individual application team to manage dashboards, should have limited permissions. With this second type of account, it is a good idea to grant limited privileges for managing the service<a id="_idIndexMarker1024"/> account to a senior member of the team as this enables the team to <span class="No-Break">work independently.</span></p>
			<p>Now that we understand RBAC in Grafana, let’s have a look at how data collected for Grafana can be used in <span class="No-Break">other systems.</span></p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor228"/>Sending telemetry to other consumers</h1>
			<p>It is common for the data collected<a id="_idIndexMarker1025"/> by observability systems to be of use<a id="_idIndexMarker1026"/> in other systems. Logs are often used in SIEM systems and aggregate metrics are of interest in BI systems. There are two different strategies that can be used to share telemetry with <span class="No-Break">other consumers:</span></p>
			<ul>
				<li><strong class="bold">Sharing data in the collection pipeline</strong>: Sharing data in the collection pipeline is dependent on the data collection pipeline being used. We’ve talked a lot about the OpenTelemetry collector, which offers the ability to filter and send data to multiple backend systems. Similarly, AWS, GCP, and Azure offer options for writing telemetry to multiple backend systems. A consideration is that this type of solution will increase costs by storing multiple copies of the same data. Spending time with other consumers to understand their needs to minimize this cost <span class="No-Break">is advised.</span></li>
				<li><strong class="bold">Querying data from Grafana directly</strong>: Querying data from Grafana is done using a scheduled job that runs queries directly against Grafana. These are often custom connectors that will read data and write it into a BI platform. Grafana offers the recording rule functionality, which can assist in this data collection process. This functionality allows for the pre-computation of queries, which can be stored as a separate time series. For example, if the business were interested in the number of unique users who logged in daily, a recording rule could query this and store the data as a new metric. When the BI platform then collects this data, it would not need to wait for a potentially slow query to complete and instead would have the data <span class="No-Break">easily available.</span></li>
			</ul>
			<p>You should now be confident<a id="_idIndexMarker1027"/> in architecting a comprehensive observability platform<a id="_idIndexMarker1028"/> that meets the needs of the organization and can feed valuable information into other systems across <span class="No-Break">the organization.</span></p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor229"/>Summary</h1>
			<p>In this chapter, we have explored the process of architecting the data fields that will be collected. You will be able to use this knowledge to structure data in a Grafana platform so it is easy to use across your organization. We have discussed the process of architecting data production by applications and offering standard guidance on the best application structure to use. This will account for most needs of the developers in the organization. We shared several levels of complexity for the data collection architecture. You can use these as a starting point for architecting your own system. We discussed the various tools that are available to validate an architectural design: both tools for running local infrastructure and tools to simulate data that is being collected. This will help in producing a pipeline for delivering the infrastructure for an observability platform that you can rely on. Finally, we briefly discussed how to share data with other consumers, either in the data collection pipeline or by querying Grafana directly. You can use this knowledge to link observability data back to the rest of <span class="No-Break">the organization.</span></p>
			<p>In the next chapter, we will explore the use of <strong class="bold">real user monitoring</strong> (<strong class="bold">RUM</strong>) to collect data directly from the browser. This provides visibility of how your code runs when users are active in <span class="No-Break">the system.</span></p>
		</div>
	

		<div id="_idContainer160" class="Content">
			<h1 id="_idParaDest-218" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor230"/>Part 4: Advanced Applications and Best Practices of Grafana</h1>
			<p>There are a number of topics related to observability, including frontend observability, application performance, load testing, DevOps pipelines, and monitoring security applications. This part will discuss these topics and additionally look at possible future trends. We will close out with some best practices and <span class="No-Break">troubleshooting approaches.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18277_12.xhtml#_idTextAnchor231"><em class="italic">Chapter 12</em></a><em class="italic">, Real User Monitoring with Grafana</em></li>
				<li><a href="B18277_13.xhtml#_idTextAnchor239"><em class="italic">Chapter 13</em></a><em class="italic">, Application Performance with Grafana Pyroscope and k6</em></li>
				<li><a href="B18277_14.xhtml#_idTextAnchor254"><em class="italic">Chapter 14</em></a><em class="italic">, Supporting DevOps Processes with Observability</em></li>
				<li><a href="B18277_15.xhtml#_idTextAnchor272"><em class="italic">Chapter 15</em></a><em class="italic">, Troubleshooting, Implementing Best Practices, and More with Grafana</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer161">
			</div>
		</div>
		<div>
			<div id="_idContainer162" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>