- en: '*Chapter 4*: Developing an Operator with the Operator SDK'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a completed design outline for an **Operator**, it is now possible to begin
    the actual work of developing it. This means writing and compiling code that can
    be deployed onto an actual running **Kubernetes cluster**. For this chapter, the
    **Operator SDK** will be used to initialize the scaffolding of a boilerplate Operator
    project. From there, the technical steps to develop the rest of a basic Operator
    will be demonstrated as a tutorial. This guide will follow the Operator design
    already planned in [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050), *Designing
    an Operator – CRD, API, and Target Reconciliation*, which focused on developing
    a *Level II* Operator to deploy and upgrade a simple **Nginx Pod**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a tutorial, this chapter will follow the process for building an Operator
    from scratch with **Go**. Beginning with the initialization of boilerplate project
    code, the guide will then follow through the steps of defining the Operator API
    and generating the corresponding **CustomResourceDefinition** (**CRD**). Then,
    we will see how to implement simple reconciliation logic that makes up the core
    functionality of the Operator. Finally, some basic troubleshooting and common
    issues will be addressed. The steps for developing an Operator with Operator SDK
    will be broken down into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining an API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding resource manifests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a control loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These sections follow roughly the design pattern that is recommended in the
    official Operator SDK Go documentation ([https://sdk.operatorframework.io/docs/building-operators/golang/](https://sdk.operatorframework.io/docs/building-operators/golang/)),
    which is why we have chosen to follow this approach. At the end of this chapter,
    we will have an Operator that covers the Level II functionality described in the
    design that was outlined in [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050),
    *Designing an Operator – CRD, API, and Target Reconciliation*. This functionality
    includes basic deployment of the Operand (in this case, Nginx) and seamless upgrades
    of the Operator and Operand. In later chapters, this guide will be built upon
    as a foundation for adding more complex functionality that graduates this sample
    Operator from lower to higher levels along the Capability Model.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The guided steps in this chapter will require the following technical prerequisites
    to follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go` version 1.16+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `operator-sdk` binary installed locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `operator-sdk` binary can be installed either directly from a release, with
    Homebrew (for macOS), or compiled from GitHub from [https://github.com/operator-framework/operator-sdk](https://github.com/operator-framework/operator-sdk).
    If choosing to install the Operator SDK from GitHub, `git` will also be required;
    however, it is recommended to use `git` anyway to take advantage of version control
    for the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for this chapter can be viewed at: [https://bit.ly/3N7yMDY](https://bit.ly/3N7yMDY)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step in starting a fresh Operator project is to initialize an empty
    project structure. First, create an empty project directory with `mkdir nginx-operator`
    and `cd` into it. Now, initialize a boilerplate project structure with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This command may take a few moments to complete the first time it is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command sets up a lot of different files and folders that will be filled
    in with the custom APIs and logic for the Operator we are building. The once-empty
    project directory should now contain the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The purposes of these files are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`config` – A directory that holds YAML definitions of Operator resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hack` – A directory that is used by many projects to hold various `hack` scripts.
    These are scripts that can serve a variety of purposes but are often used to generate
    or verify changes (often employed as part of a continuous integration process
    to ensure code is properly generated before merging).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.dockerignore` / `.gitignore` – Declarative lists of files to be ignored by
    Docker builds and Git, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dockerfile` – Container image build definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Makefile` – Operator build definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PROJECT` – File used by Kubebuilder to hold project config information ([https://book.kubebuilder.io/reference/project-config.html](https://book.kubebuilder.io/reference/project-config.html)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go.mod` / `go.sum` – Dependency management lists for `go mod` (already populated
    with various Kubernetes dependencies).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.go` – The entry point file for the Operator''s main functional code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this boilerplate project structure initialized, it is possible to start
    building Operator logic on top. While this bare project will compile, it doesn't
    do much besides start an empty controller with `Readyz` and `Healthz` endpoints.
    To get it to do a little more, first, the Operator must have a defined API.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Operator's API will be the definition of how it is represented within a
    Kubernetes cluster. The API is directly translated to a generated CRD, which describes
    the blueprint for the custom resource object that users will consume to interact
    with the Operator. Therefore, creating this API is a necessary first step before
    writing other logic for the Operator. Without this, there will be no way for the
    Operator's logic code to read values from the custom resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building an Operator API is done by writing a Go struct to represent the object.
    The basic outline of this struct can be scaffolded by the Operator SDK with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This command does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates the API types in a new directory called `api/`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defines these types as belonging to the API group `operator.example.com` (since
    we initialized the project under the domain `example.com`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates the initial version of the API named `v1alpha1`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Names these types after our Operator, `NginxOperator`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiates boilerplate controller code under a new directory called `controllers/`
    (which we will work with more under *Writing a control loop*)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updates `main.go` to add boilerplate code for starting the new controller
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, we are only concerned with the API types under `api/v1alpha1/nginxoperator_types.go`.
    There are two other files in this directory (`groupversion_info.go` and `zz_generated.deepcopy.go`)
    that do not usually need to be modified. In fact, the `zz_generated.` prefix is
    used as a standard to denote generated files that should never be manually modified.
    The `groupversion_info.go` file is used to define package variables for this API
    that instruct clients how to handle objects from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at `nginxoperator_types.go`, there are already some empty structs with
    instructions to fill in additional fields. The three most important types in this
    file are `NginxOperator`, `NginxOperatorSpec`, and `NginxOperatorStatus`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As discussed in [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050), *Designing
    an Operator – CRD, API, and Target Reconciliation*, all Kubernetes API objects
    should have `Spec` and `Status` fields, and Operators are no different. Therefore,
    `NginxOperatorSpec` and `NginxOperatorStatus` are those fields, which will be
    used to accept user input and report on the current state of the Operator, respectively.
    With `NginxOperator` representing the main object, the relationship between the
    three is hierarchical.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The relationship between NginxOperator fields and logic](img/B18147_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The relationship between NginxOperator fields and logic
  prefs: []
  type: TYPE_NORMAL
- en: 'Recalling the problem definition from [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050),
    *Designing an Operator – CRD, API, and Target Reconciliation*, this Operator needs
    to accept the following inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`port`, which will define the port number to expose on the Nginx Pod'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`replicas`, which defines the number of Pod replicas in order to allow scaling
    of this deployment through the Operator'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`forceRedploy`, which is a `Nginx` Operand'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To implement these fields, we need to update the preceding code to modify `NginxOperatorSpec`
    with these new fields, as in the following. We are using pointers for the integer
    fields so that our Operator will be able to distinguish between a zero-value and
    an unset value, which should fall back to using a defined default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: (Note, we also removed the sample `Foo` field that was generated by the Operator
    SDK as an example.)
  prefs: []
  type: TYPE_NORMAL
- en: Regenerating Code
  prefs: []
  type: TYPE_NORMAL
- en: Once the Operator types have been modified, it is sometimes necessary to run
    `make generate` from the project root. This updates generated files, such as the
    previously mentioned `zz_generated.deepcopy.go`. It is good practice to develop
    the habit of regularly running this command whenever making changes to the API,
    even if it does not always produce any changes. It is even better practice to
    add pre-submit continuous integration checks to the Operator's repository to ensure
    that any incoming code includes these generated changes. Such an automated check
    can be implemented by running `make generate` followed by a simple `git diff`
    command to assess whether any changes have appeared. If so, the check should fail
    and instruct the developer to regenerate their code.
  prefs: []
  type: TYPE_NORMAL
- en: For all three new fields, we have also added JSON tags in the form of `` `json:"...,omitempty"`
    ``. The first part of each of these tags defines how the field will appear when
    represented in JSON or YAML (when interacting with the object through `kubectl,`
    for example). `omitempty` specifies that if this field is empty, it should not
    show up in JSON output. This is good for hiding optional fields in order to provide
    a concise output when viewing the objects in the cluster (otherwise, empty fields
    will appear as nil or with an empty string).
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to initially make all three of these fields optional, with default
    values defined in the Operator. However, they could be designated as required
    with the removal of `omitempty` and the addition of more Kubebuilder tags, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: With these settings, any attempt to modify an `NginxOperator` object without
    including the `port` field will result in an error from the API server. In current
    versions of Kubebuilder, the default assumption is that any field that is not
    designated as `omitempty` is required. However, there are ways to switch this
    default globally (with the `// +kubebuilder:validation:Optional` marker applied
    to the top level of an API). Therefore, whenever changing the requirement of a
    field, it is good practice to explicitly update that field's specific requirement
    value.
  prefs: []
  type: TYPE_NORMAL
- en: With the API types defined, it is now possible to generate an equivalent CRD
    manifest, which will be used to create objects matching these types in a Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Adding resource manifests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The relevant resources for an Operator are important to package in a way that
    can be easily deployed and maintained. This includes the Operator''s CRD, but
    also other resources such as **ClusterRoles** and the matching **ServiceAccount**
    for those Roles. However, the first step is to generate a CRD from the Go types
    defined in the previous section with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This command generates a CRD that is based on the API we just defined. That
    CRD is placed under `config/crd/bases/operator.example.com_nginxoperators.yaml`.
    That CRD looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: (In this output, we have added additional formatting to more clearly represent
    longer strings, such as field descriptions, and highlighted the three fields that
    were added to the API.)
  prefs: []
  type: TYPE_NORMAL
- en: This CRD is fairly simple due to the basic structure of the Operator, but even
    that is a testament to the natural complexity of OpenAPI validation schemas. That
    complexity emphasizes the point that CRD manifests should always be generated
    and not manually edited.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Generated Manifests
  prefs: []
  type: TYPE_NORMAL
- en: The default command for generating manifests creates a complex validation schema
    that should not be edited by hand. However, the underlying command for `make manifests`
    is actually calling an additional tool, `controller-gen` manually is an acceptable
    way to generate files and code in non-default ways. For example, the `controller-gen
    schemapatch` command will regenerate only the OpenAPI validation schema for a
    CRD. This can be useful if you wish to manually modify other parts of the CRD,
    which would be overwritten with a full regeneration, such as additional annotations
    or labels. The full list of commands can be found by installing `controller-gen`
    from the previously mentioned repository and running it with `controller-gen -h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `make manifests` command also creates a corresponding **Role-Based Access
    Control** (**RBAC**) role with can be bound to the Operator''s ServiceAccount
    to give the Operator access to their own custom object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'config/rbac/role.yaml:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: This Role grants full access to create, delete, get, list, patch, update, and
    watch all `nginxoperator` objects in the cluster. It is generally not a best practice
    for an Operator to manage the life cycle of their own custom resource object (for
    example, creation of the `config` object is best left to a manual action by the
    user), so some of the verbs, such as `create` and `delete`, are not strictly necessary
    here. However, we will leave them for now.
  prefs: []
  type: TYPE_NORMAL
- en: Additional manifests and BinData
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The remaining resource manifests that will need to be created include the Operator's
    `ClusterRole` and the Nginx Deployment definition. The `ClusterRole` can be conveniently
    generated with Kubebuilder tags in the code, which will be done later in the *Writing
    a control loop* section. Before that, the Deployment should be defined so that
    the control loop has access to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to define in-memory resources, such as the Deployment, is by creating
    them in the code. Many projects take such an approach, including the official
    example projects available at [https://github.com/operator-framework/operator-sdk](https://github.com/operator-framework/operator-sdk).
    For the purpose of this Nginx Deployment, the approach would involve creating
    a function similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function returns a static Deployment Go struct, with default values
    prepopulated, such as the Deployment name and exposed port. This object could
    then be modified based on the specifications set in the Operator CRD before using
    a Kubernetes API client to update the Deployment in the cluster (for example,
    to update the number of replicas).
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050), *Designing
    an Operator – CRD, API, and Target Reconciliation*, this approach is easy to code
    because the resource struct is immediately available as a Go type. However, in
    terms of maintainability and usability, there are better options. This is where
    tools such as **go-bindata** and **go:embed** are helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Using go-bindata and go:embed to access resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The go-bindata project is available on GitHub at [https://github.com/go-bindata/go-bindata](https://github.com/go-bindata/go-bindata).
    It works by converting arbitrary files into Go code, which is then compiled into
    the main program and available in memory. The benefit of using go-bindata is that
    project resources can be more concisely managed and maintained in a more readable
    format such as YAML, which provides familiarity with native Kubernetes resource
    creation. Since Go 1.16, the language has included its own compiler directive,
    `go:embed`, to essentially perform the same function; however, we will provide
    an example of both approaches for the benefit of users who have not yet updated
    to Go 1.16 or who wish to avoid reliance on compiler-specific directives in their
    development and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step for either approach is to create the resource manifests in a
    directory, such as `assets/nginx_deployment.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: This structure is already much easier to work with than the native Go types
    by saving us from having to define each embedded type (such as `map[string]string`
    for the labels and Pod command). It can also be easily parsed by continuous integration
    checks to ensure it maintains a valid structure.
  prefs: []
  type: TYPE_NORMAL
- en: The next two subsections will demonstrate the basic concepts of implementing
    either `go-bindata` or `go:embed`. These examples will do so by showing how you
    could add the foundational concepts for each approach. However, we will ultimately
    refactor most of the code in the section titled *Simplifying resource embedding*;
    therefore, you may choose not to write any of this code yourself until reaching
    the refactoring subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Go 1.15 and older – go-bindata
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For older versions of Go, you must install the `go-bindata` package from GitHub
    to generate your files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated code that contains the manifests can then be created with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will create an `assets.go` file under the `assets/` directory
    that contains generated functions and in-memory representations of the files in
    the `assets/` directory. Note that it can be easier to keep the assets themselves
    in a different directory than the generated code, as re-running the `go-bindata`
    command will now include a representation of the `assets.go` file itself unless
    it is excluded, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: This file will need to be re-generated whenever modifications are made to the
    underlying assets. Doing so will ensure the changes are made available in the
    compiled assets package that includes the accessibility functions for the files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the assets have been generated, they can be accessed in code by importing
    the new `assets` package and using the `Asset()` function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: For newer versions of Go (1.16 and above), it is even simpler to compile resource
    manifests into assets.
  prefs: []
  type: TYPE_NORMAL
- en: Go 1.16 and newer – go:embed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `go:embed` marker was included as a compiler directive in Go 1.16 to provide
    native resource embedding without the need for external tools such as go-bindata.
    To start with this approach, create the resource manifest files similarly to the
    go-bindata setup under a new directory called `assets/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `main.go` file for the Operator project needs to be modified to import
    the `embed` package and declare the asset manifests as a variable like so (all
    of the following code in this section shows only the changes that you need to
    make):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Note the `//go:embed` comment, which tells the compiler to store the contents
    of `assets/nginx_deployment.yaml` as filesystem data in the `deployment` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data can then be read and converted to a Deployment Go struct by utilizing
    the Kubernetes API scheme declarations like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It imports the relevant Kubernetes API packages that define the schema for
    Deployment API objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It initializes a `Scheme` and a set of codecs that can be used by the API''s
    UniversalDecoder in order to know how to convert the `[]byte` data representation
    of the file to a Go struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It uses the `deployment` variable we declared earlier (as part of setting up
    the `embed` directive) to read the `Deployment` file under `assets/nginx_deployment.yaml`
    (highlighted):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It decodes the `[]byte` data returned from `deployment.ReadFile()` into an
    object that can be cast to the Go type for Deployments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It casts the object data to an in-memory representation of `*appsv1.Deployment`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From this point, it will be necessary to find a way to pass the Deployment object
    to our Nginx Operator Controller. This can be done by modifying the `NginxOperatorReconciler`
    type to have a field that holds a type of `*appsv1.Deployment`. However, this
    is not convenient for all of the different types of resources the Operator will
    be managing. To simplify this and better organize the project's structure, we
    can move the resource embedding code to its own package.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying resource embedding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The preceding examples showed the essential steps of embedding a YAML file
    into Go code. However, for our sample Nginx Operator, this can be better organized
    into its own package. To do this, we will keep the existing `assets/` directory
    (to use as an importable Go module path that holds helper functions for loading
    and processing the files) and place a new `manifests/` directory underneath it
    (which will hold the actual manifest files). This new file structure will look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'The `assets.go` file will include the API schema initialization and wrapped
    object casting functionality from the preceding examples, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: 'This new file makes a couple of changes from the implementation shared before:'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the entire `manifests/` directory is embedded as a filesystem variable.
    This will make it easier to add functions to read other resources within the directory
    without having to declare new variables in this package for each one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The main logic has been wrapped in a new function, `GetDeploymentFromFile()`.
    This function can be called and used by our control loop like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can add other manifests to this directory so that the Operator can manage
    them (for example, additional Operand dependencies). But for now, we have enough
    to begin working on a control loop.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a control loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a strategy for the in-memory representation of resource manifests in place,
    it is now much easier to begin writing the Operator's control loop. As described
    in previous chapters, this control loop comprises a core state reconciliation
    function call that is triggered by certain relevant cluster events. This function
    does not run continuously on a loop, but rather the main thread of the Operator
    will be continuously observing the cluster for those events to kick off a call
    to the state reconciliation function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The empty `Reconcile()` function has been scaffolded already by the Operator
    SDK in `controllers/nginxoperator_controller.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: Right now, this function does nothing but return an empty `ctrl.Result` and
    an empty `error`, which evaluates to a successful run and instructs the rest of
    the framework that there is no need to re-try this reconciliation run. If this
    function returns either a non-nil `error` or non-empty `ctrl.Result` struct, then
    the controller will instead re-queue this reconciliation attempt to be tried again.
    These cases will come up as we populate the controller's logic as indicated by
    the comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the Operator SDK instantiates this controller with a Kubernetes client
    already accessible, we can use functions such as `Get()` to retrieve cluster resources.
    The first thing to do is to attempt to access the existing Nginx Operator resource
    object. If one is not found, we should log a message indicating so and terminate
    the reconciliation attempt. If there are any other errors retrieving the object,
    we will instead return an error, so this attempt gets re-queued and tried again.
    This approach can account for other failures, such as network issues or temporarily
    dropped connections to the API server. With these changes, the new `Reconcile()`
    function looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'controllers/nginxoperator_controller.go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: This error-handling pattern is common among Kubernetes projects, including examples
    from the official Operator SDK documentation. Rather than immediately returning
    the error, this code essentially ignores the case where the Operator object is
    simply not found. The `errors.IsNotFound()` check comes from the `k8s.io/apimachinery/pkg/api/errors`
    package, which provides several helper functions for a standard approach to handling
    specific Kubernetes errors. Using this pattern helps to minimize logging noise
    for the user and to ignore events where the Operator resource was deleted (which
    will still trigger a reconciliation attempt). In the event that the Operator object
    is not found, developers can go a step further and use that as a signal to take
    other steps (such as deleting other resources that depend on the Operator deployment).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that this code is using `req.NamespacedName` to get the `Name` and
    `Namespace` of the Operator config object. This follows one of the best practices
    laid out in the Operator Framework documentation ([https://sdk.operatorframework.io/docs/best-practices/best-practices/](https://sdk.operatorframework.io/docs/best-practices/best-practices/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Operators shouldn''t make any assumptions about the namespace they are deployed
    in, and they should not use hardcoded names of resources that they expect to already
    exist.*'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the `req` parameter includes the name of the object event that
    triggered the reconciliation attempt. Using a consistent name across resources
    allows us to re-use the `req.NamespacedName` field in every call to `Reconcile()`,
    regardless of the object that triggered the reconciliation. In other words, if
    the Deployment has the same Name and Namespace as the Operator custom resource
    object, we can consistently eliminate the use of hardcoded assumptions for resource
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an Operator resource object successfully found, the controller can retrieve
    the values for each setting in the Operator''s `spec` in order to update them,
    if necessary. Similar to what we just did for the Operator resource, however,
    we must first check whether the Deployment exists. For this, we will follow a
    similar pattern utilizing `errors.IsNotFound()` to check for the non-existence
    of an Nginx Deployment. However, in this case, the function will not simply return
    if no Deployment is found, but instead the controller will create one from the
    embedded Deployment YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'controllers/nginxoperator_controller.go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we are loading the embedded default manifest using the `assets.GetDeploymentFromFile()`
    function created earlier. We are also modifying that manifest declaration to include
    the values from the current Operator resource object.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to this approach would be to create the Deployment with the
    default values, and then have the function immediately return with `ctrl.Result{Requeue:
    true}`. This would trigger another reconciliation attempt, where the Deployment
    should be found and then updated with the Operator resource settings. The trade
    - off here is the immediate creation of a new object without the need for another
    reconciliation cycle, in exchange for less atomic operation and some code duplication
    (because we will still need the following code to apply the Operator resource
    settings in the case where an existing Deployment was found). To eliminate that
    duplicate code, we can modify the preceding section like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'controllers/nginxoperator_controller.go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: Since the `Replicas` and `Port` fields in the Operator custom resource are optional
    (and pointers), we should use `nil` checks to see whether any value has been set.
    Otherwise, the Deployment will default to the values defined in its `manifest`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are always making sure that the Deployment object is being modified
    to include the Operator settings, whether it is the existing Deployment or a new
    one. Then, the decision to call `Create()` or `Update()` will be made later based
    on the value of the `create` Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: 'controllers/nginxoperator_controller.go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: 'If either call results in an error, it will be returned and logged by the controller
    thanks to the scaffolded framework code. If the call to create or update the Deployment
    is successful, then `err` will be `nil` and the reconciliation call completes
    successfully. Our full `Reconcile()` function now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'controllers/nginxoperator_controller.go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: In addition, we added a call to `ctrl.SetControllerReference()` to indicate
    that the Nginx Operator resource object should be listed as the `OwnerReference`
    (an API field denoting which object "owns" the specified object) of the Nginx
    Deployment, which helps with garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to ensure that the Operator actually has the cluster permissions
    necessary to get, create, and update Deployments. To do that, we need to update
    the RBAC role for the Operator. This can be done automatically using Kubebuilder
    markers on the `Reconcile()` function, which helps keep permissions organized
    and their necessary usage clearly identified. There are already Kubebuilder markers
    that were generated for accessing the Operator custom resource, but now we can
    add additional ones for Deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'controllers/nginxoperator_controller.go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, running `make manifests` should produce this new section in the Operator''s
    `ClusterRole` (`config/rbac/role.yaml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we now have a basic control loop reconciling the specified Operator
    settings with the current state of the cluster. But what events will trigger this
    loop to run? This is set up in `SetupWithManager()`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'controllers/nginxoperator_controller.go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: 'This code was generated to observe the cluster for changes to the `NginxOperator`
    objects, but we need it to also observe changes to Deployment objects (since the
    Operator is managing a Deployment). This can be done by modifying the function
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: With the added call to `Owns(&appsv1.Deployment{})`, the controller manager
    now knows to also trigger calls to `Reconcile()` for changes to Deployment objects
    in the cluster. The controller will now evaluate any changes to a Deployment object
    as a relevant event for the `NginxOperator` object since we have listed it as
    the owner of the Deployment. Multiple types of objects can be chained into this
    watch list with subsequent calls to `Owns()`.
  prefs: []
  type: TYPE_NORMAL
- en: We now have an Operator that does something. When built and deployed, this controller
    will watch for changes to any `NginxOperator` custom resource in the cluster and
    react to them. This means that the first time a user creates the Operator custom
    resource object, the Operator will see that a configuration object now exists,
    and create a Deployment based on the values present. It will also observe for
    changes to Deployments. For example, if the Nginx Deployment is accidentally deleted,
    the Operator will respond by creating a new one with the existing settings from
    its custom resource.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The steps outlined in this chapter involve using several different tools and
    libraries with varying dependency requirements. Understandably, this can lead
    to errors, especially in different development environments. While the authors
    of the software involved have taken steps to produce informative and helpful error
    messages when necessary, it is not always possible to provide a clear resolution
    with automated responses. Such is the unfortunate nature of rapidly evolving software
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, however, the benefits of open source software provide many resources
    and volunteers to help support and debug issues, should they arise. This section
    will highlight those resources as a guide for resolving technical issues. All
    of these tools offer documentation and how-to guides, but many of them also have
    community resources where users can ask for clarification and assistance from
    maintainers and other users.
  prefs: []
  type: TYPE_NORMAL
- en: General Kubernetes resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Operator SDK is foundationally built upon several Kubernetes libraries;
    therefore, it is very helpful to understand some of the Kubernetes packages that
    are used to build Operators with the framework. By doing so, it can sometimes
    be easier to find the root cause of an issue.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes reference documents are located at [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/).
    However, this home section is mostly oriented toward usage documentation. For
    support regarding the Kubernetes API (including API clients, standards, and object
    references), the API reference section is much more relevant to the topics covered
    in this chapter. That is located at [https://kubernetes.io/docs/reference/](https://kubernetes.io/docs/reference/).
  prefs: []
  type: TYPE_NORMAL
- en: The entire Kubernetes source code is available on GitHub under various organizations,
    such as [https://github.com/kubernetes](https://github.com/kubernetes) (most of
    the project code) and [https://github.com/kubernetes-sigs](https://github.com/kubernetes-sigs)
    (subprojects, such as Kubebuilder). For example, the Go client library, which
    is used by the Operator SDK framework under the hood to provide resource functions
    such as `r.Get()`, is hosted at [https://github.com/kubernetes/client-go/](https://github.com/kubernetes/client-go/).
  prefs: []
  type: TYPE_NORMAL
- en: Familiarity with the GitHub repositories that host the different code dependencies
    that the Operator Framework is built on provides an excellent resource for communication
    with the maintainers of these projects. Searching the *Issues* on GitHub can very
    often provide immediate relief to an issue (or at least provide insight into the
    current status of ongoing problems).
  prefs: []
  type: TYPE_NORMAL
- en: 'For faster responses and a wider audience, the Kubernetes community is very
    active on the Slack messaging platform. The official Kubernetes Slack server is
    open to anyone, at [slack.k8s.io](http://slack.k8s.io). Helpful channels for developers
    working with general Kubernetes issues include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**#kubernetes-novice** – This channel is for new Kubernetes users and developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#kubernetes-contributors** – This channel is more dedicated to the development
    of Kubernetes itself, but there are still useful topics covered around relevant
    topics, such as API clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#kubernetes-novice` with a focus on usage rather than development, but for
    more specific questions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIG-APIMachinery` is responsible for the ownership of the Kubernetes Go client,
    which we used by extension in this chapter. Here you will find the most knowledgeable
    contributors in regard to API topics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the topics in this chapter, these resources are relevant for issues related
    to the Kubernetes API, including the generated client tools created with commands
    such as `make generate`.
  prefs: []
  type: TYPE_NORMAL
- en: Operator SDK resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Operator SDK also provides a wealth of documentation, including example
    Operator development tutorials. In this chapter, developing an Operator in Go
    meant following similar steps to those outlined in the Operator SDK Go documentation,
    located at [https://sdk.operatorframework.io/docs/building-operators/golang/](https://sdk.operatorframework.io/docs/building-operators/golang/).
  prefs: []
  type: TYPE_NORMAL
- en: Similar to other Kubernetes projects, Operator SDK is also available on GitHub
    at [https://github.com/operator-framework/operator-sdk/](https://github.com/operator-framework/operator-sdk/).
    This is a great resource for examples, issue tracking, and staying notified of
    updates and ongoing work with the project.
  prefs: []
  type: TYPE_NORMAL
- en: There are several Operator-specific channels on [slack.k8s.io](http://slack.k8s.io),
    including **#operator-sdk-dev** (which is meant for discussion related to the
    Operator SDK) and **#kubernetes-operators**, which is for general discussion purposes
    regarding Operators.
  prefs: []
  type: TYPE_NORMAL
- en: These resources are all helpful for problems related to the `operator-sdk` binary,
    or the patterns provided by the SDK's code libraries and patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Kubebuilder resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubebuilder is the tool that is used by Operator SDK to generate manifests and
    some controller code. This includes commands that were run in this chapter, such
    as `make manifests`, so for most issues related to CRDs or generating them from
    code markers (for example, `//+kubebuilder…`), this is a good starting point for
    assistance.
  prefs: []
  type: TYPE_NORMAL
- en: An excellent reference for Kubebuilder is the Kubebuilder Book, available at
    [https://book.kubebuilder.io/](https://book.kubebuilder.io/). This is the essential
    documentation reference for Kubebuilder and includes details on all of the available
    comment markers for generating code. Its code base is also available on GitHub
    at [https://github.com/kubernetes-sigs/kubebuilder](https://github.com/kubernetes-sigs/kubebuilder),
    and some of its sub-tools (such as controller-gen) are available at [https://github.com/kubernetes-sigs/controller-tools](https://github.com/kubernetes-sigs/controller-tools).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is the **#kubebuilder** channel on the Kubernetes Slack server
    for interactive discussion and help with this tool.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter followed the design we outlined in [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050),
    *Designing an Operator – CRD, API, and Target Reconciliation*, to produce functional
    code that achieves the minimum requirements for a *Level I* Operator (Basic Install).
    With the support of the Operator Lifecycle Manager (which will be demonstrated
    in later chapters) and good subsequent API design, this Operator will also support
    upgrades for itself and its Operand, which qualifies it for *Level II*.
  prefs: []
  type: TYPE_NORMAL
- en: The steps for creating a Go-based Operator, as recommended by the Operator SDK
    documentation approach, build upon each other to achieve base functionality. In
    this chapter, that pattern meant first designing the Operator's API types, which
    are then generated into a CRD using tools such as Kubebuilder. At this time, it
    is good to begin thinking about other resource manifests, such as the Operand
    Deployment, and how those will be represented in memory. This guide took the approach
    of embedding these additional resources directly into the Go binary using built-in
    Go compiler directives that allow the language to do this natively.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the core controller code was filled in. This is what makes the Operator
    a controller, and this control loop is used to reconcile the desired state of
    the cluster with the actual state of the cluster based on user input through the
    Operator's CRD. With some additional tweaks to the event triggers and added RBAC
    permissions, this code begins to observe Deployments, which is necessary to manage
    the Operand.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build on this basic functionality to add more advanced
    code. This will bring our Operator beyond Level II, as we add things such as metrics
    and leader election to create a more sophisticated controller capable of deeper
    insights and error handling.
  prefs: []
  type: TYPE_NORMAL
