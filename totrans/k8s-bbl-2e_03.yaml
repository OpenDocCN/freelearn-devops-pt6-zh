- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing Your First Kubernetes Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we had the opportunity to explain what Kubernetes is,
    its distributed architecture, the anatomy of a working cluster, and how it can
    manage your Docker containers on multiple Linux machines. Now, we are going to
    get our hands dirty because it’s time to install Kubernetes. The main objective
    of this chapter is to get you a working Kubernetes installation for the coming
    chapters. This is so that you have your own cluster to work on, practice with,
    and learn about while reading this book.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kubernetes means that you have to get the different components to
    work together. Of course, we won’t do that the hard way of setting up individual
    cluster components; instead, we will use automated tools. These tools have the
    benefit of launching and configuring all of the components for us locally. This
    automated Kubernetes cluster setup is particularly beneficial for DevOps teams
    rapidly testing changes to YAML, developers wanting a local environment to test
    applications, and security teams rapidly testing changes to Kubernetes object
    YAML definitions.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want to have a Kubernetes cluster on your local machine, we’re
    also going to set up minimalist yet full-featured production-ready Kubernetes
    clusters on **Google Kubernetes Engine** (**GKE**), **Amazon Elastic Kubernetes
    Service** (**EKS**), and **Azure Kubernetes Service** (**AKS**) in later chapters
    of this book. These are cloud-based and production-ready solutions. In this way,
    you can practice and learn on a real-world Kubernetes cluster hosted on the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you want to go local or on the cloud, it is your choice. You’ll have
    to choose the one that suits you best by considering each solution’s benefits
    and drawbacks. In both cases, however, you’ll require a working `kubectl` installed
    on your local workstation to communicate with the resulting Kubernetes cluster.
    Installation instructions for `kubectl` are available in the previous chapter,
    *Chapter 2*, *Kubernetes Architecture – from Container Images to Running Pods*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Kubernetes cluster with `minikube`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-node Kubernetes cluster with `kind`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternative Kubernetes learning environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production-grade Kubernetes clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl` installed on your local machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A workstation with 2 CPUs or more, 2 GB of free memory, and 20 GB of free disk
    space. (You will need more resources if you want to explore the multi-node cluster
    environments.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A container or virtual machine manager installed on the workstation, such as
    Docker, QEMU, Hyperkit, Hyper-V, KVM, Parallels, Podman, VirtualBox, or VMware
    Fusion/Workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliable internet access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the latest code samples for this chapter from the official
    GitHub repository at [https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter03)
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Kubernetes cluster with minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to install a local Kubernetes cluster
    using `minikube`. It’s probably the easiest way to get a working Kubernetes installation
    locally. By the end of this section, you’re going to have a working single-node
    Kubernetes cluster installed on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: '`minikube` is easy to use and is completely free. It’s going to install all
    of the Kubernetes components on your local machine and configure all of them.
    Uninstalling all of the components through `minikube` is easy too, so you won’t
    be stuck with it if, one day, you want to destroy your local cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: '`minikube` has one big advantage compared to full-fledged production cluster
    deployment methods: it’s a super useful tool for testing the Kubernetes scenarios
    quickly. If you do not wish to use `minikube`, you can completely skip this section
    and choose other methods described in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While `minikube` is a popular choice for local Kubernetes development, it comes
    with some trade-offs in resource usage and feature fidelity compared to a full-blown
    production cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource strain**: Running `minikube` alongside other processes on your local
    machine can be resource-intensive. It requires a good amount of CPU and RAM when
    you want to create larger Kubernetes clusters, potentially impacting the performance
    of other applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking discrepancies**: Unlike a production Kubernetes cluster, `minikube`''s
    default network setup may not fully mimic real-world networking environments.
    This can introduce challenges when replicating or troubleshooting network-related
    issues that might occur in production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compatibility considerations**: Certain Kubernetes features or third-party
    tools might require a more complete Kubernetes setup than what `minikube` offers,
    leading to compatibility issues during development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent storage challenges**: Managing persistent storage for applications
    within `minikube` can be cumbersome due to limitations in its persistent volume
    support compared to a full Kubernetes cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn how to install `minikube` and deploy and develop a Kubernetes
    cluster in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing minikube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will see how the `minikube` tool can be installed on Linux, macOS,
    and Windows. Installing `minikube` using the binary or package manager method
    is a straightforward task, as explained in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: You can install `minikube` using the native package manager such as `apt-get,
    yum`, Zypper, Homebrew (macOS), or Chocolatey (Windows). Refer to the documentation
    ([https://minikube.sigs.k8s.io/docs/start](https://minikube.sigs.k8s.io/docs/start))
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Installing minikube on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On Linux, `minikube` can be installed using the Debian package, the RPM package,
    or the binary, as explained below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Please note, the path can be different in your workstation depending on the
    operating system. You need to ensure the path is included in the **PATH** environment
    variables so that `minikube` command will work without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: Installing minikube on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On macOS, `minikube` can be installed with the binary, as explained below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to install `minikube` on macOS using the package manager,
    Homebrew.
  prefs: []
  type: TYPE_NORMAL
- en: Installing minikube on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like macOS and Linux, it is possible to install `minikube` on Windows using
    multiple methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once you have configured `minikube`, then you can create different types of
    Kubernetes clusters using `minikube`, as explained in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: minikube configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `minikube` utility comes with minimal but effective customizations required
    for a development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the default specification of the Kubernetes cluster created by
    `minikube` will be 2 CPUs and 2 GB memory. It is possible to adjust this value
    using the following command if you need a bigger Kubernetes cluster node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you see on the screen, you need to delete and recreate the `minikube` cluster
    to apply the settings.
  prefs: []
  type: TYPE_NORMAL
- en: Drivers for minikube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`minikube` acts as a simple and lightweight way to run a local Kubernetes cluster
    on your development machine. To achieve this, it leverages **drivers** – the workhorses
    behind managing the cluster’s lifecycle. These drivers interact with different
    virtualization and containerization technologies, allowing `minikube` to create,
    configure, and control the underlying infrastructure for your local Kubernetes
    environment. `minikube`''s driver flexibility empowers you to deploy your cluster
    as a virtual machine, a container, or even directly on the bare metal of your
    development machine, tailoring the setup to your specific needs and preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Container drivers**: For a containerized approach, `minikube` can leverage
    a local Podman or Docker installation. This allows you to run `minikube` directly
    within a container on your development machine, potentially offering a more lightweight
    and resource-efficient setup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual machine (VM) drivers**: If you prefer a VM approach, `minikube` can
    launch VMs on your machine. These VMs will then house and wrap the necessary Kubernetes
    components, providing a more isolated environment for your local cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice between container and VM drivers depends on your specific needs and
    preferences, as well as your development environment’s capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the `minikube` driver documentation ([https://minikube.sigs.k8s.io/docs/drivers/](https://minikube.sigs.k8s.io/docs/drivers/))
    to learn about available and supported `minikube` drivers and supported operating
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to set the default driver for `minikube` using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the driver can be set while creating the `minikube` cluster as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Prerequisites depend on the individual `minikube` drivers and must be installed
    and prepared. These may include an installation of Docker, Podman, or VirtualBox
    with permissions granted on a specific operating system. Installation and configuration
    instructions can be found in the `minikube` driver-specific documentation ([https://minikube.sigs.k8s.io/docs/drivers](https://minikube.sigs.k8s.io/docs/drivers)).
  prefs: []
  type: TYPE_NORMAL
- en: Let us learn how to launch our first Kubernetes cluster using `minikube` in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a single-node Kubernetes cluster using minikube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main purpose of `minikube` is to launch the Kubernetes components on your
    local system and have them communicate with each other. In the following sections,
    we will learn how to deploy `minikube` clusters using the VirtualBox driver and
    Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up minikube using VMs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The VM method requires you to install a hypervisor on top of your workstation
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux: KVM2 (preferred), VirtualBox, QEMU'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows: Hyper-V (preferred), VirtualBox, VMware Workstation, QEMU'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'macOS: Hyperkit, VirtualBox, Parallels, VMware Fusion, QEMU'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, `minikube` will wrap all of the Kubernetes components into a VM that will
    be launched.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we are using Fedora 39 as our workstation and VirtualBox
    as our hypervisor software as it is available for Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)
    to download and install VirtualBox for your workstation. You are free to use your
    own choice of virtualization software and always follow the documentation ([https://minikube.sigs.k8s.io/docs/drivers/](https://minikube.sigs.k8s.io/docs/drivers/))
    to see the supported virtualization software.
  prefs: []
  type: TYPE_NORMAL
- en: Do not confuse the `minikube` version and the deployed Kubernetes version. For
    example, `minikube 1.32` uses Kubernetes 1.28 for stability and compatibility
    reasons. This allows for thorough testing, broader tool support, controlled rollouts,
    and longer-term support for older versions. Users still have the flexibility to
    run different versions of Kubernetes independently. This balance between stability
    and flexibility makes `minikube` a reliable and versatile platform for developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'On your workstation where you have installed `minikube` and VirtualBox, execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using a particular version of `minikube` but want to install a different
    version of Kubernetes, then you can mention the specific version, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that `minikube` is starting the Kubernetes deployment process
    including the VM image downloading, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also see the below information based on your workstation’s operating
    system and the virtualization software as a recommendation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you will see the following success message from `minikube`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Yes, you have deployed a fully working Kubernetes cluster within a minute and
    are ready to deploy your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now verify the Kubernetes cluster status using the `minikube` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also see the new `minikube` VM in your VirtualBox UI, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: The minikube VM on the VirtualBox UI'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to deploy Kubernetes clusters using `minikube`
    and containers.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up minikube using a container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The container method is simpler. Instead of using a VM, `minikube` uses a local
    Docker Engine instance or Podman to launch the Kubernetes components inside a
    big container. To use the container-based `minikube`, make sure that you install
    Docker or Podman by following the instructions for your workstation operating
    system on which you are installing `minikube`; `minikube` will not install Podman
    or Docker for you. If the provided driver is missing or if the `minikube` cannot
    find the driver on the system, you may get an error, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The Docker installation process is easy, but the steps can vary depending on
    your operating system, and you can take a look at the documentation ([https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/))
    for more information. Similarly, the Podman installation steps are available at
    [https://podman.io/docs/installation](https://podman.io/docs/installation) for
    different operating system flavors.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a Windows workstation and Hyper-V-based VM for your hands-on
    lab, remember to disable Dynamic Memory for the VM in which you are installing
    `minikube` and the container engine.
  prefs: []
  type: TYPE_NORMAL
- en: When running with the Podman driver, `minikube` performs a check of the available
    memory when it starts, and will report the “in-use” memory (set dynamically).
    So, you need to ensure enough memory is available or configure memory requirements
    for the Kubernetes node.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are using Fedora 39 as our workstation and Docker
    as the container engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use Podman as the container engine and create a Kubernetes cluster
    using `minikube` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the Kubernetes cluster created using `minikube`, in the next section
    let us learn how to access and manage the cluster using `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Kubernetes cluster created by minikube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we need to create a `kubeconfig` file for our local `kubectl` CLI to be
    able to communicate with this new Kubernetes installation. The good news is that
    `minikube` also generated one on the fly for us when we launched the `minikube
    start` command. The `kubeconfig` file generated by `minikube` is pointing to the
    local `kube-apiserver` endpoint, and your local `kubectl` was configured to call
    this cluster by default. So, essentially, there is nothing to do: the `kubeconfig`
    file is already formatted and in the proper location.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, this configuration is in `~/.kube/config`, and you should be able
    to see that a `minikube` context is now present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to display the current `kubeconfig` file. You should
    observe a cluster, named `minikube`, that points to a local IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this, run the following command, which will show the Kubernetes cluster
    that your `kubectl` is pointing to right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s try to issue a real `kubectl` command to list the nodes that are
    part of our `minikube` cluster. If everything is okay, this command should reach
    the `kube-apiserver` component launched by `minikube`, which will return only
    one node since `minikube` is a single-node solution. Let’s list the nodes with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t view any errors when running this command, it means that your `minikube`
    cluster is ready to be used and is fully working!
  prefs: []
  type: TYPE_NORMAL
- en: This is the very first real `kubectl` command you ran as part of this book.
    Here, a real `kube-apiserver` component received your API call and answered back
    with an HTTP response containing data coming from a real `etcd` data store. In
    our scenario, this is the list of the nodes in our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Since `minikube` creates a single-node Kubernetes cluster by default, this command
    only outputs one node. This node is both a control plane node and a compute node
    at the same time. It’s good for local testing, but do not deploy such a setup
    in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we can do now is list the status of the control plane components so that
    you can start familiarizing yourself with `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This command should output the status of the control plane components. You
    should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A running `etcd` datastore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A running `kube-scheduler` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A running `kube-controller-manager` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will learn how to housekeep your Kubernetes learning
    environment by stopping and deleting the `minikube` Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping and deleting the local minikube cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might want to stop or delete your local `minikube` installation. To proceed,
    do not kill the VM or container directly, but rather, use the `minikube` command-line
    utility. Here are the two commands to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will stop the cluster. However, it will continue to exist;
    its state will be kept, and you will be able to resume it later using the following
    `minikube start` command again. You can check it by calling the `minikube status`
    command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to pause the cluster instead of stopping so that you can
    quickly re-start the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And later, you can resume the cluster as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to destroy the cluster, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you use this command, the cluster will be completely destroyed. Its state
    will be lost and impossible to recover.
  prefs: []
  type: TYPE_NORMAL
- en: Now that your `minikube` cluster is operational, it’s up to you to decide whether
    you want to use it to follow the next chapters or pick another solution.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-node Kubernetes cluster using minikube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also possible to create multi-node kubernetes clusters using `minikube`.
    In the following demonstration, we are creating a three-node Kubernetes cluster
    using `minikube`:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to ensure that, your workstation has enough resources to create multiple
    Kubernetes nodes (either VMs or containers) when you create multi-node clusters.
    Also, note that `minikube` will spin up nodes with the same vCPU and memory you
    mentioned in settings or arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the cluster is provisioned, check the node details and find all the nodes
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`minikube` created a three-node cluster (`--nodes=3`) with the first node as
    the control plane node (or master node) and the remaining two nodes as compute
    nodes (you will need to assign appropriate labels later; we will learn about this
    in later chapters).'
  prefs: []
  type: TYPE_NORMAL
- en: Multi-master Kubernetes cluster using minikube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There might be situations where you want to deploy and test Kubernetes clusters
    with a high availability control plane with multiple control plane nodes. You
    can implement the same using `minikube` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`minikube` will create a five-node cluster (`--nodes 5`) and configure the
    first three nodes as control plane nodes (`--ha true`).'
  prefs: []
  type: TYPE_NORMAL
- en: Again, remember to ensure you have enough resources on your workstation to create
    such multi-node clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Kubernetes clusters using minikube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we learned, `minikube` is meant for the development and testing of Kubernetes
    environments. There might be situations where you want to simulate the environment
    with multiple Kubernetes clusters. In that case, you can use `minikube` again
    as it is possible to create multiple Kubernetes clusters using `minikube`. But
    remember to give different names (`--profile`) for your different Kubernetes clusters,
    as explained below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can list the `minikube` clusters and find the details, as shown in the
    below image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: minikube profile list showing multiple Kubernetes clusters'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We have learned how to create different types and sizes of Kubernetes clusters;
    now let’s examine another tool for setting up a local Kubernetes cluster, called
    `kind`.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-node Kubernetes cluster with kind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to discuss a tool called `kind`, which is also
    designed to run a Kubernetes cluster locally, just like `minikube`.
  prefs: []
  type: TYPE_NORMAL
- en: The whole idea behind `kind` is to use Docker or Podman containers as Kubernetes
    nodes thanks to the **Docker-in-Docker** (**DinD**) or **Containers-in-Container**
    model. By launching containers, which themselves contain the container engines
    and the kubelet, it is possible to make them behave as Kubernetes worker nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the high-level architecture of `kind` cluster components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: kind cluster components (image source: https://kind.sigs.k8s.io/docs/design/initial)'
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly the same as when you use the Docker driver for `minikube`, except
    that there, it will not be done in a single container but in several. The result
    is a local multi-node cluster. Similar to `minikube`, `kind` is a free open-source
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `minikube`, `kind` is a tool that is used for local development and
    testing. Please never use it in production because it is not designed for it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing kind onto your local system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since `kind` is a tool entirely built around Docker and Podman, you need to
    have either of these container engines installed and working on your local system.
  prefs: []
  type: TYPE_NORMAL
- en: Since the Docker and Podman installation instructions are available as documentation,
    we will skip those steps here (refer to the earlier section, *Setting up minikube
    using a container*, for the details).
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the `kind` release page for the `kind` version information and availability
    ([https://github.com/kubernetes-sigs/kind/releases](https://github.com/kubernetes-sigs/kind/releases)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the process of installing `kind` will depend on your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following commands for Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following commands for macOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also install it with Homebrew:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following commands for Windows PowerShell:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also install it with Chocolatey:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have Go language installed, then you can use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Refer to the documentation (https://kind.sigs.k8s.io/docs/user/quick-start#installation)
    to learn other installation methods for your system.
  prefs: []
  type: TYPE_NORMAL
- en: Let us learn how to create a Kubernetes cluster using `kind` in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes cluster with kind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once `kind` has been installed on your system, you can immediately proceed
    to launch a new Kubernetes cluster using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When you run this command, `kind` will start to build a Kubernetes cluster locally
    by pulling a container image containing all the control plane components. The
    result will be a single-node Kubernetes cluster with a Docker container acting
    as a *control plane node*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Podman can be used as the provider for the `kind` cluster if you prefer, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not want this setup since we can already achieve it with `minikube`.
    What we want is a multi-node cluster with `kind` where we can customize the cluster
    and nodes. To do this, we must write a very small configuration file and tell
    `kind` to use it as a template to build the local Kubernetes cluster. So, let’s
    get rid of the single-node `kind` cluster that we just built, and let’s rebuild
    it as a multi-node cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this command to delete the cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to create a `config` file that will serve as a template for `kind`
    to build our cluster. Simply copy the following content to a local file in this
    directory, for example, `~/.kube/kind_cluster`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Please note that this file is in YAML format. Pay attention to the `nodes`
    array, which is the most important part of the file. This is where you tell `kind`
    how many nodes you want in your cluster. The role key can take two values: control
    plane and worker.'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on which role you choose, a different node will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s relaunch the `kind create` command with this `config` file to build our
    multi-node cluster. For the given file, the result will be a one-master, three-worker
    Kubernetes cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is also possible to build a specific version of Kubernetes by using the
    appropriate image details while creating the `kind` cluster, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'A new Kubernetes cluster will be deployed and configured by `kind` and you
    will receive the messages related to cluster access at the end, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this, you should have four new Docker containers: one running as
    a master node and the other three as worker nodes of the same Kubernetes cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as always with Kubernetes, we need to write a `kubeconfig` file for our
    `Kubectl` utility to be able to interact with the new cluster. And guess what,
    `kind` has already generated the proper configuration and appended it to our `~/.kube/config`
    file, too. Additionally, `kind` set the current context to our new cluster, so
    there is essentially nothing left to do. We can immediately start querying our
    new cluster. Let’s list the nodes using the `kubectl get nodes` command. If everything
    is okay, we should view four nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Everything seems to be perfect. Your `kind` cluster is working!
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we did with `minikube`, you can also check for the component’s statuses
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To further debug and diagnose cluster problems, use `''kubectl cluster-info
    dump`'':'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As part of the development and learning environment housekeeping, we need to
    learn how to stop and delete Kubernetes clusters created using `kind`. Let us
    learn how to do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping and deleting the local kind cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might want to stop or remove everything `kind` created on your local system
    to clean the place after your practice. To do so, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This command will stop the Docker containers that `kind` is managing. You will
    achieve the same result if you run the Docker `stop` command on your containers
    manually. Doing this will stop the containers but will keep the state of the cluster.
    That means your cluster won’t be destroyed, and simply relaunching it using the
    following command will get the cluster back to its state before you stop it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to completely remove the cluster from your system, use the following
    command. Running this command will result in removing the cluster and its state
    from your system. You won’t be able to recover the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now that your `kind` cluster is operational, it’s up to you to decide whether
    you want to use it to practice while reading the coming chapters. You can also
    decide whether to pick another solution described in the following sections of
    this chapter. `kind` is particularly nice because it’s free to use and allows
    you to install a multi-node cluster. However, it’s not designed for production
    and remains a development and testing solution for a non-production environment.
    `kind` makes use of Docker containers to create *Kubernetes nodes*, which, in
    the real world, are supposed to be Linux machines.
  prefs: []
  type: TYPE_NORMAL
- en: Let us learn about some of the alternative Kubernetes learning and testing environments
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Kubernetes learning environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also utilize some of the available zero-configuration learning environments,
    designed to make your Kubernetes journey smooth and enjoyable.
  prefs: []
  type: TYPE_NORMAL
- en: Play with Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This interactive playground (`labs.play-with-k8s.com`), brought to you by **Docker**
    and **Tutorius**, provides a simple and fun way to experiment with Kubernetes.
    Within seconds, you’ll be running your own Kubernetes cluster directly in your
    web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The environment comes with the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Free Alpine Linux VM: Experience a realistic VM environment without leaving
    your browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DinD: This technology creates the illusion of multiple VMs, allowing you to
    explore distributed systems concepts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Killercoda Kubernetes playground
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Killercoda** ([https://killercoda.com/playgrounds/scenario/kubernetes](https://killercoda.com/playgrounds/scenario/kubernetes))
    is a zero-configuration playground that offers a temporary Kubernetes environment
    accessible through your web browser. Stay on top of the latest trends with their
    commitment to providing the newest kubeadm Kubernetes version just a few weeks
    after release.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The environment comes with the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ephemeral environment: Get started quickly with a preconfigured cluster that
    vanishes once you’re done. This makes it perfect for quick experimentation without
    commitment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Empty kubeadm cluster with two nodes: Dive into the core functionalities of
    Kubernetes with a readily available two-node cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Control plane node with scheduling ability: Unlike some playgrounds, this one
    lets you schedule workloads on the control plane node, providing more flexibility
    for testing purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore some of the production-grade Kubernetes options in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Production-grade Kubernetes clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been talking about the Kubernetes environments for development and learning
    purposes so far. How do you build a production-grade Kubernetes environment that
    meets your specific needs? Next, we’ll see some of the well-known options adopted
    by Kubernetes users.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, let us understand the managed Kubernetes services
    offered by the major **Cloud Service Providers** (**CSPs**).
  prefs: []
  type: TYPE_NORMAL
- en: Managed Kubernetes clusters using cloud services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you prefer to have your Kubernetes environment using managed services, then
    there are several options available, such as GKE, AKS, EKS, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Google Kubernetes Engine** (**GKE**): Offered by **Google Cloud Platform**
    (**GCP**), GKE is a fully managed Kubernetes service. It takes care of the entire
    cluster lifecycle, from provisioning and configuration to scaling and maintenance.
    GKE integrates seamlessly with other GCP services, making it a great choice for
    existing GCP users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Kubernetes Service** (**AKS**): Part of Microsoft Azure, AKS is another
    managed Kubernetes offering. Similar to GKE, AKS handles all aspects of cluster
    management, allowing you to focus on deploying and managing your containerized
    applications. AKS integrates well with other Azure services, making it a natural
    fit for Azure users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Elastic Kubernetes Service** (**EKS**): Offered by **Amazon Web Services**
    (**AWS**), EKS provides a managed Kubernetes service within the AWS ecosystem.
    Like GKE and AKS, EKS takes care of cluster management, freeing you to focus on
    your applications. EKS integrates with other AWS services, making it a strong
    option for AWS users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These managed Kubernetes services provide a convenient and scalable way to deploy
    and manage your containerized applications without the complexities of self-managed
    Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have detailed chapters to learn how to deploy and manage such clusters as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 15*, *Kubernetes Clusters on Google Kubernetes Engine*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 16*, *Launching a Kubernetes Cluster on Amazon Web Services with Amazon
    Elastic Kubernetes Service*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 17*, *Kubernetes Clusters on Microsoft Azure with Azure Kubernetes
    Service*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you do not have a local Kubernetes setup, as we explained in the previous
    sections of this chapter, you can create one using the managed Kubernetes service
    on your choice of cloud platform by referring to the respective chapter. But it
    is a requirement to have a working Kubernetes cluster before you start reading
    the next part of this book, *Part 2*: *Diving into Kubernetes Core Concepts*.'
  prefs: []
  type: TYPE_NORMAL
- en: We will learn about the Kubernetes distributions and platforms in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes distributions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes distributions are essentially pre-packaged versions of Kubernetes
    that include additional features and functionalities beyond the core Kubernetes
    offering. They act like value-added packages, catering to specific needs and simplifying
    deployments for users. For a more feature-rich experience, consider these Kubernetes
    distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Red Hat OpenShift**: This enterprise-grade distribution extends Kubernetes
    with developer tools (image builds and CI/CD pipelines), multi-cluster management,
    security features (RBAC and SCC), and built-in scaling for complex deployments
    ([https://www.redhat.com/en/technologies/cloud-computing/openshift](https://www.redhat.com/en/technologies/cloud-computing/openshift)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rancher**: A complete container management platform, Rancher goes beyond
    Kubernetes. It offers multi-cluster management across diverse environments, workload
    management for various orchestration platforms, and a marketplace for preconfigured
    applications ([https://www.rancher.com/](https://www.rancher.com/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VMware Tanzu**: Designed for the VMware ecosystem, Tanzu integrates seamlessly
    for infrastructure provisioning, security, and hybrid cloud deployments. It provides
    lifecycle management tools for containerized applications within the VMware environment
    ([https://tanzu.vmware.com/platform](https://tanzu.vmware.com/platform)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note, some of the above-listed Kubernetes distributions are subscription-based
    or license-based products and are not freely available.
  prefs: []
  type: TYPE_NORMAL
- en: Let us learn about some of the Kubernetes deployment tools in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes installation tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following tools provide flexibility and control over the Kubernetes cluster
    setup. Of course, you need to add more automation using other third-party tools
    and platforms to manage your Kubernetes environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**kubeadm**: This official Kubernetes tool provides a user-friendly way to
    set up Kubernetes clusters, making it suitable for both testing and production
    environments. Its simplicity allows for quick cluster deployment but may require
    additional configuration for production-grade features like high availability
    ([https://kubernetes.io/docs/reference/setup-tools/kubeadm/](https://kubernetes.io/docs/reference/setup-tools/kubeadm/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kops**: For managing robust Kubernetes clusters in production, kops is an
    official Kubernetes project offering command-line control. It streamlines the
    creation, upgrading, and maintenance of highly available clusters, ensuring the
    reliable operation of your containerized applications ([https://kops.sigs.k8s.io/](https://kops.sigs.k8s.io/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubespray**: Looking to deploy Kubernetes on bare metal or VMs? Kubespray
    leverages the power of Ansible automation. It combines Ansible playbooks with
    Kubernetes resources, allowing for automated cluster deployment on your preferred
    infrastructure ([https://github.com/kubespray](https://github.com/kubespray)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terraform**: This tool allows you to define and manage your Kubernetes cluster
    infrastructure across various cloud providers. The code-driven approach ensures
    consistency and repeatability when deploying clusters in different environments
    ([https://www.terraform.io/](https://www.terraform.io/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pulumi**: Similar to Terraform, Pulumi provides infrastructure-as-code capabilities.
    It allows you to define and manage your Kubernetes cluster infrastructure using
    programming languages like Python or Go. This approach offers greater flexibility
    and customization compared to purely declarative configuration languages ([https://www.pulumi.com/](https://www.pulumi.com/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Kubernetes landscape is very large with several Kubernetes clusters,
    then you need to consider hybrid-multi-cluster management solutions; let us learn
    about those in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid and multi-cloud solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Managing Kubernetes clusters across diverse environments requires powerful
    tools, and there are a few offering such multi-cluster management features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Anthos** (Google): This hybrid and multi-cloud platform facilitates managing
    Kubernetes clusters across diverse environments. Anthos allows organizations to
    leverage a consistent approach for deploying and managing containerized applications
    on-premises, in the cloud, or at the edge ([https://cloud.google.com/anthos](https://cloud.google.com/anthos)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Red Hat Advanced Cluster Management (RHACM) for Kubernetes**: Red Hat also
    offers a solution for managing Kubernetes clusters across hybrid and multi-cloud
    environments. Their Advanced Cluster Management platform provides a centralized
    control plane for consistent deployment, management, and governance of your containerized
    workloads ([https://www.redhat.com/en/technologies/management/advanced-cluster-management](https://www.redhat.com/en/technologies/management/advanced-cluster-management)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VMware Tanzu Mission Control**: This centralized management tool simplifies
    the process of overseeing Kubernetes clusters across various environments. From
    a single console, you can provision, monitor, and manage clusters regardless of
    their location, be that on-premises, cloud, or hybrid ([https://docs.vmware.com/en/VMware-Tanzu-Mission-Control/index.html](https://docs.vmware.com/en/VMware-Tanzu-Mission-Control/index.html)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you choose your Kubernetes platform and management solutions? Let’s explore
    some of the key points in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best production-grade Kubernetes environment depends on several factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Level of control**: Do you need complete control over the cluster configuration,
    or are you comfortable with preconfigured managed services?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Existing infrastructure**: Consider your existing infrastructure (cloud provider,
    bare metal) when choosing a deployment method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability needs**: How easily do you need to scale your cluster up or down
    to meet changing demands?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Team expertise**: Evaluate your team’s experience with Kubernetes and cloud
    infrastructure to determine which solution best suits their skills.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By carefully considering these factors and exploring the various options available,
    you can build a production-grade Kubernetes environment that delivers optimal
    performance and scalability for your containerized applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section we will discuss some of the cluster maintenance tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running Kubernetes On-Premises: Challenges and Considerations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running Kubernetes in an on-premises environment provides more control over
    infrastructure but also demands careful management. Compared to cloud-managed
    solutions, maintaining an on-premises Kubernetes cluster requires handling all
    aspects, from provisioning to upgrades, manually. Below, we explore key considerations
    and challenges that arise when managing Kubernetes on-premises.
  prefs: []
  type: TYPE_NORMAL
- en: '**Infrastructure Provisioning**: Setting up infrastructure for Kubernetes on-premises
    means automating the provisioning of nodes. Tools like Rancher’s cloud controllers
    or Terraform help streamline this process by ensuring consistency. Packer can
    also be used to create VM images, enabling smoother upgrades by deploying updated
    images across nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster Setup and Maintenance**: Deploying a Kubernetes cluster on-premises
    involves using tools such as `kubeadm`. This process is often more involved than
    in cloud-managed environments. Cluster maintenance tasks include renewing certificates,
    managing nodes, and handling high availability setups, which add further complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load Balancing and Access**: Providing external access to applications in
    on-premises environments can be challenging. Standard Kubernetes options like
    **NodePort** and **LoadBalancer** services may not be enough. **MetalLB** can
    offer a load balancing solution for bare-metal setups but comes with limitations,
    such as not being able to load balance the API server in high availability environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent Storage**: Persistent storage is critical for running production
    workloads. Kubernetes relies on **PersistentVolumeClaims** (**PVCs**) and **PersistentVolumes**
    (**PVs**), which require integration with physical storage systems. Tools like
    Longhorn allow dynamic provisioning of volumes and replication across nodes, providing
    flexibility in on-prem setups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Upgrades and Scalability**: Kubernetes releases frequent updates, which means
    managing upgrades on-premises can be tricky. It’s essential to test new versions
    before rolling them out to production. Tools like Packer and Terraform can assist
    in scaling by simplifying node additions and upgrades.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking**: On-premises Kubernetes networking depends on your data center
    configuration. Manual management of DNS, load balancers, and network settings
    is necessary. Monitoring tools such as Prometheus, alongside solutions like MetalLB
    for load balancing, can help, though they require integration and constant monitoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring and Management**: Monitoring on-premises clusters is essential
    for ensuring the system’s health. Tools like Prometheus and Grafana can be used
    to monitor resource usage. Additionally, logging and alerting systems should be
    set up to detect and resolve issues swiftly, helping to minimize downtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tooling and Automation**: Automating tasks such as node management and upgrades
    are vital in on-premises clusters. Enterprise Kubernetes platforms like Rancher
    or OpenShift help reduce manual intervention, providing a more streamlined and
    manageable Kubernetes environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and Compliance**: Security is crucial in enterprise Kubernetes setups.
    Including **FIPS** (**Federal Information Processing Standards**) support from
    the beginning can help meet compliance needs and maintain a secure environment
    as the system evolves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, managing Kubernetes on-premises provides more flexibility but demands
    careful attention to infrastructure, networking, and storage setups. With the
    right tools and strategies, organizations can effectively scale and maintain a
    robust Kubernetes environment on their own infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was quite intense! You require a Kubernetes cluster to follow this
    book, and so we examined five ways in which to set up Kubernetes clusters on different
    platforms. You learned about `minikube`, which is the most common way to set up
    a cluster on a local machine. You also discovered `kind`, which is a tool that
    can set up multi-node local clusters, which is a limitation of `minikube`.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about some of the Kubernetes learning environments and also explored
    the production-grade Kubernetes environments including three major Kubernetes
    cloud services, GKE, Amazon EKS, and AKS. These three services allow you to create
    a Kubernetes cluster on the cloud for you to practice and train with. This was
    just a quick introduction to these services, and we will have the opportunity
    to dive deeper into these services later. For the moment, simply pick the solution
    that is the best for you.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to dive into Kubernetes by exploring the concept
    of Pods. The Pod resource is the most important resource that Kubernetes manages.
    We will learn how to create, update, and delete Pods. Additionally, we will look
    at how to provision them, how to get information from them, and how to update
    the containers they are running.
  prefs: []
  type: TYPE_NORMAL
- en: We will deploy an NGINX Pod on a Kubernetes cluster and examine how we can access
    it from the outside. By the end of the next chapter, you will be capable of launching
    your first containers on your Kubernetes cluster through the usage of Pods. The
    cluster that you installed here will be very useful when you follow the real-world
    examples that are coming in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing `minikube`: [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minikube` drivers: [https://minikube.sigs.k8s.io/docs/drivers/](https://minikube.sigs.k8s.io/docs/drivers/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing Docker: [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing Podman: [https://podman.io/docs/installation](https://podman.io/docs/installation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multi-node Kubernetes using `minikube`: [https://minikube.sigs.k8s.io/docs/tutorials/multi_node/](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing `kind`: [https://kind.sigs.k8s.io/docs/user/quick-start#installation](https://kind.sigs.k8s.io/docs/user/quick-start#installation
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code119001106479081656.png)'
  prefs: []
  type: TYPE_IMG
