- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Introduction to GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this opening chapter, we’ll delve into GitOps, an innovative approach that’s
    revolutionizing software development and operations. This chapter begins with
    the tale of GitOps, focusing on its transformative effect on organizational culture
    and workflows. The *Fundamentals of GitOps* section outlines its core principles,
    such as the centralization of Git, its declarative approach, and automated synchronization.
    *Traditional CI/CD with DevOps against GitOps* traces the evolution of software
    deployment, contextualizing GitOps in the broader history of the field. This chapter
    will also contrast traditional CI/CD and DevOps methodologies with GitOps, highlighting
    GitOps as an evolution in managing complex systems. We’ll conclude by discussing
    the advantages of adopting GitOps for platform engineering while illustrating
    its efficiency, consistency, and adaptability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: GitOps unveiled – reshaping development culture and practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fundamentals of GitOps and the advantages of adopting it for platform engineering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why GitOps?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The integration between GitOps, IaC, and Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this chapter, you need to have basic knowledge of **version
    control**, **Infrastructure as Code** (**IaC**), **continuous integration** (**CI**),
    **continuous delivery** (**CD**), and Kubernetes. Basic knowledge of major cloud
    providers, such as **Google Cloud Platform** (**GCP**), **AWS**, and Azure, will
    be beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps unveiled – reshaping development culture and practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the realm of modern software development and operations, GitOps emerges as
    a confluence of ideas and practices, redefining the approach to managing complex
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: The term GitOps was first introduced by *Alexis Richardson*, the co-founder
    of **Weaveworks**, in August 2017 through a series of blog posts. Richardson described
    GitOps as a methodology where developer tools are pivotal in driving operational
    procedures. This approach emphasized the significance of using declarative tools
    and advocated for the best practices wherein configurations are treated as code.
    Consequently, these configurations should be subject to version control, aligning
    with the core principles of GitOps.
  prefs: []
  type: TYPE_NORMAL
- en: This innovative concept marked a shift in how software development and IT operations
    teams approach how infrastructure and applications are managed and deployed, promoting
    a more efficient, transparent, and reliable process.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps is a paradigm that represents a breakthrough in how software development
    and operations teams manage and deploy applications and infrastructure. It revolves
    around the idea of using **Git**, a widely used version control system, as the
    single source of truth for declarative infrastructure and applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Version control**, also known as source control, is a system that records
    changes to a file or set of files over time so that you can recall specific versions
    later. It allows multiple people to work on a document simultaneously, and version
    control systems provide a way to manage these changes among multiple people.'
  prefs: []
  type: TYPE_NORMAL
- en: Traditional CI/CD with DevOps against GitOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In traditional IT operations, as shown in *Figure 1**.1*, the development team
    periodically hands over new software versions to a **quality assurance** (**QA**)
    team. This team tests the software and passes it to the operations team for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'As software release cycles become shorter, traditional operations models struggle
    to keep up. The operations team oversees configuring the infrastructure for new
    software versions while focusing on system reliability, resilience, and security:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Example of a traditional IT operations workflow](img/B22100_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Example of a traditional IT operations workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'Managing infrastructure **without** advanced frameworks can be complex and
    requires specialized knowledge. IT operations encompass all processes and services
    provided by IT staff to meet a business’s technological requirements. This includes
    handling maintenance work and responding to customer issues. In traditional models,
    development, QA, and operations teams often work under different management structures,
    so detailed handoff processes and thorough documentation are crucial:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Traditional organization model with separated teams](img/B22100_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Traditional organization model with separated teams
  prefs: []
  type: TYPE_NORMAL
- en: The traditional organizational model, which is characterized by distinct, separated
    teams, tends to **complicate** the delivery process. This separation often leads
    to slower deployments and reduced deployment frequencies. Additionally, the need
    to transition tasks between teams heightens the risk of miscommunication, which
    can result in testing oversights and deployment errors.
  prefs: []
  type: TYPE_NORMAL
- en: Most development teams use automated build systems and CI to compile, test,
    and produce deployable artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'CI is a foundational process in modern software development that automates
    building, testing, and packaging applications, as shown in *Figure 1**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Example of a CI workflow](img/B22100_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Example of a CI workflow
  prefs: []
  type: TYPE_NORMAL
- en: In this system, software engineers frequently commit code changes to a central
    repository (for example, a **Git repository**), where these changes are automatically
    built, tested, and prepared for integration with the main code branch. This approach
    ensures that the software is always in a state ready for production deployment,
    highlighting the importance of CI in maintaining the continuous flow of software
    development.
  prefs: []
  type: TYPE_NORMAL
- en: CI’s automated processes are crucial for ensuring the quality and integrity
    of code before it merges with the main branch. By automating these stages, CI
    minimizes the risks associated with human error and speeds up the development
    cycle. However, the process often halts at the deployment stage, which is still
    predominantly manual in many organizations. This manual deployment can involve
    complex procedures or semi-automated scripts and often requires operations engineers
    to physically transfer and restart applications on servers. Such manual interventions
    are prone to errors and lack robust control mechanisms, making them inefficient
    and risky.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on the foundations of CI, **CD** takes automation a step further:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Example of a CD workflow](img/B22100_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Example of a CD workflow
  prefs: []
  type: TYPE_NORMAL
- en: CD is a practice where code changes, once they pass through CI’s build and testing
    phases, are automatically prepared and ready for release to a production environment.
    It always keeps the software in a **release-ready** state, dramatically simplifying
    the process of releasing updates and new features.
  prefs: []
  type: TYPE_NORMAL
- en: CD versus continuous deployment
  prefs: []
  type: TYPE_NORMAL
- en: CD and continuous deployment are closely related practices in software development
    that streamline the release process. CD ensures every code change is automatically
    built, tested, and prepared for release, allowing for manual deployment to production.
    Continuous deployment goes a step further by automatically deploying every change
    that passes testing directly into production, eliminating manual steps. This accelerates
    the release process but demands high confidence in automation and testing protocols.
  prefs: []
  type: TYPE_NORMAL
- en: CD not only reduces the risks associated with deploying releases by enabling
    smaller and more frequent updates that are easier to manage than larger, infrequent
    ones, but it also significantly shortens prolonged testing cycles typically necessary
    for extensive code changes. This method enhances collaboration among development,
    operations, and other teams, aligning all parties toward the shared goal of rapidly
    and efficiently delivering high-quality software. CD efficiently manages and mitigates
    potential risks associated with large-scale code modifications, fostering a more
    agile and responsive software development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: CD empowers businesses to quickly adapt to market changes and customer feedback,
    maintaining a competitive edge in innovation and customer satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: '**DevOps** marks a significant shift in both organizational framework and mindset,
    placing a strong emphasis on automation. DevOps, in essence, acts as the glue
    that binds the technical efficiencies of CI/CD with the strategic goals of the
    organization. It emphasizes continuous feedback, monitoring, and optimization
    throughout the development process, ensuring continuous improvement post-deployment.
    This approach ensures that software development is not just a linear process ending
    with deployment but a cyclical one, where feedback and performance data feed back
    into the development process.'
  prefs: []
  type: TYPE_NORMAL
- en: GitOps is an influential operational model that builds upon the core practices
    of DevOps, which are widely adopted in application development, and applies them
    to infrastructure automation. It integrates essential principles such as version
    control, collaborative work, adherence to compliance standards, and the use of
    CI/CD tools. This strategy facilitates effective and dependable management of
    IaC processes.
  prefs: []
  type: TYPE_NORMAL
- en: By integrating DevOps into the CI/CD pipeline, organizations can create a more
    holistic, efficient, and collaborative environment. This not only accelerates
    the pace of innovation and delivery but also significantly enhances product quality
    and customer satisfaction, positioning the organization competitively in an ever-evolving
    digital landscape.
  prefs: []
  type: TYPE_NORMAL
- en: In this model, the traditional roles of deployment and operations are transferred
    from the operations team to the development team of the application. DevOps integrates
    software **development** (**Dev**) with IT **operations** (**Ops**), aiming to
    reduce the overall system development life cycle. This integration facilitates
    frequent delivery of features, fixes, and updates, ensuring they align closely
    with business goals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some key advantages of adopting DevOps:'
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced collaboration between the development and operations teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improvement in the quality of the products developed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An increase in the frequency of releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reduction in the time needed to bring new features to market
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lower costs in design, development, and operational processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduced **mean time to recovery** (**MTTR**), enhancing system resilience and
    minimizing the impact of disruptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The evolution from DevOps to GitOps represents a natural progression in the
    quest for more efficient and reliable software development and operations practices.
    While DevOps focuses on breaking down the barriers between software development
    and operations while fostering a culture of collaboration and continuous improvement,
    GitOps takes this a step further by centering the entire operational workflow
    around the Git version control system. GitOps leverages Git as the single source
    of truth for declarative infrastructure and application.
  prefs: []
  type: TYPE_NORMAL
- en: Reduced MTTR
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the MTTR refers to improving one of the key **DevOps Research and Assessment**
    (**DORA**) metrics, which is the average time it takes to recover from a failure
    or outage in a system or service. This metric is crucial in understanding and
    enhancing the resilience and reliability of IT operations. By reducing the MTTR,
    organizations can ensure that their systems are restored more quickly after a
    disruption, minimizing the impact on users and business operations. This improvement
    is often achieved through more effective incident management processes, automation,
    and better preparedness for handling failures.
  prefs: []
  type: TYPE_NORMAL
- en: This approach not only streamlines deployment and management processes but also
    enhances transparency, accountability, and reproducibility.
  prefs: []
  type: TYPE_NORMAL
- en: The transition from DevOps to GitOps is driven by the need for greater automation,
    consistency, and security in managing complex and dynamic cloud-native environments.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps automates the deployment process using Git’s powerful version control
    capabilities, which means every change in the system can be tracked, reversed,
    and subject to peer review processes, just like code changes in software development.
    This shift brings the rigor and precision of software development to the world
    of operations, significantly reducing the potential for human error and improving
    the stability and security of production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, GitOps aligns perfectly with the containerized and microservices-oriented
    architectures that are prevalent in modern cloud environments, enabling faster
    and more efficient deployment pipelines that are crucial for businesses to remain
    agile and responsive in a rapidly changing digital landscape.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections of this chapter, we will delve deeper into the benefits
    of adopting GitOps. We will explore why it should be used, its integration with
    Kubernetes, and other tools such as Argo CD and Flux CD.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamentals of GitOps and the advantages of adopting it for platform engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DevOps emerged as a response to these silos, blending the roles of development
    and operations. It extended the principles of CI/CD to include a cultural shift
    toward collaboration, aiming to break down the barriers between developers and
    IT operations. The emphasis was on a holistic approach to the software life cycle,
    ensuring that both development and operational considerations were integrated
    from the start. DevOps embraced practices such as IaC and monitoring, fostering
    a more responsive and agile environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitOps, a more recent innovation, builds upon these foundations but introduces
    a significant shift: it takes the principles of DevOps and CI/CD and centralizes
    them around the Git repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a GitOps story, as illustrated in *Figure 1**.5*, everything begins with
    a Git repository, where the entire state of a system – code, configuration, environment
    settings, and even documentation – is stored and versioned. This approach allows
    for a high level of transparency, traceability, and audibility as every change
    is recorded and can be traced back to a commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Example of a GitOps pipeline embracing DevOps](img/B22100_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Example of a GitOps pipeline embracing DevOps
  prefs: []
  type: TYPE_NORMAL
- en: In GitOps, Git is not just a version control system; it’s the single source
    of truth for both application code and infrastructure configuration. This approach
    leverages the strengths of Git – such as version control, collaboration features,
    and the pull request workflow – to manage the entire deployment and operational
    process. GitOps emphasizes a **declarative approach**, where the desired state
    of the system is defined in Git and automated processes ensure that the actual
    state aligns with this desired state.
  prefs: []
  type: TYPE_NORMAL
- en: Everything from application code to infrastructure configuration is stored in
    Git repositories. This centralization not only simplifies the process of managing
    and tracking changes but also ensures consistency and transparency across all
    stages of development and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: The workflow in a GitOps scenario is elegantly automated and highly efficient.
    Developers submit changes via pull requests, which then undergo automated tests
    and reviews. Once approved, these changes are automatically deployed to production
    environments, aligning with the principles of CI/CD seen previously.
  prefs: []
  type: TYPE_NORMAL
- en: Pull request
  prefs: []
  type: TYPE_NORMAL
- en: A **pull request** is a feature in version control systems, particularly in
    Git, that facilitates collaboration in software development. Acting as a checkpoint,
    a pull request allows developers to inform others about changes they’ve pushed
    to a repository on a hosting service such as GitHub or GitLab. After pushing a
    branch with updates, a developer can initiate a pull request to merge these changes
    into the main branch. This process invites review and discussion on the proposed
    changes, ensuring that code is vetted and refined collaboratively before being
    integrated, thus enhancing code quality and shared understanding among team members.
  prefs: []
  type: TYPE_NORMAL
- en: This automation not only streamlines the deployment process but also significantly
    reduces the chances of human error. Moreover, because the entire system state
    is version-controlled, rolling back to a previous state in case of an issue is
    straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: This process, often termed **Git-centric**, empowers teams to manage infrastructure
    and applications with the same tools and processes used in code development, bringing
    a unified approach to software delivery.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps represents a significant evolution from traditional practices that leverages
    the strengths of Git, automation, and declarative models. This methodology provides
    a framework for realizing the results of DevOps culture, offering an agnostic
    approach that can be implemented with various tools, such as Kubernetes and CI/CD
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The GitOps Working Group, with its defined set of GitOps principles, underpins
    this approach, emphasizing the importance of declarative configurations, versioned
    and immutable states, automatic pulling, and continuous reconciliation.
  prefs: []
  type: TYPE_NORMAL
- en: As we explore this further, these fundamentals will be illustrated with practical
    examples, showcasing the real-world impact and advantages of adopting a GitOps
    mindset in platform engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Why GitOps?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adopting GitOps for platform engineering brings a multitude of advantages,
    reshaping how teams interact with infrastructure and applications. This methodology
    leverages the strengths of Git, automation, and declarative configurations, providing
    a robust framework for managing complex systems. Here are some of the key benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative and immutable nature**: GitOps focuses on declaring the desired
    state of systems rather than detailing imperative scripts. It adopts an immutable
    infrastructure approach where changes are made by replacing resources rather than
    modifying existing ones, enhancing consistency and stability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated synchronization**: Central to GitOps is automatically synchronizing
    the system state with the configurations described in Git to cover the full life
    cycle of infrastructure and applications, including deployment, updates, scaling,
    and recovery.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pull request workflow integration**: Operational processes in GitOps are
    deeply integrated with a pull request workflow, embodying the philosophy of treating
    everything as code. This integration facilitates code reviews, collaborative discussions,
    and shared knowledge and responsibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous feedback and monitoring**: GitOps emphasizes continuous monitoring
    to detect and remedy any divergence from the desired state, promoting ongoing
    system maintenance and improvement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced efficiency and productivity**: By automating platform engineering
    aspects, GitOps reduces manual efforts and human errors, allowing teams to focus
    more on innovation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved consistency and reliability**: Using Git as the single source of
    truth with declarative configurations ensures consistent and reliable infrastructure
    across different environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Faster recovery and rollback**: GitOps enables quick rollbacks to previous
    states for enhanced system resilience and faster recovery from failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaboration and transparency**: The methodology encourages collaborative
    platform engineering, with peer reviews and discussions improving knowledge sharing
    and transparency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Streamlined audits and compliance**: All changes are tracked in Git, simplifying
    auditing and facilitating compliance with regulatory requirements and internal
    policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability and flexibility**: GitOps scales efficiently with organizational
    needs and adapts to various types of infrastructure, including cloud, on-premises,
    and hybrid environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced security**: The use of pull requests and code reviews adds an extra
    layer of security, ensuring thorough scrutiny of changes to infrastructure and
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified onboarding and knowledge sharing**: The Git repository provides
    a clear overview of the system’s current state, aiding in onboarding new team
    members and fostering an environment of accessible knowledge sharing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous improvement and adaptation**: The inherent feedback loops and
    monitoring in GitOps enable teams to iteratively improve their systems and adapt
    to changing requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adopting GitOps presents various challenges for a company that can impact its
    transition to this methodology. Firstly, there’s the learning curve and the need
    for training in specific tools such as Kubernetes, Helm, or Argo CD, which can
    temporarily reduce productivity. Implementing GitOps also requires a cultural
    shift toward rigorous code management and CI/CD practices. The initial setup and
    integration process can be complex and time-consuming, necessitating significant
    investments in time and resources.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, organizing the Git repository structure efficiently is crucial
    as it directly affects the manageability and scalability of deployments. Mismanagement
    here can lead to operational inefficiencies and increased errors. Another critical
    aspect is secrets management; GitOps workflows require sensitive data to be handled
    carefully to prevent security breaches. Proper strategies must be implemented
    to securely store, access, and manage secrets within the GitOps processes to ensure
    that automated deployments remain secure and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we highlighted the significant advantages and challenges of
    adopting GitOps for platform engineering. This methodology capitalizes on the
    strengths of Git, automation, and declarative configurations to offer a robust
    framework for managing complex systems. The next section will introduce the integration
    between GitOps, IaC, and Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: The integration between GitOps, IaC, and Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll delve into the intricate integration of GitOps, IaC,
    and Kubernetes, along with key tools such as Argo CD and Flux CD. We’ll explore
    how this cohesive blend enhances cloud-native operations, streamlining deployment
    processes and bolstering security, thereby revolutionizing the way infrastructure
    is managed and applications are deployed in modern software development environments.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps and IaC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IaC involves managing and provisioning infrastructure via code rather than manual
    procedures. This approach involves creating configuration files that detail your
    infrastructure requirements, thus simplifying the process of modifying and disseminating
    these configurations. IaC guarantees consistent provisioning of the same environment
    each time, and at the same time, IaC transforms configuration specifications into
    coded documentation, improving configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: This approach helps avoid undocumented and spontaneous configuration alterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitOps extends the familiar Git version control system to infrastructure and
    deployment management and aligns closely with the principles of IaC. This integration
    allows developers to manage infrastructure configuration and code deployment as
    they would their software development process, bringing numerous advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accelerated production time**: Quicker infrastructure provisioning with reduced
    human error leads to more predictable outcomes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template-based reusability**: Use an IaC configuration file as a template,
    providing a baseline for further related configurations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform deployment**: Achieve consistent infrastructure deployment, avoiding
    minor discrepancies that could lead to significant future issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traceability and auditability**: Integrating IaC with a code repository for
    source tracking offers a detailed history of changes, including versioning and
    audit trails that identify who made changes and when'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced organizational knowledge**: Versioning documents the rationale behind
    changes, creating a valuable resource for both new and existing employees'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved disaster recovery**: IaC ensures the ability to rapidly reconstruct
    environments in the event of a failure, minimizing downtime and business disruption'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitOps and Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GitOps and Kubernetes ([https://kubernetes.io/docs/concepts/overview/](https://kubernetes.io/docs/concepts/overview/))
    represent a powerful combination in the realm of modern software development and
    infrastructure management. Kubernetes, an open source platform for automating
    the processes of deployment, scaling, and operations for application containers
    across clusters of hosts, provides a robust foundation for managing containerized
    applications at scale. GitOps, on the other hand, is an operational framework
    that applies the principles of Git – version control, collaboration, and compliance
    – to infrastructure automation. When combined, GitOps and Kubernetes offer a highly
    efficient, scalable, and reliable system for managing complex applications and
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes has become essential for orchestrating containerized applications,
    offering capabilities such as automated rollouts and rollbacks, service discovery
    and load balancing (with its ability to assign IP addresses to Pods and services
    for load balancing), storage orchestration, secret and configuration management
    without exposing secrets or requiring Docker image rebuilds, and self-healing
    mechanisms such as restarting failed containers and rescheduling Pods when node
    issues occur.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Kubernetes facilitates horizontal scaling based on CPU usage and
    operates declaratively. These features continue to evolve with each Kubernetes
    release.
  prefs: []
  type: TYPE_NORMAL
- en: The fusion of GitOps with Kubernetes significantly quickens and improves the
    efficiency of deployment processes. This combination promotes more frequent deployments
    by enabling CD automation and integrating essential feedback and control systems.
    By using Git’s declarative definitions, developers can employ well-known workflows,
    which simplifies the ability to create new development or test environments and
    deploy new features to a cluster. Consequently, this leads to an increased daily
    rate of changes, accelerating the delivery of new features and functionalities
    to end users.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps also empowers teams to become more self-sufficient. Traditionally, development
    teams relied on operations teams for deploying changes in production. GitOps shifts
    this dynamic, allowing development teams to be less dependent on platform and
    operations teams for deploying and managing code and configuration changes in
    production. Simply committing changes to the Git repository and merging pull requests
    can trigger the rest of the process through GitOps tools. This self-service nature
    enhances efficiency and strategic capability.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps enhances the management of deployments and infrastructure by utilizing
    Git as the source of truth for **declarative configurations**. In a declarative
    system, the focus is on defining the desired outcome rather than the steps to
    achieve it. This approach contrasts with the imperative approach, which involves
    specifying a sequence of steps and often adds extra workload for operators. Within
    GitOps, every component of the environment can be coded and declared in the Git
    repository. Once changes are made and committed to Git, the system automatically
    processes these declarations to create or update the necessary objects.
  prefs: []
  type: TYPE_NORMAL
- en: This **seamless integration** with the declarative nature of Kubernetes is where
    the power of GitOps truly shines. Kubernetes operates on a **reconciliation loop**
    that continuously adjusts the actual state of the cluster to match the desired
    state defined by its configurations. When discrepancies between the current and
    desired states are detected, Kubernetes takes automatic action to reconcile these
    differences. This could involve creating, updating, or deleting resources to ensure
    the cluster’s configuration matches what has been defined in the Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: Together, the combination of GitOps and the Kubernetes reconciliation loop provides
    a robust framework for automated system management. This ensures that all system
    components are deployed consistently according to the precise configurations defined
    in Git, adhering to a fully declarative approach that streamlines operations,
    enhances reliability, and maintains consistency across development, staging, and
    production environments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Observability** is another crucial aspect of GitOps in a Kubernetes environment.
    It involves continuously monitoring the actual state present in the cluster and
    comparing it to the desired state. GitOps aids in measuring and monitoring what’s
    running on the cluster, alerting teams to any discrepancies. Modern GitOps tools
    come equipped with monitoring and notification capabilities to support this function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a **compliance and auditing** perspective, GitOps offers significant advantages.
    With Git as the sole source of truth, auditing becomes straightforward: auditors
    can assess the desired state by examining the source code repository and verify
    the current state by reviewing the underlying infrastructure provider and the
    Kubernetes cluster state. This simplifies compliance and auditing processes across
    various domains.'
  prefs: []
  type: TYPE_NORMAL
- en: For organizations that use *multiple Kubernetes clusters* for different business
    and team needs, managing these clusters and maintaining consistent configuration
    and security policies is a significant challenge. GitOps addresses this by allowing
    GitOps agents running across these clusters to manage everything on behalf of
    the Ops team, making it an ideal solution for multi-cluster configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disaster recovery** (**DR**) is essential for organizations to recover quickly
    from incidents that disrupt business operations, with the primary aim being to
    rapidly restore critical systems and IT infrastructure. From the GitOps perspective,
    DR primarily handles configuration management, not data recovery. This distinction
    is crucial because, while configurations are saved in Git, actual data is not.
    Tools such as Git are useful for version control of configurations but do not
    aid in data recovery. For example, if a database is deleted, Git cannot assist
    in its recovery; therefore, separate data recovery strategies are necessary and
    specifically designed for restoring lost data.'
  prefs: []
  type: TYPE_NORMAL
- en: In the Kubernetes ecosystem, the adoption of GitOps for automating infrastructure
    setup is on the rise. This includes the creation of deployments, services, and
    various Kubernetes entities. DevOps and **site reliability engineering** (**SRE**)
    teams are increasingly turning to GitOps for managing all infrastructure configuration
    files as code. This approach leverages the inherent IaC characteristic of GitOps.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, GitOps enhances *security* protocols. It uses sophisticated cryptographic
    methods in Git for monitoring and managing changes, and it can also authenticate
    changes to confirm authorship and source. This practice ensures a securely defined
    intended state of the cluster. In the event of a security breach, the immutable
    and auditable nature of Git’s source of truth is instrumental in reconstructing
    a system separate from the compromised one, thereby minimizing downtime and boosting
    the efficiency of incident responses.
  prefs: []
  type: TYPE_NORMAL
- en: The practice of separating responsibilities in software packaging and release
    to production further adheres to the principle of least privilege, which diminishes
    the likelihood and severity of security breaches and offers a smaller attack surface.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps facilitates this by ensuring that the entire infrastructure environment
    and components are defined declaratively in the Git repository. In the event of
    a disaster, recovery becomes a matter of reapplying the configuration files from
    Git to quickly restore the ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes and Argo CD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Argo CD, a GitOps CD for Kubernetes ([argo-cd.readthedocs.io](http://argo-cd.readthedocs.io)),
    is a declarative tool for continuous delivery specifically designed for Kubernetes.
    It functions as a standalone solution or can be integrated into your existing
    CI/CD pipeline to efficiently deploy necessary resources across your Kubernetes
    clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating GitOps and Kubernetes using Argo CD provides a streamlined approach
    for managing cloud-native applications and jobs on Kubernetes. Argo CD, part of
    the Argo project family, offers a suite of tools, including Workflows, Events,
    and Rollouts, that enhance Kubernetes-native application delivery. This becomes
    particularly relevant for organizations transitioning to containerized environments
    and Kubernetes deployments, where Argo CD can act as a comprehensive solution.
  prefs: []
  type: TYPE_NORMAL
- en: In large-scale deployments typical of big enterprises with numerous developers
    and a multitude of microservices, the GitOps methodology shines. However, it often
    necessitates supplementary tools and services for effective implementation. It’s
    not practical for each team in such an organization to operate independently and
    manage its Kubernetes cluster. A more efficient strategy is a centralized platform
    for operating and maintaining multi-tenant clusters. This setup gives teams the
    autonomy to manage their workloads within these clusters, while still providing
    centralized oversight and maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Argo CD is instrumental in facilitating this centralized approach to cluster
    management, promoting the adoption of GitOps. The following are some key factors
    to consider if you want to create an effective GitOps strategy in Kubernetes with
    Argo CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User onboarding**: Simplifying the onboarding process is crucial. Centralizing
    the installation, setup, and maintenance of deployment operators can ease the
    process of transitioning multiple microservices to Kubernetes, rather than placing
    this burden on individual teams. Incorporating **single sign-on** (**SSO**) is
    particularly beneficial in systems with a large user base, streamlining the introduction
    of new users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-tenancy and management**: In environments with multiple tenants, users
    need secure and flexible access to resources. Kubernetes’ **role-based access
    control** (**RBAC**) system is a powerful feature but might not suffice for managing
    numerous clusters. Argo CD enhances this with additional access control features,
    integrating seamlessly with SSO providers and facilitating access to multiple
    clusters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observability**: A key feature of an effective CD tool is enabling developers
    to monitor and track the state of their applications. Argo CD’s user-friendly
    interface provides detailed insights into an application’s configuration, such
    as sync status with Git, specific out-of-sync elements, and any operational issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, we will explore Flux CD, a tool that, when integrated
    with Kubernetes, enables scalability and ensures consistent environments across
    various types of deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes and Flux CD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flux ([fluxcd.io](http://fluxcd.io)) is an open and extensible CD solution for
    Kubernetes and represents a critical component in the modern DevOps ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, Alexis Richardson, CEO of Weaveworks, has announced
    on LinkedIn that the company is facing economic challenges and will be closing
    its doors and shutting down commercial operations. Weaveworks will be collaborating
    with a financial trustee, to be announced soon, to manage the closure process.
    This decision comes despite the company generating significant revenue and expanding
    its customer base, highlighting the financial volatility and strategic challenges
    faced in maintaining its operations. The original announcement can be found here:
    [https://www.linkedin.com/posts/richardsonalexis_hi-everyone-i-am-very-sad-to-announce-activity-7160295096825860096-ZS67/](https://www.linkedin.com/posts/richardsonalexis_hi-everyone-i-am-very-sad-to-announce-activity-7160295096825860096-ZS67/).'
  prefs: []
  type: TYPE_NORMAL
- en: As a GitOps tool, Flux ensures that the state of manifests in a Git repository
    is consistently synchronized with what is running in a Kubernetes cluster. GitOps,
    far from being just another tool, offers a method for developers to manage operational
    workflows in Kubernetes using Git. This approach emphasizes using a version-controlled
    system such as Git to deploy applications in Kubernetes, allowing developers to
    directly push code into production. Changes can easily be tracked and reverted
    if necessary, bolstering the reliability of deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the main features of Flux CD:'
  prefs: []
  type: TYPE_NORMAL
- en: Automated synchronization between a version control repository and a cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instant reflection of repository changes in the cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct code deployment into production from repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version-controlled configuration, ensuring all configurations are up to date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disaster recovery capabilities, enabling new clusters to be set up with identical
    configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the context of Kubernetes, a robust container orchestration platform, Flux
    CD plays an instrumental role. Kubernetes excels in automating and simplifying
    application deployment and management, particularly in scaling and maintaining
    consistent environments across diverse deployments. Flux CD, adhering to GitOps
    principles, introduces a layer of automation and security by continuously synchronizing
    application and infrastructure states with configurations stored in a Git repository.
    This ensures that the actual state aligns with the desired state in a secure and
    controlled manner. The synergy between Kubernetes and Flux CD offers several key
    benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated deployments**: Flux CD’s automated updates and configurations are
    committed to the Git repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability and reliability**: Kubernetes’ prowess in handling containerized
    applications is complemented by Flux CD’s consistency in configurations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced security**: Flux CD’s use of Git as the single source of truth adds
    an extra security layer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operational efficiency**: The integration streamlines operations, reducing
    manual intervention and increasing efficiency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, the combination of Kubernetes and Flux CD provides a comprehensive
    solution for modern software deployment and management. Their integration enhances
    automation, scalability, security, and efficiency, marking them as indispensable
    tools in cloud-native technologies and DevOps practices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided an in-depth introduction to GitOps, exploring its transformative
    impact on software development and operations. We began by contrasting GitOps
    with traditional CI/CD and DevOps methodologies, highlighting its unique approach
    and advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we covered the history and evolution of deployment strategies that led
    to GitOps. Key principles such as Git centralization, the declarative approach,
    automated synchronization, and continuous feedback were discussed, emphasizing
    GitOps’ role in enhancing efficiency, consistency, and collaboration in platform
    engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we delved into GitOps’ integration with tools such as Kubernetes,
    showcasing its scalability and security advantages in modern cloud environments.
    We concluded by underscoring the significance of adopting GitOps for its robust
    framework and adaptability to evolving technological landscapes.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B22100_02.xhtml#_idTextAnchor027), we’ll dive into the practicalities
    of GitOps in cloud-native environments, examining its seamless integration with
    Kubernetes, the architecture of lightweight Kubernetes distributions, and the
    design of cloud-native CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Argo CD – Declarative GitOps CD for* *Kubernetes*: [https://argo-cd.readthedocs.io/en/stable/](https://argo-cd.readthedocs.io/en/stable/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Flux* *CD*: [https://fluxcd.io/](https://fluxcd.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
