- en: '*Chapter 5*: Configuring and Enhancing Kubernetes Networking Services'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to develop a configuration management
    solution for Kubernetes with Ansible. After completing that solution, you are
    now ready to build the upper layer of the Kubernetes cluster, and deploy the networking
    services and add-ons on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about enhancing and fine-tuning the essential
    networking services and add-ons, such as CoreDNS, ExternalDNS, and Ingress Controller.
    We will not dig into the basic concepts of Kubernetes networking. Topics such
    as Kubernetes networking models, inter-pod communication, intra-pod communication,
    cluster services, and basic load balancing will not be covered, as in this book
    we are more concerned with bringing the cluster to a state of production readiness
    rather than digging into the basics, which you can learn about in introductory
    Kubernetes books.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on bringing the cluster networking closer to
    the production readiness by reconfiguring the pre-deployed services, and also
    deploying additional network services that are essential to Kubernetes clusters.
    You will learn the characteristics of Kubernetes networking best practices, as
    well as how to create deployment templates for the Kubernetes networking services
    and fine tune them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing networking production readiness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Kube Proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Amazon CNI plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring CoreDNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring ExternalDNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring NGINX Ingress Controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the cluster's network services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying the cluster's resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter is located at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter05](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3rmhLdX](https://bit.ly/3rmhLdX)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing networking production readiness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the beginning of Docker and the containerization era, there have been
    different challenges and complexities associated with handling and managing containers
    networking. Over the past few years, industry leaders and community contributors
    have worked on solutions to tackle and solve these challenges, and the efforts
    are still in progress.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple container networking models, network plugins, and tools in
    the Kubernetes ecosystem that support either mainstream use cases or specific
    corner cases. You can learn more about these projects and tools at the CNCF cloud
    native network landscape at [https://landscape.cncf.io/category=cloud-native-network&format=card-mode](https://landscape.cncf.io/category=cloud-native-network&format=card-mode).
    In this chapter, we will stick to the services that are essential to the general
    Kubernetes use cases, and their production readiness, such as CoreDNS, NGINX Ingress
    Controller, and ExternalDNS.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, you will learn how to enhance and configure the pre-deployed
    network components that are usually shipped with AWS **Elastic Kubernetes Service**
    (**EKS**) and how to improve them. This is aside from deploying networking services
    and add-ons that are essential to networking functionality, operations, and reliability.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the network services and add-ons that we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kube-proxy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon VPC K8s CNI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CoreDNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ExternalDNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NGINX Ingress Controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each of these components, we will use the Ansible configuration management
    solution to deploy and configure them by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining configuration variables under the cluster's Ansible `group_vars` directory,
    available at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter05/ansible/group_vars/all](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter05/ansible/group_vars/all),
    and the `inventories` directory, available at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter05/ansible/inventories/packtclusters/group_vars/override](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter05/ansible/inventories/packtclusters/group_vars/override)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Developing a deployment template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an Ansible task
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding an entry to the cluster playbook
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are parts of the code and templates that do not introduce new concepts
    or change the configuration, we will not include their source code in the chapter
    text. Instead, you can view them in the book's GitHub source code repository at
    [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter05](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Kube Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`kube-proxy` is an agent service that runs on each node in the cluster to create,
    update, and delete network rules on the nodes, usually through the use of Linux
    iptables. These network rules allow inter-pod and intra-pod communication inside
    and outside the Kubernetes cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: Irrespective of whether you use a self-managed Kubernetes cluster or a hosted
    one, you need to control the configuration options that you pass to `kube-proxy`.
    As we are using EKS, `kube-proxy` comes pre-deployed with the cluster, which leaves
    us without a full control over its configuration, and we need to change this.
  prefs: []
  type: TYPE_NORMAL
- en: During the cluster's lifetime, you need to control the periodic updates of `kube-proxy`
    and include them within the cluster's updates' pipeline. Also, you need to optimize
    its performance by controlling the runtime parameters, including `--iptables-sync-period`,
    `--iptables-min-sync-period`, and `--proxy-mode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn about the remainder of the configuration options, please check the
    following link: [https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/#options](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/#options).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter05/ansible/templates/kube-proxy/kube-proxy.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter05/ansible/templates/kube-proxy/kube-proxy.yaml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the Ansible template and configuration for `kube-proxy`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the configuration variables and add them to the `group_vars` directory
    in this path: `ansible/group_vars/all/kube-proxy.yaml`. The basic configuration
    contains the image and its tag, which are useful for keeping track of the `kube-proxy`
    version that is deployed to your cluster, and for controlling its upgrades:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the deployment template for the `kube-proxy` DaemonSet in the following
    path: `ansible/templates/kube-proxy/kube-proxy.yaml`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet is part of this template, and the only code lines
    that you need to modify are where the `image` and `command` specs are defined:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following part of the template, you can define and fine-tune the `kube-proxy`
    runtime options and pass them to the container entry point command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following are notable configuration options that you need to consider for
    `kube-proxy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--proxy-mode`: by default, `kube-proxy` uses the `iptables` mode, as it is
    hardened on production and is faster for small-sized clusters. On the other hand,
    the `ipvs` mode is recommended if you have a scaling cluster with services numbering
    above 5,000, as the `ipvs` implementation ensures superior performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--kube-api-qps`: this configuration option limits the `kube-proxy` and hit
    `kube-apiserver`. The default value of this option is `5`, but it is recommended
    to increase it to `10` if you expect your cluster to run above 5,000 services.
    However, the more QPS that `kube-proxy` sends to `kube-apiserver`, the busier
    it will become, and this could affect the performance of `kube-apiserver`. You
    should select the QPS limit based on the cluster size (number of running services)
    and your control plane capacity, so your cluster can serve all `kube-proxy` requests
    in a timely manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--iptables-sync-period`: This option defines the maximum time interval when
    `iptables` rules are refreshed. By default, it is set to `30s`, although it is
    recommended to decrease this to `20s` for small clusters. The cluster admin needs
    to decide the appropriate time interval and weigh between the conflicting priorities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's assume you decrease the interval to `1s`. This means that `kube-proxy`
    needs to run the sync process every `1s`, which means an increased load on the
    worker nodes where `kube-proxy` is running, while also rendering `iptables` busy
    and blocking other operations on them. On the other hand, if you increase the
    sync period and run the sync process less frequently, this could result in pods
    being out of iptables sync for a fraction of time, which may lead to loss of transactions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are other options available that handle configurations for `ipvs`, `conntrack`,
    `config`, and `metrics`. However, you should be careful whenever you modify any
    of these, and if you do decide to modify them, you have to deploy the changes
    to a non-production cluster to examine the performance prior to promotion to production.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete list of `kube-proxy` configuration options, please refer to the
    Kubernetes official documentation at [https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Amazon CNI plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kubernetes, the **Container Network Interface** (**CNI**) provides a specification
    and framework for writing container network plugins to manage container networking,
    including pod communication and **IP Address Management** (**IPAM**). In the context
    of this book, we will not go into the details of the CNI plugins and how they
    work. What does concern us is how to make the best use of the CNI plugin, and
    how to configure it properly.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple CNI plugins that have been battle-tested over the years.
    Some of these satisfy the needs of general use cases, such as Calico, which is
    a highly recommended CNI plugin, while there are other CNI plugins that lean toward
    solving specific use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The list of production tested CNI plugins includes Calico, Cilium, Azure CNI,
    Contiv, Flannel, Weave Net, and AWS CNI. The list goes on. You can get a comprehensive
    list of the supported CNI plugins and their features from the Kubernetes official
    documentation at [https://kubernetes.io/docs/concepts/cluster-administration/networking/](https://kubernetes.io/docs/concepts/cluster-administration/networking/).
  prefs: []
  type: TYPE_NORMAL
- en: For the clusters that we provision in this book, we will use the AWS CNI plugin
    (**amazon-vpc-cni-k8s**) because it is the default for EKS, and it is developed
    to cover the general networking uses cases to ensure that Kubernetes works smoothly
    with AWS.
  prefs: []
  type: TYPE_NORMAL
- en: The AWS CNI plugin comes pre-deployed to the cluster with a default configuration
    in place. This could be sufficient for simple clusters; however, we need to take
    full control over the configuration, so we decided to overwrite its DaemonSet
    and add it to the cluster's Ansible configuration for easier control.
  prefs: []
  type: TYPE_NORMAL
- en: During the lifetime of the cluster, you need to control the periodic updates
    to `amazon-vpc-cni-k8s` and include them within the cluster's updates' pipeline.
    Also, you will need to optimize its performance by adjusting the configuration
    variables that are passed to it, such as `MINIMUM_IP_TARGET`, `WARM_IP_TARGET`,
    and `AWS_VPC_ENI_MTU`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the other CNI configuration options, please check this
    link: [https://docs.aws.amazon.com/eks/latest/userguide/cni-env-vars.html](https://docs.aws.amazon.com/eks/latest/userguide/cni-env-vars.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When you redeploy the updated `amazon-vpc-cni-k8s` DaemonSet into your cluster,
    the CNI pods will get restarted. The updated pods are rolled out one after the
    other, but this still causes short periods of CNI plugin unavailability, which
    may be noticeable in the case of a busy cluster.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter05/ansible/templates/cni/amazon-k8s-cni.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter05/ansible/templates/cni/amazon-k8s-cni.yaml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the Ansible template and configuration for `amazon-vpc-cni-k8s`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the configuration variables and add them to the `group_vars` directory
    in this path: `ansible/group_vars/all/cni.yaml`. The basic configuration contains
    the image and its tag, which are useful for keeping track of the `amazon-vpc-cni-k8s`
    version that is deployed to your cluster, and for controlling its upgrades.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two important configuration values for cluster performance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- `MINIMUM_IP_TARGET`, which is important for pre-scaling as it specifies the
    number of minimum IP addresses to allocate for pod assignment on the node'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- `WARM_IP_TARGET`, which is important for dynamic scaling as it specifies
    the number of free IP addresses that the `ipamD` daemon should attempt to keep
    available for pod assignment on the node.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Both of these variables together ensure that sufficient IP addresses are available
    for new pods, which improves the start-up time of pods and enhances cluster uptime
    and recovery time. You can specify the values of these variables based on the
    estimated number of pods running in the cluster, and the number during spikes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the deployment template for the `amazon-vpc-cni-k8s` DaemonSet in this
    path: `ansible/templates/cni/amazon-k8s-cni.yaml`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet is part of this template, and the only code lines
    that you need to modify are where the `image` and `env` specs are defined:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can configure other options for `amazon-vpc-cni-k8s` by adding them to the
    container environment variables, as in the previous code snippet for the container
    section in the DaemonSet template.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring CoreDNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes used to have `kube-dns` as its default cluster DNS service, but starting
    from version 1.11, it uses CoreDNS. Also, it gets pre-deployed by most of the
    managed Kubernetes offerings, including EKS, that we use in this book.
  prefs: []
  type: TYPE_NORMAL
- en: For the other Kubernetes managed services that still use `kube-dns`, such as
    GKE, we recommend referring to the official documentation of `kube-dns`.
  prefs: []
  type: TYPE_NORMAL
- en: 'CoreDNS is very flexible as it is modular and pluggable. It has a rich set
    of plugins that can be enabled to enhance DNS functionalities. This is why it
    is powerful and generally preferred over `kube-dns` and other Kubernetes DNS solutions.
    To learn more about the supported plugins, please refer to the following list:
    [https://coredns.io/plugins/](https://coredns.io/plugins/).'
  prefs: []
  type: TYPE_NORMAL
- en: During the cluster's lifetime, you need to control CoreDNS configuration as
    code, its periodic updates, and include all of this within the cluster's deployment
    pipeline. Also, you will need to optimize your cluster DNS performance and add
    extra DNS functionalities by enabling CoreDNS plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is recommended to tune the CoreDNS resource quota for CPU and memory to
    improve cluster DNS performance, especially in the case of a heavily scaling cluster.
    For detailed resource configuration and scaling, please check this link: [https://github.com/coredns/deployment/blob/master/kubernetes/Scaling_CoreDNS.md#](https://github.com/coredns/deployment/blob/master/kubernetes/Scaling_CoreDNS.md#).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can find this section's complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter05/ansible/templates/core-dns/core-dns.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter05/ansible/templates/core-dns/core-dns.yaml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the Ansible template and configuration for `coredns`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the configuration variables and add them to the `group_vars` directory
    in this path: `ansible/group_vars/all/core-dns.yaml`. The basic configuration
    contains the image and its tag, which are useful for keeping track of the CoreDNS
    version that is deployed to your cluster, and for controlling its upgrades.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The default IP of the cluster DNS is usually `172.20.0.10` unless you decide
    to change it. You can specify the number of CoreDNS pods across the cluster by
    setting the number of replicas:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the deployment template for the CoreDNS pods in this path: `ansible/templates/core-dns
    /core-dns.yaml`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet is part of this template, and the notable configuration
    here in this deployment template is the number of CoreDNS replicas and the Docker
    image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code snippet, you configure the CoreDNS image and tag:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code snippet, you specify the `ConfigMap` CoreDNS, where you
    can modify `Corefile` to enable additional plugins and fine-tune their configurations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the previous code for the `ConfigMap`, we added extra plugins that help
    to improve the cluster''s DNS performance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ready`: An HTTP endpoint on port `8181` will return `200 OK`, when all plugins
    that are able to signal readiness have done so.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loop`: This plugin halts the CoreDNS process if a forwarding loop is detected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reload`: This plugin automatically reloads `Corefile` whenever it gets changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loadbalance`: This plugin randomizes the order of DNS records in the answers
    and is a round-robin DNS load balancer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autopath @kubernetes`: This plugin follows the chain of search path elements
    and return the first reply that is not `NXDOMAIN`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache`: This plugin enables a frontend cache. It is enabled by default; however,
    it has `30` seconds as a default caching duration, but we recommend increasing
    this value to `300` seconds to achieve better performance in the case of large
    clusters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I encourage you to use the preceding CoreDNS plugins, and also check the `plugins`
    directory, which could have other interesting and useful plugins that solve specific
    problems or provide options for your applications, here: [https://coredns.io/manual/plugins/](https://coredns.io/manual/plugins/).'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring ExternalDNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While CoreDNS serves as the internal DNS server for Kubernetes clusters, ExternalDNS
    is a Kubernetes add-on that is used to manage your cluster external DNS providers,
    including Route 53, AzureDNS, and Google Cloud DNS.
  prefs: []
  type: TYPE_NORMAL
- en: It makes Kubernetes deployments and services discoverable through public DNS
    services, such as Route 53\. It queries the Kubernetes API to retrieve a list
    of services and ingresses, and then it communicates with the public DNS and registers
    these records.
  prefs: []
  type: TYPE_NORMAL
- en: ExternalDNS allows you to control DNS records (via cloud DNS services such as
    AWS Route 53 or Google Cloud DNS) dynamically via Kubernetes services and ingresses.
  prefs: []
  type: TYPE_NORMAL
- en: ExternalDNS does not come pre-installed with the cluster, so you need to deploy
    it and specify its configuration, which includes its Docker image, the number
    of replicas to run, DNS record syncing and interval updates, the cloud provider
    type (that is, AWS, Azure, and so on), and the hosted zone ID (in the case of
    AWS Route 53).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter05/ansible/templates/external-dns/external-dns.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter05/ansible/templates/external-dns/external-dns.yaml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the Ansible template and configuration for ExternalDNS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the configuration variables and add them to the `group_vars` directory
    in this path: `ansible/group_vars/all/external-dns.yaml`. The basic configuration
    contains the image and its tag, which are useful for keeping track of the ExternalDNS
    version that is deployed to your cluster, and for controlling its upgrades.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, you specify the values for other configuration variables, including `log_level`,
    `provider`, `aws_zone_type`, `interval`, `route53_zone_type`, and `external_dns_replicas`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the deployment template for the ExternalDNS pods in this path: `ansible/templates/external-dns
    /external-dns.yaml`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following code snippet of the template, you configure the number of
    ExternalDNS replicas:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then you configure the ExternalDNS image and tag, in addition to the ExternalDNS
    runtime configuration variables, including `log-level`, `source`, `provider`,
    `aws-zone-id`, `interval`, `registry`, and `txt-owner-id`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For ExternalDNS to operate properly, it needs to access the Route 53 DNS resources.
    This is why you need to create the following IAM policy to allow ExternalDNS to
    list the hosted zones, list the DNS record sets, and change the DNS records:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you do not create the preceding IAM policy and attach it to the worker nodes
    or to the pod, then ExternalDNS will fail to operate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ExternalDNS can be configured to use the majority of DNS providers, including
    AzureDNS, Google Cloud DNS, CloudFlare, and DNSimple.
  prefs: []
  type: TYPE_NORMAL
- en: To get more details and detailed code samples on how to use ExternalDNS with
    your DNS provider and your Kubernetes deployments, please check the official documentation
    at [https://github.com/kubernetes-sigs/external-dns](https://github.com/kubernetes-sigs/external-dns).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring NGINX Ingress Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three main ways in which to expose Kubernetes services externally:
    NodePort, load balancers, and Ingress. In this section, we will focus on ingresses,
    as they fulfill the needs of the majority of the workloads and deployments on
    Kubernetes clusters.'
  prefs: []
  type: TYPE_NORMAL
- en: Ingress exposes TCP/IP L7 services (such as HTTP/HTTPS) and it routes traffic
    from outside the cluster to services within the cluster. Ingress controls traffic
    routing through a defined set of rules for each ingress resource and/or a global
    configuration for all ingress resources.
  prefs: []
  type: TYPE_NORMAL
- en: There are many configurations that an ingress can control, including giving
    services an external URL, SSL/TLS termination, session validity, and name-based
    virtual hosting. An ingress controller is the Kubernetes resource that is responsible
    for fulfilling the ingress.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular and battle-tested ingress is NGINX Ingress Controller. This
    is an ingress controller for Kubernetes that uses NGINX as a reverse proxy and
    load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: NGINX Ingress Controller does not come pre-installed with the cluster, so you
    need to deploy and configure it on your cluster, which includes its Docker image,
    the number of replicas to run, runtime arguments, and service and cloud load balancer
    specs.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter05/ansible/templates/ingress-nginx/ingress-nginx.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter05/ansible/templates/ingress-nginx/ingress-nginx.yaml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the Ansible templates and configuration for `ingress-nginx`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the configuration variables and add them to the `group_vars` directory
    in this path: `ansible/group_vars/all/ingress-nginx.yaml`. The basic configuration
    contains the images for `nginx-ingress-controller` and its webhook. This is useful
    for keeping track of the `ingress-nginx` version that is deployed to your cluster
    and for controlling its upgrades:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the template for the `ingress-nginx` deployment in this path: `ansible/templates/ingress-nginx/ingress-nginx.yaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code snippet, the deployment gets the value of the container''s
    image from the `ingress-nginx` `group_vars` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code snippet, you create a `ConfigMap` to configure `nginx-ingress`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code snippet, you create the service that is used to expose
    the `nginx-ingress` controller to the public internet. This is achieved by provisioning
    AWS `nginx-ingress` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After completing the creation of the networking services and add-ons with Ansible
    templates, you are ready to deploy them and apply the Ansible playbook to your
    cluster. In the next section, you will use the `packtclusters-prod1` cluster,
    which you created in the previous chapter, to apply all of these changes.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the cluster's network services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following instructions will deploy the Ansible playbook and configure your
    cluster with the networking services and add-ons configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the Terraform state and select the workspace by running the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute Terraform to apply the infrastructure we added in this chapter – the
    IAM policy and the policy attachment for ExternalDNS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then you should get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve and configure `kubeconfig` for the target cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `virtualenv` to install and execute Ansible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install Ansible, along with the prerequisite modules, `openshift`, `pyyaml`,
    and `requests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the Ansible playbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will get the following output following the successful execution of Ansible:![Figure
    5.1 – Ansible execution output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16192_05_001.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.1 – Ansible execution output
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the following `kubectl` command to get all the pods running in the
    cluster. This allows you to verify that the cluster configuration has been applied
    successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get the following output, which lists all the pods running in the
    cluster, including the new pods for the networking add-ons:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.2 – List of all pods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16192_05_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – List of all pods
  prefs: []
  type: TYPE_NORMAL
- en: Now you have completed the application of the cluster configuration as per the
    previous instructions and your cluster has all of the networking services and
    add-ons deployed and configured, ready for production workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying the cluster's resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, you should delete the `ingress-nginx` service to instruct AWS to destroy
    the NLB associated with the ingress controller. This step is required because
    terraform will fail to destroy this NLB because it has been created by Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can follow the rest of the instructions in the *Destroying the network
    and cluster infrastructure* section in [*Chapter 3*](B16192_03_Final_PG_ePub.xhtml#_idTextAnchor073),
    *Building and Provisioning Kubernetes Clusters*, to destroy the Kubernetes cluster
    and all related AWS resources. Please ensure that the resources are destroyed
    in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes cluster `packtclusters` resources
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cluster VPC resources
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Terraform shared state resources
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By executing the previous steps, all Kubernetes and AWS infrastructure resources
    should be destroyed and cleaned up ahead of the hands-on practice in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about Kubernetes networking components and
    services that make a cluster ready for production. You developed the templates
    and configuration as code for these services with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the fact that some of these components come pre-deployed with AWS EKS,
    you still need to fine-tune their configurations to fulfill your cluster requirements
    for scaling, availability, security, and performance. You also deployed additional
    add-ons and services, including ExternalDNS and NGINX Ingress Controller, that
    proved to be essential for Kubernetes' networking needs.
  prefs: []
  type: TYPE_NORMAL
- en: By using the Ansible configuration management solution that we introduced in
    the previous chapter, writing the Kubernetes manifests of these services becomes
    simple, scalable, and maintainable. We follow the same framework and steps to
    configure each service, and this is repeated for all services and add-on configurations
    that you will develop during this book.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covered the network production readiness for Kubernetes clusters,
    but there are relevant topics that we will cover in the forthcoming chapters,
    including network security, network policies, service mesh, and network service
    observability.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn in detail about Kubernetes security; the
    security best practices, tools, add-ons, and configuration that you need to deploy
    and optimize for production-grade clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for more information on the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Getting Started with Kubernetes – Third Edition* ([*Chapter 3*](B16192_03_Final_PG_ePub.xhtml#_idTextAnchor073),
    *Working with Networking, Load Balancers, and Ingress*): [https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering Kubernetes – Second Edition* ([*Chapter 10*](B16192_10_Final_PG_ePub.xhtml#_idTextAnchor215),
    *Advanced Kubernetes Networking*): [https://www.packtpub.com/application-development/mastering-kubernetes-second-edition](https://www.packtpub.com/application-development/mastering-kubernetes-second-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hands-On Kubernetes Networking [Video]: [https://www.packtpub.com/virtualization-and-cloud/hands-kubernetes-networking-video](https://www.packtpub.com/virtualization-and-cloud/hands-kubernetes-networking-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
