- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Edge Serverless and Event-Driven Architectures with Knative and Cloud Events
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Knative 和 Cloud Events 实现边缘无服务器和事件驱动架构
- en: Serverless architecture reduces the costs of running distributed systems at
    scale. This use case is particularly useful in edge computing, where a lot of
    dedicated hardware and computational resources are used. This chapter covers how
    Knative can help you to implement APIs using serverless technologies. It also
    shows how to reduce costs and complexity using Knative for simple event-driven
    architectures and serverless functions to build your system. Across the chapter,
    we explain how Knative uses Cloud Events for its cloud event specification to
    call events, and how serverless can be helpful in the development of event-driven
    applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构降低了大规模运行分布式系统的成本。这个使用案例在边缘计算中尤为有用，因为边缘计算需要大量专用硬件和计算资源。本章将介绍如何使用 Knative
    实现基于无服务器技术的 API。还将展示如何使用 Knative 简化事件驱动架构和无服务器函数来降低成本和复杂性，帮助构建系统。在本章中，我们将解释 Knative
    如何使用 Cloud Events 来调用事件，并且阐述无服务器架构如何帮助开发事件驱动的应用程序。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Serverless at the edge with Knative and Cloud Events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Knative 和 Cloud Events 实现边缘计算中的无服务器架构
- en: Implementing serverless functions using Knative Serving
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Knative Serving 实现无服务器函数
- en: Implementing a serverless API using traffic splitting with Knative
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Knative 进行流量切分实现无服务器 API
- en: Using declarative files in Knative
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Knative 中使用声明式文件
- en: Implementing events and event-driven pipelines using sequences with Knative
    Eventing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Knative Eventing 中的序列实现事件和事件驱动的流水线
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下内容：
- en: A single or multi-node K3s cluster using ARM devices with MetalLB installed
    and with the options to avoid Traefik being installed as the default ingress controller.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用 ARM 设备的单节点或多节点 K3s 集群，并安装了 MetalLB，且避免将 Traefik 安装为默认的入口控制器。
- en: kubectl configured to be used on your local machine to avoid using the `--kubeconfig`
    parameter.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置好 kubectl 以便在本地机器上使用，避免使用 `--kubeconfig` 参数。
- en: Clone the repository at [https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch9](https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch9)
    if you want to run the YAML configuration by using `kubectl apply` instead of
    copying the code from the book. Take a look at the code for Python and YAML configurations
    inside the `ch9` directory.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想通过 `kubectl apply` 运行 YAML 配置而不是从书中复制代码，请克隆 [https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch9](https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch9)
    中的代码。查看 `ch9` 目录中的 Python 和 YAML 配置代码。
- en: We are going to install Knative to implement simple use cases using serverless
    APIs and event-driven pipelines. Let’s understand what serverless architectures
    are and how can they help in edge computing environments.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装 Knative 来实现简单的无服务器 API 和事件驱动流水线的使用案例。让我们理解无服务器架构是什么，以及它们如何在边缘计算环境中提供帮助。
- en: Serverless at the edge with Knative and Cloud Events
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Knative 和 Cloud Events 实现边缘计算中的无服务器架构
- en: Edge computing is a paradigm that processes information near the source of data.
    This improves the response time of the application. It also saves bandwidth when
    the data is accessed because instead of getting data from the cloud, data is accessed
    near to the source. But one of the problems is that the services are always up
    and running. Here is where serverless can help to reduce costs, scaling down services
    when they are not used, helping to reduce additional costs compared with the traditional
    way of having services running all the time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘计算是一种在数据源附近处理信息的范式。这可以提高应用程序的响应时间。当数据被访问时，也能节省带宽，因为数据不再从云端获取，而是直接从源头附近访问。但其中一个问题是，服务总是保持运行状态。无服务器架构可以帮助减少成本，在服务不使用时将其缩减规模，从而减少与传统始终运行服务方式相比的额外成本。
- en: Ben Ellerby, in his Medium article called *Why Serverless will enable the Edge
    Computing Revolution*, mentions that *Serverless enables us to build applications
    and services without thinking about the underlying servers*. This refers to thinking
    more about the applications instead of managing infrastructure. In this way, serverless
    technologies and cloud services have been increasing in popularity in recent years.
    Serverless cloud services only charge you for the execution time when you are
    using the service. You can often find serverless services as small code functions.
    Serverless technologies enabled event-driven architectures to flourish, because
    of their simplicity and low cost to implement new functionalities. According to
    the [https://solace.com/](https://solace.com/) website, an event-driven architecture
    is a *software design pattern in which decoupled applications can asynchronously
    publish and subscribe to events via an event broker (modern messaging-oriented-middleware)*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Ben Ellerby 在他的一篇 Medium 文章《*为什么无服务器将促进边缘计算革命*》中提到，*无服务器让我们能够构建应用程序和服务，而不必考虑底层的服务器*。这意味着更多地关注应用程序本身，而不是基础设施的管理。因此，近年来无服务器技术和云服务的普及度不断增加。无服务器云服务只会在您使用服务时收取执行时间的费用。您通常可以找到作为小型代码函数的无服务器服务。无服务器技术使得事件驱动架构得以蓬勃发展，因为它们实现新功能的简单性和低成本。根据
    [https://solace.com/](https://solace.com/) 网站，事件驱动架构是一种*软件设计模式，在该模式下，解耦的应用程序可以通过事件代理（现代消息导向中间件）异步地发布和订阅事件*。
- en: 'One of the key aspects to evaluate when building a new system is the cost of
    implementation. This will be a common scenario for choosing serverless technologies.
    Serverless technologies implemented in on-premises scenarios could take advantage
    of the temporal use of resources to execute serverless functions. Knative implements
    serverless functions and events that can be used to implement event-driven applications.
    In addition, an event specification such as Cloud Events can help to standardize
    the communication of your services and define events:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建新系统时，评估的关键因素之一是实现成本。这将在选择无服务器技术时成为常见场景。在本地环境中实现的无服务器技术可以利用资源的临时使用来执行无服务器函数。Knative
    实现了无服务器函数和事件，可用于实现事件驱动的应用程序。此外，像 Cloud Events 这样的事件规范可以帮助标准化服务的通信并定义事件：
- en: '![Figure 9.1 – Knative architecture'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.1 – Knative 架构'
- en: '](img/B16945_09_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_09_01.jpg)'
- en: Figure 9.1 – Knative architecture
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – Knative 架构
- en: 'Knative was born in Google, and it was given to the community as an open source
    project. Knative consists of two parts: Serving and Eventing. With Knative Serving,
    you can create serverless functions in Kubernetes. Knative Serving implements
    the features of networking, autoscaling, and revision tracking. This abstraction
    gives the user the ability to focus more on the logic of the business instead
    of managing infrastructure. On the other hand, Knative Eventing gives the user
    the ability to implement event-driven architectures and call functions created
    with the Serving feature. You can configure your events to use different sources
    and broker types to manage your events depending on your use case. After choosing
    a source and broker that fit your scenario, you can trigger sequences or simple
    calls of your functions.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 诞生于 Google，并作为开源项目交给了社区。Knative 由两部分组成：Serving 和 Eventing。通过 Knative
    Serving，您可以在 Kubernetes 中创建无服务器函数。Knative Serving 实现了网络、自动扩展和版本跟踪等功能。该抽象使用户能够更多地专注于业务逻辑，而不是基础设施管理。另一方面，Knative
    Eventing 使用户能够实现事件驱动架构，并调用通过 Serving 功能创建的函数。您可以根据用例配置事件，使用不同的源和代理类型来管理事件。在选择适合您场景的源和代理后，您可以触发函数的顺序或简单调用。
- en: Cloud Events works together with Knative to give a standard structure to the
    events and have a uniform way to declare and call events. Cloud Events follows
    an event specification that is used to implement events. This structure has been
    adopted for different open source projects such as OpenFaaS, Tekton, Argo Events,
    Falco, Google Cloud Eventarc, and so on. The Cloud Events SDK is available for
    different programming languages such as Python and Go. This SDK will help you
    to describe cloud events through definitions such as ID, version of the cloud
    event specification, type, source, and content type.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Events 与 Knative 一起工作，为事件提供标准结构，并有统一的方式声明和调用事件。Cloud Events 遵循用于实现事件的事件规范。这个结构已经被多个开源项目采用，如
    OpenFaaS、Tekton、Argo Events、Falco、Google Cloud Eventarc 等等。Cloud Events SDK 支持多种编程语言，如
    Python 和 Go。这个 SDK 将帮助你通过定义 ID、云事件规范的版本、类型、源和内容类型等来描述云事件。
- en: Knative and Cloud Events provide a way to implement serverless functions and
    event-driven architectures at the edge, for low-resource devices, and a lightweight
    implementation that permits cost-saving in an edge computing scenario.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 和 Cloud Events 提供了一种在边缘、低资源设备上实现无服务器功能和事件驱动架构的方法，并且提供了一种轻量级的实现，可以在边缘计算场景中节省成本。
- en: Important Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'For more information about Knative, you can visit its official documentation:
    [https://knative.dev/docs](https://knative.dev/docs). For Cloud Events, you can
    visit its official website: [https://cloudevents.io](https://cloudevents.io) or
    its specification 1.0, which is used in our examples: [https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/spec.md](https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/spec.md).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 获取更多关于 Knative 的信息，你可以访问其官方文档：[https://knative.dev/docs](https://knative.dev/docs)。关于
    Cloud Events，你可以访问其官方网站：[https://cloudevents.io](https://cloudevents.io)，或者查看其规范
    1.0，这是我们示例中使用的版本：[https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/spec.md](https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/spec.md)。
- en: Implementing serverless functions using Knative Serving
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Knative Serving 实现无服务器功能
- en: To start building our simple use cases for serverless and event-driven use cases,
    we have to install Knative with Serving, Eventing, channels, and brokers. In this
    case, we are going to use the basic options using in-memory channels and Knative
    Eventing Sugar Controller, which creates Knative resources based on labels in
    your cluster or namespace. So, let’s start installing Knative Serving in the next
    section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始构建我们的简单无服务器和事件驱动用例，我们需要安装 Knative，包括 Serving、Eventing、频道和代理。在这种情况下，我们将使用基本选项，使用内存中的频道和
    Knative Eventing Sugar Controller，该控制器会根据集群或命名空间中的标签创建 Knative 资源。所以，让我们在下一节开始安装
    Knative Serving。
- en: Installing Knative Serving
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Knative Serving
- en: 'In this section, we are going to start installing Knative Serving, which will
    be used to implement serverless functions. Let’s follow the next steps to install
    Knative Serving:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始安装 Knative Serving，后续将用于实现无服务器功能。让我们按照以下步骤安装 Knative Serving：
- en: 'Install the Knative CLI with the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装 Knative CLI：
- en: '[PRE0]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To upgrade your current Knative binary, run the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要升级当前的 Knative 二进制文件，请运行以下命令：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Install the Knative Serving CRDs to install the serving components:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Knative Serving CRD，以安装 Serving 组件：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'To learn more about **Custom Resource Definitions** (**CRDs**) you can check
    out this link: [https://docs.openshift.com/aro/3/dev_guide/creating_crd_objects.html](https://docs.openshift.com/aro/3/dev_guide/creating_crd_objects.html).
    You can also check the CRD documentation from the Kubernetes official website
    with the next link: [https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于**自定义资源定义**（**CRDs**）的信息，你可以查看这个链接：[https://docs.openshift.com/aro/3/dev_guide/creating_crd_objects.html](https://docs.openshift.com/aro/3/dev_guide/creating_crd_objects.html)。你也可以通过下一个链接查看
    Kubernetes 官方网站上的 CRD 文档：[https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources)。
- en: 'Now install the Contour ingress controller, which will be used as the default
    for Knative (this component is available for ARM):'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在安装 Contour ingress 控制器，它将作为 Knative 的默认控制器使用（该组件支持 ARM）：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Install the network component of Knative for other functionalities using the
    previous ingress running the following command:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前的 ingress 运行以下命令，安装 Knative 的网络组件以启用其他功能：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then set Contour as the default ingress controller to be used by Knative:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将 Contour 设置为 Knative 使用的默认 ingress 控制器：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Get the IP that your Contour ingress controller created as the endpoint for
    your applications. In this case, we are going to call this IP `EXTERNAL_IP`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 Contour 入口控制器创建的 IP 作为您应用程序的端点。在此情况下，我们将把此 IP 称为 `EXTERNAL_IP`：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Set the domain that Knative is going to use to expose your serverless applications:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 Knative 用来暴露您的无服务器应用程序的域：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now set the **Horizontal Pod Autoscaler** (**HPA**) feature of Knative Serving
    to run:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在设置 **水平 Pod 自动扩展器**（**HPA**）功能以运行 Knative Serving：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, perform simple troubleshooting for the Knative components running:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，进行 Knative 组件运行的简单故障排除：
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will return the state of the pods of your Knative Serving installation.
    These pods should have a ready status after a few minutes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回您 Knative Serving 安装中 pod 的状态。这些 pod 在几分钟后应该会处于就绪状态。
- en: Important Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To uninstall the components, you can use `kubectl delete` instead of `kubectl
    apply`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 若要卸载组件，您可以使用`kubectl delete`而不是`kubectl apply`。
- en: Now Knative Serving is installed and ready to use. So, let’s move on to create
    a simple serverless function using Knative Serving in the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Knative Serving 已经安装并准备好使用了。那么，让我们继续在下一部分创建一个简单的无服务器函数，使用 Knative Serving。
- en: Creating a simple serverless function
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的无服务器函数
- en: 'Now it’s time to use Knative Serving. In this section, we are going to run
    a sample API using Python and Flask. The code will look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用 Knative Serving 了。在本节中，我们将使用 Python 和 Flask 运行一个示例 API。代码将如下所示：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Every time you call the function, it is going to return the variable host with
    the container ID and `msg` with the value of the `MESSAGE` environment variable.
    This API will use port `5000`. This Python program is already packaged in a container.
    It was built and published on Docker Hub as `sergioarmgpl/app2demo`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用该函数时，它将返回带有容器 ID 的变量 host 和 `msg`，该 `msg` 为 `MESSAGE` 环境变量的值。此 API 将使用端口
    `5000`。这个 Python 程序已经打包在容器中，并作为 `sergioarmgpl/app2demo` 在 Docker Hub 上构建并发布。
- en: Important Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can explore how to build and customize this code in the GitHub repository:
    [https://github.com/sergioarmgpl/containers](https://github.com/sergioarmgpl/containers).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 仓库中探索如何构建和自定义此代码：[https://github.com/sergioarmgpl/containers](https://github.com/sergioarmgpl/containers)。
- en: 'Now, to deploy this API as a serverless function using Knative, follow the
    next steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了通过 Knative 将这个 API 部署为无服务器函数，请按照以下步骤操作：
- en: 'Create your function with the following command:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建您的函数：
- en: '[PRE11]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This command redirects port `5000` where your API is exposed in your container
    to the HTTP endpoint that Knative generates. It also receives the `MESSAGE` parameter
    with the `Knative demo` value and sets the revision of this function as `v1`.
    After running this command, you will get an output like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将容器中暴露的端口 `5000` 重定向到 Knative 生成的 HTTP 端点。它还接收带有 `Knative demo` 值的 `MESSAGE`
    参数，并将此函数的修订版设置为 `v1`。运行此命令后，您将获得如下输出：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At the end of the output, you will find the endpoint for your function. In this
    output, we are assuming that the IP address assigned to the Contour ingress controller
    is `192.168.0.54`, which is the same value assigned to the `EXTERNAL_IP` variable.
    Knative creates the necessary pods for this function in the default namespace.
    Refer to the *Installing Knative Serving* section for more information about to
    how to get the IP assigned to your Contour ingress.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的末尾，您将找到函数的端点。在这个输出中，我们假设分配给 Contour 入口控制器的 IP 地址是 `192.168.0.54`，这与分配给 `EXTERNAL_IP`
    变量的值相同。Knative 会在默认命名空间中为此函数创建必要的 pod。有关如何获取分配给 Contour 入口的 IP，请参阅 *安装 Knative
    Serving* 部分。
- en: 'Now, access your function using the `EXTERNAL_IP` variable defined in the *Installing
    Knative Serving* section, by running the following command:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 *安装 Knative Serving* 部分中定义的 `EXTERNAL_IP` 变量访问您的函数，运行以下命令：
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This command will return a JSON output in your terminal like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将在终端返回类似以下内容的 JSON 输出：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To monitor the pods created for your function, run this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要监控为您的函数创建的 pod，请运行此命令：
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After 2 minutes of inactivity for your functions, the pods created to run your
    functions will be scaled down. If you execute `watch kubectl get pods`, you will
    see a similar output to this:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的函数不活跃 2 分钟后，为运行您的函数而创建的 pod 将被缩减。如果您执行`watch kubectl get pods`，您将看到类似以下的输出：
- en: '[PRE16]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Open another terminal and execute `watch kubectl get pods`, and then call the
    function again. The pods of the function will be scaled up and you will see a
    similar output to this:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个终端并执行`watch kubectl get pods`，然后再次调用该函数。函数的pods将被扩展，你将看到类似以下的输出：
- en: '[PRE17]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the scaling to zero functionality, you can cut costs in your cloud infrastructure
    when your functions have an idle status after 2 minutes of inactivity.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过零扩展功能，当你的函数在2分钟内没有活动时，你可以减少云基础设施的成本。
- en: Important Note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `watch` command might not be installed on your operating system. This can
    be installed with the `yum` or `apt` command on Linux, or the `brew` command on
    macOS.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`watch`命令可能未在你的操作系统上安装。你可以在Linux上使用`yum`或`apt`命令进行安装，或者在macOS上使用`brew`命令进行安装。'
- en: 'Check the created services in the default namespace using the following command:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查默认命名空间中创建的服务：
- en: '[PRE18]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Or, run the following command to check the available functions in a specific
    namespace:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，运行以下命令以检查特定命名空间中可用的函数：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To check your current revisions, run the following:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查当前的修订版，运行以下命令：
- en: '[PRE20]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '(*Optional*) If you don’t want to create a public endpoint for your function,
    use the `--cluster-local` flag for the `kn` command to create a private endpoint.
    To create the same function but with a private endpoint, use the following command:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*可选*) 如果你不想为你的函数创建公共端点，可以使用`--cluster-local`标志来为`kn`命令创建私有端点。要创建具有私有端点的相同函数，请使用以下命令：
- en: '[PRE21]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'At the end of the output, you will see something like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的末尾，你将看到类似以下内容：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This endpoint will be the URL service that Knative creates for you, which is
    the same service object used in Kubernetes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点将是Knative为你创建的URL服务，它与Kubernetes中使用的相同服务对象。
- en: '(*Optional*) To access this endpoint, you have to call it inside the cluster.
    To do this, create a client container that contains `curl`. Run the following
    command:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*可选*) 要访问此端点，你必须在集群内调用它。为此，创建一个包含`curl`的客户端容器。运行以下命令：
- en: '[PRE23]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the pod is created, you have to run the following command to access the
    function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦pod创建完成，你必须运行以下命令来访问该函数：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output will look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To delete the serverless function created in this section, run this:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除本节中创建的无服务器函数，运行以下命令：
- en: '[PRE26]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, you know how to create serverless functions to implement a simple API using
    Knative Serving and scale to zero functionality to save costs. It’s time to implement
    the traffic splitting functionality using Knative Serving in the next section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道如何使用Knative Serving创建无服务器函数来实现一个简单的API，并使用零扩展功能节省成本。接下来是时候在下一节中使用Knative
    Serving实现流量拆分功能了。
- en: Implementing a serverless API using traffic splitting with Knative
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Knative实现带有流量拆分的无服务器API
- en: Knative has traffic splitting functionality that consists of distributing the
    traffic across two or more versions within a service but uses a proxy to implement
    this feature. By default, it uses Istio. For this implementation, we are using
    Contour, an Envoy-based proxy that consumes fewer resources than Istio. Both Istio
    and Contour use Envoy, a layer 7 proxy to implement service mesh capabilities
    such as traffic splitting. Traffic splitting could be used to implement deployment
    strategies such as canary and blue-green deployments, and also could be used to
    simulate faulty traffic for some basic chaos engineering scenarios. In this section,
    we are going to implement traffic splitting for the previous API function created
    in the *Creating a simple serverless function* section. In that section, we created
    a function called `api` with the revision name `v1`. Now we are going to update
    this function with another revision called `v2`. This revision just changes the
    `MESSAGE` value that is shown when you call the function. For this example, we
    are going to split traffic with 50% to revision `v1` and 50% to revision `v2`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Knative具有流量拆分功能，可以将流量分配到服务中的两个或多个版本，但使用代理来实现此功能。默认情况下，它使用Istio。对于此实现，我们使用Contour，这是一个基于Envoy的代理，比Istio消耗更少的资源。Istio和Contour都使用Envoy，这是一个第7层代理，用于实现服务网格功能，如流量拆分。流量拆分可以用于实现部署策略，如金丝雀发布和蓝绿部署，也可以用于模拟故障流量，进行一些基本的混沌工程场景。在本节中，我们将为之前在*创建简单的无服务器函数*部分中创建的API函数实现流量拆分。在该部分中，我们创建了一个名为`api`的函数，并将修订名定为`v1`。现在，我们将用另一个名为`v2`的修订版来更新此函数。此修订版仅更改了调用该函数时显示的`MESSAGE`值。对于此示例，我们将按50%的比例将流量拆分到`v1`修订版和`v2`修订版。
- en: 'To implement this scenario, follow the next steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此场景，请按照以下步骤进行操作：
- en: 'Update the current `api` function with the new revision, `v2`, which has the
    value of the `MESSAGE` variable with `Knative demo v2`, for this run:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新修订版本`v2`更新当前的`api`函数，其中`MESSAGE`变量的值为`Knative demo v2`，本次运行为：
- en: '[PRE27]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of this command will look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出将如下所示：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s check the revisions of our `api` function with the following command:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过以下命令检查我们的`api`函数的修订版本：
- en: '[PRE29]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With this command, you will see that 100% of the traffic will be processed
    by the `v2` revision. The output will look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，您将看到所有流量将由`v2`修订版本处理。输出将如下所示：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Important Note
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We are omitting the `TAGS`, `GENERATION`, `AGE`, `CONDITIONS`, `READY`, and
    `REASON` fields of the output for learning purposes. We are assuming that the
    IP address assigned to the Contour ingress controller is `192.168.0.54`, which
    is the same value assigned to the `EXTERNAL_IP` variable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 出于学习目的，我们省略了输出的`TAGS`、`GENERATION`、`AGE`、`CONDITIONS`、`READY`和`REASON`字段。我们假设分配给
    Contour Ingress 控制器的 IP 地址是`192.168.0.54`，与分配给`EXTERNAL_IP`变量的值相同。
- en: 'Set the traffic splitting to 50% for version `v1` and 50% for version `v2`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将流量拆分设置为`v1`版本的50%，`v2`版本的50%：
- en: '[PRE31]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The expected output will look like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出将如下所示：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can also use `api-v2` instead of the `@latest` option. You can also customize
    your parameter with your own versions and different traffic splitting rates.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`@latest`选项的`api-v2`替代方案。您还可以使用自定义版本和不同的流量分配率。
- en: 'Let’s check how traffic is distributed across the `api` function after setting
    the traffic splitting by running this:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令来设置流量拆分并检查流量是如何在`api`函数中分布的：
- en: '[PRE33]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output will look like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You will see that the traffic is split by 50% for each revision.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 流量按每个修订版本分为50%。
- en: 'Let’s send traffic to our function with a simple `BASH` loop script that you
    can stop with *Ctrl* + *C* by running the following command:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用一个简单的`BASH`循环脚本向我们的函数发送流量，您可以通过运行以下命令并按*Ctrl* + *C*来停止：
- en: '[PRE35]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This command is going to continuously call your function that is split in to
    two versions every 0.3 seconds. The latest available revision will be running
    by default. In this case revision `v2` will be available for responses. After
    waiting a few seconds `v1` is provisioned and the output starts to show that the
    traffic is split by 50% for each revision. The output will look something like
    this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将持续调用每0.3秒拆分为两个版本的函数。默认情况下，将运行最新可用的修订版本。在此情况下，修订版本`v2`将用于响应。等待几秒钟后，`v1`被供应，并且输出开始显示流量按每个修订版本50%拆分。输出将类似于：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Use *Ctrl* + *C* to stop the `BASH` loop.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *C*停止`BASH`循环。
- en: 'If you want to check the pods of this traffic splitting, run the following
    command:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想检查此流量拆分的 pod，请运行以下命令：
- en: '[PRE37]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output will look like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this output, there are two pods running – one for revision `v1` and the other
    for `v2`. These pods are created on demand. By the default one of these revisions
    will be running if idle time was not exceeded to be called down. After requests
    start coming, the other revision is scaled up to start splitting the traffic between
    these pods by 50% each.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在此输出中，有两个正在运行的 pod —— 一个用于修订版本`v1`，另一个用于`v2`。这些 pod 是按需创建的。默认情况下，如果没有超过空闲时间以调用它，则这些修订版本中的一个将运行。开始收到请求后，另一个修订版本将扩展以开始将流量分为这些
    pod 的50%。
- en: 'Finally, you can delete your API function with all your revisions running:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以删除正在运行的所有修订版本的 API 函数：
- en: '[PRE39]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now you have learned how to use traffic splitting and revisions in Knative.
    Now let’s go deep into Knative, learning how to use declarative files to create
    services in the next section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何在Knative中使用流量拆分和修订版本。现在让我们深入了解Knative，学习如何使用声明性文件在下一节中创建服务。
- en: Using declarative files in Knative
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Knative中使用声明性文件
- en: 'A good practice when creating environments is to create declarative definitions
    for your applications. Knative supports this with the `--target` flag. For example,
    if you want to change the previous example into a YAML file, you could use this
    flag. To do this, run the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建环境时的一个好习惯是为您的应用程序创建声明性定义。Knative 支持使用`--target`标志实现此目的。例如，如果您想将前面的示例更改为 YAML
    文件，可以使用此标志。要执行此操作，请运行以下命令：
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This command outputs a YAML file with the definition of an API function, without
    a public endpoint. The output in the `api.yaml` file will look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将输出一个没有公共端点的 API 功能定义的 YAML 文件。`api.yaml` 文件中的输出将如下所示：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the `annotations` section, you can configure different features that Knative
    provides; for example, autoscaling, rate limits, concurrency, and so on. In this
    case, we used `autoscaling.knative.dev/max-scale` to set the maximum replicas
    for the deployment of the function and `containerConcurrency` to set the number
    of simultaneous requests for each replica in the function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `annotations` 部分，你可以配置 Knative 提供的不同功能；例如，自动缩放、速率限制、并发等。在此案例中，我们使用了 `autoscaling.knative.dev/max-scale`
    来设置函数部署的最大副本数，并使用 `containerConcurrency` 来设置每个副本的并发请求数。
- en: 'Another example is how you can define the YAML for traffic splitting. Based
    on our previous traffic splitting example in the *Implementing a serverless API
    using traffic splitting with Knative* section, to generate the equivalent YAML
    configuration use the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例是如何定义流量分割的 YAML。基于我们在 *使用 Knative 进行流量分割实现无服务器 API* 部分中的流量分割示例，要生成等效的 YAML
    配置，使用以下命令：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output will look like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is a desirable feature and best practice. To have declarative definitions
    for creating your functions and other Knative objects, you can explore the official
    documentation of Knative to find examples of declarative definitions. Now it’s
    time to move on to install another feature, Knative Eventing, in the next section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个理想的功能和最佳实践。为了对创建函数和其他 Knative 对象进行声明性定义，你可以浏览 Knative 的官方文档，查找声明性定义的示例。现在是时候进入下一部分，安装
    Knative Eventing 的另一个功能了。
- en: Implementing events and event-driven pipelines using sequences with Knative
    Eventing
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Knative Eventing 实现事件和事件驱动管道
- en: Knative provides Eventing components to implement event-driven architectures.
    We are going to explore a simple Eventing pipeline with Knative using the lightweight
    in-memory channel component to implement two simple events that call a service
    showing a message. In the second part, we are going to implement a simple sequence
    that calls two servers sequentially, one after the other, showing custom messages.
    So, let’s get started with the first part to implement simple events.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 提供了 Eventing 组件来实现事件驱动架构。我们将使用 Knative 探索一个简单的 Eventing 管道，利用轻量级的内存通道组件来实现两个简单的事件，调用一个服务并展示一条消息。在第二部分，我们将实现一个简单的序列，依次调用两个服务器，展示自定义消息。那么，让我们从第一部分开始，实现简单的事件。
- en: Installing Knative Eventing
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Knative Eventing
- en: 'Before creating our events, we need to install all the Knative components.
    We are going to use the in-memory channel to manage our events, which is the simplest
    and most lightweight channel implemented in Knative, and Sugar Controller to provision
    Knative Eventing resources in namespaces using labels. To get started with installing
    Knative Eventing, follow the next steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的事件之前，我们需要安装所有 Knative 组件。我们将使用内存通道来管理我们的事件，这是 Knative 中最简单且最轻量的通道，同时还需要使用
    Sugar Controller 来通过标签在命名空间中提供 Knative Eventing 资源。按照以下步骤安装 Knative Eventing：
- en: 'Install the Knative Eventing CRDs:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Knative Eventing CRD：
- en: '[PRE44]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Install Knative Eventing core components by running the following command:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装 Knative Eventing 核心组件：
- en: '[PRE45]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now install the in-memory channel component by running this:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过运行以下命令安装内存通道组件：
- en: '[PRE46]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now install the MT channel broker, which is a lightweight and simple implementation
    to use the in-memory channel:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在安装 MT 通道代理，它是一个轻量级且简单的实现，使用内存通道：
- en: '[PRE47]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, install Knative Eventing Sugar Controller, which reacts to special
    labels and annotations and produces Eventing resources:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，安装 Knative Eventing Sugar Controller，它会响应特殊的标签和注释，并生成 Eventing 资源：
- en: '[PRE48]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Check whether all the components have a `READY` status by running the following
    command:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，检查所有组件是否处于 `READY` 状态：
- en: '[PRE49]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You will see a similar output to this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似以下的输出：
- en: '[PRE50]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now you have installed all the necessary components to implement a simple event-driven
    pipeline using Knative. Let’s move to the next section to learn how to implement
    events.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了所有必要的组件来使用 Knative 实现一个简单的事件驱动管道。让我们进入下一部分，学习如何实现事件。
- en: Implementing a simple event
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个简单的事件
- en: 'Now it’s time to implement some basic events. This scenario consists of creating
    two services and calling them with their attribute type. First, let’s explore
    the code inside the container that is in Docker Hub called `sergioarmgpl/app3demo`.
    The code used is this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现一些基本事件了。这个场景包括创建两个服务并通过它们的属性类型进行调用。首先，让我们探索在Docker Hub中名为`sergioarmgpl/app3demo`的容器内的代码。使用的代码是：
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This code receives the call and transforms the data of the requests using the
    Cloud Events library to output the event with the `app.logger.warning` function
    implemented in Flask. So, every time the application is called in the `/` route
    path, it is going to show the information of the request that is calling the container
    using the Cloud Events structure format in the logs. In this case, we are not
    returning any data in response. It just returns HTTP status response code `204`,
    which refers to a successful request call. You can also customize this code if
    necessary to fit your needs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码接收调用并使用Cloud Events库转换请求的数据，以使用Flask中实现的`app.logger.warning`函数输出事件。因此，每次在`/`路由路径中调用应用程序时，它都会在日志中显示调用容器的请求信息，采用Cloud
    Events结构格式。在这种情况下，我们不会返回任何数据作为响应。它只是返回HTTP状态响应代码`204`，表示请求成功。根据需要，您还可以自定义此代码，以适应您的需求。
- en: Now we have to create two services using YAML definitions. The first service
    will be called `api-demo`, and the second `api-demo2`. These services will be
    called every time the broker is called, sending their cloud event’s attributes.
    When the attribute type is set to `event.show`, the `api-demo` service is called,
    and when the broker is called with the `attribute` type set to `event.show.2`,
    the `api-demo2` service will be called. Both services are configured to listen
    on port `5000` and forward requests to port `80` to properly work with Knative
    Eventing.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须使用YAML定义创建两个服务。第一个服务将命名为`api-demo`，第二个服务为`api-demo2`。每次调用代理时，这些服务都会被调用，发送它们的云事件属性。当属性类型设置为`event.show`时，将调用`api-demo`服务，而当代理调用时，属性类型设置为`event.show.2`时，将调用`api-demo2`服务。两个服务都配置为监听端口`5000`并将请求转发到端口`80`，以便与Knative
    Eventing正常工作。
- en: 'To start implementing the first scenario, follow the next steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始实现第一个场景，请按照以下步骤操作：
- en: 'Create and inject the `event-demo` namespace where the event is going to be
    created:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并注入将创建事件的`event-demo`命名空间：
- en: '[PRE52]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create the default broker to use for this implementation:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于此实现的默认代理：
- en: '[PRE53]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Deploy the container that is going to process the event:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署将处理事件的容器：
- en: '[PRE54]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create the service for this `api-demo` deployment:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此`api-demo`部署创建服务：
- en: '[PRE55]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create a trigger to be consumed by the service:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个由服务消费的触发器：
- en: '[PRE56]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a pod in the `event-demo` namespace to call the broker. This broker
    is going to call our pod that shows the message **Simple Event using Knative**.
    To create this pod, run this:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`event-demo`命名空间中创建一个pod来调用代理。该代理将调用我们的pod，显示消息**Simple Event using Knative**。要创建此pod，请运行：
- en: '[PRE57]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Inside this pod, run the `curl` command to send a request to the broker. The
    broker will take the parameters of the previously implemented cloud event to send
    it to your pod. To call the broker, run this:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此pod内，运行`curl`命令发送请求到代理。代理将采用先前实现的云事件参数并将其发送到您的pod。要调用代理，请运行：
- en: '[PRE58]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The output will look like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE59]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To exit, run the next command inside the pod:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出，请在pod内运行下一个命令：
- en: '[PRE60]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now inspect the logs of the pod by running the following command:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过运行以下命令检查pod的日志：
- en: '[PRE61]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Or, if you want to see the log in real time, when you call the broker that
    calls your pod, run the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您想实时查看日志，当您调用代理并触发您的pod时，运行以下命令：
- en: '[PRE62]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output will look like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE63]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As you can see, the pod got the `msg` value `Simple Event using Knative.` and
    it’s printed in the logs of the pod. This means that when you call the broker,
    the trigger calls the pod exposed using the service that was previously created.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，pod收到了`msg`值`Simple Event using Knative.`，并且它已打印在pod的日志中。这意味着当您调用代理时，触发器会通过先前创建的服务调用暴露的pod。
- en: 'Let’s say, for example, that you want to create another event, using the same
    image. This time, let’s call it `api-demo2` for the second service. Create the
    next YAML definitions:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，假设您想使用相同的镜像创建另一个事件。这次，我们将其命名为`api-demo2`，用于第二个服务。创建下一个YAML定义：
- en: 'To create the `api-demo2` deployment, run the following:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建`api-demo2`部署，请运行以下命令：
- en: '[PRE64]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create the service for this `api-demo2` deployment:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此`api-demo2`部署创建服务：
- en: '[PRE65]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create a trigger that launches `api-demo2`, and let’s call the attribute type
    `event.show.2` to call the `api-demo2` service, which points to the `api-demo2`
    deployment:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个触发器来启动`api-demo2`，我们将调用`api-demo2`服务的属性类型`event.show.2`，该服务指向`api-demo2`部署：
- en: '[PRE66]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the previously created `curl` pod, run the following command:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前创建的`curl` pod中，运行以下命令：
- en: '[PRE67]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Check the logs in the new `api-demo2` deployment with the following command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查新`api-demo2`部署中的日志：
- en: '[PRE68]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The log will look like this:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日志将显示如下：
- en: '[PRE69]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now you have created two basic events using Knative Eventing. This can help
    you to implement simple and lightweight event-driven architectures. Now, it’s
    time to explore how to use the Sequence feature of Knative Eventing to create
    and run simple pipelines using an event-driven architecture.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经使用Knative Eventing创建了两个基本事件。这可以帮助您实现简单且轻量级的事件驱动架构。现在，是时候探索如何使用Knative
    Eventing的Sequence功能，使用事件驱动架构创建和运行简单的管道了。
- en: Using sequences to implement event-driven pipelines
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用序列实现事件驱动管道
- en: 'Another common use case for event-driven architectures is to trigger a series
    of steps one after the other to automate workflows. In those cases, you can use
    the Sequence object of Knative. In this example, we are going to create a sequence
    that consists of two steps. Each step prints the `MESSAGE` variable, which contains
    the number of the step that is running. This sequence is going to be called using
    a trigger. We are going to call the trigger using the `curl` command. This is
    a simple example pipeline using event-driven architecture. Let’s get started by
    following the next steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动架构的另一个常见用例是触发一系列步骤按顺序执行以自动化工作流。在这种情况下，您可以使用Knative的Sequence对象。在此示例中，我们将创建一个由两个步骤组成的序列。每个步骤都会打印`MESSAGE`变量，该变量包含当前运行步骤的编号。这个序列将通过触发器调用。我们将使用`curl`命令调用触发器。这是一个使用事件驱动架构的简单示例管道。让我们通过以下步骤开始：
- en: 'Create the `sequence-demo` namespace with the `eventing.knative.dev/injection:
    enabled` label. When Knative Eventing detects this label in your namespace, it
    is going to create the default Knative broker. This is possible thanks to the
    Knative Sugar Controller previously installed. So, let’s create the namespace
    by running the following command:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用`eventing.knative.dev/injection: enabled`标签创建`sequence-demo`命名空间。当Knative
    Eventing检测到此标签时，它将创建默认的Knative代理。这得益于之前安装的Knative Sugar Controller。因此，让我们通过运行以下命令创建命名空间：'
- en: '[PRE70]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Create `step1` using the Knative Service definition file by running the following
    command:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令，使用Knative服务定义文件创建`step1`：
- en: '[PRE71]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now create `step2` by running the following:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过运行以下命令创建`step2`：
- en: '[PRE72]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Important Note
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We are using the `containerPort` parameter in the service definition, to define
    a custom port where our container is listening, in order to talk with Knative
    Eventing. By default, Knative uses port `80` to listen to services.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在服务定义中使用`containerPort`参数，定义一个自定义端口，用于容器监听与Knative Eventing的通信。默认情况下，Knative使用端口`80`来监听服务。
- en: 'Let’s create our sequence object called `sequence-demo` to run the steps as
    a small pipeline using the in-memory channel for messaging:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建名为`sequence-demo`的序列对象，使用内存通道进行消息传递，作为一个小型管道运行这些步骤：
- en: '[PRE73]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Create the trigger that we are going to use. We are going to define an attribute
    to call it. In this case, every time we call an event with the `type` attribute
    with the value `event.call.sequence`, it is going to call our sequence:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们将要使用的触发器。我们将定义一个属性来调用它。在这种情况下，每次我们调用带有`type`属性且值为`event.call.sequence`的事件时，它将调用我们的序列：
- en: '[PRE74]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now let’s create a `curl` pod inside the `sequence-demo` namespace to call
    our sequence using the endpoint of our broker:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`sequence-demo`命名空间中创建一个`curl` pod，通过我们的代理的端点调用我们的序列：
- en: '[PRE75]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Inside the pod, run the following `curl` command:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在pod中运行以下`curl`命令：
- en: '[PRE76]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This is going to show an output like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示如下输出：
- en: '[PRE77]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Exit the pod and check the output of the pod for *step 1* by running the following:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出pod并通过运行以下命令检查*step 1*的输出：
- en: '[PRE78]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You will see an output like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到如下输出：
- en: '[PRE79]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This is going to receive the `SOME_VARIABLE` variable, sent by the `curl` command,
    which could be used to customize your sequence.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这将接收由`curl`命令发送的`SOME_VARIABLE`变量，该变量可用于自定义您的序列。
- en: 'Now check the output for *step 2* by running the following:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过运行以下命令检查*step 2*的输出：
- en: '[PRE80]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This is going to show the `ENV_VAR` value sent by the previous step and the
    current environment variable showing the step currently running – in this case,
    *step 2*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示由上一步发送的 `ENV_VAR` 值以及当前环境变量，表示当前正在运行的步骤——在这种情况下是 *步骤 2*。
- en: After a few minutes of being idle, the deployments for the steps in the namespace
    will scale down and will scale up every time you call it.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空闲几分钟后，命名空间中的步骤部署将会缩减，并在每次调用时重新扩展。
- en: We have finished with the basics of serverless and event-driven pipelines using
    Knative. It’s time to finish this chapter.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了使用 Knative 的无服务器和事件驱动管道基础知识的学习，是时候结束本章了。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to implement public serverless and internal
    serverless functions using Knative Serving and use the features of traffic splitting.
    We also learned how to implement simple events and a sequence of events to implement
    small event-driven architectures using Knative Eventing, and how to integrate
    and standardize API event calls using the Cloud Events Python SDK. In the next
    chapter, we are going to learn how to use databases at the edge to add more functionality
    to edge systems using K3s.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Knative Serving 实现公共无服务器和内部无服务器函数，并使用流量分配功能。我们还学习了如何使用 Knative
    Eventing 实现简单事件和事件序列，构建小型事件驱动架构，并通过 Cloud Events Python SDK 实现 API 事件调用的集成和标准化。在下一章中，我们将学习如何使用
    K3s 在边缘使用数据库，为边缘系统添加更多功能。
- en: Questions
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Here are a few questions to validate your new knowledge:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些问题来验证你新学到的知识：
- en: What are the use cases for serverless architectures?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无服务器架构的使用场景是什么？
- en: What is a serverless function?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是无服务器函数？
- en: What are the advantages of serverless technology?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无服务器技术的优势是什么？
- en: How can I implement a serverless function using Knative?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我如何使用 Knative 实现一个无服务器函数？
- en: How can I implement an event using Knative?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我如何使用 Knative 实现一个事件？
- en: How can I implement an event-driven pipeline using Knative?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我如何使用 Knative 实现事件驱动管道？
- en: How does Cloud Events help you to implement events?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cloud Events 如何帮助你实现事件？
- en: Further reading
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following references for more information on the topics
    covered in this chapter:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考以下资源获取更多关于本章内容的信息：
- en: '*Why Serverless will enable the Edge Computing Revolution*: [https://medium.com/serverless-transformation/why-serverless-will-enable-the-edge-computing-revolution-4f52f3f8a7b0](https://medium.com/serverless-transformation/why-serverless-will-enable-the-edge-computing-revolution-4f52f3f8a7b0)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为什么无服务器将推动边缘计算革命*: [https://medium.com/serverless-transformation/why-serverless-will-enable-the-edge-computing-revolution-4f52f3f8a7b0](https://medium.com/serverless-transformation/why-serverless-will-enable-the-edge-computing-revolution-4f52f3f8a7b0)'
- en: '*What is edge serverless*: [https://www.stackpath.com/edge-academy/what-is-edge-serverless](https://www.stackpath.com/edge-academy/what-is-edge-serverless)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*什么是边缘无服务器*: [https://www.stackpath.com/edge-academy/what-is-edge-serverless](https://www.stackpath.com/edge-academy/what-is-edge-serverless)'
- en: '*AI/ML, edge and serverless computing top priority list for the year ahead*:
    [https://www.redhat.com/en/blog/aiml-edge-and-serverless-computing-top-priority-list](https://www.redhat.com/en/blog/aiml-edge-and-serverless-computing-top-priority-list)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AI/ML、边缘计算和无服务器计算的年度优先事项*: [https://www.redhat.com/en/blog/aiml-edge-and-serverless-computing-top-priority-list](https://www.redhat.com/en/blog/aiml-edge-and-serverless-computing-top-priority-list)'
- en: 'Running Knative on Raspberry Pi: [https://github.com/csantanapr/knative-pi](https://github.com/csantanapr/knative-pi)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在 Raspberry Pi 上运行 Knative: [https://github.com/csantanapr/knative-pi](https://github.com/csantanapr/knative-pi)'
- en: 'Install Knative Serving using YAML: [https://knative.dev/docs/install/serving/install-serving-with-yaml/#install-a-networking-layer](https://knative.dev/docs/install/serving/install-serving-with-yaml/#install-a-networking-layer)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 YAML 安装 Knative Serving: [https://knative.dev/docs/install/serving/install-serving-with-yaml/#install-a-networking-layer](https://knative.dev/docs/install/serving/install-serving-with-yaml/#install-a-networking-layer)'
- en: 'Cloud Events website: [https://cloudevents.io](https://cloudevents.io)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Cloud Events 网站: [https://cloudevents.io](https://cloudevents.io)'
- en: 'Cloud Events SDK: [https://github.com/cloudevents/sdk-python](https://github.com/cloudevents/sdk-python)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Cloud Events SDK: [https://github.com/cloudevents/sdk-python](https://github.com/cloudevents/sdk-python)'
- en: 'CloudEvents – version 1.0.2: [https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/spec.md](https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/spec.md)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CloudEvents – 版本 1.0.2: [https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/spec.md](https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/spec.md)'
- en: 'A Hello World Python example with Knative Eventing: [https://github.com/knative/docs/tree/main/code-samples/eventing/helloworld/helloworld-python](https://github.com/knative/docs/tree/main/code-samples/eventing/helloworld/helloworld-python)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Knative Eventing 的 Hello World Python 示例：[https://github.com/knative/docs/tree/main/code-samples/eventing/helloworld/helloworld-python](https://github.com/knative/docs/tree/main/code-samples/eventing/helloworld/helloworld-python)
- en: 'Sending events to the broker: [https://knative.dev/docs/eventing/getting-started/#sending-events-to-the-broker](https://knative.dev/docs/eventing/getting-started/#sending-events-to-the-broker)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件发送到代理：[https://knative.dev/docs/eventing/getting-started/#sending-events-to-the-broker](https://knative.dev/docs/eventing/getting-started/#sending-events-to-the-broker)
- en: 'Using Sequence with Broker and Trigger: [https://knative.dev/docs/eventing/flows/sequence/sequence-with-broker-trigger](https://knative.dev/docs/eventing/flows/sequence/sequence-with-broker-trigger)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Sequence 配合 Broker 和 Trigger：[https://knative.dev/docs/eventing/flows/sequence/sequence-with-broker-trigger](https://knative.dev/docs/eventing/flows/sequence/sequence-with-broker-trigger)
