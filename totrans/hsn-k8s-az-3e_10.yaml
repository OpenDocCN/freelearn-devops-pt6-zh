- en: 6\. Securing your application with HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTPS has become a necessity for any public-facing website. Not only does it
    improve the security of your website, but it is also becoming a requirement for
    new browser functionalities. HTTPS is a secure version of the HTTP protocol. HTTPS
    makes use of **Transport Layer Security** (**TLS**) certificates to encrypt traffic
    between an end user and a server, or between two servers. TLS is the successor
    to the **Secure Sockets Layer** (**SSL**). The terms *TLS* and *SSL* are often
    used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, you needed to buy certificates from a **certificate authority**
    (**CA**), then set them up on your web server and renew them periodically. While
    that is still possible today, the **Let's Encrypt** service and helpers in Kubernetes
    make it very easy to set up verified TLS certificates in your cluster. Let's Encrypt
    is a non-profit organization run by the **Internet Security Research Group** and
    backed by multiple companies. It is a free service that offers verified TLS certificates
    in an automated manner. Automation is a key benefit of the Let's Encrypt service.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of Kubernetes helpers, you will learn about a new object called an
    **Ingress** and use a Kubernetes add-on called **cert-manager**. An ingress is
    an object within Kubernetes that manages external access to services, commonly
    used for HTTP services. An ingress adds additional functionality on top of the
    service object we explained in *Chapter 3*, *Application deployment on AKS*. It
    can be configured to handle HTTPS traffic. It can also be configured to route
    traffic to different back-end services based on the hostname, which is assigned
    by the **Domain Name System** (**DNS**) that is used to connect.
  prefs: []
  type: TYPE_NORMAL
- en: '`cert-manager` is a Kubernetes add-on that helps in automating the creation
    of TLS certificates. It also helps in the rotation of certificates when they are
    close to expiring. `cert-manager` can interface with Let''s Encrypt to request
    certificates automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will see how to set up Azure Application Gateway as a Kubernetes
    ingress, and `cert-manager` to interface with Let's Encrypt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Azure Application Gateway as a Kubernetes ingress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an ingress in front of a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding TLS support to an ingress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with setting up Azure Application Gateway as an ingress for AKS.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Azure Application Gateway as a Kubernetes ingress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An ingress in Kubernetes is an object that is used to route HTTP and HTTPS traffic
    from outside the cluster to services in a cluster. Exposing services using an
    ingress rather than exposing them directly, as you've done up to this point—has
    a number of advantages. These advantages include the ability to route multiple
    hostnames to the same public IP address and offloading TLS termination from the
    actual application to the ingress.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an ingress in Kubernetes, you need to install an ingress controller.
    An ingress controller is software that can create, configure, and manage ingresses
    in Kubernetes. Kubernetes does not come with a preinstalled ingress controller.
    There are multiple implementations of ingress controllers, and a full list is
    available at this URL: [https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/](https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/)'
  prefs: []
  type: TYPE_NORMAL
- en: In Azure, application gateway is a Layer 7 load balancer, which can be used
    as an ingress for Kubernetes by using the **Application Gateway Ingress Controller
    (AGIC)**. A layer 7 load balancer is a load balancer that works at the application
    layer, which is the seventh and highest layer in the OSI networking reference
    model. Azure Application Gateway has a number of advanced features such as autoscaling
    and **Web Application Firewall (WAF)**.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways of configuring the AGIC, either using Helm or as an **Azure
    Kubernetes Service** (**AKS**) add-on. Installing AGIC using the AKS add-on functionality
    will result in a Microsoft-supported configuration. Additionally, the add-on method
    of deployment will be automatically updated by Microsoft, ensuring that your environment
    is always up to date.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will create a new application gateway instance, set up
    AGIC using the add-on method, and finally, deploy an ingress resource to expose
    an application. Later in this chapter, you will extend this setup to also include
    TSL using a Let's Encrypt certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new application gateway
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you will use the Azure CLI to create a new application gateway.
    You will then use this application gateway in the next section to integrate with
    AGIC. The different steps in this section are summarized in the code samples for
    this chapter in the `setup-appgw.sh` file that is part of the code samples that
    come with this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To organize the resources created in this chapter, it is recommended that you
    create a new resource group. Make sure to create the new resource group in the
    same location you deployed your AKS cluster in. You can do this using the following
    command in the Azure CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you will need to create the networking components required for your application
    gateway. These are a public IP with a DNS name and a new virtual network. You
    can do this using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The az network public-ip create command might show you a warning message `[Coming
    breaking change] In the coming release, the default behavior will be changed as
    follows when sku is Standard and zone is not provided: For zonal regions, you
    will get a zone-redundant IP indicated by zones:["1","2","3"]; For non-zonal regions,
    you will get a non zone-redundant IP indicated by zones:[].`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, you can create the application gateway. This command will take a few
    minutes to execute
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will take a couple of minutes for the application gateway to deploy. Once
    it is created, you can see the resource in the Azure portal. To find this, look
    for `agic` (or the name you gave your application gateway) in the Azure search
    bar, and select your application gateway.![Searching for Application Gateway using
    the Azure portal search bar](img/B17338_06_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.1: Looking for the application gateway in the Azure search bar'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This will show you your application gateway in the Azure portal, as shown in
    *Figure 6.2*:![An overview of the Application Gateway pane in the Azure portal](img/B17338_06_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.2: The application gateway in the Azure portal'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To verify that it has been created successfully, browse to the DNS name you
    configured for the public IP address. This will show you an output similar to
    *Figure 6.3*. Note that the error message shown is expected since you haven't
    configured any applications yet behind the application gateway. You will configure
    applications behind the application gateway using AGIC in the *Adding an ingress
    rule for the guestbook application* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Browsing to the DNS name configured for the public IP address to verify if
    we can connect to the Application Gateway](img/B17338_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Verify that you can connect to the application gateway'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've created a new application gateway and were able to connect to
    it, we will move on to integrating this application gateway with your existing
    Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the AGIC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you will integrate the application gateway with your Kubernetes
    cluster using the AGIC AKS add-on. You will also set up virtual network peering
    so the application gateway can send traffic to your Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable integration between your cluster and your application gateway, use
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you will need to peer the application gateway network with the AKS network.
    To peer both networks, you can use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This concludes the integration between the application gateway and your AKS
    cluster. You've enabled the AGIC add-on, and connected both the networks together.
    In the next section, you will use this AGIC integration to create an ingress for
    a demo application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an ingress rule for the guestbook application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up to this point, you have created a new application gateway and integrated
    it with your Kubernetes cluster. In this section, you will deploy the guestbook
    application and then expose it using an ingress.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch the guestbook application, type in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will create the guestbook application you''ve used in the previous chapters.
    You should see the objects being created as shown in *Figure 6.4*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Creating the guestbook application that we’ve used in the previous chapters](img/B17338_06_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 6.4: Creating the guestbook application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can then use the following YAML file to expose the front-end service via
    the ingress. This is provided as `simple-frontend-ingress.yaml` in the source
    code for this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s have a look at what is defined in this YAML file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Ingress` object.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azure/application-gateway`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following lines define the actual ingress:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Lines 8-12**: Here, you define the path this ingress is listening on. In
    our case, this is the top-level path. In more advanced cases, you can have different
    paths pointing to different services.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 13-17**: These lines define the actual service this traffic should
    be pointed to.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use the following command to create this ingress:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you now go to http://dns-name/, which you created in the *Creating a new
    application gateway* section, you should get an output as shown in *Figure 6.5*:![Accessing
    the guestbook application via the ingress](img/B17338_06_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.5: Accessing the guestbook application via the ingress'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: You didn't have to publicly expose the front-end service as you have done in
    the preceding chapters. You have added the ingress as the exposed service, and
    the front-end service remains private to the cluster.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Flowchart displaying a publicly accessible ingress](img/B17338_06_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 6.6: Flowchart displaying publicly accessible ingress'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can verify this by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should show you that you have no public services, as seen by the lack
    of `EXTERNAL-IP` in *Figure 6.7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Output confirming that the front-end service remains private to the cluster](img/B17338_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Output shows that you have no public services'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you launched an instance of the guestbook application. You
    then exposed it publicly by creating an ingress, which in turn configured the
    application gateway that you created earlier. Only the ingress was publicly accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you'll extend the functionality of AGIC and learn how to secure traffic
    using a Certificate from Let's Encrypt.
  prefs: []
  type: TYPE_NORMAL
- en: Adding TLS to an ingress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will now add HTTPS support to your application. To do this, you need a TLS
    certificate. You will be using the `cert-manager` Kubernetes add-on to request
    a certificate from Let's Encrypt.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although this section focuses on using an automated service such as Let''s
    Encrypt, you can still pursue the traditional path of buying a certificate from
    an existing CA and importing it into Kubernetes. Please refer to the Kubernetes
    documentation for more information on how to do this: [https://kubernetes.io/docs/concepts/services-networking/ingress/#tls](https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
    )'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of steps involved. The process of adding HTTPS to the application
    involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Install `cert-manager`, which interfaces with the Let's Encrypt API to request
    a certificate for the domain name you specify.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the certificate issuer, which will get the certificate from Let's Encrypt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an SSL certificate for a given **Fully Qualified Domain Name** (**FQDN**).
    An FQDN is a fully qualified DNS record that includes the top-level domain name
    (such as .org or .com). You created an FQDN linked to your public IP in *step
    2* in the section *Creating a new application gateway*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Secure the front-end service by creating an ingress to the service with the
    certificate created in *step 3*. In the example in this section, you will not
    be executing this step as an individual step. You will, however, reconfigure the
    ingress to automatically pick up the certificate created in *step 3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start with the first step by installing `cert-manager` in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing cert-manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`cert-manager` ([https://github.com/jetstack/cert-manager](https://github.com/jetstack/cert-manager))
    is a Kubernetes add-on that automates the management and issuance of TLS certificates
    from various issuing sources. It is responsible for renewing certificates and
    ensuring they are updated periodically.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `cert-manager` project is not managed or maintained by Microsoft. It is
    an open-source solution previously managed by the company **Jetstack**, which
    recently donated it to the Cloud Native Computing Foundation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands install `cert-manager` in your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will install a number of components in your cluster as shown in *Figure
    6.8*. A detailed explanation of these components can be found in the `cert-manager`
    documentation at [https://cert-manager.io/docs/installation/kubernetes/](https://cert-manager.io/docs/installation/kubernetes/).
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing cert-manager on the cluster](img/B17338_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: Installing cert-manager in your cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '`cert-manager` makes use of a Kubernetes functionality called `cert-manager`,
    there are six CRDs that are created, some of which you will use later in this
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have installed `cert-manager`, you can move on to the next step:
    setting up a certificate issuer.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the certificate issuer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, you will install the Let''s Encrypt staging certificate issuer.
    A certificate can be issued by multiple issuers. `letsencrypt-staging`, for example,
    is for testing purposes. As you are building tests, you''ll use the staging server.
    The code for the certificate issuer has been provided in the source code for this
    chapter in the `certificate-issuer.yaml` file. As usual, use `kubectl create -f
    certificate-issuer.yaml`; the YAML file has the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at what we have defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cert-manager` created. In this case, specifically, you point to the `Issuer`
    object. An issuer is a link between your Kubernetes cluster and the actual certificate
    authority creating the certificate, which is Let''s Encrypt in this case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 6-10**: Here you provide the configuration for Let''s Encrypt and point
    to the staging server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 11-14**: This is additional configuration for the ACME client to certify
    domain ownership. You point Let''s Encrypt to the Azure Application Gateway ingress
    to verify that you own the domain you will request a certificate for later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the certificate issuer installed, you can now move on to the next step:
    creating the TLS certificate on the ingress.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the TLS certificate and securing the ingress
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you will create a TLS certificate. There are two ways you can
    configure `cert-manager` to create certificates. You can either manually create
    a certificate and link it to the ingress, or you can configure your ingress controller,
    so `cert-manager` automatically creates the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you will configure your ingress using the latter method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, edit the ingress to look like the following YAML code. This file
    is present in the source code on GitHub as `ingress-with-tls.yaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should make the following changes to the original ingress:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`acme-challenge` to prove domain ownership.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 20**: The domain name for the ingress is added here. This is required
    because Let''s Encrypt only issues certificates for domains.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 21-24**: This is the TLS configuration of the ingress. It contains the
    hostname as well as the name of the secret that will be created to store the certificate.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can update the ingress you created earlier with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It takes `cert-manager` about a minute to request a certificate and configure
    the ingress to use that certificate. While you are waiting for that, let's have
    a look at the intermediate resources that `cert-manager` created on your behalf.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First off, `cert-manager` created a `certificate` object for you. You can look
    at the status of that object using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This command will generate an output as shown in *Figure 6.9*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Output displaying the status of the certificate object  with ready as false](img/B17338_06_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 6.9: The status of the certificate object'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As you can see, the certificate isn''t ready yet. There is another object that
    `cert-manager` created to actually get the certificate. This object is `certificaterequest`.
    You can get its status by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will generate the output shown in *Figure 6.10*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Output displaying the status of the certificaterequest object as False](img/B17338_06_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While you''re waiting for the certificate to be issued, the status will look
    similar to *Figure 6.11*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Output displaying additional details about the certificaterequest object  showing
    that cert-manager is waiting on certificate issuance](img/B17338_06_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 6.11: Using the kubectl describe command to obtain details of the certificaterequest
    object'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, the `certificaterequest` object shows you that the order has
    been created and that it is pending.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After a couple of additional seconds, the `describe` command should return
    a successful certificate creation message. Run the following command to get the
    updated status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of this command is shown in *Figure 6.12*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Output displaying the successful certificate creation message](img/B17338_06_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 6.12: The issued certificate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This should now enable the front-end ingress to be served over HTTPS.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's try this out in a browser by browsing to the DNS name you created in the
    *Creating a new application gateway* section. Depending on your browser's cache,
    you might need to add `https://` in front of the URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you reach the ingress, it will indicate an error in the browser, showing
    you that the certificate isn''t valid, similar to *Figure 6.13*. This is to be
    expected since you are using the Let''s Encrypt staging server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Using the Let''s Encrypt staging server, the certificate isn''t trusted by
    default](img/B17338_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: Using the Let''s Encrypt staging server, the certificate isn''t
    trusted by default'
  prefs: []
  type: TYPE_NORMAL
- en: You can browse to your application by clicking **Advanced** and selecting **Continue**.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you successfully added a TLS certificate to your ingress to
    secure traffic to it. Since you were able to complete the test with the staging
    certificate, you can now move on to a production system.
  prefs: []
  type: TYPE_NORMAL
- en: Switching from staging to production
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, you will switch from a staging certificate to a production-level
    certificate. To do this, you can redo the previous exercise by creating a new
    issuer in your cluster, like the following (provided in `certificate-issuer-prod.yaml`
    as part of the code samples with this book). Don''t forget to change your email
    address in the file. The following code is contained in that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, replace the reference to the issuer in the `ingress-with-tls.yaml` file
    with `letsencrypt-prod` as shown (provided in the `ingress-with-tls-prod.yaml`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply these changes, execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It will again take about a minute for the certificate to become active. Once
    the new certificate is issued, you can browse to your DNS name again and shouldn''t
    see any more warnings regarding invalid certificates. If you click the padlock
    icon in the browser, you should see that your connection is secure and uses a
    valid certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The web page displaying a valid certificate](img/B17338_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: The web page displaying a valid certificate'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have learned how to add TLS support to an ingress. You
    did this by installing the `cert-manager` Kubernetes add-on. `cert-manager` got
    a free certificate from Let's Encrypt and added this to the existing ingress deployed
    on the application gateway. The process that was described here is not specific
    to Azure and Azure Application Gateway. This process of adding TLS to an ingress
    works with other ingress controllers as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s delete the resources you created during this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you added HTTPS security to the guestbook application without
    actually changing the source code. You started by setting up a new application
    gateway and configured AGIC on AKS. This gives you the ability to create Kubernetes
    ingresses that can be configured on the application gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you installed a certificate manager that interfaces with the Let's Encrypt
    API to request a certificate for the domain name we subsequently specified. You
    leveraged a certificate issuer to get the certificate from Let's Encrypt. You
    then reconfigured the ingress to request a certificate from this issuer in the
    cluster. Using these capabilities of both the certificate manager as well as the
    ingress, you are now able to secure your websites using TLS.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to monitor your deployments and set
    up alerts. You will also learn how to quickly identify root causes when errors
    do occur, and how to debug applications running on AKS. At the same time, you'll
    learn how to perform the correct fixes once you have identified the root causes.
  prefs: []
  type: TYPE_NORMAL
