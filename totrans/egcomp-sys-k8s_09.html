<html><head></head><body>
		<div id="_idContainer086">
			<h1 id="_idParaDest-182" class="chapter-number"><a id="_idTextAnchor181"/>9</h1>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor182"/>Edge Serverless and Event-Driven Architectures with Knative and Cloud Events</h1>
			<p>Serverless architecture reduces the costs of running distributed systems at scale. This use case is particularly useful in edge computing, where a lot of dedicated hardware and computational resources are used. This chapter covers how Knative can help you to implement APIs using serverless technologies. It also shows how to reduce costs and complexity using Knative for simple event-driven architectures and serverless functions to build your system. Across the chapter, we explain how Knative uses Cloud Events for its cloud event specification to call events, and how serverless can be helpful in the development of event-driven applications.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Serverless at the edge with Knative and Cloud Events</li>
				<li>Implementing serverless functions using Knative Serving</li>
				<li>Implementing a serverless API using traffic splitting with Knative</li>
				<li>Using declarative files in Knative</li>
				<li>Implementing events and event-driven pipelines using sequences with Knative Eventing</li>
			</ul>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor183"/>Technical requirements</h1>
			<p>For this chapter, you need the following:</p>
			<ul>
				<li>A single or multi-node K3s cluster using ARM devices with MetalLB installed and with the options to avoid Traefik being installed as the default ingress controller.</li>
				<li>kubectl configured to be used on your local machine to avoid using the <strong class="source-inline">--kubeconfig</strong> parameter.</li>
				<li>Clone the repository at <a href="https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch9">https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch9</a> if you want to run the YAML configuration by using <strong class="source-inline">kubectl apply</strong> instead of copying the code from the book. Take a look at the code for Python and YAML configurations inside the <strong class="source-inline">ch9</strong> directory.</li>
			</ul>
			<p>We are going to install Knative to implement simple use cases using serverless APIs and event-driven pipelines. Let’s understand what serverless architectures are and how can they help in edge computing environments.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor184"/>Serverless at the edge with Knative and Cloud Events</h1>
			<p>Edge computing is<a id="_idIndexMarker641"/> a paradigm that processes information near the source of data. This improves the response time of the application. It also saves bandwidth<a id="_idIndexMarker642"/> when the data is accessed because instead of getting data from the cloud, data is accessed near to the source. But <a id="_idIndexMarker643"/>one of the problems is that the services are always up and running. Here is where serverless can help to reduce costs, scaling <a id="_idIndexMarker644"/>down services when they are not used, helping to reduce additional costs compared with the traditional way of having services running all the time. </p>
			<p>Ben Ellerby, in his Medium article called <em class="italic">Why Serverless will enable the Edge Computing Revolution</em>, mentions that <em class="italic">Serverless enables us to build applications and services without thinking about the underlying servers</em>. This refers to thinking more about the applications instead of managing infrastructure. In this way, serverless technologies and cloud services have been increasing in popularity in recent years. Serverless cloud services only charge you for the execution time when you are using the service. You can often find serverless services as small code functions. Serverless technologies enabled event-driven architectures to flourish, because of their simplicity and low cost to implement new functionalities. According to the <a href="https://solace.com/">https://solace.com/</a> website, an event-driven architecture is a <em class="italic">software design pattern in which decoupled applications can asynchronously publish and subscribe to events via an event broker (modern messaging-oriented-middleware)</em>.</p>
			<p>One of the key aspects to evaluate when building a new system is the cost of implementation. This will be a common scenario for choosing serverless technologies. Serverless technologies implemented in on-premises scenarios could take advantage of the temporal use of resources to execute serverless functions. Knative implements serverless<a id="_idIndexMarker645"/> functions and events that <a id="_idIndexMarker646"/>can be used to implement <a id="_idIndexMarker647"/>event-driven applications. In addition, an event specification such as Cloud Events can help to standardize the communication of your services and define events:</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B16945_09_01.jpg" alt="Figure 9.1 – Knative architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Knative architecture</p>
			<p>Knative was<a id="_idIndexMarker648"/> born in Google, and it was given to the community as an open source project. Knative consists of two parts: Serving and Eventing. With Knative Serving, you can create serverless functions in Kubernetes. Knative Serving implements the features of networking, autoscaling, and revision tracking. This abstraction gives the user the ability to focus more on the logic of the business instead of managing infrastructure. On the other hand, Knative Eventing gives the user the ability to implement event-driven architectures and call functions created with the Serving feature. You can configure your events to use different sources and broker types to manage your events depending on your use case. After choosing a source and broker that fit your scenario, you can trigger sequences or simple calls of your functions.</p>
			<p>Cloud Events works together with Knative to give a standard structure to the events and have a uniform way<a id="_idIndexMarker649"/> to declare and call events. Cloud Events follows an event specification that is used to implement events. This structure has been adopted for <a id="_idIndexMarker650"/>different open source projects such as OpenFaaS, Tekton, Argo Events, Falco, Google Cloud Eventarc, and<a id="_idIndexMarker651"/> so on. The Cloud Events SDK is <a id="_idIndexMarker652"/>available for different programming languages such as Python and Go. This SDK will help you to describe cloud events through definitions such as ID, version of the cloud event specification, type, source, and content type.</p>
			<p>Knative and Cloud Events provide a way to implement serverless functions and event-driven architectures at the edge, for low-resource devices, and a lightweight implementation that permits cost-saving in an edge computing scenario.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">For more information about Knative, you can visit its official documentation: <a href="https://knative.dev/docs">https://knative.dev/docs</a>. For Cloud Events, you can visit its official website: <a href="https://cloudevents.io">https://cloudevents.io</a> or its specification 1.0, which is used in our examples: <a href="https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/spec.md">https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/spec.md</a>.</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor185"/>Implementing serverless functions using Knative Serving</h1>
			<p>To start building <a id="_idIndexMarker653"/>our simple <a id="_idIndexMarker654"/>use cases for serverless and event-driven use cases, we have to install Knative with Serving, Eventing, channels, and brokers. In this case, we are going to use the basic options using in-memory channels and Knative Eventing Sugar Controller, which creates Knative resources based on labels in your cluster or namespace. So, let’s start installing Knative Serving in the next section.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor186"/>Installing Knative Serving</h2>
			<p>In this section, we<a id="_idIndexMarker655"/> are going to start installing Knative Serving, which will be used to implement serverless functions. Let’s follow the next steps to install Knative Serving:</p>
			<ol>
				<li>Install the Knative CLI with the following command:<p class="source-code"><strong class="bold">$ brew install kn</strong></p></li>
			</ol>
			<p>To upgrade your current Knative binary, run the following:</p>
			<p class="source-code"><strong class="bold">$ brew upgrade kn</strong></p>
			<ol>
				<li value="2">Install the Knative Serving CRDs to install the serving components:<p class="source-code"><strong class="bold">$ kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.2.0/serving-crds.yaml</strong></p><p class="source-code"><strong class="bold">$ kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.2.0/serving-core.yaml</strong></p></li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">To learn <a id="_idIndexMarker656"/>more about <strong class="bold">Custom Resource Definitions</strong> (<strong class="bold">CRDs</strong>) you can check out this link: <a href="https://docs.openshift.com/aro/3/dev_guide/creating_crd_objects.html">https://docs.openshift.com/aro/3/dev_guide/creating_crd_objects.html</a>. You can also check the CRD documentation from the Kubernetes official website with the next link: <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources">https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources</a>.</p>
			<ol>
				<li value="3">Now install the Contour ingress controller, which will be used as the default for Knative (this component is available for ARM):<p class="source-code"><strong class="bold">$ kubectl apply -f https://github.com/knative/net-contour/releases/download/knative-v1.2.0/contour.yaml</strong></p></li>
				<li>Install the network component of Knative for other functionalities using the previous ingress running the following command:<p class="source-code"><strong class="bold">$ kubectl apply -f https://github.com/knative/net-contour/releases/download/knative-v1.2.0/net-contour.yaml</strong></p></li>
				<li>Then set Contour as the default ingress controller to be used by Knative:<p class="source-code"><strong class="bold">$ kubectl patch configmap/config-network \</strong></p><p class="source-code"><strong class="bold">  --namespace knative-serving \</strong></p><p class="source-code"><strong class="bold">  --type merge \</strong></p><p class="source-code"><strong class="bold">  --patch '{"data":{"ingress-class":"contour.ingress.networking.knative.dev"}}'</strong></p></li>
				<li>Get the IP that your Contour ingress controller created as the endpoint for your applications. In this case, we are going to call this IP <strong class="source-inline">EXTERNAL_IP</strong>:<p class="source-code"><strong class="bold">$ EXTERNAL_IP="$(kubectl get svc envoy -n contour-external  -o=jsonpath='{.status.loadBalancer.ingress[0].ip}')"</strong></p></li>
				<li>Set the<a id="_idIndexMarker657"/> domain that Knative is going to use to expose your serverless applications:<p class="source-code"><strong class="bold">$ KNATIVE_DOMAIN="$EXTERNAL_IP.nip.io"</strong></p><p class="source-code"><strong class="bold">$ kubectl patch configmap/config-domain \</strong></p><p class="source-code"><strong class="bold">--namespace knative-serving \</strong></p><p class="source-code"><strong class="bold">--type merge \</strong></p><p class="source-code"><strong class="bold">--patch '{"data":{"'$KNATIVE_DOMAIN'":""}}'</strong></p></li>
				<li>Now set the <strong class="bold">Horizontal Pod Autoscaler</strong> (<strong class="bold">HPA</strong>) feature of Knative Serving to run: <p class="source-code"><strong class="bold">$ kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.2.0/serving-hpa.yaml</strong></p></li>
				<li>Finally, perform simple troubleshooting for the Knative components running:<p class="source-code"><strong class="bold">$ kubectl get pods -n knative-serving</strong></p></li>
			</ol>
			<p>This will return the state of the pods of your Knative Serving installation. These pods should <a id="_idIndexMarker658"/>have a ready status after a few minutes.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">To uninstall the components, you can use <strong class="source-inline">kubectl delete</strong> instead of <strong class="source-inline">kubectl apply</strong>.</p>
			<p>Now Knative Serving is installed and ready to use. So, let’s move on to create a simple serverless function using Knative Serving in the next section.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor187"/>Creating a simple serverless function</h2>
			<p>Now it’s time <a id="_idIndexMarker659"/>to use Knative Serving. In<a id="_idIndexMarker660"/> this section, we are going to run a sample API using Python and Flask. The code will look like this:</p>
			<p class="source-code">from flask import Flask</p>
			<p class="source-code">from flask import jsonify</p>
			<p class="source-code">import os</p>
			<p class="source-code">import socket</p>
			<p class="source-code">app = Flask(__name__)</p>
			<p class="source-code">host = socket.gethostname()</p>
			<p class="source-code">msg = os.environ['MESSAGE']</p>
			<p class="source-code">@app.route('/')</p>
			<p class="source-code">def index():</p>
			<p class="source-code">    return jsonify({"host":host,"msg":msg})</p>
			<p class="source-code">if __name__ == '__main__': </p>
			<p class="source-code">    app.run(host='0.0.0.0', port=5000, debug=True)</p>
			<p>Every time you call the function, it is going to return the variable host with the container ID and <strong class="source-inline">msg</strong> with the value of the <strong class="source-inline">MESSAGE</strong> environment variable. This API will use port <strong class="source-inline">5000</strong>. This Python<a id="_idIndexMarker661"/> program is already packaged in a container. It was built and published <a id="_idIndexMarker662"/>on Docker Hub as <strong class="source-inline">sergioarmgpl/app2demo</strong>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You can explore how to build and customize this code in the GitHub repository: <a href="https://github.com/sergioarmgpl/containers">https://github.com/sergioarmgpl/containers</a>. </p>
			<p>Now, to deploy this API as a serverless function using Knative, follow the next steps:</p>
			<ol>
				<li value="1">Create your function with the following command:<p class="source-code"><strong class="bold">$ kn service create api \</strong></p><p class="source-code"><strong class="bold">--image sergioarmgpl/app2demo \</strong></p><p class="source-code"><strong class="bold">--port 5000 \</strong></p><p class="source-code"><strong class="bold">--env MESSAGE="Knative demo v1" \</strong></p><p class="source-code"><strong class="bold">--revision-name=v1</strong></p></li>
			</ol>
			<p>This <a id="_idIndexMarker663"/>command redirects port <strong class="source-inline">5000</strong> where your API is exposed in your container to the HTTP endpoint that Knative generates. It also receives the <strong class="source-inline">MESSAGE</strong> parameter with the <strong class="source-inline">Knative demo</strong> value and sets the revision of this function as <strong class="source-inline">v1</strong>. After running this command, you will get an output like this:</p>
			<p class="source-code"><strong class="bold">Service 'api' created to latest revision 'api-v1' is available at URL:</strong></p>
			<p class="source-code"><strong class="bold">http://api.default.192.168.0.54.nip.io</strong></p>
			<p>At the end of the output, you will find the endpoint for your function. In this output, we are assuming that the IP address assigned to the Contour ingress controller is <strong class="source-inline">192.168.0.54</strong>, which is the same value assigned to the <strong class="source-inline">EXTERNAL_IP</strong> variable. Knative creates the necessary pods for this function in the default namespace. Refer to the <em class="italic">Installing Knative Serving</em> section for more information about to how to get the IP assigned to your Contour ingress.</p>
			<ol>
				<li value="2">Now, access<a id="_idIndexMarker664"/> your function using the <strong class="source-inline">EXTERNAL_IP</strong> variable defined in the <em class="italic">Installing Knative Serving </em>section, by running the following command:<p class="source-code"><strong class="bold">$ curl http://api.default.$EXTERNAL_IP.nip.io</strong></p></li>
			</ol>
			<p>This command will return a JSON output in your terminal like this:</p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">  "host": "api-v1-deployment-84f568857d-cxv9z",</strong></p>
			<p class="source-code"><strong class="bold">  "msg": "Knative demo v1"</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<ol>
				<li value="3">To <a id="_idIndexMarker665"/>monitor the pods created for your function, run this:<p class="source-code"><strong class="bold">$ watch kubectl get pods</strong></p></li>
				<li>After 2 minutes of inactivity for your functions, the pods created to run your functions will be scaled down. If you execute <strong class="source-inline">watch kubectl get pods</strong>, you will see a similar output to this:<p class="source-code"><strong class="bold">NAME             READY   STATUS</strong></p><p class="source-code"><strong class="bold">api-v1           2/2     Running</strong></p><p class="source-code"><strong class="bold">api-v1           2/2     Terminating</strong></p><p class="source-code"><strong class="bold">api-v1           1/2     Terminating</strong></p><p class="source-code"><strong class="bold">api-v1           0/2     Terminating</strong></p></li>
				<li>Open another terminal and execute <strong class="source-inline">watch kubectl get pods</strong>, and then call the function again. The pods of the function will be scaled up and you will see a similar output to this:<p class="source-code"><strong class="bold">NAME             READY   STATUS</strong></p><p class="source-code"><strong class="bold">api-v1           0/2     Pending</strong></p><p class="source-code"><strong class="bold">api-v1           0/2     ContainerCreating</strong></p><p class="source-code"><strong class="bold">api-v1           1/2     Running</strong></p><p class="source-code"><strong class="bold">api-v1           2/2     Running</strong></p></li>
			</ol>
			<p>With <a id="_idIndexMarker666"/>the scaling to zero<a id="_idIndexMarker667"/> functionality, you can cut costs in your cloud infrastructure when your functions have an idle status after 2 minutes of inactivity.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The <strong class="source-inline">watch</strong> command might not be installed on your operating system. This can be installed with the <strong class="source-inline">yum</strong> or <strong class="source-inline">apt</strong> command on Linux, or the <strong class="source-inline">brew</strong> command on macOS.</p>
			<ol>
				<li value="6">Check the created services in the default namespace using the following command:<p class="source-code"><strong class="bold">$ kn service list</strong></p></li>
			</ol>
			<p>Or, run the following command to check the available functions in a specific namespace:</p>
			<p class="source-code"><strong class="bold">$ kn service list -n &lt;YOUR_NAMESPACE&gt;</strong></p>
			<ol>
				<li value="7">To check your current revisions, run the following:<p class="source-code"><strong class="bold">$ kn revisions list</strong></p></li>
				<li>(<em class="italic">Optional</em>) If you don’t want to create a public endpoint for your function, use the <strong class="source-inline">--cluster-local</strong> flag for the <strong class="source-inline">kn</strong> command to create a private endpoint. To create the same function but with a private endpoint, use the following command:<p class="source-code"><strong class="bold">$ kn service create api --cluster-local \</strong></p><p class="source-code"><strong class="bold">--image sergioarmgpl/app2demo \</strong></p><p class="source-code"><strong class="bold">--port 5000 \</strong></p><p class="source-code"><strong class="bold">--env MESSAGE="Knative demo v1" \</strong></p><p class="source-code"><strong class="bold">--revision-name=v1</strong></p></li>
			</ol>
			<p>At the<a id="_idIndexMarker668"/> end of the output, you <a id="_idIndexMarker669"/>will see something like this:</p>
			<p class="source-code"><strong class="bold">Service 'api' created to latest revision 'api-v1' is available at URL:</strong></p>
			<p class="source-code"><strong class="bold">http://api.default.svc.cluster.local</strong></p>
			<p>This endpoint will be the URL service that Knative creates for you, which is the same service object used in Kubernetes.</p>
			<ol>
				<li value="9">(<em class="italic">Optional</em>) To access this endpoint, you have to call it inside the cluster. To do this, create a client container that contains <strong class="source-inline">curl</strong>. Run the following command:<p class="source-code"><strong class="bold">$ kubectl run curl -it --rm --image=curlimages/curl:7.81.0 /bin/sh</strong></p></li>
			</ol>
			<p>Once the pod is created, you have to run the following command to access the function:</p>
			<p class="source-code"><strong class="bold">$ curl http://api.default.svc.cluster.local</strong></p>
			<p>The output will look like this:</p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">  "host": "api-v1-deployment-776c896776-vxhhk",</strong></p>
			<p class="source-code"><strong class="bold">  "msg": "Knative demo v1"</strong></p>
			<p class="source-code"><strong class="bold">}</strong> </p>
			<ol>
				<li value="10">To <a id="_idIndexMarker670"/>delete the serverless<a id="_idIndexMarker671"/> function created in this section, run this:<p class="source-code"><strong class="bold">$ kn service delete hello</strong></p></li>
			</ol>
			<p>Now, you know how to create serverless functions to implement a simple API using Knative Serving and scale to zero functionality to save costs. It’s time to implement the traffic splitting functionality using Knative Serving in the next section.</p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor188"/>Implementing a serverless API using traffic splitting with Knative</h1>
			<p>Knative has <a id="_idIndexMarker672"/>traffic splitting functionality that consists of distributing the traffic across two or more versions within a service but uses a proxy to implement this feature. By default, it uses Istio. For this<a id="_idIndexMarker673"/> implementation, we are using Contour, an Envoy-based proxy that consumes fewer resources than Istio. Both Istio and Contour use Envoy, a layer 7 proxy to implement service mesh capabilities such as traffic splitting. Traffic splitting could be used to implement deployment strategies such as canary and blue-green deployments, and also could be used to simulate faulty traffic for some basic chaos engineering scenarios. In this section, we are going to implement traffic splitting for the previous API function created in the <em class="italic">Creating a simple serverless function </em>section. In that section, we created a function called <strong class="source-inline">api</strong> with the revision name <strong class="source-inline">v1</strong>. Now we are going to update this function with another revision called <strong class="source-inline">v2</strong>. This revision just changes the <strong class="source-inline">MESSAGE</strong> value that is shown when you call the function. For this example, we are going to split traffic with 50% to revision <strong class="source-inline">v1</strong> and 50% to revision <strong class="source-inline">v2</strong>.</p>
			<p>To implement this scenario, follow the next steps:</p>
			<ol>
				<li value="1">Update the current <strong class="source-inline">api</strong> function with the new revision, <strong class="source-inline">v2</strong>, which has the value of the  <strong class="source-inline">MESSAGE</strong> variable with <strong class="source-inline">Knative demo v2</strong>, for this run:<p class="source-code"><strong class="bold">$ kn service update api \</strong></p><p class="source-code"><strong class="bold">--env MESSAGE="Knative demo v2" \</strong></p><p class="source-code"><strong class="bold">--revision-name=v2</strong></p></li>
			</ol>
			<p>The output of this command will look like this:</p>
			<p class="source-code"><strong class="bold">Service hello created to latest revision 'api-v2' is available at URL: http://api.default.192.168.0.54.nip.io</strong></p>
			<ol>
				<li value="2">Let’s <a id="_idIndexMarker674"/>check <a id="_idIndexMarker675"/>the revisions of our <strong class="source-inline">api</strong> function with the following command:<p class="source-code"><strong class="bold">$ kn revisions list</strong></p></li>
			</ol>
			<p>Wit<a id="_idTextAnchor189"/>h this command, you will see that 100% of the traffic will be processed by the <strong class="source-inline">v2</strong> revision. The output will look like this:</p>
			<p class="source-code"><strong class="bold">NAME     SERVICE   TRAFFIC </strong></p>
			<p class="source-code"><strong class="bold">api-v2   api       100%</strong></p>
			<p class="source-code"><strong class="bold">api-v1   api</strong></p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">We are omitting the <strong class="source-inline">TAGS</strong>, <strong class="source-inline">GENERATION</strong>, <strong class="source-inline">AGE</strong>, <strong class="source-inline">CONDITIONS</strong>, <strong class="source-inline">READY</strong>, and <strong class="source-inline">REASON</strong> fields of the output for learning purposes. We are assuming that the IP address assigned to the Contour ingress controller is <strong class="source-inline">192.168.0.54</strong>, which is the same value assigned to the <strong class="source-inline">EXTERNAL_IP</strong> variable.</p>
			<ol>
				<li value="3">Set the traffic splitting to 50% for version <strong class="source-inline">v1</strong> and 50% for version <strong class="source-inline">v2</strong>:<p class="source-code"><strong class="bold">$ kn service update api \</strong></p><p class="source-code"><strong class="bold">--traffic api-v1=50 \</strong></p><p class="source-code"><strong class="bold">--traffic @latest=50</strong></p></li>
			</ol>
			<p>The expected output will look like this:</p>
			<p class="source-code"><strong class="bold">Service 'api' with latest revision 'api-v2' (unchanged) is available at URL:</strong></p>
			<p class="source-code"><strong class="bold">http://api.default.192.168.0.54.nip.io</strong></p>
			<p>You can also use <strong class="source-inline">api-v2</strong> instead of the <strong class="source-inline">@latest</strong> option. You can also customize<a id="_idIndexMarker676"/> your parameter with your own versions and different traffic splitting rates.</p>
			<ol>
				<li value="4">Let’s check <a id="_idIndexMarker677"/>how traffic is distributed across the <strong class="source-inline">api</strong> function after setting the traffic splitting by running this:<p class="source-code"><strong class="bold">$ kn revisions list</strong></p></li>
			</ol>
			<p>The output will look like this:</p>
			<p class="source-code"><strong class="bold">NAME     SERVICE   TRAFFIC</strong></p>
			<p class="source-code"><strong class="bold">api-v2   api       50%</strong></p>
			<p class="source-code"><strong class="bold">api-v1   api       50%</strong></p>
			<p>You will see that the traffic is split by 50% for each revision.</p>
			<ol>
				<li value="5">Let’s send traffic to our function with a simple <strong class="source-inline">BASH</strong> loop script that you can stop with <em class="italic">Ctrl</em> + <em class="italic">C</em> by running the following command:<p class="source-code"><strong class="bold">$ while true; do curl http://api.default.$EXTERNAL_IP.nip.io;echo "";sleep 0.3; done</strong></p></li>
			</ol>
			<p>This command is going to continuously call your function that is split in to two versions every 0.3 seconds. The latest available revision will be running by default. In this case revision <strong class="source-inline">v2</strong> will be available for responses. After waiting a few seconds <strong class="source-inline">v1</strong> is provisioned and the output starts to show that the traffic is split by 50% for each revision. The output will look something like this:</p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">  "host": "api-v1-deployment-85f6f977b5-hcgdz",</strong></p>
			<p class="source-code"><strong class="bold">  "msg": "Knative demo v1"</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code"><strong class="bold"> </strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">  "host": "api-v1-deployment-85f6f977b5-hcgdz",</strong></p>
			<p class="source-code"><strong class="bold">  "msg": "Knative demo v2"</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p>Use <em class="italic">Ctrl</em> + <em class="italic">C</em> to stop the <strong class="source-inline">BASH</strong> loop.</p>
			<ol>
				<li value="6">If you <a id="_idIndexMarker678"/>want to <a id="_idIndexMarker679"/>check the pods of this traffic splitting, run the following command:<p class="source-code"><strong class="bold">$ kubectl get pods -o=custom-columns=NAME:.metadata.name,STATUS:.status.phase</strong></p></li>
			</ol>
			<p>The output will look like this:</p>
			<p class="source-code"><strong class="bold">NAME                                 STATUS</strong></p>
			<p class="source-code"><strong class="bold">api-v1-deployment-85f6f977b5-jhss5   Running</strong></p>
			<p class="source-code"><strong class="bold">api-v2-deployment-b97859489-mtvjm    Running</strong></p>
			<p>In this output, there are two pods running – one for revision <strong class="source-inline">v1</strong> and the other for <strong class="source-inline">v2</strong>. These pods are created on demand. By the default one of these revisions will be running if idle time was not exceeded to be called down. After requests start coming, the other revision is scaled up to start splitting the traffic between these pods by 50% each.</p>
			<ol>
				<li value="7">Finally, you can delete your API function with all your revisions running:<p class="source-code"><strong class="bold">$ kn service delete api</strong></p></li>
			</ol>
			<p>Now you have learned how to use traffic splitting and revisions in Knative. Now let’s go deep into Knative, learning how to use declarative files to create services in the next section.</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor190"/>Using declarative files in Knative</h1>
			<p>A <a id="_idIndexMarker680"/>good practice when creating environments is to create <a id="_idIndexMarker681"/>declarative definitions for your applications. Knative supports this with the <strong class="source-inline">--target</strong> flag. For example, if you want to change the previous example into a YAML file, you could use this flag. To do this, run the following command:</p>
			<p class="source-code">$ kn service create api --cluster-local \</p>
			<p class="source-code">--image sergioarmgpl/app2demo \</p>
			<p class="source-code">--port 5000 \</p>
			<p class="source-code">--env MESSAGE="Knative demo v1" \</p>
			<p class="source-code">--revision-name=v1 --target=api.yaml</p>
			<p>This command outputs a YAML file with the definition of an API function, without a public endpoint. The output in the <strong class="source-inline">api.yaml</strong> file will look like this:</p>
			<p class="source-code">apiVersion: serving.knative.dev/v1</p>
			<p class="source-code">kind: Service</p>
			<p class="source-code">metadata:</p>
			<p class="source-code">  labels:</p>
			<p class="source-code">    networking.knative.dev/visibility: cluster-local</p>
			<p class="source-code">  name: api</p>
			<p class="source-code">  namespace: default</p>
			<p class="source-code">spec:</p>
			<p class="source-code">  template:</p>
			<p class="source-code">    metadata:</p>
			<p class="source-code">      annotations:</p>
			<p class="source-code">        autoscaling.knative.dev/max-scale: "5"</p>
			<p class="source-code">        containerConcurrency: 2</p>
			<p class="source-code">      name: api-v1</p>
			<p class="source-code">    spec:</p>
			<p class="source-code">      containers:</p>
			<p class="source-code">      - env:</p>
			<p class="source-code">        - name: MESSAGE</p>
			<p class="source-code">          value: "Knative demo v1"</p>
			<p class="source-code">        image: sergioarmgpl/app2demo</p>
			<p class="source-code">        name: ""</p>
			<p class="source-code">        ports:</p>
			<p class="source-code">        - containerPort: 5000</p>
			<p>In the<a id="_idIndexMarker682"/> <strong class="source-inline">annotations</strong> section, you can configure different<a id="_idIndexMarker683"/> features that Knative provides; for example, autoscaling, rate limits, concurrency, and so on. In this case, we used <strong class="source-inline">autoscaling.knative.dev/max-scale</strong> to set the maximum replicas for the deployment of the function and <strong class="source-inline">containerConcurrency</strong> to set the number of simultaneous requests for each replica in the function. </p>
			<p>Another example is how you can define the YAML for traffic splitting. Based on our previous traffic splitting example in the <em class="italic">Implementing a serverless API using traffic splitting with Knative</em> section, to generate the equivalent YAML configuration use the following command:</p>
			<p class="source-code">$ kn service update api \</p>
			<p class="source-code">--traffic api-v1=50 \</p>
			<p class="source-code">--traffic @latest=50 --target=api.yaml</p>
			<p>The output will look like this:</p>
			<p class="source-code">apiVersion: serving.knative.dev/v1</p>
			<p class="source-code">kind: Service</p>
			<p class="source-code">metadata:</p>
			<p class="source-code">  labels:</p>
			<p class="source-code">    networking.knative.dev/visibility: cluster-local</p>
			<p class="source-code">  name: api</p>
			<p class="source-code">  namespace: default</p>
			<p class="source-code">spec:</p>
			<p class="source-code">  traffic:</p>
			<p class="source-code">  - latestRevision: true</p>
			<p class="source-code">    percent: 50</p>
			<p class="source-code">  - latestRevision: false</p>
			<p class="source-code">    percent: 50</p>
			<p class="source-code">    revisionName: api-v1</p>
			<p class="source-code">  template:</p>
			<p class="source-code">    metadata:</p>
			<p class="source-code">      annotations:</p>
			<p class="source-code">        autoscaling.knative.dev/max-scale: "5"</p>
			<p class="source-code">        containerConcurrency: "2"</p>
			<p class="source-code">      name: api-v1</p>
			<p class="source-code">    spec:</p>
			<p class="source-code">      containers:</p>
			<p class="source-code">      - env:</p>
			<p class="source-code">        - name: MESSAGE</p>
			<p class="source-code">          value: "Knative demo v1"</p>
			<p class="source-code">        image: sergioarmgpl/app2demo</p>
			<p class="source-code">        name: ""</p>
			<p class="source-code">        ports:</p>
			<p class="source-code">        - containerPort: 5000</p>
			<p>This is a <a id="_idIndexMarker684"/>desirable feature and best practice. To have declarative<a id="_idIndexMarker685"/> definitions for creating your functions and other Knative objects, you can explore the official documentation of Knative to find examples of declarative definitions. Now it’s time to move on to install another feature, Knative Eventing, in the next section.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor191"/>Implementing events and event-driven pipelines using sequences with Knative Eventing</h1>
			<p>Knative<a id="_idIndexMarker686"/> provides Eventing components to implement event-driven architectures. We are going to explore a simple<a id="_idIndexMarker687"/> Eventing pipeline with Knative using the lightweight in-memory channel component to implement two simple events that call a service showing a message. In the second part, we are going to implement a simple sequence that calls two servers sequentially, one after the other, showing custom messages. So, let’s get started with the first part to implement simple events.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor192"/>Installing Knative Eventing</h2>
			<p>Before creating <a id="_idIndexMarker688"/>our events, we need to install all the Knative components. We are going to use the in-memory channel to manage our events, which is the simplest and most lightweight channel implemented in Knative, and Sugar Controller to provision Knative Eventing resources in namespaces using labels. To get started with installing Knative Eventing, follow the next steps:</p>
			<ol>
				<li value="1">Install the Knative Eventing CRDs:<p class="source-code"><strong class="bold">$ kubectl apply -f https://github.com/knative/eventing/releases/download/knative-v1.2.0/eventing-crds.yaml</strong></p></li>
				<li>Install Knative Eventing core components by running the following command:<p class="source-code"><strong class="bold">$ kubectl apply -f https://github.com/knative/eventing/releases/download/knative-v1.2.0/eventing-core.yaml</strong></p></li>
				<li>Now install the in-memory channel component by running this:<p class="source-code"><strong class="bold">$ kubectl apply -f https://github.com/knative/eventing/releases/download/knative-v1.2.0/in-memory-channel.yaml</strong></p></li>
				<li>Now <a id="_idIndexMarker689"/>install the MT channel broker, which is a lightweight and simple implementation to use the in-memory channel:<p class="source-code"><strong class="bold">$ kubectl apply -f https://github.com/knative/eventing/releases/download/knative-v1.2.0/mt-channel-broker.yaml</strong></p></li>
				<li>Finally, install Knative Eventing Sugar Controller, which reacts to special labels and annotations and produces Eventing resources:<p class="source-code"><strong class="bold">$ kubectl apply -f https://github.com/knative/eventing/releases/download/knative-v1.2.0/eventing-sugar-controller.yaml</strong></p></li>
				<li>Check whether all the components have a <strong class="source-inline">READY</strong> status by running the following command:<p class="source-code"><strong class="bold">$ kubectl get pods -n knative-eventing -o=custom-columns=NAME:.metadata.name,STATUS:.status.phase</strong></p></li>
			</ol>
			<p>You will see a similar output to this:</p>
			<p class="source-code"><strong class="bold">NAME                                   STATUS</strong></p>
			<p class="source-code"><strong class="bold">mt-broker-filter-574dc4457f-pjs7z      Running</strong></p>
			<p class="source-code"><strong class="bold">imc-dispatcher-7fcb4b5d8c-qxrq2        Running</strong></p>
			<p class="source-code"><strong class="bold">mt-broker-controller-8d979648f-6st56   Running</strong></p>
			<p class="source-code"><strong class="bold">sugar-controller-6dd4c4bc5f-76kqc      Running</strong></p>
			<p class="source-code"><strong class="bold">mt-broker-ingress-5ddd6f8b5d-h94z5     Running</strong></p>
			<p class="source-code"><strong class="bold">eventing-webhook-5968f79978-5nhlc      Running</strong></p>
			<p class="source-code"><strong class="bold">eventing-controller-58875c5478-n8xzl   Running</strong></p>
			<p class="source-code"><strong class="bold">imc-controller-86cd7b7857-hpcpq        Running</strong></p>
			<p>Now you<a id="_idIndexMarker690"/> have installed all the necessary components to implement a simple event-driven pipeline using Knative. Let’s move to the next section to learn how to implement events.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor193"/>Implementing a simple event</h2>
			<p>Now it’s time <a id="_idIndexMarker691"/>to implement some basic events. This scenario consists of creating two services and calling them with their attribute type. First, let’s explore the code inside the container that is in Docker Hub called <strong class="source-inline">sergioarmgpl/app3demo</strong>. The code used is this:</p>
			<p class="source-code">from flask import Flask, request</p>
			<p class="source-code">from cloudevents.http import from_http</p>
			<p class="source-code">app = Flask(__name__)</p>
			<p class="source-code"> </p>
			<p class="source-code">@app.route("/", methods=["POST"])</p>
			<p class="source-code">def route():</p>
			<p class="source-code">    event = from_http(request.headers, request.get_data())</p>
			<p class="source-code">    app.logger.warning(event)</p>
			<p class="source-code">    return "", 204</p>
			<p class="source-code"> </p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    app.run(debug=True, host='0.0.0.0',port=5000)</p>
			<p>This code <a id="_idIndexMarker692"/>receives the call and transforms the data of the requests using the Cloud Events library to output the event with the <strong class="source-inline">app.logger.warning</strong> function implemented in Flask. So, every time the application is called in the <strong class="source-inline">/</strong> route path, it is going to show the information of the request that is calling the container using the Cloud Events structure format in the logs. In this case, we are not returning any data in response. It just returns HTTP status response code <strong class="source-inline">204</strong>, which refers to a successful request call. You can also customize this code if necessary to fit your needs.</p>
			<p>Now we have to create two services using YAML definitions. The first service will be called <strong class="source-inline">api-demo</strong>, and the second <strong class="source-inline">api-demo2</strong>. These services will be called every time the broker is called, sending their cloud event’s attributes. When the attribute type is set to <strong class="source-inline">event.show</strong>, the <strong class="source-inline">api-demo</strong> service is called, and when the broker is called with the <strong class="source-inline">attribute</strong> type set to <strong class="source-inline">event.show.2</strong>, the <strong class="source-inline">api-demo2</strong> service will be called. Both services are configured to listen on port <strong class="source-inline">5000</strong> and forward requests to port <strong class="source-inline">80</strong> to properly work with Knative Eventing.</p>
			<p>To start implementing the first scenario, follow the next steps:</p>
			<ol>
				<li value="1">Create and inject the <strong class="source-inline">event-demo</strong> namespace where the event is going to be created:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: Namespace</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: event-demo</strong></p><p class="source-code"><strong class="bold">  labels:</strong></p><p class="source-code"><strong class="bold">       eventing.knative.dev/injection: enabled</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Create the default broker to use for this implementation:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: eventing.knative.dev/v1</strong></p><p class="source-code"><strong class="bold">kind: Broker</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: default</strong></p><p class="source-code"><strong class="bold">  namespace: event-demo</strong></p><p class="source-code"><strong class="bold">  annotations:</strong></p><p class="source-code"><strong class="bold">    eventing.knative.dev/broker.class: MTChannelBasedBroker</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Deploy <a id="_idIndexMarker693"/>the container that is going to process the event:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: apps/v1 </strong></p><p class="source-code"><strong class="bold">kind: Deployment </strong></p><p class="source-code"><strong class="bold">metadata: </strong></p><p class="source-code"><strong class="bold">  labels: </strong></p><p class="source-code"><strong class="bold">    app: api-demo </strong></p><p class="source-code"><strong class="bold">  name: api-demo </strong></p><p class="source-code"><strong class="bold">  namespace: event-demo </strong></p><p class="source-code"><strong class="bold">spec: </strong></p><p class="source-code"><strong class="bold">  replicas: 1 </strong></p><p class="source-code"><strong class="bold">  selector: </strong></p><p class="source-code"><strong class="bold">    matchLabels: </strong></p><p class="source-code"><strong class="bold">      app: api-demo </strong></p><p class="source-code"><strong class="bold">  template:</strong></p><p class="source-code"><strong class="bold">    metadata: </strong></p><p class="source-code"><strong class="bold">      labels: </strong></p><p class="source-code"><strong class="bold">        app: api-demo </strong></p><p class="source-code"><strong class="bold">    spec: </strong></p><p class="source-code"><strong class="bold">      containers: </strong></p><p class="source-code"><strong class="bold">      - image: sergioarmgpl/app3demo </strong></p><p class="source-code"><strong class="bold">        name: app3demo</strong></p><p class="source-code"><strong class="bold">        imagePullPolicy: Always</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Create <a id="_idIndexMarker694"/>the service for this <strong class="source-inline">api-demo</strong> deployment:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: Service</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  labels:</strong></p><p class="source-code"><strong class="bold">    app: api-demo</strong></p><p class="source-code"><strong class="bold">  name: api-demo</strong></p><p class="source-code"><strong class="bold">  namespace: event-demo</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  ports:</strong></p><p class="source-code"><strong class="bold">  - port: 80</strong></p><p class="source-code"><strong class="bold">    protocol: TCP</strong></p><p class="source-code"><strong class="bold">    targetPort: 5000</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    app: api-demo</strong></p><p class="source-code"><strong class="bold">  type: ClusterIP</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Create a <a id="_idIndexMarker695"/>trigger to be consumed by the service:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: eventing.knative.dev/v1</strong></p><p class="source-code"><strong class="bold">kind: Trigger</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: api-demo</strong></p><p class="source-code"><strong class="bold">  namespace: event-demo</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  broker: default</strong></p><p class="source-code"><strong class="bold">  filter:</strong></p><p class="source-code"><strong class="bold">    attributes:</strong></p><p class="source-code"><strong class="bold">      type: event.show</strong></p><p class="source-code"><strong class="bold">  subscriber:</strong></p><p class="source-code"><strong class="bold">    ref:</strong></p><p class="source-code"><strong class="bold">      apiVersion: v1</strong></p><p class="source-code"><strong class="bold">      kind: Service</strong></p><p class="source-code"><strong class="bold">      name: api-demo</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Create a pod in the <strong class="source-inline">event-demo</strong> namespace to call the broker. This broker is going to call our pod that shows the message <strong class="bold">Simple Event using Knative</strong>. To create this pod, run this:<p class="source-code"><strong class="bold">$ kubectl run -n event-demo curl -it --rm --image=curlimages/curl:7.81.0 /bin/sh</strong></p></li>
				<li>Inside this pod, run the <strong class="source-inline">curl</strong> command to send a request to the broker. The broker will<a id="_idIndexMarker696"/> take the parameters of the previously implemented cloud event to send it to your pod. To call the broker, run this:<p class="source-code"><strong class="bold">$ curl -v "broker-ingress.knative-eventing.svc.cluster.local/event-demo/default" \</strong></p><p class="source-code"><strong class="bold">-X POST \</strong></p><p class="source-code"><strong class="bold">-H "Ce-Id: call-api-demo" \</strong></p><p class="source-code"><strong class="bold">-H "Ce-specversion: 1.0" \</strong></p><p class="source-code"><strong class="bold">-H "Ce-Type: event.show" \</strong></p><p class="source-code"><strong class="bold">-H "Ce-Source: test-send" \</strong></p><p class="source-code"><strong class="bold">-H "Content-Type: application/json" \</strong></p><p class="source-code"><strong class="bold">-d '{"msg":"Simple Event using Knative."}'</strong></p></li>
			</ol>
			<p>The output will look like this:</p>
			<p class="source-code"><strong class="bold">* Connected to broker-ingress.knative-eventing.svc.cluster.local (10.43.130.39) port 80 (#0)</strong></p>
			<p class="source-code"><strong class="bold">&gt; POST /event-demo/default HTTP/1.1</strong></p>
			<p class="source-code"><strong class="bold">&gt; Host: broker-ingress.knative-eventing.svc.cluster.local</strong></p>
			<p class="source-code"><strong class="bold">&gt; User-Agent: curl/7.81.0-DEV</strong></p>
			<p class="source-code"><strong class="bold">&gt; Accept: */*</strong></p>
			<p class="source-code"><strong class="bold">&gt; Ce-Id: 536808d3-88be-4077-9d7a-a3f162705f79</strong></p>
			<p class="source-code"><strong class="bold">&gt; Ce-specversion: 0.3</strong></p>
			<p class="source-code"><strong class="bold">&gt; Ce-Type: dev.knative.myevents.api-demo</strong></p>
			<p class="source-code"><strong class="bold">&gt; Ce-Source: dev.knative.myevents/api-demo-source</strong></p>
			<p class="source-code"><strong class="bold">&gt; Content-Type: application/json</strong></p>
			<p class="source-code"><strong class="bold">&gt; Content-Length: 37</strong></p>
			<p class="source-code"><strong class="bold">&gt;</strong></p>
			<p class="source-code"><strong class="bold">* Mark bundle as not supporting multiuse</strong></p>
			<p class="source-code"><strong class="bold">&lt; HTTP/1.1 202 Accepted</strong></p>
			<p class="source-code"><strong class="bold">&lt; Allow: POST, OPTIONS</strong></p>
			<p class="source-code"><strong class="bold">&lt; Date: Thu, 24 Feb 2022 05:30:13 GMT</strong></p>
			<p class="source-code"><strong class="bold">&lt; Content-Length: 0</strong></p>
			<p class="source-code"><strong class="bold">&lt;</strong></p>
			<p class="source-code"><strong class="bold">* Connection #0 to host broker-ingress.knative-eventing.svc.cluster.local left intact</strong></p>
			<ol>
				<li value="8">To exit, run <a id="_idIndexMarker697"/>the next command inside the pod:<p class="source-code"><strong class="bold">$ exit</strong></p></li>
				<li>Now inspect the logs of the pod by running the following command:<p class="source-code"><strong class="bold">$ kubectl -n event-demo logs -l app=api-demo --tail=50</strong></p></li>
			</ol>
			<p>Or, if you want to see the log in real time, when you call the broker that calls your pod, run the following command:</p>
			<p class="source-code"><strong class="bold">$ kubectl -n event-demo logs -f -l app=api-demo</strong></p>
			<p>The output will look like this:</p>
			<p class="source-code"><strong class="bold">* Serving Flask app 'index' (lazy loading)</strong></p>
			<p class="source-code"><strong class="bold">* Environment: production</strong></p>
			<p class="source-code"><strong class="bold">   WARNING: This is a development server. Do not use it in a production deployment.</strong></p>
			<p class="source-code"><strong class="bold">   Use a production WSGI server instead.</strong></p>
			<p class="source-code"><strong class="bold">* Debug mode: on</strong></p>
			<p class="source-code"><strong class="bold">* Running on all addresses.</strong></p>
			<p class="source-code"><strong class="bold">   WARNING: This is a development server. Do not use it in a production deployment.</strong></p>
			<p class="source-code"><strong class="bold">* Running on http://10.42.0.42:5000/ (Press CTRL+C to quit)</strong></p>
			<p class="source-code"><strong class="bold">* Restarting with stat</strong></p>
			<p class="source-code"><strong class="bold">* Debugger is active!</strong></p>
			<p class="source-code"><strong class="bold">* Debugger PIN: 110-221-376</strong></p>
			<p class="source-code"><strong class="bold">[2022-02-27 06:02:02,107] WARNING in index: {'attributes': {'specversion': '1.0', 'id': 'call-api-demo', 'source': 'test-send', 'type': 'event.show', 'datacontenttype': 'application/json', 'knativearrivaltime': '2022-02-27T06:02:02.069191004Z', 'time': '2022-02-27T06:02:02.107288+00:00'}, 'data': {'msg': 'Simple Event using Knative.'}}</strong></p>
			<p>As you can see, the pod got the <strong class="source-inline">msg</strong> value <strong class="source-inline">Simple Event using Knative.</strong> and<a id="_idIndexMarker698"/> it’s printed in the logs of the pod. This means that when you call the broker, the trigger calls the pod exposed using the service that was previously created.</p>
			<p>Let’s say, for example, that you want to create another event, using the same image. This time, let’s call it <strong class="source-inline">api-demo2</strong> for the second service. Create the next YAML definitions:</p>
			<ol>
				<li value="1">To create the <strong class="source-inline">api-demo2</strong> deployment, run the following:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: apps/v1 </strong></p><p class="source-code"><strong class="bold">kind: Deployment </strong></p><p class="source-code"><strong class="bold">metadata: </strong></p><p class="source-code"><strong class="bold">  labels: </strong></p><p class="source-code"><strong class="bold">    app: api-demo2 </strong></p><p class="source-code"><strong class="bold">  name: api-demo2 </strong></p><p class="source-code"><strong class="bold">  namespace: event-demo </strong></p><p class="source-code"><strong class="bold">spec: </strong></p><p class="source-code"><strong class="bold">  replicas: 1 </strong></p><p class="source-code"><strong class="bold">  selector: </strong></p><p class="source-code"><strong class="bold">    matchLabels: </strong></p><p class="source-code"><strong class="bold">      app: api-demo2 </strong></p><p class="source-code"><strong class="bold">  template:</strong></p><p class="source-code"><strong class="bold">    metadata: </strong></p><p class="source-code"><strong class="bold">      labels: </strong></p><p class="source-code"><strong class="bold">        app: api-demo2 </strong></p><p class="source-code"><strong class="bold">    spec: </strong></p><p class="source-code"><strong class="bold">      containers: </strong></p><p class="source-code"><strong class="bold">      - image: sergioarmgpl/app3demo</strong></p><p class="source-code"><strong class="bold">        name: app4</strong></p><p class="source-code"><strong class="bold">        imagePullPolicy: Always</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Create the <a id="_idIndexMarker699"/>service for this <strong class="source-inline">api-demo2</strong> deployment:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: Service</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  labels:</strong></p><p class="source-code"><strong class="bold">    app: api-demo2</strong></p><p class="source-code"><strong class="bold">  name: api-demo2</strong></p><p class="source-code"><strong class="bold">  namespace: event-demo</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  ports:</strong></p><p class="source-code"><strong class="bold">  - port: 80</strong></p><p class="source-code"><strong class="bold">    protocol: TCP</strong></p><p class="source-code"><strong class="bold">    targetPort: 5000</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    app: api-demo2</strong></p><p class="source-code"><strong class="bold">  type: ClusterIP</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Create a <a id="_idIndexMarker700"/>trigger that launches <strong class="source-inline">api-demo2</strong>, and let’s call the attribute type <strong class="source-inline">event.show.2</strong> to call the <strong class="source-inline">api-demo2</strong> service, which points to the <strong class="source-inline">api-demo2</strong> deployment:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: eventing.knative.dev/v1</strong></p><p class="source-code"><strong class="bold">kind: Trigger</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: api-demo2</strong></p><p class="source-code"><strong class="bold">  namespace: event-demo</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  broker: default</strong></p><p class="source-code"><strong class="bold">  filter:</strong></p><p class="source-code"><strong class="bold">    attributes:</strong></p><p class="source-code"><strong class="bold">      type: event.show.2</strong></p><p class="source-code"><strong class="bold">  subscriber:</strong></p><p class="source-code"><strong class="bold">    ref:</strong></p><p class="source-code"><strong class="bold">      apiVersion: v1</strong></p><p class="source-code"><strong class="bold">      kind: Service</strong></p><p class="source-code"><strong class="bold">      name: api-demo2</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>In the <a id="_idIndexMarker701"/>previously created <strong class="source-inline">curl</strong> pod, run the following command:<p class="source-code"><strong class="bold">$ curl -v "broker-ingress.knative-eventing.svc.cluster.local/event-demo/default" \</strong></p><p class="source-code"><strong class="bold">-X POST \</strong></p><p class="source-code"><strong class="bold">-H "Ce-Id: call-api-demo2" \</strong></p><p class="source-code"><strong class="bold">-H "Ce-specversion: 1.0" \</strong></p><p class="source-code"><strong class="bold">-H "Ce-Type: event.show.2" \</strong></p><p class="source-code"><strong class="bold">-H "Ce-Source: test-send" \</strong></p><p class="source-code"><strong class="bold">-H "Content-Type: application/json" \</strong></p><p class="source-code"><strong class="bold">-d '{"msg":"Simple Event using Knative."}'</strong></p></li>
				<li>Check the logs in the new <strong class="source-inline">api-demo2</strong> deployment with the following command:<p class="source-code"><strong class="bold">$ kubectl -n event-demo logs -l app=api-demo2 --tail=50</strong></p></li>
				<li>The log will look like this:<p class="source-code"><strong class="bold">* Serving Flask app 'index' (lazy loading)</strong></p><p class="source-code"><strong class="bold">* Environment: production</strong></p><p class="source-code"><strong class="bold">   WARNING: This is a development server. Do not use it in a production deployment.</strong></p><p class="source-code"><strong class="bold">   Use a production WSGI server instead.</strong></p><p class="source-code"><strong class="bold">* Debug mode: on</strong></p><p class="source-code"><strong class="bold">* Running on all addresses.</strong></p><p class="source-code"><strong class="bold">   WARNING: This is a development server. Do not use it in a production deployment.</strong></p><p class="source-code"><strong class="bold">* Running on http://10.42.0.43:5000/ (Press CTRL+C to quit)</strong></p><p class="source-code"><strong class="bold">* Restarting with stat</strong></p><p class="source-code"><strong class="bold">* Debugger is active!</strong></p><p class="source-code"><strong class="bold">* Debugger PIN: 602-982-734</strong></p><p class="source-code"><strong class="bold">[2022-02-27 06:16:07,689] WARNING in index: {'attributes': {'specversion': '1.0', 'id': 'call-api-demo2', 'source': 'test-send', 'type': 'event.show.2', 'datacontenttype': 'application/json', 'knativearrivaltime': '2022-02-27T06:16:07.654229185Z', 'time': '2022-02-27T06:16:07.688895+00:00'}, 'data': {'msg': 'Simple Event using Knative2.'}}</strong></p></li>
			</ol>
			<p>Now you have <a id="_idIndexMarker702"/>created two basic events using Knative Eventing. This can help you to implement simple and lightweight event-driven architectures. Now, it’s time to explore how to use the Sequence feature of Knative Eventing to create and run simple pipelines using an event-driven architecture.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor194"/>Using sequences to implement event-driven pipelines</h2>
			<p>Another <a id="_idIndexMarker703"/>common use case for event-driven architectures is to trigger a series of steps one after the other to automate workflows. In those cases, you can use the Sequence object of Knative. In this example, we are going to create a sequence that consists of two steps. Each step prints the <strong class="source-inline">MESSAGE</strong> variable, which contains the number of the step that is running. This sequence is going to be called using a trigger. We are going to call the trigger using the <strong class="source-inline">curl</strong> command. This is a simple example pipeline using event-driven architecture. Let’s get started by <a id="_idIndexMarker704"/>following the next steps:</p>
			<ol>
				<li value="1">Create the <strong class="source-inline">sequence-demo</strong> namespace with the <strong class="source-inline">eventing.knative.dev/injection: enabled</strong> label. When Knative Eventing detects this label in your namespace, it is going to create the default Knative broker. This is possible thanks to the Knative Sugar Controller previously installed. So, let’s create the namespace by running the following command:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: Namespace</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: sequence-demo</strong></p><p class="source-code"><strong class="bold">  labels:</strong></p><p class="source-code"><strong class="bold">       eventing.knative.dev/injection: enabled</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Create <strong class="source-inline">step1</strong> using the Knative Service definition file by running the following command:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: serving.knative.dev/v1</strong></p><p class="source-code"><strong class="bold">kind: Service</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: step1</strong></p><p class="source-code"><strong class="bold">  namespace: sequence-demo</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  template:</strong></p><p class="source-code"><strong class="bold">    spec:</strong></p><p class="source-code"><strong class="bold">      containers:</strong></p><p class="source-code"><strong class="bold">        - image: sergioarmgpl/app4demo</strong></p><p class="source-code"><strong class="bold">          ports:</strong></p><p class="source-code"><strong class="bold">           - containerPort: 5000</strong></p><p class="source-code"><strong class="bold">          env:</strong></p><p class="source-code"><strong class="bold">            - name: MESSAGE</strong></p><p class="source-code"><strong class="bold">              value: "step1"</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Now <a id="_idIndexMarker705"/>create <strong class="source-inline">step2</strong> by running the following:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: serving.knative.dev/v1</strong></p><p class="source-code"><strong class="bold">kind: Service</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: step2</strong></p><p class="source-code"><strong class="bold">  namespace: sequence-demo</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  template:</strong></p><p class="source-code"><strong class="bold">    spec:</strong></p><p class="source-code"><strong class="bold">      containers:</strong></p><p class="source-code"><strong class="bold">        - image: sergioarmgpl/app4demo</strong></p><p class="source-code"><strong class="bold">          ports:</strong></p><p class="source-code"><strong class="bold">           - containerPort: 5000</strong></p><p class="source-code"><strong class="bold">          env:</strong></p><p class="source-code"><strong class="bold">            - name: MESSAGE</strong></p><p class="source-code"><strong class="bold">              value: "step2"</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
			</ol>
			<p class="callout-heading">Important Note</p>
			<p class="callout">We are using the <strong class="source-inline">containerPort</strong> parameter in the service definition, to define a custom port where our container is listening, in order to talk with Knative Eventing. By default, Knative uses port <strong class="source-inline">80</strong> to listen to services.</p>
			<ol>
				<li value="4">Let’s <a id="_idIndexMarker706"/>create our sequence object called <strong class="source-inline">sequence-demo</strong> to run the steps as a small pipeline using the in-memory channel for messaging:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: flows.knative.dev/v1</strong></p><p class="source-code"><strong class="bold">kind: Sequence</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: sequence</strong></p><p class="source-code"><strong class="bold">  namespace: sequence-demo</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  channelTemplate:</strong></p><p class="source-code"><strong class="bold">    apiVersion: messaging.knative.dev/v1</strong></p><p class="source-code"><strong class="bold">    kind: InMemoryChannel</strong></p><p class="source-code"><strong class="bold">  steps:</strong></p><p class="source-code"><strong class="bold">    - ref:</strong></p><p class="source-code"><strong class="bold">        apiVersion: serving.knative.dev/v1</strong></p><p class="source-code"><strong class="bold">        kind: Service</strong></p><p class="source-code"><strong class="bold">        name: step1</strong></p><p class="source-code"><strong class="bold">    - ref:</strong></p><p class="source-code"><strong class="bold">        apiVersion: serving.knative.dev/v1</strong></p><p class="source-code"><strong class="bold">        kind: Service</strong></p><p class="source-code"><strong class="bold">        name: step2</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Create <a id="_idIndexMarker707"/>the trigger that we are going to use. We are going to define an attribute to call it. In this case, every time we call an event with the <strong class="source-inline">type</strong> attribute with the value <strong class="source-inline">event.call.sequence</strong>, it is going to call our sequence:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: eventing.knative.dev/v1</strong></p><p class="source-code"><strong class="bold">kind: Trigger</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: sequence-trigger</strong></p><p class="source-code"><strong class="bold">  namespace: sequence-demo</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  broker: default</strong></p><p class="source-code"><strong class="bold">  filter:</strong></p><p class="source-code"><strong class="bold">    attributes:</strong></p><p class="source-code"><strong class="bold">      type: event.call.sequence</strong></p><p class="source-code"><strong class="bold">  subscriber:</strong></p><p class="source-code"><strong class="bold">    ref:</strong></p><p class="source-code"><strong class="bold">      apiVersion: flows.knative.dev/v1</strong></p><p class="source-code"><strong class="bold">      kind: Sequence</strong></p><p class="source-code"><strong class="bold">      name: sequence</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Now let’s create a <strong class="source-inline">curl</strong> pod inside the <strong class="source-inline">sequence-demo</strong> namespace to call our <a id="_idIndexMarker708"/>sequence using the endpoint of our broker:<p class="source-code"><strong class="bold">$ kubectl run -n sequence-demo curl -it --rm --image=curlimages/curl:7.81.0 /bin/sh</strong></p></li>
				<li>Inside the pod, run the following <strong class="source-inline">curl</strong> command:<p class="source-code"><strong class="bold">$ curl -v "broker-ingress.knative-eventing.svc.cluster.local/sequence-demo/default" \</strong></p><p class="source-code"><strong class="bold">-X POST \</strong></p><p class="source-code"><strong class="bold">-H "Ce-Id: call-sequence-demo" \</strong></p><p class="source-code"><strong class="bold">-H "Ce-specversion: 1.0" \</strong></p><p class="source-code"><strong class="bold">-H "Ce-Type: event.call.sequence" \</strong></p><p class="source-code"><strong class="bold">-H "Ce-Source: test-sequence" \</strong></p><p class="source-code"><strong class="bold">-H "Content-Type: application/json" \</strong></p><p class="source-code"><strong class="bold">-d '{"SOME_VARIABLE":"Simple Sequence using Knative."}'</strong></p></li>
			</ol>
			<p>This is going to show an output like this:</p>
			<p class="source-code"><strong class="bold">*   Trying 10.43.130.39:80...</strong></p>
			<p class="source-code"><strong class="bold">* Connected to broker-ingress.knative-eventing.svc.cluster.local (10.43.130.39) port 80 (#0)</strong></p>
			<p class="source-code"><strong class="bold">&gt; POST /sequence-demo/default HTTP/1.1</strong></p>
			<p class="source-code"><strong class="bold">&gt; Host: broker-ingress.knative-eventing.svc.cluster.local</strong></p>
			<p class="source-code"><strong class="bold">&gt; User-Agent: curl/7.81.0-DEV</strong></p>
			<p class="source-code"><strong class="bold">&gt; Accept: */*</strong></p>
			<p class="source-code"><strong class="bold">&gt; Ce-Id: call-sequence-demo</strong></p>
			<p class="source-code"><strong class="bold">&gt; Ce-specversion: 1.0</strong></p>
			<p class="source-code"><strong class="bold">&gt; Ce-Type: event.call.sequense</strong></p>
			<p class="source-code"><strong class="bold">&gt; Ce-Source: test-sequence</strong></p>
			<p class="source-code"><strong class="bold">&gt; Content-Type: application/json</strong></p>
			<p class="source-code"><strong class="bold">&gt;</strong></p>
			<p class="source-code"><strong class="bold">* Mark bundle as not supporting multiuse</strong></p>
			<p class="source-code"><strong class="bold">&lt; HTTP/1.1 202 Accepted</strong></p>
			<p class="source-code"><strong class="bold">&lt; Allow: POST, OPTIONS</strong></p>
			<p class="source-code"><strong class="bold">&lt; Date: Mon, 28 Feb 2022 01:00:50 GMT</strong></p>
			<p class="source-code"><strong class="bold">&lt; Content-Length: 0</strong></p>
			<p class="source-code"><strong class="bold">&lt;</strong></p>
			<p class="source-code"><strong class="bold">* Connection #0 to host broker-ingress.knative-eventing.svc.cluster.local left intact</strong></p>
			<ol>
				<li value="8">Exit the<a id="_idIndexMarker709"/> pod and check the output of the pod for <em class="italic">step 1</em> by running the following:<p class="source-code"><strong class="bold">$ kubectl logs deploy/step1-00001-deployment -n sequence-demo user-container</strong></p></li>
			</ol>
			<p>You will see an output like this:</p>
			<p class="source-code"><strong class="bold">[2022-02-28 01:06:54,364] WARNING in index: b'{"SOME_VARIABLE":"Simple Sequence using Knative."}'</strong></p>
			<p class="source-code"><strong class="bold">[2022-02-28 01:06:54,365] WARNING in index: step1</strong></p>
			<p>This is going to receive the <strong class="source-inline">SOME_VARIABLE</strong> variable, sent by the <strong class="source-inline">curl</strong> command, which could be used to customize your sequence.</p>
			<ol>
				<li value="9">Now check the output for <em class="italic">step 2</em> by running the following:<p class="source-code"><strong class="bold">$ kubectl logs deploy/step2-00001-deployment -n sequence-demo user-container</strong></p><p class="source-code"><strong class="bold">The output will look like:</strong></p><p class="source-code"><strong class="bold">[2022-02-28 01:07:02,623] WARNING in index: b'{\n  "ENV_VAR": "step1"\n}\n'</strong></p><p class="source-code"><strong class="bold">[2022-02-28 01:07:02,624] WARNING in index: step2</strong></p></li>
			</ol>
			<p>This is <a id="_idIndexMarker710"/>going to show the <strong class="source-inline">ENV_VAR</strong> value sent by the previous step and the current environment variable showing the step currently running – in this case, <em class="italic">step 2</em>.</p>
			<ol>
				<li value="10">After a few minutes of being idle, the deployments for the steps in the namespace will scale down and will scale up every time you call it.</li>
			</ol>
			<p>We have finished with the basics of serverless and event-driven pipelines using Knative. It’s time to finish this chapter.</p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor195"/>Summary</h1>
			<p>In this chapter, we learned how to implement public serverless and internal serverless functions using Knative Serving and use the features of traffic splitting. We also learned how to implement simple events and a sequence of events to implement small event-driven architectures using Knative Eventing, and how to integrate and standardize API event calls using the Cloud Events Python SDK. In the next chapter, we are going to learn how to use databases at the edge to add more functionality to edge systems using K3s.</p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor196"/>Questions</h1>
			<p>Here are a few questions to validate your new knowledge:</p>
			<ol>
				<li value="1">What are the use cases for serverless architectures?</li>
				<li>What is a serverless function?</li>
				<li>What are the advantages of serverless technology?</li>
				<li>How can I implement a serverless function using Knative?</li>
				<li>How can I implement an event using Knative?</li>
				<li>How can I implement an event-driven pipeline using Knative?</li>
				<li>How does Cloud Events help you to implement events?</li>
			</ol>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor197"/>Further reading</h1>
			<p>You can refer to the following references for more information on the topics covered in this chapter:</p>
			<ul>
				<li><em class="italic">Why Serverless will enable the Edge Computing Revolution</em>: <a href="https://medium.com/serverless-transformation/why-serverless-will-enable-the-edge-computing-revolution-4f52f3f8a7b0">https://medium.com/serverless-transformation/why-serverless-will-enable-the-edge-computing-revolution-4f52f3f8a7b0</a></li>
				<li><em class="italic">What is edge serverless</em>: <a href="https://www.stackpath.com/edge-academy/what-is-edge-serverless">https://www.stackpath.com/edge-academy/what-is-edge-serverless</a></li>
				<li><em class="italic">AI/ML, edge and serverless computing top priority list for the year ahead</em>: <a href="https://www.redhat.com/en/blog/aiml-edge-and-serverless-computing-top-priority-list">https://www.redhat.com/en/blog/aiml-edge-and-serverless-computing-top-priority-list</a></li>
				<li>Running Knative on Raspberry Pi: <a href="https://github.com/csantanapr/knative-pi">https://github.com/csantanapr/knative-pi</a></li>
				<li>Install Knative Serving using YAML: <a href="https://knative.dev/docs/install/serving/install-serving-with-yaml/#install-a-networking-layer">https://knative.dev/docs/install/serving/install-serving-with-yaml/#install-a-networking-layer</a></li>
				<li>Cloud Events website: <a href="https://cloudevents.io">https://cloudevents.io</a></li>
				<li>Cloud Events SDK: <a href="https://github.com/cloudevents/sdk-python">https://github.com/cloudevents/sdk-python</a></li>
				<li>CloudEvents – version 1.0.2: <a href="https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/spec.md">https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/spec.md</a></li>
				<li>A Hello World Python example with Knative Eventing: <a href="https://github.com/knative/docs/tree/main/code-samples/eventing/helloworld/helloworld-python">https://github.com/knative/docs/tree/main/code-samples/eventing/helloworld/helloworld-python</a></li>
				<li>Sending events to the broker: <a href="https://knative.dev/docs/eventing/getting-started/#sending-events-to-the-broker">https://knative.dev/docs/eventing/getting-started/#sending-events-to-the-broker</a></li>
				<li>Using Sequence with Broker and Trigger: <a href="https://knative.dev/docs/eventing/flows/sequence/sequence-with-broker-trigger">https://knative.dev/docs/eventing/flows/sequence/sequence-with-broker-trigger</a></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer087">
			</div>
		</div>
	</body></html>