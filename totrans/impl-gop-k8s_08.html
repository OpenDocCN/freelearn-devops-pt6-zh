<html><head></head><body>
		<div id="_idContainer111">
			<h1 class="chapter-number" id="_idParaDest-162"><a id="_idTextAnchor165"/>8</h1>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor166"/>GitOps with OpenShift</h1>
			<p>In this chapter, we delve into the world of <strong class="bold">GitOps</strong> within the context of <strong class="bold">Red Hat OpenShift</strong>, an approach that revolutionizes the way we deploy, manage, and operate <span class="No-Break">containerized applications.</span></p>
			<p>As we journey through this chapter, we will explore the foundational principles of GitOps, highlighting how they seamlessly integrate with the robust features of Red Hat OpenShift. This combination not only enhances the efficiency and reliability of deployments but also aligns with modern DevOps practices, fostering collaboration between development and <span class="No-Break">operations teams.</span></p>
			<p>We will start by setting up a local OpenShift environment using <strong class="bold">CodeReady Containers</strong> (<strong class="bold">CRC</strong>), providing a hands-on approach to understanding how OpenShift operates and how it can be managed using GitOps principles. From there, we will dive into practical examples and best practices, including configuring automated deployments, managing application configurations, and ensuring high availability and security within your <span class="No-Break">OpenShift cluster.</span></p>
			<p>Whether you are new to OpenShift or looking to enhance your existing workflows, this exploration into GitOps will provide valuable insights and techniques for optimizing your cloud-native <span class="No-Break">development processes.</span></p>
			<p>In this chapter, we’ll focus on these <span class="No-Break">key areas:</span></p>
			<ul>
				<li>Introduction to Red <span class="No-Break">Hat OpenShift</span></li>
				<li>Setting up GitOps in Red <span class="No-Break">Hat OpenShift</span></li>
				<li>Leveraging Red Hat OpenShift’s CI/CD <span class="No-Break">for GitOps</span></li>
				<li>Automation and configuration <span class="No-Break">best practices</span></li>
				<li>A Kubernetes-Red Hat <span class="No-Break">OpenShift comparison</span></li>
			</ul>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor167"/>Technical requirements</h1>
			<p>For this chapter, ensure you have access to a Red Hat OpenShift cluster or a local setup via Red Hat OpenShift Local. Familiarity with GitOps practices and tools such as Argo CD, as well as basic development tools such as Git and a code editor, is necessary. A foundational understanding of container technology, Kubernetes architecture, and YAML syntax will aid in following the practical exercises. Ensure a stable internet connection for tool downloads and cluster access. If running OpenShift locally, your machine should ideally have at least 16 GB of RAM and <span class="No-Break">sufficient storage.</span></p>
			<p>The relevant code and resource files for this chapter can be found in the <strong class="source-inline">Chapter08</strong> folder of our dedicated GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes"><span class="No-Break">https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor168"/>Introduction to Red Hat OpenShift</h1>
			<p>OpenShift (<a href="https://www.redhat.com/en/technologies/cloud-computing/openshift">https://www.redhat.com/en/technologies/cloud-computing/openshift</a>), developed by<a id="_idIndexMarker670"/> Red Hat, is a leading enterprise Kubernetes platform that offers a <a id="_idIndexMarker671"/>comprehensive suite of features designed to streamline the deployment, scaling, and operations of containerized applications. It extends Kubernetes by simplifying many of the complex tasks associated with deploying and managing a containerized infrastructure, making it an ideal choice for enterprises looking to implement modern DevOps and <span class="No-Break">GitOps practices.</span></p>
			<p>One of the core strengths of OpenShift is its<a id="_idIndexMarker672"/> focus on <strong class="bold">developer productivity</strong> and <strong class="bold">operational efficiency</strong>. It provides a rich set of developer tools and a <a id="_idIndexMarker673"/>user-friendly console that makes it easier for developers to build, deploy, and manage their applications. OpenShift’s <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) and <a id="_idIndexMarker674"/>built-in CI/CD capabilities enable developers to automate much of the software delivery process, from code build through to testing, deployment, <span class="No-Break">and monitoring.</span></p>
			<p><strong class="bold">Security</strong> is another <a id="_idIndexMarker675"/>area where OpenShift shines. It incorporates built-in security features at every level of the application stack, from the <strong class="bold">operating system</strong> (<strong class="bold">OS</strong>) to the network, and up to the application services. This integrated approach ensures that security is not an afterthought but is woven into the very fabric of the application life cycle. Features such as <strong class="bold">Security-Enhanced Linux</strong> (<strong class="bold">SELinux</strong>) enforced <a id="_idIndexMarker676"/>isolation, automated vulnerability scanning, and default secure configurations help to protect applications and data from external threats and <span class="No-Break">internal misconfigurations.</span></p>
			<p class="callout-heading">SELinux</p>
			<p class="callout">SELinux is a<a id="_idIndexMarker677"/> kernel-integrated security feature that enforces <strong class="bold">mandatory access control</strong> (<strong class="bold">MAC</strong>) policies<a id="_idIndexMarker678"/> to enhance system security. It operates on the principle of least privilege, restricting system processes and users to the minimal permissions needed for their functions. SELinux helps prevent unauthorized access and can operate in enforcing mode, where it blocks and logs unauthorized actions, or in permissive mode, where it only logs violations without blocking them. This adds an important layer of security to Linux-based systems, including OpenShift, by controlling access with greater granularity than traditional <span class="No-Break">access controls.</span></p>
			<p>Furthermore, OpenShift is <a id="_idIndexMarker679"/>designed to support a wide range of workloads, from traditional monolithic applications to microservices and serverless functions. Its flexible architecture supports a variety of programming languages, frameworks, and databases, allowing teams to use the tools and technologies that best fit their needs. Additionally, OpenShift’s container-native storage and networking solutions provide the scalability and performance required for <span class="No-Break">high-demand applications.</span></p>
			<p>In the context of GitOps, OpenShift provides a powerful platform for implementing declarative, version-controlled workflows for infrastructure and application deployment. By leveraging OpenShift’s capabilities, teams can achieve higher levels of <strong class="bold">automation</strong>, <strong class="bold">repeatability</strong>, and <strong class="bold">consistency</strong>, which are central to the GitOps philosophy. With its robust ecosystem, OpenShift enables organizations to streamline their deployment pipelines, enhance security, and improve operational efficiency, making it an excellent choice for adopting <span class="No-Break">GitOps methodologies.</span></p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor169"/>Red Hat OpenShift environment setup</h2>
			<p>When setting up an OpenShift cluster for learning, testing, or development purposes, you have several options to consider, each with its own set of advantages. Understanding these alternatives will help you choose the best fit based on your objectives, available resources, and technical <span class="No-Break">comfort level:</span></p>
			<ul>
				<li><strong class="bold">Developer Sandbox for OpenShift</strong>: This<a id="_idIndexMarker680"/> is an excellent starting point for beginners or for those looking to test out OpenShift<a id="_idIndexMarker681"/> features without any setup. The <a id="_idIndexMarker682"/>Developer Sandbox (<a href="https://developers.redhat.com/developer-sandbox">https://developers.redhat.com/developer-sandbox</a>)  provides a free, pre-configured OpenShift environment. All you need to do is register to gain 30 days of free access to a shared OpenShift and Kubernetes cluster. This option is ideal for users who prefer to avoid the complexities of manual setup and are looking for a quick way to start experimenting with <span class="No-Break">OpenShift capabilities.</span></li>
				<li><strong class="bold">Cloud-based OpenShift cluster</strong>: Setting up an <a id="_idIndexMarker683"/>OpenShift<a id="_idIndexMarker684"/> cluster in the cloud (Azure, AWS, or GCP) is a robust solution that offers scalability and real-world applicability. This approach is suitable for users looking to simulate a production environment or to work on larger, more complex projects. However, it’s important to note that running a cluster in the cloud can incur costs, depending on the cloud provider and the <span class="No-Break">resources consumed.</span></li>
				<li><strong class="bold">Bare metal setup</strong>: Setting <a id="_idIndexMarker685"/>up OpenShift Local on bare metal is a challenging and resource-intensive task. Unlike in cloud environments, you must manually manage networking, storage, and hardware compatibility, requiring a high level of technical expertise. The system demands significant memory, multiple CPU cores, and substantial storage, which can be daunting for environments not initially designed for such loads. While a bare metal installation offers greater control and potential performance benefits, it comes with complexities and potential hurdles that need careful planning <span class="No-Break">and understanding.</span></li>
				<li><strong class="bold">Red Hat OpenShift Local</strong>: For those<a id="_idIndexMarker686"/> who prefer a local solution, setting up an OpenShift cluster on your machine using Red Hat CRC, can be an effective approach. This method allows for a more hands-on experience and works well for individual learning<a id="_idIndexMarker687"/> and <span class="No-Break">development scenarios.</span></li>
			</ul>
			<p>Red Hat OpenShift Local<a id="_idIndexMarker688"/> provides a fast and straightforward method for initiating OpenShift cluster construction. Tailored for local machine operation, it streamlines the setup and testing process, offering a cloud-like development environment right on your desktop. This tool supports various programming languages and simplifies the development of container-based applications by providing a minimal, pre-configured OpenShift cluster that requires no <span class="No-Break">server-based infrastructure.</span></p>
			<p>OpenShift Local enables the creation, building, and deployment of microservices directly into Kubernetes-hosted containers, supporting a range of OSs including Linux, macOS, and Windows 10. This makes it an ideal platform for local development and testing, mirroring a real OpenShift <span class="No-Break">cluster’s environment.</span></p>
			<p>For the remainder of this chapter, we have chosen to utilize OpenShift Local due to its convenience and relevance to local development scenarios. It’s crucial to note that running the examples effectively requires a minimum hardware allocation of 6 virtual CPUs and 12 GB of memory for the local cluster to operate correctly. This requirement ensures that users can experience the full capabilities of OpenShift Local in a GitOps context without significant <span class="No-Break">performance issues.</span></p>
			<p>To begin, navigate to <a href="https://developers.redhat.com/products/openshift-local/overview">https://developers.redhat.com/products/openshift-local/overview</a> and click on <strong class="bold">Install OpenShift on your laptop</strong>, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer093">
					<img alt="Figure 8.1 – The Red Hat OpenShift Local (CRC) homepage" src="image/B22100_08_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – The Red Hat OpenShift Local (CRC) homepage</p>
			<p>To proceed <a id="_idIndexMarker689"/>with the<a id="_idIndexMarker690"/> setup of the cluster, it is necessary to download the installer by creating a Red Hat account if you do not already have one. From the displayed page (<span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.2</em>), choose the installer corresponding to your OS (Linux, Windows, or macOS) where you plan to install the cluster. Additionally, make sure to select the <strong class="bold">Download pull secret</strong> or <strong class="bold">Copy pull secret</strong> option, as the pull secret will be required during the installation process. Remember, you can always return to this page <span class="No-Break">if needed.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer094">
					<img alt="Figure 8.2 – Starting web page for downloading the CRC installer based on the target OS" src="image/B22100_08_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Starting web page for downloading the CRC installer based on the target OS</p>
			<p>At this point, it’s important to note that a detailed step-by-step guide for installation is beyond the scope of this text. However, you can find comprehensive instructions in the official documentation provided by <span class="No-Break">Red Hat.</span></p>
			<p>For a complete walkthrough, please visit the following <span class="No-Break">link: </span><span class="No-Break">https://access.redhat.com/documentation/en-us/red_hat_codeready_containers/1.0/html/getting_started_guide/getting-started-with-codeready-containers_gsg#doc-wrapper</span><span class="No-Break">.</span></p>
			<p>This resource outlines all necessary steps to establish your local OpenShift cluster. As a standard procedure to verify the correctness of the installation, execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ crc version</pre>			<p>This should produce output like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
CodeReady Containers version: 1.25.0+0e5748c8
OpenShift version: 4.7.13</pre>			<h2 id="_idParaDest-167"><a id="_idTextAnchor170"/>Troubleshooting OpenShift CRC setup issues</h2>
			<p>Setting up your environment <a id="_idIndexMarker691"/>can be an elaborate process with potential difficulties. It requires careful attention to detail and an understanding of system configurations and dependencies. While following the provided guidelines and documentation can streamline the process, you may still encounter unexpected challenges. It’s important to approach this setup with patience and be prepared to engage in some troubleshooting to address any issues that arise. Remember to properly start the cluster by using the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ crc start --cpus 6 --memory 12288</pre>			<p>This command ensures that your CRC instance starts with the specified amount of computational resources: 6 CPUs and 12288 MB (approximately 12 GB) of memory. These settings are important for the optimal performance of your <span class="No-Break">OpenShift cluster.</span></p>
			<p>If you experience any issues during the setup process, try executing the following sequence of commands to troubleshoot and reset <span class="No-Break">your environment:</span></p>
			<ul>
				<li><strong class="source-inline">crc delete -f</strong>: This forcefully <em class="italic">deletes</em> the existing CRC instance, clearing any <span class="No-Break">current configurations.</span></li>
				<li><strong class="source-inline">crc cleanup</strong>: This command helps <em class="italic">clean up</em> any residual files or configurations left from previous instances, ensuring a <span class="No-Break">clean slate.</span></li>
				<li><strong class="source-inline">crc setup</strong>: Re-run the setup command to configure your system again <span class="No-Break">for CRC.</span></li>
				<li><strong class="source-inline">crc config unset proxy-ca-file</strong>: This removes any proxy configuration settings that might be <span class="No-Break">causing issues.</span></li>
				<li><strong class="source-inline">crc start --log-level debug</strong>: Start the CRC instance again, this time with debug logging enabled. This will provide more detailed output, which can be helpful in identifying where the setup process is <span class="No-Break">encountering problems.</span></li>
			</ul>
			<p>To <a id="_idIndexMarker692"/>finalize the setup of our cluster, an additional crucial step is required: the installation of the OpenShift <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>), commonly <a id="_idIndexMarker693"/>referred to as <strong class="source-inline">oc</strong>. This tool is essential for interacting with OpenShift clusters, allowing users to perform various tasks via the command line, such as deploying applications, inspecting cluster resources, and managing administrative activities. The <strong class="source-inline">oc</strong> CLI<a id="_idIndexMarker694"/> is specifically designed for developers and system administrators, offering advanced functionalities that surpass the basic features found in Kubernetes. This makes the <strong class="source-inline">oc</strong> CLI a vital component for those looking to automate processes via scripts or manage their clusters more directly, ensuring efficient operation within the <span class="No-Break">OpenShift ecosystem.</span></p>
			<p>Detailed steps for installing the <strong class="source-inline">oc</strong> CLI can be found in the official documentation. Please visit <strong class="bold">Getting Started with the OpenShift CLI</strong> at <span class="P---URL"> </span><a href="https://docs.openshift.com/container-platform/4.8/cli_reference/openshift_cli/getting-started-cli.html">https://docs.openshift.com/container-platform/4.8/cli_reference/openshift_cli/getting-started-cli.html</a> for comprehensive instructions on how to download, install, and begin using the <strong class="source-inline">oc</strong> CLI for managing your <span class="No-Break">OpenShift clusters.</span></p>
			<p>Check that <strong class="source-inline">oc</strong> is correctly installed by typing the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ oc version</pre>			<p>The expected<a id="_idIndexMarker695"/> output of the preceding command should <span class="No-Break">be like:</span></p>
			<pre class="source-code">
Client Version: 4.15.2
Kustomize Version: v5.0.4-0.20230601165947-6ce0bf390ce3
Server Version: 4.14.12
Kubernetes Version: v1.27.10+28ed2d7</pre>			<p>Now that our cluster setup is complete, we are ready to progress to the next section, where we will focus on setting up GitOps in our Red Hat <span class="No-Break">OpenShift cluster.</span></p>
			<p>By applying GitOps, we can leverage the full potential of our newly configured OpenShift environment, ensuring a more efficient and automated operational framework. Let’s move forward and explore the exciting capabilities of GitOps <span class="No-Break">within OpenShift.</span></p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor171"/>Setting Up GitOps in Red Hat OpenShift</h1>
			<p>Begin by installing the necessary GitOps tools. Argo CD (see the <em class="italic">Argo CD</em> section in <a href="B22100_04.xhtml#_idTextAnchor065"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>) is a popular choice for OpenShift, as it integrates seamlessly with the Kubernetes environment. You can install Argo CD directly into your OpenShift cluster using <strong class="bold">OperatorHub</strong>, which <a id="_idIndexMarker696"/>offers an easy installation process and automatic management of the application <span class="No-Break">life cycle:</span></p>
			<ol>
				<li>To<a id="_idIndexMarker697"/> obtain the address of your local OpenShift<a id="_idIndexMarker698"/> cluster running on CRC, use the following command in <span class="No-Break">your terminal:</span><pre class="source-code">
<strong class="bold">$ crc start</strong></pre><p class="list-inset">The expected output of the <strong class="source-inline">crc start</strong> command will typically include several important pieces of information relevant to your local OpenShift cluster setup. Here’s an example of what you <span class="No-Break">might see:</span></p><pre class="source-code">INFO Loading bundle: crc_vfkit_4.14.12_arm64...
INFO A CRC VM for OpenShift 4.14.12 is already running
Started the OpenShift cluster.
<strong class="bold">The server is accessible via web console at:</strong>
<strong class="bold">  https://console-openshift-console.apps-crc.testing</strong>
<strong class="bold">Log in as administrator:</strong>
<strong class="bold">  Username: kubeadmin</strong>
<strong class="bold">  Password: C57Yw-465gL-NXcpv-nri5w</strong>
<strong class="bold">Log in as user:</strong>
<strong class="bold">  Username: developer</strong>
<strong class="bold">  Password: developer</strong>
Use the 'oc' command line interface:
  $ eval $(crc oc-env)
  $ oc login -u developer https://api.crc.testing:6443</pre><p class="list-inset">This output<a id="_idIndexMarker699"/> provides you with the URL for the<a id="_idIndexMarker700"/> OpenShift web console, along with login credentials for both the administrator and regular (developer) user accounts. It also includes instructions for logging in to your cluster using the <strong class="source-inline">oc</strong> CLI. Ensure you save these details, as you will need them to access your local <span class="No-Break">OpenShift cluster.</span></p></li>				<li>Navigate to <a href="https://console-openshift-console.apps-crc.testing">https://console-openshift-console.apps-crc.testing</a> and log in as <strong class="bold">Administrator</strong> using the credentials provided by the <strong class="source-inline">crc start</strong> command, as illustrated in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.3</em>. This will give you full access to the OpenShift cluster’s <span class="No-Break">administrative functionalities.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer095">
					<img alt="Figure 8.3 – The Cluster page in the Administrator mode" src="image/B22100_08_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – The Cluster page in the Administrator mode</p>
			<ol>
				<li value="3">In the OpenShift web console, navigate to the left-hand panel and expand the <span class="No-Break"><strong class="bold">Operators</strong></span><span class="No-Break"> section.</span></li>
				<li>Click on <strong class="bold">OperatorHub</strong>. Then, in the search box on the right-hand side, type <strong class="source-inline">OpenShift GitOps</strong> to locate the relevant operator for installation. This action will bring up the OpenShift GitOps operator, which you can then proceed to install on your cluster (refer to <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.4</em> <span class="No-Break">for guidance).</span></li>
			</ol>
			<p class="callout-heading">OpenShift Operators</p>
			<p class="callout">An <strong class="bold">OpenShift Operator</strong> is a<a id="_idIndexMarker701"/> method of packaging, deploying, and managing a Kubernetes application. OpenShift Operators extend the Kubernetes API to create, configure, and manage instances of complex stateful applications on behalf of a Kubernetes user. They automate the entire life cycle of the software they manage, from initial deployment to upgrade to everyday operations, following best practices. This approach simplifies the management of complex applications and services, allowing developers and operators to focus on the specifics of their applications while leveraging the scalability and reliability of Kubernetes systems. Essentially, Operators encapsulate the human operational knowledge required to run services and provide a more efficient and reliable way to manage applications in a <span class="No-Break">cloud-native environment.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer096">
					<img alt="Figure 8.4 – Navigating to OperatorHub and searching for OpenShift GitOps Operator" src="image/B22100_08_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Navigating to OperatorHub and searching for OpenShift GitOps Operator</p>
			<ol>
				<li value="5">Once you have <a id="_idIndexMarker702"/>located the Red Hat OpenShift GitOps <a id="_idIndexMarker703"/>operator, click on it to view more details. Then, proceed to click on the <strong class="bold">Install</strong> button. When prompted, leave the default values as they are and continue with the installation process (see <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.5</em>). This will initiate the setup of the OpenShift GitOps operator on your cluster, equipping your environment with the necessary tools for <span class="No-Break">GitOps workflows.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer097">
					<img alt="Figure 8.5 – A panel displaying details prior to operator installation" src="image/B22100_08_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – A panel displaying details prior to operator installation</p>
			<ol>
				<li value="6">For <strong class="bold">Installation mode</strong>, select <strong class="bold">All namespaces on the cluster (default)</strong> to allow the operator to operate across <span class="No-Break">all namespaces.</span></li>
				<li>For <strong class="bold">Installed Namespace</strong>, choose <strong class="bold">Operator recommended Namespace openshift-gitops-operator</strong>, which is specifically suggested for the <span class="No-Break">GitOps operator.</span></li>
				<li>Click on <strong class="bold">Install</strong> and <a id="_idIndexMarker704"/>wait for the installation operations<a id="_idIndexMarker705"/> to be completed. This might take a few moments. After the installation is finished, click on <strong class="bold">View Operator</strong> to verify the installation’s success, and ensure everything is set <span class="No-Break">up correctly.</span></li>
				<li>While remaining in the <strong class="bold">Administrator</strong> mode within the web console, navigate to <strong class="bold">Create Project</strong> to start a new project. Fill in the project creation form with the necessary information, following the guidelines or specifics you have for your project (<span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.6</em>). This will establish a dedicated namespace for your GitOps deployments and <span class="No-Break">related resources.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer098">
					<img alt="Figure 8.6 – Red Hat OpenShift – Create Project" src="image/B22100_08_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Red Hat OpenShift – Create Project</p>
			<p class="callout-heading">Be aware!</p>
			<p class="callout">The display name of your project can be adjusted according to your preferences, but it’s important to remember this name as you will need to use it consistently in subsequent steps. Ensure that the name you choose is memorable and relevant to your project to avoid <span class="No-Break">confusion later.</span></p>
			<ol>
				<li value="10">Once the<a id="_idIndexMarker706"/> project is created, the dashboard for <a id="_idIndexMarker707"/>your newly established project should appear in the OpenShift web console, as illustrated in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.7</em>. It will provide an overview of your project’s resources, activities, and status. Make sure the details align with your expectations and configurations, as this dashboard will be central to managing and monitoring your project’s components in the <span class="No-Break">upcoming steps.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer099">
					<img alt="Figure 8.7 – Dashboard for the newly created project" src="image/B22100_08_07.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Dashboard for the newly created project</p>
			<ol>
				<li value="11">In the <a id="_idIndexMarker708"/>OpenShift web console, go to <strong class="bold">Operators</strong> | <strong class="bold">Installed Operators</strong>. Find and click on <strong class="bold">Red Hat OpenShift GitOps</strong>, then <a id="_idIndexMarker709"/>select <strong class="bold">All Instances</strong> to view and manage your GitOps operator instances (refer to <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.8</em> <span class="No-Break">for guidance).</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer100">
					<img alt="Figure 8.8 – List of instances where the operator has been installed and its status" src="image/B22100_08_08.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – List of instances where the operator has been installed and its status</p>
			<ol>
				<li value="12">Ensure that the project selected on the top-left is <strong class="source-inline">gitopsk8sdeployments</strong> before proceeding. Then, navigate to <strong class="bold">Create new</strong> and select <strong class="bold">Argo CD</strong> to set up a <span class="No-Break">new instance.</span></li>
				<li>In the form<a id="_idIndexMarker710"/> that<a id="_idIndexMarker711"/> appears, enter <strong class="source-inline">argocd-for-gitops-deployments</strong> into the name <span class="No-Break">input box.</span></li>
				<li>To create an external route for accessing the Argo CD server, click on <strong class="bold">Server</strong> | <strong class="bold">Route</strong> and ensure that <strong class="bold">Enabled</strong> is checked. This will allow you to access the Argo CD interface externally from your <span class="No-Break">OpenShift cluster.</span></li>
				<li>Wait for the <strong class="bold">Status</strong> value to change to <strong class="bold">Available</strong> as in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.9</em>. This indicates that your Argo CD instance is fully deployed and ready for use within your OpenShift cluster. The status change might take a few minutes as the system finalizes the setup and <span class="No-Break">deployment processes.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer101">
					<img alt="Figure 8.9 – New item displaying the created Argo CD instance for the specific namespace" src="image/B22100_08_09.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – New item displaying the created Argo CD instance for the specific namespace</p>
			<p class="list-inset">Switch to the <strong class="bold">Developer</strong> mode in the OpenShift web console and click on <strong class="bold">Topology</strong>. This view will give you a graphical representation of the resources deployed so far, allowing you to visually understand the structure and relationships of your applications and services within the selected project.Top <span class="No-Break">of Form</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer102">
					<img alt="Figure 8.10 – A graphical representation of the resources deployed" src="image/B22100_08_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – A graphical representation of the resources deployed</p>
			<ol>
				<li value="16">To further test <a id="_idIndexMarker712"/>that Argo CD has been correctly set <a id="_idIndexMarker713"/>up, you can use <strong class="source-inline">oc</strong> and run the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ oc get pods -n gitopsk8sdeployments</strong></pre><p class="list-inset">This command will list all the pods within the <strong class="source-inline">gitopsk8sdeployments</strong> namespace, allowing you to verify that the Argo CD pods have been successfully deployed and are running as expected. If the Argo CD setup was successful, you should see the related pods listed without issues (all of them in the <span class="No-Break"><strong class="bold">Running</strong></span><span class="No-Break"> status):</span></p><pre class="source-code">NAME                                                     READY   STATUS    RESTARTS   AGE
argocd-for-gitops-deployments-application-controller-0       1/1      Running   0          6m1s
argocd-for-gitops-deployments-redis-6c9476c7dc-76c6n         1/1      Running   0          6m1s
argocd-for-gitops-deployments-repo-server-65cdc966d4-qzpvt   1/1      Running   0          6m1s</pre></li>			</ol>
			<p>Now that we have successfully set up Argo CD and verified its correct installation, we are ready to proceed with the deployment. Let’s move forward to the next steps where we will utilize our GitOps workflow within the OpenShift environment to manage and deploy our <span class="No-Break">applications efficiently.</span></p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor172"/>Leveraging Red Hat OpenShift’s CI/CD for GitOps</h1>
			<p>In this section, we<a id="_idIndexMarker714"/> delve into leveraging Red Hat OpenShift’s CI/CD capabilities for GitOps. Specifically, we will apply these principles to deploy the weather application, which was introduced previously in the <em class="italic">My city weather app</em> section in <a href="B22100_04.xhtml#_idTextAnchor065"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>. Utilizing a deployment YAML file, we will orchestrate the application’s rollout on the OpenShift cluster through our Argo CD instance, targeting the <strong class="source-inline">gitopsk8sdeployments</strong> namespace. This practical example will demonstrate how OpenShift’s CI/CD tools, combined with GitOps methodologies, streamline and automate the deployment processes, ensuring a consistent, traceable, and efficient application <span class="No-Break">delivery pipeline.</span></p>
			<p>Let’s explore how to integrate these powerful technologies to deploy our weather <span class="No-Break">application seamlessly:</span></p>
			<ol>
				<li>In the OpenShift web console, ensure you are in the <span class="No-Break"><strong class="bold">Administrator</strong></span><span class="No-Break"> mode.</span></li>
				<li>Then, navigate to <strong class="bold">Networking</strong> and select <strong class="bold">Routes</strong>. Look for the entry named <strong class="source-inline">argocd-for-gitops-deployments-server</strong> in <span class="No-Break">the list.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer103">
					<img alt="Figure 8.11 – Routes section of the Administrator mode" src="image/B22100_08_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – Routes section of the Administrator mode</p>
			<ol>
				<li value="3">Click on the URL<a id="_idIndexMarker715"/> provided in the <strong class="bold">Location</strong> field of this entry. This action will take you directly to the Argo CD interface, where you can manage and monitor your GitOps deployments within the <span class="No-Break"><strong class="source-inline">gitopsk8sdeployments</strong></span><span class="No-Break"> namespace.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer104">
					<img alt="Figure 8.12 – The login page for the created Argo CD instance for our demo project" src="image/B22100_08_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – The login page for the created Argo CD instance for our demo project</p>
			<ol>
				<li value="4">To retrieve the admin credentials, switch to the <strong class="bold">Developer</strong> mode in the OpenShift <span class="No-Break">web console.</span></li>
				<li>Then, click on <strong class="bold">Secrets</strong> in the side menu. Look for and select the secret named <strong class="source-inline">argocd-for-gitops-deployments-cluster</strong>. Within this secret’s details, find and copy the value of the <span class="No-Break"><strong class="source-inline">admin.password</strong></span><span class="No-Break"> entry.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer105">
					<img alt="Figure 8.13 – Secrets section of the gitopsk8sdeployments project" src="image/B22100_08_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Secrets section of the gitopsk8sdeployments project</p>
			<ol>
				<li value="6">Once you access <a id="_idIndexMarker716"/>the Argo CD interface, the application list should initially be empty, as illustrated in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.14</em>, since no applications have been deployed yet using Argo CD. At this point, you’re ready to create a new application. This step will involve defining the source repository, the path within the repository where your Kubernetes manifests are located, and the destination where your application should be deployed, in this case, the OpenShift <span class="No-Break">local cluster.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer106">
					<img alt="Figure 8.14 – Initial empty application list of the Argo CD instance" src="image/B22100_08_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – Initial empty application list of the Argo CD instance</p>
			<p class="list-inset">To create a new Argo CD application, you have the option to either use the Argo CD web UI or the <strong class="source-inline">oc</strong> CLI. If opting for the CLI, as demonstrated in an earlier section, you can apply a deployment file (e.g., <strong class="source-inline">argocd-deployment.yaml</strong>) that specifies the <span class="No-Break">application’s configuration.</span></p>
			<ol>
				<li value="7">Utilizing the code provided in the repository accompanying this chapter, you can create the new application by executing the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ oc apply -f argocd-deployment.yaml</strong></pre><p class="list-inset">The content of the <strong class="source-inline">argocd-deployment.yaml</strong> file is <span class="No-Break">as follows:</span></p><pre class="source-code">apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: my-weather-app
spec:
  destination:
    name: ''
    namespace: gitopsk8sdeployments
    server: 'https://kubernetes.default.svc'
  source:
    path: deployment/base
    repoURL: 'https://github.com/pietrolibro/gitops-k8s-deployments-book-weather-app.git'
    targetRevision: main
  sources: []
  project: default
  syncPolicy:
    automated: null
    CreateNamespace: true</pre><p class="list-inset">At this point, a<a id="_idIndexMarker717"/> new application titled <strong class="source-inline">my-weather-app</strong> will be visible in the Argo CD dashboard that was <span class="No-Break">previously opened.</span></p></li>			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer107">
					<img alt="Figure 8.15 – Argo CD instance populated with the newly created application" src="image/B22100_08_15.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – Argo CD instance populated with the newly created application</p>
			<ol>
				<li value="8">The app will<a id="_idIndexMarker718"/> initially appear in an <strong class="bold">OutofSync</strong> status, indicating that the actual state of the cluster does not match the desired state defined in the Git repository. To resolve this, click on <strong class="bold">Sync</strong> to synchronize the app with the desired state outlined in your repository. This action will start the deployment process according to the configurations defined in your <span class="No-Break">Git repository.</span></li>
				<li>Once the application is synchronized, <em class="italic">Figures 8.16-17</em>, it will align with the configurations defined in the manifest. This includes the deployment of two replicas, as specified in the manifest settings. The application’s status should reflect that it is now in sync with the desired state, with the two replicas running as intended within your <span class="No-Break">OpenShift cluster.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer108">
					<img alt="Figure 8.16 – Application panel after successful synchronization" src="image/B22100_08_16.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.16 – Application panel after successful synchronization</p>
			<div>
				<div class="IMG---Figure" id="_idContainer109">
					<img alt="Figure 8.17 – Detailed status of deployed resources after synchronization" src="image/B22100_08_17.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.17 – Detailed status of deployed resources after synchronization</p>
			<p class="list-inset">To test the <a id="_idIndexMarker719"/>GitOps CI/CD method of deployment, you can pull the repository locally using Git and then modify the number of replicas specified in the <span class="No-Break">deployment file.</span></p>
			<p class="list-inset">Changes to the application code alone will not cause the sync status to be marked as out of sync. The sync status is only affected by changes related to the deployment (e.g., YAML configuration files). GitOps tools such as Argo CD monitor the state of the configuration files in the repository. If there is a discrepancy between the desired state defined in the configuration files and the actual state in the Kubernetes cluster, it will be marked as out of sync. Therefore, only modifications to deployment files (such as YAML files) will impact the sync status, not changes to the application <span class="No-Break">code itself.</span></p>
			<p class="list-inset">This action embodies the iterative and controlled changes typical in GitOps workflows. If using Git directly is not your preference, you have the alternative to edit the file directly on GitHub, which simplifies the process while achieving the <span class="No-Break">same result.</span></p>
			<ol>
				<li value="10">Once you have<a id="_idIndexMarker720"/> made and committed your changes, the application status in Argo CD will shift to <strong class="bold">Out of Sync</strong>. This indicates that the actual deployment no longer matches the desired state as defined in your Git repository. In our demonstration, we are operating under a manual sync approach, meaning that after any changes, you will need to manually trigger a sync in Argo CD. This step is essential to apply the new configurations, highlighting the GitOps principle where updates are made through version-controlled files, with manual intervention kept to a minimum to ensure deliberate and <span class="No-Break">recorded changes.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer110">
					<img alt="Figure 8.18 – Application in the OutOfSync status after changes to the manifest files" src="image/B22100_08_18.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.18 – Application in the OutOfSync status after changes to the manifest files</p>
			<ol>
				<li value="11">To resynchronize <a id="_idIndexMarker721"/>the application and apply the updated configurations, simply click the <strong class="bold">Sync</strong> button in the Argo CD dashboard. After initiating the sync, monitor the process to ensure it completes successfully. Once the synchronization is successful, the application’s status will update to reflect that it is now in sync with the desired state as defined in your Git repository, incorporating the changes you made, such as the updated number <span class="No-Break">of replicas.</span></li>
			</ol>
			<p>As we transition from understanding the foundational aspects of Red Hat OpenShift and Kubernetes, we now shift our focus toward applying automation and configuration best Practices within <span class="No-Break">these environments.</span></p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor173"/>Automation and configuration best practices</h1>
			<p>OpenShift is widely<a id="_idIndexMarker722"/> adopted for hosting critical applications globally. As such, applications are expected to meet high availability standards, often aiming for five nines (99.999%) to ensure continuous service delivery. OpenShift assists in deploying applications in a highly available manner to mitigate outages, even when instances or infrastructure <span class="No-Break">are compromised.</span></p>
			<p>This summary outlines<a id="_idIndexMarker723"/> some key practices <a id="_idIndexMarker724"/>for deploying highly available applications <span class="No-Break">on OpenShift:</span></p>
			<ul>
				<li><strong class="bold">Multiple replicas</strong>: Deploying multiple pod instances ensures that the deletion or failure of a single pod doesn’t lead to downtime. A recommended practice is to have at least two replicas for each application to <span class="No-Break">ensure continuity.</span></li>
				<li><strong class="bold">Update strategy</strong>: Employ <strong class="bold">rolling</strong> and <strong class="bold">recreate</strong> strategies to update applications. The rolling strategy, which is the default, minimizes downtime by gradually replacing old pods with new ones. For critical applications, <strong class="source-inline">RollingUpdate</strong> <span class="No-Break">is recommended.</span></li>
				<li><strong class="bold">Graceful shutdown</strong>: Ensure your applications handle<a id="_idIndexMarker725"/> the <strong class="bold">SIGTERM</strong> signal gracefully, allowing them to shut down properly. Adjust <strong class="source-inline">terminationGracePeriodSeconds</strong> as needed to give your applications sufficient time to close <span class="No-Break">out tasks.</span></li>
				<li><strong class="bold">Probes</strong>: Use <strong class="bold">liveness</strong>, <strong class="bold">readiness</strong>, and <strong class="bold">startup</strong> probes to monitor application health. Liveness probes<a id="_idIndexMarker726"/> help restart applications in a failed state, readiness probes<a id="_idIndexMarker727"/> manage traffic flow to the application, and startup probes<a id="_idIndexMarker728"/> allow time for initial app startup before other probes <span class="No-Break">start monitoring.</span></li>
				<li><strong class="bold">External dependencies</strong>: Manage your application’s external dependencies effectively. Use <strong class="source-inline">initContainers</strong> or <strong class="source-inline">startupProbes</strong> to ensure dependencies are ready before starting your main application and employ readiness probes to maintain <span class="No-Break">health checks.</span></li>
				<li><strong class="bold">PodDisruptionBudgets (PDBs)</strong>: Implement<a id="_idIndexMarker729"/> PDBs to limit the number of pods that can be simultaneously unavailable during maintenance, thus preserving <span class="No-Break">application availability.</span></li>
				<li><strong class="bold">Autoscaling</strong>: Utilize <strong class="bold">HorizontalPodAutoscaler</strong> (<strong class="bold">HPA</strong>) and <strong class="bold">VerticalPodAutoscaler</strong> (<strong class="bold">VPA</strong>) to <a id="_idIndexMarker730"/>dynamically <a id="_idIndexMarker731"/>adjust the number of pod replicas or resources per pod based on the current load, ensuring that your application can handle varying levels <span class="No-Break">of traffic.</span></li>
				<li><strong class="bold">Pod topology spread constraints</strong>: Spread your pod replicas across different failure domains (e.g., nodes, racks, or zones) to avoid simultaneous downtime and ensure better availability <span class="No-Break">and resilience.</span></li>
				<li><strong class="bold">Deployment strategies</strong>: Use blue/green or canary deployment strategies to minimize disruptions during application updates. These strategies enable safer rollouts and<a id="_idIndexMarker732"/> easier rollback in case <span class="No-Break">of issues.</span></li>
			</ul>
			<p>For critical applications hosted on OpenShift, adopting these best practices will significantly boost availability, resilience, and continuous service delivery, meeting and even exceeding enterprise-level expectations<a id="_idIndexMarker733"/> and <strong class="bold">service-level </strong><span class="No-Break"><strong class="bold">agreements</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SLAs</strong></span><span class="No-Break">).</span></p>
			<p>Moreover, factors such as node sizing, resource allocation, and scheduling strategies play a vital role in enhancing the performance and dependability of your OpenShift framework. Regarding application security, we strongly recommend adhering to the following best <a id="_idIndexMarker734"/>practices to fortify the security posture of <span class="No-Break">your applications:</span></p>
			<ul>
				<li><strong class="bold">Utilize trusted base container images</strong>: Prioritize the use of official or vendor-provided container images, as they are rigorously tested, secured, and maintained. If you opt for community-supported images, ensure they are from reputable sources. Avoid images from unknown origins found in public registries such as Docker Hub, as they may pose <span class="No-Break">security risks.</span></li>
				<li><strong class="bold">Regularly update base container images</strong>: Staying updated with the latest versions of container images is crucial, as they include the most recent security patches and fixes. Implement automated processes in your CI pipeline to pull the latest base images during the build process and to trigger rebuilds of your application images when new base image updates <span class="No-Break">are released.</span></li>
				<li><strong class="bold">Differentiate between build and runtime images</strong>: Separate your build and runtime environments by using distinct images for each phase. The build image should contain only what is necessary for compiling and building the application, while the runtime image should be slimmed down to include only the essentials needed for running the application. This approach minimizes the attack surface by reducing unnecessary dependencies <span class="No-Break">and vulnerabilities.</span></li>
				<li><strong class="bold">Adhere to restricted security context constraints (SCCs)</strong>: Whenever feasible, configure your container images to comply with OpenShift’s restricted SCC. This <a id="_idIndexMarker735"/>constraint enforces stringent security policies, limiting the potential for security breaches. Adapting your applications to operate under the restricted SCC maximizes the security level, safeguarding the cluster in the event of an application compromise. Refer to OpenShift’s documentation on supporting arbitrary user IDs for <span class="No-Break">additional guidance.</span></li>
				<li><strong class="bold">Secure inter-component communications</strong>: Ensure that communication between application components is secured, particularly if sensitive data is being transmitted. While OpenShift’s<a id="_idIndexMarker736"/> network is designed to be secure, using <strong class="bold">Transport Layer Security</strong> (<strong class="bold">TLS</strong>) adds an extra layer of protection. For a more streamlined approach, consider utilizing <strong class="bold">OpenShift Service Mesh</strong>, which <a id="_idIndexMarker737"/>can manage TLS, taking the burden off individual applications and providing centralized <a id="_idIndexMarker738"/>control over <span class="No-Break">security policies.</span></li>
			</ul>
			<p>Having explored key practices to enhance application availability, resilience, and security within OpenShift, we conclude this section. These guidelines provide a foundation for maintaining robust, secure applications that meet enterprise standards. As we transition, the forthcoming section will delve into a comparative analysis between Kubernetes and Red Hat OpenShift. This comparison will illuminate the distinct features and benefits of each platform, helping you understand their unique advantages in various operational environments. Let’s proceed to uncover the differences and similarities that define Kubernetes and Red Hat OpenShift, setting the stage for informed decision making in your container <span class="No-Break">orchestration strategies.</span></p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor174"/>A comparison of Kubernetes Red Hat OpenShift</h1>
			<p><em class="italic">Table 8.1</em> provides<a id="_idIndexMarker739"/> a high-level comparison between <a id="_idIndexMarker740"/>Kubernetes and OpenShift. While Kubernetes offers a flexible and widely adopted container orchestration platform, OpenShift provides a more integrated and security-focused enterprise solution with extensive support and built-in features for developer productivity and <span class="No-Break">operational efficiency.</span></p>
			<table class="T---Table _idGenTablePara-1" id="table001-5">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Feature/Aspect</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Kubernetes</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">OpenShift</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Origin</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Open-source project <span class="No-Break">by Google</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Red <a id="_idIndexMarker741"/>Hat’s enterprise <span class="No-Break">Kubernetes</span><span class="No-Break"><a id="_idIndexMarker742"/></span><span class="No-Break"> distribution</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Installation</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Manual, requires setup of networking, <span class="No-Break">storage, etc.</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Streamlined with automated setups <span class="No-Break">and configurations</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Web UI</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Basic <span class="No-Break">dashboard available</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Comprehensive and user-friendly console with <span class="No-Break">advanced features</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Security</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Basic security features: additional tools are <span class="No-Break">often needed</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Enhanced security with built-in authentication and authorization, <span class="No-Break">SELinux integration</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">CI/CD integration</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Plugins and third-party <span class="No-Break">tools required</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Built-in CI/CD tools such as OpenShift Pipelines<a id="_idIndexMarker743"/> and <span class="No-Break"><strong class="bold">Source-to-Image</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">S2I</strong></span><span class="No-Break">)</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Networking</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Pluggable <strong class="bold">Container Network </strong><span class="No-Break"><strong class="bold">Interface</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CNI</strong></span><span class="No-Break">)</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Default <a id="_idIndexMarker744"/>SDN with additional <span class="No-Break">networking features</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Storage</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Supports PersistentVolumes with <span class="No-Break">manual configuration</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Simplified storage integration with <span class="No-Break">automatic provisioning</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Developer tools</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Limited <span class="No-Break">in-built tools</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Extensive tools including OpenShift Do (<strong class="source-inline">odo</strong>), S2I, <span class="No-Break">and DevSpaces</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold">Monitoring </strong><span class="No-Break"><strong class="bold">and logging</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Basic with third-party integration (<span class="No-Break">e.g., Prometheus)</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Integrated monitoring and <span class="No-Break">logging stack</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Registry</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Requires external or <span class="No-Break">third-party registry</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Integrated container <span class="No-Break">image registry</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Enterprise support</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Available through <span class="No-Break">third-party providers</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Direct support from <span class="No-Break">Red Hat</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold">Community </strong><span class="No-Break"><strong class="bold">and support</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Large <span class="No-Break">open-source community</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Strong open-source community with <span class="No-Break">enterprise support</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Pricing</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Free, costs <a id="_idIndexMarker745"/>associated with cloud providers<a id="_idIndexMarker746"/> <span class="No-Break">or infrastructure</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Subscription-based with various plans for <span class="No-Break">enterprise use</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.1 – A Kubernetes and Red Hat OpenShift feature/aspect comparison</p>
			<p>In concluding our comparison between Kubernetes and Red Hat OpenShift, we’ve uncovered the distinct features, advantages, and considerations of each platform. This analysis equips you with the knowledge to make informed decisions based on your specific operational needs and goals. As we move forward, let’s apply this understanding to further enhance our deployment strategies and operational efficiencies within the context of container orchestration and <span class="No-Break">cloud-native development.</span></p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor175"/>Summary</h1>
			<p>In this chapter, we embarked on an in-depth exploration of leveraging GitOps within the Red Hat OpenShift environment, highlighting the integration of automation and configuration best practices to enhance operational efficiency and security. We began by setting up a local OpenShift cluster using CRC, providing a sandbox for readers to apply real-world applications of GitOps principles. This practical approach demystified the process of deploying and managing containerized applications using declarative configurations and <span class="No-Break">automated workflows.</span></p>
			<p>We delved into various best practices, from using trusted base images and setting appropriate resource limits to implementing robust security measures such as TLS for inter-component communication. Each practice was designed to fortify the deployment process, reduce vulnerabilities, and ensure applications remain resilient and available. By comparing Kubernetes with Red Hat OpenShift, we provided insights into how OpenShift extends Kubernetes capabilities, offering enhanced features that cater to <span class="No-Break">enterprise needs.</span></p>
			<p>Throughout the chapter, the emphasis was placed on hands-on examples, ensuring that readers not only understand theoretical concepts but also how to apply them effectively in their own OpenShift environments. As we conclude, the knowledge and strategies discussed here pave the way for more secure, efficient, and reliable application deployments, reflecting the evolving landscape of cloud-native development and the increasing importance of <span class="No-Break">GitOps methodologies.</span></p>
			<p>In the next chapter, we will explore the integration of GitOps practices within Azure and AWS, unveiling advanced strategies for <span class="No-Break">cloud-native deployments.</span></p>
		</div>
	</body></html>