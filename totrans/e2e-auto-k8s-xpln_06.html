<html><head></head><body>
		<div id="_idContainer049">
			<h1 id="_idParaDest-57"><em class="italic"><a id="_idTextAnchor056"/>Chapter 4</em>: Composing Infrastructure with Crossplane</h1>
			<p>Composing is a powerful construct of Crossplane that makes it unique among its peers, such as the Open Service Broker API or AWS Controllers for Kubernetes. The ability to organize infrastructure recipes in a no-code way perfectly matches the organization’s agile expectation of building a lean platform team. This chapter will take us on a journey to learn about composing from end to end. We will start with a detailed understanding of how Crossplane <strong class="bold">Composite Resources</strong> (<strong class="bold">XRs</strong>) work and then cover a hands-on journey to build an XR step by step.</p>
			<p>The following are the topics covered in this chapter:</p>
			<ul>
				<li>Feeling like an API developer</li>
				<li>How do XRs work?</li>
				<li>Postprovisioning of an XR</li>
				<li>Preprovisioned resources</li>
				<li>Building an XR</li>
				<li>Troubleshooting</li>
			</ul>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Feeling like an API developer </h1>
			<p>Traditionally, infrastructure engineers<a id="_idIndexMarker151"/> know the most profound infrastructure configuration options and different infrastructure setup patterns. But they may not have experience in building APIs. Building an infrastructure platform with Crossplane will be a shift from these usual ways. Modern infrastructure platform developers should have both pieces of knowledge, that is, infrastructure and API engineering. Building infrastructure APIs as a platform developer means implementing the following aspects:</p>
			<ul>
				<li>Evolving the APIs as time passes by. This involves introducing new APIs, updating an existing API version, and deprecating the old APIs.</li>
				<li>Applying API cross-cutting concerns for consuming product teams, such as authentication, authorization, caching, and auditing.</li>
				<li>Encapsulating different infrastructure policies within the APIs.</li>
				<li>Building reusable infrastructure<a id="_idIndexMarker152"/> recipes used across teams. For example, some product teams might develop their applications with the <strong class="bold">MEAN</strong> stack (<strong class="bold">MongoDB, Express.js, AngularJS, and Node.js</strong>). We might be interested in developing infrastructure provisioning for this stack as a template API.</li>
				<li>Building the required shared infrastructure used across teams. For example, we might want to provision a virtual private network shared by different infrastructure resources.</li>
				<li>Achieving and evolving correct API boundaries considering the different infrastructure recipes and shared infrastructure. We must perform trade-off analysis to deal with conflicting concerns between infrastructure recipes and shared infrastructure.</li>
			</ul>
			<p>Infrastructure recipes and shared infrastructure are vital elements in API-bounded context trade-offs. We will examine this in detail in an upcoming chapter. The following figure represents the nuances of API infrastructure<a id="_idIndexMarker153"/> engineering:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B17830_04_01.jpg" alt="Figure 4.1 – API infrastructure engineering&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – API infrastructure engineering</p>
			<p>We are looking at these aspects to understand XR architecture in the best possible way. Every element of the Crossplane composite is designed to cover infrastructure engineering<a id="_idIndexMarker154"/> practices from the perspective of an API.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">We can use the learnings from microservices architecture pattern to define infrastructure API boundaries. There is no perfect boundary, and every design option will have advantages and disadvantages. In <a href="B17830_06_ePub.xhtml#_idTextAnchor092"><em class="italic">Chapter 6</em></a>, <em class="italic">More Crossplane Patterns</em>, we can look for ways to adopt microservices with the Crossplane infrastructure platform.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>How do XRs work?</h1>
			<p>An XR can do two things under<a id="_idIndexMarker155"/> the hood. The first purpose is to combine related <strong class="bold">Managed Resources</strong> (<strong class="bold">MRs</strong>) into a single stack and build reusable<a id="_idIndexMarker156"/> infrastructure template APIs. When we do this, we might apply different patterns, such as shared resources between applications or cached infrastructure for faster provisioning. The second one is to expose only limited attributes<a id="_idIndexMarker157"/> of the infrastructure API to the application team after abstracting all organization policies. We will get into the details of achieving these aspects as we progress in this chapter. The following are the<a id="_idIndexMarker158"/> critical components in an XR:</p>
			<ul>
				<li><strong class="bold">Composite Resource Definition</strong> (<strong class="bold">XRD</strong>)</li>
				<li>Composition</li>
				<li>Claim</li>
			</ul>
			<p>Let’s start looking at the purpose of each component and how they interact with each other.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>XRD</h2>
			<p>The <strong class="bold">XRD</strong> is the schema defining the infrastructure<a id="_idIndexMarker159"/> API specification. It is best to describe<a id="_idIndexMarker160"/> an XRD first. Fixing the API specification first will force us to think about end users’ needs and the different ways they will consume the API. We will also apply all the organization policies to decide what fields are to be exposed to an application team. It will clearly set the scope and the boundary of the API. <strong class="source-inline">CompositeResourceDefinition</strong> is the Crossplane configuration element used to define an XRD. Creating this configuration is like writing an OpenAPI Specification or Swagger API definition. The following are the critical aspects of the <strong class="source-inline">CompositeResourceDefinition</strong> configuration YAML:</p>
			<ul>
				<li><strong class="bold">The XR names</strong>: These will be the<a id="_idIndexMarker161"/> first to define, representing the infrastructure API name in singular and plural format. The singular name will eventually become the <strong class="source-inline">kind</strong> attribute of the new API. Note that it’s standard practice to use <em class="italic">X</em> as a prefix for the XR name.</li>
				<li><strong class="bold">API group</strong>: This will help us to group the API logically, avoid naming conflicts, and manage authorization.</li>
				<li><strong class="bold">Metadata name</strong>: Metadata is a string value constructed <a id="_idIndexMarker162"/>in a standard format. It is the concatenation of the plural name (plural name of the XR) and a dot followed by the API group (the group under which we what to classify the XR resource). In other words, the string follows this template: <strong class="source-inline">&lt;resource plural name&gt;.&lt;API group&gt;</strong>.</li>
				<li><strong class="bold">versions</strong>: This is an XRD configuration<a id="_idIndexMarker163"/> construct that will help us to manage the API versions. The <strong class="source-inline">versions</strong> element is an array and can hold configuration for multiple versions of the same XR API. Typically, when we start, we will have just one version. As time progresses, we will increment the API version with changes. The old version can become a technical debt to deprecate later.</li>
				<li><strong class="bold">served and referenceable</strong>: These are a couple of mandatory Boolean attributes for every defined version. The <strong class="source-inline">served</strong> element will indicate whether the XR API is served with the given version. The <strong class="source-inline">referenceable</strong> flag will determine whether we can define an implementation for the given API version. We can look at version management and these attributes in more depth in <a href="B17830_05_ePub.xhtml#_idTextAnchor074"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Infrastructure Platform Patterns</em>. For now, both flags will be <strong class="source-inline">true</strong> when we have only one version defined in the XRD.</li>
				<li><strong class="bold">Schema</strong>: This is a section under each version covering the actual OpenAPI specification. It covers details such as parameter lists, data types, and required parameters.</li>
				<li><strong class="bold">Connection secret keys</strong>: This will hold the list of keys that need to be created and populated in the Kubernetes Secrets after the resource provisioning.</li>
				<li><strong class="bold">Composition reference</strong>: These parameters influence which resource-composing implementation is to be used on specific infrastructure API calls. In other words, we could have multiple API implementations for the given XRD, and this section of the XRD configuration will help to define the default implementation or enforced implementation. <strong class="source-inline">DefaultCompositionRef</strong> and <strong class="source-inline">EnforcedCompositionRef</strong> are a couple of attributes providing this flexibility.</li>
				<li><strong class="bold">Claim names</strong>: These are optional parameters<a id="_idIndexMarker164"/> that create a proxy API for the given XR API with the specified name. Applying the claim object’s create, delete, and update action will create, delete, and update the underlying XR. Claims are a critical component in Crossplane, and we will look at that in a dedicated topic shortly in this chapter.</li>
			</ul>
			<p>The XRD<a id="_idIndexMarker165"/> is nothing but an opinionated <strong class="bold">Custom Resource Definition</strong> (<strong class="bold">CRD</strong>), and many parts of the configuration<a id="_idIndexMarker166"/> look like a CRD. These are just a few possible parameters. We will look at a few more parameters as we progress through the book. The complete API documentation is available at <a href="https://doc.crds.dev/github.com/crossplane/crossplane">https://doc.crds.dev/github.com/crossplane/crossplane</a>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">We are looking at v1.5.1 of the Crossplane documentation, which is the latest at the time of writing this chapter. Refer to the latest version at the time of reading for more accurate details.</p>
			<p>Note that some of the configurations<a id="_idIndexMarker167"/> discussed previously are not part of the following YAML, such as <strong class="source-inline">DefaultCompositionRef</strong> and <strong class="source-inline">ConnectionSecretKeys</strong>. These configurations are injected by Crossplane with default behavior if not specified. Refer to the following YAML for an example:</p>
			<pre class="source-code">apiVersion: apiextensions.crossplane.io/v1</pre>
			<pre class="source-code">kind: CompositeResourceDefinition</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  #'&lt;plural&gt;.&lt;group&gt;'</pre>
			<pre class="source-code">  name: xclouddbs.book.imarunrk.com</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  # API group</pre>
			<pre class="source-code">  group: book.imarunrk.com</pre>
			<pre class="source-code">  # Singular name and plural name.</pre>
			<pre class="source-code">  names:</pre>
			<pre class="source-code">    kind: xclouddb</pre>
			<pre class="source-code">    plural: xclouddbs</pre>
			<pre class="source-code">  # Optional parameter to create namespace proxy claim API</pre>
			<pre class="source-code">  claimNames:</pre>
			<pre class="source-code">    kind: Clouddb</pre>
			<pre class="source-code">    plural: Clouddbs</pre>
			<pre class="source-code">  # Start from alpha to beta to production to deprecated.</pre>
			<pre class="source-code">  versions:</pre>
			<pre class="source-code">  - name: v1</pre>
			<pre class="source-code">    # Is the specific version actively served</pre>
			<pre class="source-code">    served: true</pre>
			<pre class="source-code">    # Can the version be referenced from an API implementation</pre>
			<pre class="source-code">    referenceable: true</pre>
			<pre class="source-code">    # OpenAPI schema </pre>
			<pre class="source-code">    schema:</pre>
			<pre class="source-code">      openAPIV3Schema:</pre>
			<pre class="source-code">        type: object</pre>
			<pre class="source-code">        properties:</pre>
			<pre class="source-code">          spec:</pre>
			<pre class="source-code">            type: object</pre>
			<pre class="source-code">            properties:</pre>
			<pre class="source-code">              parameters:</pre>
			<pre class="source-code">                type: object</pre>
			<pre class="source-code">                properties:</pre>
			<pre class="source-code">                  storageSize:</pre>
			<pre class="source-code">                    type: integer</pre>
			<pre class="source-code">                required:</pre>
			<pre class="source-code">                - storageSize</pre>
			<pre class="source-code">            required:</pre>
			<pre class="source-code">            - parameters</pre>
			<p>Once we are done with the API<a id="_idIndexMarker168"/> specification, the next step<a id="_idIndexMarker169"/> is to build the API implementation. Composition is the Crossplane construct used for providing API implementation.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Composition</h2>
			<p>The composition<a id="_idIndexMarker170"/> will link one or more MRs<a id="_idIndexMarker171"/> with an XR API. When we create, update, and delete an XR, the same operation will happen on all the linked MRs. We can consider XRD as the CRD and composition as the custom controller implementation. The following diagram represents how XR, XRD, composition, and MRs are related:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B17830_04_02.jpg" alt="Figure 4.2 – XRM, composition, and XR&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – XRM, composition, and XR</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">We have referred to XR in this book in two contexts. We can use XR to refer to a new infrastructure API that we are building. Also, the composition resources list can hold both an MR and an existing XR. We will also refer to an XR from that context. Look at <em class="italic">Figure 4.2</em> where XR is referred to in both dimensions.</p>
			<p>Let’s look at some<a id="_idIndexMarker172"/> of the crucial elements<a id="_idIndexMarker173"/> from the composition configuration:</p>
			<ul>
				<li><strong class="bold">CompositeTypeRef</strong>: This is an attribute that will help us to map a specific XR version with the current composition. <strong class="source-inline">kind</strong> and <strong class="source-inline">apiVersion</strong> are the two configuration elements defined under <strong class="source-inline">CompositeTypeRef</strong>. While <strong class="source-inline">kind</strong> specifies the XR name, <strong class="source-inline">apiVersion</strong> will refer to a specific version defined in the XRD. The mapped version should be configured as referenceable in the XRD.</li>
				<li><strong class="bold">WriteConnectionSecretsToNamespace</strong>: This will specify the namespace for storing the connection Secrets.</li>
				<li><strong class="bold">Resources</strong>: This section is an array that holds the list of MRs to be created, updated, and deleted when someone creates, updates, and deletes the XR. We can even define another XR under this section. It is a mandatory section, and we should define at least one resource, either an MR or XR. The base is the critical object under each resource that holds the XR/MR configuration template.</li>
				<li><strong class="bold">Patches</strong>: This section under a given resource<a id="_idIndexMarker174"/> will be helpful to overlay the API input attributes to the composing resource (MR/XR) attributes. This section is optional and an array where we can specify multiple patches. There are many predefined types of patches. <strong class="source-inline">FromCompositeFieldPath</strong> is the default type and is used most frequently. It is helpful to patch an attribute from the XR into the composition resource base template, that is, feeding the user input into the composing resources. <strong class="source-inline">FromFieldPath</strong> and <strong class="source-inline">ToFieldPath</strong> are the subattributes that perform the actual patching. There is a patch type called <strong class="source-inline">ToCompositeFieldPath</strong>, which does the reverse of <strong class="source-inline">FromCompositeFieldPath</strong>. We could copy fields from the resources back into the XR using this patch type. The <strong class="source-inline">CombineFromComposite</strong> patch type is the most suitable option when combining multiple attributes.</li>
				<li><strong class="bold">Transforms</strong>: These are optional elements helpful in computing the patched fields. These are predefined functions, such as <strong class="source-inline">convert</strong> for typecasting, <strong class="source-inline">math</strong> for mathematical operations, and <strong class="source-inline">map</strong> for key-value operations. We could have a list of transform functions on a given patch, and they are executed in the order specified in the configuration. Both patches and transforms are vital patterns. We will look at different configuration examples for patches and transforms throughout the book.</li>
				<li><strong class="bold">Policy</strong>: These are under each patch<a id="_idIndexMarker175"/> and will determine the patching behavior. We can mandate the patch path presence because the default behavior is to skip the patch if the field is absent. Also, we can configure the behavior of merge when the patching is performed over an object.</li>
				<li><strong class="bold">ConnectionDetails</strong>: These are specified under each resource and will hold the list of secret keys we want to propagate back into the XR.</li>
				<li><strong class="bold">ReadinessChecks</strong>: These will allow us to define any custom readiness logic. If this section is not provided, the default behavior is to make the XR state ready when all the composing resources are ready.</li>
				<li><strong class="bold">PatchSets</strong>: This is the final attribute<a id="_idIndexMarker176"/> that we will cover. Patch sets allow us to define a set of reusable patch functions that can be used across multiple resources. It’s like a shared reusable function.<p class="callout-heading">Tip</p><p class="callout">We have a few field path attributes when defining a composition. Values for these fields will follow standard JavaScript syntax to access JSON, for example, <strong class="source-inline">spec.parameters.storageSize</strong> or <strong class="source-inline">spec.versions[0].name</strong>.</p></li>
			</ul>
			<p>We covered most of the configuration<a id="_idIndexMarker177"/> options available with the composition. Have a look at the Crossplane documentation<a id="_idIndexMarker178"/> for the complete list. The following figure represents the composition configuration options and the relationship between them:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B17830_04_03.jpg" alt="Figure 4.3 – Composition configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Composition configuration</p>
			<p>The following is a sample<a id="_idIndexMarker179"/> composition configuration YAML:</p>
			<pre class="source-code">apiVersion: apiextensions.crossplane.io/v1</pre>
			<pre class="source-code">kind: Composition</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: xclouddb-composition</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  # Link Composition to a specific XR and version</pre>
			<pre class="source-code">  compositeTypeRef:</pre>
			<pre class="source-code">    apiVersion: xclouddb.book.imarunrk.com/v1</pre>
			<pre class="source-code">    kind: Xclouddb</pre>
			<pre class="source-code">  # Connection secrets namespace</pre>
			<pre class="source-code">  writeConnectionSecretsToNamespace: crossplane-system</pre>
			<pre class="source-code">  # List of composed MRs or XRs.</pre>
			<pre class="source-code">  resources:</pre>
			<pre class="source-code">  - name: clouddbInstance</pre>
			<pre class="source-code">    # Resource base template</pre>
			<pre class="source-code">    base:</pre>
			<pre class="source-code">      apiVersion: database.gcp.crossplane.io/v1beta1</pre>
			<pre class="source-code">      kind: CloudSQLInstance</pre>
			<pre class="source-code">      spec:</pre>
			<pre class="source-code">        forProvider:</pre>
			<pre class="source-code">          databaseVersion: POSTGRES_9_6</pre>
			<pre class="source-code">          region: us-central</pre>
			<pre class="source-code">          settings:</pre>
			<pre class="source-code">            tier: db-g1-small</pre>
			<pre class="source-code">            dataDiskSizeGb: 20</pre>
			<pre class="source-code">    # Resource patches </pre>
			<pre class="source-code">    patches:</pre>
			<pre class="source-code">    - type: FromCompositeFieldPath</pre>
			<pre class="source-code">      fromFieldPath: spec.parameters.storageSize</pre>
			<pre class="source-code">      toFieldPath: spec.forProvider.settings.dataDiskSizeGb</pre>
			<pre class="source-code">    # Resource secrets</pre>
			<pre class="source-code">    connectionDetails:</pre>
			<pre class="source-code">    - name: hostname</pre>
			<pre class="source-code">      fromConnectionSecretKey: hostname</pre>
			<p>We will cover an example<a id="_idIndexMarker180"/> with more configuration elements in the <em class="italic">Building an XR</em> section. An XRD version can have more<a id="_idIndexMarker181"/> than one composition, that is, one-to-many relationships between the XRD version and composition. It provides polymorphic behavior for our infrastructure API to work based on the context. For example, we could have different compositions defined for production and staging. The <strong class="source-inline">CompositionRef</strong> attribute defined in the XR can refer to a specific composition. Instead of <strong class="source-inline">CompositionRef</strong>, we can also use <strong class="source-inline">CompositionSelector</strong> to match the compositions based on labels.</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B17830_04_04.jpg" alt="Figure 4.4 – XR and composition relation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – XR and composition relation</p>
			<p>In the next<a id="_idIndexMarker182"/> section, we will look at <strong class="bold">XR claims</strong>, also known as <strong class="bold">claims</strong>.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Claim</h2>
			<p>A claim is a proxy API to the XR, created<a id="_idIndexMarker183"/> by providing claim name attributes<a id="_idIndexMarker184"/> in XRD configurations. As a general practice, we provide the exact name of the XR after removing the initial <strong class="source-inline">X</strong>. In the preceding example, <strong class="source-inline">xclouddb</strong> is the XR name and <strong class="source-inline">Clouddb</strong> is the claim name but following such naming conventions is not mandatory. Claims are very similar to the XR, and it might tempt us to think that it’s an unnecessary proxy layer. Having a claim is helpful<a id="_idIndexMarker185"/> in many ways, such as the following:</p>
			<ul>
				<li>XRs are cluster-level resources, while the claims are namespace level. It enables us to create namespace-level authorization. For example, we can assign different permissions for different product teams based on their namespace ownership.</li>
				<li>We can keep some of the XR only as a private API at the cluster level for the platform team’s use. For example, the platform team may not be interested in exposing the XR API that creates a virtual private network.</li>
				<li>It’s not ideal to manage some of the resources at the namespace level as they are shared between teams and do not fit into the context.</li>
				<li>We can also use this pattern to support the preprovisioning of infrastructure. A claim can just reference itself with a preprovisioned XR infrastructure, keeping the provisioning time low. It is very similar to caching.</li>
			</ul>
			<p>The following figure represents<a id="_idIndexMarker186"/> how claims, XR, XRD, composition, and MRs are related, giving an end-to-end view of how the whole concept works:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B17830_04_05.jpg" alt="Figure 4.5 – How does composition work?&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – How does composition work?</p>
			<p>The following are the sample<a id="_idIndexMarker187"/> claim and XR YAML. The claim YAML is as follows:</p>
			<pre class="source-code">apiVersion: book.imarunrk.com/v1</pre>
			<pre class="source-code"># Kind name matches the singular claim name in the XRD</pre>
			<pre class="source-code">kind: Clouddb</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: cloud-db</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  # Parameters to be mapped and patched in the composition </pre>
			<pre class="source-code">  parameters:</pre>
			<pre class="source-code">    storageSize: 20</pre>
			<pre class="source-code">  # Name of the composition to be used</pre>
			<pre class="source-code">  compositionRef:</pre>
			<pre class="source-code">    name: xclouddb-composition</pre>
			<pre class="source-code">  writeConnectionSecretToRef:</pre>
			<pre class="source-code">    namespace: crossplane-system</pre>
			<pre class="source-code">    name: db-conn</pre>
			<p>A namespace is not part of the preceding claim YAML. Hence, it will create<a id="_idIndexMarker188"/> the resource in the default namespace, the Kubernetes standard. An equivalent XR YAML to the preceding claim YAML is as follows:</p>
			<pre class="source-code">apiVersion: book.imarunrk.com/v1</pre>
			<pre class="source-code">kind: XClouddb</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: cloud-db</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  parameters:</pre>
			<pre class="source-code">    storageSize: 20</pre>
			<pre class="source-code">  compositionRef:</pre>
			<pre class="source-code">    name: xclouddb-composition</pre>
			<pre class="source-code">  writeConnectionSecretToRef:</pre>
			<pre class="source-code">    namespace: crossplane-system</pre>
			<pre class="source-code">    name: db-conn</pre>
			<p>Note that the XR is always created<a id="_idIndexMarker189"/> at the cluster level and namespace configuration under metadata is not applicable. We can look at a more detailed claim and XR configurations in the <em class="italic">Building an XR</em> section. Let’s explore a few more XR, XRD, composition, and claim configurations from the perspective of postprovisioning requirements.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Postprovisioning of an XR</h1>
			<p>After performing CRUD operations <a id="_idIndexMarker190"/>over a claim or XR resource, the following are some critical aspects to bring the API request to a close:</p>
			<ul>
				<li>Readiness check</li>
				<li>Patch status</li>
				<li>Propagating the credentials back </li>
			</ul>
			<p>Let’s start with learning about readiness checks.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Readiness check</h2>
			<p>The XR state will be ready<a id="_idIndexMarker191"/> by default when all the underlying resources are ready. Every resource element in the composition can define its custom readiness logic. Let’s look at a few of the custom readiness check configurations. If you want to match one of the composing resource status fields to a predefined string, use <strong class="source-inline">MatchString</strong>. A sample configuration for <strong class="source-inline">MatchString</strong> is as follows:</p>
			<pre class="source-code">- type: MatchString</pre>
			<pre class="source-code">  fieldPath: status.atProvider.state</pre>
			<pre class="source-code">  matchString: "Online"</pre>
			<p><strong class="source-inline">MatchInteger</strong> will perform a similar function when two integers are matched. The following sample configuration will check the <strong class="source-inline">state</strong> attribute with integer <strong class="source-inline">1</strong>:</p>
			<pre class="source-code"> - type: MatchInteger</pre>
			<pre class="source-code">  fieldPath: status.atProvider.state</pre>
			<pre class="source-code">  matchInteger: 1</pre>
			<p>Use the <strong class="source-inline">None</strong> type to consider the readiness as soon as the resource is available:</p>
			<pre class="source-code">- type: None</pre>
			<p>Use <strong class="source-inline">NonEmpty</strong> to make the resource ready as soon as some value exists in the field of our choice. The following example will make the readiness true as soon as some value exists under the mentioned field path:</p>
			<pre class="source-code">- type: NonEmpty</pre>
			<pre class="source-code">  fieldPath: status.atProvider.state</pre>
			<p>In the next section, we will look at an example of patching a status attribute after resource provisioning. Note that <strong class="source-inline">fieldPath</strong> falls under the <strong class="source-inline">status</strong> attribute. These are the attributes filled by MR during resource provisioning based on the values it gets back from the cloud provider.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Patch status</h2>
			<p><strong class="source-inline">ToCompositeFieldPath</strong> is a patch type for copying<a id="_idIndexMarker192"/> any attribute from a specific composed resource back into the XR. Generally, we use it to copy the status fields. We can look at these as a way to define the API response. While there is a set of existing default status fields, patched fields are custom defined to enhance our debugging, monitoring, and audit activities. First, we need to define the state fields as a part of openAPIV3Schema in the XRD to make the new status fields available in the XR. The next step is to define a patch under the specific composing resource. The following patch will copy the current disk size of the CloudSQLInstance to the XR:</p>
			<pre class="source-code">- type: ToCompositeFieldPath</pre>
			<pre class="source-code">  fromFieldPath: status.atProvider.currentDiskSize</pre>
			<pre class="source-code">  toFieldPath: status.dbDiskSize</pre>
			<p>We can also use the <strong class="source-inline">CombineToComposite</strong> patch type if we need to copy a combination of multiple fields.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Propagating credentials back</h2>
			<p>We can see that the connection<a id="_idIndexMarker193"/> secret-related configuration<a id="_idIndexMarker194"/> is part of the XRD, XR, claim, and composition. We must understand the relationship between these configurations to configure it correctly and get it working:</p>
			<ul>
				<li>Define the list of connection secret keys in the XRD using the <strong class="source-inline">ConnectionSecretKeys</strong> configuration.</li>
				<li>Configure the composing resources to define how to populate connection keys defined in the XRD. Connection details configuration can be of different types. The <strong class="source-inline">FromConnectionSecretKey</strong> type is correct when copying the secret from an existing secret key. We have the <strong class="source-inline">FromFieldPath</strong> type for copying the connection details from one of the composing resource fields.</li>
				<li>The claim or XR should save the Secrets using the <strong class="source-inline">WriteConnectionSecretToRef</strong> configuration.</li>
			</ul>
			<p>The following diagram can help create a mind map of these configurations:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B17830_04_06.jpg" alt="Figure 4.6 – Propagating the Secrets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Propagating the Secrets</p>
			<p>The section covered different<a id="_idIndexMarker195"/> patterns that we can use with composition<a id="_idIndexMarker196"/> after the resources are provisioned. It is like customizing the API responses. Now we can look at the usefulness of reusing existing resources.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/>Preprovisioned resources</h1>
			<p>There are a few use cases where<a id="_idIndexMarker197"/> we may not create a new external resource and instead will reuse an existing provisioned resource. We will look at two such use cases in this section. The first use case is when we decide to cache the composed recourses because new resource provisioning may take too long to complete. The platform team can provision an XR and keep the resources in the resource pool. Then, the product team can claim these resources by adding the <strong class="source-inline">ResourceRef</strong> configuration under the spec of a claim YAML. With this pattern, we should ensure that the new claim attributes match the attributes in the existing pre-provisioned XR. If some of the attributes are different, Crossplane will try to update the XR specifications to match what is mentioned in the claim.</p>
			<p>The second<a id="_idIndexMarker198"/> use case is about importing the existing resources from the external provider into the Crossplane. The <strong class="source-inline">crossplane.io/external-name</strong> annotation can help with this. Crossplane will look for an existing resource with the name mentioned in this configuration. The external name configuration mentioned in a claim will automatically be propagated into the XR. Still, it’s our responsibility to patch this configuration into the composing resource. The following is a sample MR YAML where we onboard an existing VPC with the name <strong class="source-inline">alpha-beta-vpc</strong>:</p>
			<pre class="source-code">apiVersion: compute.gcp.crossplane.io/v1beta1</pre>
			<pre class="source-code">kind: Network</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: alpha-beta-vpc-crossplane-ref</pre>
			<pre class="source-code">  annotations:</pre>
			<pre class="source-code">    # Annotation to provide existing resource named</pre>
			<pre class="source-code">    crossplane.io/external-name: alpha-beta-vpc</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  providerConfigRef:</pre>
			<pre class="source-code">    name: gcp-credentials-project-1</pre>
			<pre class="source-code">  # Provide the required parameters same as external resource.</pre>
			<pre class="source-code">  forProvider:</pre>
			<pre class="source-code">    autoCreateSubnetworks: true</pre>
			<p>Once you apply the YAML, you will see that it’s ready for use in Crossplane. This can be seen in the following screenshot:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B17830_04_07.jpg" alt="Figure 4.7 – VPC reference status&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – VPC reference status</p>
			<p>Note that the <strong class="source-inline">alpha-beta-vpc</strong> VPC is an existing VPC we created manually in GCP. What we achieve here is to map the manual resource to a Claim.The section covered different ways<a id="_idIndexMarker199"/> we can use preprovisioned resources with an XR/claim. The following section will be a hands-on journey to build an XR from scratch.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Building an XR</h1>
			<p>It’s time to go through a hands-on journey <a id="_idIndexMarker200"/>to build an XR from scratch. We will start with writing down the infrastructure API requirement at a high level, then provide an API specification with XRD and finally provide an implementation with a composition. We will cover the API requirement in such a way as to learn most of the configuration discussed in this chapter.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>The infrastructure API requirement</h2>
			<p>We will develop<a id="_idIndexMarker201"/> an API to provision a database<a id="_idIndexMarker202"/> from Google Cloud. The following are the compliance, architecture, and product team’s requirements:</p>
			<ul>
				<li><strong class="bold">Compliance policy</strong>: The provisioning should be done in the <strong class="source-inline">us-central</strong> region to comply with the data storage regulations from the government.</li>
				<li><strong class="bold">Architecture policy</strong>: We should have two tiers of the database. For small, the disk size should be 20 GB, and it should be 40 GB for big.</li>
				<li><strong class="bold">Architecture policy</strong>: The small tier’s virtual machine should be <strong class="source-inline">db-g1-small</strong>, and <strong class="source-inline">db-n1-standard-1</strong> for the big tier.</li>
				<li><strong class="bold">Product team</strong>: We should have the option to choose between Postgres and MySQL.</li>
				<li><strong class="bold">Product team</strong>: We should specify the size in the XR with two enums (<strong class="source-inline">SMALL</strong> or <strong class="source-inline">BIG</strong>).</li>
				<li><strong class="bold">Platform team</strong>: Patch the zone in which the database is created back into the XR/claim status field for monitoring requirements.</li>
			</ul>
			<p>The next step is to write the XRD configuration YAML.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>Creating the XRD</h2>
			<p>When defining the API specification<a id="_idIndexMarker203"/> with an XRD, the following configurations<a id="_idIndexMarker204"/> should be encoded into the YAML:</p>
			<ul>
				<li>Use <strong class="source-inline">alpha-beta.imarunrk.com</strong> as the API group to organize all APIs for alpha and beta teams.</li>
				<li>We will provide the XR name as <strong class="source-inline">XGCPdb</strong> and the claim name as <strong class="source-inline">GCPdb</strong>.</li>
				<li>We will start with a new API version, v1.</li>
				<li>Create <strong class="source-inline">size</strong> as an input parameter and <strong class="source-inline">zone</strong> as the response status attribute.</li>
			</ul>
			<p>As the example XRD is oversized, we will cover only the schema definition here. Refer to the entire XRD file at <a href="https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter04/Hand-on-examples/Build-an-XR/xrd.yaml">https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter04/Hand-on-examples/Build-an-XR/xrd.yaml</a>. Without wasting much time, let’s look at the schema:</p>
			<pre class="source-code">    schema:</pre>
			<pre class="source-code">      openAPIV3Schema:</pre>
			<pre class="source-code">        type: object</pre>
			<pre class="source-code">        properties:</pre>
			<pre class="source-code">          # Spec – defines the API input</pre>
			<pre class="source-code">          spec:</pre>
			<pre class="source-code">            type: object</pre>
			<pre class="source-code">            properties:</pre>
			<pre class="source-code">              parameters:</pre>
			<pre class="source-code">                type: object</pre>
			<pre class="source-code">                properties:</pre>
			<pre class="source-code">                  # Size will be a user input</pre>
			<pre class="source-code">                  size:</pre>
			<pre class="source-code">                    type: string</pre>
			<pre class="source-code">                required:</pre>
			<pre class="source-code">                - size</pre>
			<pre class="source-code">            required:</pre>
			<pre class="source-code">            - parameters</pre>
			<pre class="source-code">          # status – the additional API output parameter</pre>
			<pre class="source-code">          status:</pre>
			<pre class="source-code">            type: object</pre>
			<pre class="source-code">            # Recourse zone - status patch parameter.</pre>
			<pre class="source-code">            properties:</pre>
			<pre class="source-code">              zone:</pre>
			<pre class="source-code">                description: DB zone.</pre>
			<pre class="source-code">                type: string</pre>
			<p>Save the YAML from GitHub<a id="_idIndexMarker205"/> and apply it to the cluster with <strong class="source-inline">kubectl apply -f xrd.yaml</strong>. Refer to the<a id="_idIndexMarker206"/> following screenshot, which shows successful XRD creation:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B17830_04_08.jpg" alt="Figure 4.8 – XRD creation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – XRD creation</p>
			<p>Note that the <strong class="source-inline">ESTABLISHED</strong> and <strong class="source-inline">OFFERED</strong> flags in the screenshot are <strong class="source-inline">True</strong>. This means that the XRD is created correctly. If these statuses are not <strong class="source-inline">True</strong>, use kubectl to describe the details of the XRD and look for an error.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Providing implementation</h2>
			<p>The next step is to provide<a id="_idIndexMarker207"/> an API implementation. As a part<a id="_idIndexMarker208"/> of the implementation, we should be providing a composition configuration. We will create two compositions, one for Postgres and the other for MySQL. It will be an example of the polymorphic behavior<a id="_idIndexMarker209"/> implementation. The following are the steps<a id="_idIndexMarker210"/> to remember when we build the composition YAML:</p>
			<ol>
				<li>Refer to the v1 XRD API version with the <strong class="source-inline">CompositeTypeRef</strong> configuration.</li>
				<li>Define the <strong class="source-inline">CloudSQLInstance</strong> configuration under the resource base.</li>
				<li>Hardcode the region to <strong class="source-inline">us-central1</strong> to meet the compliance requirement.</li>
				<li>The database tier and disk size will hold default values, but the patch configuration will overlay them using the <strong class="source-inline">FromCompositeFieldPath</strong> patch type.</li>
				<li>Use the <strong class="source-inline">Map</strong> transformation to convert the <strong class="source-inline">SMALL</strong> tier size to the <strong class="source-inline">db-g1-small</strong> machine tier. Use the <strong class="source-inline">Map</strong> and <strong class="source-inline">Convert</strong> transformations to map the <strong class="source-inline">SMALL</strong> tier size to the 20 GB disk size.</li>
				<li>Similar mapping will be done for the <strong class="source-inline">BIG</strong> configuration.</li>
				<li>Patch the <strong class="source-inline">GceZone</strong> attribute from the MR status to the XR/claim for monitoring. We can achieve this using the <strong class="source-inline">ToCompositeFieldPath</strong> patch type.</li>
				<li>Provide a mapping between the MR connection secret key to the XR/claim keys with the <strong class="source-inline">ConnectionDetails</strong> configuration.</li>
			</ol>
			<p>We will look at the Postgres composition example in four parts. The XRD and resource definition section of the composition will look like the following configuration:</p>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  # Refer to an XRD API version</pre>
			<pre class="source-code">  compositeTypeRef:</pre>
			<pre class="source-code">    apiVersion: alpha-beta.imarunrk.com/v1</pre>
			<pre class="source-code">    kind: XGCPdb</pre>
			<pre class="source-code">  writeConnectionSecretsToNamespace: crossplane-system</pre>
			<pre class="source-code">  resources:</pre>
			<pre class="source-code">    # Provide configuration for Postgres resource</pre>
			<pre class="source-code">  - name: cloudsqlinstance</pre>
			<pre class="source-code">    base:</pre>
			<pre class="source-code">      apiVersion: database.gcp.crossplane.io/v1beta1</pre>
			<pre class="source-code">      kind: CloudSQLInstance</pre>
			<pre class="source-code">      spec:</pre>
			<pre class="source-code">        # reference to GCP credentials</pre>
			<pre class="source-code">        providerConfigRef:</pre>
			<pre class="source-code">          name: gcp-credentials-project-1</pre>
			<pre class="source-code">        forProvider:</pre>
			<pre class="source-code">          databaseVersion: POSTGRES_9_6</pre>
			<pre class="source-code">          # Compliance Policy</pre>
			<pre class="source-code">          region: us-central1</pre>
			<pre class="source-code">          settings:</pre>
			<pre class="source-code">            # These are default values </pre>
			<pre class="source-code">            # Architecture policies will be a patch</pre>
			<pre class="source-code">            tier: db-g1-small</pre>
			<pre class="source-code">            dataDiskSizeGb: 20</pre>
			<p>Read through the comments between<a id="_idIndexMarker211"/> the code snippets to understand <a id="_idIndexMarker212"/>concepts in detail. The following configuration uses the map transform to patch the virtual machine tier:</p>
			<pre class="source-code">- type: FromCompositeFieldPath</pre>
			<pre class="source-code">  fromFieldPath: spec.parameters.size</pre>
			<pre class="source-code">  toFieldPath: spec.forProvider.settings.tier</pre>
			<pre class="source-code">      # Use map transform</pre>
			<pre class="source-code">       # If the from-field value is BIG, then </pre>
			<pre class="source-code">       # the mapped to-field value is db-n1-standard-1</pre>
			<pre class="source-code">       transforms:</pre>
			<pre class="source-code">       - type: map</pre>
			<pre class="source-code">         map:</pre>
			<pre class="source-code">           BIG: db-n1-standard-1</pre>
			<pre class="source-code">           SMALL: db-g1-small</pre>
			<pre class="source-code">       policy:</pre>
			<pre class="source-code">         # return error if there is no field.</pre>
			<pre class="source-code">         fromFieldPath: Required</pre>
			<p>Next, we can look at the configuration<a id="_idIndexMarker213"/> to patch the disk size. The patch<a id="_idIndexMarker214"/> will have two transform operations. The first operation is to map the disk size, and the second one is to convert the mapped string to an integer:</p>
			<pre class="source-code">- type: FromCompositeFieldPath</pre>
			<pre class="source-code">  fromFieldPath: spec.parameters.size</pre>
			<pre class="source-code">  toFieldPath: spec.forProvider.settings.dataDiskSizeGb</pre>
			<pre class="source-code">  # If the from-field value is BIG, then </pre>
			<pre class="source-code">  # the mapped to-field value is '40;</pre>
			<pre class="source-code">  # Apply the second transform to convert '40' to int</pre>
			<pre class="source-code">  transforms:</pre>
			<pre class="source-code">  - type: map</pre>
			<pre class="source-code">    map:</pre>
			<pre class="source-code">      BIG: "40"</pre>
			<pre class="source-code">      SMALL: "20"</pre>
			<pre class="source-code">  - type: convert</pre>
			<pre class="source-code">    convert:</pre>
			<pre class="source-code">      toType: int</pre>
			<pre class="source-code">  policy:</pre>
			<pre class="source-code">    # return error if there is no field.</pre>
			<pre class="source-code">    fromFieldPath: Required</pre>
			<p>Finally, the following patch adds the resource zone into the API response:</p>
			<pre class="source-code"># Patch zone information back to the XR status</pre>
			<pre class="source-code"># No transformation or policy required</pre>
			<pre class="source-code">- type: ToCompositeFieldPath</pre>
			<pre class="source-code">  fromFieldPath: status.atProvider.gceZone</pre>
			<pre class="source-code">  toFieldPath: status.zone</pre>
			<p>The composition configuration<a id="_idIndexMarker215"/> for MySQL will be the same<a id="_idIndexMarker216"/> as the preceding configuration, excluding two changes. We should be changing the name of the composition in the metadata, and in the resource definition, we should change the database version to <strong class="source-inline">MYSQL_5_7</strong>. We can implement this with an additional parameter in the XR as well. Building two different compositions does not make sense when the difference is so small. We can capture the difference as a parameter in the XR. We are building two compositions, as an example. All composition examples and the upcoming claim examples are available for reference at <a href="https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter04/Hand-on-examples/Build-an-XR">https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter04/Hand-on-examples/Build-an-XR</a>.</p>
			<p>Refer to the following screenshot, which shows the successful creation of both compositions:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B17830_04_09.jpg" alt="Figure 4.9 – Composition created&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 – Composition created</p>
			<p>The final step is to use the claim API and create the database resources.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Provisioning the resources with a claim</h2>
			<p>Finally, we can start<a id="_idIndexMarker217"/> provisioning the GCP database<a id="_idIndexMarker218"/> with an XR or a claim. The <strong class="source-inline">CompositionRef</strong> configuration<a id="_idIndexMarker219"/> will specify which composition implementation to use. Note that the claims are namespace resources, and we provision them in the <strong class="source-inline">alpha</strong> namespace here. The following is a sample claim YAML for the MySQL database:</p>
			<pre class="source-code">apiVersion: alpha-beta.imarunrk.com/v1</pre>
			<pre class="source-code">kind: GCPdb</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  # Claims in alpha namespace</pre>
			<pre class="source-code">  namespace: alpha</pre>
			<pre class="source-code">  name: mysql-db</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  # Refer to the mysql composition</pre>
			<pre class="source-code">  compositionRef:</pre>
			<pre class="source-code">    name: mysql</pre>
			<pre class="source-code">  # save connection details as secret - db-conn2</pre>
			<pre class="source-code">  writeConnectionSecretToRef:</pre>
			<pre class="source-code">    name: db-conn2</pre>
			<pre class="source-code">  parameters:</pre>
			<pre class="source-code">    size: SMALL</pre>
			<p>The Postgres YAML as well will look similar with minor changes. Refer to the following screenshot, which shows a successful database creation:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B17830_04_10.jpg" alt="Figure 4.10 – Claim status&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10 – Claim status</p>
			<p>Note that the zone information <a id="_idIndexMarker220"/>is made available<a id="_idIndexMarker221"/> as the part of claim status:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B17830_04_11.jpg" alt="Figure 4.11 – Zone information&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11 – Zone information</p>
			<p>This concludes the journey to build an XR. We will look at a few troubleshooting tips.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Troubleshooting</h1>
			<p>If we face issues with<a id="_idIndexMarker222"/> our infrastructure API, these tips could help us debug the problem in the best possible way:</p>
			<ul>
				<li>Status attributes and events are essential elements to debug issues. These details can be viewed by running <strong class="source-inline">kubectl describe</strong> on the given resource.</li>
				<li>When we start looking for issues, we take a top-down approach. This is because Crossplane follows the same convention as Kubernetes to hold the errors close to the resource where it happens.</li>
				<li>The debugging order will be <em class="italic">claim</em>, then <em class="italic">XR</em>, and then <em class="italic">each composing resource</em>. We should start with a claimed object. If we cannot locate the issue, we go deep into the XR and then the composing resources.</li>
				<li><strong class="source-inline">spec.resourceRef</strong> from the claim description can help us to identify the XR name. Again, the same attribute can be used to find the composing resources from the XR.</li>
			</ul>
			<p>Make an intentional mistake<a id="_idIndexMarker223"/> in the resource configuration of the composition to go through the debugging experience. You learn more when you debug issues. This concludes our troubleshooting section. Next, we will look at the chapter summary before moving on to the next chapter.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Summary</h1>
			<p>With this chapter, we covered one of the critical aspects of Crossplane, the XR. We started with understanding how an XR works and configuring an XR. Above all, we went through a hands-on journey to build a fresh infrastructure API from end to end. The chapter also covered some advanced XR configuration patterns and ways to approach debugging when there is an issue. This will be the base knowledge for what we will learn in the next chapter.</p>
			<p>The next chapter will cover different advanced infrastructure platform patterns.</p>
		</div>
	</body></html>