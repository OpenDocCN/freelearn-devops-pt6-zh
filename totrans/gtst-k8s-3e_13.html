<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cluster Authentication, Authorization, and Container Security</h1>
                </header>
            
            <article>
                
<p>This chapter will discuss the basics of container security from the container runtime level to the host itself. We will discuss how to apply these concepts to workloads running in a Kubernetes cluster and some of the security concerns and practices that relate specifically to running your Kubernetes cluster.</p>
<p>This chapter will discuss the following topics:</p>
<ul>
<li>Basic container security</li>
<li>Container image security and continuous vulnerability scanning</li>
<li>Kubernetes cluster security</li>
<li>Kubernetes secrets</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Basics of container security</h1>
                </header>
            
            <article>
                
<p>Container security is a deep subject area and in itself can fill its own book. Having said this, we will cover some of the high-level concerns and give you a starting point so that you can start thinking about this area.</p>
<p>In the <em>A brief overview of containers</em> section of <a href="">Chapter 1</a><em>, Introduction to Kubernetes</em>, we looked at some of the core isolation features in the Linux kernel that enable container technology. Understanding the details of how containers work is the key to grasping the various security concerns in managing them.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>A good paper to dive deeper is <em>NCC's Whitepaper</em>, <em>Understanding and Hardening Linux Containers</em>. In <em>section 7</em>, the paper explores the various attack vectors of concern for container deployments, which I will summarize.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Keeping containers contained </h1>
                </header>
            
            <article>
                
<p>One of the most obvious features that is discussed in the paper we mentioned in the preceding section is that of escaping the isolation/virtualization of the container construct. Modern container implementations guard against using namespaces to isolate processes as well as allowing the control of Linux capabilities that are available to a container. Additionally, there is an increased move toward secure default configurations of the out-of-the-box container environment. For example, by default, Docker only enables a small set of capabilities. Networking is another avenue of escape and it can be challenging since there are a variety of network options that plug into most modern container setups.</p>
<p>The next area discussed in the paper is that of attacks between two containers. The <em>User</em> namespace model gives us added protection here by mapping the root user within the container to a lower-level user on the host machine. Networking is, of course, still an issue, and something that requires proper diligence and attention when selecting and implementing your container networking solution.</p>
<p>Attacks within the container itself are another vector and, as with previous concerns, namespaces and networking are key to protection here. Another aspect that is vital in this scenario is the application security itself. The code still needs to follow secure coding practices and the software should be kept up to date and patched regularly. Finally, the efficiency of container images has an added benefit of shrinking the attack surface. The images should be built with only the packages and software that's necessary.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Resource exhaustion and orchestration security</h1>
                </header>
            
            <article>
                
<p>Similar to the <strong>denial-of-service</strong> (<strong>DoS</strong>) attacks, we've seen in various other areas of computing that resource exhaustion is very much a pertinent concern in the container world. While cgroups provide some limitations on resource usage for things such as CPU, memory, and disk usage, there are still valid attack avenues for resource exhaustion. Tools such as Docker offer some starting defaults to the cgroups limitations, and Kubernetes also offers additional limits that can be placed on groups of containers running in the cluster. It's important to understand these defaults and to adjust for your deployments.</p>
<p class="mce-root"/>
<p>While the Linux kernel and the features that enable containers give us some form of isolation, they are fairly new to the Linux operating system. As such, they still contain their own bugs and vulnerabilities. The built-in mechanisms for capabilities and namespaces can and do have issues, and it is important to track these as part of your secure container operations.</p>
<p>The final area covered in the NCC paper is the attack of the container management layer itself. The Docker engine, image repositories, and orchestration tools are all significant vectors of attack and should be considered when developing your strategy. We'll look in more depth at how we can address the repositories and Kubernetes as an orchestration layer in the following sections.</p>
<div class="packt_tip">If you're interested in knowing more about the specific security features of Docker's implementation, take a look here: <a href="https://docs.docker.com/engine/security/security/">https://docs.docker.com/engine/security/security/</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Image repositories</h1>
                </header>
            
            <article>
                
<p>Vulnerability management is a critical component of any modern day IT operation. Zero-day vulnerabilities are on the rise and even those vulnerabilities with patches can be cumbersome to remediate. First, application owners must be made aware of their vulnerabilities and potential patches. Then, these patches must be integrated into systems and code, and often this requires additional deployments or maintenance windows. Even when there is visibility to vulnerabilities, there is often a lag in remediation, often taking large organizations several months to patch.</p>
<p>While containers greatly improve the process of updating applications and minimizing downtime, there still remains a challenge that's inherent in vulnerability management. Especially since an attacker only needs to expose one such vulnerability, making anything less than 100% of the systems patched is a risk of compromise. </p>
<p>What's needed is a faster feedback loop in addressing vulnerabilities. Continuous scanning and tying into the software deployment life cycle is key to speeding up the information and remediation of vulnerabilities. Luckily, this is exactly the approach that's being built into the latest container management and security tooling.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Continuous vulnerability scanning</h1>
                </header>
            
            <article>
                
<p>One such open source project that has emerged in this space is <strong>clair</strong>. clair is an open source project for the static analysis of vulnerabilities in appc (<a href="https://github.com/appc/spec">https://github.com/appc/spec</a>) and Docker (<a href="https://github.com/moby/moby/blob/master/image/spec/v1.md">https://github.com/moby/moby/blob/master/image/spec/v1.md</a>) containers.</p>
<div class="packt_infobox">You can visit clair at the following link: <a href="https://github.com/coreos/clair">https://github.com/coreos/clair</a>.</div>
<p>clair scans your code against <strong>Common Vulnerabilities and Exploits</strong> (<strong>CVEs</strong>). It can be integrated into your CI/CD pipeline and run as a response to new builds. If vulnerabilities are found, they can be taken as feedback into the pipeline, even stop deployment, and fail the build. This forces developers to be aware of and remediate vulnerabilities during their normal release process.</p>
<p>clair can be integrated with a number of container image repositories and CI/CD pipelines.</p>
<div class="packt_tip">clair can even be deployed on Kubernetes: <a href="https://github.com/coreos/clair/blob/master/Documentation/running-clair.md#kubernetes-helm">https://github.com/coreos/clair/blob/master/Documentation/running-clair.md#kubernetes-helm</a>.</div>
<p>clair is also used as the scanning mechanism in CoreOS's Quay image repository. Quay offers a number of enterprise features, including continuous vulnerability scanning (<a href="https://quay.io/">https://quay.io/</a>).</p>
<p>Both Docker Hub and Docker Cloud support security scanning. Again, containers that are pushed to the repository are automatically scanned against CVEs, and notifications of vulnerabilities are sent as a result of any findings. Additionally, binary analysis of the code is performed to match the signature of the components with that of known versions. </p>
<p>There are a variety of other scanning tools that can be used as well for scanning your image repositories, including OpenSCAP, Twistlock, Aqua Sec, and many more.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Image signing and verification</h1>
                </header>
            
            <article>
                
<p>Whether you are using a private image repository in-house or a public repository such as Docker Hub, it's important to know that you are only running the code that your developers have written. The potential for malicious code or man-in-the-middle attacks on downloads is an important factor in protecting your container images.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>As such, both rkt and Docker support the ability to sign images and verify that the contents have not changed. Publishers can use keys to sign the images when they are pushed to the repositories, and users can verify the signature on the client side when downloading for use.</p>
<div class="packt_infobox">This is from the rkt documentation: <br/>
<br/>
<q><span>"Before executing a remotely fetched ACI, rkt will verify it based on attached signatures generated by the ACI</span></q> <span>creator."</span><span><br/>
<br/>
Fo</span><span>r</span> <span>more information, visit the following links:</span><q><span><br/></span></q>
<ul>
<li><a href="https://github.com/rkt/rkt/blob/master/Documentation/subcommands/trust.md">https://github.com/rkt/rkt/blob/master/Documentation/subcommands/trust.md</a></li>
<li><a href="https://github.com/rkt/rkt/blob/master/Documentation/signing-and-verification-guide.md">https://github.com/rkt/rkt/blob/master/Documentation/signing-and-verification-guide.md</a><a href="https://coreos.com/rkt/docs/latest/signing-and-verification-guide.html"> </a></li>
</ul>
<p>This is from the Docker documentation:<br/>
<q><span>"Content trust gives you the ability to verify both the integrity and the publisher of all the data received from a registry over any channel. "</span></q></p>
<p><span>F</span><span>or more information, visit</span><q><span> </span></q><a href="https://docs.docker.com/engine/security/trust/content_trust/">https://docs.docker.com/engine/security/trust/content_trust/</a>.<a href="https://docs.docker.com/engine/security/trust/content_trust/"><br/></a>This is from the Docker Notary GitHub page:</p>
<p><q>"The Notary project comprises a server and a client for running and interacting with trusted collections."</q></p>
<p>For more information, visit <a href="https://github.com/docker/notary">https://github.com/docker/notary</a>.</p>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Kubernetes cluster security</h1>
                </header>
            
            <article>
                
<p>Kubernetes has continued to add a number of security features in their latest releases and has a well-rounded set of control points that can be used in your cluster <span>–</span> everything from secure node communication to pod security and even the storage of sensitive configuration data.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Secure API calls</h1>
                </header>
            
            <article>
                
<p>During every API call, Kubernetes applies a number of security controls. This security life cycle is depicted here:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img class="image-border" src="Images/f03a474d-08ef-43ef-83a2-76af157b1860.png" style="width:39.17em;height:29.42em;" width="960" height="720"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">API call life cycle</div>
<p>After secure TLS communication is established, the API server runs through authorization and authentication. Finally, an admission controller loop is applied to the request before it reaches the API server.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Secure node communication</h1>
                </header>
            
            <article>
                
<p>Kubernetes supports the use of secure communication channels between the API server and any client, including the nodes themselves. Whether it's a GUI or command-line utility such as <kbd>kubectl</kbd>, we can use certificates to communicate with the API server. Hence, the API server is the central interaction point for any changes to the cluster and is a critical component to secure.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In deployments such as GCE, the <kbd>kubelet</kbd> on each node is deployed for secure communication by default. This setup uses TLS bootstrapping and the new certificates' API to establish a secure connection with the API server using TLS client certificates and a <strong>Certificate Authority</strong> (<strong>CA</strong>) cluster. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Authorization and authentication plugins</h1>
                </header>
            
            <article>
                
<p>The plugin mechanisms for authentication and authorization in Kubernetes are still being developed. They have come a long way, but still have plugins in beta stages and enhancements in the works. There are also third-party providers that integrate with the features here, so bear that in mind when building your hardening strategy.</p>
<p>Authentication is currently supported in the form of tokens, passwords, and certificates, with plans to add the plugin capability at a later stage. OpenID Connect tokens are supported and several third-party implementations, such as Dex from CoreOS and user account and authentication from Cloud Foundry, are available.</p>
<p>Authorization already supports three modes. The <strong>role-based access control</strong> (<strong>RBAC</strong>) mode recently went to general availability in the 1.8 release and brings the standard role-based authentication model to Kubernetes. <strong>Attribute-based access control</strong> (<strong>ABAC</strong>) has long been supported and lets a user define privileges via attributes in a file.</p>
<p>Additionally, a Webhook mechanism is supported, which allows for integration with third-party authorization via REST web service calls. Finally, we have the new node authorization method, which <span>grants permissions to kubelets based on the pods they are scheduled to run.</span></p>
<div class="packt_tip">You can learn more about each area at the following links:<br/>
<ul>
<li><a href="http://kubernetes.io/docs/admin/authorization/">http://kubernetes.io/docs/admin/authorization/</a></li>
<li><a href="http://kubernetes.io/docs/admin/authentication/">http://kubernetes.io/docs/admin/authentication/</a></li>
<li><a href="https://kubernetes.io/docs/reference/access-authn-authz/node/">https://kubernetes.io/docs/reference/access-authn-authz/node/</a></li>
</ul>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Admission controllers</h1>
                </header>
            
            <article>
                
<p>Kubernetes also provides a mechanism for integrating, with additional verification as a final step. This could be in the form of image scanning, signature checks, or anything that is able to respond in the specified fashion.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>When an API call is made, the hook is called and that server can run its verification. Admission controllers can also be used to transform requests and add or alter the original request. Once the operations are run, a response is then sent back with a status that instructs Kubernetes to allow or deny the call.</p>
<p>This can be especially helpful for verifying or testing images, as we mentioned in the last section. The <kbd>ImagePolicyWebhook</kbd> plugin provides an admission controller that allows for integration with additional image inspection.</p>
<div class="packt_tip">For more information, visit the <span class="packt_screen">Using Admission Controller</span> page in the following documentation: <a href="https://kubernetes.io/docs/admin/admission-controllers/">https://kubernetes.io/docs/admin/admission-controllers/</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">RBAC</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier in this chapter, Kubernetes has now made RBAC a central component to authorization within the cluster. Kubernetes offers two levels for this kind of control. First, there is a <em>ClusterRole</em>, which provides cluster-wide authorization to resources. This is handy for enforcing access control across multiple teams, products, or to cluster-wide resources such as the underlying cluster nodes. Second, we have a <em>Role</em>, which simply provides access to resources within a specific namespace.</p>
<p>Once you have a role, you need a way to provide users with membership to that role. These are referred to as <em>Bindings</em>, and again we have <em>ClusterRoleBinding</em> and <em>RoleBinding</em>. As with the roles themselves, the former is meant for cluster-wide access and the latter is meant to apply within a specific namespace.</p>
<p>We will not dive into the details of RBAC in this book, but it is something you'll want to explore as you get ready for production grade deployments. The <em>PodSecurityPolicy</em> discussed in the next section typically utilizes Roles and RoleBindings to control which policies each user has access to.</p>
<div class="packt_infobox">For more information, please refer to the documentation here: <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">https://kubernetes.io/docs/reference/access-authn-authz/rbac/</a>.<a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/"/></div>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pod security policies and context</h1>
                </header>
            
            <article>
                
<p>One of the latest additions to the Kubernetes' security arsenal is that of pod security policies and contexts. These allow users to control users and groups for container processes and attached volumes, limit the use of host networks or namespaces, and even set the root filesystem to read-only. Additionally, we can limit the capabilities available and also set SELinux options for the labels that are applied to the containers in each pod. </p>
<div class="packt_tip">In addition to SELinux, Kubernetes also added beta support for using AppArmor with your pods by using annotations. For more information, refer to the following documentation page: <a href="https://kubernetes.io/docs/admin/apparmor/">https://kubernetes.io/docs/admin/apparmor/</a>.</div>
<p><span>PodSecurityPolicies are enforced using the admission controller we spoke of earlier in this book. </span>By default, Kubernetes doesn't enable PodSecurityPolicy, so if you have a GKE cluster running, you can try the following:</p>
<pre><strong>$ kubectl get psp</strong></pre>
<p>You should see <kbd>'No resources found.'</kbd>, assuming you haven't enabled them. </p>
<p>Let's try an example by using the Docker image from our previous chapters. If we use the following <kbd>run</kbd> command on a cluster with no PodSecurityPolicy applied, it will happily run:</p>
<pre><strong><span>$ kubectl run myroottest --image=jonbaier/node-express-info:latest</span></strong></pre>
<p>Follow this with<span> </span><kbd>kubectl get pods</kbd><span> and in a minute or so we should see a pod starting with <kbd>myroottest</kbd> in the listings. </span></p>
<p>Go ahead and clean this up with the following code before proceeding:</p>
<pre><strong><span>$ kubectl delete deployment myroottest<br/></span></strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Enabling PodSecurityPolicies</h1>
                </header>
            
            <article>
                
<p>Now, let's try this with a cluster that can utilize PodSecurityPolicies. If you are using GKE, it is quite easy to create a cluster with PodSecurityPolicy enabled. Note you will need the Beta APIs enabled for this:</p>
<pre><strong>$ gcloud beta container clusters create [Cluster Name] --enable-pod-security-policy --zone=[Zone To Deply Cluster]</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<div class="packt_tip">If you have an existing GKE cluster, you can enable it with a command similar to the preceding one. Simply replace the <kbd>create</kbd> keyword with <kbd>update</kbd>.<br/>
<br/>
For clusters created with <kbd>kube-up</kbd>, like we saw in <a href="446f901d-70fa-4ebe-be8a-0de14248f99c.xhtml">Chapter 1</a>, <em>Introduction to Kubernetes</em>, you'll need to enable the admission controller on the API server. Take a look here for more information: <a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#enabling-pod-security-policies">https://kubernetes.io/docs/concepts/policy/pod-security-policy/#enabling-pod-security-policies</a>.</div>
<p>Once you have PodSecurityPolicy enabled, you can see the applied policies by using the following code:</p>
<pre><strong>$ kubectl get psp</strong></pre>
<p class="CDPAlignCenter CDPAlign"><img src="Images/79bea3b7-c4ae-4451-b9d4-978f07e1cf44.jpg" width="653" height="93"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">GKE default pod security policies</div>
<p>You'll notice a few predefined policies that GKE has already defined. You can explore the details and the YAML used to create these policies with the following code:</p>
<pre><strong>$ kubectl <span>get psp/[PSP Name] -o yaml</span></strong></pre>
<p>It's important to note that PodSecurityPolicies work with the RBAC features of Kubernetes. There are a few default roles, role bindings, and namespaces that are defined by GKE. As such, we will see different behaviors based on how we interact with Kubernetes. For example, by using <kbd>kubectl</kbd> in a GCloud Shell, you may be sending commands as a cluster admin and therefore have access to all policies, including <kbd>gce.privileged</kbd>. However, using the <kbd>kubectl run</kbd> command, as we did previously, will invoke the pods through the kube-controller-manager, which will be restricted to the policies bound to its role. Thus, if you simply create a pod with <kbd>kubectl</kbd>, it will create it without an issue, but by using the <kbd>run</kbd> command, we will be restricted.</p>
<p>Sticking to our previous method of using <kbd>kubectl run</kbd>, let's try the same deployment as the preceding one:</p>
<pre><strong><span>$ kubectl run myroottest --image=jonbaier/node-express-info:latest</span></strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Now, if we follow this with<span> </span><kbd>kubectl get pods</kbd><span>, we won't see any pods prefaced with <kbd>myroottest</kbd>. We can dig a bit deeper by describing our deployment:</span></p>
<pre><strong><span>$ k</span></strong><span><strong>ubectl describe deployment myroottest</strong></span></pre>
<p>By using the name of the replica set listed in the output from the preceding command, we can then get the details on the failure. Run the following command:</p>
<pre><strong><span>$ k</span><span>ubectl describe rs [ReplicaSet name from deployment describe]</span></strong></pre>
<p><span>Under the events at the bottom, you will see the following pod security policy validation error:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/916c02b0-331a-4e10-a10c-097fb49138ed.jpg" width="892" height="487"/></p>
<div class="CDPAlignCenter packt_figref">Replica set pod security policy validation error</div>
<p>Again, because the <kbd>run</kbd> command uses the controller manager and that role has no bindings that allow the use of the existing <strong>PodSecurityPolicies</strong>, we are unable to run any pods.</p>
<div>
<p>Understanding that running containers securely is not merely the task of administrators adding constraints is important. The work must be done in collaboration with developers, who will properly create the images. </p>
<p><span>You can find all of the possible parameters for PodSecurityPolicies in the source code, but I've created the following table for convenience. You can find more handy lookups like this on</span> my new site,<span> </span><a href="http://www.kubesheets.com">http://www.kubesheets.com</a>:</p>
</div>
<div>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Parameter</strong></p>
</td>
<td>
<p><strong>Type</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
<td><strong>Required</strong></td>
</tr>
<tr>
<td>
<p><kbd>Privileged</kbd></p>
</td>
<td>
<p><kbd>bool</kbd></p>
</td>
<td>
<p>Allows or disallows running a pod as privileged.</p>
</td>
<td>No</td>
</tr>
<tr>
<td>
<p><kbd><span>DefaultAddCapabilities</span></kbd></p>
</td>
<td>
<p><kbd><span>[]v1.Capaility</span></kbd></p>
</td>
<td>
<p>This defines a default set of capabilities that are added to the container. If the pod specifies a capability drop that will override, then add it here. </p>
<p>Values are strings of POSIX capabilities minus the leading <kbd>CAP_</kbd>. For example, <kbd>CAP_SETUID</kbd> would be <kbd>SETUID</kbd> (<a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">http://man7.org/linux/man-pages/man7/capabilities.7.html</a>).</p>
</td>
<td>No</td>
</tr>
<tr>
<td>
<p><kbd><span>RequiredDropCapabilities</span></kbd></p>
</td>
<td>
<p><kbd>[]v1.Capaility</kbd></p>
</td>
<td>
<p>This defines a set of capabilities that must be dropped from a container. The pod cannot specify any of these capabilities.</p>
<p>Values are strings of POSIX capabilities minus the leading <kbd>CAP_</kbd>. For example, <kbd>CAP_SETUID</kbd> would be <kbd>SETUID</kbd> (<a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">http://man7.org/linux/man-pages/man7/capabilities.7.html</a>).</p>
</td>
<td>No</td>
</tr>
<tr>
<td>
<p><kbd><span>AllowedCapabilities</span></kbd></p>
</td>
<td>
<p><kbd><span>[]v1.Capaility</span></kbd></p>
</td>
<td>
<p>This defines a set of capabilities that are allowed and can be added to a container. The pod can specify any of these capabilities.</p>
<p>Values are strings of POSIX capabilities minus the leading <kbd>CAP_</kbd>. For example, <kbd>CAP_SETUID</kbd> would be <kbd>SETUID</kbd> (<a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">http://man7.org/linux/man-pages/man7/capabilities.7.html</a>).</p>
</td>
<td>No</td>
</tr>
<tr>
<td>
<p><kbd><span>Volumes</span></kbd></p>
</td>
<td>
<p><kbd><span><span>[]string</span></span></kbd></p>
</td>
<td>
<p>This list defines which volumes can be used. Leave this empty for all types (<a href="https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/apis/extensions/v1beta1/types.go#L1127">https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/apis/extensions/v1beta1/types.go#L1127</a>).</p>
</td>
<td><span>No</span></td>
</tr>
<tr>
<td>
<p><kbd>HostNetwork</kbd></p>
</td>
<td>
<p><kbd>bool</kbd></p>
</td>
<td>
<p>This allows or disallows the pod to use the host network.</p>
</td>
<td><span>No</span></td>
</tr>
<tr>
<td>
<p><kbd>HostPorts</kbd></p>
</td>
<td>
<p><kbd>[]HostPortRange</kbd></p>
</td>
<td>
<p>This lets us restrict allowable host ports that can be exposed.</p>
</td>
<td><span>No</span></td>
</tr>
<tr>
<td>
<p><kbd>HostPID</kbd></p>
</td>
<td>
<p><kbd>bool</kbd></p>
</td>
<td>
<p><span>This allows or disallows the pod to use the host PID.</span></p>
</td>
<td><span>No</span></td>
</tr>
<tr>
<td>
<p><kbd>HostIPC</kbd></p>
</td>
<td>
<p><kbd>bool</kbd></p>
</td>
<td>
<p><span>This allows or disallows the pod to use the host IPC.</span></p>
</td>
<td><span>No</span></td>
</tr>
<tr>
<td>
<p><kbd>SELinux</kbd></p>
</td>
<td>
<p><kbd>SELinuxStrategyOptions</kbd></p>
</td>
<td>
<p>Set it to one of the strategy options, as defined here: <a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#selinux">https://kubernetes.io/docs/concepts/policy/pod-security-policy/#selinux</a>.</p>
</td>
<td>Yes</td>
</tr>
<tr>
<td>
<p><kbd>RunAsUser</kbd></p>
</td>
<td>
<p><kbd>RunAsUserStrategyOptions</kbd></p>
</td>
<td>
<p>Set it to one of the strategy options, as defined here: <a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups">https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups</a>.</p>
</td>
<td>Yes</td>
</tr>
<tr>
<td>
<p><kbd>SupplementalGroups</kbd></p>
</td>
<td>
<p><kbd>SupplementalGroupsStrategyOptions</kbd></p>
</td>
<td>
<p>Set it to one of the strategy options, as defined here: <a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups">https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups</a></p>
</td>
<td>Yes</td>
</tr>
<tr>
<td>
<p><kbd>FSGroup</kbd></p>
</td>
<td>
<p><kbd>FSGroupStrategyOptions</kbd></p>
</td>
<td>
<p>Set it to one of the strategy options, as defined here: <a href="https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies">https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies</a></p>
</td>
<td>Yes</td>
</tr>
<tr>
<td>
<p><kbd>ReadOnlyRootFilesystem</kbd></p>
</td>
<td>
<p><kbd>bool</kbd></p>
</td>
<td>
<p>Setting this to <kbd>true</kbd> will either deny the pod or force it to run with a read-only root filesystem.</p>
</td>
<td><span>No</span></td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>allowedHostPaths</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>[]<span>AllowedHostPath</span></kbd></p>
</td>
<td>
<p>This provides a whitelist of host paths that can be used at volumes.</p>
</td>
<td><span>No</span></td>
</tr>
<tr>
<td>
<p><kbd><span>allowedFlexVolumes</span></kbd></p>
</td>
<td>
<p><kbd>[]<span>AllowedFlexVolume</span></kbd></p>
</td>
<td>
<p><span>This provides a whitelist of flex volumes that can be mounted.</span></p>
</td>
<td><span>No</span></td>
</tr>
<tr>
<td>
<p><kbd><span>allowPrivilegeEscalation</span></kbd></p>
</td>
<td>
<p><span><kbd>bool</kbd></span></p>
</td>
<td>
<p>This governs where <kbd>setuid</kbd> can be used to change the user a process is running under. Its default is<span> </span><kbd>true</kbd>.<span> </span> </p>
</td>
<td>No</td>
</tr>
<tr>
<td>
<p><kbd><span>defaultAllowPrivilegeEscalation</span></kbd></p>
</td>
<td>
<p><kbd><span>bool</span></kbd></p>
</td>
<td>
<p>Sets the default for <kbd>allowPrivilegeEscalation</kbd>.</p>
</td>
<td>No</td>
</tr>
</tbody>
</table>
<p> </p>
<p> </p>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Additional considerations</h1>
                </header>
            
            <article>
                
<p>In addition to the features we just reviewed, Kubernetes has a number of other constructs that should be considered in your overall cluster hardening process. Earlier in this book, we looked at namespaces that provide a logical separation for multi-tenancy. While the namespaces themselves do not isolate the actual network traffic, some of the network plugins, such as Calico and Canal, provide additional capability for network policies. We also looked at quotas and limits that can be set for each namespace, which should be used to prevent a single tenant or project from consuming too many resources within the cluster.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Securing sensitive application data (secrets)</h1>
                </header>
            
            <article>
                
<p>Sometimes, our application needs to hold sensitive information. This can be credentials or tokens to log in to a database or service. Storing this sensitive information in the image itself is something to be avoided. Here, Kubernetes provides us with a solution in the construct of secrets.</p>
<p>Secrets give us a way to store sensitive information without including plaintext versions in our resource definition files. Secrets can be mounted to the pods that need them and then accessed within the pod as files with the secret values as content. Alternatively, you can also expose the secrets via environment variables.</p>
<div class="packt_tip">
<p>Given that Kubernetes still relies on plaintext etcd storage, you may want to explore integration with more mature secrets vaults, such as Vault from Hashicorp. There is even a GitHub project for integration: <a href="https://github.com/Boostport/kubernetes-vault">https://github.com/Boostport/kubernetes-vault</a>.</p>
</div>
<p>We can easily create a secret either with YAML or on the command line. Secrets do need to be base-64 encoded, but if we use the <kbd>kubectl</kbd> command line, this encoding is done for us. </p>
<p>Let's start with the following secret:</p>
<pre><strong>$ kubectl create secret generic secret-phrases --from-literal=quiet-phrase="Shh! Dont' tell"</strong></pre>
<p>We can then check for the secret with this command:  </p>
<pre><strong>$ kubectl get secrets</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Now that we have successfully created the secret, let's make a pod that can use the secret. Secrets are consumed in pods by way of attached volumes. In the following <kbd>secret-pod.yaml</kbd> file, you'll notice that we use <kbd>volumeMount</kbd> to mount the secret to a folder in our container:</p>
<pre>apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: secret-pod<br/>spec:<br/>  containers:<br/>  - name: secret-pod<br/>    image: jonbaier/node-express-info:latest<br/>    ports:<br/>    - containerPort: 80<br/>      name: web<br/>    volumeMounts:<br/>      - name: secret-volume<br/>        mountPath: /etc/secret-phrases<br/>  volumes:<br/>  - name: secret-volume<br/>    secret:<br/>      secretName: secret-phrases</pre>
<p>Create this pod with <kbd>kubectl create -f secret-pod.yaml</kbd>. Once created, we can get a bash shell in the pod with <kbd>kubectl exec</kbd> and then change directories to the <kbd>/etc/secret-phrases</kbd> folder that we set up in the pod definition. Listing this directory reveals a single file with the name of the secret that we created earlier:</p>
<pre><strong>$ kubectl exec -it secret-pod bash<br/>$ cd /etc/secret-phrases</strong><br/><strong>$ ls</strong></pre>
<p>If we then display its contents, we should see the phrase we encoded previously, <kbd>Shh! Dont' tell</kbd>:</p>
<pre><strong>$ cat quiet-phrase</strong></pre>
<p>Typically, this would be used for a username and password to a database or service, or any sensitive credentials and configuration data.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Bear in mind that secrets are still in their early stages, but they are a vital component for production operations. There are several improvements being planned for future releases. At the moment, secrets are still stored in plaintext in the etcd server. However, the secrets construct does allow us to control which pods can access it, and it stores the information on the tmpfs, but does not store it at rest for each pod. You can limit users with access to etcd and perform additional wipe procedures when you decommission servers, but you'll likely want more protection in place for a production-ready system.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we took a look at basic container security and some essential areas of consideration. We also touched on basic image security and continuous vulnerability scanning. Later in this chapter, we looked at the overall security features of Kubernetes, including secrets for storing sensitive configuration data, secure API calls, and even setting up security policies and contexts for pods running on our cluster.</p>
<p>You should now have a solid starting point for securing your cluster and moving toward production. To that end, the next chapter will cover an overall strategy for moving toward production and will also look at some third-party vendors that offer tools to fill in the gaps and assist you on the way.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ul>
<li>Which component can be used as a central point for managing and prevent vulnerabilities from being released?</li>
<li>What are three methods for authorization within a Kubernetes cluster?</li>
<li>Which parameter of a PodSecurityPolicy disallows the running of privileged containers?</li>
<li><span>How do you list all secrets that you have access to in a cluster?</span></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><a href="https://www.nccgroup.trust/us/our-research/understanding-and-hardening-linux-containers/">https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/2016/april/ncc_group_understanding_hardening_linux_containers-10pdf/</a></li>
<li><a href="https://github.com/moby/moby/blob/89dac8427e7366cbd6a47e713fe8f445198ca3d4/oci/defaults.go#L14">https://github.com/moby/moby/blob/89dac8427e7366cbd6a47e713fe8f445198ca3d4/oci/defaults.go#L14</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/blob/2d7b92ee743de20d17406003e463a829a0db5a51/pkg/apis/policy/types.go#L145">https://github.com/kubernetes/kubernetes/blob/2d7b92ee743de20d17406003e463a829a0db5a51/pkg/apis/policy/types.go#L145</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>