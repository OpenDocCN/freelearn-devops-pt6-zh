<html><head></head><body>
		<div id="_idContainer020">
			<h1 id="_idParaDest-67"><em class="italic"><a id="_idTextAnchor066"/>Chapter 4</em>: Developing an Operator with the Operator SDK</h1>
			<p>With a completed design <a id="_idIndexMarker178"/>outline for an <strong class="bold">Operator</strong>, it is now possible to begin the actual work of developing it. This means writing and compiling code that can be deployed onto an actual running <strong class="bold">Kubernetes cluster</strong>. For this chapter, the <strong class="bold">Operator SDK</strong> will <a id="_idIndexMarker179"/>be used to initialize the scaffolding of a boilerplate Operator project. From there, the technical steps to develop the rest of a basic Operator will be demonstrated as a tutorial. This guide will follow the Operator design already planned in <a href="B18147_03_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Designing an Operator – CRD, API, and Target Reconciliation</em>, which focused on developing a <em class="italic">Level II</em> Operator to deploy and upgrade a<a id="_idIndexMarker180"/> simple <strong class="bold">Nginx Pod</strong>.</p>
			<p>As a tutorial, this chapter will follow the process for building an Operator from scratch with <strong class="bold">Go</strong>. Beginning <a id="_idIndexMarker181"/>with the initialization of boilerplate project code, the guide will then follow through the <a id="_idIndexMarker182"/>steps of defining the Operator API and generating the corresponding <strong class="bold">CustomResourceDefinition</strong> (<strong class="bold">CRD</strong>). Then, we will see how to implement simple reconciliation logic that makes up the core functionality of the Operator. Finally, some basic troubleshooting and common issues will be addressed. The steps for developing an Operator with Operator SDK will be broken down into the following sections:</p>
			<ul>
				<li>Setting up your project</li>
				<li>Defining an API</li>
				<li>Adding resource manifests</li>
				<li>Writing a control loop</li>
				<li>Troubleshooting</li>
			</ul>
			<p>These sections follow roughly the design pattern that is recommended in the official Operator SDK Go documentation (<a href="https://sdk.operatorframework.io/docs/building-operators/golang/">https://sdk.operatorframework.io/docs/building-operators/golang/</a>), which is why we have chosen to follow this approach. At the end of this chapter, we will have an Operator that covers the Level II functionality described in the design that was outlined in <a href="B18147_03_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Designing an Operator – CRD, API, and Target Reconciliation</em>. This functionality includes basic deployment of the Operand (in this case, Nginx) and seamless upgrades of the Operator and Operand. In later chapters, this guide will be built upon as a foundation for adding more complex functionality that graduates this sample Operator from lower to higher levels along the Capability Model.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Technical requirements</h1>
			<p>The guided steps in this chapter will require the following technical prerequisites to follow along:</p>
			<ul>
				<li><strong class="source-inline">go</strong> version 1.16+</li>
				<li>An <strong class="source-inline">operator-sdk</strong> binary installed locally</li>
			</ul>
			<p>The <strong class="source-inline">operator-sdk</strong> binary can be installed either directly from a release, with Homebrew (for macOS), or compiled from GitHub from <a href="https://github.com/operator-framework/operator-sdk">https://github.com/operator-framework/operator-sdk</a>. If choosing to install the Operator SDK from GitHub, <strong class="source-inline">git</strong> will also be required; however, it is recommended to use <strong class="source-inline">git</strong> anyway to take advantage of version control for the project.</p>
			<p>The Code in Action video for this chapter can be viewed at: <a href="https://bit.ly/3N7yMDY">https://bit.ly/3N7yMDY</a></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Setting up your project</h1>
			<p>The first step in<a id="_idIndexMarker183"/> starting a fresh Operator project is to initialize an empty project structure. First, create an empty project directory with <strong class="source-inline">mkdir nginx-operator</strong> and <strong class="source-inline">cd</strong> into it. Now, initialize a boilerplate project structure with the following:</p>
			<p class="source-code">operator-sdk init --domain example.com --repo github.com/example/nginx-operator</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This command may take a few moments to complete the first time it is run.</p>
			<p>This command sets up a lot of different files and folders that will be filled in with the custom APIs and logic for the Operator we are building. The once-empty project directory should now contain the following files:</p>
			<p class="source-code">~/nginx-operator$ ls</p>
			<p class="source-code">total 112K</p>
			<p class="source-code">drwxr-xr-x   12 mdame staff  384 Dec 22 21:07 . </p>
			<p class="source-code">drwxr-xr-x+ 282 mdame staff 8.9K Dec 22 21:06 .. </p>
			<p class="source-code">drwx------    8 mdame staff  256 Dec 22 21:07 config</p>
			<p class="source-code">drwx------    3 mdame staff   96 Dec 22 21:06 hack</p>
			<p class="source-code">-rw-------    1 mdame staff  129 Dec 22 21:06 .dockerignore</p>
			<p class="source-code">-rw-------    1 mdame staff  367 Dec 22 21:06 .gitignore</p>
			<p class="source-code">-rw-------    1 mdame staff  776 Dec 22 21:06 Dockerfile</p>
			<p class="source-code">-rw-------    1 mdame staff 8.7K Dec 22 21:07 Makefile</p>
			<p class="source-code">-rw-------    1 mdame staff  228 Dec 22 21:07 PROJECT</p>
			<p class="source-code">-rw-------    1 mdame staff  157 Dec 22 21:07 go.mod</p>
			<p class="source-code">-rw-r--r--    1 mdame staff  76K Dec 22 21:07 go.sum</p>
			<p class="source-code">-rw-------    1 mdame staff 2.8K Dec 22 21:06 main.go</p>
			<p>The<a id="_idIndexMarker184"/> purposes of these files are as follows:</p>
			<ul>
				<li><strong class="source-inline">config</strong> – A directory that holds YAML definitions of Operator resources.</li>
				<li><strong class="source-inline">hack</strong> – A directory that is used by many projects to hold various <strong class="source-inline">hack</strong> scripts. These are scripts that can serve a variety of purposes but are often used to generate or verify changes (often employed as part of a continuous integration process to ensure code is properly generated before merging). </li>
				<li><strong class="source-inline">.dockerignore</strong> / <strong class="source-inline">.gitignore</strong> – Declarative lists of files to be ignored by Docker builds and Git, respectively.</li>
				<li><strong class="source-inline">Dockerfile</strong> – Container image build definitions.</li>
				<li><strong class="source-inline">Makefile</strong> – Operator build definitions.</li>
				<li><strong class="source-inline">PROJECT</strong> – File used by Kubebuilder to hold project config information (<a href="https://book.kubebuilder.io/reference/project-config.html">https://book.kubebuilder.io/reference/project-config.html</a>).</li>
				<li><strong class="source-inline">go.mod</strong> / <strong class="source-inline">go.sum</strong> – Dependency management lists for <strong class="source-inline">go mod</strong> (already populated with various Kubernetes dependencies).</li>
				<li><strong class="source-inline">main.go</strong> – The entry point file for the Operator's main functional code.</li>
			</ul>
			<p>With this boilerplate project structure initialized, it is possible to start building Operator logic on top. While this bare project will compile, it doesn't do much besides start an empty controller<a id="_idIndexMarker185"/> with <strong class="source-inline">Readyz</strong> and <strong class="source-inline">Healthz</strong> endpoints. To get it to do a little more, first, the Operator must have a defined API.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Defining an API</h1>
			<p>The Operator's API <a id="_idIndexMarker186"/>will <a id="_idIndexMarker187"/>be the definition of how it is represented within a Kubernetes cluster. The API is directly translated to a generated CRD, which describes the blueprint for the custom resource object that users will consume to interact with the Operator. Therefore, creating this API is a necessary first step before writing other logic for the Operator. Without this, there will be no way for the Operator's logic code to read values from the custom resource.</p>
			<p>Building an Operator API is done by writing a Go struct to represent the object. The basic outline of this struct can be scaffolded by the Operator SDK with the following command:</p>
			<p class="source-code">operator-sdk create api --group operator --version v1alpha1 --kind NginxOperator --resource --controller</p>
			<p>This command does the following:</p>
			<ol>
				<li>Creates the API types in a new directory called <strong class="source-inline">api/</strong></li>
				<li>Defines these types as belonging to the API group <strong class="source-inline">operator.example.com</strong> (since we initialized the project under the domain <strong class="source-inline">example.com</strong>)</li>
				<li>Creates the initial version of the API named <strong class="source-inline">v1alpha1</strong></li>
				<li>Names these types after our Operator, <strong class="source-inline">NginxOperator</strong></li>
				<li>Instantiates boilerplate controller code under a new directory called <strong class="source-inline">controllers/</strong> (which we will work with more under <em class="italic">Writing a control loop</em>)</li>
				<li>Updates <strong class="source-inline">main.go</strong> to add boilerplate code for starting the new controller</li>
			</ol>
			<p>For now, we are only concerned with the API types under <strong class="source-inline">api/v1alpha1/nginxoperator_types.go</strong>. There are two other files in this directory (<strong class="source-inline">groupversion_info.go</strong> and <strong class="source-inline">zz_generated.deepcopy.go</strong>) that do not usually need to be modified. In fact, the <strong class="source-inline">zz_generated.</strong> prefix is used as a standard to denote generated files that should never be manually modified. The <strong class="source-inline">groupversion_info.go</strong> file is used to define package variables for this API that instruct clients how to handle objects from it.</p>
			<p>Looking at <strong class="source-inline">nginxoperator_types.go</strong>, there are already some empty structs with instructions to<a id="_idIndexMarker188"/> fill in <a id="_idIndexMarker189"/>additional fields. The three most important types in this file are <strong class="source-inline">NginxOperator</strong>, <strong class="source-inline">NginxOperatorSpec</strong>, and <strong class="source-inline">NginxOperatorStatus</strong>:</p>
			<pre class="source-code">// NginxOperatorSpec defines the desired state of NginxOperator</pre>
			<pre class="source-code">type <strong class="bold">NginxOperatorSpec</strong> struct {</pre>
			<pre class="source-code">  // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster</pre>
			<pre class="source-code">  // Important: Run "make" to regenerate code after modifying this file</pre>
			<pre class="source-code">  // Foo is an example field of NginxOperator. Edit nginxoperator_types.go to remove/update</pre>
			<pre class="source-code">  Foo string `json:"foo,omitempty"`</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">// NginxOperatorStatus defines the observed state of NginxOperator</pre>
			<pre class="source-code">type <strong class="bold">NginxOperatorStatus</strong> struct {</pre>
			<pre class="source-code">  // INSERT ADDITIONAL STATUS FIELD - define observed state of cluster</pre>
			<pre class="source-code">  // Important: Run "make" to regenerate code after modifying this file</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">//+kubebuilder:object:root=true</pre>
			<pre class="source-code">//+kubebuilder:subresource:status</pre>
			<pre class="source-code">// NginxOperator is the Schema for the nginxoperators API</pre>
			<pre class="source-code">type <strong class="bold">NginxOperator</strong> struct {</pre>
			<pre class="source-code">  metav1.TypeMeta   `json:",inline"`</pre>
			<pre class="source-code">  metav1.ObjectMeta `json:"metadata,omitempty"`</pre>
			<pre class="source-code">  <strong class="bold">Spec   NginxOperatorSpec</strong>   `json:"spec,omitempty"`</pre>
			<pre class="source-code">  <strong class="bold">Status NginxOperatorStatus</strong> `json:"status,omitempty"`</pre>
			<pre class="source-code">}</pre>
			<p>As <a id="_idIndexMarker190"/>discussed<a id="_idIndexMarker191"/> in <a href="B18147_03_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Designing an Operator – CRD, API, and Target Reconciliation</em>, all Kubernetes API objects should have <strong class="source-inline">Spec</strong> and <strong class="source-inline">Status</strong> fields, and Operators are no different. Therefore, <strong class="source-inline">NginxOperatorSpec</strong> and <strong class="source-inline">NginxOperatorStatus</strong> are those fields, which will be used to accept user input and report on the current state of the Operator, respectively. With <strong class="source-inline">NginxOperator</strong> representing the main object, the relationship between the three is hierarchical.</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B18147_04_001.jpg" alt="Figure 4.1 – The relationship between NginxOperator fields and logic"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – The relationship between NginxOperator fields and logic</p>
			<p>Recalling the problem definition from <a href="B18147_03_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Designing an Operator – CRD, API, and Target Reconciliation</em>, this Operator needs to accept the following inputs:</p>
			<ol>
				<li value="1"><strong class="source-inline">port</strong>, which will define the port number to expose on the Nginx Pod</li>
				<li><strong class="source-inline">replicas</strong>, which defines the number of Pod replicas in order to allow scaling of this deployment through the Operator</li>
				<li><strong class="source-inline">forceRedploy</strong>, which<a id="_idIndexMarker192"/> is a <strong class="bold">no-operation</strong> (<strong class="bold">no-op</strong>) field that simply instructs the Operator to redeploy the <strong class="source-inline">Nginx</strong> Operand</li>
			</ol>
			<p>To implement<a id="_idIndexMarker193"/> these<a id="_idIndexMarker194"/> fields, we need to update the preceding code to modify <strong class="source-inline">NginxOperatorSpec</strong> with these new fields, as in the following. We are using pointers for the integer fields so that our Operator will be able to distinguish between a zero-value and an unset value, which should fall back to using a defined default:</p>
			<pre class="source-code">// NginxOperatorSpec defines the desired state of NginxOperator</pre>
			<pre class="source-code">type NginxOperatorSpec struct {</pre>
			<pre class="source-code">   // Port is the port number to expose on the Nginx Pod</pre>
			<pre class="source-code">   <strong class="bold">Port *int32</strong> `json:"port,omitempty"`</pre>
			<pre class="source-code">   </pre>
			<pre class="source-code">   // Replicas is the number of deployment replicas to scale</pre>
			<pre class="source-code">   <strong class="bold">Replicas *int32</strong> `json:"replicas,omitempty"`</pre>
			<pre class="source-code">   </pre>
			<pre class="source-code">   // ForceRedploy is any string, modifying this field </pre>
			<pre class="source-code">   // instructs  the Operator to redeploy the Operand</pre>
			<pre class="source-code">   <strong class="bold">ForceRedploy string</strong> `json:"forceRedploy,omitempty"`</pre>
			<pre class="source-code">}</pre>
			<p>(Note, we also removed the sample <strong class="source-inline">Foo</strong> field that was generated by the Operator SDK as an example.)</p>
			<p class="callout-heading">Regenerating Code</p>
			<p class="callout">Once the Operator types have been modified, it is sometimes necessary to run <strong class="source-inline">make generate</strong> from the project root. This updates generated files, such as the previously mentioned <strong class="source-inline">zz_generated.deepcopy.go</strong>. It is good practice to develop the habit of regularly running this command whenever making changes to the API, even if it does not always produce any changes. It is even better practice to add pre-submit continuous integration checks to the Operator's repository to ensure that any incoming code includes these generated changes. Such an automated check can be implemented by running <strong class="source-inline">make generate</strong> followed by a simple <strong class="source-inline">git diff</strong>  command to assess whether any changes have appeared. If so, the check should fail and instruct the developer to regenerate their code.</p>
			<p>For all three new <a id="_idIndexMarker195"/>fields, we<a id="_idIndexMarker196"/> have also added JSON tags in the form of <strong class="source-inline">`json:"...,omitempty"`</strong>. The first part of each of these tags defines how the field will appear when represented in JSON or YAML (when interacting with the object through <strong class="source-inline">kubectl,</strong> for example). <strong class="source-inline">omitempty</strong> specifies that if this field is empty, it should not show up in JSON output. This is good for hiding optional fields in order to provide a concise output when viewing the objects in the cluster (otherwise, empty fields will appear as nil or with an empty string). </p>
			<p>We are going to initially make all three of these fields optional, with default values defined in the Operator. However, they could be designated as required with the removal of <strong class="source-inline">omitempty</strong> and the addition of more Kubebuilder tags, for example:</p>
			<pre class="source-code">   // Port is the port number to expose on the Nginx Pod</pre>
			<pre class="source-code">   // +kubebuilder:default=8080</pre>
			<pre class="source-code">   // +kubebuilder:validation:Required</pre>
			<pre class="source-code">   Port int `json:"port"`</pre>
			<p>With these settings, any attempt to modify an <strong class="source-inline">NginxOperator</strong> object without including the <strong class="source-inline">port</strong> field will result in an error from the API server. In current versions of Kubebuilder, the<a id="_idIndexMarker197"/> default assumption is that any field that is not designated as <strong class="source-inline">omitempty</strong> is required. However, there are ways to switch this default globally (with the <strong class="source-inline">// +kubebuilder:validation:Optional</strong> marker applied to the top level of an API). Therefore, whenever changing the requirement of a field, it is good practice to explicitly update that field's specific requirement value.</p>
			<p>With the API<a id="_idIndexMarker198"/> types<a id="_idIndexMarker199"/> defined, it is now possible to generate an equivalent CRD manifest, which will be used to create objects matching these types in a Kubernetes cluster.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>Adding resource manifests</h1>
			<p>The relevant<a id="_idIndexMarker200"/> resources<a id="_idIndexMarker201"/> for an Operator are important to package in a way that can be easily deployed and maintained. This includes the Operator's CRD, but also other resources such<a id="_idIndexMarker202"/> as <strong class="bold">ClusterRoles</strong> and the matching <strong class="bold">ServiceAccount</strong> for those<a id="_idIndexMarker203"/> Roles. However, the first step is to generate a CRD from the Go types defined in the previous section with the following:</p>
			<p class="source-code">$ make manifests</p>
			<p>This command generates a CRD that is based on the API we just defined. That CRD is placed under <strong class="source-inline">config/crd/bases/operator.example.com_nginxoperators.yaml</strong>. That <a id="_idIndexMarker204"/>CRD <a id="_idIndexMarker205"/>looks as follows:</p>
			<pre class="source-code">apiVersion: apiextensions.k8s.io/v1</pre>
			<pre class="source-code">kind: CustomResourceDefinition</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  annotations:</pre>
			<pre class="source-code">    controller-gen.kubebuilder.io/version: v0.7.0</pre>
			<pre class="source-code">  creationTimestamp: null</pre>
			<pre class="source-code">  name: nginxoperators.operator.example.comspec:</pre>
			<pre class="source-code">  group: operator.example.com</pre>
			<pre class="source-code">  names:</pre>
			<pre class="source-code">    kind: NginxOperator</pre>
			<pre class="source-code">    listKind: NginxOperatorList</pre>
			<pre class="source-code">    plural: nginxoperators</pre>
			<pre class="source-code">    singular: nginxoperator</pre>
			<pre class="source-code">  scope: Namespaced</pre>
			<pre class="source-code">  versions:</pre>
			<pre class="source-code">  - name: v1alpha1</pre>
			<pre class="source-code">    schema:</pre>
			<pre class="source-code">      <strong class="bold">openAPIV3Schema</strong>:</pre>
			<pre class="source-code">        description: NginxOperator is the Schema for the </pre>
			<pre class="source-code">                     nginxoperators API</pre>
			<pre class="source-code">        properties:</pre>
			<pre class="source-code">          apiVersion:</pre>
			<pre class="source-code">            description: 'APIVersion defines the versioned </pre>
			<pre class="source-code">                          schema of this representation</pre>
			<pre class="source-code">                          of an object. Servers should convert </pre>
			<pre class="source-code">                          recognized schemas to the latest</pre>
			<pre class="source-code">                          internal value, and may reject </pre>
			<pre class="source-code">                          unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'</pre>
			<pre class="source-code">            type: string</pre>
			<pre class="source-code">          kind:</pre>
			<pre class="source-code">            description: 'Kind is a string value representing </pre>
			<pre class="source-code">                          the REST resource this</pre>
			<pre class="source-code">                          object represents. Servers may infer </pre>
			<pre class="source-code">                          this from the endpoint the client</pre>
			<pre class="source-code">                          submits requests to. Cannot be </pre>
			<pre class="source-code">                          updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'</pre>
			<pre class="source-code">            type: string</pre>
			<pre class="source-code">          metadata:</pre>
			<pre class="source-code">            type: object</pre>
			<pre class="source-code">          spec:</pre>
			<pre class="source-code">            description: NginxOperatorSpec defines the desired </pre>
			<pre class="source-code">                         state of NginxOperator</pre>
			<pre class="source-code">            properties:</pre>
			<pre class="source-code">              <strong class="bold">forceRedploy</strong>:</pre>
			<pre class="source-code">                description: <strong class="bold">ForceRedploy is any string,</strong> </pre>
			<pre class="source-code">                             <strong class="bold">modifying this field instructs</strong></pre>
			<pre class="source-code">                             <strong class="bold">the Operator to redeploy the</strong> </pre>
			<pre class="source-code">                             <strong class="bold">Operand</strong></pre>
			<pre class="source-code">                type: string</pre>
			<pre class="source-code">              <strong class="bold">port</strong>:</pre>
			<pre class="source-code">                description: <strong class="bold">Port is the port number to expose</strong> </pre>
			<pre class="source-code">                             <strong class="bold">on the Nginx Pod</strong></pre>
			<pre class="source-code">                type: integer</pre>
			<pre class="source-code">              <strong class="bold">replicas</strong>:</pre>
			<pre class="source-code">                description: <strong class="bold">Replicas is the number of</strong> </pre>
			<pre class="source-code">                             <strong class="bold">deployment replicas to scale</strong></pre>
			<pre class="source-code">                type: integer</pre>
			<pre class="source-code">            type: object</pre>
			<pre class="source-code">          status:</pre>
			<pre class="source-code">            description: NginxOperatorStatus defines the </pre>
			<pre class="source-code">                         observed state of NginxOperator</pre>
			<pre class="source-code">            type: object</pre>
			<pre class="source-code">        type: object</pre>
			<pre class="source-code">    served: true</pre>
			<pre class="source-code">    storage: true</pre>
			<pre class="source-code">    subresources:</pre>
			<pre class="source-code">      status: {}</pre>
			<pre class="source-code">status:</pre>
			<pre class="source-code">  acceptedNames:</pre>
			<pre class="source-code">    kind: ""</pre>
			<pre class="source-code">    plural: ""</pre>
			<pre class="source-code">  conditions: []</pre>
			<pre class="source-code">  storedVersions: []</pre>
			<p>(In this output, we have added additional formatting to more clearly represent longer strings, such as field descriptions, and highlighted the three fields that were added to the API.)</p>
			<p>This CRD is fairly simple due to the basic structure of the Operator, but even that is a testament to the natural complexity of OpenAPI validation schemas. That complexity emphasizes <a id="_idIndexMarker206"/>the<a id="_idIndexMarker207"/> point that CRD manifests should always be generated and not manually edited. </p>
			<p class="callout-heading">Customizing Generated Manifests</p>
			<p class="callout">The default command for generating manifests creates a complex validation schema that should not be edited by hand. However, the underlying command for <strong class="source-inline">make manifests</strong> is actually calling an<a id="_idIndexMarker208"/> additional tool, <strong class="bold">controller-gen</strong>. This tool is part of a suite of generators available at <a href="https://github.com/kubernetes-sigs/controller-tools">https://github.com/kubernetes-sigs/controller-tools</a>. Running <strong class="source-inline">controller-gen</strong> manually is an acceptable way to generate files and code in non-default ways. For example, the <strong class="source-inline">controller-gen schemapatch</strong> command will regenerate only the OpenAPI validation schema for a CRD. This can be useful if you wish to manually modify other parts of the CRD, which would be overwritten with a full regeneration, such as additional annotations or labels. The full list of commands can be found by installing <strong class="source-inline">controller-gen</strong> from the previously mentioned repository and running it with <strong class="source-inline">controller-gen -h</strong>.</p>
			<p>The <strong class="source-inline">make manifests</strong> command <a id="_idIndexMarker209"/>also creates a corresponding <strong class="bold">Role-Based Access Control</strong> (<strong class="bold">RBAC</strong>) role with can be bound to the Operator's ServiceAccount to give the Operator access to their own custom object:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">config/rbac/role.yaml:</p>
			<pre class="source-code">apiVersion: rbac.authorization.k8s.io/v1</pre>
			<pre class="source-code">kind: ClusterRole</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  creationTimestamp: null</pre>
			<pre class="source-code">  name: manager-role</pre>
			<pre class="source-code">rules:</pre>
			<pre class="source-code">- apiGroups:</pre>
			<pre class="source-code">  - operator.example.com</pre>
			<pre class="source-code">  resources:</pre>
			<pre class="source-code">  - nginxoperators</pre>
			<pre class="source-code">  verbs:</pre>
			<pre class="source-code">  - create</pre>
			<pre class="source-code">  - delete</pre>
			<pre class="source-code">  - get</pre>
			<pre class="source-code">  - list</pre>
			<pre class="source-code">  - patch</pre>
			<pre class="source-code">  - update</pre>
			<pre class="source-code">  - watch</pre>
			<pre class="source-code">- apiGroups:</pre>
			<pre class="source-code">  - operator.example.com</pre>
			<pre class="source-code">  resources:</pre>
			<pre class="source-code">  - nginxoperators/finalizers</pre>
			<pre class="source-code">  verbs:</pre>
			<pre class="source-code">  - update</pre>
			<pre class="source-code">- apiGroups:</pre>
			<pre class="source-code">  - operator.example.com</pre>
			<pre class="source-code">  resources:</pre>
			<pre class="source-code">  - nginxoperators/status</pre>
			<pre class="source-code">  verbs:</pre>
			<pre class="source-code">  - get</pre>
			<pre class="source-code">  - patch</pre>
			<pre class="source-code">  - update</pre>
			<p>This Role grants full access to create, delete, get, list, patch, update, and watch all <strong class="source-inline">nginxoperator</strong> objects in the cluster. It is generally not a best practice for an Operator to manage the life cycle of their own custom resource object (for example, creation of the <strong class="source-inline">config </strong>object is best left to a manual action by the user), so some of the verbs, such <a id="_idIndexMarker210"/>as <strong class="source-inline">create</strong> and <strong class="source-inline">delete</strong>, are not strictly<a id="_idIndexMarker211"/> necessary here. However, we will leave them for now. </p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Additional manifests and BinData</h2>
			<p>The remaining<a id="_idIndexMarker212"/> resource manifests<a id="_idIndexMarker213"/> that will need to be created include the Operator's <strong class="source-inline">ClusterRole</strong> and the Nginx Deployment definition. The <strong class="source-inline">ClusterRole</strong> can be conveniently generated with Kubebuilder tags in the code, which will be done later in the <em class="italic">Writing a control loop</em> section. Before that, the Deployment should be defined so that the control loop has access to it.</p>
			<p>One way to define in-memory resources, such as the Deployment, is by creating them in the code. Many projects take such an approach, including the official example projects available at <a href="https://github.com/operator-framework/operator-sdk">https://github.com/operator-framework/operator-sdk</a>. For the purpose of this Nginx Deployment, the approach would involve creating a function similar to the following:</p>
			<pre class="source-code">func nginxDeployment() *appsv1.Deployment {</pre>
			<pre class="source-code">      dep := &amp;appsv1.Deployment{</pre>
			<pre class="source-code">            ObjectMeta: metav1.ObjectMeta{</pre>
			<pre class="source-code">                  Name:      "nginxDeployment",</pre>
			<pre class="source-code">                  Namespace: "nginxDeploymentNS",</pre>
			<pre class="source-code">            },</pre>
			<pre class="source-code">            Spec: appsv1.DeploymentSpec{</pre>
			<pre class="source-code">               Replicas: &amp;pointer.Int32Ptr(1),</pre>
			<pre class="source-code">                Selector: &amp;metav1.LabelSelector{</pre>
			<pre class="source-code">                      MatchLabels: map[string]string{"app":"nginx"},</pre>
			<pre class="source-code">                },</pre>
			<pre class="source-code">                Template: corev1.PodTemplateSpec{</pre>
			<pre class="source-code">                 ObjectMeta: metav1.ObjectMeta{</pre>
			<pre class="source-code">                       Labels: map[string]string{"app":"nginx"},,          },      </pre>
			<pre class="source-code">            Spec: corev1.PodSpec{ </pre>
			<pre class="source-code">     Containers: []corev1.Container{{</pre>
			<pre class="source-code">                                 Image:   "nginx:latest",</pre>
			<pre class="source-code">                                 Name:    "nginx",</pre>
			<pre class="source-code">                                 Command: []string{"nginx"                              Ports: []corev1.ContainerPort{{</pre>
			<pre class="source-code">                                   ContainerPort: 8080,</pre>
			<pre class="source-code">                                   Name:          "nginx",                                    }},                              }},</pre>
			<pre class="source-code">                        },</pre>
			<pre class="source-code">                  },            },</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      return dep</pre>
			<pre class="source-code">}</pre>
			<p>The preceding function returns a static Deployment Go struct, with default values prepopulated, such as the Deployment name and exposed port. This object could then be modified based on the specifications set in the Operator CRD before using a Kubernetes API client to update the Deployment in the cluster (for example, to update the number of replicas).</p>
			<p>As discussed in <a href="B18147_03_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Designing an Operator – CRD, API, and Target Reconciliation</em>, this approach is easy to code because the resource<a id="_idIndexMarker214"/> struct is immediately available as a Go type. However, in terms of maintainability<a id="_idIndexMarker215"/> and usability, there are better options. This is where tools such as <strong class="bold">go-bindata</strong> and <strong class="bold">go:embed</strong> are helpful.</p>
			<h3>Using go-bindata and go:embed to access resources</h3>
			<p>The go-bindata<a id="_idIndexMarker216"/> project<a id="_idIndexMarker217"/> is available on GitHub at <a href="https://github.com/go-bindata/go-bindata">https://github.com/go-bindata/go-bindata</a>. It works by converting arbitrary files into Go code, which is then compiled into the main program and available in memory. The benefit of using go-bindata is that project resources can be more concisely managed and maintained in a more readable format such as YAML, which provides familiarity with native Kubernetes resource creation. Since Go 1.16, the language has included its own compiler directive, <strong class="source-inline">go:embed</strong>, to essentially perform the same function; however, we will provide an example of both approaches for the benefit of users who have not yet updated to Go 1.16 or who wish to avoid reliance on compiler-specific directives in their development and production environments.</p>
			<p>The first step for either approach is to create the resource manifests in a directory, such as <strong class="source-inline">assets/nginx_deployment.yaml</strong>:</p>
			<pre class="source-code">apiVersion: apps/v1</pre>
			<pre class="source-code">kind: Deployment</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: "nginx-deployment"</pre>
			<pre class="source-code">  namespace: "nginx-operator-ns"</pre>
			<pre class="source-code">  labels:</pre>
			<pre class="source-code">    app: "nginx"</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  replicas: 1</pre>
			<pre class="source-code">  selector:</pre>
			<pre class="source-code">    matchLabels:</pre>
			<pre class="source-code">      app: "nginx"</pre>
			<pre class="source-code">  template:</pre>
			<pre class="source-code">    metadata:</pre>
			<pre class="source-code">      labels:</pre>
			<pre class="source-code">        app: "nginx"</pre>
			<pre class="source-code">    spec:</pre>
			<pre class="source-code">      containers:</pre>
			<pre class="source-code">        - name: "nginx"</pre>
			<pre class="source-code">          image: "nginx:latest"</pre>
			<pre class="source-code">          command: ["nginx"]</pre>
			<p>This structure is already much easier to work with than the native Go types by saving us from having to define each embedded type (such as <strong class="source-inline">map[string]string</strong> for the labels and Pod command). It can also be easily parsed by continuous integration checks to ensure it maintains a valid structure.</p>
			<p>The next two subsections will demonstrate the basic concepts of implementing either <strong class="source-inline">go-bindata</strong> or <strong class="source-inline">go:embed</strong>. These examples will do so by showing how you could add the foundational <a id="_idIndexMarker218"/>concepts for each approach. However, we will<a id="_idIndexMarker219"/> ultimately refactor most of the code in the section titled <em class="italic">Simplifying resource embedding</em>; therefore, you may choose not to write any of this code yourself until reaching the refactoring subsection.</p>
			<h3>Go 1.15 and older – go-bindata</h3>
			<p>For older <a id="_idIndexMarker220"/>versions of Go, you must install the <strong class="source-inline">go-bindata</strong> package from GitHub to generate your files:</p>
			<p class="source-code">$ go get -u github.com/go-bindata/go-bindata/...</p>
			<p>The generated code that contains the manifests can then be created with the following command:</p>
			<p class="source-code">$ go-bindata -o assets/assets.go assets/...</p>
			<p>This command will create an <strong class="source-inline">assets.go</strong> file under the <strong class="source-inline">assets/</strong> directory that contains generated functions and in-memory representations of the files in the <strong class="source-inline">assets/</strong> directory. Note that it can be easier to keep the assets themselves in a different directory than the generated code, as re-running the <strong class="source-inline">go-bindata</strong> command will now include a representation of the <strong class="source-inline">assets.go</strong> file itself unless it is excluded, like so:</p>
			<p class="source-code">$ go-bindata -o assets/assets.go -ignore=\assets\/assets\.go assets/… </p>
			<p>This file will need to be re-generated whenever modifications are made to the underlying assets. Doing so will ensure the changes are made available in the compiled assets package that includes the accessibility functions for the files.</p>
			<p>Once the assets have been generated, they can be accessed in code by importing the new <strong class="source-inline">assets</strong> package and using the <strong class="source-inline">Asset()</strong> function like so:</p>
			<pre class="source-code">import "github.com/sample/nginx-operator/assets"</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">asset, err := assets.Asset("nginx_deployment.yaml")</pre>
			<pre class="source-code">if err != nil {</pre>
			<pre class="source-code">  // process object not found error</pre>
			<pre class="source-code">}</pre>
			<p>For newer versions of Go (1.16 and above), it is even simpler to compile resource manifests into assets.</p>
			<h3>Go 1.16 and newer – go:embed</h3>
			<p>The <strong class="source-inline">go:embed</strong> marker <a id="_idIndexMarker221"/>was included as a compiler directive in Go 1.16 to provide native resource embedding without the need for external tools such as go-bindata. To start with this approach, create the resource manifest files similarly to the go-bindata setup under a new directory called <strong class="source-inline">assets/</strong>.</p>
			<p>Next, the <strong class="source-inline">main.go</strong> file for the Operator project needs to be modified to import the <strong class="source-inline">embed</strong> package and declare the asset manifests as a variable like so (all of the following code in this section shows only the changes that you need to make):</p>
			<pre class="source-code">package main</pre>
			<pre class="source-code">import (</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  "embed"</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">)</pre>
			<pre class="source-code">//go:embed assets/nginx_deployment.yaml</pre>
			<pre class="source-code">var deployment embed.FS</pre>
			<p>Note <a id="_idIndexMarker222"/>the <strong class="source-inline">//go:embed</strong> comment, which tells the compiler to store the contents of <strong class="source-inline">assets/nginx_deployment.yaml</strong> as filesystem data in the <strong class="source-inline">deployment</strong> variable.</p>
			<p>The data can then be read and converted to a Deployment Go struct by utilizing the Kubernetes API scheme declarations like so:</p>
			<pre class="source-code">import (</pre>
			<pre class="source-code">  appsv1 "k8s.io/api/apps/v1"</pre>
			<pre class="source-code">  "k8s.io/apimachinery/pkg/runtime"</pre>
			<pre class="source-code">  "k8s.io/apimachinery/pkg/runtime/serializer"</pre>
			<pre class="source-code">)</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">var (</pre>
			<pre class="source-code">      appsScheme = runtime.NewScheme()</pre>
			<pre class="source-code">      appsCodecs = serializer.NewCodecFactory(appsScheme)</pre>
			<pre class="source-code">)</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">func main() {</pre>
			<pre class="source-code">if err := appsv1.AddToScheme(appsScheme); err != nil {</pre>
			<pre class="source-code">  panic(err)</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">deploymentBytes, err := <strong class="bold">deployment.ReadFile("assets/nginx_deployment.yaml")</strong></pre>
			<pre class="source-code">if err != nil {</pre>
			<pre class="source-code">  panic(err)</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">deploymentObject, err := runtime.Decode(appsCodecs.UniversalDecoder(appsv1.SchemeGroupVersion), deploymentBytes)</pre>
			<pre class="source-code">if err != nil {</pre>
			<pre class="source-code">  panic(err)</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"><strong class="bold">dep := deploymentObject.(*appsv1.Deployment)</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">}</pre>
			<p>This code <a id="_idIndexMarker223"/>does a few things:</p>
			<ol>
				<li value="1">It imports the relevant Kubernetes API packages that define the schema for Deployment API objects:<p class="source-code">import (</p><p class="source-code">  appsv1 "k8s.io/api/apps/v1"</p><p class="source-code">  "k8s.io/apimachinery/pkg/runtime"</p><p class="source-code">  "k8s.io/apimachinery/pkg/runtime/serializer"</p><p class="source-code">)</p></li>
				<li>It initializes a <strong class="source-inline">Scheme</strong> and a set of codecs that can be used by the API's UniversalDecoder in order to know how to convert the <strong class="source-inline">[]byte</strong> data representation of the file to a Go struct:<p class="source-code">var (</p><p class="source-code">     appsScheme = runtime.NewScheme()</p><p class="source-code">      appsCodecs = serializer.NewCodecFactory(appsScheme)</p><p class="source-code">)</p></li>
				<li>It uses<a id="_idIndexMarker224"/> the <strong class="source-inline">deployment</strong> variable we declared earlier (as part of setting up the <strong class="source-inline">embed</strong> directive) to read the <strong class="source-inline">Deployment</strong> file under <strong class="source-inline">assets/nginx_deployment.yaml</strong> (highlighted):<p class="source-code">deploymentBytes, err := <strong class="bold">deployment.ReadFile("assets/nginx_deployment.yaml")</strong> </p><p class="source-code">if err != nil {</p><p class="source-code">  panic(err) </p><p class="source-code">}</p></li>
				<li>It decodes the <strong class="source-inline">[]byte</strong> data returned from <strong class="source-inline">deployment.ReadFile()</strong> into an object that can be cast to the Go type for Deployments:<p class="source-code">deploymentObject, err := runtime.Decode(appsCodecs.UniversalDecoder(appsv1.SchemeGroupVersion), deploymentBytes) </p><p class="source-code">if err != nil {</p><p class="source-code">  panic(err)</p><p class="source-code">}</p></li>
				<li>It casts the object data to an in-memory representation of <strong class="source-inline">*appsv1.Deployment</strong>:<p class="source-code"><strong class="bold">dep := deploymentObject.(*appsv1.Deployment)</strong></p></li>
			</ol>
			<p>From this point, it will be necessary to find a way to pass the Deployment object to our Nginx Operator Controller. This can be done by modifying the <strong class="source-inline">NginxOperatorReconciler</strong> type to have a field that holds a type of <strong class="source-inline">*appsv1.Deployment</strong>. However, this is not convenient for all of the different types of resources the Operator will be managing. To simplify this and better organize the project's<a id="_idIndexMarker225"/> structure, we can move the resource embedding code to its own package.</p>
			<h3>Simplifying resource embedding</h3>
			<p>The preceding<a id="_idIndexMarker226"/> examples showed the essential steps of embedding a YAML file into Go code. However, for our sample Nginx Operator, this can be better organized into its own package. To do this, we will keep the existing <strong class="source-inline">assets/</strong> directory (to use as an importable Go module path that holds helper functions for loading and processing the files) and place a new <strong class="source-inline">manifests/</strong> directory underneath it (which will hold the actual manifest files). This new file structure will look as follows:</p>
			<p class="source-code">./nginx-operator/</p>
			<p class="source-code">| - assets/</p>
			<p class="source-code">| - - assets.go</p>
			<p class="source-code">| - - manifests/</p>
			<p class="source-code">| - - - nginx_deployment.yaml</p>
			<p>The <strong class="source-inline">assets.go</strong> file will include the API schema initialization and wrapped object casting functionality from<a id="_idIndexMarker227"/> the preceding examples, like this:</p>
			<pre class="source-code">package assets</pre>
			<pre class="source-code">import (</pre>
			<pre class="source-code">  "embed"</pre>
			<pre class="source-code">  appsv1 "k8s.io/api/apps/v1"</pre>
			<pre class="source-code">  "k8s.io/apimachinery/pkg/runtime"</pre>
			<pre class="source-code">  "k8s.io/apimachinery/pkg/runtime/serializer"</pre>
			<pre class="source-code">)</pre>
			<pre class="source-code">var (</pre>
			<pre class="source-code">  <strong class="bold">//go:embed manifests/*</strong></pre>
			<pre class="source-code">  <strong class="bold">manifests embed.FS</strong></pre>
			<pre class="source-code">  appsScheme = runtime.NewScheme()</pre>
			<pre class="source-code">  appsCodecs = serializer.NewCodecFactory(appsScheme)</pre>
			<pre class="source-code">)</pre>
			<pre class="source-code">func init() {</pre>
			<pre class="source-code">  if err := appsv1.AddToScheme(appsScheme); err != nil {</pre>
			<pre class="source-code">    panic(err)</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">func <strong class="bold">GetDeploymentFromFile</strong>(name string) *appsv1.Deployment {</pre>
			<pre class="source-code">  deploymentBytes, err := manifests.ReadFile(name)</pre>
			<pre class="source-code">  if err != nil {</pre>
			<pre class="source-code">    panic(err)</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  deploymentObject, err := runtime.Decode(</pre>
			<pre class="source-code">    appsCodecs.UniversalDecoder(appsv1.SchemeGroupVersion), </pre>
			<pre class="source-code">    deploymentBytes,</pre>
			<pre class="source-code">  )</pre>
			<pre class="source-code">  if err != nil {</pre>
			<pre class="source-code">    panic(err)</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  return deploymentObject.(*appsv1.Deployment)</pre>
			<pre class="source-code">}</pre>
			<p>This new file makes a couple of changes from the implementation shared before:</p>
			<ol>
				<li value="1">Now, the entire <strong class="source-inline">manifests/</strong> directory is embedded as a filesystem variable. This will make it easier to add functions to read other resources within the directory <a id="_idIndexMarker228"/>without having to declare new variables in this package for each one.</li>
				<li>The main logic has been wrapped in a new function, <strong class="source-inline">GetDeploymentFromFile()</strong>. This function can be called and used by our control loop like this:<p class="source-code">import "github.com/sample/nginx-operator/assets"</p><p class="source-code">...</p><p class="source-code">nginxDeployment := assets.GetDeploymentFromFile("manifests/nginx_deployment.yaml")</p></li>
			</ol>
			<p>We can add other manifests to this directory so that the Operator can manage them (for example, additional Operand dependencies). But for now, we have enough to begin working on a<a id="_idIndexMarker229"/> control loop.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Writing a control loop</h1>
			<p>With a strategy <a id="_idIndexMarker230"/>for the in-memory representation of resource manifests in place, it is now much easier to begin writing the Operator's control loop. As described in previous chapters, this control loop comprises a core state reconciliation function call that is triggered by certain relevant cluster events. This function does not run continuously on a loop, but rather the main thread of the Operator will be continuously observing the cluster for those events to kick off a call to the state reconciliation function.</p>
			<p>The empty <strong class="source-inline">Reconcile()</strong> function has been scaffolded already by the Operator SDK in <strong class="source-inline">controllers/nginxoperator_controller.go</strong>:</p>
			<pre class="source-code">func (r *NginxOperatorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {</pre>
			<pre class="source-code">  _ = log.FromContext(ctx)</pre>
			<pre class="source-code">  // your logic here</pre>
			<pre class="source-code">  return ctrl.Result{}, nil                                                                                                                                                                                   </pre>
			<pre class="source-code">}</pre>
			<p>Right now, this function does nothing but return an empty <strong class="source-inline">ctrl.Result</strong> and an empty <strong class="source-inline">error</strong>, which evaluates to a successful run and instructs the rest of the framework that there is no need to re-try this reconciliation run. If this function returns either a non-nil <strong class="source-inline">error</strong> or non-empty <strong class="source-inline">ctrl.Result</strong> struct, then the controller will instead re-queue this reconciliation attempt to be tried again. These cases will come up as we populate the controller's logic as indicated by the comment.</p>
			<p>Because the Operator SDK instantiates this controller with a Kubernetes client already accessible, we can use functions such as <strong class="source-inline">Get()</strong> to retrieve cluster resources. The first thing to do is to attempt to access the existing Nginx Operator resource object. If one is not found, we should log a message indicating so and terminate the reconciliation attempt. If there are any other errors retrieving the object, we will instead return an error, so this attempt gets re-queued and tried again. This approach can account for other failures, such as network issues or temporarily dropped connections to the API server. With these changes, the new <strong class="source-inline">Reconcile()</strong> function looks like the following:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">controllers/nginxoperator_controller.go:</p>
			<pre class="source-code">func (r *NginxOperatorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {</pre>
			<pre class="source-code">  logger := log.FromContext(ctx)</pre>
			<pre class="source-code">  operatorCR := &amp;operatorv1alpha1.NginxOperator{}</pre>
			<pre class="source-code">  err := <strong class="bold">r.Get(ctx, req.NamespacedName, operatorCR)</strong></pre>
			<pre class="source-code">  if err != nil &amp;&amp; <strong class="bold">errors.IsNotFound(err)</strong> {</pre>
			<pre class="source-code">    logger.Info("Operator resource object not found.")</pre>
			<pre class="source-code">    return ctrl.Result{}, nil</pre>
			<pre class="source-code">  } else if err != nil {</pre>
			<pre class="source-code">    logger.Error(err, "Error getting operator resource object")</pre>
			<pre class="source-code">    return ctrl.Result{}, err</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  return ctrl.Result{}, nil</pre>
			<pre class="source-code">}</pre>
			<p>This error-handling <a id="_idIndexMarker231"/>pattern is common among Kubernetes projects, including examples from the official Operator SDK documentation. Rather than immediately returning the error, this code essentially ignores the case where the Operator object is simply not found. The <strong class="source-inline">errors.IsNotFound()</strong> check comes from the <strong class="source-inline">k8s.io/apimachinery/pkg/api/errors</strong> package, which provides several helper functions for a standard approach to handling specific Kubernetes errors. Using this pattern helps to minimize logging noise for the user and to ignore events where the Operator resource was deleted (which will still trigger a reconciliation attempt). In the event that the Operator object is not found, developers can go a step further and use that as a signal to take other steps (such as deleting other resources that depend on the Operator deployment). </p>
			<p>Also, note that this code is using <strong class="source-inline">req.NamespacedName</strong> to get the <strong class="source-inline">Name</strong> and <strong class="source-inline">Namespace</strong> of the Operator config object. This follows one of the best practices laid out in the Operator Framework documentation (<a href="https://sdk.operatorframework.io/docs/best-practices/best-practices/">https://sdk.operatorframework.io/docs/best-practices/best-practices/</a>): </p>
			<p><em class="italic">Operators shouldn't make any assumptions about the namespace they are deployed in, and they should not use hardcoded names of resources that they expect to already exist.</em></p>
			<p>In this case, the <strong class="source-inline">req</strong> parameter includes the name of the object event that triggered the reconciliation attempt. Using a consistent name across resources allows us to re-use the <strong class="source-inline">req.NamespacedName</strong> field in every call to <strong class="source-inline">Reconcile()</strong>, regardless of the object that triggered the reconciliation. In other words, if the Deployment has the same Name and Namespace as the Operator custom resource object, we can consistently eliminate the use of hardcoded assumptions for resource names. </p>
			<p>With an Operator resource object successfully found, the controller can retrieve the values for each setting in the Operator's <strong class="source-inline">spec</strong> in order to update them, if necessary. Similar to what we just did for the Operator resource, however, we must first check whether the Deployment exists. For this, we will follow a similar pattern utilizing <strong class="source-inline">errors.IsNotFound()</strong> to check for the non-existence of an Nginx Deployment. However, in this<a id="_idIndexMarker232"/> case, the function will not simply return if no Deployment is found, but instead the controller will create one from the embedded Deployment YAML file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">controllers/nginxoperator_controller.go:</p>
			<pre class="source-code">deployment := &amp;appsv1.Deployment{}</pre>
			<pre class="source-code">err = r.Get(ctx, req.NamespacedName, deployment)</pre>
			<pre class="source-code">if err != nil &amp;&amp; errors.IsNotFound(err) {</pre>
			<pre class="source-code">  deployment.Namespace = req.Namespace</pre>
			<pre class="source-code">  deployment.Name = req.Name</pre>
			<pre class="source-code">  <strong class="bold">deploymentManifest := assets.GetDeploymentFromFile("manifests/nginx_deployment.yaml")</strong></pre>
			<pre class="source-code">  <strong class="bold">deploymentManifest.Spec.Replicas = operatorCR.Spec.Replicas</strong></pre>
			<pre class="source-code"><strong class="bold">deploymentManifest.Spec.Template.Spec.Containers[0].Ports[0].ContainerPort = *operatorCR.Spec.Port</strong></pre>
			<pre class="source-code">  err = r.Create(ctx, deploymentManifest)</pre>
			<pre class="source-code">  if err != nil {</pre>
			<pre class="source-code">    logger.Error(err, "Error creating Nginx deployment.")</pre>
			<pre class="source-code">    return ctrl.Result{}, err</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">return ctrl.Result{}, nil</pre>
			<pre class="source-code">} else if err != nil {</pre>
			<pre class="source-code">  logger.Error(err, "Error getting existing Nginx deployment.")</pre>
			<pre class="source-code">  return ctrl.Result{}, err</pre>
			<pre class="source-code">}</pre>
			<p>In this code, we <a id="_idIndexMarker233"/>are loading the embedded default manifest using the <strong class="source-inline">assets.GetDeploymentFromFile()</strong> function created earlier. We are also modifying that manifest declaration to include the values from the current Operator resource object. </p>
			<p>An alternative to this approach would be to create the Deployment with the default values, and then have the function immediately return with <strong class="source-inline">ctrl.Result{Requeue: true}</strong>. This would trigger another reconciliation attempt, where the Deployment should be found and then updated with the Operator resource settings. The trade - off here is the immediate creation of a new object without the need for another reconciliation cycle, in exchange for less atomic operation and some code duplication (because we will still need the following code to apply the Operator resource settings in the case where an existing Deployment was found). To eliminate that duplicate code, we can modify the preceding section like this:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">controllers/nginxoperator_controller.go:</p>
			<pre class="source-code">deployment := &amp;appsv1.Deployment{}</pre>
			<pre class="source-code"><strong class="bold">create := false</strong></pre>
			<pre class="source-code">err = r.Get(ctx, req.NamespacedName, deployment)</pre>
			<pre class="source-code">  if err != nil &amp;&amp; errors.IsNotFound(err) {</pre>
			<pre class="source-code">    <strong class="bold">create = true</strong></pre>
			<pre class="source-code">    deployment = assets.GetDeploymentFromFile("manifests/nginx_deployment.yaml")</pre>
			<pre class="source-code">} else if err != nil {</pre>
			<pre class="source-code">  logger.Error(err, "Error getting existing Nginx deployment.")</pre>
			<pre class="source-code">  return ctrl.Result{}, err</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">if operatorCR.Spec.Replicas != nil {</pre>
			<pre class="source-code">  deployment.Spec.Replicas = <strong class="bold">operatorCR.Spec.Replicas</strong></pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">if operatorCR.Spec.Port != nil {</pre>
			<pre class="source-code">deployment.Spec.Template.Spec.Containers[0].Ports[0].ContainerPort = *<strong class="bold">operatorCR.Spec.Port</strong></pre>
			<pre class="source-code">}</pre>
			<p>Since<a id="_idIndexMarker234"/> the <strong class="source-inline">Replicas</strong> and <strong class="source-inline">Port</strong> fields in the Operator custom resource are optional (and pointers), we should use <strong class="source-inline">nil</strong> checks to see whether any value has been set. Otherwise, the Deployment will default to the values defined in its <strong class="source-inline">manifest</strong> file.</p>
			<p>Now, we are always making sure that the Deployment object is being modified to include the Operator settings, whether it is the existing Deployment or a new one. Then, the decision to call <strong class="source-inline">Create()</strong> or <strong class="source-inline">Update()</strong> will be made later based on the value of the <strong class="source-inline">create</strong> Boolean:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">controllers/nginxoperator_controller.go:</p>
			<pre class="source-code">if create {</pre>
			<pre class="source-code">  err = r.Create(ctx, deployment)</pre>
			<pre class="source-code">} else {</pre>
			<pre class="source-code">  err = r.Update(ctx, deployment)</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">return ctrl.Result{}, err</pre>
			<p>If either call results in an error, it will be returned and logged by the controller thanks to the scaffolded framework code. If the call to create or update the Deployment is successful, then <strong class="source-inline">err</strong> will be <strong class="source-inline">nil</strong> and the reconciliation call completes successfully. Our full <strong class="source-inline">Reconcile()</strong> function<a id="_idIndexMarker235"/> now looks like this:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">controllers/nginxoperator_controller.go:</p>
			<pre class="source-code">func (r *NginxOperatorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {</pre>
			<pre class="source-code">   logger := log.FromContext(ctx)</pre>
			<pre class="source-code">   operatorCR := &amp;operatorv1alpha1.NginxOperator{}</pre>
			<pre class="source-code">   err := r.Get(ctx, req.NamespacedName, operatorCR)</pre>
			<pre class="source-code">   if err != nil &amp;&amp; errors.IsNotFound(err) {</pre>
			<pre class="source-code">      logger.Info("Operator resource object not found.")</pre>
			<pre class="source-code">      return ctrl.Result{}, nil</pre>
			<pre class="source-code">   } else if err != nil {</pre>
			<pre class="source-code">      logger.Error(err, "Error getting operator resource object")</pre>
			<pre class="source-code">      return ctrl.Result{}, err</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   deployment := &amp;appsv1.Deployment{}</pre>
			<pre class="source-code">   create := false</pre>
			<pre class="source-code">   err = r.Get(ctx, req.NamespacedName, deployment)</pre>
			<pre class="source-code">   if err != nil &amp;&amp; errors.IsNotFound(err) {</pre>
			<pre class="source-code">      create = true</pre>
			<pre class="source-code">      deployment = assets.GetDeploymentFromFile("assets/nginx_deployment.yaml")</pre>
			<pre class="source-code">   } else if err != nil {</pre>
			<pre class="source-code">      logger.Error(err, "Error getting existing Nginx deployment.")</pre>
			<pre class="source-code">      return ctrl.Result{}, err</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">  deployment.Namespace = req.Namespace</pre>
			<pre class="source-code">  deployment.Name = req.Name</pre>
			<pre class="source-code">  if operatorCR.Spec.Replicas != nil {</pre>
			<pre class="source-code">    deployment.Spec.Replicas = operatorCR.Spec.Replicas</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">  if operatorCR.Spec.Port != nil { deployment.Spec.Template.Spec.Containers[0].Ports[0].ContainerPort = *operatorCR.Spec.Port</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  <strong class="bold">ctrl.SetControllerReference</strong>(operatorCR, deployment, r.Scheme)</pre>
			<pre class="source-code">   if create {</pre>
			<pre class="source-code">      err = r.Create(ctx, deployment)</pre>
			<pre class="source-code">   } else {</pre>
			<pre class="source-code">      err = r.Update(ctx, deployment)</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   return ctrl.Result{}, err</pre>
			<pre class="source-code">}</pre>
			<p>In addition, we added a call to <strong class="source-inline">ctrl.SetControllerReference()</strong> to indicate that the Nginx Operator resource object should be listed as the <strong class="source-inline">OwnerReference</strong> (an API field denoting which object "owns" the specified object) of the Nginx Deployment, which helps with garbage collection. </p>
			<p>Finally, we need to ensure that the Operator actually has the cluster permissions necessary to get, create, and update Deployments. To do that, we need to update the RBAC role for the <a id="_idIndexMarker236"/>Operator. This can be done automatically using Kubebuilder markers on the <strong class="source-inline">Reconcile()</strong> function, which helps keep permissions organized and their necessary usage clearly identified. There are already Kubebuilder markers that were generated for accessing the Operator custom resource, but now we can add additional ones for Deployments:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">controllers/nginxoperator_controller.go:</p>
			<pre class="source-code">//+kubebuilder:rbac:groups=operator.example.com,resources=nginxoperators,verbs=get;list;watch;create;update;patch;delete</pre>
			<pre class="source-code">//+kubebuilder:rbac:groups=operator.example.com,resources=nginxoperators/status,verbs=get;update;patch</pre>
			<pre class="source-code">//+kubebuilder:rbac:groups=operator.example.com,resources=nginxoperators/finalizers,verbs=update</pre>
			<pre class="source-code"><strong class="bold">//+kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete</strong></pre>
			<p>Now, running <strong class="source-inline">make manifests</strong> should produce <a id="_idIndexMarker237"/>this new section in the Operator's <strong class="source-inline">ClusterRole</strong> (<strong class="source-inline">config/rbac/role.yaml</strong>):</p>
			<pre class="source-code">rules:</pre>
			<pre class="source-code">- apiGroups:</pre>
			<pre class="source-code">  - apps</pre>
			<pre class="source-code">  resources:</pre>
			<pre class="source-code">  - deployments</pre>
			<pre class="source-code">  verbs:</pre>
			<pre class="source-code">  - create</pre>
			<pre class="source-code">  - delete</pre>
			<pre class="source-code">  - get</pre>
			<pre class="source-code">  - list</pre>
			<pre class="source-code">  - patch</pre>
			<pre class="source-code">  - update</pre>
			<pre class="source-code">  - watch</pre>
			<p>At this point, we now have a basic control loop reconciling the specified Operator settings with the current state of the cluster. But what events will trigger this loop to run? This is set up in <strong class="source-inline">SetupWithManager()</strong>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">controllers/nginxoperator_controller.go:</p>
			<pre class="source-code">// SetupWithManager sets up the controller with the Manager.</pre>
			<pre class="source-code">func (r *NginxOperatorReconciler) SetupWithManager(mgr ctrl.Manager) error {</pre>
			<pre class="source-code">   return ctrl.NewControllerManagedBy(mgr).</pre>
			<pre class="source-code">      For(&amp;operatorv1alpha1.NginxOperator{}).</pre>
			<pre class="source-code">      Complete(r)</pre>
			<pre class="source-code">}</pre>
			<p>This code was generated to observe the cluster for changes to the <strong class="source-inline">NginxOperator</strong> objects, but we need it to also observe changes to Deployment objects (since the Operator is managing a Deployment). This can be done by modifying the function like this:</p>
			<pre class="source-code">// SetupWithManager sets up the controller with the Manager.</pre>
			<pre class="source-code">func (r *NginxOperatorReconciler) SetupWithManager(mgr ctrl.Manager) error {</pre>
			<pre class="source-code">   return ctrl.NewControllerManagedBy(mgr).</pre>
			<pre class="source-code">      For(&amp;operatorv1alpha1.NginxOperator{}).</pre>
			<pre class="source-code">      <strong class="bold">Owns(&amp;appsv1.Deployment{}).</strong></pre>
			<pre class="source-code">      Complete(r)</pre>
			<pre class="source-code">}</pre>
			<p>With the added call to <strong class="source-inline">Owns(&amp;appsv1.Deployment{})</strong>, the controller manager now knows to<a id="_idIndexMarker238"/> also trigger calls to <strong class="source-inline">Reconcile()</strong> for changes to Deployment objects in the cluster. The controller will now evaluate any changes to a Deployment object as a relevant event for the <strong class="source-inline">NginxOperator</strong> object since we have listed it as the owner of the Deployment. Multiple types of objects can be chained into this watch list with subsequent calls to <strong class="source-inline">Owns()</strong>.</p>
			<p>We now have an Operator that does something. When built and deployed, this controller will watch for changes to any <strong class="source-inline">NginxOperator</strong> custom resource in the cluster and react to them. This means that the first time a user creates the Operator custom resource object, the Operator will see that a configuration object now exists, and create a Deployment based on the values present. It will also observe for changes to Deployments. For example, if the Nginx Deployment is accidentally deleted, the Operator will respond by creating a new one with the existing settings from its custom resource.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Troubleshooting</h1>
			<p>The steps outlined <a id="_idIndexMarker239"/>in this chapter involve using several different tools and libraries with varying dependency requirements. Understandably, this can lead to errors, especially in different development environments. While the authors of the software involved have taken steps to produce informative and helpful error messages when necessary, it is not always possible to provide a clear resolution with automated responses. Such is the unfortunate nature of rapidly evolving software development. </p>
			<p>Fortunately, however, the benefits of open source software provide many resources and volunteers to help support and debug issues, should they arise. This section will highlight those resources as a guide for resolving technical issues. All of these tools offer documentation and how-to guides, but many of them also have community resources where users can ask for clarification and assistance from maintainers and other users.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>General Kubernetes resources</h2>
			<p>The Operator <a id="_idIndexMarker240"/>SDK is foundationally<a id="_idIndexMarker241"/> built upon several Kubernetes libraries; therefore, it is very helpful to understand some of the Kubernetes packages that are used to build Operators with the framework. By doing so, it can sometimes be easier to find the root cause of an issue.</p>
			<p>The Kubernetes reference documents are located at <a href="https://kubernetes.io/docs/home/">https://kubernetes.io/docs/home/</a>. However, this home section is mostly oriented toward usage documentation. For support regarding the Kubernetes API (including API clients, standards, and object references), the API reference section is much more relevant to the topics covered in this chapter. That is located at <a href="https://kubernetes.io/docs/reference/">https://kubernetes.io/docs/reference/</a>. </p>
			<p>The entire Kubernetes source code is available on GitHub under various organizations, such as <a href="https://github.com/kubernetes">https://github.com/kubernetes</a> (most of the project code) and <a href="https://github.com/kubernetes-sigs">https://github.com/kubernetes-sigs</a> (subprojects, such as Kubebuilder). For example, the Go client library, which is used by the Operator SDK framework under the hood to provide resource functions such as <strong class="source-inline">r.Get()</strong>, is hosted at <a href="https://github.com/kubernetes/client-go/">https://github.com/kubernetes/client-go/</a>.</p>
			<p>Familiarity with the GitHub repositories that host the different code dependencies that the Operator Framework is built on provides an excellent resource for communication with the maintainers of these projects. Searching the <em class="italic">Issues</em> on GitHub can very often provide immediate relief to an issue (or at least provide insight into the current status of ongoing problems).</p>
			<p>For faster responses and a wider audience, the Kubernetes community is very active on the Slack messaging platform. The official Kubernetes Slack server is open to anyone, at <a href="http://slack.k8s.io">slack.k8s.io</a>. Helpful channels for developers working with general Kubernetes issues include the<a id="_idIndexMarker242"/> following:</p>
			<ul>
				<li><strong class="bold">#kubernetes-novice</strong> – This channel is for new Kubernetes users and developers.</li>
				<li><strong class="bold">#kubernetes-contributors</strong> – This channel is more dedicated to the development of Kubernetes itself, but there are still useful topics covered around relevant topics, such as API clients.</li>
				<li><strong class="bold">#kubernetes-users</strong> – Similar to <strong class="source-inline">#kubernetes-novice</strong> with a focus on usage rather than development, but for more specific questions.</li>
				<li><strong class="bold">#sig-api-machinery</strong> – The different areas and subprojects of Kubernetes are owned by their<a id="_idIndexMarker243"/> respective <strong class="bold">Special Interest Groups</strong> (<strong class="bold">SIGs</strong>). <strong class="source-inline">SIG-APIMachinery</strong> is responsible for the ownership of the Kubernetes Go client, which we used by extension in this chapter. Here you will find the most knowledgeable contributors in regard to API topics.</li>
			</ul>
			<p>For the topics in <a id="_idIndexMarker244"/>this chapter, these<a id="_idIndexMarker245"/> resources are relevant for issues related to the Kubernetes API, including the generated client tools created with commands such as <strong class="source-inline">make generate</strong>.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Operator SDK resources</h2>
			<p>The Operator <a id="_idIndexMarker246"/>SDK also provides a wealth of <a id="_idIndexMarker247"/>documentation, including example Operator development tutorials. In this chapter, developing an Operator in Go meant following similar steps to those outlined in the Operator SDK Go documentation, located at <a href="https://sdk.operatorframework.io/docs/building-operators/golang/">https://sdk.operatorframework.io/docs/building-operators/golang/</a>.</p>
			<p>Similar to other Kubernetes projects, Operator SDK is also available on GitHub at <a href="https://github.com/operator-framework/operator-sdk/">https://github.com/operator-framework/operator-sdk/</a>. This is a great resource for examples, issue tracking, and staying notified of updates and ongoing work with the project.</p>
			<p>There are several Operator-specific channels on <a href="http://slack.k8s.io">slack.k8s.io</a>, including <strong class="bold">#operator-sdk-dev</strong> (which is meant for discussion related to the Operator SDK) and <strong class="bold">#kubernetes-operators</strong>, which is for general discussion purposes regarding Operators.</p>
			<p>These resources are all helpful for problems related to the <strong class="source-inline">operator-sdk</strong> binary, or the patterns <a id="_idIndexMarker248"/>provided by the SDK's code libraries and patterns.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>Kubebuilder resources</h2>
			<p>Kubebuilder is the tool <a id="_idIndexMarker249"/>that is used by Operator<a id="_idIndexMarker250"/> SDK to generate manifests and some controller code. This includes commands that were run in this chapter, such as <strong class="source-inline">make manifests</strong>, so for most issues related to CRDs or generating them from code markers (for example, <strong class="source-inline">//+kubebuilder…</strong>), this is a good starting point for assistance.</p>
			<p>An excellent reference for Kubebuilder is the Kubebuilder Book, available at <a href="https://book.kubebuilder.io/">https://book.kubebuilder.io/</a>. This is the essential documentation reference for Kubebuilder and includes details on all of the available comment markers for generating code. Its code base is also available on GitHub at <a href="https://github.com/kubernetes-sigs/kubebuilder">https://github.com/kubernetes-sigs/kubebuilder</a>, and some of its sub-tools (such as controller-gen) are available at <a href="https://github.com/kubernetes-sigs/controller-tools">https://github.com/kubernetes-sigs/controller-tools</a>.</p>
			<p>Finally, there is the <strong class="bold">#kubebuilder</strong> channel on the Kubernetes Slack server for interactive discussion and help with this tool.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Summary</h1>
			<p>This chapter followed the design we outlined in <a href="B18147_03_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Designing an Operator – CRD, API, and Target Reconciliation</em>, to produce functional code that achieves the minimum requirements for a <em class="italic">Level I </em>Operator (Basic Install). With the support of the Operator Lifecycle Manager (which will be demonstrated in later chapters) and good subsequent API design, this Operator will also support upgrades for itself and its Operand, which qualifies it for <em class="italic">Level II</em>.</p>
			<p>The steps for creating a Go-based Operator, as recommended by the Operator SDK documentation approach, build upon each other to achieve base functionality. In this chapter, that pattern meant first designing the Operator's API types, which are then generated into a CRD using tools such as Kubebuilder. At this time, it is good to begin thinking about other resource manifests, such as the Operand Deployment, and how those will be represented in memory. This guide took the approach of embedding these additional resources directly into the Go binary using built-in Go compiler directives that allow the language to do this natively.</p>
			<p>Finally, the core controller code was filled in. This is what makes the Operator a controller, and this control loop is used to reconcile the desired state of the cluster with the actual state of the cluster based on user input through the Operator's CRD. With some additional tweaks to the event triggers and added RBAC permissions, this code begins to observe Deployments, which is necessary to manage the Operand.</p>
			<p>In the next chapter, we will build on this basic functionality to add more advanced code. This will bring our Operator beyond Level II, as we add things such as metrics and leader election to create a more sophisticated controller capable of deeper insights and error handling. </p>
		</div>
	</body></html>