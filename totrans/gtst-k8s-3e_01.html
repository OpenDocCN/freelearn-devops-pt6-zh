<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction to Kubernetes</h1>
                </header>
            
            <article>
                
<p>In this book, we will help you build, scale, and manage production-ready Kubernetes clusters. Each section of this book will empower you with the core container concepts and the operational context of running modern web services that need to be available 24 hours of the day, 7 days a week, 365 days of the year. As we progress, you'll be given concrete, code-based examples that you can deploy into running clusters in order to get real-world feedback on Kubernetes' many abstractions. By the end of this book, you will have mastered the core conceptual building blocks of Kubernetes, and will have a firm understanding of how to handle the following paradigms:</p>
<ul>
<li style="font-weight: 400">Orchestration</li>
<li style="font-weight: 400">Scheduling</li>
<li style="font-weight: 400">Networking</li>
<li style="font-weight: 400">Security</li>
<li style="font-weight: 400">Storage</li>
<li style="font-weight: 400">Identity and authentication</li>
<li style="font-weight: 400">Infrastructure management</li>
</ul>
<p>This chapter will set the <span><span>stage </span></span>for <em>why Kubernetes?</em> and give an overview of modern container history, diving into how containers work, as well as why it's important to schedule, orchestrate, and manage a container platform well. We'll tie this back to concrete objectives and goals for your business and product. This chapter will also give a brief overview of how Kubernetes orchestration can enhance our container management strategy and how we can get a basic Kubernetes cluster up, running, and ready for container deployments.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Introducing container operations and management</li>
<li>The importance of container management </li>
<li>The advantages of Kubernetes</li>
</ul>
<p class="mce-root"/>
<ul>
<li>Downloading the latest Kubernetes</li>
<li>Installing and starting up a new Kubernetes cluster</li>
<li>The components of a Kubernetes cluster</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p><span>You'll need to have the following tools installed:</span></p>
<ul>
<li>Python</li>
<li>AWS CLI</li>
<li>Google Cloud CLI</li>
<li>Minikube</li>
</ul>
<p>We'll go into the specifics of these tools' installation and configuration as we go through this chapter. If you already know how to do this, you can go ahead and set them up now.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A brief overview of containers</h1>
                </header>
            
            <article>
                
<p>Believe it or not, containers and their precursors have been around for over 15 years in the Linux and Unix operating systems. If you look deeper into the fundamentals of how containers operate, you can see their roots in the chroot technology that was invented all the way back in 1970. Since the early 2000s, FreeBSD, Linux, Solaris, Open VZ, Warden, and finally Docker all made significant attempts at encapsulating containerization technology for the end user.</p>
<p>While the VServer's project and first commit (<em>running several general purpose Linux server on a single box with a high degree of independence and security</em> (<a href="http://ieeexplore.ieee.org/document/1430092/?reload=true">http://ieeexplore.ieee.org/document/1430092/?reload=true</a>)) may have been one of the most interesting historical junctures in container history, it's clear that Docker set the container ecosystem on fire back in late 2013 when they went full in on the container ecosystem and decided to rebrand from dotCloud to Docker. Their mass marketing of container appeal set the stage for the broad market adoption we see today and is a direct precursor of the massive container orchestration and scheduling platforms we're writing about here.</p>
<p class="mce-root"/>
<p>Over the past five years, containers have grown in popularity like wildfire. Where containers were once relegated to developer laptops, testing, or development environments, you'll now see them as the building blocks of powerful production systems. They're running highly secure banking workloads and trading systems, powering IoT, keeping our on-demand economy humming, and scaling up to millions of containers to keep the products of the 21st century running at peak efficiency in both the cloud and private data centers. Furthermore, containerization technology permeates our technological zeitgest, with every technology conference in the world devoting a significant portion of their talks and sessions devoted to building, running, or developing in containers.</p>
<p>At the beginning of this compelling story lies Docker and their compelling suite of developer-friendly tools. Docker for macOS and Windows, Compose, Swarm, and Registry have been incredibly powerful tools that have shaped workflows and changed how companies develop software. They've built a bridge for containers to exist at the very heart of the <strong>Software Delivery Life Cycle</strong> (<strong>SDLC</strong>), and a remarkable ecosystem has sprung up around those containers. As Malcom McLean revolutionized the physical shipping world in the 1950s by creating a standardized shipping container, which is used today for everything from ice cube trays to automobiles, Linux containers are revolutionizing the software development world by making application environments portable and consistent across the infrastructure landscape.</p>
<p>We'll pick this story up as containers go mainstream, go to production, and go big within organizations. We'll look at what makes a container next.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is a container?</h1>
                </header>
            
            <article>
                
<p class="mce-root">Containers are a type of operating system virtualization, much like the virtual machines that preceded them. There's also lesser known types of virtualization such as Application Virtualization, Network Virtualization, and Storage Virtualization. While these technologies have been around since the 1960s, Docker's encapsulation of the container paradigm represents a modern implementation of resource isolation that utilizes built-in Linux kernel features such as chroot, <strong>control groups</strong> (<strong>cgroups</strong>), UnionFS, and namespaces to fully isolated resource control at the process level.</p>
<p>Containers use these technologies to create lightweight images that act as a standalone, fully encapsulated piece of software that carries everything it needs inside the box. This can include application binaries, any system tools or libraries, environment-based configuration, and runtime. This special property of isolation is very important, as it allows developers and operators to leverage the all-in-one nature of a container to run without issue, regardless of the environment it's run on. This includes developer laptops and any kind of pre-production or production environment.</p>
<p>This decoupling of application packaging mechanism from the environment on which it runs is a powerful concept that provides a clear separation of concerns between engineering teams. This allows developers to focus on building the core business capabilities into their application code and managing their own dependencies, while operators can streamline the continuous integration, promotion, and deployment of said applications without having to worry about their configuration.</p>
<p>At the core of container technology are three key concepts:</p>
<ul>
<li style="font-weight: 400">cgroups</li>
<li style="font-weight: 400">Namespaces</li>
<li style="font-weight: 400">Union filesystems</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">cgroups</h1>
                </header>
            
            <article>
                
<p>cgroups work by allowing the host to share and also limit the resources each process or container can consume. This is important for both resource utilization and security, as it prevents <strong>denial-of-service</strong> (<strong>DoS</strong>) attacks on the host's hardware resources. Several containers can share CPU and memory while staying within the predefined constraints. cgroups allow containers to provision access to memory, disk I/O, network, and CPU. You can also access devices (for example, <kbd>/dev/foo</kbd>). cgroups also power the soft and hard limits of container constraints that we'll discuss in later chapters.</p>
<p>There are seven major cgroups:</p>
<ul>
<li style="font-weight: 400"><strong>Memory cgroup</strong>: This keeps track of page access by the group, and can define limits for physical, kernel, and total memory.</li>
<li style="font-weight: 400"><strong>Blkio cgroup</strong>: This tracks the I/O usage per group, across the read and write activity per block device. You can throttle by group per device, on operations versus bytes, and for reads versus writes.</li>
<li style="font-weight: 400"><strong>CPU cgroup</strong>: This keeps track of user and system CPU time and usage per CPU. This allows you to set weights, but not limits.</li>
</ul>
<ul>
<li style="font-weight: 400"><strong>Freezer cgroup</strong>: This is useful in batch management systems that are often stopping and starting tasks in order to schedule resources efficiently. The SIGSTOP signal is used to suspend a process, and the process is generally unaware that it is being suspended (or resumed, for that matter.)</li>
<li style="font-weight: 400"><strong>CPUset cgroup</strong>: This allows you to pin a group to a specific CPU within a multi-core CPU architecture. You can pin by application, which will prevent it from moving between CPUs. This can improve the performance of your code by increasing the amount of local memory access or minimizing thread switching.</li>
<li style="font-weight: 400"><strong>Net_cls/net_prio cgroup</strong>: This keeps tabs on the egress traffic class (<kbd>net_cls</kbd>)  or priority (<kbd>net_prio</kbd>) that is generated by the processes within the cgroup.</li>
<li style="font-weight: 400"><strong>Devices cgroup</strong>: This controls what read/write permissions the group has on device nodes.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Namespaces </h1>
                </header>
            
            <article>
                
<p class="mce-root">Namespaces offer another form of isolation for process interaction within operating systems, creating the workspace we call a container. Linux namespaces are created via a syscall named <kbd>unshare</kbd>, while <kbd>clone</kbd> and <kbd>setns</kbd> allow you to manipulate namespaces in other manners.</p>
<div class="packt_infobox"><kbd>unshare()</kbd> allows a process (or thread) to disassociate parts of its execution context that are currently being shared with other processes (or threads). Part of the execution context, such as the mount namespace, is shared implicitly when a new process is created using FORK(2) (for more information visit <a href="http://man7.org/linux/man-pages/man2/fork.2.html">http://man7.org/linux/man-pages/man2/fork.2.html</a>) or VFORK(2) (for more information visit <a href="http://man7.org/linux/man-pages/man2/vfork.2.html">http://man7.org/linux/man-pages/man2/vfork.2.html</a>), while other parts, such as virtual memory, may be shared by explicit request when creating a process or thread using CLONE(2) (for more information visit <a href="http://man7.org/linux/man-pages/man2/clone.2.html">http://man7.org/linux/man-pages/man2/clone.2.html</a>).</div>
<p>Namespaces limit the visibility a process has on other processes, networking, filesystems, and user ID components. Container processes are limited to seeing only what is in the same namespace. Processes from containers or the host processes are not directly accessible from within this container process. Additionally, Docker gives each container its own networking stack that protects the sockets and interfaces in a similar fashion. </p>
<p>If cgroups limit how much of a thing you can use, namespaces limit what things you can see. The following diagram shows the composition of a container:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/4cce4fa1-a187-490d-90b0-ee6b67e68600.png" style="width:36.92em;height:26.42em;" width="1999" height="1429"/></div>
<p>In the case of the Docker engine, the following namespaces are used:</p>
<ul>
<li style="font-weight: 400"><kbd>pid</kbd>: Provides process isolation via an independent set of process IDs from other namespaces. These are nested.</li>
<li style="font-weight: 400"><kbd>net</kbd>: Manages network interfaces by virtualizing the network stack through providing a loopback interface, and can create physical and virtual network interfaces that exist in a single namespace at a time.</li>
<li style="font-weight: 400"><kbd>ipc</kbd>: Manages access to interprocess communication.</li>
<li style="font-weight: 400"><kbd>mnt</kbd>: Controls filesystem mount points. These were the first kind of namespaces created in the Linux kernel, and can be private or shared.</li>
<li style="font-weight: 400"><kbd>uts</kbd>: The Unix time-sharing system isolates version IDs and kernel by allowing a single system to provide different host and domain naming schemes to different processes. The processes <kbd>gethostname</kbd> and <kbd>sethostname</kbd> use this namespace.</li>
<li><kbd>user</kbd>: This namespace allows you to map UID/GID from container to host, and prevents the need for extra configuration in the container.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Union filesystems</h1>
                </header>
            
            <article>
                
<p><span>Union filesystems </span>are also a key advantage of using Docker containers. Containers run from an image. Much like an image in the VM or cloud world, it represents state at a particular point in time. Container images snapshot the filesystem, but tend to be much smaller than a VM. The container shares the host kernel and generally runs a much smaller set of processes, so the filesystem and bootstrap period tend to be much smaller—<span>t</span>hough those constraints are not strictly enforced. Second, the union filesystem allows for the efficient storage, download, and execution of these images. Containers use the idea of <em>copy-on-write storage</em>, which is able to create a brand new container immediately, without having to wait on copying out a whole new filesystem. This is similar to thin provisioning in other systems, where storage is allocated as needed:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/e23753d0-1323-4c21-a729-5e298550813e.png" style="width:32.50em;height:22.92em;" width="601" height="423"/></div>
<p>Copy-on-write storage keeps track of what's changed, and in this way is similar to <strong>distributed version control systems</strong> (<strong>DVCS</strong>) such as Git. There are a number of options available to the end user that leverage copy-on-write storage:</p>
<ul>
<li style="font-weight: 400">AUFS and overlay at the file level</li>
<li style="font-weight: 400">Device mapper at the block level</li>
<li style="font-weight: 400">BTRFS and ZFS and the filesystem level</li>
</ul>
<p>The easiest way to understand union filesystems is to think of them like a layer cake with each layer baked independently. The Linux kernel is our base layer; then, we might add an OS such as Red Hat Linux or Ubuntu.</p>
<p>Next, we might add an application such as nginx or Apache. Every change creates a new layer. Finally, as you make changes and new layers are added, you'll always have a top layer (think frosting) that is a writable layer. Union filesystems leverage this strategy to make each layer lightweight and speedy.</p>
<p>In Docker's case, the storage driver is responsible for stacking these layers on top of each other and providing a single pane of glass to view these systems. The thin writable layer on the top of this stack of layers is where you'll do your work: the writable container layer. We can consider each layer below to be container image layers:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/d71ff188-e5be-44a7-99e7-38e1e04ccd6a.png" style="width:15.50em;height:41.33em;" width="399" height="1062"/></div>
<p>What makes this truly efficient is that Docker caches the layers the first time we build them. So, let's say that we have an image with Ubuntu and then add Apache and build the image. Next, we build MySQL with Ubuntu as the base. The second build will be much faster because the Ubuntu layer is already cached. Essentially, our chocolate and vanilla layers, from the preceding diagram, are already baked. We simply need to bake the pistachio (MySQL) layer, assemble, and add the icing (the writable layer).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Why are containers so cool?</h1>
                </header>
            
            <article>
                
<p>What's also really exciting is that not only has the open source community embraced containers and Kubernetes, but the cloud providers have also deeply embraced the container ecosystem, and invested millions of dollars in supporting tooling, ecosystem, and management planes that can help manage containers. This means you have more options to run container workloads, and you'll have more tools to manage the scheduling and orchestration of the applications running on your clusters.</p>
<p>We'll explore some specific opportunities available to Kubernetes users, but at the time of this book's publishing, all of the major <strong>cloud service providers</strong> (<strong>CSPs</strong>) are offering some form of hosted or managed Kubernetes:</p>
<ul>
<li><strong>Amazon Web Services</strong>: AWS offers <strong>Elastic Container Service for Kubernetes</strong> (<strong>EKS</strong>) (for more information visit <a href="https://aws.amazon.com/eks/">https://aws.amazon.com/eks/</a>), a managed service that simplifies running Kubernetes clusters in their cloud. You can also roll your own clusters with kops (for information visit <a href="https://kubernetes.io/docs/setup/custom-cloud/kops/">https://kubernetes.io/docs/setup/custom-cloud/kops/</a>). This product is still in active development:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="Images/02bfdebe-ea92-4aeb-8f55-40461f10787e.png" width="1043" height="400"/></div>
<ul>
<li><strong>Google Cloud Platform</strong>: GCP offers the <strong>Google Kubernetes Engine</strong> (<strong>GKE</strong>) (for more information visit <a href="https://cloud.google.com/kubernetes-engine/">https://cloud.google.com/kubernetes-engine/</a>), a powerful cluster manager that can deploy, manage, and scale containerized applications in the cloud. Google has been running containerized workloads for over 15 years, and this platform is an excellent choice for sophisticated workload management:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="Images/ff002177-ab39-4bb5-9c8f-569c4f5b4c98.png" style="width:34.33em;height:19.08em;" width="382" height="212"/></div>
<ul>
<li><strong>Microsoft Azure</strong>: Azure offers the <strong>Azure Container Service</strong> (<strong>AKS</strong>) (for more information visit <a href="https://azure.microsoft.com/en-us/services/kubernetes-service/">https://azure.microsoft.com/en-us/services/kubernetes-service/</a>), which aims to simplify the deployment, management, and operations of a full-scale Kubernetes cluster. This product is still in active development:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f45bd510-b702-4f04-b815-6bcc2081699d.png" style="width:52.92em;height:7.92em;" width="1068" height="160"/></div>
<p style="padding-left: 60px">When you take advantage of one of these systems, you get built-in management of your Kubernetes cluster, which allows you to focus on the optimization, configuration, and deployment of your cluster.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The advantages of Continuous Integration/Continuous Deployment</h1>
                </header>
            
            <article>
                
<p>ThoughtWorks defines Continuous Integration as a development practice that requires developers to integrate code into a shared repository several times a day. By having a continuous process of building and deploying code, organizations are able to instill quality control and testing as part of the everyday work cycle. The result is that updates and bug fixes happen much faster and the overall quality improves.</p>
<p>However, there has always been a challenge in creating development environments that match those of testing and production. Often, inconsistencies in these environments make it difficult to gain the full advantage of Continuous Delivery. Continuous Integration is the first step in speeding up your organization's software delivery life cycle, which helps you get your software features in front of customer quickly and reliably.</p>
<p>The concept of Continuous Delivery/Deployment uses Continuous Integration to enables developers to have truly portable deployments. Containers that are deployed on a developer's laptop are easily deployed on an in-house staging server. They are then easily transferred to the production server running in the cloud. This is facilitated due to the nature of containers, which build files that specify parent layers, as we discussed previously. One advantage of this is that it becomes very easy to ensure OS, package, and application versions are the same across development, staging, and production environments. Because all the dependencies are packaged into the layer, the same host server can have multiple containers running a variety of OS or package versions. Furthermore, we can have various languages and frameworks on the same host server without the typical dependency clashes we would get in a VM with a single operating system.</p>
<p>This sets the stage for Continuous Delivery/Deployment of the application, as the operations teams or the developers themselves can focus on getting deployments and application rollouts correct, without having to worry about the intricacies of dependencies.</p>
<p>Continuous Delivery is the embodiment and process wherein all code changes are automatically built, tested (Continuous Integration), and then released into production (Continuous Delivery). If this process captures the correct quality gates, security guarantees, and unit/integration/system tests, the development teams will constantly release production-ready and deployable artifacts that have moved through an automated and standardized process.</p>
<p>It's important to note that CD requires the engineering teams to automate more than just unit tests. In order to utilize CD in sophisticated scheduling and orchestration systems such as Kubernetes, teams need to verify application functionality across many dimensions before they're deployed to customers. We'll explore deployment strategies that Kubernetes has to offer in later chapters.</p>
<p>Lastly, it's important to keep in mind that utilizing Kubernetes with CI/CD reduces the risk of the many common problems that technology firms face:</p>
<ul>
<li style="font-weight: 400"><strong>Long release cycles</strong>: If it takes a long time to release code to your users, then it's a potential functionality that they're missing out on, and this results in lost revenue. If you have a manual testing or release process, it's going to slow down getting changes to production, and therefore in front of your customers.</li>
<li style="font-weight: 400"><strong>Fixing code is hard</strong>: When you shorten the release cycle, you're able to discover and remediate bugs closer to the point of creation. This lowers the fixed cost, as there's a correlation between bug introduction and bug discovery times.</li>
<li style="font-weight: 400"><strong>Release better</strong>: The more you release, the better you get at releasing. Challenging your developers and operators to build automation, monitoring, and logging around the processes of CI/CD will make your pipeline more robust. As you release more often, the amount of difference between releases also decreases. A smaller difference allows teams to troubleshoot potential breaking changes more quickly, which in turn gives them more time to refine the release process further. It's a virtuous cycle!</li>
</ul>
<p>Because all the dependencies are packaged into the layer, the same host server can have multiple containers running a variety of OS or package versions. Furthermore, we can have various languages and frameworks on the same host server without the typical dependency clashes we would get in a VM with a single operating system.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Resource utilization</h1>
                </header>
            
            <article>
                
<p>The well-defined isolation and layer filesystem also makes containers ideal for running systems with a very small footprint and domain-specific purpose. A streamlined deployment and release process means we can deploy quickly and often. As such, many companies have reduced their deployment time from weeks or months to days and hours in some cases. This development life cycle lends itself extremely well to small, targeted teams working on small chunks of a larger application.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Microservices and orchestration</h1>
                </header>
            
            <article>
                
<p>As we break down an application into very specific domains, we need a uniform way to communicate between all the various pieces and domains. Web services have served this purpose for years, but the added isolation and granular focus that containers bring have paved the way for microservices.</p>
<p>A definition for microservices can be a bit nebulous, but a definition from Martin Fowler, a respected author and speaker on software development, says this:</p>
<div class="packt_quote">In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.</div>
<p>As the pivot to containerization and as microservices evolve in an organization, they will soon need a strategy to maintain many containers and microservices. Some organizations will have hundreds or even thousands of containers running in the years ahead.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Future challenges</h1>
                </header>
            
            <article>
                
<p>Life cycle processes alone are an important piece of operation and management. How will we automatically recover when a container fails? Which upstream services are affected by such an outage? How will we patch our applications with minimal downtime? How will we scale up our containers and services as our traffic grows?</p>
<p>Networking and processing are also important concerns. Some processes are part of the same service and may benefit from proximity to the network. Databases, for example, may send large amounts of data to a particular microservice for processing. How will we place containers near each other in our cluster? Is there common data that needs to be accessed? How will new services be discovered and made available to other systems?</p>
<p>Resource utilization is also key. The small footprint of containers means that we can optimize our infrastructure for greater utilization. Extending the savings started in the Elastic cloud will take us even further toward minimizing wasted hardware. How will we schedule workloads most efficiently? How will we ensure that our important applications always have the right resources? How can we run less important workloads on spare capacity?</p>
<p>Finally, portability is a key factor in moving many organizations to containerization. Docker makes it very easy to deploy a standard container across various operating systems, cloud providers, and on-premise hardware or even developer laptops. However, we still need tooling to move containers around. How will we move containers between different nodes on our cluster? How will we roll out updates with minimal disruption? What process do we use to perform blue-green deployments or canary releases?</p>
<p>Whether you are starting to build out individual microservices and separating concerns into isolated containers or you simply want to take full advantage of the portability and immutability in your application development, the need for management and orchestration becomes clear. This is where orchestration tools such as Kubernetes offer the biggest value.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Our first clusters</h1>
                </header>
            
            <article>
                
<p>Kubernetes is supported on a variety of platforms and OSes. For the examples in this book, I used an Ubuntu 16.04 Linux VirtualBox (<a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a>) for my client and <strong>Google Compute Engine</strong> (<strong>GCE</strong>) with Debian for the cluster itself. We will also take a brief look at a cluster running on <strong>Amazon Web Services</strong> (<strong>AWS</strong>) with Ubuntu.</p>
<div class="packt_infobox">To save some money, both GCP (<a href="https://cloud.google.com/free/">https://cloud.google.com/free/</a>) and AWS (<a href="https://aws.amazon.com/free/">https://aws.amazon.com/free/</a>) offer free tiers and trial offers for their cloud infrastructure. It's worth using these free trials for learning Kubernetes, if possible.<br/>
<br/>
Most of the concepts and examples in this book should work on any installation of a Kubernetes cluster. To get more information on other platform setups, refer to the Kubernetes getting started page, which will help you pick the right solution for your cluster: <span class="URLPACKT"><a href="http://kubernetes.io/docs/getting-started-guides/">http://kubernetes.io/docs/getting-started-guides/</a>.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running Kubernetes on GCE</h1>
                </header>
            
            <article>
                
<p>We have a few options for setting up the prerequisites for our development environment. While we'll use a Linux client on our local machine in this example, you can also use the Google Cloud Shell to simplify your dependencies and setup. You can check out that documentation at <a href="https://cloud.google.com/shell/docs/">https://cloud.google.com/shell/docs/</a>, and then jump down to the <kbd>gcloud auth login</kbd> portion of the tutorial.</p>
<p>Getting back to the local installation, let's make sure that our environment is properly set up before we install Kubernetes. Start by updating the packages:</p>
<pre><strong>$ sudo apt-get update</strong></pre>
<p>You should see something similar to the following output:</p>
<pre><strong>$ sudo apt update</strong><br/><strong>[sudo] password for user:</strong><br/><strong>Hit:1 http://archive.canonical.com/ubuntu xenial InRelease</strong><br/><strong>Ign:2 http://dl.google.com/linux/chrome/deb stable InRelease</strong><br/><strong>Hit:3 http://archive.ubuntu.com/ubuntu xenial InRelease</strong><br/><strong>Get:4 http://security.ubuntu.com/ubuntu xenial-security InRelease [102 kB]</strong><br/><strong>Ign:5 http://dell.archive.canonical.com/updates xenial-dell-dino2-mlk InRelease</strong><br/><strong>Hit:6 http://ppa.launchpad.net/webupd8team/sublime-text-3/ubuntu xenial InRelease</strong><br/><strong>Hit:7 https://download.sublimetext.com apt/stable/ InRelease</strong><br/><strong>Hit:8 http://dl.google.com/linux/chrome/deb stable Release</strong><br/><strong>Get:9 http://archive.ubuntu.com/ubuntu xenial-updates InRelease [102 kB]</strong><br/><strong>Hit:10 https://apt.dockerproject.org/repo ubuntu-xenial InRelease</strong><br/><strong>Hit:11 https://deb.nodesource.com/node_7.x xenial InRelease</strong><br/><strong>Hit:12 https://download.docker.com/linux/ubuntu xenial InRelease</strong><br/><strong>Ign:13 http://dell.archive.canonical.com/updates xenial-dell InRelease</strong><br/><strong>&lt;SNIPPED...&gt;</strong><br/><strong>Fetched 1,593 kB in 1s (1,081 kB/s)</strong><br/><strong>Reading package lists... Done</strong><br/><strong>Building dependency tree</strong><br/><strong>Reading state information... Done</strong><br/><strong>120 packages can be upgraded. Run 'apt list --upgradable' to see them.</strong><br/><strong>$</strong></pre>
<p>Install Python and <kbd>curl</kbd> if they are not present:</p>
<pre><strong>$ sudo apt-get install python</strong><br/><strong>$ sudo apt-get install curl</strong></pre>
<p>Install the <kbd>gcloud</kbd> SDK:</p>
<pre><strong>$ curl https://sdk.cloud.google.com | bash</strong></pre>
<div class="packt_tip">We will need to start a new shell before <kbd>gcloud</kbd> is on our path.</div>
<p>Configure your GCP account information. This should automatically open a browser, from where we can log in to our Google Cloud account and authorize the SDK:</p>
<pre><strong>$ gcloud auth login</strong></pre>
<div class="packt_tip">If you have problems with login or want to use another browser, you can optionally use the <kbd>--no-launch-browser</kbd> command. Copy and paste the URL to the machine and/or browser of your choice. Log in with your Google Cloud credentials and click <span class="packt_screen">Allow</span> on the permissions page. Finally, you should receive an authorization code that you can copy and paste back into the shell, where the prompt will be waiting.</div>
<p>A default project should be set, but we can verify this with the following command:</p>
<pre><strong>$ gcloud config list project</strong></pre>
<p>We can modify this and set a new default project with the following command. Make sure to use project ID and not project name, as follows:</p>
<pre><strong>$ gcloud config set project &lt;PROJECT ID&gt;</strong></pre>
<div class="packt_tip">We can find our project ID in the console at the following URL: <a href="https://console.developers.google.com/project"><span class="URLPACKT">https://console.developers.google.com/project</span></a>. Alternatively, we can list the active projects with <kbd>$ gcloud alpha projects list</kbd>.</div>
<p>You can turn on API access to your project at this point in the GCP dashboard, <a href="https://console.developers.google.com/project">https://console.developers.google.com/project</a>, or the Kubernetes script will prompt you to do so in the next section:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/bca0be7b-7eeb-4967-9f75-6e95d2d658c3.png" style="width:22.33em;height:21.92em;" width="391" height="384"/></div>
<p>Next, you want to change to a directory when you can install the Kubernetes binaries. We'll set that up and then download the software:</p>
<pre><strong>$ mkdir ~/code/gsw-k8s-3</strong><br/><strong>$ cd ~/code/gsw-k8s-3</strong></pre>
<p>Installing the latest Kubernetes version is done in a single step, as follows:</p>
<pre><strong>$ curl -sS https://get.k8s.io | bash</strong></pre>
<p>It may take a minute or two to download Kubernetes depending on your connection speed. Earlier versions would automatically call the <kbd>kube-up.sh</kbd> script and start building our cluster. In version 1.5, we will need to call <span>the</span> <kbd>kube-up.sh</kbd> <span>script ourselves to launch the cluster. </span>By default, it will use the Google Cloud and GCE:</p>
<pre><strong>$ kubernetes/cluster/kube-up.sh</strong></pre>
<p>If you get an error at this point due to missing components, you'll need to add a few pieces to your local Linux box. If you're running the Google Cloud Shell, or are utilizing a VM in GCP, you probably won't see this error:</p>
<pre><strong>$ kubernetes_install cluster/kube-up.sh... </strong><br/><strong>Starting cluster in us-central1-b using provider gce</strong><br/><strong>... calling verify-prereqs</strong><br/><strong>missing required gcloud component "alpha"</strong><br/><strong>missing required gcloud component "beta"</strong><br/><strong>$</strong></pre>
<p>You can see that these components are missing and are required for leveraging the <kbd>kube-up.sh script</kbd>:</p>
<div>
<pre><strong>$ gcloud components list</strong><br/><strong>Your current Cloud SDK version is: 193.0.0</strong><br/><strong>The latest available version is: 193.0.0</strong><br/><strong>┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────┐</strong><br/><strong>│ Components │</strong><br/><strong>├───────────────┬──────────────────────────────────────────────────────┬──────────────────────────┬───────────┤</strong><br/><strong>│ Status │ Name │ ID │ Size │</strong><br/><strong>├───────────────┼──────────────────────────────────────────────────────┼──────────────────────────┼───────────┤</strong><br/><strong>│ Not Installed │ App Engine Go Extensions │ app-engine-go │ 151.9 MiB │</strong><br/><strong>│ Not Installed │ Cloud Bigtable Command Line Tool │ cbt │ 4.5 MiB │</strong><br/><strong>│ Not Installed │ Cloud Bigtable Emulator │ bigtable │ 3.7 MiB │</strong><br/><strong>│ Not Installed │ Cloud Datalab Command Line Tool │ datalab │ &lt; 1 MiB │</strong><br/><strong>│ Not Installed │ Cloud Datastore Emulator │ cloud-datastore-emulator │ 17.9 MiB │</strong><br/><strong>│ Not Installed │ Cloud Datastore Emulator (Legacy) │ gcd-emulator │ 38.1 MiB │</strong><br/><strong>│ Not Installed │ Cloud Pub/Sub Emulator │ pubsub-emulator │ 33.4 MiB │</strong><br/><strong>│ Not Installed │ Emulator Reverse Proxy │ emulator-reverse-proxy │ 14.5 MiB │</strong><br/><strong>│ Not Installed │ Google Container Local Builder │ container-builder-local │ 3.8 MiB │</strong><br/><strong>│ Not Installed │ Google Container Registry's Docker credential helper │ docker-credential-gcr │ 3.3 MiB │</strong><br/><strong>│ Not Installed │ gcloud Alpha Commands │ alpha │ &lt; 1 MiB │</strong><br/><strong>│ Not Installed │ gcloud Beta Commands │ beta │ &lt; 1 MiB │</strong><br/><strong>│ Not Installed │ gcloud app Java Extensions │ app-engine-java │ 118.9 MiB │</strong><br/><strong>│ Not Installed │ gcloud app PHP Extensions │ app-engine-php │ │</strong><br/><strong>│ Not Installed │ gcloud app Python Extensions │ app-engine-python │ 6.2 MiB │</strong><br/><strong>│ Not Installed │ gcloud app Python Extensions (Extra Libraries) │ app-engine-python-extras │ 27.8 MiB │</strong><br/><strong>│ Not Installed │ kubectl │ kubectl │ 12.3 MiB │</strong><br/><strong>│ Installed │ BigQuery Command Line Tool │ bq │ &lt; 1 MiB │</strong><br/><strong>│ Installed │ Cloud SDK Core Libraries │ core │ 7.3 MiB │</strong><br/><strong>│ Installed │ Cloud Storage Command Line Tool │ gsutil │ 3.3 MiB │</strong><br/><strong>└───────────────┴──────────────────────────────────────────────────────┴──────────────────────────┴───────────┘</strong><br/><strong>To install or remove components at your current SDK version [193.0.0], run:</strong><br/><strong>  $ gcloud components install COMPONENT_ID</strong><br/><strong>  $ gcloud components remove COMPONENT_ID</strong><br/><strong>To update your SDK installation to the latest version [193.0.0], run:</strong><br/><strong>  $ gcloud components update</strong></pre></div>
<p>You can update the components by adding them to your shell:</p>
<pre><span><strong>$ gcloud components install alpha beta</strong><br/><strong>Your current Cloud SDK version is: 193.0.0</strong><br/><strong>Installing components from version: 193.0.0</strong><br/><strong>┌──────────────────────────────────────────────┐</strong><br/><strong>│ These components will be installed. │</strong><br/><strong>├───────────────────────┬────────────┬─────────┤</strong><br/><strong>│ Name │ Version │ Size │</strong><br/><strong>├───────────────────────┼────────────┼─────────┤</strong><br/><strong>│ gcloud Alpha Commands │ 2017.09.15 │ &lt; 1 MiB │</strong><br/><strong>│ gcloud Beta Commands │ 2017.09.15 │ &lt; 1 MiB │</strong><br/><strong>└───────────────────────┴────────────┴─────────┘</strong><br/><strong>For the latest full release notes, please visit:</strong><br/><strong>  https://cloud.google.com/sdk/release_notes</strong><br/><strong>Do you want to continue (Y/n)? y</strong><br/><strong>╔════════════════════════════════════════════════════════════╗</strong><br/><strong>╠═ Creating update staging area ═╣</strong><br/><strong>╠════════════════════════════════════════════════════════════╣</strong><br/><strong>╠═ Installing: gcloud Alpha Commands ═╣</strong><br/><strong>╠════════════════════════════════════════════════════════════╣</strong><br/><strong>╠═ Installing: gcloud Beta Commands ═╣</strong><br/><strong>╠════════════════════════════════════════════════════════════╣</strong><br/><strong>╠═ Creating backup and activating new installation ═╣</strong><br/><strong>╚════════════════════════════════════════════════════════════╝</strong><br/><strong>Performing post processing steps...done. </strong><br/><strong>Update done!</strong><br/></span></pre>
<p>After you run the <kbd>kube-up.sh</kbd> script, you will see quite a few lines roll past. Let's take a look at them one section at a time:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/9bce1223-359c-4702-b07b-f3725376f242.png" style="width:31.08em;height:8.67em;" width="577" height="161"/></div>
<div class="packt_figure packt_figref packt_infobox CDPAlignLeft CDPAlign">If your <kbd>gcloud</kbd> components are not up to date, you may be prompted to update them.</div>
<p>The preceding screenshot shows the checks for prerequisites, as well as making sure that all components are up to date. This is specific to each provider. In the case of GCE, it will verify that the SDK is installed and that all components are up to date. If not, you will see a prompt at this point to install or update:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/c277bd3e-da43-4520-803f-b125efcf6e5e.png" width="762" height="306"/></div>
<p>Now, the script is turning up the cluster. Again, this is specific to the provider. For GCE, it first checks to make sure that the SDK is configured for a default project and zone. If they are set, you'll see those in the output:</p>
<div class="packt_tip">You may see an output that the bucket for storage hasn't been created. That's normal! The creation script will go ahead and create it.</div>
<div>
<pre><span>BucketNotFoundException: 404 gs://kubernetes-staging-22caacf417 bucket does not exist.</span></pre></div>
<p>Next, it uploads the server binaries to Google Cloud storage, as seen in the <span class="packt_screen">Creating gs:...</span> lines:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/dc10e65f-1d28-48dc-832f-000a511b0f70.png" width="759" height="406"/></div>
<p>It then checks for any pieces of a cluster already running. Then, we finally start creating the cluster. In the output in the preceding screenshot, we can see it creating the master server, IP address, and appropriate firewall configurations for the cluster:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/86efdb69-7538-4f21-80db-9c14d13bd6dd.png" style="width:40.42em;height:35.83em;" width="734" height="651"/></div>
<p>Finally, it creates the minions or nodes for our cluster. This is where our container workloads will actually run. It will continually loop and wait while all the minions start up. By default, the cluster will have four nodes (minions), but K8s supports having more than 1,000 (and soon beyond). We will come back to scaling the nodes later on in this book:</p>
<pre><strong>Attempt 1 to create kubernetes-minion-template</strong><br/><strong>WARNING: You have selected a disk size of under [200GB]. This may result in poor I/O performance. For more information, see: https://developers.google.com/compute/docs/disks#performance.</strong><br/><strong>Created [https://www.googleapis.com/compute/v1/projects/gsw-k8s-3/global/instanceTemplates/kubernetes-minion-template].</strong><br/><strong>NAME MACHINE_TYPE PREEMPTIBLE CREATION_TIMESTAMP</strong><br/><strong>kubernetes-minion-template n1-standard-2 2018-03-17T11:14:04.186-07:00</strong><br/><strong>Created [https://www.googleapis.com/compute/v1/projects/gsw-k8s-3/zones/us-central1-b/instanceGroupManagers/kubernetes-minion-group].</strong><br/><strong>NAME LOCATION SCOPE BASE_INSTANCE_NAME SIZE TARGET_SIZE INSTANCE_TEMPLATE AUTOSCALED</strong><br/><strong>kubernetes-minion-group us-central1-b zone kubernetes-minion-group 0 3 kubernetes-minion-template no</strong><br/><strong>Waiting for group to become stable, current operations: creating: 3</strong><br/><strong>Group is stable</strong><br/><strong>INSTANCE_GROUPS=kubernetes-minion-group</strong><br/><strong>NODE_NAMES=kubernetes-minion-group-176g kubernetes-minion-group-s9qw kubernetes-minion-group-tr7r</strong><br/><strong>Trying to find master named 'kubernetes-master'</strong><br/><strong>Looking for address 'kubernetes-master-ip'</strong><br/><strong>Using master: kubernetes-master (external IP: 104.155.172.179)</strong><br/><strong>Waiting up to 300 seconds for cluster initialization.</strong></pre>
<p>Now that everything is created, the cluster is initialized and started. Assuming that everything goes well, we will get an IP address for the master:</p>
<pre><strong>... calling validate-cluster</strong><br/><strong>Validating gce cluster, MULTIZONE=</strong><br/><strong>Project: gsw-k8s-3</strong><br/><strong>Network Project: gsw-k8s-3</strong><br/><strong>Zone: us-central1-b</strong><br/><strong>No resources found.</strong><br/><strong>Waiting for 4 ready nodes. 0 ready nodes, 0 registered. Retrying.</strong><br/><strong>No resources found.</strong><br/><strong>Waiting for 4 ready nodes. 0 ready nodes, 0 registered. Retrying.</strong><br/><strong>Waiting for 4 ready nodes. 0 ready nodes, 1 registered. Retrying.</strong><br/><strong>Waiting for 4 ready nodes. 0 ready nodes, 4 registered. Retrying.</strong><br/><strong>Found 4 node(s).</strong><br/><strong>NAME STATUS ROLES AGE VERSION</strong><br/><strong>kubernetes-master Ready,SchedulingDisabled &lt;none&gt; 32s v1.9.4</strong><br/><strong>kubernetes-minion-group-176g Ready &lt;none&gt; 25s v1.9.4</strong><br/><strong>kubernetes-minion-group-s9qw Ready &lt;none&gt; 25s v1.9.4</strong><br/><strong>kubernetes-minion-group-tr7r Ready &lt;none&gt; 35s v1.9.4</strong><br/><strong>Validate output:</strong><br/><strong>NAME STATUS MESSAGE ERROR</strong><br/><strong>etcd-1 Healthy {"health": "true"}</strong><br/><strong>scheduler Healthy ok</strong><br/><strong>controller-manager Healthy ok</strong><br/><strong>etcd-0 Healthy {"health": "true"}</strong><br/><strong>Cluster validation succeeded</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Also, note that configuration along with the cluster management credentials are stored in <kbd>home/&lt;Username&gt;/.kube/config</kbd>.</p>
<p>Then, the script will validate the cluster. At this point, we are no longer running provider-specific code. The validation script will query the cluster via the <kbd>kubectl.sh</kbd> script. This is the central script for managing our cluster. In this case, it checks the number of minions found, registered, and in a ready state. It loops through, giving the cluster up to 10 minutes to finish initialization.</p>
<p>After a successful startup, a summary of the minions and the cluster component health is printed on the screen:</p>
<pre><strong>Done, listing cluster services:</strong><br/><strong>Kubernetes master is running at https://104.155.172.179</strong><br/><strong>GLBCDefaultBackend is running at https://104.155.172.179/api/v1/namespaces/kube-system/services/default-http-backend:http/proxy</strong><br/><strong>Heapster is running at https://104.155.172.179/api/v1/namespaces/kube-system/services/heapster/proxy</strong><br/><strong>KubeDNS is running at https://104.155.172.179/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</strong><br/><strong>kubernetes-dashboard is running at https://104.155.172.179/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy</strong><br/><strong>Metrics-server is running at https://104.155.172.179/api/v1/namespaces/kube-system/services/https:metrics-server:/proxy</strong><br/><strong>Grafana is running at https://104.155.172.179/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy</strong><br/><strong>InfluxDB is running at https://104.155.172.179/api/v1/namespaces/kube-system/services/monitoring-influxdb:http/proxy</strong><br/><strong><span>To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.</span></strong></pre>
<p>Finally, a <kbd>kubectl cluster-info</kbd> command is run, which outputs the URL for the master services, including DNS, UI, and monitoring. Let's take a look at some of these components.</p>
<p>If you'd like to get further debugging and/or diagnose cluster problems, you can use <kbd>kubectl cluster-info dump</kbd> to see what's going on with your cluster. Additionally, if you need to pause and take a break and want to conserve your free hours, you can log into the GUI and set the <kbd>kubernetes-minion-group</kbd> instance group to zero, which will remove all of the instances. The pencil will edit the group for you; set it to zero. Don't forget to set it back to three if you want to pick up again! </p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/e7a95be3-d56c-4796-be5a-d8174fcb7028.png" width="709" height="259"/></div>
<p>You can simply stop the manager as well. You'll need to click the stop button to shut it down:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/9f1c5f60-568c-4c18-aedf-532a60dddd42.png" width="1043" height="334"/></div>
<p>If you'd like to start the cluster up again, start the servers again to keep going. They'll need some time to start up and connect to each other.</p>
<p>If you want to work on more than one cluster at a time or you want to use a different name than the default, see the <kbd>&lt;kubernetes&gt;/cluster/gce/config-default.sh</kbd> file for more fine-grained configuration of your cluster.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Kubernetes UI</h1>
                </header>
            
            <article>
                
<p>Since Kubernetes v1.3.x, you can no longer authenticate through public IP addresses to the GUI. To get around this, we'll use the <kbd>kubectl proxy</kbd> command. First, grab the token from the configuration command, and then we'll use it to launch a local proxy version of the UI:</p>
<pre><strong>$ kubectl config view |grep token</strong><br/><strong> token: RvoYTIn4rExi1bNRzk56g0PU0srZbzOf</strong><br/><strong>$ kubectl proxy --port=8001</strong></pre>
<p>Open a browser and enter the following URL: <kbd><span class="URLPACKT">https://localhost/ui/</span></kbd><span class="URLPACKT">.</span></p>
<div class="packt_tip">You can also type these commands to open a browser window automatically if you're on macOS: <kbd>$ open https://localhost/ui/</kbd> <span>or </span><kbd>$ xdg-open https://localhost/ui</kbd> <span>if you're on Linux.</span></div>
<p>The certificate is self-signed by default, so you'll need to ignore the warnings in your browser before proceeding. After this, we will see a login dialog:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/5c4da402-e2f2-4f0a-b72f-101788aae39f.png" style="width:32.25em;height:28.08em;" width="648" height="565"/></div>
<p>At this login dialog, you'll need to input the token that you grabbed in the aforementioned command.</p>
<div class="packt_tip">This is where we use the credentials listed during the K8s installation. We can find them at any time by simply using the <kbd>config</kbd> command <kbd>$ kubectl config view</kbd>.</div>
<p>Use the <strong><span class="packt_screen">Token</span></strong> option and log in to your cluster:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/080257e6-6645-4639-9997-14b8833b5c09.png" style="width:41.50em;height:33.08em;" width="900" height="717"/></div>
<p>Now that we have entered our token, you should see a dashboard like the one in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/bf003d6e-6874-4688-9547-f145566721f5.png" width="1737" height="853"/></div>
<p>The main dashboard takes us to a page with not much display at first. There is a link to deploy a containerized app that will take you to a GUI for deployment. This GUI can be a very easy way to get started deploying apps without worrying about the YAML syntax for Kubernetes. However, as your use of containers matures, it's a good practice to use the YAML definitions that are checked in to source control.</p>
<p>If you click on the <span class="packt_screen"><strong>Nodes</strong></span> link on the left-hand side menu, you will see some metrics on the current cluster nodes:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="EmailPACKT"><img src="Images/6012dc3f-9574-4e15-b021-880e9fe99bed.png" style="width:49.58em;height:33.83em;" width="837" height="570"/></span></div>
<p>At the top, we can see an aggregate of the CPU and memory use followed by a listing of our cluster nodes. Clicking on one of the nodes will take us to a page with detailed information about that node, its health, and various metrics.</p>
<p>The Kubernetes UI has a lot of other views that will become more useful as we start launching real applications and adding configurations to the cluster.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Grafana</h1>
                </header>
            
            <article>
                
<p class="CDPAlignLeft CDPAlign">Another service installed by default is Grafana. This tool will give us a dashboard to view metrics on the cluster nodes. We can access it using the following syntax in a browser:</p>
<pre class="CDPAlignLeft CDPAlign">https://localhost/api/v1/proxy/namespaces/kube-system/services/monitoring-grafana</pre>
<p class="CDPAlignLeft CDPAlign">The Grafana dashboard should look like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/5b4c0b74-8e2e-4589-91b1-d950b7f7b873.png" width="1999" height="1339"/></div>
<p>From the main page, click on the <span class="packt_screen">Home</span> drop-down and select <span class="packt_screen">Cluster</span>. Here, Kubernetes is actually running a number of services. Heapster is used to collect the resource usage on the pods and nodes, and stores the information in InfluxDB. The results, such as CPU and memory usage, are what we see in the Grafana UI. We will explore this in depth in <a href="da3af5da-0ef5-4aa7-9652-2aed6b8c709e.xhtml"><span class="ChapterrefPACKT">Chapter</span> <span class="ChapterrefPACKT">8</span></a>, <em>Monitoring and Logging</em>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Command line</h1>
                </header>
            
            <article>
                
<p>The <kbd>kubectl</kbd> script has commands for exploring our cluster and the workloads running on it. You can find it in the <kbd>/kubernetes/client/bin</kbd> folder. We will be using this command throughout the book, so let's take a second to set up our environment. We can do so by putting the binaries folder on our <kbd>PATH</kbd>, in the following manner:</p>
<pre><strong>$ </strong><strong>export PATH=$PATH:/&lt;Path where you downloaded K8s&gt;/kubernetes/client/bin<br/>$ chmod +x /&lt;Path where you downloaded K8s&gt;/kubernetes/client/bin</strong></pre>
<div class="packt_tip">You may choose to download the <kbd>kubernetes</kbd> folder outside your home folder, so modify the preceding command as appropriate. It is also a good idea to make the changes permanent by adding the <kbd>export</kbd> command to the end of your <kbd>.bashrc</kbd> file in your home directory.</div>
<p>Now that we have <kbd>kubectl</kbd> on our path, we can start working with it. It has quite a few commands. Since we have not spun up any applications yet, most of these commands will not be very interesting. However, we can explore two commands right away.</p>
<p>First, we have already seen the <kbd>cluster-info</kbd> command during initialization, but we can run it again at any time with the following command:</p>
<pre><strong>$ kubectl cluster-info</strong></pre>
<p>Another useful command is <kbd>get</kbd>. It can be used to see currently running services, pods, replication controllers, and a lot more. Here are the three examples that are useful right out of the gate:</p>
<ul>
<li>Lists the nodes in our cluster:</li>
</ul>
<pre>    <strong>$ kubectl get nodes</strong></pre>
<ul>
<li>Lists cluster events:</li>
</ul>
<pre>    <strong>$ kubectl get events</strong></pre>
<ul>
<li>Finally, we can see any services that are running in the cluster, as follows:</li>
</ul>
<pre>    <strong>$ kubectl get services</strong></pre>
<p>To start with, we will only see one service, named <kbd>kubernetes</kbd>. This service is the core API server for the cluster.</p>
<p>For any of the preceding commands, you can always add a <kbd>-h</kbd> flag on the end to understand the intended usage.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Services running on the master</h1>
                </header>
            
            <article>
                
<p>Let's dig a little bit deeper into our new cluster and its core services. By default, machines are named with the <kbd>kubernetes-</kbd> prefix. We can modify this using <kbd>$KUBE_GCE_INSTANCE_PREFIX</kbd> before a cluster is spun up. For the cluster we just started, the master should be named <kbd>kubernetes-master</kbd>. We can use the <kbd>gcloud</kbd> command-line utility to SSH into the machine. The following command will start an SSH session with the master node. Be sure to substitute your project ID and zone to match your environment:</p>
<pre><strong>$ gcloud compute ssh --zone "&lt;your gce zone&gt;" "kubernetes-master"<br/></strong><strong><br/>$ gcloud compute ssh --zone "us-central1-b" "kubernetes-master"<br/>Warning: Permanently added 'compute.5419404412212490753' (RSA) to the list of known hosts.<br/><br/>Welcome to Kubernetes v1.9.4!<br/><br/>You can find documentation for Kubernetes at:<br/>  http://docs.kubernetes.io/<br/><br/>The source for this release can be found at:<br/>  /home/kubernetes/kubernetes-src.tar.gz<br/>Or you can download it at:<br/>  https://storage.googleapis.com/kubernetes-release/release/v1.9.4/kubernetes-src.tar.gz<br/><br/>It is based on the Kubernetes source at:<br/>  https://github.com/kubernetes/kubernetes/tree/v1.9.4<br/><br/>For Kubernetes copyright and licensing information, see:<br/>  /home/kubernetes/LICENSES<br/><br/>jesse@kubernetes-master ~ $ <br/></strong></pre>
<div class="packt_tip">If you have trouble with SSH via the Google Cloud CLI, you can use the console, which has a built-in SSH client. Simply go to the <span class="packt_screen">VM instances details</span> page and you'll see an <span class="packt_screen">SSH</span> option as a column in the <kbd>kubernetes-master</kbd> listing. Alternatively, the VM instance details page has the SSH option at the top.</div>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/15ca2d54-f6e8-4982-981a-3e6b5c05ae31.png" width="761" height="628"/></div>
<p>Once we are logged in, we should get a standard shell prompt. Let's run the <kbd>docker</kbd> command that filters for <kbd>Image</kbd> and <kbd>Status</kbd>:</p>
<pre><strong>$ docker container ls --format 'table {{.Image}}\t{{.Status}}' </strong></pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/5c649932-5aca-49e5-8f55-1db402052a08.png" width="897" height="438"/></div>
<p>Even though we have not deployed any applications on Kubernetes yet, we can note that there are several containers already running. The following is a brief description of each container:</p>
<ul>
<li><kbd>fluentd-gcp</kbd>: This container collects and sends the cluster logs file to the Google Cloud Logging service.</li>
<li><kbd>node-problem-detector</kbd>: This container is a daemon that runs on every node and currently detects issues at the hardware and kernel layer.</li>
<li><kbd>rescheduler</kbd>: This is another add-on container that makes sure critical components are always running. In cases of low resource availability, it may even remove less critical pods to make room.</li>
<li><kbd>glbc</kbd>: This is another Kubernetes add-on container that provides Google Cloud Layer 7 load balancing using the new Ingress capability.</li>
<li><kbd>kube-addon-manager</kbd>: This component is core to the extension of Kubernetes through various add-ons. It also periodically applies any changes to the <kbd>/etc/kubernetes/addons</kbd> directory.</li>
<li><kbd>etcd-empty-dir-cleanup</kbd>: A utility to clean up empty keys in <kbd>etcd</kbd>.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<ul>
<li><kbd>kube-controller-manager</kbd>: This is a controller manager that controls a variety of cluster functions, ensuring accurate and up-to-date replication is one of its vital roles. Additionally, it monitors, manages, and discovers new nodes. Finally, it manages and updates service endpoints.</li>
<li><kbd>kube-apiserver</kbd>: This container runs the API server. As we explored in the Swagger interface, this RESTful API allows us to create, query, update, and remove various components of our Kubernetes cluster.</li>
<li><kbd>kube-scheduler</kbd>: This scheduler takes unscheduled pods and binds them to nodes based on the current scheduling algorithm.</li>
<li><kbd>etcd</kbd>: This runs the <kbd>etcd</kbd> software built by CoreOS, and it is a distributed and consistent key-value store. This is where the Kubernetes cluster state is stored, updated, and retrieved by various components of K8s.</li>
<li><kbd>pause</kbd>: This container is often referred to as the pod infrastructure container and is used to set up and hold the networking namespace and resource limits for each pod.</li>
</ul>
<div class="packt_infobox">I omitted the <kbd>amd64</kbd> for many of these names to make this more generic. The purpose of the pods remains the same.</div>
<p>To exit the SSH session, simply type <kbd>exit</kbd> at the prompt.</p>
<div class="packt_infobox">In the next chapter, we will also show how a few of these services work together in the first image, <span><em>Kubernetes core architecture</em>.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Services running on the minions</h1>
                </header>
            
            <article>
                
<p>We could SSH to one of the minions, but since Kubernetes schedules workloads across the cluster, we would not see all the containers on a single minion. However, we can look at the pods running on all the minions using the <kbd>kubectl</kbd> command:</p>
<pre><strong>$ kubectl get pods<br/>No resources found.</strong></pre>
<p>Since we have not started any applications on the cluster yet, we don't see any pods. However, there are actually several system pods running pieces of the Kubernetes infrastructure. We can see these pods by specifying the <kbd>kube-system</kbd> namespace. We will explore namespaces and their significance later, but for now, the <kbd>--namespace=kube-system</kbd> command can be used to look at these K8s system resources, as follows:</p>
<pre><strong>$ kubectl get pods --namespace=kube-system<br/>jesse@kubernetes-master ~ $ kubectl get pods --namespace=kube-system<br/>NAME READY STATUS RESTARTS AGE<br/>etcd-server-events-kubernetes-master 1/1 Running 0 50m<br/>etcd-server-kubernetes-master 1/1 Running 0 50m<br/>event-exporter-v0.1.7-64464bff45-rg88v 1/1 Running 0 51m<br/>fluentd-gcp-v2.0.10-c4ptt 1/1 Running 0 50m<br/>fluentd-gcp-v2.0.10-d9c5z 1/1 Running 0 50m<br/>fluentd-gcp-v2.0.10-ztdzs 1/1 Running 0 51m<br/>fluentd-gcp-v2.0.10-zxx6k 1/1 Running 0 50m<br/>heapster-v1.5.0-584689c78d-z9blq 4/4 Running 0 50m<br/>kube-addon-manager-kubernetes-master 1/1 Running 0 50m<br/>kube-apiserver-kubernetes-master 1/1 Running 0 50m<br/>kube-controller-manager-kubernetes-master 1/1 Running 0 50m<br/>kube-dns-774d5484cc-gcgdx 3/3 Running 0 51m<br/>kube-dns-774d5484cc-hgm9r 3/3 Running 0 50m<br/>kube-dns-autoscaler-69c5cbdcdd-8hj5j 1/1 Running 0 51m<br/>kube-proxy-kubernetes-minion-group-012f 1/1 Running 0 50m<br/>kube-proxy-kubernetes-minion-group-699m 1/1 Running 0 50m<br/>kube-proxy-kubernetes-minion-group-sj9r 1/1 Running 0 50m<br/>kube-scheduler-kubernetes-master 1/1 Running 0 50m<br/>kubernetes-dashboard-74f855c8c6-v4f6x 1/1 Running 0 51m<br/>l7-default-backend-57856c5f55-2lz6w 1/1 Running 0 51m<br/>l7-lb-controller-v0.9.7-kubernetes-master 1/1 Running 0 50m<br/>metrics-server-v0.2.1-7f8dd98c8f-v9b4c 2/2 Running 0 50m<br/>monitoring-influxdb-grafana-v4-554f5d97-l7q4k 2/2 Running 0 51m<br/>rescheduler-v0.3.1-kubernetes-master 1/1 Running 0 50m</strong></pre>
<p>The first six lines should look familiar. Some of these are the services we saw running on the master, and we will see pieces of these on the nodes. There are a few additional services we have not seen yet. The <kbd>kube-dns</kbd> option provides the DNS and service discovery plumbing, <kbd>kubernetes-dashboard-xxxx</kbd> is the user interface for Kubernetes, <kbd>l7-default-backend-xxxx</kbd> provides the default load balancing backend for the new layer-7 load balancing capability, and <kbd>heapster-v1.2.0-xxxx</kbd><span> </span>and <kbd>monitoring-influx-grafana</kbd> provide the Heapster database and user interface to monitor resource usage across the cluster.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Finally, <kbd>kube-proxy-kubernetes-minion-group-xxxx</kbd>  is the proxy, which directs traffic to the proper backing services and pods running on our cluster. The <kbd>kube-apiserver</kbd> validates and configures data for the API objects, which include services, replication controllers, pods, and other Kubernetes objects. The <kbd>rescheduler</kbd> guarantees the scheduling of critical system add-ons, given that the cluster has enough available resources.</p>
<p>If we did SSH into a random minion, we would see several containers that run across a few of these pods. A sample might look like the following:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/ec7f9677-b44e-4b66-b529-68b35753f39c.png" width="778" height="305"/></div>
<p>Again, we saw a similar lineup of services on the master. The services we did not see on the master include the following:</p>
<ul>
<li><kbd><span>kube</span>dns</kbd>: This container monitors the service and endpoint resources in Kubernetes and synchronizes any changes to DNS lookups.</li>
<li><kbd>kube-dnsmasq</kbd>: This is another container that provides DNS caching.</li>
<li><kbd>dnsmasq-metrics</kbd>: This provides metric reporting for DNS services in cluster.</li>
<li><kbd>l7-defaultbackend</kbd>: This is the default backend for handling the GCE L7 load balancer and Ingress.</li>
<li><kbd>kube-proxy</kbd>: This is the network and service proxy for your cluster. This component makes sure that service traffic is directed to wherever your workloads are running on the cluster. We will explore this in more depth later in this book.</li>
<li><kbd>heapster</kbd>: This container is for monitoring and analytics.</li>
<li><kbd>addon-resizer</kbd>: This cluster utility is for scaling containers.</li>
</ul>
<ul>
<li><kbd>heapster_grafana</kbd>: This tracks resource usage and monitoring.</li>
<li><kbd>heapster_influxdb</kbd>: This time series database is for Heapster data.</li>
<li><kbd>cluster-proportional-autoscaler</kbd>: This c<span>luster utility is for scaling containers in proportion to the cluster size.</span></li>
<li><kbd>exechealthz</kbd>: This performs health checks on the pods.</li>
</ul>
<div class="packt_infobox">Again, I have omitted the <kbd>amd64</kbd> for many of these names to make this more generic. The purpose of the pods remains the same.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tearing down a cluster</h1>
                </header>
            
            <article>
                
<p>Alright, this is our first cluster on GCE, but let's explore some other providers. To keep things simple, we need to remove the one we just created on GCE. We can tear down the cluster with one simple command:</p>
<pre><strong>$ cluster/kube-down.sh</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with other providers</h1>
                </header>
            
            <article>
                
<p>By default, Kubernetes uses the GCE provider for Google Cloud. In order to use other cloud providers, we can explore a rapidly expanding tool set of different options. Let's use AWS for this example, where we have two main options: kops (<a href="https://github.com/kubernetes/kops">https://github.com/kubernetes/kops</a>) and kube-aws (<a href="https://github.com/kubernetes-incubator/kube-aws">https://github.com/kubernetes-incubator/kube-aws</a>). For reference, the following <kbd>KUBERNETES_PROVIDER</kbd> are listed in this table:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td style="width: 242px">
<p><strong>Provider</strong></p>
</td>
<td style="width: 211px">
<p><strong>KUBERNETES_PROVIDER value</strong></p>
</td>
<td style="width: 264px">
<p><strong>Type</strong></p>
</td>
</tr>
<tr>
<td>
<p>Google Compute Engine</p>
</td>
<td style="width: 211px">
<p><kbd>gce</kbd></p>
</td>
<td style="width: 264px">
<p>Public cloud</p>
</td>
</tr>
<tr>
<td>
<p>Google Container Engine</p>
</td>
<td style="width: 211px">
<p><kbd>gke</kbd></p>
</td>
<td style="width: 264px">
<p>Public cloud</p>
</td>
</tr>
<tr>
<td>
<p>Amazon Web Services</p>
</td>
<td style="width: 211px">
<p><kbd>aws</kbd></p>
</td>
<td style="width: 264px">
<p>Public cloud</p>
</td>
</tr>
<tr>
<td>
<p>Microsoft Azure</p>
</td>
<td style="width: 211px">
<p><kbd>azure</kbd></p>
</td>
<td style="width: 264px">
<p>Public cloud</p>
</td>
</tr>
<tr>
<td>
<p>Hashicorp vagrant</p>
</td>
<td style="width: 211px">
<p><kbd>vagrant</kbd></p>
</td>
<td style="width: 264px">
<p>Virtual development environment</p>
</td>
</tr>
<tr>
<td>
<p>VMware vSphere</p>
</td>
<td style="width: 211px">
<p><kbd>vsphere</kbd></p>
</td>
<td style="width: 264px">
<p>Private cloud/on-premise virtualization</p>
</td>
</tr>
<tr>
<td>
<p><kbd>libvirt</kbd> running CoreOS</p>
</td>
<td style="width: 211px">
<p><kbd>libvirt-coreos</kbd></p>
</td>
<td style="width: 264px">
<p>Virtualization management tool</p>
</td>
</tr>
<tr>
<td>
<p>Canonical Juju (folks behind Ubuntu)</p>
</td>
<td style="width: 211px">
<p><kbd>juju</kbd></p>
</td>
<td style="width: 264px">
<p>OS service orchestration tool</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">CLI setup</h1>
                </header>
            
            <article>
                
<p>Let's try setting up the cluster on AWS. As a prerequisite, we need to have the AWS CLI installed and configured for our account. The AWS CLI installation and configuration documentation can be found at the following links:</p>
<ul>
<li>Installation documentation: <a href="http://docs.aws.amazon.com/cli/latest/userguide/installing.html#install-bundle-other-os"><span class="URLPACKT">http://docs.aws.amazon.com/cli/latest/userguide/installing.html#install-bundle-other-os</span></a></li>
<li>Configuration documentation: <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html"><span class="URLPACKT">http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html</span></a></li>
</ul>
<p>You'll also need to configure your credentials as recommended by AWS (refer to <a href="https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials">https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials</a>) in order to use kops. To get started, you'll need to first install the CLI tool (refer to <a href="https://github.com/kubernetes/kops/blob/master/docs/install.md">https://github.com/kubernetes/kops/blob/master/docs/install.md</a>). If you're running on Linux, you can install the tools as follows:</p>
<pre><strong>curl -Lo kops https://github.com/kubernetes/kops/releases/download/$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d '"' -f 4)/kops-darwin-amd64</strong><br/><strong>chmod +x ./kops</strong><br/><strong>sudo mv ./kops /usr/local/bin/</strong></pre>
<p>If you're installing this for macOS, you can use <kbd>brew update &amp;&amp; brew install kops</kbd> from the command-line Terminal. As a reminder, you'll need <kbd>kubectl</kbd> installed if you haven't already! Check the instructions in the preceding links to confirm the installation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">IAM setup</h1>
                </header>
            
            <article>
                
<p>In order for us to use kops, we'll need an IAM role created in AWS with the following permissions:</p>
<pre>AmazonEC2FullAccess<br/>AmazonRoute53FullAccess<br/>AmazonS3FullAccess<br/>IAMFullAccess<br/>AmazonVPCFullAccess</pre>
<p>Once you've created those pieces manually in the AWS GUI, you can run the following commands from your PC to set up permissions with the correct access:</p>
<pre class="mce-root"><strong>aws iam create-group --group-name kops<br/><br/>aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/AmazonEC2FullAccess --group-name kops</strong><br/><strong>aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/AmazonRoute53FullAccess --group-name kops</strong><br/><strong>aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/AmazonS3FullAccess --group-name kops</strong><br/><strong>aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/IAMFullAccess --group-name kops</strong><br/><strong>aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/AmazonVPCFullAccess --group-name kops<br/><br/>aws iam create-user --user-name kops<br/><br/>aws iam add-user-to-group --user-name kops --group-name kops<br/><br/>aws iam create-access-key --user-name kops<br/></strong></pre>
<p>In order to use this newly created kops user to interact with the kops tool, you need to copy down the <kbd>SecretAccessKey</kbd> and <kbd>AccessKeyID</kbd> from the output JSON, and then configure the AWS CLI as follows:</p>
<pre># configure the aws client to use your new IAM user<br/>aws configure # Use your new access and secret key here<br/>aws iam list-users # you should see a list of all your IAM users here<br/># Because "aws configure" doesn't export these vars for kops to use, we export them now<br/>export AWS_ACCESS_KEY_ID=$(aws configure get aws_access_key_id)<br/>export AWS_SECRET_ACCESS_KEY=$(aws configure get aws_secret_access_key)</pre>
<p>We're going to use a gossip-based cluster to bypass a kops configuration requirement of public DNS zones. This requires kops 1.6.2 or later, and allows you to create a locally registered cluster that requires a name ending in <kbd>.k8s.local</kbd>. More on that in a bit.</p>
<div class="packt_tip">If you'd like to explore how to purchase and set up publicly routable DNS  through a provider, you can review the available scenarios in the kops documentation here: <a href="https://github.com/kubernetes/kops/blob/master/docs/aws.md#configure-dns">https://github.com/kubernetes/kops/blob/master/docs/aws.md#configure-dns</a>.</div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cluster state storage</h1>
                </header>
            
            <article>
                
<p>Since we're building resources in the cloud using configuration management, we're going to need to store the representation of our cluster in a dedicated S3 bucket. This source of truth will allow us to maintain a single location for the configuration and state of our Kubernetes cluster. Please prepend your bucket name with a unique value.</p>
<div class="packt_tip">You'll need to have <kbd>kubectl</kbd>, <kbd>kops</kbd>, the <kbd>aws cli</kbd>, and IAM credentials set up for yourself at this point!</div>
<p>Be sure to create your bucket in the <kbd>us-east-1</kbd> region for now, as kops is currently opinionated as to where the bucket belongs:</p>
<pre><strong>aws s3api create-bucket \</strong><br/><strong> --bucket gsw-k8s-3-state-store \</strong><br/><strong> --region us-east-1</strong></pre>
<p>Let's go ahead and set up versioning as well, so you can roll your cluster back to previous states in case anything goes wrong. Behold the power of Infrastructure as Code!</p>
<pre><strong>aws s3api put-bucket-versioning --bucket gsw-k8s-3-state-store --versioning-configuration Status=Enabled</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating your cluster</h1>
                </header>
            
            <article>
                
<p>We'll go ahead and use the <kbd>.k8s.local</kbd> settings mentioned previously to simplify the DNS setup of the cluster. If you'd prefer, you can also use the name and state flags available within kops to avoid using environment variables. Let's prepare the local environment first:</p>
<pre><strong>$ export NAME=gswk8s3.k8s.local</strong><br/><strong>$ export KOPS_STATE_STORE=s3://gsw-k8s-3-state-store</strong><br/><strong>$ aws s3api create-bucket --bucket gsw-k8s-3-state-store --region us-east-1</strong><br/><strong>{</strong><br/><strong>  "Location": "/gsw-k8s-3-state-store"</strong><br/><strong>}</strong><br/><strong>$</strong></pre>
<p>Let's spin up our cluster in Ohio, and verify that we can see that region first:</p>
<pre><strong>$ aws ec2 describe-availability-zones --region us-east-2</strong><br/><strong>{</strong><br/><strong>  "AvailabilityZones": [</strong><br/><strong>  {</strong><br/><strong>  "State": "available", </strong><br/><strong>  "ZoneName": "us-east-2a", </strong><br/><strong>  "Messages": [], </strong><br/><strong>  "RegionName": "us-east-2"</strong><br/><strong>  }, </strong><br/><strong>  {</strong><br/><strong>  "State": "available", </strong><br/><strong>  "ZoneName": "us-east-2b", </strong><br/><strong>  "Messages": [], </strong><br/><strong>  "RegionName": "us-east-2"</strong><br/><strong>  }, </strong><br/><strong>  {</strong><br/><strong>  "State": "available", </strong><br/><strong>  "ZoneName": "us-east-2c", </strong><br/><strong>  "Messages": [], </strong><br/><strong>  "RegionName": "us-east-2"</strong><br/><strong>  }</strong><br/><strong>  ]</strong><br/><strong>}</strong></pre>
<p>Great! Let's make some Kubernetes. We're going to use the most basic kops cluster command available, though there are much more complex examples available in the documentation (<a href="https://github.com/kubernetes/kops/blob/master/docs/high_availability.md">https://github.com/kubernetes/kops/blob/master/docs/high_availability.md</a>):</p>
<pre><strong>kops create cluster --zones us-east-2a ${NAME}</strong></pre>
<p>With kops and generally with Kubernetes, everything is going to be created within <strong>Auto Scaling groups</strong> (<strong>ASGs</strong>).</p>
<div class="packt_tip">Read more about AWS autoscaling groups here—they're essential: <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/AutoScalingGroup.html">https://docs.aws.amazon.com/autoscaling/ec2/userguide/AutoScalingGroup.html</a>.</div>
<p>Once you run this command, you'll get a whole lot of configuration output in what we call a dry run format. This is similar to the Terraform idea of a Terraform plan, which lets you see what you're about to build in AWS and lets you edit the output accordingly.</p>
<p>At the end of the output, you'll see the following text, which gives you some basic suggestions on the next steps:</p>
<pre>Must specify --yes to apply changes<br/>Cluster configuration has been created.<br/><br/>Suggestions:<br/>* list clusters with: kops get cluster<br/>* edit this cluster with: kops edit cluster gwsk8s3.k8s.local<br/>* edit your node instance group: kops edit ig --name=gwsk8s3.k8s.local nodes<br/>* edit your master instance group: kops edit ig --name=gwsk8s3.k8s.local master-us-east-2a<br/><br/>Finally configure your cluster with: kops update cluster gwsk8s3.k8s.local --yes</pre>
<div class="mce-root packt_tip">If you don't have an SSH keypair in your <kbd>~/.ssh</kbd> directory, you'll need to create one. This article will lead you through the steps: <a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/">https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/</a>.</div>
<p>Once you've confirmed that you like the look of the output, you can create the cluster:</p>
<pre><strong>kops update cluster gwsk8s3.k8s.local --yes</strong></pre>
<p>This will give you a lot of output about cluster creation that you can follow along with:</p>
<pre><strong>I0320 21:37:34.761784 29197 apply_cluster.go:450] Gossip DNS: skipping DNS validation</strong><br/><strong>I0320 21:37:35.172971 29197 executor.go:91] Tasks: 0 done / 77 total; 30 can run</strong><br/><strong>I0320 21:37:36.045260 29197 vfs_castore.go:435] Issuing new certificate: "apiserver-aggregator-ca"</strong><br/><strong>I0320 21:37:36.070047 29197 vfs_castore.go:435] Issuing new certificate: "ca"</strong><br/><strong>I0320 21:37:36.727579 29197 executor.go:91] Tasks: 30 done / 77 total; 24 can run</strong><br/><strong>I0320 21:37:37.740018 29197 vfs_castore.go:435] Issuing new certificate: "apiserver-proxy-client"</strong><br/><strong>I0320 21:37:37.758789 29197 vfs_castore.go:435] Issuing new certificate: "kubecfg"</strong><br/><strong>I0320 21:37:37.830861 29197 vfs_castore.go:435] Issuing new certificate: "kube-controller-manager"</strong><br/><strong>I0320 21:37:37.928930 29197 vfs_castore.go:435] Issuing new certificate: "kubelet"</strong><br/><strong>I0320 21:37:37.940619 29197 vfs_castore.go:435] Issuing new certificate: "kops"</strong><br/><strong>I0320 21:37:38.095516 29197 vfs_castore.go:435] Issuing new certificate: "kubelet-api"</strong><br/><strong>I0320 21:37:38.124966 29197 vfs_castore.go:435] Issuing new certificate: "kube-proxy"</strong><br/><strong>I0320 21:37:38.274664 29197 vfs_castore.go:435] Issuing new certificate: "kube-scheduler"</strong><br/><strong>I0320 21:37:38.344367 29197 vfs_castore.go:435] Issuing new certificate: "apiserver-aggregator"</strong><br/><strong>I0320 21:37:38.784822 29197 executor.go:91] Tasks: 54 done / 77 total; 19 can run</strong><br/><strong>I0320 21:37:40.663441 29197 launchconfiguration.go:333] waiting for IAM instance profile "nodes.gswk8s3.k8s.local" to be ready</strong><br/><strong>I0320 21:37:40.889286 29197 launchconfiguration.go:333] waiting for IAM instance profile "masters.gswk8s3.k8s.local" to be ready</strong><br/><strong>I0320 21:37:51.302353 29197 executor.go:91] Tasks: 73 done / 77 total; 3 can run</strong><br/><strong>I0320 21:37:52.464204 29197 vfs_castore.go:435] Issuing new certificate: "master"</strong><br/><strong>I0320 21:37:52.644756 29197 executor.go:91] Tasks: 76 done / 77 total; 1 can run</strong><br/><strong>I0320 21:37:52.916042 29197 executor.go:91] Tasks: 77 done / 77 total; 0 can run</strong><br/><strong>I0320 21:37:53.360796 29197 update_cluster.go:248] Exporting kubecfg for cluster</strong><br/><strong>kops has set your kubectl context to gswk8s3.k8s.local</strong></pre>
<p>As with GCE, the setup activity will take a few minutes. It will stage files in <strong>S3</strong> and create the appropriate instances, <strong>Virtual Private Cloud</strong> (<strong>VPC</strong>), security groups, and so on in our AWS account. Then, the Kubernetes cluster will be set up and started. Once everything is finished and started, we should see some options on what comes next:</p>
<pre class="packt_figure CDPAlignLeft CDPAlign">Cluster is starting. It should be ready in a few minutes.<br/><br/>Suggestions:<br/> * validate cluster: kops validate cluster<br/> * list nodes: kubectl get nodes --show-labels<br/> * ssh to the master: ssh -i ~/.ssh/id_rsa admin@api.gswk8s3.k8s.local<br/>The admin user is specific to Debian. If not using Debian please use the appropriate user based on your OS.<br/> * read about installing addons: https://github.com/kubernetes/kops/blob/master/docs/addons.md</pre>
<p>You'll be able to see instances and security groups, and a VPC will be created for your cluster. The <kbd>kubectl</kbd> context will also be pointed at your new AWS cluster so that you can interact with it:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/72363a73-9f3d-4f9e-b610-d159caafa5f2.png" width="892" height="231"/></div>
<p>Once again, we will SSH into master. This time, we can use the native SSH client and the admin user as the AMI for Kubernetes in kops is Debian. We'll find the key files in <kbd>/home/&lt;username&gt;/.ssh</kbd>:</p>
<pre><strong>$ ssh -v -i /home/&lt;username&gt;/.ssh/&lt;your_id_rsa_file&gt; admin@&lt;Your master IP&gt;</strong></pre>
<p>If you have trouble with your SSH key, you can set it manually on the cluster by creating a secret, adding it to the cluster, and checking if the cluster requires a rolling update:</p>
<pre><strong>$ kops create secret --name gswk8s3.k8s.local sshpublickey admin -i ~/.ssh/id_rsa.pub</strong><br/><strong>$ kops update cluster --yes</strong><br/><strong>Using cluster from kubectl context: gswk8s3.k8s.local</strong><br/><strong>I0320 22:03:42.823049 31465 apply_cluster.go:450] Gossip DNS: skipping DNS validation</strong><br/><strong>I0320 22:03:43.220675 31465 executor.go:91] Tasks: 0 done / 77 total; 30 can run</strong><br/><strong>I0320 22:03:43.919989 31465 executor.go:91] Tasks: 30 done / 77 total; 24 can run</strong><br/><strong>I0320 22:03:44.343478 31465 executor.go:91] Tasks: 54 done / 77 total; 19 can run</strong><br/><strong>I0320 22:03:44.905293 31465 executor.go:91] Tasks: 73 done / 77 total; 3 can run</strong><br/><strong>I0320 22:03:45.385288 31465 executor.go:91] Tasks: 76 done / 77 total; 1 can run</strong><br/><strong>I0320 22:03:45.463711 31465 executor.go:91] Tasks: 77 done / 77 total; 0 can run</strong><br/><strong>I0320 22:03:45.675720 31465 update_cluster.go:248] Exporting kubecfg for cluster</strong><br/><strong>kops has set your kubectl context to gswk8s3.k8s.local</strong><br/><br/><strong>Cluster changes have been applied to the cloud.</strong><br/><br/><strong>Changes may require instances to restart: kops rolling-update cluster</strong><br/><br/><strong>$ kops rolling-update cluster --name gswk8s3.k8s.local</strong><br/><strong>NAME STATUS NEEDUPDATE READY MIN MAX NODES</strong><br/><strong>master-us-east-2a Ready 0 1 1 1 1</strong><br/><strong>nodes Ready 0 2 2 2 2</strong><br/><br/><strong>No rolling-update required.</strong><br/><strong>$</strong></pre>
<p>Once you've gotten into the cluster master, we can look at the containers. We'll use <kbd>s<span>udo docker ps --format '</span><span class="s2"><span class="hljs-string">table <span class="hljs-template-variable">{{.Image}}</span></span></span><span class="se"><span class="hljs-string">t</span></span><span class="s2"><span class="hljs-string"><span class="hljs-template-variable">{{.Status}}'</span></span></span></kbd> to explore the running containers. We should see the following:</p>
<pre class="packt_figure CDPAlignLeft CDPAlign"><strong>admin@ip-172-20-47-159:~$ sudo docker container ls --format 'table {{.Image}}\t{{.Status}}'</strong><br/><strong>IMAGE STATUS</strong><br/><strong>kope/dns-controller@sha256:97f80ad43ff833b254907a0341c7fe34748e007515004cf0da09727c5442f53b Up 29 minutes</strong><br/><strong>gcr.io/google_containers/pause-amd64:3.0 Up 29 minutes</strong><br/><strong>gcr.io/google_containers/kube-apiserver@sha256:71273b57d811654620dc7a0d22fd893d9852b6637616f8e7e3f4507c60ea7357 Up 30 minutes</strong><br/><strong>gcr.io/google_containers/etcd@sha256:19544a655157fb089b62d4dac02bbd095f82ca245dd5e31dd1684d175b109947 Up 30 minutes</strong><br/><strong>gcr.io/google_containers/kube-proxy@sha256:cc94b481f168bf96bd21cb576cfaa06c55807fcba8a6620b51850e1e30febeb4 Up 30 minutes</strong><br/><strong>gcr.io/google_containers/kube-controller-manager@sha256:5ca59252abaf231681f96d07c939e57a05799d1cf876447fe6c2e1469d582bde Up 30 minutes</strong><br/><strong>gcr.io/google_containers/etcd@sha256:19544a655157fb089b62d4dac02bbd095f82ca245dd5e31dd1684d175b109947 Up 30 minutes</strong><br/><strong>gcr.io/google_containers/kube-scheduler@sha256:46d215410a407b9b5a3500bf8b421778790f5123ff2f4364f99b352a2ba62940 Up 30 minutes</strong><br/><strong>gcr.io/google_containers/pause-amd64:3.0 Up 30 minutes</strong><br/><strong>gcr.io/google_containers/pause-amd64:3.0 Up 30 minutes</strong><br/><strong>gcr.io/google_containers/pause-amd64:3.0 Up 30 minutes</strong><br/><strong>gcr.io/google_containers/pause-amd64:3.0 Up 30 minutes</strong><br/><strong>gcr.io/google_containers/pause-amd64:3.0 Up 30 minutes</strong><br/><strong>gcr.io/google_containers/pause-amd64:3.0 Up 30 minutes</strong><br/><strong>protokube:1.8.1</strong></pre>
<p>We can see some of the same containers as our GCE cluster had. However, there are several missing. We can see the core Kubernetes components, but the <kbd>fluentd-gcp</kbd> service is missing, as well as some of the newer utilities such as<span> </span><kbd>node-problem-detector</kbd><span><span>,<span> </span><kbd>rescheduler</kbd><span>,<span> </span><kbd>glbc</kbd><span>,</span><span> </span><kbd>kube-addon-manager</kbd><span>, and</span><span> </span><kbd>etcd-empty-dir-cleanup</kbd><span>. This reflects some of the subtle differences in the <kbd>kube-up</kbd> script between various public cloud providers. This is ultimately decided by the efforts of the large Kubernetes open-source community, but GCP often has many of the latest features first.</span></span></span></span></p>
<p>You also have a command that allows you to check on the state of the cluster in <kbd>kops validate cluster</kbd>, which allows you to make sure that the cluster is working as expected. There's also a lot of handy modes that kops provides that allow you to do various things with the output, provisioners, and configuration of the cluster.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Other modes</h1>
                </header>
            
            <article>
                
<p>There are various other modes to take into consideration, including the following:</p>
<ul>
<li><strong>Build a terraform model</strong>: <kbd>--target=terraform</kbd>. The terraform model will be built in <kbd>out/terraform</kbd>.</li>
<li><strong>Build a cloudformation model</strong>: <kbd>--target=cloudformation</kbd><span>. The Cloudformation JSON file will be built in <kbd>out/cloudformation</kbd>.</span></li>
<li><strong>Specify the K8s build to run</strong>: <kbd>--kubernetes-version=1.2.2</kbd>.</li>
<li><strong>Run nodes in multiple zones</strong>: <kbd>--zones=us-east-1b,us-east-1c,us-east-1d</kbd><span>.</span></li>
<li><strong>Run with a HA master</strong>: <kbd>--master-zones=us-east-1b,us-east-1c,us-east-1d</kbd><span>.</span></li>
<li><strong>Specify the number of nodes</strong>: <kbd>--node-count=4</kbd><span>.</span></li>
<li><strong>Specify the node size</strong>: <kbd>--node-size=m4.large</kbd><span>.</span></li>
<li><strong>Specify the master size</strong>: <kbd>--master-size=m4.large</kbd><span>.</span></li>
<li><strong>Override the default DNS zone</strong>: <kbd>--dns-zone=&lt;my.hosted.zone&gt;</kbd><span>.</span></li>
</ul>
<div class="packt_tip">The full list of CLI documentation can be found here: <a href="https://github.com/kubernetes/kops/tree/master/docs/cli">https://github.com/kubernetes/kops/tree/master/docs/cli</a>.</div>
<p class="mce-root"/>
<p>Another tool for diagnosing the cluster status is the <kbd>componentstatuses</kbd> command, which will inform you of state of the major Kubernetes moving pieces:</p>
<pre><strong>$ kubectl get componentstatuses</strong><br/><strong>NAME STATUS MESSAGE ERROR</strong><br/><strong><span>scheduler Healthy ok<br/>controller-manager Healthy ok<br/>etcd-0 Healthy {"health": "true"}</span></strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Resetting the cluster</h1>
                </header>
            
            <article>
                
<p>You just had a little taste of running the cluster on AWS. For the remainder of this book, I will be basing my examples on a GCE cluster. For the best experience following along, you can get back to a GCE cluster easily.</p>
<p>Simply tear down the AWS cluster, as follows:</p>
<pre><strong>$ kops delete cluster --name ${NAME} --yes</strong></pre>
<p>If you omit the <kbd>--yes</kbd> flag, you'll get a similar dry run output that you can confirm. Then, create a GCE cluster again using the following, and in doing so making sure that you're back in the directory where you installed the Kubernetes code:</p>
<pre><strong>$ cd ~/&lt;kubernetes_install_dir&gt;</strong><br/><strong>$ kube-up.sh</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Investigating other deployment automation</h1>
                </header>
            
            <article>
                
<p>If you'd like to learn more about other tools for cluster automation, we recommend that you visit the kube-deploy repository, which has references to community maintained Kubernetes cluster deployment tools.</p>
<div class="packt_tip">Visit <a href="https://github.com/kubernetes/kube-deploy">https://github.com/kubernetes/kube-deploy</a> to learn more.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Local alternatives</h1>
                </header>
            
            <article>
                
<p>The <kbd>kube-up.sh</kbd> script and <kbd>kops</kbd> are pretty handy ways to get started using Kubernetes on your platform of choice. However, they're not without flaws and can sometimes run aground when conditions are not just so.</p>
<p>Luckily, since K8's inception, a number of alternative methods for creating clusters have emerged. We'd recommend checking out Minikube in particular, as it's an extremely simple and local development environment that you can use to test out your Kubernetes configuration.</p>
<p>This project can be found here: <a href="https://github.com/kubernetes/minikube">https://github.com/kubernetes/minikube</a>.</p>
<div class="packt_tip">It's important to mention that you're going to need a hypervisor on your machine to run Minikube. For Linux, you can use kvm/kvm2, or VirtualBox, and on macOS you can run native xhyve or VirtualBox. For Windows, Hyper-V is the default hypervisor.</div>
<p>The main limitation for this project is that it only runs a single node, which limits our exploration of certain advanced topics that require multiple machines. Minikube is a great resource for simple or local development however, and can be installed very simply on your Linux VM with the following:</p>
<div class="highlight highlight-source-shell">
<pre><strong>$ curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 <span class="pl-k">&amp;&amp;</span> chmod +x minikube <span class="pl-k">&amp;&amp;</span> sudo mv minikube /usr/local/bin/</strong></pre></div>
<p>Or install it on macOS with the following:</p>
<pre><strong>$ brew cask install minikube</strong></pre>
<p>We'll cover how to get started with Minikube with the following commands:</p>
<pre><strong>$ minikube start</strong><br/><strong>Starting local Kubernetes v1.7.5 cluster...</strong><br/><strong>Starting VM...</strong><br/><strong>SSH-ing files into VM...</strong><br/><strong>Setting up certs...</strong><br/><strong>Starting cluster components...</strong><br/><strong>Connecting to cluster...</strong><br/><strong>Setting up kubeconfig...</strong><br/><strong>Kubectl is now configured to use the cluster.</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>You can create a sample deployment quite simply:</p>
<pre><strong>$ kubectl run hello-minikube --image=k8s.gcr.io/echoserver:1.4 --port=8080
deployment <span class="pl-s"><span class="pl-pds">"</span>hello-minikube<span class="pl-pds">"</span></span> created
$ kubectl expose deployment hello-minikube --type=NodePort
service <span class="pl-s"><span class="pl-pds">"</span>hello-minikube<span class="pl-pds">"</span></span> exposed</strong><br/><br/></pre>
<p>Once you have your cluster and service up and running, you can interact with it simply by using the <kbd>kubectl</kbd> tool and the <kbd>context</kbd> command. You can get to the Minikube dashboard with <kbd>minikube dashboard</kbd>.</p>
<div class="packt_tip">Minikube is powered by localkube (<a href="https://github.com/kubernetes/minikube/tree/master/pkg/localkube">https://github.com/kubernetes/minikube/tree/master/pkg/localkube</a>) and libmachine (<a href="https://github.com/docker/machine/tree/master/libmachine">https://github.com/docker/machine/tree/master/libmachine</a>). Check them out!</div>
<p>Additionally, we've already referenced a number of managed services, including GKE, EKS, and Microsoft <strong>Azure Container Service</strong> (<strong>ACS</strong>), which provide an automated installation and some managed cluster operations. We will look at a demos of these in <a href="f805c680-0926-43dc-86db-662abeeccdb2.xhtml">Chapter 14</a>, <em>Hardening Kubernetes</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Starting from scratch</h1>
                </header>
            
            <article>
                
<p>Finally, there is the option to start from scratch. Luckily, starting in 1.4, the Kubernetes team has put a major focus on simplifying  the cluster setup process. To that end, they have introduced kubeadm for Ubuntu 16.04, CentOS 7, and HypriotOS v1.0.1+.</p>
<p>Let's take a quick look at spinning up a cluster on AWS from scratch using the kubeadm tool.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cluster setup</h1>
                </header>
            
            <article>
                
<p>We will need to provision our cluster master and nodes beforehand. For the moment, we are limited to the operating systems and version listed earlier. Additionally, it is recommended that you have at least 1 GB of RAM. All the nodes must have network connectivity to one another.</p>
<p>For this walkthrough, we will need one t2.medium (master node) and three t2.mirco (nodes) sized instances on AWS. These instance have burstable CPU and come with the minimum 1 GB of RAM that's required. We will need to create one master and three worker nodes.</p>
<p>We will also need to create some security groups for the cluster. The following ports are needed for the master:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p><strong>Type</strong></p>
</td>
<td>
<p><strong>Protocol</strong></p>
</td>
<td>
<p><strong>Port range</strong></p>
</td>
<td>
<p><strong>Source</strong></p>
</td>
</tr>
<tr>
<td>
<p>All traffic</p>
</td>
<td>
<p>All</p>
</td>
<td>
<p>All</p>
</td>
<td>
<p>{This SG ID (Master SG)}</p>
</td>
</tr>
<tr>
<td>
<p>All traffic</p>
</td>
<td>
<p>All</p>
</td>
<td>
<p>All</p>
</td>
<td>
<p>{Node SG ID}</p>
</td>
</tr>
<tr>
<td>
<p>SSH</p>
</td>
<td>
<p>TCP</p>
</td>
<td>
<p><kbd>22</kbd></p>
</td>
<td>
<p>{Your Local Machine's IP}</p>
</td>
</tr>
<tr>
<td>
<p>HTTPS</p>
</td>
<td>
<p>TCP</p>
</td>
<td>
<p><kbd>443</kbd></p>
</td>
<td>
<p>{Range allowed to access K8s API and UI}</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figure CDPAlignCenter CDPAlign CDPAlignLeft">The following table shows the port's node security groups:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p><strong>Type</strong></p>
</td>
<td>
<p><strong>Protocol</strong></p>
</td>
<td>
<p><strong>Port range</strong></p>
</td>
<td>
<p><strong>Source</strong></p>
</td>
</tr>
<tr>
<td>
<p>All traffic</p>
</td>
<td>
<p>All</p>
</td>
<td>
<p>All</p>
</td>
<td>
<p>{Master SG ID}</p>
</td>
</tr>
<tr>
<td>
<p>All traffic</p>
</td>
<td>
<p>All</p>
</td>
<td>
<p>All</p>
</td>
<td>
<p>{This SG ID (Node SG)}</p>
</td>
</tr>
<tr>
<td>
<p>SSH</p>
</td>
<td>
<p>TCP</p>
</td>
<td>
<p><kbd>22</kbd></p>
</td>
<td>
<p>{Your Local Machine's IP}</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><span class="NormalPACKTChar1">Once you have th</span>ese SGs, go ahe<span class="NormalPACKTChar1">ad and spin up four instances (one t2.medium and three t2.mircos) using Ubuntu 16.04. If you are new to AWS, refer to the documentation on spinning up EC2 instances at the following URL</span>: <strong><a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/LaunchingAndUsingInstances.html"><span class="URLPACKT">http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/LaunchingAndUsingInstances.html</span></a>.</strong></p>
<p>Be sure to identify the t2.medium instance as the master and associate the master security group. Name the other three as nodes and associate the node security group with those.</p>
<div class="packt_infobox">These steps are adapted from the walk-through in the manual. For more information or to work with an alternative to Ubuntu, refer to <a href="https://kubernetes.io/docs/getting-started-guides/kubeadm/">https://kubernetes.io/docs/getting-started-guides/kubeadm/</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Kubernetes components (kubelet and kubeadm)</h1>
                </header>
            
            <article>
                
<p>Next, we will need to SSH into all four of the instances and install the Kubernetes components.</p>
<p>As the root user, perform the following steps on all four instances:</p>
<ol>
<li style="padding-left: 30px">Update the packages and install the <kbd>apt-transport-https</kbd> package so that we can download from sources that use HTTPS:</li>
</ol>
<pre><strong>   $ apt-get update </strong><br/><strong>   $ apt-get install -y apt-transport-https</strong></pre>
<ol start="2">
<li style="padding-left: 30px">Install the Google Cloud public key:</li>
</ol>
<pre><strong>   $ curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg |<br/>   apt-key add -</strong>    </pre>
<ol start="3">
<li style="padding-left: 30px">Next, let's set up the repository:</li>
</ol>
<pre><strong>   cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list</strong><br/><strong>   deb http://apt.kubernetes.io/ kubernetes-xenial main</strong><br/><strong>   EOF</strong><br/><strong>   apt-get update</strong><br/><strong>   apt-get install -y kubelet kubeadm kubectl docker.io kubernetes-cni</strong></pre>
<p>You'll need to make sure that the <kbd>cgroup</kbd> driver used by the <kbd>kubelet</kbd> on the master node is configured correctly to work with Docker. Make sure you're on the master node, then run the following:</p>
<pre><strong>docker info | grep -i cgroup</strong><br/><strong>cat /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</strong></pre>
<p class="mce-root">If these items don't match, you're going to need to change the kubelet configuration to match the Docker driver. Running <kbd>sed -i "s/cgroup-driver=systemd/cgroup-driver=cgroupfs/g" /etc/systemd/system/kubelet.service.d/10-kubeadm.conf </kbd> should fix the settings, or you can manually open the <kbd>systemd</kbd> file and add the correct flag to the appropriate environment. After that's complete, restart the service:</p>
<pre><strong>$ systemctl daemon-reload</strong><br/><strong>$ systemctl restart kubele</strong>t</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up a master</h1>
                </header>
            
            <article>
                
<p>On the instance you have previously chosen as master, we will run master initialization. Again, as the root, run the following command, and you should see the following output:</p>
<pre><strong>$ kubeadm init<br/>[init] using Kubernetes version: v1.11.3<br/>[preflight] running pre-flight checks<br/>I1015 02:49:42.378355 5250 kernel_validator.go:81] Validating kernel version<br/>I1015 02:49:42.378609 5250 kernel_validator.go:96] Validating kernel config<br/>[preflight/images] Pulling images required for setting up a Kubernetes cluster<br/>[preflight/images] This might take a minute or two, depending on the speed of your internet connection<br/>[preflight/images] You can also perform this action in beforehand using 'kubeadm config images pull'<br/>[kubelet] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"<br/>[kubelet] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"<br/>[preflight] Activating the kubelet service<br/>[certificates] Generated ca certificate and key.<br/>[certificates] Generated apiserver certificate and key.<br/>[certificates] apiserver serving cert is signed for DNS names [master kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 172.17.0.71]<br/>[certificates] Generated apiserver-kubelet-client certificate and key.<br/>[certificates] Generated sa key and public key.<br/>[certificates] Generated front-proxy-ca certificate and key.<br/>[certificates] Generated front-proxy-client certificate and key.<br/>[certificates] Generated etcd/ca certificate and key.<br/>[certificates] Generated etcd/server certificate and key.<br/>[certificates] etcd/server serving cert is signed for DNS names [master localhost] and IPs [127.0.0.1 ::1]<br/>[certificates] Generated etcd/peer certificate and key.<br/>[certificates] etcd/peer serving cert is signed for DNS names [master localhost] and IPs [172.17.0.71 127.0.0.1 ::1]<br/>[certificates] Generated etcd/healthcheck-client certificate and key.<br/>[certificates] Generated apiserver-etcd-client certificate and key.<br/>[certificates] valid certificates and keys now exist in "/etc/kubernetes/pki"<br/>[kubeconfig] Wrote KubeConfig file to disk: "/etc/kubernetes/admin.conf"<br/>[kubeconfig] Wrote KubeConfig file to disk: "/etc/kubernetes/kubelet.conf"<br/>[kubeconfig] Wrote KubeConfig file to disk: "/etc/kubernetes/controller-manager.conf"<br/>[kubeconfig] Wrote KubeConfig file to disk: "/etc/kubernetes/scheduler.conf"<br/>[controlplane] wrote Static Pod manifest for component kube-apiserver to "/etc/kubernetes/manifests/kube-apiserver.yaml"<br/>[controlplane] wrote Static Pod manifest for component kube-controller-manager to "/etc/kubernetes/manifests/kube-controller-manager.yaml"<br/>[controlplane] wrote Static Pod manifest for component kube-scheduler to "/etc/kubernetes/manifests/kube-scheduler.yaml"<br/>[etcd] Wrote Static Pod manifest for a local etcd instance to "/etc/kubernetes/manifests/etcd.yaml"<br/>[init] waiting for the kubelet to boot up the control plane as Static Pods from directory "/etc/kubernetes/manifests"<br/>[init] this might take a minute or longer if the control plane images have to be pulled<br/>[apiclient] All control plane components are healthy after 43.001889 seconds<br/>[uploadconfig] storing the configuration used in ConfigMap "kubeadm-config" in the "kube-system" Namespace<br/>[kubelet] Creating a ConfigMap "kubelet-config-1.11" in namespace kube-system with the configuration for the kubelets in the cluster<br/>[markmaster] Marking the node master as master by adding the label "node-role.kubernetes.io/master=''"<br/>[markmaster] Marking the node master as master by adding the taints [node-role.kubernetes.io/master:NoSchedule]<br/>[patchnode] Uploading the CRI Socket information "/var/run/dockershim.sock" to the Node API object "master" as an annotation<br/>[bootstraptoken] using token: o760dk.q4l5au0jyx4vg6hr<br/>[bootstraptoken] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials<br/>[bootstraptoken] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token<br/>[bootstraptoken] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster<br/>[bootstraptoken] creating the "cluster-info" ConfigMap in the "kube-public" namespace<br/>[addons] Applied essential addon: CoreDNS<br/>[addons] Applied essential addon: kube-proxy<br/><br/>Your Kubernetes master has initialized successfully!<br/><br/>To start using your cluster, you need to run the following as a regular user:<br/><br/>  mkdir -p $HOME/.kube<br/>  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br/>  sudo chown $(id -u):$(id -g) $HOME/.kube/config<br/><br/>You should now deploy a pod network to the cluster.<br/>Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:<br/>  https://kubernetes.io/docs/concepts/cluster-administration/addons/<br/><br/>You can now join any number of machines by running the following on each node<br/>as root:<br/><br/>  kubeadm join 172.17.0.71:6443 --token o760dk.q4l5au0jyx4vg6hr --discovery-token-ca-cert-hash sha256:453e2964eb9cc0cecfdb167194f60c6f7bd8894dc3913e0034bf0b33af4f40f5<br/></strong></pre>
<p>To start using your cluster, you need to run as a regular user:</p>
<pre class="mce-root"><strong>mkdir -p $HOME/.kube</strong><br/><strong> sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</strong><br/><strong> sudo chown $(id -u):$(id -g) $HOME/.kube/config</strong></pre>
<p class="mce-root">You should now deploy a pod network to the cluster. Run <kbd>kubectl apply -f [podnetwork].yaml</kbd> with one of the options listed at <a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/">https://kubernetes.io/docs/concepts/cluster-administration/addons/</a>.</p>
<p class="mce-root">You can now join any number of machines by running the following on each node<br/>
as root:</p>
<pre class="mce-root"><strong>kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</strong></pre>
<p>Note that initialization can only be run once, so if you run into problems, you'll need to use <kbd>kubeadm reset</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Joining nodes</h1>
                </header>
            
            <article>
                
<p>After a successful initialization, you will get a <kbd>join</kbd> command that can be used by the nodes. Copy this down for the join process later on. It should look similar to this:</p>
<pre><strong>$ kubeadm join --token=&lt;some token&gt; &lt;master ip address&gt;</strong></pre>
<p>The token is used to authenticate cluster nodes, so make sure to store it somewhere securely for future use.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Networking</h1>
                </header>
            
            <article>
                
<p>Our cluster will need a networking layer for the pods to communicate on. Note that kubeadm requires a CNI compatible network fabric. The list of plugins currently available can be found here: <strong><a href="http://kubernetes.io/docs/admin/addons/"><span class="URLPACKT">http://kubernetes.io/docs/admin/addons/</span></a></strong>.</p>
<p>For our example, we will use calico. We will need to create the calico components on our cluster using the following <kbd>yaml</kbd>. For convenience, you can download it here: <strong><a href="http://docs.projectcalico.org/v1.6/getting-started/kubernetes/installation/hosted/kubeadm/calico.yaml"><span class="URLPACKT">http://docs.projectcalico.org/v1.6/getting-started/kubernetes/installation/hosted/kubeadm/calico.yaml</span></a></strong>.</p>
<p>Once you have this file on your master, create the components with the following command:</p>
<pre><strong>$ kubectl apply -f calico.yaml</strong></pre>
<p>Give this a minute to run setup and then list the <kbd>kube-system</kbd> nodes in order to check this:</p>
<pre><strong>$ kubectl get pods --namespace=kube-system</strong></pre>
<p>You should get a listing similar to the following one with three new calico pods and one completed job that is not shown:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/00c12709-5b01-475e-98f8-23e9b5a11b1e.png" width="660" height="242"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Calico setup</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Joining the cluster</h1>
                </header>
            
            <article>
                
<p>Now, we need to run the <kbd>join</kbd> command we copied earlier, on each of our node instances:</p>
<pre><strong>$ kubeadm join --token=&lt;some token&gt; &lt;master ip address&gt;</strong></pre>
<p>Once you've finished that, you should be able to see all nodes from the master by running the following command:</p>
<pre><strong>$ kubectl get nodes</strong></pre>
<p>If all went well, this will show three nodes and one master, as shown here:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/cff5aa3d-ca69-4360-9d4b-7338aae22b1a.png" style="width:19.83em;height:6.25em;" width="295" height="93"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We took a very brief look at how containers work and how they lend themselves to the new architecture patterns in microservices. You should now have a better understanding of how these two forces will require a variety of operations and management tasks, and how Kubernetes offers strong features to address these challenges. We created two different clusters on both GCE and AWS, and explored the startup script as well as some of the built-in features of Kubernetes. Finally, we looked at the alternatives to the <kbd>kube-up</kbd> script in kops, and tried our hand at manual cluster configuration with the kubeadm tool on AWS with Ubuntu 16.04.</p>
<p>In the next chapter, we will explore the core concept and abstractions K8s provides to manage containers and full application stacks. We will also look at basic scheduling, service discovery, and health checking.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Name three places where you can easily deploy a Kubernetes cluster.</li>
<li>What are other types of pre-existing virtualization technologies that predate containers?</li>
<li>Name as many cgroup controls as you can!</li>
<li>What are some of the reasons why enabling CI/CD with containers is so important to organizations?</li>
<li>What prerequisites are required to get a Kubernetes cluster up and running on AWS or GCE?</li>
<li>Name four services running on the Kubernetes master nodes. Hint: these are containers.</li>
<li>What are some alternatives to the <kbd>kube-up.sh</kbd> script?</li>
<li>What's the tool used for building a Kubernetes cluster from scratch?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p><span>Want more information on DevOps practices on Kubernetes? Check out <em>DevOps with Kubernetes</em>: </span><a href="https://www.packtpub.com/virtualization-and-cloud/devops-kubernetes"><span>https://www.packtpub.com/virtualization-and-cloud/devops-kubernetes</span></a>.</p>
<p>You can also read about different applications and automation approaches with the <em>Kubernetes Cookbook</em>: <a href="https://www.packtpub.com/virtualization-and-cloud/kubernetes-cookbook">https://www.packtpub.com/virtualization-and-cloud/kubernetes-cookbook</a>.</p>


            </article>

            
        </section>
    </div>



  </body></html>