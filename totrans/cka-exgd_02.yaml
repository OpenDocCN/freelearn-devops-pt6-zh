- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing and Configuring Kubernetes Clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces the different configurations of Kubernetes, which is
    the first step toward working with Kubernetes. We’ll get our hands dirty by setting
    up a Kubernetes cluster with a single worker node and then multiple worker nodes.
    This chapter familiarizes you with Kubernetes installations, which is one of the
    key skills that will serve in your daily job as a Kubernetes administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on Kubernetes tooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring a Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `minikube` to set up a single node Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `kubeadm` to install a basic Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a highly available cluster with `kubeadm`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, we need to make sure your local machine meets the technical
    requirements described as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A compatible Linux host – we recommend a Debian-based Linux distribution such
    as Ubuntu 18.04 or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure your host machine has at least 2 GB RAM, 2 CPU cores, and about 20
    GB of free disk space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hands-on Kubernetes tooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a handful of Kubernetes tools on the market – we’ll start by covering
    some widely used Kubernetes tools to interact with the Kubernetes cluster. We’ll
    dive into some key tools with hands-on labs later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Core tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to cover tools which are required to work with
    Kubernetes and containers.
  prefs: []
  type: TYPE_NORMAL
- en: kubectl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`kubectl` is a Kubernetes command-line tool used to talk to the Kubernetes
    cluster. It is hands down the most common and important utility that allows you
    to run commands against the Kubernetes cluster. There are a handful of `kubectl`
    commands available that will allow users to work with the Kubernetes cluster,
    such as deploying a containerized application, managing cluster resources, and
    monitoring and visualizing events and logs. We’ll cover most of the common `kubectl`
    commands with examples as we go through the process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up the `kubectl` utility, if you’re on Red Hat-based distributions such
    as CentOS or Fedora, check out the official article for further information: [https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/#install-using-native-package-management](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/#install-using-native-package-management).
    You can use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re on Debian-based distributions such as Ubuntu 18.04, you can follow
    the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, you need to update the `apt` package index – then, you need to install
    the packages needed to use the Kubernetes `apt` repository by running the following
    commands sequentially:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Download the Google Cloud public signing key and add the Kubernetes `apt` repository
    by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you’re ready to go. Make sure you update the `apt` package index with
    the new repository again and then install the `kubectl` utility using the `apt-get
    install` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can verify whether `kubectl` has been successfully installed by running
    the following command upon the completion of the previous steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll see an output similar to the following if you have installed `kubectl`
    successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – A successful installation of kubectl ](img/Figure_2.01_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – A successful installation of kubectl
  prefs: []
  type: TYPE_NORMAL
- en: For instructions on installing `kubectl` in different environments, please refer
    to [https://kubernetes.io/docs/tasks/tools/](https://kubernetes.io/docs/tasks/tools/).
  prefs: []
  type: TYPE_NORMAL
- en: Container runtimes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we are going to set up `containerd` as our container runtime by following
    these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `apt` index, add Docker’s official `GPG` key, and set up the `apt`
    repository by running the following instructions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the Docker engine and `containerd.io`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Validate that Docker has been installed successfully by using the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Docker is up and running ](img/Figure_2.02_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Docker is up and running
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re about to configure `containerd` as the container runtime, you can
    use the following command and set the configuration to `default`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart `containerd` to make sure the changes take effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to know more about how to set up CRI-O as a runtime, please check
    out the following link: [https://kubernetes.io/docs/setup/production-environment/container-runtimes/#cri-o](https://kubernetes.io/docs/setup/production-environment/container-runtimes/#cri-o).
    It will show you how `containerd` serves as a container runtime in the context
    of Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: Deployment tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To bootstrap a Kubernetes cluster, we rely on the deployment tools. There are
    lots of useful tools on the market to help spin up a Kubernetes cluster, of which
    a lot of them are vendor-affinity. Here, we will cover what’s requested in the
    CKA exam. That’s the primary reason that we focus on upstream Kubernetes and these
    tools will help bootstrap a cluster on-premises. The following tools help you
    set up a Kubernetes cluster and we’ll cover the detailed instructions while working
    with each of them in the next chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubeadm` is the most important tool to help you crack the exam exercises.
    It helps install and set up the Kubernetes cluster with best practices. With `kubeadm`,
    you can provision a single node cluster and, more importantly, multi-node clusters.
    This is the first choice for most large organizations that want to manage their
    own Kubernetes cluster and use their own on-premises servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minikube` is a popular local Kubernetes that can be provisioned on your local
    laptop or a **virtual machine** (**VM**). It’s very lightweight, focusing on making
    it easy to learn and testing Kubernetes quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` is similar to `minikube`. It focuses on provisioning local Kubernetes
    clusters and some simple CI scenarios and development. It runs local Kubernetes
    clusters using a Docker runtime – it can run as a single node Kubernetes cluster
    or a Kubernetes multi-node cluster. You can test lots of useful, simple scenarios
    with `kind`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the other tools are not covered in the CKA exam – however, they will
    still come in handy in your daily work as a Kubernetes administrator.
  prefs: []
  type: TYPE_NORMAL
- en: Helm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Helm is a management tool for managing packages of pre-configured Kubernetes
    objects in the form of charts – we call these Helm charts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `helm`, you can follow the following instructions for a Debian-based
    distribution such as Ubuntu 18.04:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `apt` package index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the packages to use the Helm `apt` repository with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure you update the `apt` package index with the new repository again
    and then install Helm using the `apt-get install` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following Helm command to validate its successful installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Successful installation of Helm ](img/Figure_2.03_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Successful installation of Helm
  prefs: []
  type: TYPE_NORMAL
- en: 'To know more ways to install Helm, check out the following link: [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/).'
  prefs: []
  type: TYPE_NORMAL
- en: Kompose
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most people who work with Docker will know about Docker Compose. Docker Compose
    is a tool used to define and run the multi-container applications containerized
    by Docker. It also uses a YAML file to define the application specifications.
    As more and more people are moving away from purely using Docker Swarm or Docker
    Desktop to take advantage of the enterprise-scale container orchestration system,
    Kompose comes in handy as a conversion tool for Docker Compose to contain orchestrators
    such as Kubernetes – the same structure works for Redhat OpenShift too.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install Kompose by running the following instructions on your Ubuntu
    18.04:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fetch the `kompose` binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you can fetch a `docker compose` example file from the official website
    and test the `kompose convert` command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your output will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – A kompose convert command translating Docker compose into Kubernetes-native
    YAML-defined files  ](img/Figure_2.04_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – A kompose convert command translating Docker compose into Kubernetes-native
    YAML-defined files
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, deploy those YAML files to your local Kubernetes cluster by using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your output will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Kubernetes Pods up and running  ](img/Figure_2.05_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Kubernetes Pods up and running
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the Redis Pods running in your Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can install a web-based **user interface** (**UI**) to your Kubernetes cluster.
    It not only displays the cluster status and shows what’s going on with the Kubernetes
    cluster but also allows you to deploy containerized applications, troubleshoot,
    and manage the cluster and all related resources in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – The Kubernetes dashboard ](img/Figure_2.06_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – The Kubernetes dashboard
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard is sometimes handy for quick monitoring of the cluster states
    from the UI and user-friendly for collaborating with people who are not familiar
    with `kubectl` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring a Kubernetes cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section focuses on the installation of the Kubernetes cluster and the related
    configurations for it. With a good understanding gained from [*Chapter 1*](B18201_01.xhtml#_idTextAnchor015),
    where you learned about the Kubernetes cluster architecture and Kubernetes toolings,
    you will perform the Kubernetes cluster installation the hard way with `minikube`
    and `kubeadm`, and then update the cluster version.
  prefs: []
  type: TYPE_NORMAL
- en: Note that using `minikube` to spin up a single node cluster is not covered in
    the CKA exam but it comes quite handy when you’d like to test out Kubernetes in
    your local machine. The same goes for using `kubeadm` to install a Kubernetes
    multi-node cluster, as well as setting up a **highly available** (**HA**) Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: We expect you to learn both ways while putting more focus on the hands-on lab
    working with `kubeadm`. Starting with the next section, we’ll walk you through
    the process of installing a new Kubernetes cluster and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites for installing a Kubernetes cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started, we need to make sure your local machine meets the following
    technical requirements for both `minikube` and `kubeadm`:'
  prefs: []
  type: TYPE_NORMAL
- en: A compatible Linux host – we recommend a Debian-based Linux distribution such
    as Ubuntu 18.04 or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure your host machine has at least 2 GB RAM, 2 CPU cores, and about 20
    GB of free disk space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet connectivity, as you will need to download dependencies throughout
    the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A container runtime is needed prior to creating a Kubernetes cluster. During
    the cluster creation process, the Kubernetes cluster automatically detects an
    installed container runtime by scanning through the Unix domain sockets, if there
    are any, within your local machine. The **Unix domain socket** uses **Transmission
    Control Protocol** (**TCP**) as the underlying transport protocol. It is used
    for bidirectional data communication happening on the same operating system. We
    talked about how to install and configure container runtime in [*Chapter 1*](B18201_01.xhtml#_idTextAnchor015)
    – please follow those instructions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we get started, let’s get the following checklist done.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether swap is disabled
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For `kubeadm`, we have to disable `swap` in order to make `kubelet` work correctly,
    you can disable `swap` by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Checking the container runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can check the path to the Unix domain socket as instructed to verify your
    container runtime – this path is detectable by Kubernetes. Following the instructions
    to install Docker covered earlier in this chapter, you will find the Unix domain
    path under the `/var/run/dockershim.sock` path once you have installed the `kubelet`
    agent. To validate that Docker has been installed successfully, run the `docker
    ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome of the following command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Checking the Docker runtime ](img/Figure_2.07_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Checking the Docker runtime
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have installed `containerd` as the container runtime, which we covered
    earlier in this chapter under the *Container runtimes* section, you will find
    the Unix domain path under the `/run/containerd/containerd.sock` path as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Checking the containerd runtime ](img/Figure_2.08_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Checking the containerd runtime
  prefs: []
  type: TYPE_NORMAL
- en: '`kubeadm` picks `docker` over `containerd` as the container runtime when both
    the `docker` and `containerd` runtimes are detected. At the time of writing, as
    announced at the beginning of Jan 2022, Kubernetes is removing `dockershim` in
    the upcoming v1.24 release. This is not surprising at all since it was first announced
    in Dec 2020 and Kubernetes’ built-in `dockershim` component was deprecated in
    Kubernetes v1.20\. In most cases, it won’t affect the applications running in
    Kubernetes or the build process of the containerized applications if the following
    conditions are satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: There’s no privileged root permission applied at the container level while it
    executes inside the pods using Docker commands and it restarts `docker.service`
    with `systemctl`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker configuration files such as /`etc/docker/daemon.json` are modified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point, the official Kubernetes documentation has published this article
    to help users check whether `dockershim` deprecation will impact them. Check it
    out here for more ways to check the dependencies on Docker: [https://kubernetes.io/docs/tasks/administer-cluster/migrating-from-dockershim/check-if-dockershim-deprecation-affects-you/#find-docker-dependencies](https://kubernetes.io/docs/tasks/administer-cluster/migrating-from-dockershim/check-if-dockershim-deprecation-affects-you/#find-docker-dependencies).'
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether the ports required by Kubernetes are opened
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We also need to check if certain ports are open on your local machines prior
    to installing `kubeadm`. You can use the `telnet` command to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the official documentation to make sure the ports and protocols
    used by Kubernetes are available by visiting this link: [https://kubernetes.io/docs/reference/ports-and-protocols/](https://kubernetes.io/docs/reference/ports-and-protocols/).'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring iptables sees bridged traffic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Make sure your Linux node’s `iptables` is correctly configured to be able to
    watch the bridged traffic. You can set the `net.bridge.bridge-nf-call-iptables`
    parameter to a value of `1`, just as we did here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – iptables watching bridged traffic ](img/Figure_2.09_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – iptables watching bridged traffic
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the values in `iptables` have been updated.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether you have installed kubectl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`kubectl` is the command-line utility that you can use to talk to the Kubernetes
    cluster. Using the `kubectl version` command, you can verify whether `kubectl`
    has been successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A successful installation will show an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Checking the kubectl version ](img/Figure_2.10_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Checking the kubectl version
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have completed the checklist in this section before moving on
    to the next section. These tools and requirements are essential and you may use
    them accordingly in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Using minikube to set up a single node Kubernetes cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Kubernetes cluster using `minikube` is the easiest way to spin up
    a local Kubernetes cluster and it can be achieved in a matter of minutes. Here’s
    what you need to do.
  prefs: []
  type: TYPE_NORMAL
- en: Installing minikube
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow these steps to install `minikube`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On your local or cloud-based Linux VM, use the `curl` command to retrieve the
    `minikube` binary, and then install it under `/usr/local/bin/minikube` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can go to `/usr/local/bin/minikube` to check whether you have successfully
    installed the `minikube` binary before moving to the next steps or you can also
    check by typing the following command into the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using minikube to provision a single node Kubernetes cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow these steps to use minikube to provision a single node Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `minikube` to provision a single node Kubernetes cluster, you can
    simply use the `minikube start` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also set up the CPU cores and memory to start your `minikube` cluster
    by adding a `--memory` and `--cpus` flag as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the command is executed, it kicks off the `minikube` cluster provisioning
    process. You’ll see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Spinning up a minikube cluster ](img/Figure_2.11_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Spinning up a minikube cluster
  prefs: []
  type: TYPE_NORMAL
- en: By the end, you will see a message telling you we’re ready to use the `minikube`
    Kubernetes cluster (as concluded in the preceding screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the minikube cluster installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your `minikube` cluster contains one node that serves as both the control plane
    and worker node. That means that once you have it set up, you can start to schedule
    workloads in your local Kubernetes cluster. You can use the following command
    to see whether the node is ready to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the shortcut of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will show you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The status of the node and whether it’s ready to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The role of that node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kubernetes version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The age of that node since it’s been deployed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Checking the Docker runtime ](img/Figure_2.12_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Checking the Docker runtime
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the minikube cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’d like to configure the `minikube` cluster without reprovisioning a new
    one, you need to stop the `minikube` cluster using the `minikube stop` command.
  prefs: []
  type: TYPE_NORMAL
- en: The `minikube config set` command will help you apply the settings such as CPU
    and memory that you’ll allocate to the `minikube` cluster. After configuring the
    `minikube` cluster, you need to start the `minikube` cluster and from there, you’ll
    be working on the cluster with the new configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the process to configure `minikube` using more memory and CPUs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After that, you can continue to play with the `minikube` cluster. In case you
    have any questions about how the commands work, use the `minikube config - - help`
    command to get help.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a minikube cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following command deletes all local Kubernetes clusters and all profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'What you learned from this section can be used repeatedly every time you need
    a local Kubernetes cluster. You can replicate what you have learned from this
    section for quick testing of the latest Kubernetes release for most of the new
    features featured in the release note: [https://github.com/kubernetes/kubernetes/releases](https://github.com/kubernetes/kubernetes/releases).'
  prefs: []
  type: TYPE_NORMAL
- en: However, most enterprise-grade environments will not be satisfied with a single
    node cluster. They are mostly multi-node setups. In the next section, we will
    dive into creating a Kubernetes multi-node cluster with `kubeadm`.
  prefs: []
  type: TYPE_NORMAL
- en: Using kubeadm to install a basic Kubernetes cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create a multi-node Kubernetes cluster using `kubeadm`.
    The following are the steps we need to achieve the goal:'
  prefs: []
  type: TYPE_NORMAL
- en: Install `kubeadm`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bootstrap a master node where your control plane will be located
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the network plugins (we will get to the detailed supported plugins later
    in this chapter and use Calico as an example in that section).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bootstrap the worker nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join the worker nodes to the control plane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before getting started, you need to make sure your master node meets all the
    technical requirements listed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll deploy a basic Kubernetes cluster by going through the steps described
    in this section, as shown in *Figure 2.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – The workflow of using kubeadm to spin up a basic Kubernetes
    cluster ](img/Figure_2.13_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – The workflow of using kubeadm to spin up a basic Kubernetes cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kubernetes cluster will be similar to the architecture featured in *Figure
    2.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – A standard multi-node Kubernetes cluster  ](img/Figure_2.14_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – A standard multi-node Kubernetes cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'From now on, you can follow these instructions to create a multi-node Kubernetes
    cluster. To create a Kubernetes cluster using `kubeadm`, its default settings
    conform to best practices of setting up a standard Kubernetes cluster. This set
    of best practices is encapsulated as Kubernetes Conformance tests. Check out the
    details about the Kubernetes Conformance Program here: [https://kubernetes.io/blog/2017/10/software-conformance-certification/](https://kubernetes.io/blog/2017/10/software-conformance-certification/).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing kubeadm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We introduced setting up `docker` or `containerd` as the container runtime
    – we can then install `kubeadm` by following these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `apt` package index, add the Google Cloud public signing key, and
    set up the Kubernetes `apt` repository by running the following instructions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start by updating the `ap`t package index and then install `kubelet` and `kubeadm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, if you haven’t installed `kubectl` yet, you can also install `kubelet`,
    `kubeadm`, and `kubectl` in one go:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following command to pin the version of the utilities you’re installing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output shows those packages are set on hold as shown in *Figure 2.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Checking the containerd runtime ](img/Figure_2.15_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – Checking the containerd runtime
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you can check whether `kubeadm` has been successfully installed
    by typing `kubeadm` into the command shell. Here’s the output of the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Checking the containerd runtime ](img/Figure_2.16_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – Checking the containerd runtime
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that `kubelet` is present on the master node, you can use the `which
    kubelet` command, which returns the location of the `kubelet` agent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Checking kubelet’s presence ](img/Figure_2.17_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – Checking kubelet’s presence
  prefs: []
  type: TYPE_NORMAL
- en: As you have successfully installed `kubeadm` and `kubelet`, you can now start
    initiating a control plane.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will show an optional operation where you can use `images pull` to
    pre-pull the images that are required to set up the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Pre-pulling the images ](img/Figure_2.18_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – Pre-pulling the images
  prefs: []
  type: TYPE_NORMAL
- en: Note that the preceding operation is optional – you’re free to skip it and go
    straight to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping a master node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `kubeadm init` command to initiate the control plane as a regular
    user and gain `sudo` privileges from your master node machine by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – The control plane initiated successfully ](img/Figure_2.19_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 – The control plane initiated successfully
  prefs: []
  type: TYPE_NORMAL
- en: 'After your Kubernetes `control-plane` is initialized successfully, you can
    execute the following commands to configure `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re a root user, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Then, the next step is to deploy a pod network to the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the networking plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order for the pods to talk to each other, you can deploy the networking by
    enabling **Container Network Interface** (**CNI**) plugin. The CNI plugins conform
    to the CNI specification, and as per the official Kubernetes documentation, Kubernetes
    follows the v0.4.0 release of the CNI specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a wide range of networking plugins working with Kubernetes – we will
    dive into Kubernetes networking in [*Chapter 7*](B18201_07.xhtml#_idTextAnchor235),
    *Demystifying Kubernetes Networking*. Here are some add-ons options:'
  prefs: []
  type: TYPE_NORMAL
- en: Calico
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flannel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weave Net
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For all the possible options acknowledged by the Kubernetes community, please
    check out the official documentation: [https://kubernetes.io/docs/concepts/cluster-administration/addons/](https://kubernetes.io/docs/concepts/cluster-administration/addons/).
    You can check out the links from this page to get the installation instructions
    for the respective options.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we’re going to use the Calico plugin as the overlay network for our Kubernetes
    cluster. It is a Kubernetes CNI networking provider and it allows you to write
    up the network policies, which means that it supports a set of networking options
    to suit your different requirements. Here’s how we’ll approach it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploy the Tigera Calico `kubectl create -f` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can use the `watch` command to monitor the pod status in the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, use the following alternative command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can see the pods have a `Running` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20 – The control plane initiated successfully ](img/Figure_2.20_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.20 – The control plane initiated successfully
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Kubernetes cluster created by `kubeadm`, there’s a taint by default
    for master nodes. Therefore, we need to remove taints so that the master node
    is available to schedule pods. To remove the taint, you can use the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows that the taint on the master node has been successfully
    removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.21 – Removing the taint on the master node successfully ](img/Figure_2.21_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.21 – Removing the taint on the master node successfully
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command to check out the current nodes that are available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get more information from the node, you can use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows the sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.22 – The Kubernetes node status ](img/Figure_2.22_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.22 – The Kubernetes node status
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding command output, you can see the Kubernetes node is operational
    after enabling the CNI networking and it has been assigned an internal IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the worker nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To add more worker nodes to the Kubernetes cluster, we will SSH to the client
    machine, and make sure the worker nodes meet the same technical requirements as
    the master node. Check out the *Prerequisites for installing a Kubernetes cluster*
    section of this chapter and refer to the information on `kubeadm` for more details.
    Make sure you have installed the container runtime and `kubeadm`, although `kubectl`
    is optional for worker nodes since we usually use the master node for management.
  prefs: []
  type: TYPE_NORMAL
- en: Joining the worker nodes to the control plane
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can go ahead with installing `kubeadm` for the master node after making sure
    that your worker nodes and local environment meet the technical requirements that
    we set, as we mentioned earlier in this section. As introduced in [*Chapter 1*](B18201_01.xhtml#_idTextAnchor015),
    *Kubernetes Overview*, the worker nodes are where your containerized workloads
    are up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command to join the worker nodes to the Kubernetes
    cluster. This command can be used repeatedly each time you have to join new worker
    nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can actually go back and copy the output of the master node control plane,
    which would look similar to the following sample command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You can use the preceding command to join the worker node to the control plane
    and set up your Kubernetes cluster with multiple worker nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a highly available cluster with kubeadm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B18201_01.xhtml#_idTextAnchor015), *Kubernetes Overview*,
    we introduced the cluster architecture, which gives us two options: setting up
    a single node Kubernetes cluster for dev/test quick testing or setting up a multi-node
    Kubernetes cluster for more professional use, or even use in production. A standard
    configuration would be one master with multiple worker nodes. As we stated in
    the previous chapter, the Kubernetes master node is where the control plane resides.
    In the event of a master node going down, either the containerized workloads up
    and running in the worker nodes will still keep running until the worker node
    is off the grid for some reason or there are no available master nodes, meaning
    no new workloads will be scheduled to the worker node.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two options available to build a HA Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building multiple master nodes**: This is the option where the control plane
    nodes and etcd members co-exist in the same master nodes. *Figure 2.16* shows
    the stacked etcd topology:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.23 – A stacked etcd topology for a HA kubeadm cluster ](img/Figure_2.23_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.23 – A stacked etcd topology for a HA kubeadm cluster
  prefs: []
  type: TYPE_NORMAL
- en: This topology makes the cluster more resilient compared to the basic Kubernetes
    cluster architecture that we built in this chapter, thanks to the redundancy of
    the master node. In case one master node goes down, it’s easy to switch to another
    available master node to ensure the health of the entire Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: However, in some cases where we need to manage the cluster and replicate the
    cluster information, the external etcd typology comes in.
  prefs: []
  type: TYPE_NORMAL
- en: '`kubeadm` HA topology architecture for an external etcd cluster is shown in
    *Figure 2.24*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.24 – The topology for an external etcd HA kubeadm cluster ](img/Figure_2.24_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.24 – The topology for an external etcd HA kubeadm cluster
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 2.24*, the external etcd is a cluster and it communicates
    with the API server of each control plane. In the event of the control plane node
    going down, we won’t lose all the information stored in the etcd store. It also
    makes the control plane more decoupled and manageable, as we only need to add
    more control plane nodes. A loss of the control plane node won’t be as impactful
    as it would with the stacked etcd topology.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the very first job for most Kubernetes administrators who
    are setting up a Kubernetes cluster with a single worker node or with multiple
    worker nodes. The various tools introduced in this chapter will help your daily
    routine at work beyond the exam. Nevertheless, this is also one of the most time-consuming
    tasks in the CKA exam. Practice, practice, and more practice will help you get
    the hang of it. Knowing the HA topology for a Kubernetes cluster will also help
    you address the requirements of the organization that you’ll be working for as
    a Kubernetes administrator. As you master the setup process for a basic Kubernetes
    cluster, it will become easier to apply your skills to different typologies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll talk about Kubernetes cluster maintenance, including
    some important topics such as upgrades to Kubernetes components, which is quite
    an essential task in the daily work of a Kubernetes administrator. Touching on
    external etcd typology in this chapter is just a start, as we’ll dive into more
    interesting work with etcd in the next chapter. Happy learning!
  prefs: []
  type: TYPE_NORMAL
- en: Mock CKA scenario-based practice test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have two VMs, *master-0* and *worker-0*. Please complete the following mock
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 1**:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install the latest version of `kubeadm`, then create a basic `kubeadm` cluster
    on the `master-0` node, and get the node information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 2**:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH to `worker-0` and join it to the `master-0` node.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 3 (optional)**:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set up a local `minikube` cluster and schedule your first workload, called `hello
    Packt`
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the scenario resolutions in [*Appendix*](B18201_Appendix_A.xhtml#_idTextAnchor386)
    *- Mock CKA scenario-based practice test resolutions* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: FAQs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Where should I start to test the Kubernetes cluster?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can start on your local laptop or desktop on Windows, Linux, or Mac OS,
    and we recommend using VMware player or Hyper-V to spin up multiple VMs so you
    can test out a multinode scenario. Using Multipass from Canonical is also great
    for creating Ubuntu VMs and it supports Linux, Mac, and Windows. Check it out
    here: [https://multipass.run/](https://multipass.run/).'
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to get a cloud subscription such as Microsoft Azure, AWS,
    or GCP, using which you can provision a VM with a click-through experience.
  prefs: []
  type: TYPE_NORMAL
- en: '*Where can I find the latest Kubernetes release to test out?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Kubernetes GitHub repository is where you can find all the releases as
    well as changelogs, and you can get the latest release and build it by yourself:
    [https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes).'
  prefs: []
  type: TYPE_NORMAL
- en: We can also use `kubeadm` or `minikube` to get Kubernetes, as they are aligned
    with the Kubernetes source code delivery cycle and are up to date.
  prefs: []
  type: TYPE_NORMAL
