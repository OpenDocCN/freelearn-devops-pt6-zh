- en: 3\. Application deployment on AKS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 在 AKS 上部署应用程序
- en: In this chapter, you will deploy two applications on **Azure Kubernetes Service** (**AKS**).
    An application consists of multiple parts, and you will build the applications
    one step at a time while the conceptual model behind them is explained. You will
    be able to easily adapt the steps in this chapter to deploy any other application
    on AKS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将在 **Azure Kubernetes Service**（**AKS**）上部署两个应用程序。一个应用程序由多个部分组成，你将一步一步地构建这些应用程序，同时解释它们背后的概念模型。你将能够轻松地将本章中的步骤应用到
    AKS 上部署任何其他应用程序。
- en: To deploy the applications and make changes to them, you will be using **YAML**
    files. YAML is a recursive acronym for **YAML Ain't Markup Language**. YAML is
    a language that is used to create configuration files to deploy to Kubernetes.
    Although you can use either JSON or YAML files to deploy applications to Kubernetes,
    YAML is the most commonly used language to do so. YAML became popular because
    it is easier for a human to read when compared to JSON or XML. You will see multiple
    examples of YAML files throughout this chapter and throughout the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署应用程序并对其进行更改，你将使用**YAML**文件。YAML 是 **YAML Ain't Markup Language** 的递归缩写。YAML
    是一种用于创建配置文件以部署到 Kubernetes 的语言。虽然你可以使用 JSON 或 YAML 文件将应用程序部署到 Kubernetes，但 YAML
    是最常用的语言。YAML 之所以受欢迎，是因为它比 JSON 或 XML 更易于人类阅读。你将在本章和整本书中看到多个 YAML 文件的示例。
- en: 'During the deployment of the sample guestbook application, you will see Kubernetes
    concepts in action. You will see how a **deployment** is linked to a **ReplicaSet**,
    and how that is linked to the **pods** that are deployed. A deployment is an object
    in Kubernetes that is used to define the desired state of an application. A **deployment**
    will create a ReplicaSet. A **ReplicaSet** is an object in Kubernetes that guarantees
    that a certain number of **pods** will always be available. Hence, a ReplicaSet
    will create one or more pods. A pod is an object in Kubernetes that is a group
    of one or more containers. Let''s revisit the relationship between deployments,
    ReplicaSets, and pods:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署示例的留言簿应用程序时，你将看到 Kubernetes 概念的实际应用。你将看到**部署**是如何与**ReplicaSet**关联的，且**ReplicaSet**又是如何与已部署的**pods**关联的。部署是
    Kubernetes 中的一个对象，用于定义应用程序的期望状态。**部署**将创建一个 ReplicaSet。**ReplicaSet**是 Kubernetes
    中的一个对象，确保始终有一定数量的**pods**可用。因此，ReplicaSet 将创建一个或多个 pods。Pod 是 Kubernetes 中的一个对象，它是一个或多个容器的集合。让我们再来看一下部署、ReplicaSets
    和 pods 之间的关系：
- en: '![Relationship showing that a deployment creates a replicaset, which in turn
    creates multiple pods](img/B17338_01_06.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![展示部署创建一个 replicaset，而 replicaset 又创建多个 pods 的关系](img/B17338_01_06.jpg)'
- en: 'Figure 3.1: Relationship between a deployment, a ReplicaSet, and pods'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：部署、ReplicaSet 和 pod 之间的关系
- en: While deploying the sample applications, you will use the **service** object
    to connect to the application. A service in Kubernetes is an object that is used
    to provide a static IP address and DNS name to an application. Since a pod can
    be killed and moved to different nodes in the cluster, a service ensures you can
    connect to a static endpoint for your application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署示例应用程序时，你将使用**service**对象连接到应用程序。Kubernetes 中的服务对象用于为应用程序提供一个静态的 IP 地址和 DNS
    名称。由于 pod 可能被销毁并移动到集群中的不同节点，服务确保你可以通过静态端点连接到应用程序。
- en: You will also edit the sample applications to provide configuration details
    using a **ConfigMap**. A ConfigMap is an object that is used to provide configuration
    details to pods. It allows you to keep configuration settings outside of the actual
    container. You can then provide these configuration details to your application
    by connecting the ConfigMap to your deployment.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将编辑示例应用程序，使用**ConfigMap**提供配置详细信息。ConfigMap 是一个对象，用于向 pod 提供配置信息。它允许你将配置设置保留在实际容器之外。然后，你可以通过将
    ConfigMap 连接到你的部署，将这些配置信息提供给你的应用程序。
- en: Finally, you will be introduced to Helm. Helm is a package manager for Kubernetes
    that helps to streamline the deployment process. You will deploy a WordPress site
    using Helm and gain an understanding of the value Helm brings to Kubernetes. This
    WordPress installation makes use of persistent storage in Kubernetes and you will
    learn how persistent storage in AKS is set up.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将接触到 Helm。Helm 是 Kubernetes 的一个包管理工具，帮助简化部署过程。你将使用 Helm 部署一个 WordPress 网站，并了解
    Helm 为 Kubernetes 带来的价值。这个 WordPress 安装使用了 Kubernetes 中的持久存储，你将学习如何在 AKS 中设置持久存储。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Deploying the sample guestbook application step by step
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分步部署示例留言簿应用程序
- en: Full deployment of the sample guestbook application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例留言簿应用程序的完整部署
- en: Using Helm to install complex Kubernetes applications
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Helm 安装复杂的 Kubernetes 应用程序
- en: We'll begin with the sample guestbook application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从示例留言簿应用程序开始。
- en: Deploying the sample guestbook application step by step
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分步部署示例留言簿应用程序
- en: In this chapter, you will deploy the classic guestbook sample Kubernetes application.
    You will be mostly following the steps from [https://kubernetes.io/docs/tutorials/stateless-application/guestbook/](https://kubernetes.io/docs/tutorials/stateless-application/guestbook/)
    with some modifications. You will employ these modifications to show additional
    concepts, such as ConfigMaps, that are not present in the original sample.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将部署经典的留言簿示例 Kubernetes 应用程序。你将主要按照 [https://kubernetes.io/docs/tutorials/stateless-application/guestbook/](https://kubernetes.io/docs/tutorials/stateless-application/guestbook/)
    上的步骤进行，并做一些修改。你将使用这些修改来展示一些额外的概念，例如 ConfigMaps，这些在原始示例中并未出现。
- en: The sample guestbook application is a simple, multi-tier web application. The
    different tiers in this application will have multiple instances. This is beneficial
    for both high availability and scalability. The guestbook's front end is a stateless
    application because the front end doesn't store any state. The Redis cluster in
    the back end is stateful as it stores all the guestbook entries.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 示例留言簿应用程序是一个简单的多层次 Web 应用程序。该应用程序中的不同层次将拥有多个实例。这对高可用性和可扩展性都非常有益。留言簿的前端是一个无状态应用程序，因为前端不存储任何状态。后端的
    Redis 集群是有状态的，因为它存储所有留言簿条目。
- en: You will be using this application as the basis for testing out the scaling
    of the back end and the front end, independently, in the next chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一章中使用该应用程序作为基础，测试后端和前端的独立扩展。
- en: Before we get started, let's consider the application that we'll be deploying.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们考虑一下我们将要部署的应用程序。
- en: Introducing the application
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍该应用程序
- en: The application stores and displays guestbook entries. You can use it to record
    the opinion of all the people who visit your hotel or restaurant, for example.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序存储和显示留言簿条目。你可以用它记录所有访问你酒店或餐馆的人的意见。
- en: '*Figure 3.2* shows you a high-level overview of the application. The application
    uses PHP as a front end. The front end will be deployed using multiple replicas.
    The application uses Redis for its data storage. Redis is an in-memory key-value
    database. Redis is most often used as a cache.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.2* 显示了该应用程序的高层概述。该应用程序使用 PHP 作为前端。前端将通过多个副本进行部署。该应用程序使用 Redis 进行数据存储。Redis
    是一个内存中的键值数据库。Redis 最常用作缓存。'
- en: '![Architecture of the multi-tier guestbook application](img/B17338_03_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![多层次留言簿应用程序的架构](img/B17338_03_02.jpg)'
- en: 'Figure 3.2: High-level overview of the guestbook application'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：留言簿应用程序的高层概述
- en: We will begin deploying this application by deploying the Redis master.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过部署 Redis 主节点开始部署该应用程序。
- en: Deploying the Redis master
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署 Redis 主节点
- en: In this section, you are going to deploy the Redis master. You will learn about
    the YAML syntax that is required for this deployment. In the next section, you
    will make changes to this YAML. Before making changes, let's start by deploying
    the Redis master.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将部署 Redis 主节点。你将学习此部署所需的 YAML 语法。在下一节中，你将对这个 YAML 进行更改。在进行更改之前，我们先开始部署
    Redis 主节点。
- en: 'Perform the following steps to complete the task:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成任务：
- en: Open your friendly Azure Cloud Shell, as highlighted in *Figure 3.3*:![Opening
    Cloud Shell from the Azure portal](img/B17338_03_03.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你友好的 Azure 云 Shell，如 *图 3.3* 所示：![从 Azure 门户打开云 Shell](img/B17338_03_03.jpg)
- en: 'Figure 3.3: Opening the Cloud Shell'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.3：打开云 Shell
- en: 'If you have not cloned the GitHub repository for this book, please do so now
    by using the following command:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有克隆本书的 GitHub 仓库，请现在使用以下命令进行克隆：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Change into the directory for Chapter 3 using the following command:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令切换到第 3 章的目录：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Enter the following command to deploy the master:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以部署主节点：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It will take some time for the application to download and start running. While
    you wait, let''s understand the command you just typed and executed. Let''s start
    by exploring the content of the YAML file that was used (the line numbers are
    used for explaining key elements from the code snippets):'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序下载并启动需要一些时间。等待时，让我们来理解一下你刚刚输入并执行的命令。我们先从探索用于该命令的 YAML 文件内容开始（行号用于解释代码片段中的关键元素）：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s dive deeper into the code line by line to understand the provided parameters:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们逐行深入分析代码，理解提供的参数：
- en: '`deployment` is given a name, which is `redis-master`.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deployment` 被命名为 `redis-master`。'
- en: '`app: redis, role: master, and tier: backend`). The preceding label exactly
    matches the labels provided in lines *14-19*.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app: redis, role: master, and tier: backend`）。前面的标签与第*14-19*行提供的标签完全匹配。'
- en: '`master`. In the case of a multi-container pod, each container in a pod requires
    a unique name.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`master`。在多容器 Pod 的情况下，每个容器都需要一个唯一的名称。'
- en: '`redis` image tagged with `e2e` (the latest Redis image that successfully passed
    its end-to-end [`e2e`] tests).'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redis` 镜像标记为 `e2e`（已通过端到端[`e2e`]测试的最新 Redis 镜像）。'
- en: '`cpu/memory` resources requested for the container. A request in Kubernetes
    is a reservation of resources that cannot be used by other pods. If those resources
    are not available in the cluster, the pod will not start. In this case, the request
    is 0.1 CPU, which is equal to `100m` and is also often referred to as 100 millicores.
    The memory requested is `100Mi`, or 104,857,600 bytes, which is equal to ~105
    MB. CPU and memory limits are set in a similar way. Limits are caps on what a
    container can use. If your pod hits the CPU limit, it''ll get throttled, whereas
    if it hits the memory limits, it''ll get restarted. Setting requests and limits
    is a best practice in Kubernetes. For more info, refer to [https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/](https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/).'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpu/memory` 为容器请求的资源。在 Kubernetes 中，资源请求是资源的保留，其他 Pod 无法使用这些资源。如果这些资源在集群中不可用，Pod
    将无法启动。在这种情况下，请求的是 0.1 CPU，等于 `100m`，也通常称为 100 毫核。请求的内存是 `100Mi`，即 104,857,600
    字节，约等于 105 MB。CPU 和内存限制以类似方式设置。限制是容器可以使用的最大资源。如果 Pod 达到 CPU 限制，它将被限制使用，而如果达到了内存限制，它将被重启。在
    Kubernetes 中，设置请求和限制是最佳实践。更多信息，请参见 [https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/](https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/)。'
- en: '`6379`.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6379`。'
- en: As you can see, the YAML definition for the deployment contains several settings
    and parameters that Kubernetes will use to deploy and configure your application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，部署的 YAML 定义包含多个 Kubernetes 将用于部署和配置应用程序的设置和参数。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Kubernetes YAML definition is similar to the arguments given to Docker
    to run a particular container image. If you had to run this manually, you would
    define this example in the following way:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的 YAML 定义类似于给 Docker 运行特定容器镜像时提供的参数。如果你需要手动运行该命令，你将以以下方式定义此示例：
- en: '`# Run a container named master, listening on port 6379, with 100M memory and
    100m CPU using the redis:e2e image.`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 运行一个名为 master 的容器，监听端口 6379，内存为 100M，CPU 为 100m，使用 redis:e2e 镜像。`'
- en: '`docker run --name master -p 6379:6379 -m 100M -c 100m -d k8s.gcr.io/redis:e2e`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run --name master -p 6379:6379 -m 100M -c 100m -d k8s.gcr.io/redis:e2e`'
- en: In this section, you have deployed the Redis master and learned about the syntax
    of the YAML file that was used to create this deployment. In the next section,
    you will examine the deployment and learn about the different elements that were
    created.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已经部署了 Redis 主节点，并了解了用于创建此部署的 YAML 文件的语法。在下一节中，你将检查部署并了解创建的不同元素。
- en: Examining the deployment
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查部署
- en: 'The `redis-master` deployment should be complete by now. Continue in the Azure
    Cloud Shell that you opened in the previous section and type the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`redis-master` 部署现在应该已完成。在你之前打开的 Azure Cloud Shell 中继续输入以下命令：'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You should get an output similar to the one displayed in *Figure 3.4*. In your
    case, the name of the pod and the ReplicaSet might contain different IDs at the
    end of the name. If you do not see a pod, a deployment, and a ReplicaSet, please
    run the code as explained in step 4 in the previous section again.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似于*图 3.4*中的输出。在你的情况中，Pod 和 ReplicaSet 的名称可能会在名称末尾包含不同的 ID。如果你没有看到 Pod、部署和
    ReplicaSet，请按照上一节第 4 步中的说明再次运行代码。
- en: '![A list of objects that were created by your deployment](img/B17338_03_04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![由你的部署创建的对象列表](img/B17338_03_04.jpg)'
- en: 'Figure 3.4: Objects that were created by your deployment'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：由你的部署创建的对象
- en: You can see that you created a deployment named `redis-master`. It controls
    a ReplicaSet named `redis-master-f46ff57fd`. On further examination, you will
    also find that the ReplicaSet is controlling a pod, `redis- master-f46ff57fd-b8cjp`.
    *Figure 3.1* has a graphical representation of this relationship.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到你创建了一个名为 `redis-master` 的部署。它控制一个名为 `redis-master-f46ff57fd` 的 ReplicaSet。进一步检查后，你还会发现该
    ReplicaSet 控制着一个 pod，`redis-master-f46ff57fd-b8cjp`。*图 3.1* 以图示方式展示了这种关系。
- en: 'More details can be obtained by executing the `kubectl describe <object> <instance-name>`
    command, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过执行 `kubectl describe <object> <instance-name>` 命令获取更多详细信息，如下所示：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will generate an output as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成如下输出：
- en: '![Using the kubectl describe command to fetch the details of the deployment](img/B17338_03_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用 kubectl describe 命令获取部署的详细信息](img/B17338_03_05.jpg)'
- en: 'Figure 3.5: Description of the deployment'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：部署的描述
- en: You have now launched a Redis master with the default configuration. Typically,
    you would launch an application with an environment-specific configuration.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经使用默认配置启动了一个 Redis 主节点。通常情况下，你会使用特定于环境的配置来启动应用程序。
- en: 'In the next section, you will get acquainted with a new concept called ConfigMaps
    and then recreate the Redis master. So, before proceeding, clean up the current
    version, which you can do by running the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，你将了解一个新概念，叫做 ConfigMap，并重建 Redis 主节点。因此，在继续之前，请清理当前版本，你可以通过运行以下命令来完成：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Executing this command will produce the following output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令将生成以下输出：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this section, you examined the Redis master deployment you created. You saw
    how a deployment relates to a ReplicaSet and how a ReplicaSet relates to pods.
    In the following section, you will recreate this Redis master with an environment-specific
    configuration provided via a ConfigMap.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你检查了所创建的 Redis 主节点部署。你看到了部署如何与 ReplicaSet 关联，ReplicaSet 又如何与 pods 关联。在接下来的部分，你将使用通过
    ConfigMap 提供的特定环境配置重新创建这个 Redis 主节点。
- en: Redis master with a ConfigMap
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有 ConfigMap 的 Redis 主节点
- en: There was nothing wrong with the previous deployment. In practical use cases,
    it would be rare that you would launch an application without some configuration
    settings. In this case, you are going to set the configuration settings for `redis-master`
    using a ConfigMap.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上一次的部署没有问题。在实际使用中，很少会在没有一些配置设置的情况下启动应用程序。在这种情况下，你将使用 ConfigMap 设置 `redis-master`
    的配置设置。
- en: A ConfigMap is a portable way of configuring containers without having specialized
    images for each environment. It has a key-value pair for data that needs to be
    set on a container. A ConfigMap is used for non-sensitive configuration. Kubernetes
    has a separate object called a **Secret**. A Secret is used for configurations
    that contain critical data such as passwords. This will be explored in detail
    in *Chapter 10, Storing Secrets in AKS* of this book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 是一种便携式配置容器的方式，无需为每个环境使用专门的镜像。它包含一个键值对，用于设置容器中的数据。ConfigMap 用于非敏感配置。Kubernetes
    还有一个单独的对象叫做 **Secret**。Secret 用于存储包含敏感数据（如密码）的配置。关于这一点将在本书的 *第10章，AKS中的秘密存储* 中详细探讨。
- en: 'In this example, you are going to create a ConfigMap. In this ConfigMap, you
    will configure `redis-config` as the key and the value will be the following two
    lines:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，你将创建一个 ConfigMap。在此 ConfigMap 中，你将配置 `redis-config` 作为键，值将是以下两行内容：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s create this ConfigMap. There are two ways to create a ConfigMap:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来创建这个 ConfigMap。有两种方法可以创建 ConfigMap：
- en: Creating a ConfigMap from a file
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件创建 ConfigMap
- en: Creating a ConfigMap from a YAML file
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 YAML 文件创建 ConfigMap
- en: In the following two sections, you'll explore both.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两部分中，你将探索这两种方法。
- en: Creating a ConfigMap from a file
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从文件创建 ConfigMap
- en: 'The following steps will help us create a ConfigMap from a file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助我们从文件创建 ConfigMap：
- en: 'Open the Azure Cloud Shell code editor by typing `code redis-config` in the
    terminal. Copy and paste the following two lines and save the file as `redis-config`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中输入 `code redis-config` 打开 Azure Cloud Shell 代码编辑器。复制并粘贴以下两行，并将文件保存为 `redis-config`：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now you can create the ConfigMap using the following code:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以使用以下代码创建 ConfigMap：
- en: '[PRE10]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should get an output as follows:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该获得如下输出：
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can use the same command to describe this ConfigMap:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用相同的命令描述此 ConfigMap：
- en: '[PRE12]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output will be as shown in *Figure 3.6*:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如 *图 3.6* 所示：
- en: '![Using the kubectl describe command to fetch the description of the ConfigMap](img/B17338_03_06.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![使用 kubectl describe 命令获取 ConfigMap 的描述](img/B17338_03_06.jpg)'
- en: 'Figure 3.6: Description of the ConfigMap'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：ConfigMap 描述
- en: In this example, you created the ConfigMap by referring to a file on disk. A
    different way to deploy ConfigMaps is by creating them from a YAML file. Let's
    have a look at how this can be done in the following section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你通过引用磁盘上的文件来创建了 ConfigMap。另一种部署 ConfigMap 的方式是通过从 YAML 文件中创建它们。让我们在下一节中看看如何做到这一点。
- en: Creating a ConfigMap from a YAML file
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 YAML 文件创建 ConfigMap
- en: 'In this section, you will recreate the ConfigMap from the previous section
    using a YAML file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将使用 YAML 文件重新创建上一节中的 ConfigMap：
- en: 'To start, delete the previously created ConfigMap:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，删除先前创建的 ConfigMap：
- en: '[PRE13]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Copy and paste the following lines into a file named `example-redis-config.yaml`,
    and then save the file:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容复制并粘贴到名为 `example-redis-config.yaml` 的文件中，然后保存：
- en: '[PRE14]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can now create your ConfigMap via the following command:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以通过以下命令创建你的 ConfigMap：
- en: '[PRE15]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should get an output as follows:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该会得到如下输出：
- en: '[PRE16]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, run the following command:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令：
- en: '[PRE17]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This command returns the same output as the previous one, as shown in *Figure 3.6*.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令返回与之前相同的输出，如 *图 3.6* 所示。
- en: As you can see, using a YAML file, you were able to create the same ConfigMap.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过使用 YAML 文件，你成功创建了相同的 ConfigMap。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`kubectl get` has the useful `-o` option, which can be used to get the output
    of an object in either YAML or JSON. This is very useful in cases where you have
    made manual changes to a system and want to see the resulting object in YAML format.
    You can get the current ConfigMap in YAML using the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get` 具有有用的 `-o` 选项，可以用来获取对象的输出，无论是 YAML 还是 JSON 格式。这在你手动更改系统并希望查看结果对象的
    YAML 格式时非常有用。你可以使用以下命令获取当前 ConfigMap 的 YAML 输出：'
- en: '`kubectl get -o yaml configmap/example-redis-config`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get -o yaml configmap/example-redis-config`'
- en: Now that you have the ConfigMap defined, let's use it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了 ConfigMap，接下来我们来使用它。
- en: Using a ConfigMap to read in configuration data
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ConfigMap 读取配置数据
- en: 'In this section, you will reconfigure the `redis-master` deployment to read
    configuration from the ConfigMap:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将重新配置 `redis-master` 部署，以从 ConfigMap 读取配置：
- en: 'To start, modify `redis-master-deployment.yaml` to use the ConfigMap as follows.
    The changes you need to make will be explained after the source code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，修改 `redis-master-deployment.yaml` 以使用 ConfigMap，修改方法如下。你需要做的更改将在源代码后解释：
- en: '[PRE18]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If you downloaded the source code accompanying this book, there is a file in
    *Chapter 3, Application deployment on AKS*, called `redis-master-deployment_Modified.yaml`,
    that has the necessary changes applied to it.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你下载了本书的源代码，在 *第 3 章，应用程序在 AKS 上部署* 中，有一个文件叫做 `redis-master-deployment_Modified.yaml`，其中应用了必要的更改。
- en: 'Let''s dive deeper into the code to understand the different sections:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们深入分析代码，理解不同的部分：
- en: '`redis-server` pointing to a specific configuration file.'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redis-server` 指向特定的配置文件。'
- en: '`docker run -e "MASTER=true". --name master -p 6379:6379 -m 100M -c 100m -d
    Kubernetes /redis:v1`. This sets the environment variable `MASTER` to `true`.
    Your application can read the environment variable settings for its configuration.'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker run -e "MASTER=true". --name master -p 6379:6379 -m 100M -c 100m -d
    Kubernetes /redis:v1`。这将环境变量 `MASTER` 设置为 `true`。你的应用程序可以读取环境变量设置来进行配置。'
- en: '`config` (this volume is defined in lines 39-45) on the `/redis-master` path
    on the running container. It will hide whatever exists on `/redis-master` on the
    original container.'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`（该卷在第 39-45 行定义）位于正在运行的容器中的 `/redis-master` 路径。它将隐藏原容器中 `/redis-master`
    上的内容。'
- en: In Docker terms, it would be equivalent to `docker run -v config:/redis-master.
    -e "MASTER=TRUE" --name master -p 6379:6379 -m 100M -c 100m -d Kubernetes /redis:v1`.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用 Docker 的术语来说，这等同于 `docker run -v config:/redis-master. -e "MASTER=TRUE" --name
    master -p 6379:6379 -m 100M -c 100m -d Kubernetes /redis:v1`。
- en: '`config`. This name will be used within the context of this pod.'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`。这个名称将在该 pod 的上下文中使用。'
- en: '`example-redis-config` ConfigMap. This ConfigMap should already exist in the
    system. You have already defined this, so you are good.'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`example-redis-config` ConfigMap。该 ConfigMap 应该已经存在于系统中。你已经定义了它，所以一切正常。'
- en: '`redis-config` key (the two-line `maxmemory` settings) as a `redis.conf` file.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redis-config` 键（两行 `maxmemory` 设置）作为 `redis.conf` 文件。'
- en: By adding the ConfigMap as a volume and mounting the volume, you are able to
    load dynamic configuration.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 ConfigMap 作为卷添加并挂载卷，你可以加载动态配置。
- en: 'Let''s create this updated deployment:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建这个更新后的部署：
- en: '[PRE19]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should output the following:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该输出以下内容：
- en: '[PRE20]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s now make sure that the configuration was successfully applied. First,
    get the pod''s name:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们确认配置是否成功应用。首先，获取 Pod 的名称：
- en: '[PRE21]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This should return an output similar to *Figure 3.7*:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该返回类似于*图 3.7*的输出：
- en: '![Fetching the details of the Redis-master pod using the kubectl get pods command](img/B17338_03_07.jpg)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用 kubectl get pods 命令获取 Redis-master Pod 的详细信息](img/B17338_03_07.jpg)'
- en: 'Figure 3.7: Details of the pod'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.7：Pod 详情
- en: 'Then `exec` into the pod and verify that the settings were applied:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后 `exec` 进入 Pod 并验证设置是否已应用：
- en: '[PRE22]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This open a `redis-cli` session with the running pod. Now you can get the `maxmemory`
    configuration:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会打开一个与正在运行的 Pod 连接的 `redis-cli` 会话。现在你可以获取 `maxmemory` 配置：
- en: '[PRE23]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And then you can get the `maxmemory-policy` configuration:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后你可以获取 `maxmemory-policy` 配置：
- en: '[PRE24]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This should give you an output similar to *Figure 3.8*:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该给你类似于*图 3.8*的输出：
- en: '![Verifying the maxmemoery and maxmemory-policy custom configuration](img/B17338_03_08.jpg)'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![验证 maxmemory 和 maxmemory-policy 自定义配置](img/B17338_03_08.jpg)'
- en: 'Figure 3.8: Verifying the Redis configuration in the pod'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.8：在 Pod 中验证 Redis 配置
- en: To leave the Redis shell, type the `exit` command.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要离开 Redis shell，请键入 `exit` 命令。
- en: To summarize, you have just performed an important part of configuring cloud-native
    applications, namely providing dynamic configuration data to an application. You
    will have also noticed that the apps have to be configured to read config dynamically.
    After you set up your app with configuration, you accessed a running container
    to verify the running configuration. You will use this methodology frequently
    throughout this book to verify the functionality of running applications.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，你刚刚完成了配置云原生应用程序的重要步骤，即为应用程序提供动态配置数据。你还会注意到，应用程序必须配置为动态读取配置。在你设置应用程序配置后，你访问了一个运行中的容器来验证运行配置。你将在本书中频繁使用这种方法来验证正在运行的应用程序的功能。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Connecting to a running container by using the `kubectl exec` command is useful
    for troubleshooting and doing diagnostics. Due to the ephemeral nature of containers,
    you should never connect to a container to do additional configuration or installation.
    This should either be part of your container image or configuration you provide
    via Kubernetes (as you just did).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl exec` 命令连接到正在运行的容器对于故障排除和诊断非常有用。由于容器是短暂的，绝不要通过连接容器来进行额外的配置或安装。这些应该是容器镜像的一部分，或者是通过
    Kubernetes 提供的配置（就像你刚才做的那样）。
- en: In this section, you configured the Redis master to load configuration data
    from a ConfigMap. In the next section, we will deploy the end-to-end application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你配置了 Redis 主服务从 ConfigMap 加载配置数据。在下一节中，我们将部署端到端应用程序。
- en: Complete deployment of the sample guestbook application
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整部署示例访客簿应用程序
- en: Having taken a detour to understand the dynamic configuration of applications
    using a ConfigMap, you will now return to the deployment of the rest of the guestbook
    application. You will once again come across the concepts of deployment, ReplicaSets,
    and pods. Apart from this, you will also be introduced to another key concept,
    called a service.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过绕道了解使用 ConfigMap 动态配置应用程序后，你将返回到部署其余访客簿应用程序的部分。你将再次遇到部署、ReplicaSets 和 Pod
    的概念。除此之外，你还将接触到另一个关键概念——服务。
- en: To start the complete deployment, we are going to create a service to expose
    the Redis master service.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动完整部署，我们将创建一个服务来暴露 Redis 主服务。
- en: Exposing the Redis master service
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暴露 Redis 主服务
- en: When exposing a port in plain Docker, the exposed port is constrained to the
    host it is running on. With Kubernetes networking, there is network connectivity
    between different pods in the cluster. However, pods themselves are ephemeral
    in nature, meaning they can be shut down, restarted, or even moved to other hosts
    without maintaining their IP address. If you were to connect to the IP of a pod
    directly, you might lose connectivity if that pod was moved to a new host.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通 Docker 中暴露端口时，暴露的端口仅限于运行该容器的主机。使用 Kubernetes 网络时，集群中的不同 Pod 之间有网络连接。然而，Pod
    本身是短暂的，意味着它们可以被关闭、重启，甚至移到其他主机而不保持其 IP 地址。如果你直接连接到 Pod 的 IP 地址，如果该 Pod 被移到新主机，可能会失去连接。
- en: 'Kubernetes provides the `service` object, which handles this exact problem.
    Using label-matching selectors, it sends traffic to the right pods. If there are
    multiple pods serving traffic to a service, it will also do load balancing. In
    this case, the master has only one pod, so it just ensures that the traffic is
    directed to the pod independent of the node the pod runs on. To create the service,
    run the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了 `service` 对象，用于解决这个问题。通过使用标签匹配选择器，它将流量发送到正确的 pods。如果有多个 pods
    为一个服务提供流量，它还会进行负载均衡。在这种情况下，主节点只有一个 pod，所以它确保流量无论 pod 运行在哪个节点上，都会被定向到该 pod。要创建服务，请运行以下命令：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `redis-master-service.yaml` file has the following content:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`redis-master-service.yaml` 文件包含以下内容：'
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s now see what you have created using the preceding code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看您使用前面的代码创建了什么：
- en: '`redis-master`, which has the same labels as our `redis-master` server pod.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redis-master`，它具有与我们的 `redis-master` 服务器 pod 相同的标签。'
- en: '`6379` and forward it to port `6379` of the pods that match the selector defined
    between lines 13 and 16.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `6379` 端口转发到与第 13 行到第 16 行之间定义的选择器匹配的 pods 的 `6379` 端口。
- en: '`app: redis, role: master and tier: backend`) is expected to handle port `6379`
    traffic. If you look back at the previous example, those are the exact labels
    we applied to that deployment.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app: redis, role: master and tier: backend`）预计处理 `6379` 端口流量。如果回顾前面的示例，这些正是我们应用于该部署的标签。'
- en: 'You can check the properties of the service by running the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令检查服务的属性：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will give you an output as shown in *Figure 3.9*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您提供一个输出，如 *图 3.9* 所示：
- en: '![Obtaining the properties of the Redis-master service using the kubectl get
    service command](img/B17338_03_09.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![使用 kubectl get service 命令获取 Redis-master 服务的属性](img/B17338_03_09.jpg)'
- en: 'Figure 3.9: Properties of the created service'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9：创建的服务的属性
- en: You see that a new service, named `redis-master`, has been created. It has a
    Cluster-IP of `10.0.106.207` (in your case, the IP will likely be different).
    Note that this IP will work only within the cluster (hence the `ClusterIP` type).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到已创建一个名为 `redis-master` 的新服务。它的 Cluster-IP 为 `10.0.106.207`（在您的情况下，IP 可能不同）。请注意，这个
    IP 仅在集群内部有效（因此是 `ClusterIP` 类型）。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You are now creating a service of type `ClusterIP`. There are other types of
    service as well, which will be introduced later in this chapter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您正在创建一个 `ClusterIP` 类型的服务。后续章节将介绍其他类型的服务。
- en: 'A service also introduces a `<service-name>.<namespace>.svc.cluster.local`;
    in this case, it would be `redis-master.default.svc.cluster.local`. To see this
    in action, we''ll do a name resolution on our `redis-master` pod. The default
    image doesn''t have `nslookup` installed, so we''ll bypass that by running a `ping`
    command. Don''t worry if that traffic doesn''t return; this is because you didn''t
    expose `ping` on your service, only the `redis` port. The command is, however,
    useful to see the full DNS name and the name resolution work. Let''s have a look:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 服务还会引入一个 `<service-name>.<namespace>.svc.cluster.local`；在本例中，它将是 `redis-master.default.svc.cluster.local`。为了查看这个功能，我们将在
    `redis-master` pod 上进行域名解析。默认镜像没有安装 `nslookup`，所以我们通过运行 `ping` 命令来绕过这一点。如果该流量没有返回，请不要担心；这是因为您没有在服务中暴露
    `ping`，只暴露了 `redis` 端口。然而，这个命令对于查看完整的 DNS 名称以及域名解析的工作非常有用。让我们来看一下：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This should output the resulting name resolution, showing you the `exit` command,
    as shown in *Figure 3.10*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会输出结果的名称解析，显示 `exit` 命令，如 *图 3.10* 所示：
- en: '![Using a ping command to view the FQDN of your service](img/B17338_03_10.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![使用 ping 命令查看服务的 FQDN](img/B17338_03_10.jpg)'
- en: 'Figure 3.10: Using a ping command to view the FQDN of your service'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10：使用 ping 命令查看服务的 FQDN
- en: In this section, you exposed the Redis master using a service. This ensures
    that even if a pod moves to a different host, it can be reached through the service's
    IP address. In the next section, you will deploy the Redis replicas, which help
    to handle more read traffic.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您通过服务暴露了 Redis 主节点。这确保了即使一个 pod 移动到不同的主机，也可以通过服务的 IP 地址访问。在下一节中，您将部署 Redis
    副本，它们有助于处理更多的读取流量。
- en: Deploying the Redis replicas
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署 Redis 副本
- en: Running a single back end on the cloud is not recommended. You can configure
    Redis in a leader-follower (master-slave) setup. This means that you can have
    a master that will serve write traffic and multiple replicas that can handle read
    traffic. It is useful for handling increased read traffic and high availability.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在云端运行单一后端并不推荐。你可以将 Redis 配置为主从（leader-follower）模式。这意味着你可以有一个主节点处理写操作流量，多个副本处理读操作流量。这有助于处理增加的读流量和提高可用性。
- en: 'Let''s set this up:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来配置这个：
- en: 'Create the deployment by running the following command:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建部署：
- en: '[PRE29]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s check all the resources that have been created now:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查一下当前已创建的所有资源：
- en: '[PRE30]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output would be as shown in *Figure 3.11*:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如*图 3.11*所示：
- en: '![Using the kubectl get all command to show all objects created](img/B17338_03_11.jpg)'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用 kubectl get all 命令显示所有已创建的对象](img/B17338_03_11.jpg)'
- en: 'Figure 3.11: Deploying the Redis replicas creates a number of new objects'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.11：部署 Redis 副本会创建多个新对象
- en: 'Based on the preceding output, you can see that you created two replicas of
    the `redis-replica` pods. This can be confirmed by examining the `redis-replica-
    deployment.yaml` file:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据之前的输出，你可以看到你创建了两个 `redis-replica` Pods 的副本。可以通过查看 `redis-replica-deployment.yaml`
    文件来确认这一点：
- en: '[PRE31]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Everything is the same except for the following:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了以下几点，其余部分都是相同的：
- en: '`GET_HOSTS_FROM` to `dns`. This is a setting that specifies that Redis should
    get the hostname of the master using DNS.'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `GET_HOSTS_FROM` 设置为 `dns`。这是一个设置，指定 Redis 应该使用 DNS 获取主节点的主机名。
- en: As you can see, this is similar to the Redis master you created earlier.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，这与之前创建的 Redis 主节点类似。
- en: 'Like the master service, you need to expose the replica service by running
    the following:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与主服务一样，你需要通过运行以下命令暴露副本服务：
- en: '[PRE32]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The only difference between this service and the `redis-master` service is that
    this service proxies traffic to pods that have the `role:replica` label.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个服务和 `redis-master` 服务的唯一不同之处在于，它将流量代理到具有 `role:replica` 标签的 Pods。
- en: 'Check the `redis-replica` service by running the following command:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令检查 `redis-replica` 服务：
- en: '[PRE33]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This should give you the output shown in *Figure 3.12*:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将给出*图 3.12*中所示的输出：
- en: '![Redis master and Redis replica configuration details](img/B17338_03_12.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Redis 主节点与 Redis 副本配置详细信息](img/B17338_03_12.jpg)'
- en: 'Figure 3.12: Redis-master and redis-replica service'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12：Redis-master 和 redis-replica 服务
- en: You now have a Redis cluster up and running, with a single master and two replicas.
    In the next section, you will deploy and expose the front end.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有一个运行中的 Redis 集群，其中包含一个主节点和两个副本。在接下来的部分，你将部署并暴露前端。
- en: Deploying and exposing the front end
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署并暴露前端
- en: Up to now, you have focused on the Redis back end. Now you are ready to deploy
    the front end. This will add a graphical web page to your application that you'll
    be able to interact with.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你主要集中在 Redis 后端。现在你已经准备好部署前端了。这将为你的应用程序添加一个可以交互的图形网页。
- en: 'You can create the front end using the following command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令创建前端：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To verify the deployment, run this command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证部署，请运行以下命令：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will display the output shown in *Figure 3.13*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示在*图 3.13*中展示的输出：
- en: '![Details of the frontend deployment](img/B17338_03_13.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![前端部署详细信息](img/B17338_03_13.jpg)'
- en: 'Figure 3.13: Verifying the front end deployment'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13：验证前端部署
- en: 'You will notice that this deployment specifies `3` replicas. The deployment
    has the usual aspects with minor changes, as shown in the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，这个部署指定了`3`个副本。这个部署有通常的组成部分，只有少许改动，如下代码所示：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s see these changes:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这些变化：
- en: '**Line 11**: The replica count is set to 3.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 11 行**：副本数量设置为 3。'
- en: '`app: guestbook` and `tier: frontend`.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app: guestbook` 和 `tier: frontend`。'
- en: '`gb-frontend:v4` is used as the image.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `gb-frontend:v4` 作为镜像。
- en: You have now created the front-end deployment. You now need to expose it as
    a service.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经创建了前端部署。接下来，你需要将其暴露为服务。
- en: Exposing the front-end service
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暴露前端服务
- en: 'There are multiple ways to define a Kubernetes service. The two Redis services
    we created were of the type `ClusterIP`. This means they are exposed on an IP
    that is reachable only from the cluster, as shown in *Figure 3.14*:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 Kubernetes 服务有多种方式。我们创建的两个 Redis 服务都是 `ClusterIP` 类型。这意味着它们在一个仅能从集群内部访问的
    IP 上暴露，如*图 3.14*所示：
- en: '![Kubernetes service of type ClusterIP](img/B17338_03_14.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![Kubernetes ClusterIP 类型服务](img/B17338_03_14.jpg)'
- en: 'Figure 3.14: Kubernetes service of type ClusterIP'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14：Kubernetes ClusterIP 类型服务
- en: 'Another type of service is the type `NodePort`. A service of type NodePort
    is accessible from outside the cluster, by connecting to the IP of a node and
    the specified port. This service is exposed on a static port on each node as shown
    in *Figure 3.15*:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![Kubernetes service of type NodePort](img/B17338_03_15.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.15: Kubernetes service of type NodePort'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'A final type – which will be used in this example – is the `LoadBalancer` type.
    This will create an **Azure Load Balancer** that will get a public IP that you
    can use to connect to, as shown in *Figure 3.16*:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![Kubernetes service of type LoadBalancer](img/B17338_03_16.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: Kubernetes service of type LoadBalancer'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will help you to understand how the frontend service is
    exposed:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This definition is similar to the services you created earlier, except that
    in *line 9* you defined `type: Load Balancer`. This will create a service of that
    type, which will cause AKS to add rules to the Azure load balancer.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have seen how a front-end service is exposed, let''s make the
    guestbook application ready for use with the following steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the service, run the following command:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This step takes some time to execute when you run it for the first time. In
    the background, Azure must perform a couple of actions to make it seamless. It
    has to create an Azure load balancer and a public IP and set the port-forwarding
    rules to forward traffic on port `80` to internal ports of the cluster.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following until there is a value in the `EXTERNAL-IP` column:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This should display the output shown in *Figure 3.17*:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Fetching the external IP value of the front-end deployment](img/B17338_03_17.jpg)'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 3.17: External IP value'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the Azure portal, if you click on All Resources and filter on Load balancer,
    you will see a kubernetes Load balancer. Clicking on it shows you something similar
    to *Figure 3.18*. The highlighted sections show you that there is a load balancing
    rule accepting traffic on `port 80` and you have two public IP addresses:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Azure load balancer showing the load balancing rule accepting traffic on
    port 80 ](img/B17338_03_18.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.18: kubernetes Load balancer in the Azure portal'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: If you click through on the two public IP addresses, you'll see both IP addresses
    linked to your cluster. One of those will be the IP address of your actual front-end
    service; the other one is used by AKS to make outbound connections.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Azure has two types of load balancers: basic and standard.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Virtual machines behind a basic load balancer can make outbound connections
    without any specific configuration. Virtual machines behind a standard load balancer
    (which is the default for AKS now) need an outbound rule on the load balancer
    to make outbound connections. This is why you see a second IP address configured.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: You're finally ready to see your guestbook app in action!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The guestbook application in action
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Type the public IP of the service in your favorite browser. You should get
    the output shown in *Figure 3.19*:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the public IP address to see the Guestbook application in action](img/B17338_03_19.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.19: The guestbook application in action'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and record your messages. They will be saved. Open another browser
    and type the same IP; you will see all the messages you typed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations – you have completed your first fully deployed, multi-tier,
    cloud-native Kubernetes application!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'To conserve resources on your free-trial virtual machines, it is better to
    delete the created deployments to run the next round of the deployments by using
    the following commands:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Over the course of the preceding sections, you have deployed a Redis cluster
    and deployed a publicly accessible web application. You have learned how deployments,
    ReplicaSets, and pods are linked, and you have learned how Kubernetes uses the
    `service` object to route network traffic. In the next section of this chapter,
    you will use Helm to deploy a more complex application on top of Kubernetes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Installing complex Kubernetes applications using Helm
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you used static YAML files to deploy an application.
    When deploying more complicated applications, across multiple environments (such
    as dev/test/prod), it can become cumbersome to manually edit YAML files for each
    environment. This is where the Helm tool comes in.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Helm is the package manager for Kubernetes. Helm helps you deploy, update, and
    manage Kubernetes applications at scale. For this, you write something called
    Helm Charts.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: You can think of Helm Charts as parameterized Kubernetes YAML files. If you
    think about the Kubernetes YAML files we wrote in the previous section, those
    files were static. You would need to go into the files and edit them to make changes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Helm Charts allow you to write YAML files with certain parameters in them, which
    you can dynamically set. This setting of the parameters can be done through a
    values file or as a command-line variable when you deploy the chart.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Finally, with Helm, you don't necessarily have to write Helm Charts yourself;
    you can also use a rich library of pre-written Helm Charts and install popular
    software in your cluster through a simple command such as `helm install --name
    my-release stable/mysql`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what you are going to do in the next section. You will install
    WordPress on your cluster by issuing only two commands. In the next chapters,
    you'll also dive into custom Helm Charts that you'll edit.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On November 13, 2019, the first stable release of Helm v3 was released. We will
    be using Helm v3 in the following examples. The biggest difference between Helm
    v2 and Helm v3 is that Helm v3 is a fully client-side tool that no longer requires
    the server-side tool called **Tiller**.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by installing WordPress on your cluster using Helm. In this section,
    you'll also learn about persistent storage in Kubernetes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Installing WordPress using Helm
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned in the introduction, Helm has a rich library of pre-written Helm
    Charts. To access this library, you''ll have to add a repo to your Helm client:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the repo that contains the stable Helm Charts using the following command:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To install WordPress, run the following command:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This execution will cause Helm to install the chart detailed at [https://github.com/bitnami/charts/tree/master/bitnami/wordpress](https://github.com/bitnami/charts/tree/master/bitnami/wordpress).
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It takes some time for Helm to install and the site to come up. Let's look at
    a key concept, `PersistentVolumeClaims`, while the site is loading. After covering
    this, we'll go back and look at your site that got created.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: PersistentVolumeClaims
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A typical process requires compute, memory, network, and storage. In the guestbook
    example, we saw how Kubernetes helps us abstract the compute, memory, and network.
    The same YAML files work across all cloud providers, including a cloud-specific
    setup of public-facing load balancers. The WordPress example shows how the last
    piece, namely storage, is abstracted from the underlying cloud provider.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the WordPress Helm Chart depends on the MariaDB helm chart ([https://github.com/bitnami/charts/tree/master/bitnami/mariadb](https://github.com/bitnami/charts/tree/master/bitnami/mariadb))
    for its database installation.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Unlike stateless applications, such as our front ends, MariaDB requires careful
    handling of storage. To make Kubernetes handle stateful workloads, it has a specific
    object called a `<pod-name>-#`, where `#` starts from `0` for the first pod, and
    `1` for the second pod.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the following command, you can see that MariaDB has a predictable number
    attached to it, whereas the WordPress deployment has a random number attached
    to the end:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will generate the output shown in *Figure 3.20*:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '![Naming of pods using a StatefulSet](img/B17338_03_20.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.20: Numbers attached to MariaDB and WordPress pods'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The numbering reinforces the ephemeral nature of the deployment pods versus
    the StatefulSet pods.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is how pod deletion is handled. When a deployment pod is
    deleted, Kubernetes will launch it again anywhere it can, whereas when a StatefulSet
    pod is deleted, Kubernetes will relaunch it only on the node it was running on.
    It will relocate the pod only if the node is removed from the Kubernetes cluster.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Often, you will want to attach storage to a StatefulSet. To achieve this, a
    StatefulSet requires a **PersistentVolume** (**PV**). This volume can be backed
    by many mechanisms (including blocks, such as Azure Blob, EBS, and iSCSI, and
    network filesystems, such as AFS, NFS, and GlusterFS). StatefulSets require either
    a pre-provisioned volume or a dynamically provisioned volume handled by a **PersistentVolumeClaim**
    (**PVC**). A PVC allows a user to dynamically request storage, which will result
    in a PV being created.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to [https://kubernetes.io/docs/concepts/storage/persistent-volumes/](https://kubernetes.io/docs/concepts/storage/persistent-volumes/)
    for more detailed information.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'In this WordPress example, you are using a PVC. A PVC provides an abstraction
    over the underlying storage mechanism. Let''s look at what the MariaDB Helm Chart
    did by running the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding command, you got the YAML definition of the StatefulSet that
    was created and stored it in a file called `mariadbss.yaml`. Let''s look at the
    most relevant parts of that YAML file. The code has been truncated to only show
    the most relevant parts:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Most of the elements of the preceding code have been covered earlier in the
    deployment. In the following points, we will highlight the key differences, to
    take a look at just the PVC:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: PVC can be used by any pod, not just StatefulSet pods.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the different elements of the preceding code in detail:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '`StatefulSet` declaration.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data` and mount it under the `/bitnami/mariadb` path.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`, which is reused at *line 285*.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadWriteOnce`, which will create block storage, which on Azure is a disk.
    There are other access modes as well, namely `ReadOnlyMany` and `ReadWriteMany`.
    As the name suggests, a `ReadWriteOnce` volume can only be attached to a single
    pod, while a `ReadOnlyMany` or `ReadWriteMany` volume can be attached to multiple
    pods at the same time. These last two types require a different underlying storage
    mechanism such as Azure Files or Azure Blob.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 321**: This line defines the size of the disk.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on the preceding information, Kubernetes dynamically requests and binds
    an 8 GiB volume to this pod. In this case, the default dynamic-storage provisioner
    backed by the Azure disk is used. The dynamic provisioner was set up by Azure
    when you created the cluster. To see the storage classes available on your cluster,
    you can run the following command:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will show you an output similar to *Figure 3.21*:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![List of storage classes available on your cluster](img/B17338_03_21.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.21: Different storage classes in your cluster'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get more details about the PVC by running the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output generated is displayed in *Figure 3.22*:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![A list of PVCs in the created cluster](img/B17338_03_22.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.22: Different PVCs in the cluster'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'When we asked for storage in the StatefulSet description (*lines 128-143*),
    Kubernetes performed Azure-disk-specific operations to get the Azure disk with
    8 GiB of storage. If you copy the name of the PVC and paste that in the Azure
    search bar, you should find the disk that was created:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting the disk linked to a PVC](img/B17338_03_23.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.23: Getting the disk linked to a PVC'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a PVC abstracts cloud provider storage specifics. This allows
    the same Helm template to work across Azure, AWS, or GCP. On AWS, it will be backed
    by **Elastic Block Store** (**EBS**), and on GCP it will be backed by Persistent
    Disk.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that PVCs can be deployed without using Helm.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: In this section, the concept of storage in Kubernetes using **PersistentVolumeClaim**
    (**PVC**) was introduced. You saw how they were created by the WordPress Helm
    deployment, and how Kubernetes created an Azure disk to support the PVC used by
    MariaDB. In the next section, you will explore the WordPress application on Kubernetes
    in more detail.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Checking the WordPress deployment
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After our analysis of the PVCs, let''s check back in with the Helm deployment.
    You can check the status of the deployment using:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This should return the output shown in *Figure 3.24*:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking status of the WordPress application deployment in Helm](img/B17338_03_24.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.24: WordPress application deployment status'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get more info from our deployment in Helm using the following command:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will return the output shown in *Figure 3.25*:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![Fetching further details of the WordPress deployment using the helm status
    command](img/B17338_03_25.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.25: Getting more details about the deployment'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows you that your chart was deployed successfully. It also shows more
    info on how you can connect to your site. You won''t be using these steps for
    now; you will revisit these steps in *Chapter 5, Handling common failures in AKS*,
    in the section where we cover fixing storage mount issues. For now, let''s look
    into everything that Helm created for you:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This will generate an output similar to *Figure 3.26*:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![List of objects created by Helm](img/B17338_03_26.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.26: List of objects created by Helm'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have an external IP yet, wait for a couple of minutes and retry
    the command.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then go ahead and connect to your external IP and access your WordPress
    site. *Figure 3.27* is the resulting output:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to the WordPress site using the external IP](img/B17338_03_27.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.27: WordPress site being displayed on connection with the external
    IP'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure you don''t run into issues in the following chapters, let''s delete
    the WordPress site. This can be done in the following way:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'By design, the PVCs won''t be deleted. This ensures persistent data is kept.
    As you don''t have any persistent data, you can safely delete the PVCs as well:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Be very careful when executing `kubectl delete <object> --all` as it will delete all
    the objects in a namespace. This is not recommended on a production cluster.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have deployed a full WordPress site using Helm. You also
    learned how Kubernetes handles persistent storage using PVCs.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you deployed two applications. You started the chapter by deploying
    the guestbook application. During that deployment, the details of pods, ReplicaSets,
    and deployments were explored. You also used dynamic configuration using ConfigMaps.
    Finally, you looked into how services are used to route traffic to the deployed
    applications.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: The second application you deployed was a WordPress application. You deployed
    it via the Helm package manager. As part of this deployment, PVCs were used, and
    you explored how they were used in the system and how they were linked to disks
    on Azure.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你部署的第二个应用程序是WordPress应用程序。你通过Helm包管理器部署了它。在这次部署中，使用了PVC，并且你探索了它们如何在系统中使用，以及如何与Azure上的磁盘关联。
- en: In *Chapter 4, Building scalable applications*, you will look into scaling applications
    and the cluster itself. You will first learn about the manual and automatic scaling
    of the application, and afterward, you'll learn about the manual and automatic
    scaling of the cluster itself. Finally, different ways in which applications can
    be updated on Kubernetes will be explained.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4章，构建可扩展应用程序*中，你将探讨如何扩展应用程序及其集群。你将首先学习应用程序的手动和自动扩展，之后，你将学习集群本身的手动和自动扩展。最后，将解释应用程序在Kubernetes上的不同更新方式。
