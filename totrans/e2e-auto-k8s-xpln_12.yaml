- en: '*Chapter 9*: Using Helm, Kustomize, and KubeVela'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter concentrates mainly on configuration management for bespoke applications.
    The Kubernetes configuration for bespoke applications includes deployment, service,
    ingress, secret, configmaps, tags needed for governance, cross-cutting concerns,
    application security context, and other dependencies. Managing these configurations
    requires carefully choosing patterns and tools that fit the use case. Also, we
    must keep reuse, team collaboration, and scalability in mind. In the previous
    chapter, we lightly touched on a few tools such as Helm, Kustomize, and KubeVela
    for application configuration management. This chapter will be an opportunity
    to explore these tools in more detail.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in the chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Application configuration management capabilities
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Helm for application deployment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hands-on chart development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing configurations with Kustomize
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying application workloads with KubeVela
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application configuration management capabilities
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operating an application successfully in the Kubernetes environment requires
    a few capabilities from the perspective of configuration management. Here is a
    list of critical configuration management capabilities:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**Packaging**: As discussed several times, deploying an application into Kubernetes
    involves configuring multiple resources. It requires a capability where we can
    package all these resources into a single bundle.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Life cycle management**: An application and all its dependencies must be
    executed into the cluster as a single deployment supporting the required release
    management constructs such as rollout, rollback, version management, and blue-green
    deployment.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application discovery**: This is a capability that is required for day-to-day
    operations. It will enable any discovery tools to dashboard a list of applications
    deployed, their version, and dependencies.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application description customization**: Not all environments will hold the
    same configuration. For example, the replication count in a staging environment
    could be one, while in production, we may set up horizontal Pod scaling. The capability
    is also required when we want to inject dependencies enabling segregation of concerns.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explore the tools available for application configuration management,
    keeping the capabilities in mind. The following section will deep dive into Helm,
    our first tool to explore.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Using Helm for application deployment
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Helm is one of the popular configuration management tools in the Kubernetes
    ecosystem. It came into existence as early as 2015\. It has come a long way in
    evolving itself and solving all the bottlenecks. Being a **Cloud Native Computing
    Foundation** (**CNCF**)-graduated project shows its maturity, production readiness,
    and value. Here are three key concepts of Helm:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Charts**: Charts are the basic units of applications in Helm. A chart is
    nothing but the bundled package of an application with all its dependencies.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository**: A bundled chart requires a consistent way of storage to distribute
    reliably, and repositories support this requirement. While open source applications
    can use a public repository, private repositories can be used for proprietary
    applications. Starting from Helm v3.8.0, any **Open Container Initiative** (**OCI**)-compliant
    repository will support Helm. This means that most container registries support
    Helm packages as well.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release**: This is an instance of the chart running in the cluster. When
    we install a chart for the first time, it creates a new release version. Any update
    will be an increment in the release version. The construct enables release management
    capabilities such as rollout, rollback, and blue-green deployment.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using Helm requires a client-side `brew` to install the CLI, while the `choco`
    installer can be used for Windows. The following code snippet shows how to install
    the CLI on either of these operating systems:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For more installation options, visit [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/).
    We will explore Helm in two parts—the first part will cover working with an existing
    chart, and new chart development will be covered in the second part.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Working with an existing chart
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Working with an existing chart can be categorized into repository management,
    release management, and cluster discovery. Here are a few repository management
    commands:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding repository management commands are good enough for our day-to-day
    repository operations. Next, we will look at a few release management Helm commands,
    as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding commands are some frequently used release management commands.
    The following snippet will cover a couple of cluster discovery commands:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It’s time to explore new chart development through a step-by-step, hands-on
    example.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on chart development
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm charts are nothing but a set of configuration templates with variable placeholders
    in the templates. These placeholders can be replaced with values when templates
    are rendered for installation. Helm has a powerful **domain-specific language**
    (**DSL**) providing a wide range of constructs for variable replacement. We will
    look at some frequently used constructs to learn chart development in the upcoming
    sections.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Chart generation
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Helm chart bundle has a set of organized files and folders. Either we need
    to understand the structure to develop it from scratch or we can use the generator.
    In the hands-on example, we will use the generator to create a chart named `hello-world`
    (`helm create <chart-name>`), as illustrated in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Creating a chart'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_09_01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Creating a chart
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the use of each file, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '`Chart.yaml`: This is a file that holds a description for the chart. It contains
    information such as supported Helm version, chart version, application version,
    application name, description, other dependent charts, maintainers, and so on.
    It also has an attribute called `type` that holds the value of either `application`
    or `library`. `application` refers to the fact that we are packing a Kubernetes
    application, and `library` means that the chart contains utility functions for
    reuse.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`charts` folder: This is a folder that can hold a list of dependent sub-charts.
    We can use sub-charts for many reasons. Dividing an extensive application into
    small modules with a sub-chart for each module is one way to use it. Another way
    could be to use it as a packaging mechanism for application dependencies such
    as a database. We could also use it as a holder of reusable functions that can
    be used as a shared library. An important thing to note here is that sub-charts
    can be independently deployed, meaning they cannot explicitly refer to the parent,
    but a parent can override values of sub-chart templates when required.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values.yaml`: This `helm upgrade redis-install-1 bitnami/redis -f values.yaml`.
    Also, we can use the `set` flag in the CLI to override a specific value.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template` folder: `NOTES.txt`, `_helpers.tpl`, and Kubernetes resource YAML
    templates are files that are part of the `template` folder. The `NOTES.txt` file
    is a template file that will be rendered and printed in the console when we run
    `helm install` or `helm upgrade`. The `_helpers.tpl` file will hold reusable functions
    that can be used across a chart. The rest of the files will be standard Kubernetes
    resource templates relevant to the application. Using the Helm `create` command
    to generate a basic chart adds a list of Kubernetes resources required for application
    deployment into the `template` folder. We can delete resources that are not necessary.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tests` folder: This can hold unit tests to test the logic we write in the
    resource template.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm uses the `template` package from the Go language and provides many powerful
    templating constructs to render complex scenarios. The following sections will
    explain each concept using the `hello-world` example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Variable access
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When templates are rendered, we can replace placeholder variables by simply
    specifying the variable hierarchy with the following syntax:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the preceding example, note that `.` acts as a separator representing the
    variable hierarchy. We start with `.` representing the root, then refer to one
    of the root objects. Note that we could have a variable with a multiple-depth
    hierarchy—for example, `{{ .Values.image.repository }}`. Here are some important
    built-in root objects available for us to use:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '`Release`: This object holds release-related information such as the release’s
    name, release namespace, revision number, and so on.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Values`: An object formed with the values file/command-line set flags.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chart`: Values defined in the `chart.yaml` file will be available under this
    object.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more objects available, such as `Files`, `Capabilities`, `Template`,
    and so on. Refer to [https://helm.sh/docs/chart_template_guide/builtin_objects/](https://helm.sh/docs/chart_template_guide/builtin_objects/)
    for a complete list.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: To remove an object or a specific attribute from the template, use the `--set`
    command-line with a `null` value—for example, `--set livenessProbe.httpGet=null`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Functions and pipelines
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We may have requirements to replace variables after doing some transformation,
    and built-in functions and pipelines can help with these. For example, refer to
    the following code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We refer to the application version and then enclose a string inside a quote
    in the preceding example. There are two essential things to note here. The quote
    is an built-in function available for us to use, and `|` will help pipe the output
    from one instruction to another. Here is a list of some frequently used functions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`indent`: Useful to format the configuration YAML. It takes a numerical input
    and indents the row with the specified index.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nindent`: The function works like the `intent` function, with an addition
    of a newline at the beginning.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trunc`: Truncates a string with the specified number of indexes.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trimSuffix`: This method takes a string suffix as input and truncates the
    suffix if it is present in the operating string.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace`: The `replace` method can replace one substring with another in an
    operating string.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`semverCompare`: This function can be used to compare two semantic versions.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the functions used in `deployment.yaml` and `_helpers.tpl`.
    Refer to [https://helm.sh/docs/chart_template_guide/function_list/](https://helm.sh/docs/chart_template_guide/function_list/)
    to look at an extensive list of built-in functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Information
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is `-` in many template placeholders—for example, the sixth
    line of `deployment.yaml` has `{{-`. This instructs the template engine to remove
    whitespace on the left. Similarly, `-}}` can remove whitespace on the right.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Flow control
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Flow controls make any programming language powerful and enable us to encode
    complex logic. Helm’s template language provides three flow controls. The first
    flow control available is the standard `if`/`else` statement. It is helpful to
    include a block based on a specific condition. The following code snippet from
    the `ingress.yaml` file checks the Kubernetes version to decide on the ingress
    **application programming interface** (**API**) version:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Note that `Capabilities` is an built-in object providing the capabilities of
    the target Kubernetes cluster. The second flow control, `with`, allows us to create
    a block with a specific variable scope. Refer to the following code snippet from
    `serviceaccount.yaml`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Remember our earlier discussion about variable references? We mentioned that
    the initial `.` refers to all objects’ roots. Inside a `with` block, the definition
    changes. The initial `.` within the block will refer to the scope variable defined.
    The third flow control is the range used for looping. Refer to the following code
    snippet from `NOTES.txt`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We declare a new variable, `host`, in the preceding example, and refer to it
    within the loop. Similarly, we could use variable declaration in other places
    as well.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: We can use `dry-run` and a `disable-openapi-validation` flag with `helm install`
    or `helm upgrade` to debug or validate the YAML outputs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Named templates
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Named templates are frequently used, and they act as static custom-defined
    functions. We define a template with a name and then import them into the required
    place. Generally, these named templates are described in the helper file and reused
    across the chart. Refer to the two pieces of code in the following snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Note that the template output can be piped with other built-in functions. We
    have covered most of the skills required to create new Helm charts for our bespoke
    applications. After changing the image name to `hello-world` in the `value.yaml`
    file, we can deploy the chart. Refer to the following screenshot for the chart
    installation:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Installing the chart'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_09_02.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Installing the chart
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we can use Kustomize to customize the configuration.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Customizing configurations with Kustomize
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Be it a configuration managed by Helm or other configuration management tools,
    Kustomize is one of the best tools for configuration customization. Let’s look
    at some of the use cases for Kustomize, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Keeping environment-specific customization separate from the base configuration
    is one use case. For example, replication counts can be done in staging, while
    the production environment could be enabled with auto-scaling.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing cross-cutting configurations outside the base configuration is another
    use case. For example, the application operator working with governance-specific
    labels in all deployments can keep the configuration separate from the base configuration.
    It can enable **separation of concerns** (**SoC**) for multi-persona collaboration
    without friction. Injecting a service mesh configuration as a cross-cutting concern
    is another example.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third use case is fixing vulnerabilities as a step in the configuration
    pipeline. Consider that there is a security vulnerability with an nginx image.
    The security team can add a customization step in the pipeline to ensure that
    the vulnerable version of nginx is updated for all deployments.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classic use case is to avoid abstraction leaking, as we discussed many times
    in the previous chapters. When we want to reuse the base configuration template
    across a few similar workloads, we can consider Kustomize as the new parameter.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot represents how Kustomize patching can be used in a
    multi-persona collaboration environment:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Configuration customization'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_09_03.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – Configuration customization
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a simple example to use Kustomize. We should have the base configuration
    on one side and `kustomization.yaml` on the other. `kustomization.yaml` defines
    how to customize the base configuration. Here is a sample `kustomization.yaml`
    file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The preceding configuration refers to the base configuration and defines how
    to customize it. The `deployment.yaml` file is the base configuration reference
    under the `resources` section. The `commonLabels` configuration adds the team’s
    name as a label to the deployment, and the `namespace` configuration will override
    the deployment resource namespace. We can run the `kubectl kustomize .` command
    to perform the customization. Refer to the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Configuration customization (continued)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_09_04.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Configuration customization (continued)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Kustomize can work with Crossplane configurations as well. An example to add
    a label to the composition is available in the hands-on example repository for
    this chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '`helm install` can use Kustomize as a post-render step by specifying the path
    to `kustomization.yaml`. The syntax is `helm install <release-name> <chart-name>
    --post-renderer ./path/to/executable`.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: An example of using Helm and Kustomize is available at [https://github.com/thomastaylor312/advanced-helm-demos/tree/master/post-render](https://github.com/thomastaylor312/advanced-helm-demos/tree/master/post-render).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: More than labels and namespaces, a lot more is possible with Kustomize. Refer
    to [https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/](https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/)
    for a deep dive into all possible customizations. This takes us to the end of
    the discussion on Kustomize, and in the following section, we will discuss KubeVela
    for application workload deployment.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Deploying application workloads with KubeVela
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed earlier, KubeVela is a project like Crossplane but focuses primarily
    on bespoke application workload. It can also cover off-the-shelf components via
    add-ons. Before getting into the details, let’s look at ways to install KubeVela.
    We will do the KubeVela installation in two steps. The first part is installing
    the KubeVela CLI. We can use Homebrew or a script if you have a macOS operating
    system. In the case of Windows, we can use PowerShell. Here are the CLI installation
    instructions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'As the next step, we should install KubeVela into the Kubernetes cluster, which
    is nothing but a set of **Custom Resource Definitions** (**CRDs**). Here are the
    KubeVela CRDs’ installation instructions. We can use either the CLI or a Helm
    chart:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Additionally, we can enable add-ons. Add-ons enhance the capability of KubeVela.
    For example, we can use the `velaux` add-on as an application management dashboard.
    `terraform-gcp` is another add-on useful to compose **Google Cloud Platform**
    (**GCP**) resources’ dependencies:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: We are all good to start using KubeVela. The core of the KubeVela configuration
    is the application API, and the anatomy of the application API is described in
    the following section.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a KubeVela application definition
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application specification carries the following four key sections:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '`Deployment` and `Job`. The external off-the-shelf dependency components can
    be a Terraform module, CloudFormation template, or even a Crossplane **Composite
    Resource** (**XR**)/Claim.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traits**: Traits are nothing but declarative operational behavior. Application
    rollout behavior, auto-scaling rules, and route rules are some examples of a trait.
    Traits are attached to the components, and we could have more than one trait attached.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policies**: Policies are a set of rules to be enforced. Pod security policy
    and health-check configurations are a couple of examples.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workflow**: A workflow is a final section that allows us to control the component
    delivery process. Approval steps and environment-specific traits are examples.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a look at the complete list of components, traits, policies, and workflows
    supported by our cluster using the following commands:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The following screenshot describes the anatomy of a KubeVela application with
    a hands-on example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Application API'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_09_05.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – Application API
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the `application` YAML, and you will find that our `hello-world` application
    is running successfully, as we can see here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Deployed application'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_09_06.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – Deployed application
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The KubeVela community has developed many components, traits, policies, and
    workflows based on the **Open Application Model** (**OAM**) specifications and
    documented them in the usage examples. The list will cover most of the requirements.
    Refer to [https://kubevela.io/docs/end-user/components/references](https://kubevela.io/docs/end-user/components/references)
    for a deep dive. If we have a custom requirement, KubeVela has all the ingredients
    to compose a custom component, trait, policy, and workflow. It is again creating
    and registering new CRDs. As with Crossplane, KubeVela also provides a framework
    to develop these CRDs. That takes us to the end of the chapter and the discussion
    on KubeVela.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chapter discussed some popular configuration management tools from the perspective
    of bespoke applications. While we did not cover every aspect of the tool, we did
    cover basic concepts, usage patterns, and a hands-on example. Each tool discussed
    here requires a book by itself to learn about in depth, which is beyond the scope
    of this book. The concepts, patterns, and tools we discussed will guide us to
    approach **end-to-end** (**E2E**) automation of the whole application using Crossplane.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从定制化应用的角度讨论了一些流行的配置管理工具。虽然我们没有涵盖工具的每一个方面，但我们介绍了基本概念、使用模式和一个实际操作示例。这里讨论的每个工具都需要一本书才能深入学习，这超出了本书的范围。我们讨论的概念、模式和工具将引导我们使用
    Crossplane 实现整个应用程序的**端到端**（**E2E**）自动化。
- en: The next chapter will go through a hands-on journey to onboard a complete application
    and its dependency using Crossplane, Helm, and a few other tools.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将通过实践操作，使用 Crossplane、Helm 以及其他一些工具，带领我们完成一个完整应用程序及其依赖的引导过程。
