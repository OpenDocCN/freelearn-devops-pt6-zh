- en: '*Chapter 9*: Using Helm, Kustomize, and KubeVela'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter concentrates mainly on configuration management for bespoke applications.
    The Kubernetes configuration for bespoke applications includes deployment, service,
    ingress, secret, configmaps, tags needed for governance, cross-cutting concerns,
    application security context, and other dependencies. Managing these configurations
    requires carefully choosing patterns and tools that fit the use case. Also, we
    must keep reuse, team collaboration, and scalability in mind. In the previous
    chapter, we lightly touched on a few tools such as Helm, Kustomize, and KubeVela
    for application configuration management. This chapter will be an opportunity
    to explore these tools in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Application configuration management capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Helm for application deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hands-on chart development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing configurations with Kustomize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying application workloads with KubeVela
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application configuration management capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operating an application successfully in the Kubernetes environment requires
    a few capabilities from the perspective of configuration management. Here is a
    list of critical configuration management capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Packaging**: As discussed several times, deploying an application into Kubernetes
    involves configuring multiple resources. It requires a capability where we can
    package all these resources into a single bundle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Life cycle management**: An application and all its dependencies must be
    executed into the cluster as a single deployment supporting the required release
    management constructs such as rollout, rollback, version management, and blue-green
    deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application discovery**: This is a capability that is required for day-to-day
    operations. It will enable any discovery tools to dashboard a list of applications
    deployed, their version, and dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application description customization**: Not all environments will hold the
    same configuration. For example, the replication count in a staging environment
    could be one, while in production, we may set up horizontal Pod scaling. The capability
    is also required when we want to inject dependencies enabling segregation of concerns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explore the tools available for application configuration management,
    keeping the capabilities in mind. The following section will deep dive into Helm,
    our first tool to explore.
  prefs: []
  type: TYPE_NORMAL
- en: Using Helm for application deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Helm is one of the popular configuration management tools in the Kubernetes
    ecosystem. It came into existence as early as 2015\. It has come a long way in
    evolving itself and solving all the bottlenecks. Being a **Cloud Native Computing
    Foundation** (**CNCF**)-graduated project shows its maturity, production readiness,
    and value. Here are three key concepts of Helm:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Charts**: Charts are the basic units of applications in Helm. A chart is
    nothing but the bundled package of an application with all its dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository**: A bundled chart requires a consistent way of storage to distribute
    reliably, and repositories support this requirement. While open source applications
    can use a public repository, private repositories can be used for proprietary
    applications. Starting from Helm v3.8.0, any **Open Container Initiative** (**OCI**)-compliant
    repository will support Helm. This means that most container registries support
    Helm packages as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release**: This is an instance of the chart running in the cluster. When
    we install a chart for the first time, it creates a new release version. Any update
    will be an increment in the release version. The construct enables release management
    capabilities such as rollout, rollback, and blue-green deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using Helm requires a client-side `brew` to install the CLI, while the `choco`
    installer can be used for Windows. The following code snippet shows how to install
    the CLI on either of these operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For more installation options, visit [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/).
    We will explore Helm in two parts—the first part will cover working with an existing
    chart, and new chart development will be covered in the second part.
  prefs: []
  type: TYPE_NORMAL
- en: Working with an existing chart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Working with an existing chart can be categorized into repository management,
    release management, and cluster discovery. Here are a few repository management
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding repository management commands are good enough for our day-to-day
    repository operations. Next, we will look at a few release management Helm commands,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands are some frequently used release management commands.
    The following snippet will cover a couple of cluster discovery commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: It’s time to explore new chart development through a step-by-step, hands-on
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on chart development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm charts are nothing but a set of configuration templates with variable placeholders
    in the templates. These placeholders can be replaced with values when templates
    are rendered for installation. Helm has a powerful **domain-specific language**
    (**DSL**) providing a wide range of constructs for variable replacement. We will
    look at some frequently used constructs to learn chart development in the upcoming
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Chart generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Helm chart bundle has a set of organized files and folders. Either we need
    to understand the structure to develop it from scratch or we can use the generator.
    In the hands-on example, we will use the generator to create a chart named `hello-world`
    (`helm create <chart-name>`), as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Creating a chart'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_09_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Creating a chart
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the use of each file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Chart.yaml`: This is a file that holds a description for the chart. It contains
    information such as supported Helm version, chart version, application version,
    application name, description, other dependent charts, maintainers, and so on.
    It also has an attribute called `type` that holds the value of either `application`
    or `library`. `application` refers to the fact that we are packing a Kubernetes
    application, and `library` means that the chart contains utility functions for
    reuse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`charts` folder: This is a folder that can hold a list of dependent sub-charts.
    We can use sub-charts for many reasons. Dividing an extensive application into
    small modules with a sub-chart for each module is one way to use it. Another way
    could be to use it as a packaging mechanism for application dependencies such
    as a database. We could also use it as a holder of reusable functions that can
    be used as a shared library. An important thing to note here is that sub-charts
    can be independently deployed, meaning they cannot explicitly refer to the parent,
    but a parent can override values of sub-chart templates when required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values.yaml`: This `helm upgrade redis-install-1 bitnami/redis -f values.yaml`.
    Also, we can use the `set` flag in the CLI to override a specific value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template` folder: `NOTES.txt`, `_helpers.tpl`, and Kubernetes resource YAML
    templates are files that are part of the `template` folder. The `NOTES.txt` file
    is a template file that will be rendered and printed in the console when we run
    `helm install` or `helm upgrade`. The `_helpers.tpl` file will hold reusable functions
    that can be used across a chart. The rest of the files will be standard Kubernetes
    resource templates relevant to the application. Using the Helm `create` command
    to generate a basic chart adds a list of Kubernetes resources required for application
    deployment into the `template` folder. We can delete resources that are not necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tests` folder: This can hold unit tests to test the logic we write in the
    resource template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm uses the `template` package from the Go language and provides many powerful
    templating constructs to render complex scenarios. The following sections will
    explain each concept using the `hello-world` example.
  prefs: []
  type: TYPE_NORMAL
- en: Variable access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When templates are rendered, we can replace placeholder variables by simply
    specifying the variable hierarchy with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, note that `.` acts as a separator representing the
    variable hierarchy. We start with `.` representing the root, then refer to one
    of the root objects. Note that we could have a variable with a multiple-depth
    hierarchy—for example, `{{ .Values.image.repository }}`. Here are some important
    built-in root objects available for us to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Release`: This object holds release-related information such as the release’s
    name, release namespace, revision number, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Values`: An object formed with the values file/command-line set flags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chart`: Values defined in the `chart.yaml` file will be available under this
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more objects available, such as `Files`, `Capabilities`, `Template`,
    and so on. Refer to [https://helm.sh/docs/chart_template_guide/builtin_objects/](https://helm.sh/docs/chart_template_guide/builtin_objects/)
    for a complete list.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: To remove an object or a specific attribute from the template, use the `--set`
    command-line with a `null` value—for example, `--set livenessProbe.httpGet=null`.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and pipelines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We may have requirements to replace variables after doing some transformation,
    and built-in functions and pipelines can help with these. For example, refer to
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We refer to the application version and then enclose a string inside a quote
    in the preceding example. There are two essential things to note here. The quote
    is an built-in function available for us to use, and `|` will help pipe the output
    from one instruction to another. Here is a list of some frequently used functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`indent`: Useful to format the configuration YAML. It takes a numerical input
    and indents the row with the specified index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nindent`: The function works like the `intent` function, with an addition
    of a newline at the beginning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trunc`: Truncates a string with the specified number of indexes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trimSuffix`: This method takes a string suffix as input and truncates the
    suffix if it is present in the operating string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace`: The `replace` method can replace one substring with another in an
    operating string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`semverCompare`: This function can be used to compare two semantic versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the functions used in `deployment.yaml` and `_helpers.tpl`.
    Refer to [https://helm.sh/docs/chart_template_guide/function_list/](https://helm.sh/docs/chart_template_guide/function_list/)
    to look at an extensive list of built-in functions.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is `-` in many template placeholders—for example, the sixth
    line of `deployment.yaml` has `{{-`. This instructs the template engine to remove
    whitespace on the left. Similarly, `-}}` can remove whitespace on the right.
  prefs: []
  type: TYPE_NORMAL
- en: Flow control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Flow controls make any programming language powerful and enable us to encode
    complex logic. Helm’s template language provides three flow controls. The first
    flow control available is the standard `if`/`else` statement. It is helpful to
    include a block based on a specific condition. The following code snippet from
    the `ingress.yaml` file checks the Kubernetes version to decide on the ingress
    **application programming interface** (**API**) version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `Capabilities` is an built-in object providing the capabilities of
    the target Kubernetes cluster. The second flow control, `with`, allows us to create
    a block with a specific variable scope. Refer to the following code snippet from
    `serviceaccount.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember our earlier discussion about variable references? We mentioned that
    the initial `.` refers to all objects’ roots. Inside a `with` block, the definition
    changes. The initial `.` within the block will refer to the scope variable defined.
    The third flow control is the range used for looping. Refer to the following code
    snippet from `NOTES.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We declare a new variable, `host`, in the preceding example, and refer to it
    within the loop. Similarly, we could use variable declaration in other places
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We can use `dry-run` and a `disable-openapi-validation` flag with `helm install`
    or `helm upgrade` to debug or validate the YAML outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Named templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Named templates are frequently used, and they act as static custom-defined
    functions. We define a template with a name and then import them into the required
    place. Generally, these named templates are described in the helper file and reused
    across the chart. Refer to the two pieces of code in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the template output can be piped with other built-in functions. We
    have covered most of the skills required to create new Helm charts for our bespoke
    applications. After changing the image name to `hello-world` in the `value.yaml`
    file, we can deploy the chart. Refer to the following screenshot for the chart
    installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Installing the chart'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_09_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Installing the chart
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we can use Kustomize to customize the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing configurations with Kustomize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Be it a configuration managed by Helm or other configuration management tools,
    Kustomize is one of the best tools for configuration customization. Let’s look
    at some of the use cases for Kustomize, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping environment-specific customization separate from the base configuration
    is one use case. For example, replication counts can be done in staging, while
    the production environment could be enabled with auto-scaling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing cross-cutting configurations outside the base configuration is another
    use case. For example, the application operator working with governance-specific
    labels in all deployments can keep the configuration separate from the base configuration.
    It can enable **separation of concerns** (**SoC**) for multi-persona collaboration
    without friction. Injecting a service mesh configuration as a cross-cutting concern
    is another example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third use case is fixing vulnerabilities as a step in the configuration
    pipeline. Consider that there is a security vulnerability with an nginx image.
    The security team can add a customization step in the pipeline to ensure that
    the vulnerable version of nginx is updated for all deployments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classic use case is to avoid abstraction leaking, as we discussed many times
    in the previous chapters. When we want to reuse the base configuration template
    across a few similar workloads, we can consider Kustomize as the new parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot represents how Kustomize patching can be used in a
    multi-persona collaboration environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Configuration customization'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_09_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – Configuration customization
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a simple example to use Kustomize. We should have the base configuration
    on one side and `kustomization.yaml` on the other. `kustomization.yaml` defines
    how to customize the base configuration. Here is a sample `kustomization.yaml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding configuration refers to the base configuration and defines how
    to customize it. The `deployment.yaml` file is the base configuration reference
    under the `resources` section. The `commonLabels` configuration adds the team’s
    name as a label to the deployment, and the `namespace` configuration will override
    the deployment resource namespace. We can run the `kubectl kustomize .` command
    to perform the customization. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Configuration customization (continued)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_09_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Configuration customization (continued)
  prefs: []
  type: TYPE_NORMAL
- en: Kustomize can work with Crossplane configurations as well. An example to add
    a label to the composition is available in the hands-on example repository for
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '`helm install` can use Kustomize as a post-render step by specifying the path
    to `kustomization.yaml`. The syntax is `helm install <release-name> <chart-name>
    --post-renderer ./path/to/executable`.'
  prefs: []
  type: TYPE_NORMAL
- en: An example of using Helm and Kustomize is available at [https://github.com/thomastaylor312/advanced-helm-demos/tree/master/post-render](https://github.com/thomastaylor312/advanced-helm-demos/tree/master/post-render).
  prefs: []
  type: TYPE_NORMAL
- en: More than labels and namespaces, a lot more is possible with Kustomize. Refer
    to [https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/](https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/)
    for a deep dive into all possible customizations. This takes us to the end of
    the discussion on Kustomize, and in the following section, we will discuss KubeVela
    for application workload deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying application workloads with KubeVela
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed earlier, KubeVela is a project like Crossplane but focuses primarily
    on bespoke application workload. It can also cover off-the-shelf components via
    add-ons. Before getting into the details, let’s look at ways to install KubeVela.
    We will do the KubeVela installation in two steps. The first part is installing
    the KubeVela CLI. We can use Homebrew or a script if you have a macOS operating
    system. In the case of Windows, we can use PowerShell. Here are the CLI installation
    instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'As the next step, we should install KubeVela into the Kubernetes cluster, which
    is nothing but a set of **Custom Resource Definitions** (**CRDs**). Here are the
    KubeVela CRDs’ installation instructions. We can use either the CLI or a Helm
    chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we can enable add-ons. Add-ons enhance the capability of KubeVela.
    For example, we can use the `velaux` add-on as an application management dashboard.
    `terraform-gcp` is another add-on useful to compose **Google Cloud Platform**
    (**GCP**) resources’ dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: We are all good to start using KubeVela. The core of the KubeVela configuration
    is the application API, and the anatomy of the application API is described in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a KubeVela application definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application specification carries the following four key sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Deployment` and `Job`. The external off-the-shelf dependency components can
    be a Terraform module, CloudFormation template, or even a Crossplane **Composite
    Resource** (**XR**)/Claim.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traits**: Traits are nothing but declarative operational behavior. Application
    rollout behavior, auto-scaling rules, and route rules are some examples of a trait.
    Traits are attached to the components, and we could have more than one trait attached.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policies**: Policies are a set of rules to be enforced. Pod security policy
    and health-check configurations are a couple of examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workflow**: A workflow is a final section that allows us to control the component
    delivery process. Approval steps and environment-specific traits are examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a look at the complete list of components, traits, policies, and workflows
    supported by our cluster using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot describes the anatomy of a KubeVela application with
    a hands-on example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Application API'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_09_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – Application API
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the `application` YAML, and you will find that our `hello-world` application
    is running successfully, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Deployed application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_09_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – Deployed application
  prefs: []
  type: TYPE_NORMAL
- en: The KubeVela community has developed many components, traits, policies, and
    workflows based on the **Open Application Model** (**OAM**) specifications and
    documented them in the usage examples. The list will cover most of the requirements.
    Refer to [https://kubevela.io/docs/end-user/components/references](https://kubevela.io/docs/end-user/components/references)
    for a deep dive. If we have a custom requirement, KubeVela has all the ingredients
    to compose a custom component, trait, policy, and workflow. It is again creating
    and registering new CRDs. As with Crossplane, KubeVela also provides a framework
    to develop these CRDs. That takes us to the end of the chapter and the discussion
    on KubeVela.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chapter discussed some popular configuration management tools from the perspective
    of bespoke applications. While we did not cover every aspect of the tool, we did
    cover basic concepts, usage patterns, and a hands-on example. Each tool discussed
    here requires a book by itself to learn about in depth, which is beyond the scope
    of this book. The concepts, patterns, and tools we discussed will guide us to
    approach **end-to-end** (**E2E**) automation of the whole application using Crossplane.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will go through a hands-on journey to onboard a complete application
    and its dependency using Crossplane, Helm, and a few other tools.
  prefs: []
  type: TYPE_NORMAL
