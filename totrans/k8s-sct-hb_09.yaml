- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Cloud Secret Store on Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we did a deep dive into Secrets Manager on AWS. In this chapter,
    we shall focus on another popular cloud provider, Microsoft Azure. We will learn
    about Azure Key Vault, a solution provided by Azure to store Secrets and perform
    encryption and decryption. We will utilize Azure Key Vault in order to store Secrets
    and use them on our Kubernetes workloads and we also utilize Key Vault to encrypt
    the Secrets that reside on etcd.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of Azure Key Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Workload Identity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AKS cluster and Azure Key Vault integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auditing and logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Key Vault for secret encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we should be able to store our Secrets in Azure
    Key Vault, retrieve them on a Kubernetes deployment, monitor secret access through
    auditing, and encrypt Kubernetes Secrets using Azure Key Vault.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To link concepts with hands-on examples, we are leveraging a series of tools
    and platforms commonly used to interact with the Azure API and Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure (az) CLI** ([https://learn.microsoft.com/en-us/cli/azure/](https://learn.microsoft.com/en-us/cli/azure/))
    is a multi-platform set of command-line tools used in order to create and manage
    Azure resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terraform** ([https://www.terraform.io/](https://www.terraform.io/)) is an
    infrastructure-as-code software solution that can be used to provision and manage
    infrastructure on the cloud'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kubectl** ([https://kubernetes.io/docs/reference/kubectl/](https://kubernetes.io/docs/reference/kubectl/))
    is the command-line tool used for communicating with a Kubernetes cluster through
    the Kubernetes API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of Azure Key Vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Key Vault is a versatile service. It can be used as a secret storage.
    On Azure Key Vault, we can store cryptographic keys. Also, Azure Key Vault can
    be used to perform encryption and decryption operations.
  prefs: []
  type: TYPE_NORMAL
- en: Since it is a managed Azure service, it benefits from the features that Azure
    provides by default on its services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The features of interest are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure RBAC and access policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging, auditing, and monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with other Azure components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take some time to examine these features that are crucial to the security
    of our Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Azure RBAC and access policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every service on Azure is protected from unauthorized usage through an identity
    access management layer that Azure provides. This layer comes in the form of Azure’s
    RBAC and access policy. A security principal is an entity that has an identity
    on Azure and can be a user account, group account, or computer account. The legacy
    way of assigning permissions to security principals is through *access policies*.
    The recommended way to assign permissions is through **Azure role-based access
    control** (**Azure RBAC**). Azure RBAC will be our choice to secure Azure Key
    Vault as we progress through the chapter. By using Azure RBAC, we will control
    access to resources by creating role assignments.
  prefs: []
  type: TYPE_NORMAL
- en: High availability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we create a Key Vault, we must specify the region where the Key Vault would
    be located. The contents of the Key Vault are replicated within this region. Also,
    the contents of the Key Vault will be replicated to a secondary region. Azure
    Key Vault contents are regionally highly available but also, they support disaster
    recovery out-of-the-box.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the scenario of a region becoming unavailable. Once the region becomes
    unavailable, the requests toward Azure Key Vault will be routed to the secondary
    region. This will happen automatically; there is no need to provision any extra
    Azure Key Vault resources or configure a fallback to a Key Vault residing in another
    region.
  prefs: []
  type: TYPE_NORMAL
- en: Logging, auditing, and monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Azure, we have the option to audit the usage of a Key Vault. By enabling
    auditing, we can identify who accessed the data hosted on Azure Key Vault. We
    can achieve this by collecting the logs through **Diagnostic settings**. Resources
    on Azure produce logs, and those logs contain information about the resources
    and the operations that take place involving each resource. Based on the resource,
    the content of the logs may vary.
  prefs: []
  type: TYPE_NORMAL
- en: '**Diagnostic settings** give us the option to stream those logs to various
    locations. By default, the logs will be streamed to an Azure storage account.
    Other options are to stream the logs to the Log Analytics workspace or to the
    Azure Event Hub.'
  prefs: []
  type: TYPE_NORMAL
- en: Integration with other Azure components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important benefit of Azure Key Vault is the integration with other Azure
    components. Azure Key Vault can be integrated with the Azure Application Gateway
    for traffic encryption or with the SQL Server offering from Azure, to encrypt
    the data. One of the components of interest is the Azure Kubernetes Service.
  prefs: []
  type: TYPE_NORMAL
- en: This is enabled using the Kubernetes Secrets Store CSI Driver for Azure Key
    Vault. We saw in the previous chapter how the CSI Secret Store works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows how the integration works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Azure Key Vault integration](img/B20970_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Azure Key Vault integration
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take advantage of Azure CSI Key Vault plugin and integrate
    it with Azure securely. The integration will involve a Kubernetes cluster in Azure
    using **Azure Kubernetes Service** (**AKS**). To integrate these two components,
    Azure Key Vault and the Kubernetes cluster, it is crucial to have fine-grained
    permissions from the cluster toward Azure Key Vault. For this, Azure provides
    us with the concept of Workload Identity.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Workload Identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Workload Identity on AKS on Azure enables us to assign permissions to Kubernetes
    workloads so they can interact with Azure resources. For example, we have an Azure
    Key Vault that we use to store sensitive information. To interact with Azure Key
    Vault, we need some form of credentials. Workload Identities are machine identities
    representing software workloads that require identities to interact with Azure
    resources. Instead of creating an identity or a service principal, we can use
    Workload Identity by manually attaching their credentials to the service. This
    way, each service can have its own identity and authenticate by itself.
  prefs: []
  type: TYPE_NORMAL
- en: In Kubernetes, we can assign a Workload Identity to our Pods. By granting the
    RBAC permissions to this identity, we will be able to interact with Azure Key
    Vault.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how Workload Identity works:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.2 – \uFEFF Workload Identity behind the scenes (\uFEFFsource: https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview?tabs=dotnet)](img/B20970_09_2.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2 – Workload Identity behind the scenes (source: [https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview?tabs=dotnet](https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview?tabs=dotnet))'
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation of Azure has a detailed overview of how a Workload
    Identity requests a token from the Azure Active Directory and then uses that token
    to interact with an Azure resource ([https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview](https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview)).
  prefs: []
  type: TYPE_NORMAL
- en: Since we’ve acquired an understanding of the Workload Identity concept, we can
    proceed and learn more about how Azure enables the interaction between AKS and
    other Azure resources, such as Azure Key Vault.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating an AKS cluster and Azure Key Vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To integrate Kubernetes with Azure Key Vault, we need to have a cluster set
    up. There are various options to create a cluster and each choice applies to the
    needs of certain circumstances. We shall create a simple AKS cluster; the master
    will be publicly available, but the nodes will reside on a private subnet of a
    virtual network.
  prefs: []
  type: TYPE_NORMAL
- en: We will provide some Terraform code for the scope of creating the cluster. Also,
    we shall provide the commands needed in case Terraform is not applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Terraform project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While creating the Terraform project, we will configure the state. The state
    can be saved in a storage account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By setting up the Terraform configuration, we can proceed and provision resources
    on Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is crucial to provision the resources for this chapter under one resource
    group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By using a resource group, we logically separate our resources from other resources
    on our Azure account, specifically to the solution we want to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we shall create a storage account to persist logs from our services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in the *Overview of Azure Key Vault* section, through **Diagnostics
    settings**, we can enable the logs of an Azure resource to be streamed to a storage
    account. The storage account we provisioned will serve this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: We can now proceed with creating the network.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning the network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a virtual network, and we will allocate a subset of private
    IPs. We shall also create a subnet on which we will be able to host the Kubernetes
    cluster nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `enforce_private_link_endpoint_network_policies` option is enabled. Through
    this option, the applications hosted in this subnet can access Azure components
    through the internal network.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning the AKS cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an AKS cluster by creating the master and adding a default node
    pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: An important thing to note is that we enable the **OpenID Connect** (**OIDC**)
    feature and the Workload Identity. This gives us the ability to assign roles to
    our Kubernetes workloads so that they can interact with Azure Key Vault.
  prefs: []
  type: TYPE_NORMAL
- en: 'After using the `terraform apply` command, the cluster will be provisioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We have the option to implement a fully private cluster using the `private_cluster_enabled`
    option. In the repo, you can find the settings to create the bastion host to enable
    this action ([https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook/blob/main/ch09/bastion.tf](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook/blob/main/ch09/bastion.tf)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if we do not want to provision the cluster through Terraform,
    we can use the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now successfully log in to our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By executing the preceding command, we will set up a configuration for the `kubectl`
    command. This configuration resides on the local `~/.kube/config` path of the
    workstation used to execute `kubectl` commands. Now we should be able to execute
    commands toward the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Key Vault
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We shall proceed and create a Key Vault resource; then, on that Key Vault, we
    shall create a key and a secret. We will assign fine-grained permissions to make
    it feasible to interact with the Key Vault through RBAC permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the Azure Key Vault:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we enabled the RBAC option. Since we enabled RBAC, we will
    create an identity that can be used with our Kubernetes workloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We created the identity and attached the permissions enabling us to use the
    Secrets and view them. The next step is to set up the credentials for the federated
    identity. We need to use the OIDC issuer URL from the cluster we provisioned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can create the Key Vault through the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By provisioning the identity credential, we can now interact with Azure Key
    Vault through Kubernetes. The federated identity credentials enable us to access
    resources protected by Active Directory. The federated credential that we used
    establishes a trust relationship with the identity provider of our AKS cluster
    and Active Directory. We allow the `service-token-reader` service account to impersonate
    `ksm-reader-identity`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Secrets from the Key Vault
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have our AKS cluster set up and our `kubectl` command is ready to execute
    commands to the cluster. So far, we have not had to install any plugins. This
    is because the plugins were enabled when creating the AKS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check this by running the following command on the CSI plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The CSI driver that will enable us to fetch credentials from the Key Vault
    is already enabled. Along with the CSI driver, we have a new object type created
    on Kubernetes: `SecretProviderClass`. This custom resource is used to provide
    driver configurations and provider-specific parameters to the CSI driver. In Kubernetes,
    a **custom resource** is an extension of the Kubernetes API. We specify a new
    kind of object that is accessed through the Kubernetes API just like all the other
    Kubernetes resources. We can find more information on custom resources through
    the official documentation ([https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create `SecretProviderClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now provision the service account that will have the identity attached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, the identity used is the identity that we provisioned previously
    with the purpose of interacting with Azure Key Vault.
  prefs: []
  type: TYPE_NORMAL
- en: 'After applying the following, we can set up a Pod that will use the Key Vault
    credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As of now, we have achieved our main goal, which is to use Key Vault Secrets
    through Azure Key Vault. We did achieve access to the Key Vault Secrets, so the
    next thing to check is whether auditing of Key Vault access is feasible.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing and logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we created the Key Vault on Azure. Azure provides us
    with the option to enable auditing for the resources we provision.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we add a block that enables us to store the audit logs of Key Vault
    access to a storage account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us perform the Terraform code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We’ve enabled Azure to capture the logs needed for auditing through a storage
    account.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Take note that we have set a retention policy on the log. At the time of writing,
    it has been announced that the **Diagnostic Settings Storage Retention** feature
    is being deprecated, thus the retention for logs and metrics should be configured
    through Azure Storage Lifecycle Management.
  prefs: []
  type: TYPE_NORMAL
- en: If we navigate to the bucket, there should be a container created on that storage
    account. The container will have the name `insights-logs-auditevent`, and the
    files in the container will be in the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us examine one of the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can see the category and the operation. Also, the identity is the one we
    attached to Kubernetes previously. Through audit logs, we can identify the actions
    that took place, the actor of those actions, and the resource upon which the actions
    took place, which in our case is the Key Vault we provisioned.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Key Vault for secret encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve used Azure Key Vault to store sensitive Secrets. What we want
    to identify is whether we can use Azure Key Vault to encrypt the Secrets that
    reside on etcd.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already created a Key Vault. We shall use that Key Vault to create a *key*
    used for KMS purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a key first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Take note that we can also specify a rotation policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When we create the Kubernetes cluster, we can use this key to encrypt the Secrets
    we create.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the AKS section, we shall put this option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve successfully encrypted our Secrets on etcd using Azure Key Vault as a
    KMS. We can also check this through the audit logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Azure Key Vault is actively being used to decrypt the Secrets
    hosted on AKS. The `KeyDecrypt` operation indicates the decryption operations.
    An equivalent operation will take place for encrypting the Secrets on AKS. This
    hardens the security of our Secrets management.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we managed to create an AKS cluster that would be able to read
    Secrets from Azure Key Vault. We identified the RBAC permissions needed to achieve
    encrypting and decrypting of the Secrets. We also increased the security by encrypting
    the Secrets on etcd, using Azure Key Vault as a KMS for Kubernetes. Lastly, we
    could identify the usage of Azure Key Vault through the audit logs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on another popular cloud provider, Google
    Cloud Platform. We will explore the secret storage option on GCP and its integration
    with the Kubernetes offering of GCP, as well as the secret encryption options.
  prefs: []
  type: TYPE_NORMAL
