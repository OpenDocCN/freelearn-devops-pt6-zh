- en: Building Your Own Kubernetes Cluster
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你自己的 Kubernetes 集群
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下方案：
- en: Exploring the Kubernetes architecture
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Kubernetes 架构
- en: Setting up a Kubernetes cluster on macOS by minikube
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 minikube 在 macOS 上设置 Kubernetes 集群
- en: Setting up a Kubernetes cluster on Windows by minikube
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 minikube 在 Windows 上设置 Kubernetes 集群
- en: Setting up a Kubernetes cluster on Linux by kubeadm
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 kubeadm 在 Linux 上设置 Kubernetes 集群
- en: Setting up a Kubernetes cluster on Linux by Ansible (kubespray)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Ansible (kubespray) 在 Linux 上设置 Kubernetes 集群
- en: Running your first container in Kubernetes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中运行你的第一个容器
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Welcome to your journey into Kubernetes! In this very first section, you will
    learn how to build your own Kubernetes cluster. Along with understanding each
    component and connecting them together, you will learn how to run your first container
    on Kubernetes. Having a Kubernetes cluster will help you continue your studies
    in the chapters ahead.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎踏上 Kubernetes 之旅！在这一部分中，你将学习如何构建自己的 Kubernetes 集群。在理解每个组件并将它们连接在一起的过程中，你将学习如何在
    Kubernetes 上运行第一个容器。拥有一个 Kubernetes 集群将帮助你在接下来的章节中继续学习。
- en: Exploring the Kubernetes architecture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Kubernetes 架构
- en: Kubernetes is an open source container management tool. It is a Go language-based
    ([https://golang.org](https://golang.org)), lightweight and portable application.
    You can set up a Kubernetes cluster on a Linux-based OS to deploy, manage, and
    scale Docker container applications on multiple hosts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个开源的容器管理工具。它是基于 Go 语言的 ([https://golang.org](https://golang.org))，轻量级且可移植的应用程序。你可以在基于
    Linux 的操作系统上设置 Kubernetes 集群，以部署、管理和扩展多个主机上的 Docker 容器应用。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Kubernetes is made up of the following components:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 由以下组件组成：
- en: Kubernetes master
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 主节点
- en: Kubernetes nodes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 节点
- en: etcd
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: etcd
- en: Kubernetes network
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 网络
- en: 'These components are connected via a network, as shown in the following diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件通过网络连接，如下图所示：
- en: '![](img/e964924c-0254-4850-ae57-8d05133ea0aa.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e964924c-0254-4850-ae57-8d05133ea0aa.png)'
- en: 'The preceding diagram can be summarized as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示可以总结如下：
- en: '**Kubernetes master**: It connects to etcd via HTTP or HTTPS to store the data'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes 主节点**：它通过 HTTP 或 HTTPS 连接到 etcd 以存储数据'
- en: '**Kubernetes nodes**: It connect to the Kubernetes master via HTTP or HTTPS
    to get a command and report the status'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes 节点**：它通过 HTTP 或 HTTPS 连接到 Kubernetes 主节点以获取命令并报告状态'
- en: '**Kubernetes network**: It L2, L3 or overlay make a connection of their container
    applications'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes 网络**：它通过 L2、L3 或覆盖网络连接其容器应用程序'
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this section, we are going to explain how to use the Kubernetes master and
    nodes to realize the main functions of the Kubernetes system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释如何使用 Kubernetes 主节点和节点来实现 Kubernetes 系统的主要功能。
- en: Kubernetes master
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 主节点
- en: 'The Kubernetes master is the main component of the Kubernetes cluster. It serves
    several functionalities, such as the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 主节点是 Kubernetes 集群的主要组件。它提供多个功能，具体如下：
- en: Authorization and authentication
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权与认证
- en: RESTful API entry point
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful API 入口点
- en: Container deployment scheduler to Kubernetes nodes
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器部署调度到 Kubernetes 节点
- en: Scaling and replicating controllers
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展和复制控制器
- en: Reading the configuration to set up a cluster
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取配置以设置集群
- en: 'The following diagram shows how master daemons work together to fulfill the
    aforementioned functionalities:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了主节点守护进程如何协同工作，以实现上述功能：
- en: '![](img/d05d8b65-158f-4a4b-8a4c-b9cf00ef1133.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d05d8b65-158f-4a4b-8a4c-b9cf00ef1133.png)'
- en: There are several daemon processes that form the Kubernetes master's functionality,
    such as `kube-apiserver`, `kube-scheduler` and `kube-controller-manager`. Hypercube,
    the wrapper binary, can launch all these daemons.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个守护进程组成 Kubernetes 主节点的功能，如 `kube-apiserver`、`kube-scheduler` 和 `kube-controller-manager`。Hypercube，作为封装二进制文件，可以启动所有这些守护进程。
- en: In addition, the Kubernetes command-line interface, kubect can control the Kubernetes
    master functionality.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Kubernetes 命令行界面 kubectl 可以控制 Kubernetes 主节点的功能。
- en: API server (kube-apiserver)
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 服务器（kube-apiserver）
- en: The API server provides an HTTP- or HTTPS-based RESTful API, which is the hub
    between Kubernetes components, such as kubectl, the scheduler, the replication
    controller, the etcd data store, the kubelet and kube-proxy, which runs on Kubernetes
    nodes, and so on.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: API 服务器提供基于 HTTP 或 HTTPS 的 RESTful API，它是 Kubernetes 各组件之间的枢纽，如 kubectl、调度器、复制控制器、etcd
    数据存储、在 Kubernetes 节点上运行的 kubelet 和 kube-proxy 等。
- en: Scheduler (kube-scheduler)
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度器（kube-scheduler）
- en: 'The scheduler helps to choose which container runs on which nodes. It is a
    simple algorithm that defines the priority for dispatching and binding containers
    to nodes. For example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器帮助选择容器运行的节点。它是一个简单的算法，定义了调度和将容器绑定到节点的优先级。例如：
- en: CPU
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU
- en: Memory
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存
- en: How many containers are running?
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多少个容器在运行？
- en: Controller manager (kube-controller-manager)
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器管理器（kube-controller-manager）
- en: 'The controller manager performs cluster operations. For example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器管理器执行集群操作。例如：
- en: Manages Kubernetes nodes
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理Kubernetes节点
- en: Creates and updates the Kubernetes internal information
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和更新Kubernetes内部信息
- en: Attempts to change the current status to the desired status
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将当前状态更改为目标状态
- en: Command-line interface (kubectl)
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行接口（kubectl）
- en: 'After you install the Kubernetes master, you can use the Kubernetes command-line
    interface, `kubectl`, to control the Kubernetes cluster. For example, `kubectl
    get cs` returns the status of each component. Also, `kubectl get nodes` returns
    a list of Kubernetes nodes:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Kubernetes主节点后，你可以使用Kubernetes命令行接口`kubectl`来控制Kubernetes集群。例如，`kubectl get
    cs`返回各个组件的状态。此外，`kubectl get nodes`返回Kubernetes节点的列表：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Kubernetes node
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes节点
- en: The Kubernetes node is a slave node in the Kubernetes cluster. It is controlled
    by the Kubernetes master to run container applications using Docker ([http://docker.com](http://docker.com))
    or rkt ([http://coreos.com/rkt/docs/latest/)](http://coreos.com/rkt/docs/latest/).
    In this book, we will use the Docker container runtime as the default engine.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes节点是Kubernetes集群中的从节点。它由Kubernetes主节点控制，用于通过Docker（[http://docker.com](http://docker.com)）或rkt（[http://coreos.com/rkt/docs/latest/](http://coreos.com/rkt/docs/latest/)）运行容器应用程序。在本书中，我们将使用Docker容器运行时作为默认引擎。
- en: Node or slave?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 节点还是从节点？
- en: The term slave is used in the computer industry to represent the cluster worker
    node; however, it is also associated with discrimination. The Kubernetes project
    uses minion in the early version and node in the current version.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “从节点”一词在计算机行业中用于表示集群工作节点；然而，它也与歧视相关。Kubernetes项目在早期版本中使用minion，在当前版本中使用节点（node）。
- en: 'The following diagram displays the role and tasks of daemon processes in the
    node:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了节点中守护进程的角色和任务：
- en: '![](img/bd21b8ae-fe86-4015-8b84-3a5e8aa502a9.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd21b8ae-fe86-4015-8b84-3a5e8aa502a9.png)'
- en: The node also has two daemon processes, named kubelet and kube-proxy, to support
    its functionalities.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 节点也有两个守护进程，分别是kubelet和kube-proxy，以支持其功能。
- en: kubelet
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kubelet
- en: 'kubelet is the main process on the Kubernetes node that communicates with the
    Kubernetes master to handle the following operations:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: kubelet是Kubernetes节点上的主要进程，它与Kubernetes主节点进行通信，处理以下操作：
- en: Periodically accesses the API controller to check and report
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期访问API控制器进行检查并报告
- en: Performs container operations
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行容器操作
- en: Runs the HTTP server to provide simple APIs
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行HTTP服务器以提供简单的API
- en: Proxy (kube-proxy)
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理（kube-proxy）
- en: The proxy handles the network proxy and load balancer for each container. It
    changes Linux iptables rules (nat table) to control TCP and UDP packets across
    the containers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 代理处理每个容器的网络代理和负载均衡器。它通过更改Linux iptables规则（nat表）来控制跨容器的TCP和UDP数据包。
- en: 'After starting the kube-proxy daemon, it configures iptables rules; you can
    use `iptables -t nat -L` or `iptables -t nat -S` to check the nat table rules,
    as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 启动kube-proxy守护进程后，它配置iptables规则；你可以使用`iptables -t nat -L`或`iptables -t nat -S`来检查nat表规则，如下所示：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: There are two more components to complement Kubernetes node functionalities,
    the data store etcd and the inter-container network. You can learn how they support
    the Kubernetes system in the following subsections.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个组件补充Kubernetes节点的功能，数据存储etcd和容器间网络。你可以在以下小节中了解它们如何支持Kubernetes系统。
- en: etcd
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: etcd
- en: etcd ([https://coreos.com/etcd/](https://coreos.com/etcd/)) is the distributed
    key-value data store. It can be accessed via the RESTful API to perform CRUD operations
    over the network. Kubernetes uses etcd as the main data store.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: etcd ([https://coreos.com/etcd/](https://coreos.com/etcd/))是一个分布式键值数据存储。可以通过RESTful
    API进行访问，从而在网络上执行CRUD操作。Kubernetes使用etcd作为主要的数据存储。
- en: 'You can explore the Kubernetes configuration and status in etcd (`/registry`)
    using the `curl` command, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`curl`命令在etcd（`/registry`）中查看Kubernetes的配置和状态，如下所示：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Kubernetes network
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes网络
- en: Network communication between containers is the most difficult part. Because
    Kubernetes manages multiple nodes (hosts) running several containers, those containers
    on different nodes may need to communicate with each other.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 容器之间的网络通信是最困难的部分。因为 Kubernetes 管理多个运行着多个容器的节点（主机），这些不同节点上的容器可能需要彼此通信。
- en: If the container's network communication is only within a single node, you can
    use Docker network or Docker compose to discover the peer. However, along with
    multiple nodes, Kubernetes uses an overlay network or **container network interface**
    (**CNI**) to achieve multiple container communication.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器的网络通信仅限于单个节点内，你可以使用 Docker 网络或 Docker Compose 来发现对等体。然而，随着节点的增加，Kubernetes
    使用叠加网络或**容器网络接口**（**CNI**）来实现多个容器之间的通信。
- en: See also
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: This recipe describes the basic architecture and methodology of Kubernetes and
    the related components. Understanding Kubernetes is not easy, but a step-by-step
    learning process on how to set up, configure, and manage Kubernetes is really
    fun.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱描述了 Kubernetes 的基本架构和方法论以及相关组件。理解 Kubernetes 并不容易，但逐步学习如何设置、配置和管理 Kubernetes
    真的很有趣。
- en: Setting up the Kubernetes cluster on macOS by minikube
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 minikube 在 macOS 上设置 Kubernetes 集群
- en: Kubernetes consists of combination of multiple open source components. These
    are developed by different parties, making it difficult to find and download all
    the related packages and install, configure, and make them work from scratch.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 由多个开源组件组成。这些组件由不同的方开发，使得很难找到并下载所有相关的包，并从零开始安装、配置并使其工作。
- en: Fortunately, there are some different solutions and tools that have been developed
    to set up Kubernetes clusters effortlessly. Therefore, it is highly recommended
    you use such a tool to set up Kubernetes on your environment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，已经开发出一些不同的解决方案和工具，可以轻松设置 Kubernetes 集群。因此，强烈建议你使用这些工具来设置你环境中的 Kubernetes。
- en: 'The following tools are categorized by different types of solution to build
    your own Kubernetes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下工具按不同类型的解决方案进行分类，帮助你构建自己的 Kubernetes：
- en: 'Self-managed solutions that include:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括以下自我管理解决方案：
- en: minikube
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: minikube
- en: kubeadm
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubeadm
- en: kubespray
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubespray
- en: kops
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: kops
- en: 'Enterprise solutions that include:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括以下企业解决方案：
- en: OpenShift ([https://www.openshift.com](https://www.openshift.com))
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenShift ([https://www.openshift.com](https://www.openshift.com))
- en: Tectonic ([https://coreos.com/tectonic/](https://coreos.com/tectonic/))
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tectonic ([https://coreos.com/tectonic/](https://coreos.com/tectonic/))
- en: 'Cloud-hosted solutions that include:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括以下云托管解决方案：
- en: Google Kubernetes engine ([https://cloud.google.com/kubernetes-engine/](https://cloud.google.com/kubernetes-engine/))
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Kubernetes 引擎 ([https://cloud.google.com/kubernetes-engine/](https://cloud.google.com/kubernetes-engine/))
- en: Amazon elastic container service for Kubernetes (Amazon EKS, [https://aws.amazon.com/eks/](https://aws.amazon.com/eks/))
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊弹性容器服务 Kubernetes（Amazon EKS, [https://aws.amazon.com/eks/](https://aws.amazon.com/eks/))
- en: Azure Container Service (AKS, [https://azure.microsoft.com/en-us/services/container-service/](https://azure.microsoft.com/en-us/services/container-service/))
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 容器服务（AKS, [https://azure.microsoft.com/en-us/services/container-service/](https://azure.microsoft.com/en-us/services/container-service/))
- en: A self-managed solution is suitable if we just want to build a development environment
    or do a proof of concept quickly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是想快速构建一个开发环境或进行概念验证，自我管理解决方案是合适的。
- en: By using minikube ([https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube))
    and kubeadm ([https://kubernetes.io/docs/admin/kubeadm/](https://kubernetes.io/docs/admin/kubeadm/)),
    we can easily build the desired environment on our machine locally; however, it
    is not practical if we want to build a production environment.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 minikube ([https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube))
    和 kubeadm ([https://kubernetes.io/docs/admin/kubeadm/](https://kubernetes.io/docs/admin/kubeadm/))，我们可以轻松地在本地机器上构建所需的环境；然而，如果我们想要构建生产环境，这就不太实际了。
- en: By using kubespray ([https://github.com/kubernetes-incubator/kubespray](https://github.com/kubernetes-incubator/kubespray))
    and kops ([https://github.com/kubernetes/kops](https://github.com/kubernetes/kops)),
    we can also build a production-grade environment quickly from scratch.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 kubespray ([https://github.com/kubernetes-incubator/kubespray](https://github.com/kubernetes-incubator/kubespray))
    和 kops ([https://github.com/kubernetes/kops](https://github.com/kubernetes/kops))，我们也可以快速从零开始构建生产级环境。
- en: 'An enterprise solution or cloud-hosted solution is the easiest starting point
    if we want to create a production environment. In particular, the **Google Kubernetes
    Engine** (**GKE**), which has been used by Google for many years, comes with comprehensive
    management, meaning that users don''t need to care much about the installation
    and settings. Also, Amazon EKS is a new service that was introduced at AWS re:
    Invent 2017, which is managed by the Kubernetes service on AWS.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想创建一个生产环境，企业解决方案或云托管解决方案是最简单的起点。特别是**Google Kubernetes Engine**（**GKE**），这是
    Google 多年来一直使用的解决方案，提供了全面的管理，意味着用户不需要过多关注安装和设置。此外，Amazon EKS 是 AWS 在 2017 年 re:Invent
    上推出的一项新服务，由 AWS 上的 Kubernetes 服务进行管理。
- en: Kubernetes can also run on different clouds and on-premise VMs by custom solutions.
    To get started, we will build Kubernetes using minikube on macOS desktop machines
    in this chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 还可以通过自定义解决方案在不同的云平台和本地虚拟机上运行。为了入门，本章将展示如何在 macOS 台式机上使用 minikube
    构建 Kubernetes。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: minikube runs Kubernetes on the Linux VM on macOS. It relies on a hypervisor
    (virtualization technology), such as VirtualBox ([https://www.virtualbox.org](https://www.virtualbox.org)),
    VMWare fusion ([https://www.vmware.com/products/fusion.html](https://www.vmware.com/products/fusion.html)),
    or hyperkit ([https://github.com/moby/hyperkit](https://github.com/moby/hyperkit))
    In addition, we will need to have the Kubernetes **command-line interface** (**CLI**)
    `kubectl`, which is used to connect through the hypervisor, to control Kubernetes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: minikube 在 macOS 上的 Linux 虚拟机上运行 Kubernetes。它依赖于虚拟化程序（虚拟化技术），如 VirtualBox ([https://www.virtualbox.org](https://www.virtualbox.org))、VMWare
    Fusion ([https://www.vmware.com/products/fusion.html](https://www.vmware.com/products/fusion.html))
    或 hyperkit ([https://github.com/moby/hyperkit](https://github.com/moby/hyperkit))。此外，我们还需要
    Kubernetes 的**命令行界面**（**CLI**）`kubectl`，用于通过虚拟化程序连接并控制 Kubernetes。
- en: With minikube, you can run the entire suite of the Kubernetes stack on your
    macOS, including the Kubernetes master, node, and CLI. It is recommended that
    macOS has enough memory to run Kubernetes. By default, minikube uses VirtualBox
    as the hypervisor.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 minikube，你可以在 macOS 上运行整个 Kubernetes 堆栈，包括 Kubernetes 主节点、节点和 CLI。建议 macOS
    有足够的内存来运行 Kubernetes。默认情况下，minikube 使用 VirtualBox 作为虚拟化程序。
- en: In this chapter, however, we will demonstrate how to use hyperkit, which is
    the most lightweight solution. As Linux VM consumes 2 GB of memory, at least 4
    GB of memory is recommended. Note that hyperkit is built on the top of the hypervisor
    framework ([https://developer.apple.com/documentation/hypervisor](https://developer.apple.com/documentation/hypervisor))
    on macOS; therefore, macOS 10.10 Yosemite or later is required.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中，我们将演示如何使用 hyperkit，它是最轻量级的解决方案。由于 Linux 虚拟机消耗 2 GB 的内存，建议至少使用 4 GB 内存。请注意，hyperkit
    是建立在 macOS 上的虚拟化框架之上的 ([https://developer.apple.com/documentation/hypervisor](https://developer.apple.com/documentation/hypervisor))，因此需要
    macOS 10.10 Yosemite 或更高版本。
- en: 'The following diagram shows the relationship between kubectl, the hypervisor,
    minikube, and macOS:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 kubectl、虚拟化程序、minikube 和 macOS 之间的关系：
- en: '![](img/52edf167-0558-4969-b440-eddb763d898e.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52edf167-0558-4969-b440-eddb763d898e.png)'
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: macOS doesn't have an official package management tool, such as yum and apt-get
    on Linux. But there are some useful tools available for macOS. `Homebrew` ([https://brew.sh](https://brew.sh))
    is the most popular package management tool and manages many open source tools,
    including minikube.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: macOS 没有官方的包管理工具，如 Linux 上的 yum 和 apt-get，但 macOS 有一些有用的工具可供使用。`Homebrew` ([https://brew.sh](https://brew.sh))
    是最受欢迎的包管理工具，管理着许多开源工具，包括 minikube。
- en: 'In order to install `Homebrew` on macOS, perform the following steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 macOS 上安装 `Homebrew`，请执行以下步骤：
- en: 'Open the Terminal and then type the following command:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，然后输入以下命令：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once installation is completed, you can type `/usr/local/bin/brew help` to see
    the available command options.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，你可以输入 `/usr/local/bin/brew help` 来查看可用的命令选项。
- en: If you just install or upgrade Xcode on your macOS, the `Homebrew` installation
    may stop. In that case, open Xcode to accept the license agreement or type `sudo
    xcodebuild -license` beforehand.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚在 macOS 上安装或升级了 Xcode，`Homebrew` 安装可能会停止。在这种情况下，请打开 Xcode 接受许可协议，或者事先输入
    `sudo xcodebuild -license`。
- en: 'Next, install the `hyperkit driver` for minikube. At the time of writing (February
    2018), HomeBrew does not support hyperkit; therefore type the following command
    to install it:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，安装 minikube 的 `hyperkit driver`。截至撰写本文时（2018 年 2 月），HomeBrew 不支持 hyperkit，因此输入以下命令进行安装：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, let''s install the Kubernetes CLI. Use Homebrew with the following comment
    to install the `kubectl` command on your macOS:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们安装 Kubernetes CLI。使用 Homebrew 执行以下命令在您的 macOS 上安装 `kubectl` 命令：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, you can install minikube. It is not managed by Homebrew; however, Homebrew
    has an extension called `homebrew-cask` ([https://github.com/caskroom/homebrew-cask](https://github.com/caskroom/homebrew-cask))
    that supports minikube.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以安装 minikube。它不是由 Homebrew 管理的；但是，Homebrew 有一个扩展工具 `homebrew-cask` ([https://github.com/caskroom/homebrew-cask](https://github.com/caskroom/homebrew-cask))，它支持
    minikube。
- en: 'In order to install minikube by `homebrew-cask`, just simply type the following
    command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 若要通过 `homebrew-cask` 安装 minikube，只需输入以下命令：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you have never installed **Docker for Mac** on your machine, you need to
    install it via `homebrew-cask` as well
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您从未在您的机器上安装过 **Docker for Mac**，也需要通过 `homebrew-cask` 来安装它。
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now you are all set! The following command shows whether the required packages
    have been installed on your macOS or not:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在一切就绪！以下命令将显示是否已在您的 macOS 上安装所需的软件包：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'minikube is suitable for setting up Kubernetes on your macOS with the following
    command, which downloads and starts a Kubernetes VM stet, and then configures
    the kubectl configuration (`~/.kube/config`):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: minikube 适合在 macOS 上设置 Kubernetes，使用以下命令，它会下载并启动一个 Kubernetes 虚拟机实例，然后配置 kubectl
    配置文件（`~/.kube/config`）：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After getting all the necessary packages, perform the following steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 获取所有必要的软件包后，请执行以下步骤：
- en: Wait for a few minutes for the Kubernetes cluster setup to complete.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几分钟，直到 Kubernetes 集群设置完成。
- en: Use `kubectl version` to check the Kubernetes master version and `kubectl get
    cs` to see the component status.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `kubectl version` 检查 Kubernetes 主版本，使用 `kubectl get cs` 查看组件状态。
- en: 'Also, use the `kubectl get nodes` command to check whether the Kubernetes node
    is ready or not:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，使用 `kubectl get nodes` 命令检查 Kubernetes 节点是否已准备好：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now you can start to use Kubernetes on your machine. The following sections
    describe how to use the `kubectl` command to manipulate Docker containers.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以开始在机器上使用 Kubernetes。以下部分描述了如何使用 `kubectl` 命令操作 Docker 容器。
- en: 'Note that, in some cases, you may need to maintain the Kubernetes cluster,
    such as starting/stopping the VM or completely deleting it. The following commands 
    maintain the minikube environment:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，在某些情况下，您可能需要维护 Kubernetes 集群，例如启动/停止虚拟机或完全删除它。以下命令用于维护 minikube 环境：
- en: '| **Command** | **Purpose** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **目的** |'
- en: '| `minikube start --vm-driver=hyperkit` | Starts the Kubernetes VM using the
    hyperkit driver |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `minikube start --vm-driver=hyperkit` | 使用 hyperkit 驱动程序启动 Kubernetes 虚拟机
    |'
- en: '| `minikube stop` | Stops the Kubernetes VM |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `minikube stop` | 停止 Kubernetes 虚拟机 |'
- en: '| `minikube delete` | Deletes a Kubernetes VM image |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `minikube delete` | 删除 Kubernetes 虚拟机镜像 |'
- en: '| `minikube ssh` | ssh to the Kubernetes VM guest |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `minikube ssh` | SSH 连接到 Kubernetes 虚拟机 |'
- en: '| `minikube ip` | Shows the Kubernetes VM (node) IP address |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `minikube ip` | 显示 Kubernetes 虚拟机（节点）IP 地址 |'
- en: '| `minikube update-context` | Checks and updates `~/.kube/config` if the VM
    IP address is changed |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `minikube update-context` | 如果虚拟机 IP 地址发生更改，检查并更新 `~/.kube/config` |'
- en: '| `minikube dashboard` | Opens the web browser to connect the Kubernetes UI
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `minikube dashboard` | 打开浏览器连接到 Kubernetes UI |'
- en: 'For example, minikube starts a dashboard (the Kubernetes UI) by the default.
    If you want to access the dashboard, type `minikube dashboard`; it then opens
    your default browser and connects the Kubernetes UI, as illustrated in the following
    screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，minikube 默认启动一个仪表盘（Kubernetes UI）。如果您想访问仪表盘，输入 `minikube dashboard`，然后它会打开您的默认浏览器并连接到
    Kubernetes UI，如下图所示：
- en: '![](img/8d9207f5-35c3-4b5a-82cc-0025425f1ff1.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d9207f5-35c3-4b5a-82cc-0025425f1ff1.png)'
- en: See also
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: This recipe describes how to set up a Kubernetes cluster on your macOS using
    minikube. It is the easiest way to start using Kubernetes. We also learned how
    to use kubectl, the Kubernetes command-line interface tool, which is the entry
    point to control our Kubernetes cluster!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程描述了如何使用 minikube 在 macOS 上设置 Kubernetes 集群。这是开始使用 Kubernetes 的最简单方法。我们还学习了如何使用
    kubectl，这是 Kubernetes 的命令行接口工具，它是控制 Kubernetes 集群的入口！
- en: Setting up the Kubernetes cluster on Windows by minikube
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 上使用 minikube 设置 Kubernetes 集群
- en: By nature, Docker and Kubernetes are based on a Linux-based OS. Although it
    is not ideal to use the Windows OS to explore Kubernetes, many people are using
    the Windows OS as their desktop or laptop machine. Luckily, there are a lot of
    ways to run the Linux OS on Windows using virtualization technologies, which makes
    running a Kubernetes cluster on Windows machines possible. Then, we can build
    a development environment or do a proof of concept on our local Windows machine.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，Docker 和 Kubernetes 是基于 Linux 操作系统的。虽然使用 Windows 操作系统来探索 Kubernetes 并非理想选择，但许多人仍然将
    Windows 操作系统作为桌面或笔记本电脑的操作系统。幸运的是，通过虚拟化技术，有很多方法可以在 Windows 上运行 Linux 操作系统，这使得在
    Windows 机器上运行 Kubernetes 集群成为可能。然后，我们可以在本地 Windows 机器上构建开发环境或进行概念验证。
- en: You can run the Linux VM by using any hypervisor on Windows to set up Kubernetes
    from scratch, but using minikube ([https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube))
    is the fastest way to build a Kubernetes cluster on Windows. Note that this recipe
    is not ideal for a production environment because it will set up a Kubernetes
    on Linux VM on Windows.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 Windows 上使用任何虚拟化软件从头开始设置 Kubernetes，来运行 Linux 虚拟机，但使用 minikube ([https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube))
    是在 Windows 上构建 Kubernetes 集群的最快方式。请注意，这个方法并不适用于生产环境，因为它会在 Windows 上设置一个运行 Kubernetes
    的 Linux 虚拟机。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To set up minikube on Windows requires a hypervisor, either VirtualBox ([https://www.virtualbox.org](https://www.virtualbox.org))
    or Hyper-V, because, again, minikube uses the Linux VM on Windows. This means
    that you cannot use the Windows virtual machine (for example, running the Windows
    VM on macOS by parallels).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上设置 minikube 需要一个虚拟化软件，可能是 VirtualBox ([https://www.virtualbox.org](https://www.virtualbox.org))
    或 Hyper-V，因为，minikube 使用 Windows 上的 Linux 虚拟机。这意味着你不能使用 Windows 虚拟机（例如，在 macOS
    上通过 Parallels 运行 Windows 虚拟机）。
- en: However, `kubectl` , the Kubernetes CLI, supports a Windows native binary that
    can connect to Kubernetes over a network. So, you can set up a portable suite
    of Kubernetes stacks on your Windows machine.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`kubectl`，Kubernetes 的命令行工具，支持一个可以通过网络连接到 Kubernetes 的 Windows 本地二进制文件。因此，你可以在
    Windows 机器上设置一个便携式 Kubernetes 套件。
- en: 'The following diagram shows the relationship between kubectl, Hypervisor, minikube,
    and Windows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 kubectl、虚拟化软件、minikube 和 Windows 之间的关系：
- en: '![](img/a68272cf-8a6b-4ad9-8b69-bf2e0a3b06b4.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a68272cf-8a6b-4ad9-8b69-bf2e0a3b06b4.png)'
- en: Hyper-V is required for Windows 8 Pro or later. While many users still use Windows
    7, we will use VirtualBox as the minikube hypervisor in this recipe.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 8 Pro 或更高版本需要 Hyper-V。虽然许多用户仍然使用 Windows 7，但我们在这个教程中将使用 VirtualBox 作为
    minikube 的虚拟化软件。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First of all, VirtualBox for Windows is required:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要安装 Windows 版的 VirtualBox：
- en: Go to the VirtualBox website ([https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads))
    to download the Windows installer.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 VirtualBox 网站 ([https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads))
    下载 Windows 安装程序。
- en: 'Installation is straightforward, so we can just choose the default options
    and click Next:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装过程非常简单，所以我们只需选择默认选项并点击“下一步”：
- en: '![](img/974c0731-431f-4311-92d5-e90fb7125196.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/974c0731-431f-4311-92d5-e90fb7125196.png)'
- en: 'Next, create the `Kubernetes` folder, which is used to store the minikube and
    kubectl binaries. Let''s create the `k8s` folder on top of the `C:` drive, as
    shown in the following screenshot:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个 `Kubernetes` 文件夹，用于存储 minikube 和 kubectl 可执行文件。我们将在 `C:` 盘上创建一个 `k8s`
    文件夹，如下图所示：
- en: '![](img/0e05fcfa-9a7e-4433-8092-da2715ed76df.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e05fcfa-9a7e-4433-8092-da2715ed76df.png)'
- en: This folder must be in the command search path, so open System Properties, then
    move to the Advanced tab.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个文件夹必须在命令搜索路径中，因此打开系统属性，然后转到“高级”选项卡。
- en: 'Click the Environment Variables... button, then choose Path , and then click
    the Edit... button, as shown in the following screenshot:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“环境变量...”按钮，然后选择“Path”，接着点击“编辑...”按钮，如下图所示：
- en: '![](img/5aca299b-611c-48ae-973d-e8a219ab1b47.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5aca299b-611c-48ae-973d-e8a219ab1b47.png)'
- en: 'Then, append `c:\k8s` , as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加 `c:\k8s`，如下所示：
- en: '![](img/06503e44-8ead-4b89-b980-9317068883c4.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06503e44-8ead-4b89-b980-9317068883c4.png)'
- en: After clicking the OK button, log off and logo on to Windows again (or reboot)
    to apply this change.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“确定”按钮后，注销并重新登录 Windows（或重启）以应用此更改。
- en: Next, download minikube for Windows. It is a single binary, so use any web browser
    to download [https://github.com/kubernetes/minikube/releases/download/v0.26.1/minikube-windows-amd64](https://github.com/kubernetes/minikube/releases/download/v0.26.1/minikube-windows-amd64)
    and then copy it to the `c:\k8s` folder, but change the filename to `minikube.exe`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，下载适用于Windows的minikube。它是一个单独的二进制文件，使用任何Web浏览器下载[https://github.com/kubernetes/minikube/releases/download/v0.26.1/minikube-windows-amd64](https://github.com/kubernetes/minikube/releases/download/v0.26.1/minikube-windows-amd64)，然后将其复制到`c:\k8s`文件夹中，但请将文件名更改为`minikube.exe`。
- en: Next, download kubectl for Windows, which can communicate with Kubernetes. It
    is also single binary like minikube. So, download [https://storage.googleapis.com/kubernetes-release/release/v1.10.2/bin/windows/amd64/kubectl.exe](https://storage.googleapis.com/kubernetes-release/release/v1.10.2/bin/windows/amd64/kubectl.exe)
    and then copy it to the `c:\k8s` folder as well.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，下载适用于Windows的kubectl，它可以与Kubernetes通信。它也是像minikube一样的单一二进制文件。所以，下载[https://storage.googleapis.com/kubernetes-release/release/v1.10.2/bin/windows/amd64/kubectl.exe](https://storage.googleapis.com/kubernetes-release/release/v1.10.2/bin/windows/amd64/kubectl.exe)，然后也将其复制到`c:\k8s`文件夹中。
- en: 'Eventually, you will see two binaries in the `c:\k8s` folder, as shown in the
    following screenshot:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，你将在`c:\k8s`文件夹中看到两个二进制文件，如下图所示：
- en: '![](img/d769ed44-88be-4a27-93d7-bdb86f28fdbf.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d769ed44-88be-4a27-93d7-bdb86f28fdbf.png)'
- en: If you are running anti-virus software, it may prevent you from running `kubectl.exe`
    and `minikube.exe`. If so, please update your anti-virus software setting that
    allows running these two binaries.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行防病毒软件，它可能会阻止你运行`kubectl.exe`和`minikube.exe`。如果是这种情况，请更新防病毒软件设置，允许运行这两个二进制文件。
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's get started!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 'Open Command Prompt and then type `minikube start` , as shown in the following
    screenshot:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符并输入`minikube start`，如以下截图所示：
- en: '![](img/cf21415a-f5c0-4528-95d0-74ae67d5f90f.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf21415a-f5c0-4528-95d0-74ae67d5f90f.png)'
- en: 'minikube downloads the Linux VM image and then sets up Kubernetes on the Linux
    VM; now if you open VirtualBox, you can see that the minikube guest has been registered,
    as illustrated in the following screenshot:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: minikube下载Linux虚拟机镜像并在其上设置Kubernetes；现在如果你打开VirtualBox，你会看到minikube虚拟机已经注册，如下图所示：
- en: '![](img/49a5d949-29c4-4762-8ee0-f89969082c19.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49a5d949-29c4-4762-8ee0-f89969082c19.png)'
- en: Wait for a few minutes to complete the setup of the Kubernetes cluster.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几分钟以完成Kubernetes集群的设置。
- en: As per the following screenshot, type `kubectl version` to check the Kubernetes
    master version.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下图所示，输入`kubectl version`以检查Kubernetes主版本。
- en: 'Use the `kubectl get nodes` command to check whether the Kubernetes node is
    ready or not:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl get nodes`命令检查Kubernetes节点是否已准备好：
- en: '![](img/d323c09d-4c29-4862-8fdd-9ab4ab63be36.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d323c09d-4c29-4862-8fdd-9ab4ab63be36.png)'
- en: Now you can start to use Kubernetes on your machine! Again, Kubernetes is running
    on the Linux VM, as shown in the next screenshot.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以开始在你的机器上使用Kubernetes了！再次强调，Kubernetes运行在Linux虚拟机上，如下图所示。
- en: 'Using `minikube ssh` allows you to access the Linux VM that runs Kubernetes:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`minikube ssh`可以访问运行Kubernetes的Linux虚拟机：
- en: '![](img/9f745739-14ce-487c-9a3b-16ff37edefe0.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f745739-14ce-487c-9a3b-16ff37edefe0.png)'
- en: Therefore, any Linux-based Docker image is capable of running on your Windows
    machine.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，任何基于Linux的Docker镜像都能够在你的Windows机器上运行。
- en: 'Type `minikube ip` to verify which IP address the Linux VM uses and also `minikube
    dashboard`, to open your default web browser and navigate to the Kubernetes UI
    ,as shown in the following screenshot:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`minikube ip`来验证Linux虚拟机使用的IP地址，同时输入`minikube dashboard`，以打开默认的Web浏览器并导航到Kubernetes
    UI，如下图所示：
- en: '![](img/4cac90a8-990e-4b86-b195-f660c51d0cb4.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cac90a8-990e-4b86-b195-f660c51d0cb4.png)'
- en: 'If you don''t need to use Kubernetes anymore, type `minikube stop` or open
    VirtualBox to stop the Linux guest and release the resource, as shown in the following
    screenshot:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你不再需要使用Kubernetes，输入`minikube stop`，或者打开VirtualBox停止Linux虚拟机并释放资源，如下图所示：
- en: '![](img/09fe9f63-c0cf-420f-ac7d-a09f00810126.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09fe9f63-c0cf-420f-ac7d-a09f00810126.png)'
- en: See also
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: This recipe describes how to set up a Kubernetes cluster on your Windows OS
    using minikube. It is the easiest way to start using Kubernetes. It also describes
    kubectl, the Kubernetes command-line interface tool, which is the entry point
    form which to control your Kubernetes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程描述了如何使用minikube在Windows操作系统上设置Kubernetes集群。这是开始使用Kubernetes的最简单方式。它还介绍了kubectl，这是Kubernetes的命令行工具，是用来控制Kubernetes的入口工具。
- en: Setting up the Kubernetes cluster on Linux via kubeadm
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过kubeadm在Linux上设置Kubernetes集群
- en: In this recipe, we are going to show how to create a Kubernetes cluster along
    with kubeadm ([https://github.com/kubernetes/kubeadm](https://github.com/kubernetes/kubeadm))
    on Linux servers. Kubeadm is a command-line tool that simplifies the procedure
    of creating and managing a Kubernetes cluster. Kubeadm leverages the fast deployment
    feature of Docker, running the system services of the Kubernetes master and the
    etcd server as containers. When triggered by the `kubeadm` command, the container
    services will contact kubelet on the Kubernetes node directly; kubeadm also checks
    whether every component is healthy. Through the kubeadm setup steps, you can avoid
    having a bunch of installation and configuration commands when you build everything
    from scratch.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将展示如何在 Linux 服务器上使用 kubeadm 创建一个 Kubernetes 集群 ([https://github.com/kubernetes/kubeadm](https://github.com/kubernetes/kubeadm))。Kubeadm
    是一个命令行工具，用于简化创建和管理 Kubernetes 集群的过程。Kubeadm 利用 Docker 的快速部署功能，将 Kubernetes 主节点和
    etcd 服务器的系统服务作为容器运行。当通过 `kubeadm` 命令触发时，容器服务将直接联系 Kubernetes 节点上的 kubelet；kubeadm
    还会检查每个组件是否正常。通过 kubeadm 的设置步骤，您可以避免在从头开始构建时需要执行一堆安装和配置命令。
- en: Getting ready
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will provide instructions of two types of OS:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供两种类型操作系统的说明：
- en: Ubuntu Xenial 16.04 (LTS)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Xenial 16.04 (LTS)
- en: CentOS 7.4
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CentOS 7.4
- en: 'Make sure the OS version is matched before continuing. Furthermore, the software
    dependency and network settings should be also verified before you proceed to
    thecd cd next step. Check the following items to prepare the environment:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保操作系统版本匹配。此外，软件依赖和网络设置也应在继续到下一步之前进行验证。检查以下项目以准备环境：
- en: '**Every node has a unique MAC address and product UUID**: Some plugins use
    the MAC address or product UUID as a unique machine ID to identify nodes (for
    example, `kube-dns`). If they are duplicated in the cluster, kubeadm may not work
    while starting the plugin:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个节点都有唯一的 MAC 地址和产品 UUID**：某些插件使用 MAC 地址或产品 UUID 作为唯一机器 ID 来识别节点（例如，`kube-dns`）。如果它们在集群中重复，kubeadm
    在启动插件时可能无法正常工作：'
- en: '[PRE11]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Every node has a different hostname**: If the hostname is duplicated, the
    Kubernetes system may collect logs or statuses from multiple nodes into the same
    one.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个节点都有不同的主机名**：如果主机名重复，Kubernetes 系统可能会将来自多个节点的日志或状态收集到同一个节点。'
- en: '**Docker is installed**: As mentioned previously, the Kubernetes master will
    run its daemon as a container, and every node in the cluster should get Docker
    installed. For how to perform the Docker installation, you can follow the steps
    on the official website: (Ubuntu: [https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/](https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/),
    and CentOS: [https://docs.docker.com/engine/installation/linux/docker-ce/centos/](https://docs.docker.com/engine/installation/linux/docker-ce/centos/))
    Here we have Docker CE 17.06 installed on our machines; however, only Docker versions
    1.11.2 to 1.13.1, and 17.03.x are verified with Kubernetes version 1.10.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已安装 Docker**：如前所述，Kubernetes 主节点将作为容器运行其守护进程，并且集群中的每个节点都应安装 Docker。有关如何安装
    Docker，可以按照官方网站上的步骤进行操作：（Ubuntu：[https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/](https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/)，CentOS：[https://docs.docker.com/engine/installation/linux/docker-ce/centos/](https://docs.docker.com/engine/installation/linux/docker-ce/centos/)）。在我们的机器上已经安装了
    Docker CE 17.06；然而，只有 Docker 版本 1.11.2 至 1.13.1，以及 17.03.x 与 Kubernetes 版本 1.10
    验证过。'
- en: '**Network ports are available**: The Kubernetes system services need network
    ports for communication. The ports in the following table should now be occupied
    according to the role of the node:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络端口可用**：Kubernetes 系统服务需要网络端口进行通信。根据节点的角色，下面表格中的端口应当被占用：'
- en: '| **Node role** | **Ports** | **System service** |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **节点角色** | **端口** | **系统服务** |'
- en: '| Master | `6443` | Kubernetes API server |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 主节点 | `6443` | Kubernetes API 服务器 |'
- en: '| `10248/10250/10255` | kubelet local healthz endpoint/Kubelet API/Heapster
    (read-only) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `10248/10250/10255` | kubelet 本地 healthz 端点/Kubelet API/Heapster（只读） |'
- en: '| `10251` | kube-scheduler |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `10251` | kube-scheduler |'
- en: '| `10252` | kube-controller-manager |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `10252` | kube-controller-manager |'
- en: '| `10249/10256` | kube-proxy |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `10249/10256` | kube-proxy |'
- en: '| `2379/2380` | etcd client/etcd server communication |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `2379/2380` | etcd 客户端/etcd 服务器通信 |'
- en: '| Node | `10250/10255` | Kubelet API/Heapster (read-only) |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 节点 | `10250/10255` | Kubelet API/Heapster（只读） |'
- en: '| `30000~32767` | Port range reserved for exposing container service to outside
    world |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `30000~32767` | 用于将容器服务暴露给外部世界的端口范围 |'
- en: 'The Linux command, `netstat`, can help to check if the port is in use or not:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 命令`netstat`可以帮助检查端口是否在使用中：
- en: '[PRE12]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Network tool packages are installed. `ethtool` and `ebtables` are two required
    utilities for kubeadm. They can be download and installed by the`apt-get` or `yum`package
    managing tools.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装网络工具包。`ethtool` 和 `ebtables` 是 kubeadm 所需的两个工具。它们可以通过 `apt-get` 或 `yum` 包管理工具下载并安装。
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The installation procedures for two Linux OSes, Ubuntu and CentOS, are going
    to be introduced separately in this recipe as they have different setups.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱将分别介绍两种 Linux 操作系统（Ubuntu 和 CentOS）的安装过程，因为它们的设置方式不同。
- en: Package installation
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包安装
- en: Let's get the Kubernetes packages first! The repository for downloading needs
    to be set in the source list of the package management system. Then, we are able
    to get them installed easily through the command-line.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先获取Kubernetes包！需要在包管理系统的源列表中设置下载仓库。然后，我们可以通过命令行轻松安装它们。
- en: Ubuntu
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ubuntu
- en: 'To install Kubernetes packages in Ubuntu perform the following steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 中安装 Kubernetes 包，请执行以下步骤：
- en: 'Some repositories are URL with HTTPS. The `apt-transport-https` package must
    be installed to access the HTTPS endpoint:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些仓库的 URL 使用 HTTPS。必须安装 `apt-transport-https` 包才能访问 HTTPS 端点：
- en: '[PRE13]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Download the public key for accessing packages on Google Cloud, and add it
    as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载用于访问 Google Cloud 上包的公钥，并按以下方式添加：
- en: '[PRE14]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, add a new source list for the Kubernetes packages:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个新的源列表用于 Kubernetes 包：
- en: '[PRE15]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, it is good to install the Kubernetes packages:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，最好安装 Kubernetes 包：
- en: '[PRE16]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: CentOS
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CentOS
- en: 'To install Kubernetes packages in CentOS perform the following steps:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS 中安装 Kubernetes 包，请执行以下步骤：
- en: 'As with Ubuntu, new repository information needs to be added:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 Ubuntu 一样，需要添加新的仓库信息：
- en: '[PRE17]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we are ready to pull the packages from the Kubernetes source base via
    the `yum` command:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好通过 `yum` 命令从 Kubernetes 源库拉取包：
- en: '[PRE18]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: No matter what OS it is, check the version of the package you get!
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论是什么操作系统，检查你获取的包的版本！
- en: '[PRE19]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: System configuration prerequisites
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统配置前提条件
- en: Before running up the whole system by kubeadm, please check that Docker is running
    on your machine for Kubernetes. Moreover, in order to avoid critical errors while
    executing kubeadm, we will show the necessary service configuration on both the
    system and kubelet. As well as the master, please set the following configurations
    on the Kubernetes nodes to get kubelet to work fine with kubeadm.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过 kubeadm 启动整个系统之前，请确保 Docker 已在你的机器上运行。除此之外，为了避免在执行 kubeadm 时发生严重错误，我们将展示系统和
    kubelet 上必要的服务配置。作为主节点，请在 Kubernetes 节点上设置以下配置，以确保 kubelet 能与 kubeadm 正常工作。
- en: CentOS system settings
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CentOS 系统设置
- en: 'There are other additional settings in CentOS to make Kubernetes behave correctly.
    Be aware that, even if we are not using kubeadm to manage the Kubernetes cluster,
    the following setup should be considered while running kubelet:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS 中还有其他附加设置，以确保 Kubernetes 正常工作。请注意，即使我们没有使用 kubeadm 来管理 Kubernetes 集群，以下设置仍应在运行
    kubelet 时考虑：
- en: 'Disable SELinux, since kubelet does not support SELinux completely:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用 SELinux，因为 kubelet 完全不支持 SELinux：
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can `disable SELinux` through the following command, or by `modifying the
    configuration file`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令 `disable SELinux`，或者通过 `修改配置文件` 来禁用 SELinux：
- en: '[PRE21]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then we''ll need to `reboot` the machine:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要 `reboot` 机器：
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Enable the usage of iptables. To prevent some routing errors happening, add
    runtime parameters:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用 iptables 的使用。为了防止发生一些路由错误，请添加运行时参数：
- en: '[PRE23]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Booting up the service
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动服务
- en: 'Now we can start the service. First enable and then start kubelet on your Kubernetes
    master machine:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以启动服务了。首先启用并启动 Kubernetes 主节点上的 kubelet：
- en: '[PRE24]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'While checking the status of kubelet, you may be worried to see the status
    displaying activating (`auto-restart`); and you may get further frustrated to
    see the detail logs by the `journalctl` command, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查 kubelet 状态时，你可能会担心看到状态显示为激活（`auto-restart`）；并且你可能会更为沮丧，看到通过 `journalctl`
    命令查看的详细日志，如下所示：
- en: '`error: unable to load client CA file /etc/kubernetes/pki/ca.crt: open /etc/kubernetes/pki/ca.crt:
    no such file or directory`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`error: unable to load client CA file /etc/kubernetes/pki/ca.crt: open /etc/kubernetes/pki/ca.crt:
    no such file or directory`'
- en: Don't worry. kubeadm takes care of creating the certificate authorities file.
    It is defined in the service configuration file, `/etc/systemd/system/kubelet.service.d/10-kubeadm.conf
    by argument KUBELET_AUTHZ_ARGS`. The kubelet service won't be a healthy without
    this file, so keep trying to restart the daemon by itself.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心，kubeadm 会负责创建证书颁发机构文件。该文件在服务配置文件 `/etc/systemd/system/kubelet.service.d/10-kubeadm.conf`
    中通过参数 KUBELET_AUTHZ_ARGS 来定义。如果没有这个文件，kubelet 服务将无法正常工作，因此可以尝试自行重启该守护进程。
- en: 'Go ahead and start all the master daemons via kubeadm. It is worth noting that
    using kubeadm requires the root permission to achieve a service level privilege.
    For any sudoer, each kubeadm would go after the `sudo` command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 继续通过 kubeadm 启动所有主节点守护进程。值得注意的是，使用 kubeadm 需要 root 权限来获得服务级别的特权。对于任何 sudo 用户，每个
    kubeadm 命令都需要在 `sudo` 命令后运行：
- en: '[PRE25]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Find preflight checking error while firing command `kubeadm init`? Using following
    one to disable running swap as description.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 `kubeadm init` 命令时，如果出现预检错误？使用以下命令来禁用交换分区，如描述所示。
- en: '`$ sudo kubeadm init --ignore-preflight-errors=Swap`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ sudo kubeadm init --ignore-preflight-errors=Swap`'
- en: 'And you will see the sentence `Your Kubernetes master has initialized successfully!`
    showing on the screen. Congratulations! You are almost done! Just follow the information
    about the user environment setup below the greeting message:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会在屏幕上看到 `Your Kubernetes master has initialized successfully!` 这句话。恭喜！你几乎完成了！只需按照问候信息下方的用户环境设置说明继续操作：
- en: '[PRE26]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding commands ensure every Kubernetes instruction is fired by your
    account execute with the proper credentials and connects to the correct server
    portal:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令确保每个 Kubernetes 指令都由你的账户执行，并具有正确的凭据，并连接到正确的服务器门户：
- en: '[PRE27]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'More than that, kubelet goes into a healthy state now:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，kubelet 现在进入了健康状态：
- en: '[PRE28]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Network configurations for containers
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的网络配置
- en: After the master of the cluster is ready to handle jobs and the services are
    running, for the purpose of making containers accessible to each other through
    networking, we need to set up the network for container communication. It is even
    more important initially while building up a Kubernetes cluster with kubeadm,
    since the master daemons are all running as containers. kubeadm supports the CNI
    ([https://github.com/containernetworking/cni](https://github.com/containernetworking/cni)).
    We are going to attach the CNI via a Kubernetes network add-on.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群的主节点准备好处理任务并且服务正在运行之后，为了使容器通过网络互相访问，我们需要为容器间通信设置网络。在使用 kubeadm 构建 Kubernetes
    集群时，这一步尤为重要，因为主进程都是以容器形式运行的。kubeadm 支持 CNI（[https://github.com/containernetworking/cni](https://github.com/containernetworking/cni)）。我们将通过
    Kubernetes 网络附加组件来连接 CNI。
- en: 'There are many third-party CNI solutions that supply secured and reliable container
    network environments. Calico ([https://www.projectcalico.org](https://www.projectcalico.org)),
    one CNI provide stable container networking. Calico is light and simple, but still
    well implemented by the CNI standard and integrated with Kubernetes:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多第三方 CNI 解决方案提供安全可靠的容器网络环境。Calico（[https://www.projectcalico.org](https://www.projectcalico.org)）是一个提供稳定容器网络的
    CNI。Calico 轻量简洁，但仍然很好地遵循 CNI 标准并与 Kubernetes 集成：
- en: '[PRE29]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, whatever your host OS is, the command kubectl can fire any sub command
    for utilizing resources and managing systems. We use `kubectl` to apply the configuration
    of Calico to our new-born Kubernetes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，无论你的主机操作系统是什么，`kubectl` 命令都可以执行任何子命令来利用资源和管理系统。我们使用 `kubectl` 将 Calico 的配置应用到我们的新
    Kubernetes 集群中。
- en: More advanced management of networking and Kubernetes add-ons will be discussed
    in [Chapter 7](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml), *Building Kubernetes
    on GCP*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的网络管理和 Kubernetes 附加组件将会在[第七章](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml)中讨论，*在
    GCP 上构建 Kubernetes*。
- en: Getting a node involved
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取节点参与
- en: 'Let''s log in to your Kubernetes node to join the group controlled by kubeadm:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们登录到你的 Kubernetes 节点，加入由 kubeadm 控制的群组：
- en: 'First, enable and start the service, `kubelet`. Every Kubernetes machine should
    have `kubelet` running on it:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，启用并启动服务 `kubelet`。每台 Kubernetes 机器上都应该运行 `kubelet`：
- en: '[PRE30]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After that, fire the `kubeadm` join command with an input flag token and the
    IP address of the master, notifying the master that it is a secured and authorized
    node. You can get the token on the master node via the `kubeadm` command:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，使用 `kubeadm` 加入命令，输入标志 token 和主节点的 IP 地址，通知主节点这是一个安全且授权的节点。你可以通过 `kubeadm`
    命令在主节点上获取 token：
- en: '[PRE31]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding output, if `kubeadm init` succeeds, the default token will
    be generated. Copy the token and paste it onto the node, and then compose the
    following command:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的输出中，如果 `kubeadm init` 成功，默认令牌将被生成。复制令牌并粘贴到节点上，然后组成以下命令：
- en: '[PRE32]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What if you call `kubeadm token list` to list the tokens, and see they are
    all expired? You can create a new one manually by this command: `kubeadm token
    create` .'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用 `kubeadm token list` 来列出令牌，却发现它们都过期了怎么办？你可以通过以下命令手动创建一个新的令牌：`kubeadm token
    create`。
- en: 'Please make sure that the master''s firewall doesn''t block any traffic to
    port `6443`, which is for API server communication. Once you see the words `Successfully
    established connection` showing on the screen, it is time to check with the master
    if the group got the new member:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请确保主节点的防火墙没有阻止任何到 `6443` 端口的流量，该端口用于 API 服务器通信。一旦你看到屏幕上显示 `Successfully established
    connection`，就可以检查主节点是否已经接收到新成员。
- en: '[PRE33]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Well done! No matter if whether your OS is Ubuntu or CentOS, kubeadm is installed
    and kubelet is running. You can easily go through the preceding steps to build
    your Kubernetes cluster.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！无论你的操作系统是 Ubuntu 还是 CentOS，kubeadm 都已安装并且 kubelet 正在运行。你可以轻松地按照前面的步骤来构建你的
    Kubernetes 集群。
- en: 'You may be wondering about the flag `discovery-token-unsafe-skip-ca-verification`
    used while joining the cluster. Remember the kubelet log that says the certificate
    file is not found? That''s it, since our Kubernetes node is brand new and clean,
    and has never connected with the master before. There is no certificate file to
    find for verification. But now, because the node has shaken hands with the master,
    the file exists. We may join in this way (in some situation requiring rejoining
    the same cluster):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想了解在加入集群时使用的标志 `discovery-token-unsafe-skip-ca-verification`。还记得 kubelet
    日志中提到找不到证书文件吗？就是因为这样，因为我们的 Kubernetes 节点是全新的，之前从未与主节点连接过，所以没有可供验证的证书文件。但现在，因为节点已经与主节点完成了握手，文件存在了。我们可以这样加入（在某些需要重新加入同一集群的情况下）：
- en: '`kubeadm join --token $TOKEN $MASTER_IPADDR:6443 --discovery-token-ca-cert-hash
    sha256:$HASH`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubeadm join --token $TOKEN $MASTER_IPADDR:6443 --discovery-token-ca-cert-hash
    sha256:$HASH`'
- en: 'The hash value can be obtained by the `openssl` command:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希值可以通过 `openssl` 命令获得：
- en: '[PRE34]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'When kubeadm init sets up the master, there are six stages:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当 kubeadm init 设置主节点时，共有六个阶段：
- en: '**Generating certificate files and keys for services**: Certificated files
    and keys are used for security management during cross-node communications. They
    are located in the `/etc/kubernetes/pki` directory. Take kubelet, for example.
    It cannot access the Kubernetes API server without passing the identity verification.'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为服务生成证书文件和密钥**：证书文件和密钥用于跨节点通信中的安全管理。它们位于 `/etc/kubernetes/pki` 目录下。以 kubelet
    为例，如果没有通过身份验证，它无法访问 Kubernetes API 服务器。'
- en: '**Writing kubeconfig files**: The `kubeconfig` files define permissions, authentication,
    and configurations for kubectl actions. In this case, the Kubernetes controller
    manager and scheduler have related `kubeconfig` files to fulfill any API requests.'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写 kubeconfig 文件**：`kubeconfig` 文件定义了 kubectl 操作的权限、身份验证和配置。在这种情况下，Kubernetes
    控制器管理器和调度器有相关的 `kubeconfig` 文件，以处理任何 API 请求。'
- en: '**Creating service daemon YAML files**: The service daemons under kubeadm''s
    control are just like computing components running on the master. As with setting
    deployment configurations on disk, kubelet will make sure each daemon is active.'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建服务守护进程 YAML 文件**：在 kubeadm 控制下的服务守护进程就像在主节点上运行的计算组件一样。与设置磁盘上的部署配置类似，kubelet
    会确保每个守护进程保持活动状态。'
- en: '**Waiting for kubelet to be alive, running the daemons as pods**: When kubelet
    is alive, it will boot up the service pods described in the files under the `/etc/kubernetes/manifests`
    directory. Moreover, kubelet guarantees to keep them activated, restarting the
    pod automatically if it crashes.'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**等待 kubelet 存活，运行作为 Pod 的守护进程**：当 kubelet 存活时，它会启动 `/etc/kubernetes/manifests`
    目录下文件中描述的服务 Pod。此外，kubelet 确保这些 Pod 始终保持活动状态，如果 Pod 崩溃，它会自动重启。'
- en: '**Setting post-configuration for the cluster**: Some cluster configurations
    still need to be set, such as configuring **role-based accessing control** (**RBAC**)
    rules, creating a namespace, and tagging the resources.'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为集群设置后配置**：一些集群配置仍然需要设置，例如配置 **基于角色的访问控制** (**RBAC**) 规则、创建命名空间和标记资源。'
- en: '**Applying add-ons**: DNS and proxy services can be added along with the kubeadm
    system.'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用附加组件**：DNS 和代理服务可以与 kubeadm 系统一起添加。'
- en: While the user enters kubeadm and joins the Kubernetes node, kubeadm will complete
    the first two stages like the master.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: If you have faced a heavy and complicated set up procedure in earlier versions
    of Kubernetes, it is quite a relief to set up a Kubernetes cluster with kubeadm.
    kubeadm reduces the overhead of configuring each daemon and starting them one
    by one. Users can still do customization on kubelet and master services, by just
    modifying a familiar file, `10-kubeadm.conf` and the YAML files under `/etc/kubernetes/manifests`.
    Kubeadm not only helps to establish the cluster but also enhances security and
    availability, saving you time.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We talked about how to build a Kubernetes cluster. If you''re ready to run
    your first application on it, check the last recipe in this chapter and run the
    container! And for advanced management of your cluster, you can also look at [Chapter
    8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml), *Advanced Cluster Administration*,
    of this book:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '*Advanced settings in kubeconfig*, in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Kubernetes cluster on Linux via Ansible (kubespray)
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are familiar with configuration management, such as Puppet, Chef and
    Ansible, kubespray ([https://github.com/kubernetes-incubator/kubespray](https://github.com/kubernetes-incubator/kubespray))
    is the best choice to set up a Kubernetes cluster from scratch. It provides the
    Ansible playbook that supports the majority of Linux distributions and public
    clouds, such as AWS and GCP.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Ansible ([https://www.ansible.com](https://www.ansible.com)) is a Python-based
    SSH automation tool that can configure Linux as your desired state based on the
    configuration, which is called playbook. This cookbook describes how to use kubespray
    to set up Kubernetes on Linux.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As of May 2018, the latest version of kubespray is 2.5.0, which supports the
    following operation systems to install Kubernetes:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: RHEL/CentOS 7
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu 16.04 LTS
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: According to the kubespray documentation, it also supports CoreOS and debian
    distributions. However, those distributions may need some additional steps or
    have technical difficulties. This cookbook uses CentOS 7 and Ubuntu 16.04 LTS.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, you need to install Ansible on your machine. Ansible works on
    Python 2.6, 2.7, and 3.5 or higher. macOS and Linux might be the best choice to
    install Ansible because Python is preinstalled by most of macOS and Linux distributions
    by default. In order to check which version of Python you have, open a Terminal
    and type the following command:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Overall, you need at least three machines, as mentioned in the following table:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type of host** | **Recommended OS/Distribution** |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| Ansible | macOS or any Linux which has Python 2.6, 2.7, or 3.5 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| Kubernetes master | RHEL/CentOS 7 or Ubuntu 16.04 LTS |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: '| Kubernetes node | RHEL/CentOS 7 or Ubuntu 16.04 LTS |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: 'There are some network communicating with each other, so you need to at least
    open a network port (for example, AWS Security Group or GCP Firewall rule) as:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在一些相互通信的网络，因此你至少需要开放一个网络端口（例如，AWS 安全组或 GCP 防火墙规则），如：
- en: '**TCP/22 (ssh)**: Ansible to Kubernetes master/node host'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TCP/22（ssh）**：Ansible 到 Kubernetes 主节点/节点主机'
- en: '**TCP/6443 (Kubernetes API server)**: Kubernetes node to master'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TCP/6443（Kubernetes API 服务器）**：Kubernetes 节点到主节点'
- en: '**Protocol 4 (IP encapsulated in IP)**: Kubernetes master and node to each
    other by Calico'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议 4（IP 封装在 IP 中）**：Kubernetes 主节点和节点之间通过 Calico 通信'
- en: In Protocol 4 (IP encapsulated in IP), if you are using AWS, set an ingress
    rule to specify `aws ec2 authorize-security-group-ingress --group-id <your SG
    ID> --cidr <network CIDR> --protocol 4`. In addition, if you are using GCP, set
    the firewall rule to specify as `cloud compute firewall-rules create allow-calico
    --allow 4 --network <your network name> --source-ranges <network CIDR>`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议 4（IP 封装在 IP 中）中，如果你使用 AWS，设置一个入口规则来指定 `aws ec2 authorize-security-group-ingress
    --group-id <your SG ID> --cidr <network CIDR> --protocol 4`。另外，如果你使用 GCP，设置防火墙规则，指定
    `cloud compute firewall-rules create allow-calico --allow 4 --network <your network
    name> --source-ranges <network CIDR>`。
- en: Installing pip
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 pip
- en: 'The easiest way to install Ansible, is to use pip, the Python package manager.
    Some of newer versions of Python have `pip` already (Python 2.7.9 or later and
    Python 3.4 or later):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Ansible 的最简单方法是使用 pip，Python 包管理器。某些较新的 Python 版本已经自带 `pip`（Python 2.7.9
    或更高版本，Python 3.4 或更高版本）：
- en: 'To confirm whether `pip` is installed or not, similar to the Python command,
    use `-V`:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确认是否安装了 `pip`，可以使用类似 Python 命令的 `-V`：
- en: '[PRE36]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'On the other hand, if you see the following result, you need to install `pip`:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，如果你看到以下结果，你需要安装 `pip`：
- en: '[PRE37]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In order to install pip, download `get-pip.py` and install by using the following
    command:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安装 pip，下载 `get-pip.py` 并使用以下命令安装：
- en: '[PRE38]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Installing Ansible
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Ansible
- en: 'Perform the following steps to install Ansible:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来安装 Ansible：
- en: 'Once you have installed `pip`, you can install Ansible with the following command:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你安装了 `pip`，你可以使用以下命令安装 Ansible：
- en: '[PRE39]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`pip` scans your Python and installs the necessary libraries for Ansible, so
    it may take a few minutes to complete.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip` 会扫描你的 Python 环境并安装 Ansible 所需的库，因此可能需要几分钟才能完成。'
- en: 'Once you have successfully installed Ansible by `pip`, you can verify it with
    the following command and see output as this:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你成功通过 `pip` 安装了 Ansible，你可以通过以下命令进行验证，看到如下输出：
- en: '[PRE40]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Installing python-netaddr
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 python-netaddr
- en: 'Next, according to kubespray''s documentation ([https://github.com/kubernetes-incubator/kubespray#requirements](https://github.com/kubernetes-incubator/kubespray#requirements)),
    it needs the `python-netaddr` package. This package can also be installed by pip,
    as shown in the following code:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，根据 kubespray 的文档（[https://github.com/kubernetes-incubator/kubespray#requirements](https://github.com/kubernetes-incubator/kubespray#requirements)），它需要
    `python-netaddr` 包。这个包也可以通过 pip 安装，如下所示：
- en: '[PRE41]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Setting up ssh public key authentication
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 ssh 公钥认证
- en: One more thing, as mentioned previously, Ansible is actually the ssh automation
    tool. If you log on to host via ssh, you have to have an appropriate credential
    (user/password or ssh public key) to the target machines. In this case, the target
    machines mean the Kubernetes master and nodes.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事，如前所述，Ansible 实际上是一个 ssh 自动化工具。如果你通过 ssh 登录主机，你必须拥有适当的凭证（用户名/密码或 ssh 公钥）才能访问目标机器。在这种情况下，目标机器指的是
    Kubernetes 主节点和节点。
- en: Due to security reasons, especially in the public cloud, Kubernetes uses only
    the ssh public key authentication instead of ID/password authentication.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，特别是在公共云环境中，Kubernetes 只使用 ssh 公钥认证，而不使用 ID/密码认证。
- en: 'To follow the best practice, let''s copy the ssh public key from your Ansible
    machine to the Kubernetes master/node machines:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循最佳实践，让我们将 ssh 公钥从你的 Ansible 机器复制到 Kubernetes 主节点/节点机器：
- en: If you've already set up ssh public key authentication between the Ansible machine
    to Kubernetes candidate machines, you can skip this step.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经设置了 Ansible 机器与 Kubernetes 候选机器之间的 ssh 公钥认证，你可以跳过此步骤。
- en: 'In order to create an ssh public/private key pair from your Ansible machine,
    type the following command:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从你的 Ansible 机器创建 ssh 公私钥对，请输入以下命令：
- en: '[PRE42]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It will ask you to set a passphrase. You may set or skip (empty) this, but you
    have to remember it.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会要求你设置一个密码短语。你可以设置或跳过（留空），但你必须记住它。
- en: 'Once you have successfully created a key pair, you can see the private key
    as `~/.ssh/id_rsa` and public key as `~/.ssh/id_rsa.pub`. You need to append the
    public key to the target machine under `~/.ssh/authorized_keys`, as shown in the
    following screenshot:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/669c5f59-6af8-4865-a8f6-5d4b7dea7d7b.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
- en: You need to copy and paste your public key to all Kubernetes master and node
    candidate machines.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make sure your ssh public key authentication works, just ssh from the Ansible
    machine to the target host that won''t ask for your logon password, as here:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now you are all set! Let's set up Kubernetes using kubespray (Ansible) from
    scratch.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'kubespray is provided through the GitHub repository ([https://github.com/kubernetes-incubator/kubespray/tags](https://github.com/kubernetes-incubator/kubespray/tags)),
    as shown in the following screenshot:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59438d0b-62fd-4241-896c-f27f0e78185c.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
- en: 'Because kubespray is an Ansible playbook, not a binary, you can download the
    latest version (as of May 2018, version 2.5.0 is the latest) of the `zip` or `tar.gz`
    to your Ansible machine directly and unarchive it with the following command:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Maintaining the Ansible inventory
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to perform the Ansible playbook, you need to maintain your own inventory
    file, which contains target machine IP addresses:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a sample inventory file under the inventory directory, so you can
    copy it by using the following:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In this cookbook, we are using target machines that have the following IP addresses:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Kubernetes master : `10.128.0.2`'
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kubernetes node : `10.128.0.4`'
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, `hosts.ini` should be in the following format:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ea729763-477f-49f1-b64e-4ef047102ad7.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
- en: Please change the IP address to match your environment.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that hostname (`my-master-1` and `my-node-1`) will be set by the kubespray
    playbook based on this `hosts.ini`, so feel free to assign a meaningful hostname.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Running the Ansible ad hoc command to test your environment
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before running the kubespray playbook, let''s check whether `hosts.ini` and
    Ansible itself work properly or not:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, use the Ansible ad hoc command, using the ping module, as shown
    in the following screenshot:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f64fdf05-c6ff-4b77-9fc9-23af593c08aa.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
- en: 'This result indicates `SUCCESS`. But if you see the following error, probably
    the IP address is wrong or the target machine is down, so please the check target
    machine first:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/13ae1baa-a1ae-4655-8ea9-426410983ed7.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
- en: 'Next, check your authority whether you can escalate a privilege on the target
    machine or not. In other words, whether you can run `sudo` or not. This is because
    you will need to install Kubernetes, Docker, and some related binaries, and configurations
    that need a root privilege. To confirm that, add the `-b` (become) option, as
    shown in the following screenshot:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0c2f06a0-2e53-40e7-be10-cb2c28eb05ae.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
- en: With the `-b` option, it actually tries to perform sudo on the target machine.
    If you see `SUCCESS`, you are all set! Go to the *How it works…* section to run
    kubespray.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you're unfortunate enough to see some errors, please refer to the following
    section to solve Ansible issues.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Ansible troubleshooting
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ideal situation would be to use the same Linux distribution, version, settings,
    and logon user. However, the environment will be different based on policy, compatibility,
    and other reasons. Ansible is flexible and can support many use cases to run `ssh`
    and `sudo`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Need to specify a sudo password
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on your Linux machine setting, you may see the following error when adding
    the `-b` option. In this case, you need to type your password while running the
    `sudo` command:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cb344cb-f98a-4b6d-9526-bac1590dadbe.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
- en: 'In this case, add `-K` (ask for the `sudo` password) and run again. It will
    ask for your sudo password when running the Ansible command, as shown in the following
    screenshot:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2efbf16-c053-420d-9fe7-8ee7933675fd.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
- en: 'If your Linux uses the `su` command instead of `sudo`, adding `--become-method=su`
    to run the Ansible command could help. Please read the Ansible documentation for
    more details : [http://docs.ansible.com/ansible/latest/become.html](http://docs.ansible.com/ansible/latest/become.html)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Need to specify different ssh logon user
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you may need to ssh to target machines using a different logon user.
    In this case, you can append the `ansible_user` parameter to an individual host
    in `hosts.ini`. For example:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Use the username `kirito` to `ssh` to `my-master-1`
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the username `asuna` to `ssh` to `my-node-1`
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, change `hosts.ini`, as shown in the following code:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Need to change ssh port
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another scenario is where you may need to run the ssh daemon on some specific
    port number rather than the default port number `22`. Ansible also supports this
    scenario and uses the `ansible_port` parameter to the individual host in `hosts.ini`,
    as shown in the following code (in the example, the `ssh` daemon is running at
    `10022` on `my-node-1`):'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Common ansible issue
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible is flexible enough to support any other situations. If you need any
    specific parameters to customize the ssh logon for the target host, read the Ansible
    inventory documentation to find a specific parameter: [http://docs.ansible.com/ansible/latest/intro_inventory.html](http://docs.ansible.com/ansible/latest/intro_inventory.html)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, Ansible has a configuration file, `ansible.cfg`, on top of the
    `kubespray` directory. It defines common settings for Ansible. For example, if
    you are using a very long username that usually causes an Ansible error, change
    `ansible.cfg` to set `control_path` to solve the issue, as shown in the following
    code:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you plan to set up more than `10` nodes, you may need to increase ssh simultaneous
    sessions. In this case, adding the `forks` parameter also requires you to increase
    the ssh timeout from `10` seconds to `30` seconds by adding the timeout parameter,
    as shown in the following code:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following screenshot contains all of the preceding configurations in `ansible.cfg`:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7643fd9-85af-40ff-804c-f62fadabb2f3.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
- en: For more details, please visit the Ansible configuration documentation at [http://docs.ansible.com/ansible/latest/intro_configuration.html](http://docs.ansible.com/ansible/latest/intro_configuration.html)
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now you can start to run the kubepray playbook:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: You've already created an inventory file as `inventory/mycluster/hosts.ini`.
    Other than `hosts.ini`, you need to check and update global variable configuration
    files at `inventory/mycluster/group_vars/all.yml`.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are a lot of variables defined, but at least one variable, `bootstrap_os`
    , needs to be changed from `none` to your target Linux machine. If you are using
    RHEL/CentOS7, set `bootstrap_os` as `centos`. If you are using Ubuntu 16.04 LTS,
    set `bootstrap_os` as `ubuntu` as shown in the following screenshot:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6d901bec-7cf7-4f38-965b-8699f376d321.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
- en: You can also update other variables, such as `kube_version`, to change or install
    a Kubernetes version. For more details, read the documentation at [https://github.com/kubernetes-incubator/kubespray/blob/master/docs/vars.md](https://github.com/kubernetes-incubator/kubespray/blob/master/docs/vars.md).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can execute the playbook. Use the `ansible-playbook` command instead
    of the Ansible command. Ansible-playbook runs multiple Ansible modules based on
    tasks and roles that are defined in the playbook.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To run the kubespray playbook, type the ansible-playbook command with the following
    parameters:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The ansible-playbook argument parameter is the same as the Ansible command.
    So, if you need to use `-K` (ask for the `sudo` password) or `--become-method=su`,
    you need to specify for ansible-playbook as well.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'It takes around 5 to 10 minutes to complete based on the machine spec and network
    bandwidth. But eventually you can see `PLAY RECAP`, as shown in the following
    screenshot, to see whether it has succeeded or not:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1402d1ac-b161-4138-a5ad-5be4b9470580.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
- en: 'If you see `failed=0` like in the preceding screenshot, you have been successful
    in setting up a Kubernetes cluster. You can ssh to the Kubernetes master machine
    and run the `/usr/local/bin/kubectl` command to see the status, as shown in the
    following screenshot:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8a93387d-c43c-4f24-a7d3-4c2115f4fecd.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows that you have been successful in setting up the
    Kubernetes version 1.10.2 master and node. You can continue to use the `kubectl`
    command to configure you Kubernetes cluster in the following chapters.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unfortunately, if you see a failed count of more than 0, the Kubernetes cluster
    has probably not been set up correctly. Because failure is caused by many reasons,
    there is no single solution. It is recommended that you append the verbose option
    `-v` to see more detailed output from Ansible, as shown in the following code:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If the failure is timeout, just retrying the ansible-playbook command again
    may solve it. Because Ansible is designed as an idempotency, if you re-perform
    the ansible-playbook command twice or more, Ansible still can configure correctly.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the failure is change target IP address after you run ansible-playbook (for
    example, re-using the Ansible machine to set up another Kubernetes cluster), you
    need to clean up the fact cache file. It is located under `/tmp` directory, so
    you just delete this file, as shown in the following screenshot:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6990eb72-ec1c-4471-8af9-6cb8fdc41985.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
- en: See also
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section describes how to set up the Kubernetes cluster on the Linux OS
    using kubespray. It is the Ansible playbook that supports major Linux distribution.
    Ansible is simple, but due to supporting any situation and environment, you need
    to care about some different use cases. Especially with ssh and sudo-related configurations,
    you need to understand Ansible deeper to fit it with your environment.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Running your first container in Kubernetes
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! You've built your own Kubernetes cluster in the previous recipes.
    Now, let's get on with running your very first container, nginx ([http://nginx.org/](http://nginx.org/)),
    which is an open source reverse proxy server, load balancer, and web server. Along
    with this recipe, you will create a simple nginx application and expose it to
    the outside world.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you start to run your first container in Kubernetes, it''s better to
    check if your cluster is in a healthy mode. A checklist showing the following
    items would make your `kubectl` sub commands stable and successful, without unknown
    errors caused by background services:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking the master daemons. Check whether the Kubernetes components are running:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Check the status of the Kubernetes master:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Check whether all the nodes are ready:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Ideal results should look like the preceding outputs. You can successfully fire
    the `kubectl` command and get the response without errors. If any one of the checked
    items failed to meet the expectation, check out the settings in the previous recipes
    based on the management tool you used.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Check the access permission of the Docker registry, as we will use the official
    free image as an example. If you want to run your own application, be sure to
    dockerize it first! What you need to do for your custom application is to write
    a Dockerfile ([https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)),
    and build and push it into the public or private Docker registry.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test your node connectivity with the public/private Docker registry
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: On your node, try the Docker pull nginx command to test whether you can pull
    the image from the Docker Hub. If you're behind a proxy, please add `HTTP_PROXY`
    into your Docker configuration file([https://docs.docker.com/engine/admin/systemd/#httphttps-proxy](https://docs.docker.com/engine/admin/systemd/#httphttps-proxy)).
    If you want to run the image from the private repository in the Docker Hub, or
    the image from the private Docker registry, a Kubernetes secret is required. Please
    check *Working with secrets*, in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Working through Kubernetes Concepts*, *for the instructions.*
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the official Docker image of nginx as an example. The image is provided
    in the Docker Hub ([https://store.docker.com/images/nginx](https://store.docker.com/images/nginx)),
    and also the Docker Store ([https://hub.docker.com/_/nginx/](https://hub.docker.com/_/nginx/)).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Many of the official and public images are available on the Docker Hub or Docker
    Store so that you do not need to build them from scratch. Just pull them and set
    up your custom setting on top of them.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Docker Store versus Docker Hub
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: As you may be aware, there is a more familiar official repository, Docker Hub,
    which was launched for the community for sharing the based image. Compared with
    the Docker Hub, the Docker Store is focused on enterprise applications. It provides
    a place for enterprise-level Docker images, which could be free or paid for software.
    You may feel more confident in using a more reliable image on the Docker Store.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Running a HTTP server (nginx)
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the Kubernetes master, we can use `kubectl run` to create a certain number
    of containers. The Kubernetes master will then schedule the pods for the nodes
    to run, with general command formatting, as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The following example will create two replicas with the name `my-first-nginx`
    from the nginx image and expose port `80`. We can deploy one or more containers
    in what is referred to as a pod. In this case, we will deploy one container per
    pod. Just like a normal Docker behavior, if the nginx image doesn''t exist locally,
    it will pull it from the Docker Hub by default:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The name of deployment <my-first-nginx> cannot be duplicated
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'The resource (pods, services, deployment, and so on) in one Kubernetes namespace
    cannot be duplicated. If you run the preceding command twice, the following error
    will pop up:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s move on and see the current status of all the pods by `kubectl get pods`.
    Normally the status of the pods will hold on Pending for a while, since it takes
    some time for the nodes to pull the image from the registry:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If the pod status is not running for a long time
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: "You could always use kubectl get pods to check the current status of the pods,\
    \ and kubectl describe pods `$pod_name` to check the detailed information in a\
    \ pod. If you make a typo of the image name, you might get the `ErrImagePull`\
    \ error message, and if you are pulling \Lthe images from a private repository\
    \ or registry without proper credentials, you might get the `ImagePullBackOff`\
    \ message. If you get the `Pending` status for a long time and check out the node\
    \ capacity, make sure you don't run too many replicas that exceed the node capacity.\
    \ If there are other unexpected error messages, you could either stop the pods\
    \ or the entire replication controller to force the master to schedule the tasks\
    \ again."
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check the details about the deployment to see whether all the
    pods are ready:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Exposing the port for external access
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We might also want to create an external IP address for the nginx deployment.
    On cloud providers that support an external load balancer (such as Google compute
    engine), using the `LoadBalancer` type will provision a load balancer for external
    access. On the other hand, you can still expose the port by creating a Kubernetes
    service as follows, even though you''re not running on platforms that support
    an external load balancer. We''ll describe how to access this externally later:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can see the service status we just created:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You may find an additional service named `kubernetes` if the service daemon
    run as a container (for example, using kubeadm as a management tool). It is for
    exposing the REST API of the Kubernetes API server internally. The pending state
    of `my-first-nginx` service's external IP indicates that it is waiting for a specific
    public IP from cloud provider. Take a look at [Chapter 6](b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml),
    *Building Kubernetes on AWS*, and [Chapter 7](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml),
    *Building Kubernetes on GCP*, for more details.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You just ran your first container with a Kubernetes pod and
    exposed port `80` with the Kubernetes service.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Stopping the application
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can stop the application using commands such as the delete deployment and
    service. Before this, we suggest you read through the following code first to
    understand more about how it works:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works…
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the insight of the service using describe in the `kubectl`
    command. We will create one Kubernetes service with the type `LoadBalancer`, which
    will dispatch the traffic into two endpoints, `192.168.79.9` and `192.168.79.10`
    with port `80`:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The port here is an abstract service port, which will allow any other resources
    to access the service within the cluster. The `nodePort` will be indicating the
    external port to allow external access. The `targetPort` is the port the container
    allows traffic into; by default, it will be the same port.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, external access will access the service with `nodePort`.
    The service acts as a load balancer to dispatch the traffic to the pod using port
    `80`. The pod will then pass through the traffic into the corresponding container
    using `targetPort 80`:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f7b733a-b8aa-47b9-904e-137cc1e958f6.png)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
- en: 'In any nodes or master, once the inter-connection network is set up, you should
    be able to access the nginx service using `ClusterIP` `192.168.61.150` with port
    `80`:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'It will be the same result if we `curl` to the target port of the pod directly:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If you'd like to try out external access, use your browser to access the external
    IP address. Please note that the external IP address depends on which environment
    you're running in.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Google compute engine, you could access it via a `ClusterIP` with a
    proper rewall rules setting:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In a custom environment, such as on-premise data center, you could go through
    the IP address of nodes to access :'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You should be able to see the following page using a web browser:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3d0dfde-0b38-463c-809f-65f6cc14f357.png)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
- en: See also
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have run our very first container in this section. Go ahead and read the
    next chapter to aquire more knowledge about Kubernetes:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking through Kubernetes
    Concepts*'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
