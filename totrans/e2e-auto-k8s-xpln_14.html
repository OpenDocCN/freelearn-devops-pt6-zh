<html><head></head><body>
		<div id="_idContainer125">
			<h1 id="_idParaDest-169"><em class="italic"><a id="_idTextAnchor168"/>Chapter 11</em>: Driving the Platform Adoption</h1>
			<p>By now, you might be thinking about adopting Crossplane in your organization. As we’ve discussed many times, we must set up a platform team to support every product team across the organization adopting Crossplane. But many organizations fail with their technology platform projects because these platforms impact the agility of the consuming teams in many ways. Setting up proper boundaries and an interaction model between the product and platform teams is key to the success of a platform. This chapter aims to help you understand the aspects required to build and adopt a successful infrastructure platform. We will also look at a few common pitfalls that can lead to weak platform adoption and low return on investment.</p>
			<p>The following are the topics covered in this chapter:</p>
			<ul>
				<li>Why we need an infrastructure platform as a product</li>
				<li>Understanding customers’ needs</li>
				<li>The platform prodcut life cycle and team interaction</li>
				<li>The OAM personas</li>
			</ul>
			<p>In the following section, we will start with understanding why we need to approach infrastructure platforms as product development.</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor169"/>Why we need an infrastructure platform as a product</h1>
			<p>We touched on this topic a bit in <a href="B17830_02_ePub.xhtml#_idTextAnchor025"><em class="italic">Chapter 2</em></a>. It is time to look back and see why we need a <a id="_idIndexMarker602"/>platform team to develop the Crossplane APIs. The following are the three key reasons:</p>
			<ul>
				<li><strong class="bold">Cognitive load</strong>: Any organization will tend to use a vast amount of cloud resources and other external services. These resources and services consist of tens of thousands of attributes to configure them according to the organization’s requirements. Remembering the usage of each configuration attribute involves a significant cognitive load. Suppose we attempt to build this knowledge within the product team. In that case, the team will focus on technical complexity rather than product feature development, which is of direct business interest. If you look <a id="_idIndexMarker603"/>at the CNCF cloud-native landscape, it’s vast (<a href="https://landscape.cncf.io/">https://landscape.cncf.io/</a>). Not every team can tame the terrain. It requires a specialized group to build this cognitive capability into the organization. Provided every product team <a id="_idIndexMarker604"/>faces the same situation, it makes sense to abstract this effort as a shared service managed by a platform team.</li>
				<li><strong class="bold">Policy management</strong>: Infrastructure and other external services’ usage policies come from security, compliance, product, and architecture teams. It requires a centralized team to track, consolidate, and encode the policies when these resources are provisioned and used. It won’t be easy to keep the policies enforced and updated if we have these resources’ automation as part of individual product teams.</li>
				<li><strong class="bold">Return on investment on reuse</strong>: Generally, many tools, architecture patterns, and infrastructure setup patterns look similar across the organization. This is because of centralized IT strategies, the cross-pollination of successful designs, the organization’s cognitive capability, and so on. These commonalities will translate into the reuse of infrastructure reference architecture. Provided we have the cognitive load and policy management advantages, the economics of return on investment with reuse is an added advantage.</li>
			</ul>
			<p>Now that we are convinced that an infrastructure platform team is required, the following section will explore the product teams’ expectations of the infrastructure platform team.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor170"/>Understanding customers’ needs</h1>
			<p>A platform team for infrastructure <a id="_idIndexMarker605"/>means external delivery dependency. This is something that is always avoided by agile product development teams. If you have worked in a large organization, you might have noticed that the product teams are often unhappy with what the platform team offers. They have issues with the delivery timeline, backlog coupling, and weak contracts. It is critical to set up a proper interaction model between the product and platform teams to mitigate these risks. The following are qualities that a platform team should possess to match the delivery expectations of product teams in the modern software engineering era:</p>
			<ul>
				<li>Product development practices</li>
				<li>Self-service</li>
				<li>Collaborative backlog management</li>
			</ul>
			<p>The following section will<a id="_idIndexMarker606"/> look at the product development engineering practices for the platform team.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor171"/>Product development practices</h2>
			<p>Adopting product<a id="_idIndexMarker607"/> development practices is a critical component that can make a platform team successful. The following are some of the product development practices for adoption:</p>
			<ul>
				<li><strong class="bold">Quick start</strong>: Platform <a id="_idIndexMarker608"/>usage must be made quick and straightforward. Crossplane being an API-based platform solves part of the problem. APIs have a clear contract, and they are easy to understand. But this is not enough. We must make additional efforts to make the platform easy to adopt. We should have a quick-start guide, code repositories with examples, a support system to help adopting teams, and extensive API documentation. More importantly, the ability to quickly start should be a critical metric measured and continuously improved. We can do this with continuous feedback cycles between the product and platform teams. The feedback should be from multiple sources, such as customer surveys, usage statistics of various quick-starter asserts, usage statistics of the platform itself, and time to adoption. There should be incentives for the platform team to improve these metrics continuously.</li>
				<li><strong class="bold">Community of practice</strong>: Building a <a id="_idIndexMarker609"/>community with participants from the platform and product teams is another essential aspect. Application operators could be natural participants of the community from the product team. Being close to the product team’s requirements, they will bring a reality check to what we build as APIs in the platform. Again, there should be metrics and incentives to run the community <a id="_idIndexMarker610"/>successfully. We can use the community in many ways, such as for co-creation, as knowledge carriers, for two-way feedback flow channels, and for <a id="_idIndexMarker611"/>accelerating adoption. We will look at some of these options in detail in the following sections of the chapter.</li>
				<li><strong class="bold">Composable APIs</strong>: One of the critical challenges with technology platforms is that they enforce a particular <a id="_idIndexMarker612"/>way of development that hinders innovation. The platform should have a basic set of fine-grained XRs, above which we can quickly compose the claim recipes required by the product team. It is recommended to have two-layered APIs. The first layer should have fine-grained XRs composing organization-centralized policies, and the following layer should be the recipe layer, composing product-level policies and requirements. We could have a basic set of reused recipes used across the organization and leave space for the community to innovate new recipes. Some organization setups may require Goldilocks governance to avoid the community’s proliferation of too many new recipes.<p class="callout-heading">Information</p><p class="callout">Goldilocks architecture governance has gained traction in modern software engineering practices where a balanced approach is taken between governance and flexibility.</p></li>
			</ul>
			<p>In the following section, we will cover the self-service aspect of platform engineering.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor172"/>Self-service</h2>
			<p>Self-service is<a id="_idIndexMarker613"/> one of the critical aspects of building a platform. Think about how any cloud provider works. We have the console and the APIs to create/operate the resource required. It’s an entirely self-service model where users can manage resources according to their permissions. A refined resource granularity in a cloud provider environment will work for any organization and personas. We must have a similar experience for our platform as well. With Crossplane being an API-based resource composing platform, part of the problem is already solved. But we must put a lot of thought into defining the scope and granularity of the XR/claim APIs that the product teams will consume. What level of granularity will work for your organization is a crucial question to ask. It may depend on the organization’s size, the team boundaries, the technical maturity of the developers/platform team, and so on. Defining wrong boundaries will derail the self-service agenda.</p>
			<p>Getting the boundary perfect at first is difficult. It keeps on improving in iterations by measuring the self-service metrics. In addition to API boundaries, we need to focus on the quick-start guide, technical support system, and building community, as discussed earlier, to enable self-service further. The whole experience should be like how a successful cloud provider platform works. The only difference is that we operate on a higher level of abstraction to tame the complexity.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor173"/>Collaborative backlog management</h2>
			<p>A single centralized <a id="_idIndexMarker614"/>platform team serving multiple internal teams within the organization is not a fun place to work. We must manage the backlog to satisfy everyone’s needs. There will be continuous requests from every direction to enhance an existing XR/claim or create a new one. We may end up in many unwanted situations, such as constant delivery pressure on the platform team, impact on the product team’s delivery throughput, or frustrated product teams developing the capability locally. The following are some of the ways to mitigate these risks:</p>
			<ul>
				<li><strong class="bold">Backlog prioritization</strong>: Score <a id="_idIndexMarker615"/>each backlog item with metrics such as time criticality, missed opportunity, and short-/long-term business value, in a prioritization session. Document the reason for each score for visibility. All product teams with backlog items should be actively involved in the prioritization session. There could be a tendency that each product team tries to push their score up in the prioritization sessions. We can tackle that with a scoring slider where a total score is set<a id="_idIndexMarker616"/> on a metric, and the sum of the scores for each backlog should not exceed the set value.</li>
				<li><strong class="bold">Expectation management</strong>: Product teams are waiting for their backlog to be delivered, and they <a id="_idIndexMarker617"/>should be treated like end customers. It’s essential to set expectations for the customers on when and what they can expect. Use Scrum of Scrums or any other scale agile framework to find a way to provide regular updates. Provide an update on the progress and the delivery date. Be open and transparent about any delayed delivery.</li>
				<li><strong class="bold">Community and governance</strong>: Look at how open source projects such as Kubernetes and <a id="_idIndexMarker618"/>Crossplane work. They also face the same situation where there is a lot of expectation from many users for new features, enhancements, and bug fixes. These projects were initially started with a few focused developers. When the product moves from the alpha-beta stage to general availability, many customers start adopting it. At this point, managing the backlog becomes critical. These open source projects scale up the delivery velocity by building a solid <a id="_idIndexMarker619"/>community around them. Development activities by the community are governed by technical steering groups filled with core contributors. We could adopt the same model in the internal product as well. As we have said already, application operators close to the product team can be naturally attracted to the community. Product teams with pressing needs can allocate their application operator to co-create the product.</li>
			</ul>
			<p>In the following section, we will investigate various stages of platform API development and how they impact the interaction between the platform team and the product team.</p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor174"/>The platform product life cycle and team interaction</h1>
			<p>We may start our Crossplane API development as a small proof of concept working with one of the product<a id="_idIndexMarker620"/> teams. Later, when we are comfortable with the proof of concept, we will release an alpha version asking a few teams to consume and test it. Again, when we are satisfied with the alpha version, we will ask a few more sections of the organization to adopt and go live with the API. If everything goes well, we can move the API to general availability to be consumed by anyone in the organization. It will not end there. Sometimes, we will have the requirement to deprecate the APIs and mark them for removal in the future. The following figure represents the API journey:</p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B17830_11_01.jpg" alt="Figure 11.1 – Crossplane API life cycle&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – Crossplane API life cycle</p>
			<p>Every API may not go through all the phases mentioned. It may take its own path, moving from left to right and skipping some stages depending on the situation.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">Sometimes, we may move directly to the deprecated state from alpha or beta if we find no business value or technical feasibility.</p>
			<p>Each step requires a different engagement model and developer capability. The following list describes each of the life cycle phases:</p>
			<ul>
				<li><strong class="bold">Proof of concept and alpha stages</strong>: Two things are essential to consider at these stages. First, the<a id="_idIndexMarker621"/> interaction model between the product and platform teams should be collaboration. This means both teams should work closely together as much as possible. The capability of the developers involved should be rapid innovators. We don’t need the API to be scalable or reliable at this point. Our only aim should be to experiment with the feasibility and value as quickly as possible.</li>
				<li><strong class="bold">Beta stage</strong>: This stage should continue the collaborative work format, but we should slowly move toward self-service. The product teams should be able to request access to the <a id="_idIndexMarker622"/>new API using some self-service portal and start using it. Creating self-service artifacts should be performed at this stage. The platform team should perfect the self-service portal and API in close collaboration with the product team. The capability of the developers involved should be a mix of rapid innovators and people who can bring stability/reliability. Our aim should be to get ready for organization usage.</li>
				<li><strong class="bold">General availability</strong>: This is the <a id="_idIndexMarker623"/>stage of organization-wide usage. Two key aspects are being entirely self-service and having a stable and reliable API.</li>
				<li><strong class="bold">Depreciation and removal stage</strong>: Sometimes, we need to deprecate and remove support for an API. Pushing the <a id="_idIndexMarker624"/>product team to get rid of the API usage is not easy because they are stuck with their priority. The platform team should use the facilitating interaction model to execute the activity. The platform developers perform the actual work for the product team to get rid of an API. Again, the platform developers at this stage are required to be rapid innovators.<p class="callout-heading">Acknowledgment</p><p class="callout">Many of the concepts we discussed in this chapter are influenced by the ideas found in <a href="https://teamtopologies.com/">https://teamtopologies.com/</a>, Evan Bottcher’s work on platform engineering (<a href="https://martinfowler.com/articles/talk-about-platforms.html">https://martinfowler.com/articles/talk-about-platforms.html</a>), and finally, some experience in implementing these concepts at work.</p></li>
			</ul>
			<p>The following diagram represents the preceding API stages and the team interaction model discussed:</p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B17830_11_02.jpg" alt="Figure 11.2 – API stages and team interaction model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – API stages and team interaction model</p>
			<p>This takes<a id="_idIndexMarker625"/> us to the end of the platform life cycle discussion. In the following section, we will look at the <strong class="bold">Open Application Model</strong> (<strong class="bold">OAM</strong>) specification to take<a id="_idIndexMarker626"/> some inspiration for the organization-level team structure from the perspective of platform engineering.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor175"/>The OAM personas</h1>
			<p>We’ve touched upon OAM specifications several times throughout this book. We will refresh the same topic from the perspective of organizational structure. We will take some inspiration from the <a id="_idIndexMarker627"/>OAM model to organize the platform and its ecosystem. OAM proposes the following three personas to deploy and manage cloud-native applications:</p>
			<ul>
				<li><strong class="bold">Application developer</strong>: Concentrates <a id="_idIndexMarker628"/>on application development, keeping the entire emphasis on developing features that add value to customers directly.</li>
				<li><strong class="bold">Application operator</strong>: Offloads the complexity of configuring the applications in the cloud-native ecosystem <a id="_idIndexMarker629"/>from application developers. Enables the application development team to move faster with feature development. Application operators contribute to the end consumer indirectly.</li>
				<li><strong class="bold">Infrastructure operator</strong>: Offloads the complexity of configuring the cloud, other infrastructure, and<a id="_idIndexMarker630"/> services across the organization. It allows the application operator to focus on configuring and operating the application.</li>
			</ul>
			<p>Overlapping the OAM personas and other concepts we learned in this chapter, we could structure the platform team and its ecosystem as illustrated in the following diagram:</p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B17830_11_03.jpg" alt="Figure 11.3 – Platform ecosystem&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – Platform ecosystem</p>
			<p>The following <a id="_idIndexMarker631"/>aspects explain the team constructs represented in the preceding diagram:</p>
			<ul>
				<li>The organization <em class="italic">x</em> is split into multiple products.</li>
				<li>Each product is divided into multiple Scrum teams handling different subdomains.</li>
				<li>One or more application operators support configuring and operating all applications from a given product.</li>
				<li>The platform team acts as a cross-cutting service to support all product teams for infrastructure, service, and application automation.</li>
				<li>The platform team and application operator form the community to support activities such as co-creation and accelerating adoption.</li>
			</ul>
			<p>We could explore more models to structure the platform and its ecosystem. But the core idea is to manage the platform development as a product engineering practice treating all internal <a id="_idIndexMarker632"/>consumers as customers.</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor176"/>Summary</h1>
			<p>We started the book with an idea to support cloud-native architects, platform engineers, infrastructure operators, and application operators interested in simplifying infrastructure, application, and service automation with the Kubernetes APIs. Throughout the book, we’ve covered different aspects of building a fully declarative self-service control plane to automate infrastructure, applications, and services using Crossplane and Kubernetes. I hope you learned about the required concepts while having fun. Let’s together take software engineering in to a new era.</p>
		</div>
	</body></html>