<html><head></head><body>
		<div id="_idContainer092">
			<h1 id="_idParaDest-198" class="chapter-number"><a id="_idTextAnchor198"/>10</h1>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor199"/>SQL and NoSQL Databases at the Edge</h1>
			<p>When you have to create an edge system, a critical task is storing your data. For this, you have to take into consideration the resources that you have, the processor that your devices are using, and the type of data that you want to store. CAP theorem states that distributed data stores only provide two of the following guarantees: consistency, availability, and partition tolerance. So, this theorem can help you to decide which type of database is best according to your system needs. In this chapter, we are going to learn how to deploy different database types to run on edge systems using K3s and ARM devices. These examples include different techniques such as using ConfigMaps and Secrets to deploy your databases.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>CAP theorem for SQL and NoSQL databases</li>
				<li>Creating a volume to persist your data</li>
				<li>Using MySQL and MariaDB SQL databases</li>
				<li>Using a Redis key-value NoSQL database</li>
				<li>Using a MongoDB document-oriented NoSQL database</li>
				<li>Using a PostgreSQL object-relational SQL database</li>
				<li>Using a Neo4j graph NoSQL database </li>
			</ul>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor200"/>Technical requirements</h1>
			<p>To deploy the databases in this chapter, you need the following:</p>
			<ul>
				<li>A single- or multi-node K3s cluster using ARM devices with MetalLB, and Longhorn storage installed. If you are using Raspberry Pi devices, you will need at least 4 GB of RAM and at least the 4B model. Each node must have the Ubuntu ARM64 operating system in order to support the ARMv8 architecture, necessary for some deployments in this chapter.</li>
				<li><strong class="source-inline">kubectl</strong> configured to be used on your local machine, to avoid using the <strong class="source-inline">--kubeconfig</strong> parameter.</li>
				<li>Clone the repository at <a href="https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch10">https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch10</a> if you want to run the YAML configuration by using <strong class="source-inline">kubectl apply</strong> instead of copying the code from the book. Take a look at the directory <strong class="source-inline">yaml</strong> for the YAML examples inside the <strong class="source-inline">ch10</strong> directory. </li>
			</ul>
			<p>With this, you can deploy the databases explained in this chapter. So, let’s get started learning about CAP theorem first, to choose the right database for your specific use case.</p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor201"/>CAP theorem for SQL and NoSQL databases</h1>
			<p>CAP theorem <a id="_idIndexMarker711"/>was defined by Eric Brewer in 1999 and presented at the 19th Annual ACM Symposium<a id="_idIndexMarker712"/> on <strong class="bold">Principles of Distributed Computing</strong> (<strong class="bold">PODC</strong>) in 2000. This theorem states that a distributed data store can only provide two of the following guarantees:</p>
			<ul>
				<li><strong class="bold">Consistency</strong>: This <a id="_idIndexMarker713"/>means when reading information, the data store returns the most recent written data or returns an error if it fails. This refers to regular SQL databases that use atomic operations to guarantee that data is written. If not, the system automatically rolls back to a previous data state.</li>
				<li><strong class="bold">Availability</strong>: This<a id="_idIndexMarker714"/> means that all reads contain data, but it might not be the most recent. </li>
				<li><strong class="bold">Partition tolerance</strong>: This <a id="_idIndexMarker715"/>is the most desired feature in a distributed system. It means that data is distributed in several nodes, helping to reduce downtime for the database. This means that if a node is down, just a small portion of data will be inaccessible:</li>
			</ul>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B16945_10_01.jpg" alt="Figure 10.1 – CAP theorem diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – CAP theorem diagram</p>
			<p>This <a id="_idIndexMarker716"/>theorem is commonly used as a point of reference to design strong distributed systems in the context of data. Now, in<a id="_idIndexMarker717"/> the CAP theorem diagram (<em class="italic">Figure 10.1</em>), represented as a triangle, you can see the different sides, and how each side has a relationship with<a id="_idIndexMarker718"/> the other sides. Let’s explore these sides and give examples of databases:</p>
			<ul>
				<li><strong class="bold">CA</strong>: On this side, we can classify databases that have consistency and availability. Here, we can find SQLite, which is a very simple database. MySQL and PostgreSQL are very popular open source databases. SQL Server is a proprietary database from Microsoft and Neo4j is a graph database. Each of these databases tries to guarantee consistency and availability. These guarantees can be found <a id="_idIndexMarker719"/>on <strong class="bold">relational database management system</strong> (<strong class="bold">RDBMS</strong>)-based databases. But as we have mentioned, Neo4j is classified on this side of the triangle. Something important on this side is that the database will fail if the network is down.</li>
				<li><strong class="bold">CP</strong>: On this side, you <a id="_idIndexMarker720"/>can find databases that provide consistency and partition tolerance. This means that databases such as Mongo and Redis use algorithms to write information that guarantee the consistency of data. For example, MongoDB uses the reader-writer algorithm to write in the database. Redis uses a similar algorithm to write data. Talking about partition tolerance, MongoDB can distribute information across nodes. This gives MongoDB the ability to partition the data. This is sharding, which provides the partition tolerance feature to MongoDB. Other databases based on Bigtable work similarly. Those Bigtable-based databases usually read data from distributed buckets of information across the cloud. The problem in CP is the risk that some data will become unavailable when a node or source of data is down.</li>
				<li><strong class="bold">AP</strong>: On this side, databases look for availability and partition tolerance. Here, we can find databases such as Cassandra, CouchDB, Riak, DynamoDB, and databases based on Cassandra. For example, Cassandra has high availability, using its masterless technique to scale servers, but it doesn’t guarantee the consistency of data. That’s a common issue in some NoSQL databases. </li>
			</ul>
			<p>Before deciding which database is right for you, let’s explore what a relational and no-relational database is. A <strong class="bold">relational database</strong> is a <a id="_idIndexMarker721"/>database where the data is structured. This means that data is organized in tables, rows, and columns. These tables have relationships and dependencies. These databases use <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) to <a id="_idIndexMarker722"/>manage the information. Relational databases are also<a id="_idIndexMarker723"/> called <strong class="bold">SQL databases</strong>. They also use ACID operations. This stands for atomicity, consistency, isolation, and durability; these<a id="_idIndexMarker724"/> properties in data guarantee data integrity when errors and failures happen. Some examples are MySQL, PostgreSQL, and SQL Server.</p>
			<p>A <strong class="bold">non-relational database</strong> is <a id="_idIndexMarker725"/>not structured. It doesn’t use a table, row, and column data schema. Instead, it uses a storage model optimized for specific requirements of the type of data being stored. Some of these types of data could be JSON documents, key values, and so on. These databases are also called <strong class="bold">NoSQL databases</strong>. These <a id="_idIndexMarker726"/>databases don’t use ACID operations. They look for availability and partition tolerance for data. Some examples are MongoDB, Redis, Neo4j, and Cassandra. When choosing the right database, you can evaluate some of these questions:</p>
			<ul>
				<li>Which of the guarantees of consistency, partition tolerance, and availability does my system need? According to this, which database fits my system needs best?</li>
				<li>Does my database need to support the SQL language to query information?</li>
				<li>Do I need a database that supports the SQL language?</li>
				<li>Is my data not structured as JSON documents or do I need something structured as tables?</li>
				<li>What type of data am I storing? Do I need a SQL or NoSQL database?</li>
				<li>Do I need consistency, availability, or partition tolerance? Which of these components is important for my system?</li>
				<li>How many resources is my database going to use? How many simultaneous connections is my system expected to handle?</li>
				<li>Do I need to replicate information, implement rate limits, or have any other specific features in my database?</li>
				<li>How fast is my database at writing and reading data?</li>
				<li>How can I do replication or scaling on my database?</li>
			</ul>
			<p>These and <a id="_idIndexMarker727"/>other questions could be important when choosing the right database. So, this chapter focuses on giving you a quick start when choosing the right database, using CAP theorem and some examples of how to deploy some SQL and NoSQL databases mentioned in the CAP theorem description. These SQL and NoSQL databases will be deployed at the edge in a K3s cluster using containers. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You can find in the <em class="italic">Further reading</em> section some links to learn more about SQL and NoSQL databases, the official web links for the databases explained in this chapter, and complementary links to evaluate which database is best for your use case. A complementary theorem that you can use is the PACELC theorem. This looks for the trade-offs between latency and consistency when data is replicated.</p>
			<p>Now let’s move on to create a volume to persist your data before performing the deployment of your selected database.</p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor202"/>Creating a volume to persist your data</h1>
			<p>Before <a id="_idIndexMarker728"/>we start deploying our databases, let’s create a volume to store data first. For this, we have two options. One is to use a directory inside the server. This means that in order to not lose <a id="_idIndexMarker729"/>data, your Pods have to be provisioned in the same node as where your volume was created the first time. If you don’t want to depend on which node your pods are running, you have to choose a second option, which is to use a storage driver. If that’s your case, we are going to use Longhorn as our storage driver option. Now, let’s create our storage first, using a local directory. For this, follow the next steps:</p>
			<ol>
				<li>Create a <strong class="bold">PersistentVolume</strong> using the <strong class="source-inline">/mnt/data</strong> directory in the node to store data:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: PersistentVolume</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: db-pv-volume</strong></p><p class="source-code"><strong class="bold">  labels:</strong></p><p class="source-code"><strong class="bold">    type: local</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  storageClassName: manual</strong></p><p class="source-code"><strong class="bold">  capacity:</strong></p><p class="source-code"><strong class="bold">    storage: 5Gi</strong></p><p class="source-code"><strong class="bold">  accessModes:</strong></p><p class="source-code"><strong class="bold">    - ReadWriteOnce</strong></p><p class="source-code"><strong class="bold">  hostPath:</strong></p><p class="source-code"><strong class="bold">    path: "/mnt/data"</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Create<a id="_idIndexMarker730"/> a <strong class="bold">PersistentVolumeClaim</strong> using 5 GB of storage:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: PersistentVolumeClaim</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: db-pv-claim</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  storageClassName: manual</strong></p><p class="source-code"><strong class="bold">  accessModes:</strong></p><p class="source-code"><strong class="bold">    - ReadWriteOnce</strong></p><p class="source-code"><strong class="bold">  resources:</strong></p><p class="source-code"><strong class="bold">    requests:</strong></p><p class="source-code"><strong class="bold">      storage: 5Gi</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
			</ol>
			<p>If you <a id="_idIndexMarker731"/>want to use Longhorn as your storage, follow the next steps:</p>
			<ol>
				<li value="1">Create a PersistentVolumeClaim with 5 GB of storage, this time, using Longhorn:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: PersistentVolumeClaim</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: db-pv-claim</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  accessModes:</strong></p><p class="source-code"><strong class="bold">    - ReadWriteOnce</strong></p><p class="source-code"><strong class="bold">  storageClassName: longhorn</strong></p><p class="source-code"><strong class="bold">  resources:</strong></p><p class="source-code"><strong class="bold">    requests:</strong></p><p class="source-code"><strong class="bold">      storage: 5Gi</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
			</ol>
			<p>This is a<a id="_idIndexMarker732"/> critical step to persist and avoid losing your data. In the next sections, we are going to start deploying our databases, starting with basic configuration and adding more complex configurations such as using <strong class="bold">ConfigMaps</strong> and <strong class="bold">Secrets</strong> to perform more production-ready deployments. But first, let’s start with MySQL and MariaDB, very popular databases used across the internet.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor203"/>Using MySQL and MariaDB SQL databases</h1>
			<p>MySQL is a <a id="_idIndexMarker733"/>relational database that uses the SQL language to read and write information. It’s one of the most used databases on the internet. MariaDB is a fork of MySQL<a id="_idIndexMarker734"/> and the version used in this example is fully compatible with MySQL. It’s a very fast SQL database <a id="_idIndexMarker735"/>and it’s simple to use. After this brief introduction to MySQL, let’s get started deploying this database by following the next steps:</p>
			<ol>
				<li value="1">Create the MySQL deployment creating a PersistentVolumeClaim called <strong class="source-inline">db-pv-claim</strong>:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: apps/v1</strong></p><p class="source-code"><strong class="bold">kind: Deployment</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: mysql</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    matchLabels:</strong></p><p class="source-code"><strong class="bold">      app: mysql</strong></p><p class="source-code"><strong class="bold">  strategy:</strong></p><p class="source-code"><strong class="bold">    type: Recreate</strong></p><p class="source-code"><strong class="bold">  template:</strong></p><p class="source-code"><strong class="bold">    metadata:</strong></p><p class="source-code"><strong class="bold">      labels:</strong></p><p class="source-code"><strong class="bold">        app: mysql</strong></p><p class="source-code"><strong class="bold">    spec:</strong></p><p class="source-code"><strong class="bold">      containers:</strong></p><p class="source-code"><strong class="bold">      - image: mysql:8.0.28-oracle</strong></p><p class="source-code"><strong class="bold">        name: mysql</strong></p><p class="source-code"><strong class="bold">        env:</strong></p><p class="source-code"><strong class="bold">        - name: MYSQL_ROOT_PASSWORD</strong></p><p class="source-code"><strong class="bold">          value: password</strong></p><p class="source-code"><strong class="bold">        ports:</strong></p><p class="source-code"><strong class="bold">        - containerPort: 3306</strong></p><p class="source-code"><strong class="bold">          name: mysql</strong></p><p class="source-code"><strong class="bold">        volumeMounts:</strong></p><p class="source-code"><strong class="bold">        - name: mysql-persistent-storage</strong></p><p class="source-code"><strong class="bold">          mountPath: /var/lib/mysql</strong></p><p class="source-code"><strong class="bold">      volumes:</strong></p><p class="source-code"><strong class="bold">      - name: mysql-persistent-storage</strong></p><p class="source-code"><strong class="bold">        persistentVolumeClaim:</strong></p><p class="source-code"><strong class="bold">          claimName: db-pv-claim</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
			</ol>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Instead of using MySQL, you can use MariaDB, which is fully compatible with MySQL version 5.6. To do this, change the <strong class="source-inline">mysql:8.0.28-oracle</strong> image to <strong class="source-inline">arm64v8/mariadb:latest</strong> and the <strong class="source-inline">MYSQL_ROOT_PASSWORD</strong> variable to <strong class="source-inline">MARIADB_ROOT_PASSWORD</strong>. You can also check for other image versions in <a href="https://hub.docker.com">https://hub.docker.com</a> for MySQL and MariaDB images. For this deployment, the password is <strong class="source-inline">password</strong>. The images used for the deployment are both designed to run on ARM devices. In the case of MySQL reinstallation using local storage, you have to delete the content inside the <strong class="source-inline">/mnt/data</strong> directory using the <strong class="source-inline">rm -R /mnt/data</strong> command to avoid errors. </p>
			<ol>
				<li value="2">Now let’s <a id="_idIndexMarker736"/>create <a id="_idIndexMarker737"/>our service to access MySQL using a service:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: Service</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: mysql</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  ports:</strong></p><p class="source-code"><strong class="bold">  - port: 3306</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    app: mysql</strong></p><p class="source-code"><strong class="bold">  clusterIP: None </strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>To test whether your MySQL deployment works, you can access your deployment pod by running this:<p class="source-code"><strong class="bold">$ kubectl exec -it $(kubectl get pods -l app=mysql --output=jsonpath={..metadata.name}) -- bash</strong></p></li>
			</ol>
			<p>Inside the pod, run the following command to connect to your database:</p>
			<p class="source-code"><strong class="bold">$ mysql -h localhost -uroot -ppassword</strong></p>
			<p>Now, the<a id="_idIndexMarker738"/> prompt will change to <strong class="source-inline">mysql&gt;</strong>. Let’s create a simple<a id="_idIndexMarker739"/> database, <strong class="source-inline">EXAMPLE</strong>, with the <strong class="source-inline">VALUE_TABLE</strong> table, and insert and list some records. To do this, run the following commands and you will see output like this:</p>
			<p class="source-code"><strong class="bold">mysql&gt; CREATE DATABASE EXAMPLE;</strong></p>
			<p class="source-code"><strong class="bold">Query OK, 1 row affected (0.02 sec)</strong></p>
			<p class="source-code"><strong class="bold"> </strong></p>
			<p class="source-code"><strong class="bold">mysql&gt; USE EXAMPLE;</strong></p>
			<p class="source-code"><strong class="bold">Database changed</strong></p>
			<p class="source-code"><strong class="bold">mysql&gt; CREATE TABLE VALUE_TABLE (ID INT PRIMARY KEY NOT NULL,VALUE INT NOT NULL);</strong></p>
			<p class="source-code"><strong class="bold">Query OK, 0 rows affected (0.10 sec)</strong></p>
			<p class="source-code"><strong class="bold"> </strong></p>
			<p class="source-code"><strong class="bold">mysql&gt; INSERT INTO VALUE_TABLE (ID,VALUE) VALUES (1,123);</strong></p>
			<p class="source-code"><strong class="bold">Query OK, 1 row affected (0.03 sec)</strong></p>
			<p class="source-code"><strong class="bold"> </strong></p>
			<p class="source-code"><strong class="bold">mysql&gt; SELECT * FROM VALUE_TABLE;</strong></p>
			<p class="source-code"><strong class="bold">+----+-------+</strong></p>
			<p class="source-code"><strong class="bold">| ID | VALUE |</strong></p>
			<p class="source-code"><strong class="bold">+----+-------+</strong></p>
			<p class="source-code"><strong class="bold">|  1 |   123 |</strong></p>
			<p class="source-code"><strong class="bold">+----+-------+</strong></p>
			<p class="source-code"><strong class="bold">1 row in set (0.00 sec)</strong></p>
			<ol>
				<li value="4">Finally, delete<a id="_idIndexMarker740"/> the <a id="_idIndexMarker741"/>table and database with the following commands: <p class="source-code"><strong class="bold">mysql&gt; DROP TABLE VALUE_TABLE;</strong></p><p class="source-code"><strong class="bold">Query OK, 0 rows affected (0.07 sec)</strong></p><p class="source-code"><strong class="bold"> </strong></p><p class="source-code"><strong class="bold">mysql&gt; DROP DATABASE EXAMPLE;</strong></p><p class="source-code"><strong class="bold">Query OK, 0 rows affected (0.05 sec)</strong></p><p class="source-code"><strong class="bold"> </strong></p><p class="source-code"><strong class="bold">mysql&gt; EXIT</strong></p><p class="source-code"><strong class="bold">Bye</strong></p></li>
			</ol>
			<p>Now you have learned how to use MySQL with this basic deployment and example. Now let’s move on to learn how Redis works.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor204"/>Using a Redis key-value NoSQL database</h1>
			<p>Now it’s time<a id="_idIndexMarker742"/> to use Redis as our key-value database. Redis is a nice key-value database that doesn’t consume many resources. All its data is stored in memory. It has very interesting types of data such as hash keys, lists, and sets. It also implements publisher-subscriber and streaming features to implement channels of communication and simple broker functionalities. For our Redis deployment, we are going to use a custom configuration to set the password for Redis, and a storage volume to prevent losing data. To use Redis in your cluster, follow the next steps:</p>
			<ol>
				<li value="1">Create the <strong class="bold">ConfigMap</strong> to use a custom configuration with the password <strong class="source-inline">K3s123-</strong> and the <strong class="source-inline">/data</strong> directory to store Redis data:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: ConfigMap</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: redis-configmap</strong></p><p class="source-code"><strong class="bold">data:</strong></p><p class="source-code"><strong class="bold">  redis-config: |</strong></p><p class="source-code"><strong class="bold">    dir /data</strong></p><p class="source-code"><strong class="bold">    requirepass YOUR_PASSWORD</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Create<a id="_idIndexMarker743"/> the deployment for Redis using the previous ConfigMap called <strong class="source-inline">redis-configmap</strong> and mounted as the <strong class="source-inline">redis.conf</strong> file. We also use the PersistentVolumeClaim called <strong class="source-inline">db-pv-claim</strong>, and some resource limits for the deployment, setting the CPU and memory. Let’s create the deployment by running the following command:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: apps/v1</strong></p><p class="source-code"><strong class="bold">kind: Deployment</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  labels:</strong></p><p class="source-code"><strong class="bold">    run: redis</strong></p><p class="source-code"><strong class="bold">  name: redis</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  replicas: 1</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    matchLabels:</strong></p><p class="source-code"><strong class="bold">      run: redis</strong></p><p class="source-code"><strong class="bold">  template:</strong></p><p class="source-code"><strong class="bold">    metadata:</strong></p><p class="source-code"><strong class="bold">      labels:</strong></p><p class="source-code"><strong class="bold">        run: redis</strong></p><p class="source-code"><strong class="bold">    spec:</strong></p><p class="source-code"><strong class="bold">      containers:</strong></p><p class="source-code"><strong class="bold">      - name: redis</strong></p><p class="source-code"><strong class="bold">        image: arm64v8/redis:6.2</strong></p><p class="source-code"><strong class="bold">        command:</strong></p><p class="source-code"><strong class="bold">          - redis-server</strong></p><p class="source-code"><strong class="bold">          - /redisconf/redis.conf</strong></p><p class="source-code"><strong class="bold">        ports:</strong></p><p class="source-code"><strong class="bold">        - containerPort: 6379</strong></p><p class="source-code"><strong class="bold">        resources:</strong></p><p class="source-code"><strong class="bold">          limits:</strong></p><p class="source-code"><strong class="bold">            cpu: "0.2"</strong></p><p class="source-code"><strong class="bold">            memory: "128Mi"</strong></p><p class="source-code"><strong class="bold">        volumeMounts:</strong></p><p class="source-code"><strong class="bold">        - mountPath: "/data"</strong></p><p class="source-code"><strong class="bold">          name: redis-storage</strong></p><p class="source-code"><strong class="bold">        - mountPath: /redisconf</strong></p><p class="source-code"><strong class="bold">          name: config</strong></p><p class="source-code"><strong class="bold">      volumes:</strong></p><p class="source-code"><strong class="bold">        - name: config</strong></p><p class="source-code"><strong class="bold">          configMap:</strong></p><p class="source-code"><strong class="bold">            name: redis-configmap</strong></p><p class="source-code"><strong class="bold">            items:</strong></p><p class="source-code"><strong class="bold">            - key: redis-config</strong></p><p class="source-code"><strong class="bold">              path: redis.conf</strong></p><p class="source-code"><strong class="bold">        - name: redis-storage</strong></p><p class="source-code"><strong class="bold">          persistentVolumeClaim:</strong></p><p class="source-code"><strong class="bold">            claimName: db-pv-claim</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Now create the<a id="_idIndexMarker744"/> <strong class="source-inline">redis</strong>, which points to port <strong class="source-inline">6379</strong> in our <strong class="source-inline">redis</strong> deployment:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: Service</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  labels:</strong></p><p class="source-code"><strong class="bold">    run: redis</strong></p><p class="source-code"><strong class="bold">  name: redis</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  ports:</strong></p><p class="source-code"><strong class="bold">  - port: 6379</strong></p><p class="source-code"><strong class="bold">    protocol: TCP</strong></p><p class="source-code"><strong class="bold">    targetPort: 6379</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    run: redis</strong></p><p class="source-code"><strong class="bold">  type: ClusterIP</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
			</ol>
			<p>This service creates a DNS record inside the cluster called <strong class="source-inline">redis</strong> that points to our <strong class="source-inline">redis</strong> deployment. This DNS record is accessible to other deployments in the cluster.</p>
			<ol>
				<li value="4">Let’s <a id="_idIndexMarker745"/>access our Redis pods to test some basic commands to store a value in our database. To do this, run the following command:<p class="source-code"><strong class="bold">$ kubectl exec -it $(kubectl get pods -l run=redis --output=jsonpath={..metadata.name}) -- redis-cli</strong></p></li>
			</ol>
			<p>The prompt will look like this: <strong class="source-inline">127.0.0.1:6379&gt;</strong>.</p>
			<ol>
				<li value="5">Now, authenticate to the Redis database using the <strong class="source-inline">AUTH</strong> command, and then use <strong class="source-inline">set</strong> and <strong class="source-inline">get</strong> to create the <strong class="source-inline">a</strong> key with the value <strong class="source-inline">1</strong>. Finally, exit using the <strong class="source-inline">exit</strong> command. This simple test will look like this:<p class="source-code"><strong class="bold">127.0.0.1:6379&gt; AUTH YOUR_PASSWORD</strong></p><p class="source-code"><strong class="bold">OK</strong></p><p class="source-code"><strong class="bold">127.0.0.1:6379&gt; set a 1</strong></p><p class="source-code"><strong class="bold">OK</strong></p><p class="source-code"><strong class="bold">127.0.0.1:6379&gt; get a</strong></p><p class="source-code"><strong class="bold">"1"</strong></p><p class="source-code"><strong class="bold">127.0.0.1:6379&gt; exit</strong></p></li>
			</ol>
			<p>With this, you stored the <strong class="source-inline">a</strong> key with the value <strong class="source-inline">1</strong>. Now you have used Redis to store simple values. After running <strong class="source-inline">exit</strong>, you will exit to the Redis pod.</p>
			<p>Now you <a id="_idIndexMarker746"/>have learned how to deploy a simple Redis deployment, it’s time to deploy MongoDB in the next section.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor205"/>Using a MongoDB document-oriented NoSQL database</h1>
			<p>MongoDB i<a id="_idIndexMarker747"/>s a document-oriented NoSQL database. It stores its data as JSON documents. It also implements sharding techniques to distribute data across <a id="_idIndexMarker748"/>its nodes and uses the MapReduce technique for data aggregation. It’s easy to use and uses low resources for single node scenarios. For our MongoDB deployment, we are going to use a ConfigMap to store custom configurations. In this case, our MongoDB configuration is set to expose its port across the network, but for the moment we are not using Secrets to simplify the deployment. In the <em class="italic">Using a PostgreSQL object-relational and SQL database</em> section, we are going to explore the use of secrets, but before that, let’s follow the next steps to deploy MongoDB:</p>
			<ol>
				<li value="1">Deploy your custom configuration to enable clients to connect to MongoDB:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: ConfigMap</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: mongo-configmap</strong></p><p class="source-code"><strong class="bold">data:</strong></p><p class="source-code"><strong class="bold">  mongod-conf: |</strong></p><p class="source-code"><strong class="bold">    dbpath=/var/lib/mongodb</strong></p><p class="source-code"><strong class="bold">    logpath=/var/log/mongodb/mongodb.log</strong></p><p class="source-code"><strong class="bold">    logappend=true</strong></p><p class="source-code"><strong class="bold">    bind_ip = 0.0.0.0</strong></p><p class="source-code"><strong class="bold">    port = 27017</strong></p><p class="source-code"><strong class="bold">    journal=true</strong></p><p class="source-code"><strong class="bold">    auth = true</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
			</ol>
			<p>This exposes MongoDB to listen on port <strong class="source-inline">27017</strong> across the network.</p>
			<ol>
				<li value="2">Create<a id="_idIndexMarker749"/> the deployment using the ConfigMap called <strong class="source-inline">mongo-configmap</strong>, the PersistentVolumeClaim, and the <strong class="source-inline">MONGO_INITDB_ROOT_USERNAME</strong>, <strong class="source-inline">MONGO_INITDB_ROOT_PASSWORD</strong>, and <strong class="source-inline">MONGO_INITDB_DATABASE</strong> variables, which set the initial root, user, and the password to connect to MongoDB as root or with your defined user:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: apps/v1</strong></p><p class="source-code"><strong class="bold">kind: Deployment</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  labels:</strong></p><p class="source-code"><strong class="bold">    app: mongo</strong></p><p class="source-code"><strong class="bold">  name: mongo</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  replicas: 1</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    matchLabels:</strong></p><p class="source-code"><strong class="bold">      app: mongo</strong></p><p class="source-code"><strong class="bold">  template:</strong></p><p class="source-code"><strong class="bold">    metadata:</strong></p><p class="source-code"><strong class="bold">      labels:</strong></p><p class="source-code"><strong class="bold">        app: mongo</strong></p><p class="source-code"><strong class="bold">    spec:</strong></p><p class="source-code"><strong class="bold">      containers:</strong></p><p class="source-code"><strong class="bold">      - image: arm64v8/mongo:4.4</strong></p><p class="source-code"><strong class="bold">        name: mongo</strong></p><p class="source-code"><strong class="bold">        env:</strong></p><p class="source-code"><strong class="bold">        - name: MONGO_INITDB_ROOT_USERNAME</strong></p><p class="source-code"><strong class="bold">          value: "admin"</strong></p><p class="source-code"><strong class="bold">        - name: MONGO_INITDB_ROOT_PASSWORD</strong></p><p class="source-code"><strong class="bold">          value: "YOUR_PASSWORD"</strong></p><p class="source-code"><strong class="bold">        - name: MONGO_INITDB_DATABASE</strong></p><p class="source-code"><strong class="bold">          value: "mydatabase"</strong></p><p class="source-code"><strong class="bold">        ports:</strong></p><p class="source-code"><strong class="bold">        - containerPort: 27017</strong></p><p class="source-code"><strong class="bold">        resources:</strong></p><p class="source-code"><strong class="bold">          limits:</strong></p><p class="source-code"><strong class="bold">            cpu: "0.5"</strong></p><p class="source-code"><strong class="bold">            memory: "200Mi"</strong></p><p class="source-code"><strong class="bold">        volumeMounts:</strong></p><p class="source-code"><strong class="bold">        - mountPath: "/data/db"</strong></p><p class="source-code"><strong class="bold">          name: mongo-storage</strong></p><p class="source-code"><strong class="bold">        - mountPath: /mongoconf</strong></p><p class="source-code"><strong class="bold">          name: config</strong></p><p class="source-code"><strong class="bold">      volumes:</strong></p><p class="source-code"><strong class="bold">        - name: config</strong></p><p class="source-code"><strong class="bold">          configMap:</strong></p><p class="source-code"><strong class="bold">            name: mongo-configmap</strong></p><p class="source-code"><strong class="bold">            items:</strong></p><p class="source-code"><strong class="bold">            - key: mongod-conf</strong></p><p class="source-code"><strong class="bold">              path: mongod.conf</strong></p><p class="source-code"><strong class="bold">        - name: mongo-storage</strong></p><p class="source-code"><strong class="bold">          persistentVolumeClaim:</strong></p><p class="source-code"><strong class="bold">            claimName: db-pv-claim</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
			</ol>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Be aware that if you want to use a version of MongoDB greater than 5.0, you need a device with ARMv8.2-A or higher in order to use it. That’s the reason to use MongoDB 4.4 for this example. MongoDB 4.4 is supported to run on ARMv8 processors such as a Raspberry Pi.</p>
			<ol>
				<li value="3">Now <a id="_idIndexMarker750"/>create the service that exposes your MongoDB deployment as a service accessible inside the cluster (MongoDB uses port <strong class="source-inline">27017</strong> to connect):<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: Service</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  labels:</strong></p><p class="source-code"><strong class="bold">    app: mongo</strong></p><p class="source-code"><strong class="bold">  name: mongo</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  ports:</strong></p><p class="source-code"><strong class="bold">  - port: 27017</strong></p><p class="source-code"><strong class="bold">    protocol: TCP</strong></p><p class="source-code"><strong class="bold">    targetPort: 27017</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    app: mongo</strong></p><p class="source-code"><strong class="bold">  type: ClusterIP</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Access<a id="_idIndexMarker751"/> the pod that contains MongoDB to test whether you are able to write some data:<p class="source-code"><strong class="bold">$ kubectl exec -it $(kubectl get pods -l app=mongo --output=jsonpath={..metadata.name}) -- mongo -uadmin -pYOUR_PASSWORD</strong></p></li>
			</ol>
			<p>Once you are inside the pod, change into <strong class="source-inline">mydatabase</strong> and insert the <strong class="source-inline">{"a":1}</strong> document in the <strong class="source-inline">mycollection</strong> collection using <strong class="source-inline">db.mycolletion.insert</strong>. Then, list the inserted document using <strong class="source-inline">db.mycollection.find</strong>. Finally, execute <strong class="source-inline">exit</strong> to finish the Mongo session. The commands and output of this execution will look like this:</p>
			<p class="source-code"><strong class="bold">&gt; use mydatabase</strong></p>
			<p class="source-code"><strong class="bold">switched to db mydatabase</strong></p>
			<p class="source-code"><strong class="bold">&gt; db.mycollection.insert({"a":1})</strong></p>
			<p class="source-code"><strong class="bold">WriteResult({ "nInserted" : 1 })</strong></p>
			<p class="source-code"><strong class="bold">&gt; db.mycollection.find()</strong></p>
			<p class="source-code"><strong class="bold">{ "_id" : ObjectId("622c498199789d3b03b20c45"), "a" : 1 }</strong></p>
			<p class="source-code"><strong class="bold">&gt; exit</strong></p>
			<p class="source-code"><strong class="bold">Bye</strong></p>
			<p>These are<a id="_idIndexMarker752"/> some basic commands to use MongoDB, to have a quick start with Mongo.</p>
			<p>Now you know how to deploy a simple MongoDB database in K3s, let’s move on to learn how to use Postgres in the next section.</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor206"/>Using a PostgreSQL object-relational and SQL database</h1>
			<p>PostgreSQL is an <a id="_idIndexMarker753"/>object-relational database, used because of its strong reputation for reliability, feature robustness, and performance. It uses SQL to query its data. It’s also commonly used for storing files or to store data used to create machine learning models. So, let’s<a id="_idIndexMarker754"/> learn how to deploy PostgreSQL in a very simple way. To do this, follow the next steps:</p>
			<ol>
				<li value="1">For this example, let’s use Kubernetes Secrets, and let’s create the password as <strong class="source-inline">YOUR_PASSWORD</strong> to give an example of how to hide sensible information as passwords. For this, let’s generate a Base64 encoding for your password with the following command:<p class="source-code"><strong class="bold">$ echo "YOUR_PASSWORD"| tr -d "\n"  | base64</strong></p></li>
			</ol>
			<p>The output will look like this:</p>
			<p class="source-code"><strong class="bold">WU9VUl9QQVNTV09SRA==</strong></p>
			<ol>
				<li value="2">Use the <a id="_idIndexMarker755"/>previous output to create your Secret object using a YAML file. You can create the <strong class="source-inline">db-password</strong> Secret with this value using the following command:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: Secret</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: db-password</strong></p><p class="source-code"><strong class="bold">data:</strong></p><p class="source-code"><strong class="bold">  password: WU9VUl9QQVNTV09SRA==</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Now create the Postgres deployment with the following command:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: apps/v1</strong></p><p class="source-code"><strong class="bold">kind: Deployment</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  labels:</strong></p><p class="source-code"><strong class="bold">    app: postgres</strong></p><p class="source-code"><strong class="bold">  name: postgres</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  replicas: 1</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    matchLabels:</strong></p><p class="source-code"><strong class="bold">      app: postgres</strong></p><p class="source-code"><strong class="bold">  template:</strong></p><p class="source-code"><strong class="bold">    metadata:</strong></p><p class="source-code"><strong class="bold">      labels:</strong></p><p class="source-code"><strong class="bold">        app: postgres</strong></p><p class="source-code"><strong class="bold">    spec:</strong></p><p class="source-code"><strong class="bold">      containers:</strong></p><p class="source-code"><strong class="bold">      - image: arm64v8/postgres:14.2</strong></p><p class="source-code"><strong class="bold">        name: postgres</strong></p><p class="source-code"><strong class="bold">        env:</strong></p><p class="source-code"><strong class="bold">        - name: PGDATA </strong></p><p class="source-code"><strong class="bold">          value: "/var/lib/postgresql/data/pgdata" </strong></p><p class="source-code"><strong class="bold">        - name: POSTGRES_PASSWORD </strong></p><p class="source-code"><strong class="bold">          valueFrom: </strong></p><p class="source-code"><strong class="bold">             secretKeyRef: </strong></p><p class="source-code"><strong class="bold">                name: db-password </strong></p><p class="source-code"><strong class="bold">                key: password</strong></p><p class="source-code"><strong class="bold">        ports:</strong></p><p class="source-code"><strong class="bold">        - containerPort: 5432</strong></p><p class="source-code"><strong class="bold">        resources:</strong></p><p class="source-code"><strong class="bold">          limits:</strong></p><p class="source-code"><strong class="bold">            cpu: "0.5"</strong></p><p class="source-code"><strong class="bold">            memory: "200Mi"</strong></p><p class="source-code"><strong class="bold">        volumeMounts:</strong></p><p class="source-code"><strong class="bold">        - mountPath: "/var/lib/postgresql/data"</strong></p><p class="source-code"><strong class="bold">          name: postgres-storage</strong></p><p class="source-code"><strong class="bold">      volumes:</strong></p><p class="source-code"><strong class="bold">        - name: postgres-storage</strong></p><p class="source-code"><strong class="bold">          persistentVolumeClaim:</strong></p><p class="source-code"><strong class="bold">            claimName: db-pv-claim</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Now <a id="_idIndexMarker756"/>create the <strong class="source-inline">postgres</strong> service by running the following command:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: Service</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  labels:</strong></p><p class="source-code"><strong class="bold">    app: postgres</strong></p><p class="source-code"><strong class="bold">  name: postgres</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  ports:</strong></p><p class="source-code"><strong class="bold">  - port: 5432</strong></p><p class="source-code"><strong class="bold">    protocol: TCP</strong></p><p class="source-code"><strong class="bold">    targetPort: 5432</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    app: postgres</strong></p><p class="source-code"><strong class="bold">  type: ClusterIP</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Access the pod that contains Postgres to test whether you can write some data. To do this, run the following command:<p class="source-code"><strong class="bold">$ kubectl exec -it $(kubectl get pods -l app=postgres --output=jsonpath={..metadata.name}) -- bash -c "PGPASSWORD='YOUR_PASSWORD' psql -h postgres -U postgres"</strong></p></li>
				<li>The prompt <a id="_idIndexMarker757"/>will look like <strong class="source-inline">postgres=#</strong>. Next, you will find some example commands and their output. This commands will be used to test whether our database works.</li>
			</ol>
			<p>First, create the <strong class="source-inline">VALUE_TABLE</strong> table with the <strong class="source-inline">ID</strong> and <strong class="source-inline">VALUE</strong> fields:</p>
			<p class="source-code"><strong class="bold">postgres=# CREATE TABLE VALUE_TABLE (ID INT PRIMARY KEY NOT NULL,VALUE INT NOT NULL);</strong></p>
			<p class="source-code"><strong class="bold">CREATE TABLE</strong></p>
			<p>Then insert a record with <strong class="source-inline">ID</strong>=<strong class="source-inline">1</strong> and <strong class="source-inline">VALUE</strong>=<strong class="source-inline">123</strong>:</p>
			<p class="source-code"><strong class="bold">postgres=# INSERT INTO VALUE_TABLE (ID,VALUE) VALUES (1,123);</strong></p>
			<p class="source-code"><strong class="bold">INSERT 0 1</strong></p>
			<p>Show the values:</p>
			<p class="source-code"><strong class="bold">postgres=# SELECT * FROM VALUE_TABLE;</strong></p>
			<p class="source-code"><strong class="bold"> id | value</strong></p>
			<p class="source-code"><strong class="bold">----+-------</strong></p>
			<p class="source-code"><strong class="bold">  1 |   123</strong></p>
			<p class="source-code"><strong class="bold">(1 row)</strong></p>
			<p>Delete the table:</p>
			<p class="source-code"><strong class="bold">postgres=# DROP TABLE VALUE_TABLE;</strong></p>
			<p class="source-code"><strong class="bold">DROP TABLE</strong></p>
			<p>Exit from Postgres:</p>
			<p class="source-code"><strong class="bold">postgres=# exit</strong></p>
			<p>Now you’ve<a id="_idIndexMarker758"/> learned how to install and run basic commands with Postgres to store your data in this database, let’s move on to learn about Neo4j, a graph NoSQL database, in the next section.</p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor207"/>Using a Neo4j graph NoSQL database</h1>
			<p>Neo4j is a graph <a id="_idIndexMarker759"/>database that can be used to store relationships between objects. Neo4j uses <strong class="bold">Cypher Query Language</strong> (<strong class="bold">CQL</strong>), which is the equivalent of SQL for relational <a id="_idIndexMarker760"/>databases. Neo4j also <a id="_idIndexMarker761"/>represents data using nodes, relationships, properties, and labels in a visual way. It supports ACID operations and native graph storage and processing. It has great scalability and enterprise support. Because of the way it stores data, it can be used for IoT applications to query relationships between data. So now, let’s install Neo4j by following the next steps:</p>
			<ol>
				<li value="1">Create the deployment for Neo4j:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: apps/v1</strong></p><p class="source-code"><strong class="bold">kind: Deployment</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  labels:</strong></p><p class="source-code"><strong class="bold">    app: neo4j</strong></p><p class="source-code"><strong class="bold">  name: neo4j</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  replicas: 1</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    matchLabels:</strong></p><p class="source-code"><strong class="bold">      app: neo4j</strong></p><p class="source-code"><strong class="bold">  template:</strong></p><p class="source-code"><strong class="bold">    metadata:</strong></p><p class="source-code"><strong class="bold">      labels:</strong></p><p class="source-code"><strong class="bold">        app: neo4j</strong></p><p class="source-code"><strong class="bold">    spec:</strong></p><p class="source-code"><strong class="bold">      containers:</strong></p><p class="source-code"><strong class="bold">      - image: arm64v8/neo4j</strong></p><p class="source-code"><strong class="bold">        name: neo4j</strong></p><p class="source-code"><strong class="bold">        env:</strong></p><p class="source-code"><strong class="bold">        - name: NEO4J_AUTH</strong></p><p class="source-code"><strong class="bold">          value: none</strong></p><p class="source-code"><strong class="bold">        ports:</strong></p><p class="source-code"><strong class="bold">            - containerPort: 7474</strong></p><p class="source-code"><strong class="bold">              name: http</strong></p><p class="source-code"><strong class="bold">            - containerPort: 7687</strong></p><p class="source-code"><strong class="bold">              name: bolt</strong></p><p class="source-code"><strong class="bold">            - containerPort: 7473</strong></p><p class="source-code"><strong class="bold">              name: https</strong></p><p class="source-code"><strong class="bold">        volumeMounts:</strong></p><p class="source-code"><strong class="bold">            - name: neo4j-data</strong></p><p class="source-code"><strong class="bold">              mountPath: "/var/lib/neo4j/data"</strong></p><p class="source-code"><strong class="bold">      volumes:</strong></p><p class="source-code"><strong class="bold">          - name: neo4j-data</strong></p><p class="source-code"><strong class="bold">            persistentVolumeClaim:</strong></p><p class="source-code"><strong class="bold">              claimName: db-pv-claim</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
			</ol>
			<p>In this <a id="_idIndexMarker762"/>deployment, we are using the <strong class="source-inline">NEO4J_AUTH</strong> variable with its value set to <strong class="source-inline">none</strong>, to use the non-authentication method, just to simplify this example. You can also explore how to use secrets and other options by modifying this configuration.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you delete the <strong class="source-inline">NEO4J_AUTH</strong> variable, Neo4j by default sets the user name and password to <strong class="source-inline">neo4j</strong>. Then, after logging in, a dialog box will ask you to change this password.</p>
			<ol>
				<li value="2">Create the service to expose the <strong class="source-inline">bolt</strong>, <strong class="source-inline">http</strong>, and <strong class="source-inline">https</strong> ports that Neo4j uses:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: Service</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  labels:</strong></p><p class="source-code"><strong class="bold">    app: neo4j</strong></p><p class="source-code"><strong class="bold">  name: neo4j</strong></p><p class="source-code"><strong class="bold">spec: </strong></p><p class="source-code"><strong class="bold">  ports:</strong></p><p class="source-code"><strong class="bold">  - name: https</strong></p><p class="source-code"><strong class="bold">    port: 7473</strong></p><p class="source-code"><strong class="bold">    protocol: TCP</strong></p><p class="source-code"><strong class="bold">    targetPort: 7473</strong></p><p class="source-code"><strong class="bold">  - name: http</strong></p><p class="source-code"><strong class="bold">    port: 7474</strong></p><p class="source-code"><strong class="bold">    protocol: TCP</strong></p><p class="source-code"><strong class="bold">    targetPort: 7474</strong></p><p class="source-code"><strong class="bold">  - name: bolt</strong></p><p class="source-code"><strong class="bold">    port: 7687</strong></p><p class="source-code"><strong class="bold">    protocol: TCP</strong></p><p class="source-code"><strong class="bold">    targetPort: 7687</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    app: neo4j</strong></p><p class="source-code"><strong class="bold">  type: ClusterIP</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Expose<a id="_idIndexMarker763"/> the <strong class="source-inline">http</strong> and <strong class="source-inline">bolt</strong> ports, before connecting to Neo4j with the browser. To do this, run the following commands in different terminals:<p class="source-code"><strong class="bold">$ kubectl port-forward service/neo4j 7474:7474</strong></p><p class="source-code"><strong class="bold">$ kubectl port-forward service/neo4j 7687:7687</strong></p></li>
				<li>Open your browser at<a id="_idIndexMarker764"/> the page <strong class="source-inline">http://localhost:7474</strong>, choose <strong class="bold">Authentication type</strong>: <strong class="bold">No authentication</strong>, then click on the <strong class="bold">Connect</strong> button:</li>
			</ol>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B16945_10_02.jpg" alt="Figure 10.2 – Neo4j login page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Neo4j login page</p>
			<p>Then you will see the Neo4j UI:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B16945_10_03.jpg" alt="Figure 10.3 – Neo4j main page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Neo4j main page</p>
			<ol>
				<li value="5">Run a simple<a id="_idIndexMarker765"/> example in the Neo4j terminal located at the top of the browser as <strong class="source-inline">neo4j$</strong>. To do this, add the next commands and run them by clicking on the blue triangle button: <p class="source-code"><strong class="bold">CREATE (IronMan:Hero{name: "Tony Stark"}) </strong></p><p class="source-code"><strong class="bold">CREATE (Thanos:Villainous {name: "Thanos"})</strong></p><p class="source-code"><strong class="bold">CREATE (Thanos)-[r:ENEMY_OF]-&gt;(IronMan) </strong></p><p class="source-code"><strong class="bold">RETURN IronMan, Thanos</strong></p></li>
			</ol>
			<p>You will see that Neo4j visualizes the relationship between the Marvel characters:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B16945_10_04.jpg" alt="Figure 10.4 – Neo4j graph visualization&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Neo4j graph visualization</p>
			<p>Now you<a id="_idIndexMarker766"/> have learned how to use Neo4j with this basic example, let’s move on to the summary of this chapter, about what we have learned.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor208"/>Summary</h1>
			<p>In this chapter, we learned how to use CAP theorem to choose the right database to store data. This theorem helped us to take into consideration important guarantees when designing distributed data storage in a distributed system at the edge. In this chapter, we also learned about different relational and non-relational databases. We gained practical knowledge on how to set up and deploy various database paradigms such as relational, key-value, document-oriented, and graph databases. In the next chapter, we are going to focus on the time series database Prometheus, which stores data in the form of values and time and can be used to implement useful monitoring dashboards for devices at the edge.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor209"/>Questions</h1>
			<p>Here are a few questions to validate your new knowledge:</p>
			<ul>
				<li>How can CAP theorem help you to decide which database to use according to your use case?</li>
				<li>How can you deploy MySQL in K3s?</li>
				<li>How can you deploy Redis in K3s?</li>
				<li>How can you deploy MongoDB in K3s?</li>
				<li>How can you deploy PostgreSQL on K3s?</li>
				<li>How can you deploy Neo4j on K3s?</li>
				<li>How can you use PersistentVolumeClaims to deploy a database on K3s?</li>
				<li>How can you use ConfigMaps and Secrets to deploy a database on K3s?</li>
			</ul>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor210"/>Further reading</h1>
			<p>You can refer to the following references for more information on the topics covered in this chapter:</p>
			<ul>
				<li><em class="italic">Databases and Quick Overview of SQLite</em>: <a href="https://medium.com/aiadventures/databases-and-quick-overview-of-sqlite-5b7d4f8f6174">https://medium.com/aiadventures/databases-and-quick-overview-of-sqlite-5b7d4f8f6174</a></li>
				<li><em class="italic">CAP Theorem for Databases: Consistency, Availability &amp; Partition Tolerance</em>: <a href="https://www.bmc.com/blogs/cap-theorem">https://www.bmc.com/blogs/cap-theorem</a></li>
				<li>Non-relational data and NoSQL: <a href="https://aloa.co/blog/relational-vs-non-relational-database-pros-cons">https://aloa.co/blog/relational-vs-non-relational-database-pros-cons</a></li>
				<li>CAP theorem: <a href="https://devopedia.org/cap-theorem">https://devopedia.org/cap-theorem</a></li>
				<li><em class="italic">System design fundamentals: What is the CAP theorem?</em>: <a href="https://www.educative.io/blog/what-is-cap-theorem">https://www.educative.io/blog/what-is-cap-theorem</a></li>
				<li><em class="italic">What are the ACID properties of transactions and why do they matter in data engineering?</em>: <a href="https://www.keboola.com/blog/acid-transactions">https://www.keboola.com/blog/acid-transactions</a></li>
				<li><em class="italic">SQL vs NoSQL Databases: What’s The Difference?</em>: <a href="https://www.bmc.com/blogs/sql-vs-nosql">https://www.bmc.com/blogs<span id="_idTextAnchor211"/>/sql-vs-nosql</a></li>
				<li><em class="italic">Traditional RDBMS to NoSQL database: New era of databases for big data</em>: <a href="https://www.researchgate.net/publication/324922396_TRADITIONAL_RDBMS_TO_NOSQL_DATABASE_NEW_ERA_OF_DATABASES_FOR_BIG_DATA">https://www.researchgate.net/publication/324922396_TRADITIONAL_RDBMS_TO_NOSQL_DATABASE_NEW_ERA_OF_DATABASES_FOR_BIG_DATA</a></li>
				<li>MySQL client K8s: <a href="https://gist.github.com/vishnuhd/b8686197f855c00fa734bc5f1fedf078">https://gist.github.com/vishnuhd/b8686197f855c00fa734bc5f1fedf078</a></li>
				<li><em class="italic">Run a Single-Instance Stateful Application</em>: <a href="https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application">https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application</a></li>
				<li><em class="italic">MySQL 8 Administrator’s Guide</em>: <a href="https://www.packtpub.com/product/mysql-8-administrator-s-guide/9781788395199">https://www.packtpub.com/product/mysql-8-administrator-s-guide/9781788395199</a></li>
				<li><em class="italic">Configuring Redis using a ConfigMap</em>: <a href="https://kubernetes.io/docs/tutorials/configuration/configure-redis-using-configmap">https://kubernetes.io/docs/tutorials/configuration/configure-redis-using-configmap</a></li>
				<li><em class="italic">Redis Essentials</em>: <a href="https://www.packtpub.com/product/redis-essentials/9781784392451">https://www.packtpub.com/product/redis-essentials/9781784392451</a></li>
				<li>Kubernetes secrets: <a href="https://kubernetes.io/fr/docs/concepts/configuration/secret">https://kubernetes.io/fr/docs/concepts/configuration/secret</a></li>
				<li><em class="italic">Seven NoSQL Databases in a Week</em>: <a href="https://www.packtpub.com/product/seven-nosql-databases-in-a-week/9781787288867">https://www.packtpub.com/product/seven-nosql-databases-in-a-week/9781787288867</a></li>
				<li><em class="italic">How to use Kubernetes to deploy Postgres</em>: <a href="https://www.sumologic.com/blog/kubernetes-deploy-postgres">https://www.sumologic.com/blog/kubernetes-deploy-postgres</a></li>
				<li><em class="italic">PostgreSQL 14 Administration Cookbook</em>: <a href="https://www.packtpub.com/product/postgresql-14-administration-cookbook/9781803248974">https://www.packtpub.com/product/postgresql-14-administration-cookbook/9781803248974</a></li>
				<li><em class="italic">Internet of Things and Data: A Powerful Connection</em>: <a href="https://neo4j.com/news/internet-things-data-powerful-connection">https://neo4j.com/news/internet-things-data-powerful-connection</a></li>
				<li>Why not SQLite: <a href="https://stackoverflow.com/questions/66950385/how-to-use-sqlite3-database-with-django-on-kuberenets-pod">https://stackoverflow.com/questions/66950385/how-to-use-sqlite3-database-with-django-on-kuberenets-pod</a></li>
				<li><em class="italic">Creating a Graph Application with Python, Neo4j, Gephi, and Linkurious.js</em>: <a href="https://linkurious.com/blog/creating-a-graph-application-with-python-neo4j-gephi-and-linkurious-js">https://linkurious.com/blog/creating-a-graph-application-with-python-neo4j-gephi-and-linkurious-js</a></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer093">
			</div>
		</div>
	

		<div id="_idContainer094" class="Content">
			<h1 id="_idParaDest-211"><a id="_idTextAnchor212"/>Part 3: Edge Computing Use Cases in Practice </h1>
			<p>In this part, you will learn how to use k3s and k3OS for different use cases, exploring complementary software and best practices for building an edge computing system.</p>
			<p>This part of the book comprises the following chapters:</p>
			<ul>
				<li><a href="B16945_11_Final_PG.xhtml#_idTextAnchor213"><em class="italic">Chapter 11</em></a>, <em class="italic">Monitoring the Edge with Prometheus and Grafana  </em></li>
				<li><a href="B16945_12_Final_PG.xhtml#_idTextAnchor227"><em class="italic">Chapter 12</em></a>, <em class="italic">Communicating with Edge Devices across Long Distances Using LoRa</em>   </li>
				<li><a href="B16945_13_Final_PG.xhtml#_idTextAnchor246"><em class="italic">Chapter 13</em></a>, <em class="italic">Geolocalization Applications Using GPS, NoSQL, and K3s Clusters</em></li>
				<li><a href="B16945_14_Final_PG.xhtml#_idTextAnchor267"><em class="italic">Chapter 14</em></a>, <em class="italic">Computer Vision with Python and K3s Clusters</em></li>
				<li><a href="B16945_15_Final_PG.xhtml#_idTextAnchor285"><em class="italic">Chapter 15</em></a>, <em class="italic">Designing Your Own Edge Computing System</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer095">
			</div>
		</div>
		<div>
			<div id="_idContainer096">
			</div>
		</div>
	</body></html>