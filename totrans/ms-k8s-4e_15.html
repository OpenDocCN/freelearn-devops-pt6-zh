<html><head></head><body>
  <div id="_idContainer294" class="Basic-Text-Frame">
    <h1 class="chapterNumber">15</h1>
    <h1 id="_idParaDest-688" class="chapterTitle">Extending Kubernetes</h1>
    <p class="normal">In this chapter, we will dig deep into the guts of Kubernetes. We will start with the Kubernetes API and learn how to work with Kubernetes programmatically via direct access to the API, the controller-runtime Go library, and automating kubectl. Then, we’ll look into extending the Kubernetes API with custom resources. The last part is all about the various plugins Kubernetes supports. Many aspects of Kubernetes operation are modular and designed for extension. We will examine the API aggregation layer and several types of plugins, such as custom schedulers, authorization, admission control, custom metrics, and volumes. Finally, we’ll look into extending kubectl and adding your own commands.</p>
    <p class="normal">The covered topics are as follows:</p>
    <ul>
      <li class="bulletList">Working with the Kubernetes API</li>
      <li class="bulletList">Extending the Kubernetes API</li>
      <li class="bulletList">Writing Kubernetes and kubectl plugins</li>
      <li class="bulletList">Writing webhooks</li>
    </ul>
    <h1 id="_idParaDest-689" class="heading-1">Working with the Kubernetes API</h1>
    <p class="normal">The <a id="_idIndexMarker1575"/>Kubernetes API is comprehensive and encompasses the entire functionality of Kubernetes. As you may expect, it is huge. But it is designed very well using best practices, and it is consistent. If you understand the basic principles, you can discover everything you need to know. We covered the Kubernetes API itself in <em class="chapterRef">Chapter 1</em>, <em class="italic">Understanding Kubernetes Architecture</em>. If you need a refresher, go and take a look. In this section, we’re going to dive deeper and learn how to access and work with the Kubernetes API. But, first let’s look at OpenAPI, which is the formal foundation that gives structure to the entire Kubernetes API.</p>
    <h2 id="_idParaDest-690" class="heading-2">Understanding OpenAPI</h2>
    <p class="normal">OpenAPI (formerly Swagger) is<a id="_idIndexMarker1576"/> an open standard that defines a language- and<a id="_idIndexMarker1577"/> framework-agnostic way to describe RESTful APIs. It provides a standardized, machine-readable format for describing APIs, including their endpoints, parameters, request and response bodies, authentication, and other metadata.</p>
    <p class="normal">In the context of Kubernetes, OpenAPI is used to define and document the API surface of a Kubernetes cluster. OpenAPI is used in Kubernetes to provide a standardized way to document and define the API objects that can be used to configure and manage the cluster. The Kubernetes API is based on a declarative model, where users define the desired state of their resources using YAML or JSON manifests. These manifests follow the OpenAPI schema, which defines the structure and properties of each resource. Kubernetes uses the OpenAPI schema to validate manifests, provide auto-completion and documentation in API clients, and generate API reference documentation.</p>
    <p class="normal">One of the key benefits of using OpenAPI in Kubernetes is that it enables code generation for client libraries. This allows developers to interact with the Kubernetes API using their programming language of choice and generated client libraries, which provide a native and type-safe way to interact with the API. </p>
    <p class="normal">Additionally, OpenAPI allows tools like kubectl to provide autocompletion and validation for Kubernetes resources.</p>
    <p class="normal">OpenAPI also enables automated documentation generation for the Kubernetes API. With the OpenAPI schema, Kubernetes can automatically generate API reference documentation, which serves as a comprehensive and up-to-date resource for understanding the Kubernetes API and its capabilities.</p>
    <p class="normal">Kubernetes has had stable support for OpenAPI v3 since Kubernetes 1.27.</p>
    <p class="normal">Check out <a href="https://www.openapis.org"><span class="url">https://www.openapis.org</span></a> for <a id="_idIndexMarker1578"/>more details.</p>
    <p class="normal">In order to work with the Kubernetes API locally, we need to set up a proxy.</p>
    <h2 id="_idParaDest-691" class="heading-2">Setting up a proxy</h2>
    <p class="normal">To <a id="_idIndexMarker1579"/>simplify access, you can use kubectl to set up a proxy:</p>
    <pre class="programlisting gen"><code class="hljs">$ k proxy --port 8080
</code></pre>
    <p class="normal">Now, you can access the API server on <code class="inlineCode">http://localhost:8080</code> and it will reach the same Kubernetes API server that kubectl is configured for.</p>
    <h2 id="_idParaDest-692" class="heading-2">Exploring the Kubernetes API directly</h2>
    <p class="normal">The <a id="_idIndexMarker1580"/>Kubernetes API is highly discoverable. You can just browse to the URL of the API server at <code class="inlineCode">http://localhost:8080</code> and get a nice JSON document that describes all the available operations under the <code class="inlineCode">paths</code> key.</p>
    <p class="normal">Here is a partial list due to space constraints:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"paths"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-string">"/api"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"/api/v1"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"/apis"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"/apis/"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"/apis/admissionregistration.k8s.io"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"/apis/admissionregistration.k8s.io/v1"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"/apis/apiextensions.k8s.io"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"/livez/poststarthook/storage-object-count-tracker-hook"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"/logs"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"</span><span class="hljs-string">/metrics"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"/openapi/v2"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"/openapi/v3"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"/openapi/v3/"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"/openid/v1/jwks"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"/readyz/shutdown"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"/version"</span>
    <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">You can drill down any one of the paths. For example, to discover the endpoint for the <code class="inlineCode">default</code> namespace, I first called the <code class="inlineCode">/api</code> endpoint, then discovered <code class="inlineCode">/api/v1</code>, which told me there was <code class="inlineCode">/api/v1/namespaces</code>, which pointed me to <code class="inlineCode">/api/v1/namespaces/default</code>. Here is the response from the <code class="inlineCode">/api/v1/namespaces/default</code> endpoint:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"kind"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Namespace"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"v1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"metadata"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"default"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"uid"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"7e39c279-949a-4fb6-ae47-796bb797082d"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"resourceVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"192"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"creationTimestamp"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2022-11-13T04:33:00Z"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"</span><span class="hljs-attr">labels"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"kubernetes.io/metadata.name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"default"</span>
    <span class="hljs-punctuation">},</span>
    <span class="hljs-attr">"managedFields"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"manager"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"kube-apiserver"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"operation"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Update"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"v1"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"time"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"</span><span class="hljs-string">2022-11-13T04:33:00Z"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"fieldsType"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"FieldsV1"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"fieldsV1"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
          <span class="hljs-attr">"f:metadata"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"f:labels"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
              <span class="hljs-attr">"."</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{},</span>
              <span class="hljs-attr">"f:kubernetes.io/metadata.name"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{}</span>
            <span class="hljs-punctuation">}</span>
          <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">}</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">},</span>
  <span class="hljs-attr">"spec"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"finalizers"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-string">"kubernetes"</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">},</span>
  <span class="hljs-attr">"status"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"phase"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Active"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">You<a id="_idIndexMarker1581"/> can explore the Kubernetes API from the command line using tools like cURL or even kubectl itself, but sometimes using a GUI application is more convenient.</p>
    <h3 id="_idParaDest-693" class="heading-3">Using Postman to explore the Kubernetes API</h3>
    <p class="normal">Postman (<a href="https://www.getpostman.com"><span class="url">https://www.getpostman.com</span></a>) is a<a id="_idIndexMarker1582"/> very polished application for working<a id="_idIndexMarker1583"/> with RESTful APIs. If you<a id="_idIndexMarker1584"/> lean more to the GUI side, you may find it extremely useful.</p>
    <p class="normal">The following <a id="_idIndexMarker1585"/>screenshot shows the available endpoints under the batch v1 API group:</p>
    <figure class="mediaobject"><img src="../Images/B18998_15_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.1: The available endpoints under the batch v1 API group</p>
    <p class="normal">Postman has a lot of options, and it organizes the information in a very pleasing way. Give it a try.</p>
    <h3 id="_idParaDest-694" class="heading-3">Filtering the output with HTTPie and jq</h3>
    <p class="normal">The<a id="_idIndexMarker1586"/> output from the API can be too verbose sometimes. Often, you’re interested just in one value out of a huge chunk of a JSON response. For example, if you want to get the names of all running services, you can hit the <code class="inlineCode">/api/v1/services</code> endpoint. The response, however, includes a lot of additional information that is irrelevant. Here is a very partial subset of the output:</p>
    <pre class="programlisting gen"><code class="hljs">$ http http://localhost:8080/api/v1/services
{
  "kind": "ServiceList",
  "apiVersion": "v1",
  "metadata": {
    "resourceVersion": "3237"
  },
  "items": [
    ...
    {
      "metadata": {
        "name": "kube-dns",
        "namespace": "kube-system",
        ...
      },
      "spec": {
        ... 
        "selector": {
          "k8s-app": "kube-dns"
        },
        "clusterIP": "10.96.0.10",
        "type": "ClusterIP",
        "sessionAffinity": "None",
      },
      "status": {
        "loadBalancer": {}
      }
    }
  ]
}
</code></pre>
    <p class="normal">The <a id="_idIndexMarker1587"/>complete output is 193 lines long! Let’s see how to use HTTPie and jq to gain full control over the output and show only the names of the services. I prefer<a id="_idIndexMarker1588"/> HTTPie(<a href="https://httpie.org/"><span class="url">https://httpie.org/</span></a>) over cURL for interacting with REST APIs on the command line. The<a id="_idIndexMarker1589"/> jq (<a href="https://stedolan.github.io/jq/"><span class="url">https://stedolan.github.io/jq/</span></a>) command-line JSON processor is great for slicing and dicing JSON.</p>
    <p class="normal">Examining the full output, you can see that the service name is in the <code class="inlineCode">metadata</code> section of each item in the <code class="inlineCode">items</code> array. The jq expression that will select just the name is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">.items<span class="hljs-punctuation">[]</span>.metadata.name
</code></pre>
    <p class="normal">Here is <a id="_idIndexMarker1590"/>the full command and output on a fresh kind cluster:</p>
    <pre class="programlisting gen"><code class="hljs">$ http http://localhost:8080/api/v1/services | jq '.items[].metadata.name'
"kubernetes"
"kube-dns"
</code></pre>
    <h2 id="_idParaDest-695" class="heading-2">Accessing the Kubernetes API via the Python client</h2>
    <p class="normal">Exploring <a id="_idIndexMarker1591"/>the API interactively using HTTPie and jq is great, but the real power of APIs comes when you consume and integrate them with other software. The Kubernetes Incubator project provides a full-fledged and very well-documented Python client library. It is available at <a href="https://github.com/kubernetes-incubator/client-python"><span class="url">https://github.com/kubernetes-incubator/client-python</span></a>.</p>
    <p class="normal">First, make sure you have Python installed (<a href="https://wiki.python.org/moin/BeginnersGuide/Download"><span class="url">https://wiki.python.org/moin/BeginnersGuide/Download</span></a>). Then install the Kubernetes package:</p>
    <pre class="programlisting gen"><code class="hljs">$ pip install kubernetes
</code></pre>
    <p class="normal">To start talking to a Kubernetes cluster, you need to connect to it. Start an interactive Python session:</p>
    <pre class="programlisting gen"><code class="hljs">$ python
Python 3.9.12 (main, Aug 25 2022, 11:03:34)
[Clang 13.1.6 (clang-1316.0.21.2.3)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</code></pre>
    <p class="normal">The Python client can read your kubectl config:</p>
    <pre class="programlisting gen"><code class="hljs">&gt;&gt;&gt; from kubernetes import client, config
&gt;&gt;&gt; config.load_kube_config()
&gt;&gt;&gt; v1 = client.CoreV1Api()
</code></pre>
    <p class="normal">Or it can connect directly to an already running proxy:</p>
    <pre class="programlisting gen"><code class="hljs">&gt;&gt;&gt; from kubernetes import client, config
&gt;&gt;&gt; client.Configuration().host = 'http://localhost:8080'
&gt;&gt;&gt; v1 = client.CoreV1Api()
</code></pre>
    <p class="normal">Note that<a id="_idIndexMarker1592"/> the <code class="inlineCode">client</code> module provides methods to get access to different group versions, such as <code class="inlineCode">CoreV1Api</code>.</p>
    <h3 id="_idParaDest-696" class="heading-3">Dissecting the CoreV1Api group</h3>
    <p class="normal">Let’s<a id="_idIndexMarker1593"/> dive in and understand the <code class="inlineCode">CoreV1Api</code> group. The<a id="_idIndexMarker1594"/> Python object has 407 public attributes!</p>
    <pre class="programlisting gen"><code class="hljs">&gt;&gt;&gt; attributes = [x for x in dir(v1) if not x.startswith('__')]
&gt;&gt;&gt; len(attributes)
407
</code></pre>
    <p class="normal">We ignore the attributes that start with double underscores because those are special class/instance methods unrelated to Kubernetes.</p>
    <p class="normal">Let’s pick ten random methods and see what they look like:</p>
    <pre class="programlisting gen"><code class="hljs">&gt;&gt;&gt; import random
&gt;&gt;&gt; from pprint import pprint as pp
&gt;&gt;&gt; pp(random.sample(attributes, 10))
['replace_namespaced_persistent_volume_claim',
 'list_config_map_for_all_namespaces_with_http_info',
 'connect_get_namespaced_pod_attach_with_http_info',
 'create_namespaced_event',
 'connect_head_node_proxy_with_path',
 'create_namespaced_secret_with_http_info',
 'list_namespaced_service_account',
 'connect_post_namespaced_pod_portforward_with_http_info',
 'create_namespaced_service_account_token',
 'create_namespace_with_http_info']
</code></pre>
    <p class="normal">Very interesting. The attributes begin with a verb such as <code class="inlineCode">replace</code>, <code class="inlineCode">list</code>, or <code class="inlineCode">create</code>. Many of them have a notion of a namespace and many have a <code class="inlineCode">with_http_info</code> suffix. To understand this better, let’s count how many verbs exist and how many attributes use each verb (where the verb is the first token before the underscore):</p>
    <pre class="programlisting gen"><code class="hljs">&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; verbs = [x.split('_')[0] for x in attributes]
&gt;&gt;&gt; pp(dict(Counter(verbs)))
{'api': 1,
 'connect': 96,
 'create': 38,
 'delete': 58,
 'get': 2,
 'list': 56,
 'patch': 50,
 'read': 54,
 'replace': 52}
</code></pre>
    <p class="normal">We <a id="_idIndexMarker1595"/>can drill further and look at the interactive<a id="_idIndexMarker1596"/> help for a specific attribute:</p>
    <pre class="programlisting gen"><code class="hljs">&gt;&gt;&gt; help(v1.create_node)
Help on method create_node in module kubernetes.client.apis.core_v1_api:
create_node(body, **kwargs) method of kubernetes.client.api.core_v1_api.CoreV1Api instance
    create_node  # noqa: E501
    create a Node  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.create_node(body, async_req=True)
    &gt;&gt;&gt; result = thread.get()
    :param async_req bool: execute request asynchronously
    :param V1Node body: (required)
    :param str pretty: If 'true', then the output is pretty printed.
    :param str dry_run: When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
    :param str field_manager: fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
    :param str field_validation: fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields, provided that the `ServerSideFieldValidation` feature gate is also enabled. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23 and is the default behavior when the `ServerSideFieldValidation` feature gate is disabled. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default when the `ServerSideFieldValidation` feature gate is enabled. - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
    :param _preload_content: if False, the urllib3.HTTPResponse object will
                             be returned without reading/decoding response
                             data. Default is True.
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :return: V1Node
             If the method is called
             returns the request thread.
</code></pre>
    <p class="normal">We <a id="_idIndexMarker1597"/>see that the API is vast, which makes <a id="_idIndexMarker1598"/>sense because it represents the entire Kubernetes API. We also learned how to discover groups of related methods and how to get detailed information on specific methods.</p>
    <p class="normal">You can poke around yourself and learn more about the API. Let’s look at some common operations, such as listing, creating, and watching objects.</p>
    <h3 id="_idParaDest-697" class="heading-3">Listing objects</h3>
    <p class="normal">You<a id="_idIndexMarker1599"/> can list different kinds of objects. The method names start with <code class="inlineCode">list_</code>. Here is an example listing all namespaces:</p>
    <pre class="programlisting gen"><code class="hljs">&gt;&gt;&gt; for ns in v1.list_namespace().items:
...     print(ns.metadata.name)
...
default
kube-node-lease
kube-public
kube-system
local-path-storage
</code></pre>
    <h3 id="_idParaDest-698" class="heading-3">Creating objects</h3>
    <p class="normal">To <a id="_idIndexMarker1600"/>create an object, you need to pass a <code class="inlineCode">body</code> parameter to the <code class="inlineCode">create</code> method. The <code class="inlineCode">body</code> must be a Python dictionary that is equivalent to a YAML configuration manifest you would use with kubectl. The easiest way to do it is to actually use a YAML manifest and then use the Python YAML module (not part of the standard library and must be installed separately) to read the YAML file and load it into a dictionary. For example, to create an <code class="inlineCode">nginx-deployment</code> with 3 replicas, we can use this YAML manifest (<code class="inlineCode">nginx-deployment.yaml</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span>  
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
          <span class="hljs-attr">ports:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>
</code></pre>
    <p class="normal">To install the <code class="inlineCode">yaml</code> Python module, type this command:</p>
    <pre class="programlisting gen"><code class="hljs">$ pip install yaml
</code></pre>
    <p class="normal">Then the following Python program (<code class="inlineCode">create_nginx_deployment.py</code>) will create the deployment:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> path
<span class="hljs-keyword">import</span> yaml
<span class="hljs-keyword">from</span> kubernetes <span class="hljs-keyword">import</span> client, config
<span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():
    <span class="hljs-comment"># Configs can be set in Configuration class directly or using</span>
    <span class="hljs-comment"># helper utility. If no argument provided, the config will be</span>
    <span class="hljs-comment"># loaded from default location.</span>
    config.load_kube_config()
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path.join(path.dirname(__file__),
                        <span class="hljs-string">'nginx-deployment.yaml'</span>)) <span class="hljs-keyword">as</span> f:
        dep = yaml.safe_load(f)
        k8s = client.AppsV1Api()
        dep = k8s.create_namespaced_deployment(body=dep,
                                               namespace=<span class="hljs-string">"default"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Deployment created. status='</span><span class="hljs-subst">{dep.status}</span><span class="hljs-string">'"</span>)
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'</span><span class="hljs-string">__main__'</span>:
    main()
</code></pre>
    <p class="normal">Let’s run<a id="_idIndexMarker1601"/> it and check the deployment was actually created using kubectl:</p>
    <pre class="programlisting gen"><code class="hljs">$ python create_nginx_deployment.py
Deployment created. status='{'available_replicas': None,
 'collision_count': None,
 'conditions': None,
 'observed_generation': None,
 'ready_replicas': None,
 'replicas': None,
 'unavailable_replicas': None,
 'updated_replicas': None}'
$ k get deploy
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     3            3           56s
</code></pre>
    <h3 id="_idParaDest-699" class="heading-3">Watching objects</h3>
    <p class="normal">Watching objects <a id="_idIndexMarker1602"/>is an advanced capability. It is implemented using a separate <code class="inlineCode">watch</code> module. Here is an example of watching 10 namespace events and printing them to the screen (<code class="inlineCode">watch_demo.py</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> kubernetes <span class="hljs-keyword">import</span> client, config, watch
<span class="hljs-comment"># Configs can be set in Configuration class directly or using helper utility</span>
config.load_kube_config()
v1 = client.CoreV1Api()
count = <span class="hljs-number">10</span>
w = watch.Watch()
<span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> w.stream(v1.list_namespace, _request_timeout=<span class="hljs-number">60</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Event: </span><span class="hljs-subst">{event[</span><span class="hljs-string">'type'</span><span class="hljs-subst">]}</span><span class="hljs-string"> </span><span class="hljs-subst">{event[</span><span class="hljs-string">'object'</span><span class="hljs-subst">].metadata.name}</span><span class="hljs-string">"</span>)
    count -= <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span>:
        w.stop()
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Done.'</span>)
</code></pre>
    <p class="normal">Here is the output:</p>
    <pre class="programlisting gen"><code class="hljs">$ python watch_demo.py
Event: ADDED kube-node-lease
Event: ADDED default
Event: ADDED local-path-storage
Event: ADDED kube-system
Event: ADDED kube-public
</code></pre>
    <p class="normal">Note<a id="_idIndexMarker1603"/> that only 5 events were printed (one for each namespace) and the program continues to watch for more events.</p>
    <p class="normal">Let’s create and delete some namespaces in a separate terminal window, so the program can end:</p>
    <pre class="programlisting gen"><code class="hljs">$ k create ns ns-1
namespace/ns-1 created
$ k delete ns ns-1
namespace "ns-1" deleted
$ k create ns ns-2
namespace/ns-2 created
The final output is:
$ python watch_demo.py
Event: ADDED default
Event: ADDED local-path-storage
Event: ADDED kube-system
Event: ADDED kube-public
Event: ADDED kube-node-lease
Event: ADDED ns-1
Event: MODIFIED ns-1
Event: MODIFIED ns-1
Event: DELETED ns-1
Event: ADDED ns-2
Done.
</code></pre>
    <p class="normal">You can of <a id="_idIndexMarker1604"/>course react to events and perform a useful action when an event happens (e.g., automatically deploy a workload in each new namespace).</p>
    <h2 id="_idParaDest-700" class="heading-2">Creating a pod via the Kubernetes API</h2>
    <p class="normal">The API <a id="_idIndexMarker1605"/>can be used for creating, updating, and deleting<a id="_idIndexMarker1606"/> resources too. Unlike working with kubectl, the API requires specifying the manifests in JSON and not YAML syntax (although every JSON document is also valid YAML). Here is a JSON pod definition (<code class="inlineCode">nginx-pod.json</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"kind"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"</span><span class="hljs-string">Pod"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"v1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"metadata"</span><span class="hljs-punctuation">:{</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"nginx"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"namespace"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"default"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"labels"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"nginx"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">},</span>
  <span class="hljs-attr">"spec"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"containers"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[{</span>
                     <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"nginx"</span><span class="hljs-punctuation">,</span>
                     <span class="hljs-attr">"image"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"nginx"</span><span class="hljs-punctuation">,</span>
                     <span class="hljs-attr">"</span><span class="hljs-attr">ports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[{</span><span class="hljs-attr">"containerPort"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">80</span><span class="hljs-punctuation">}]</span>
                   <span class="hljs-punctuation">}]</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">The following command will create the pod via the API:</p>
    <pre class="programlisting gen"><code class="hljs">$ http POST http://localhost:8080/api/v1/namespaces/default/pods @nginx-pod.json
</code></pre>
    <p class="normal">To verify it worked, let’s extract the name and status of the current pods. The endpoint is <code class="inlineCode">/api/v1/namespaces/default/pods</code>.</p>
    <p class="normal">The jq expression is <code class="inlineCode">items[].metadata.name,.items[].status.phase</code>.</p>
    <p class="normal">Here is the full <a id="_idIndexMarker1607"/>command and output:</p>
    <pre class="programlisting gen"><code class="hljs">$ FILTER='.items[].metadata.name,.items[].status.phase'
$ http http://localhost:8080/api/v1/namespaces/default/pods | jq $FILTER
"nginx"
"Running"
</code></pre>
    <h2 id="_idParaDest-701" class="heading-2">Controlling Kubernetes using Go and controller-runtime</h2>
    <p class="normal">Python is cool and <a id="_idIndexMarker1608"/>easy to work with, but for production-level tools, controllers, and operators, I prefer to use Go, and in particular the controller-runtime project. The controller-runtime is the standard Go client to use to access the Kubernetes API.</p>
    <h3 id="_idParaDest-702" class="heading-3">Using controller-runtime via go-k8s</h3>
    <p class="normal">The <a id="_idIndexMarker1609"/>controller-runtime project is a set of Go libraries that can fully query and manipulate Kubernetes in a very efficient manner (e.g., advanced caching to avoid overwhelming the API server).</p>
    <p class="normal">Working directly with controller-runtime is not easy. There are many interlocking pieces and different <a id="_idIndexMarker1610"/>ways to accomplish things.</p>
    <p class="normal">See <a href="https://pkg.go.dev/sigs.k8s.io/controller-runtime"><span class="url">https://pkg.go.dev/sigs.k8s.io/controller-runtime</span></a>.</p>
    <p class="normal">I created a little open-source project called <code class="inlineCode">go-k8s</code> that encapsulates some of the complexity and helps <a id="_idIndexMarker1611"/>with using a subset of the controller-runtime functionality with less hassle.</p>
    <p class="normal">Check it out here: <a href="https://github.com/the-gigi/go-k8s/tree/main/pkg/client"><span class="url">https://github.com/the-gigi/go-k8s/tree/main/pkg/client</span></a>.</p>
    <p class="normal">Note that the go-k8s project has other libraries, but we will focus on the client library.</p>
    <p class="normal">The go-k8s client package supports two types of clients: <code class="inlineCode">Clientset</code> and <code class="inlineCode">DynamicClient</code>. The <code class="inlineCode">Clientset</code> client supports working with well-known kinds, but explicitly specifying the API version, kind, and operation as method names. For example, listing all pods using <code class="inlineCode">Clientset</code> looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">podList, err := clientset.CoreV1().Pods(<span class="hljs-string">"ns-1"</span>).List(context.Background(), metav1.ListOptions{})
</code></pre>
    <p class="normal">It returns a pod list and an error. The error is <code class="inlineCode">nil</code> if everything is OK. The pod list is of struct type <code class="inlineCode">PodList</code>, which is defined here: <a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/types.go#L2514"><span class="url">https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/types.go#L2514</span></a>.</p>
    <p class="normal">Conveniently, you can find all the Kubernetes API types in the same file. The API is very nested, for example, a <code class="inlineCode">PodList</code>, as you may expect, is a list of <code class="inlineCode">Pod</code> objects. Each <code class="inlineCode">Pod</code> object has <code class="inlineCode">TypeMeta</code>, <code class="inlineCode">ObjectMeta</code>, <code class="inlineCode">PodSpec</code>, and <code class="inlineCode">PodStatus</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">type</span> Pod <span class="hljs-keyword">struct</span> {
    metav1.TypeMeta
    metav1.ObjectMeta
    Spec PodSpec
    Status PodStatus
}
</code></pre>
    <p class="normal">In <a id="_idIndexMarker1612"/>practice, this means that when you make a call through the <code class="inlineCode">Clientset</code>, you get back a strongly typed nested object that is very easy to work with. For example, if we want to check if a pod has a label called <code class="inlineCode">app</code> and its value, we can do it in one line:</p>
    <pre class="programlisting code"><code class="hljs-code">app, ok := pods[<span class="hljs-number">0</span>].ObjectMeta.Labels[<span class="hljs-string">"app"</span>]
</code></pre>
    <p class="normal">If the label doesn’t exist, <code class="inlineCode">ok</code> will be false. If it does exist, then its value will be available in the <code class="inlineCode">app</code> variable.</p>
    <p class="normal">Now, let’s look at <code class="inlineCode">DynamicClient</code>. Here, you get the ultimate flexibility and the ability to work with well-known types as well as custom types. In particular, if you want to create arbitrary resources, the dynamic client can operate in a generic way on any Kubernetes type.</p>
    <p class="normal">However, with the dynamic client, you always get back a generic object of type <code class="inlineCode">Unstructured</code>, defined here: <a href="https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/unstructured/unstructured.go#L41"><span class="url">https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/unstructured/unstructured.go#L41</span></a>.</p>
    <p class="normal">It is really a very thin wrapper around the generic Golang type <code class="inlineCode">map[string]interface{}</code>. It has a single field called <code class="inlineCode">Object</code> of type <code class="inlineCode">map[string]interface{}</code>. This means that the object you get back is a map of field names to arbitrary other objects (represented as <code class="inlineCode">interface{}</code>). To drill down the hierarchy, we have to perform typecasting, which means taking an <code class="inlineCode">interface{}</code> value and casting it explicitly to its actual type. Here is a simple example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>{} = <span class="hljs-number">5</span>
x, ok := i.(<span class="hljs-type">int</span>)
</code></pre>
    <p class="normal">Now, <code class="inlineCode">x</code> is a variable of type <code class="inlineCode">int</code> with a value of 5 that can be used as an integer. The original <code class="inlineCode">i</code> variable can’t be used as an integer because its type is the generic <code class="inlineCode">interface{}</code> even if it contains an integer value.</p>
    <p class="normal">In the <a id="_idIndexMarker1613"/>case of the objects returned from the dynamic client, we have to keep typecasting an <code class="inlineCode">interface{}</code> to a <code class="inlineCode">map[string]interface{}</code> until we get to the field we are interested in. To get to the <code class="inlineCode">app</code> label of our pod, we need to follow this path:</p>
    <pre class="programlisting code"><code class="hljs-code">    pod := pods[<span class="hljs-number">0</span>].Object
    metadata := pod[<span class="hljs-string">"metadata"</span>].(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>{})
    labels := metadata[<span class="hljs-string">"labels"</span>].(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>{})
    app, ok := labels[<span class="hljs-string">"app"</span>].(<span class="hljs-type">string</span>)
</code></pre>
    <p class="normal">This is extremely tiresome and error-prone. Luckily, there is a better way. The Kubernetes <code class="inlineCode">apimachinery/runtime</code> package provides a conversion function that can take an unstructured object and convert it into a known type:</p>
    <pre class="programlisting code"><code class="hljs-code">    pod := pods[<span class="hljs-number">0</span>].Object
    <span class="hljs-keyword">var</span> p corev1.Pod
    err = runtime.DefaultUnstructuredConverter.FromUnstructured(pod, &amp;p)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
      <span class="hljs-keyword">return</span> err
    }
    app, ok = p.ObjectMeta.Labels[<span class="hljs-string">"app"</span>]
</code></pre>
    <p class="normal">The controller-runtime is very powerful, but it can be tedious to deal with all the types. One way to “cheat” is to use kubectl, which actually uses the controller-runtime under the covers. This is especially easy using Python and its dynamic typing.</p>
    <h3 id="_idParaDest-703" class="heading-3">Invoking kubectl programmatically from Python and Go</h3>
    <p class="normal">If you don’t want<a id="_idIndexMarker1614"/> to deal with the REST API directly or client libraries, you have another option. Kubectl is used mostly as an<a id="_idIndexMarker1615"/> interactive command-line tool, but nothing is stopping you from automating it and invoking it through scripts and programs. There are some <a id="_idIndexMarker1616"/>benefits to using kubectl as your Kubernetes API client:</p>
    <ul>
      <li class="bulletList">Easy to find examples for any usage</li>
      <li class="bulletList">Easy to experiment on the command line to find the right combination of commands and arguments</li>
      <li class="bulletList">kubectl supports output in JSON or YAML for quick parsing</li>
      <li class="bulletList">Authentication <a id="_idIndexMarker1617"/>is built in via kubectl configuration</li>
    </ul>
    <h3 id="_idParaDest-704" class="heading-3">Using Python subprocess to run kubectl</h3>
    <p class="normal">Let’s<a id="_idIndexMarker1618"/> use Python first, so you can compare using the official Python client to rolling your own. Python has a module called <code class="inlineCode">subprocess</code> that <a id="_idIndexMarker1619"/>can run external processes such as kubectl and capture the output. </p>
    <p class="normal">Here is a Python 3 example running kubectl on its own and displaying the beginning of the usage output:</p>
    <pre class="programlisting gen"><code class="hljs">&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; out = subprocess.check_output('kubectl').decode('utf-8')
&gt;&gt;&gt; print(out[:276])
</code></pre>
    <p class="normal">Kubectl controls the Kubernetes cluster manager.</p>
    <p class="normal">Find more <a id="_idIndexMarker1620"/>information at <a href="https://kubernetes.io/docs/reference/kubectl/overview/"><span class="url">https://kubernetes.io/docs/reference/kubectl/overview/</span></a>.</p>
    <p class="normal">The <code class="inlineCode">check_output()</code> function captures the output as a bytes array, which needs to be decoded into <code class="inlineCode">utf-8</code> to be displayed properly. We can generalize it a little bit and create a convenience function called <code class="inlineCode">k()</code> in the <code class="inlineCode">k.py</code> file. It accepts any number of arguments it feeds to kubectl, and then decodes the output and returns it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> subprocess <span class="hljs-keyword">import</span> check_output
<span class="hljs-keyword">def</span> <span class="hljs-title">k</span>(<span class="hljs-params">*args</span>):
    out = check_output([<span class="hljs-string">'kubectl'</span>] + <span class="hljs-built_in">list</span>(args))
    <span class="hljs-keyword">return</span> out.decode(<span class="hljs-string">'utf-8'</span>)
</code></pre>
    <p class="normal">Let’s use it to list all the running pods in the default namespace:</p>
    <pre class="programlisting gen"><code class="hljs">&gt;&gt;&gt; from k import k
&gt;&gt;&gt; print(k('get', 'po'))
NAME                                                      READY   STATUS             RESTARTS   AGE
nginx                                                     1/1     Running            0          4h48m
nginx-deployment-679f9c75b-c79mv                          1/1     Running            0          132m
nginx-deployment-679f9c75b-cnmvk                          1/1     Running            0          132m
nginx-deployment-679f9c75b-gzfgk                          1/1     Running            0          132m
</code></pre>
    <p class="normal">This is nice<a id="_idIndexMarker1621"/> for display, but kubectl already does that. The real power comes when you use the structured output options with the <code class="inlineCode">-o</code> flag. Then<a id="_idIndexMarker1622"/> the result can be converted automatically into a Python object. Here is a modified version of the <code class="inlineCode">k()</code> function that accepts a Boolean <code class="inlineCode">use_json</code> keyword argument (defaults to <code class="inlineCode">False</code>), and if <code class="inlineCode">True</code>, adds <code class="inlineCode">-o json</code> and then parses the JSON output to a Python object (dictionary):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> subprocess <span class="hljs-keyword">import</span> check_output
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">def</span> <span class="hljs-title">k</span>(<span class="hljs-params">*args, use_json=</span><span class="hljs-literal">False</span>):
    cmd = [<span class="hljs-string">'kubectl'</span>] + <span class="hljs-built_in">list</span>(args)
    <span class="hljs-keyword">if</span> use_json:
        cmd += [<span class="hljs-string">'-o'</span>, <span class="hljs-string">'json'</span>]
    out = check_output(cmd).decode(<span class="hljs-string">'utf-8'</span>)
    <span class="hljs-keyword">if</span> use_json:
        out = json.loads(out)
    <span class="hljs-keyword">return</span> out
</code></pre>
    <p class="normal">That returns a full-fledged API object, which can be navigated and drilled down just like when accessing the REST API directly or using the official Python client:</p>
    <pre class="programlisting gen"><code class="hljs">result = k('get', 'po', use_json=True)
&gt;&gt;&gt; for r in result['items']:
...     print(r['metadata']['name'])
...
nginx-deployment-679f9c75b-c79mv
nginx-deployment-679f9c75b-cnmvk
nginx-deployment-679f9c75b-gzfgk
</code></pre>
    <p class="normal">Let’s see how to delete the deployment and wait until all the pods are gone. The kubectl <code class="inlineCode">delete</code> command doesn’t accept the <code class="inlineCode">-o json</code> option (although it has <code class="inlineCode">-o name</code>), so let’s leave out <code class="inlineCode">use_json</code>:</p>
    <pre class="programlisting gen"><code class="hljs">&gt;&gt;&gt; k('delete', 'deployment', 'nginx-deployment')
while len(k('get', 'po', use_json=True)['items']) &gt; 0:
    print('.')
print('Done.')
.
.
.
.
Done.
</code></pre>
    <p class="normal">Python is<a id="_idIndexMarker1623"/> great, but what if you prefer Go for automating kubectl? No worries, I have just the package for you. The <code class="inlineCode">kugo</code> package <a id="_idIndexMarker1624"/>provides a simple Go API to automate<a id="_idIndexMarker1625"/> kubectl. You can find the code here: <a href="https://github.com/the-gigi/kugo"><span class="url">https://github.com/the-gigi/kugo</span></a>.</p>
    <p class="normal">It provides 3 functions: <code class="inlineCode">Run()</code>, <code class="inlineCode">Get()</code>, and <code class="inlineCode">Exec()</code>.</p>
    <p class="normal">The <code class="inlineCode">Run()</code> function is your Swiss Army knife. It can run any kubectl command as is. Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code">    cmd := fmt.Sprintf(<span class="hljs-string">"create deployment test-deployment --image nginx --replicas 3 -n ns-1"</span>)
    _, err := kugo.Run(cmd)
</code></pre>
    <p class="normal">This is super convenient because you can interactively compose the exact command and parameters you need using kubectl and then, once you’ve figured out everything, you can literally take the same command and pass it to <code class="inlineCode">kuge.Run()</code> in your Go program.</p>
    <p class="normal">The <code class="inlineCode">Get()</code> function is a smart wrapper around <code class="inlineCode">kubectl get</code>. It accepts a <code class="inlineCode">GetRequest</code> parameter and provides several amenities: it supports field selectors, fetching by label, and different output types. Here is an example of fetching all namespaces by name using a custom kube config file and custom kube context:</p>
    <pre class="programlisting code"><code class="hljs-code">    output, err := kugo.Get(kugo.GetRequest{
        BaseRequest: kugo.BaseRequest{
            KubeConfigFile: c.kubeConfigFile,
            KubeContext:    c.GetKubeContext(),
        },
        Kind:   <span class="hljs-string">"ns"</span>,
        Output: <span class="hljs-string">"name"</span>,
    })
</code></pre>
    <p class="normal">Finally, the <code class="inlineCode">Exec()</code> function is a wrapper around <code class="inlineCode">kubectl exec</code> and lets you execute commands on a running pod/container. It accepts an <code class="inlineCode">ExecRequest</code> that looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">type</span> GetRequest <span class="hljs-keyword">struct</span> {
    BaseRequest
    Kind           <span class="hljs-type">string</span>
    FieldSelectors []<span class="hljs-type">string</span>
    Label          <span class="hljs-type">string</span>
    Output         <span class="hljs-type">string</span>
}
</code></pre>
    <p class="normal">Let’s look at <a id="_idIndexMarker1626"/>the code of the Exec() function. It is <a id="_idIndexMarker1627"/>pretty straightforward. It does basic validation that required fields like <code class="inlineCode">Command</code> and <code class="inlineCode">Target</code> were provided and then it builds a kubectl argument list starting with the <code class="inlineCode">exec</code> command and finally calls the <code class="inlineCode">Run()</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// Exec executes a command in a pod</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// The target pod can specified by name or an arbitrary pod</span>
<span class="hljs-comment">// from a deployment or service.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// If the pod has multiple containers you can choose which</span>
<span class="hljs-comment">// container to run the command in</span>
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">Exec</span><span class="hljs-params">(r ExecRequest)</span> (result <span class="hljs-type">string</span>, err <span class="hljs-type">error</span>) {
    <span class="hljs-keyword">if</span> r.Command == <span class="hljs-string">""</span> {
        err = errors.New(<span class="hljs-string">"Must specify Command field"</span>)
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">if</span> r.Target == <span class="hljs-string">""</span> {
        err = errors.New(<span class="hljs-string">"Must specify Target field"</span>)
        <span class="hljs-keyword">return</span>
    }
    args := []<span class="hljs-type">string</span>{<span class="hljs-string">"exec"</span>, r.Target}
    <span class="hljs-keyword">if</span> r.Container != <span class="hljs-string">""</span> {
        args = <span class="hljs-built_in">append</span>(args, <span class="hljs-string">"</span><span class="hljs-string">-c"</span>, r.Container)
    }
    args = handleCommonArgs(args, r.BaseRequest)
    args = <span class="hljs-built_in">append</span>(args, <span class="hljs-string">"--"</span>, r.Command)
    <span class="hljs-keyword">return</span> Run(args...)
}
</code></pre>
    <p class="normal">Now, that we have accessed Kubernetes programmatically via its REST API, client libraries, and by controlling kubectl, it’s time to learn how to extend Kubernetes.</p>
    <h1 id="_idParaDest-705" class="heading-1">Extending the Kubernetes API</h1>
    <p class="normal">Kubernetes<a id="_idIndexMarker1628"/> is an extremely flexible platform. It was designed from the get-go for extensibility and as it evolved, more parts of Kubernetes were opened up, exposed through robust interfaces, and could be replaced by alternative implementations. I would venture to say that the exponential adoption of Kubernetes across the board by start-ups, large companies, infrastructure providers, and cloud providers is a direct result of Kubernetes providing a lot of capabilities out of the box, but allowing easy integration with other actors. In this section, we will cover many of the available extension points, such as:</p>
    <ul>
      <li class="bulletList">User-defined types (custom resources)</li>
      <li class="bulletList">API access extensions</li>
      <li class="bulletList">Infrastructure extensions</li>
      <li class="bulletList">Operators</li>
      <li class="bulletList">Scheduler extensions</li>
    </ul>
    <p class="normal">Let’s understand the various ways you can extend Kubernetes.</p>
    <h2 id="_idParaDest-706" class="heading-2">Understanding Kubernetes extension points and patterns</h2>
    <p class="normal">Kubernetes is made of multiple components: the API server, etcd state store, controller manager, kube-proxy, kubelet, and container runtime. You can deeply extend and customize each and every one of these components, as well as adding your own custom components that watch and react to events, handle new requests, and modify everything about incoming requests.</p>
    <p class="normal">The following diagram shows some of the <a id="_idIndexMarker1629"/>available extension points and how they are connected to various Kubernetes components:</p>
    <figure class="mediaobject"><img src="../Images/B18998_15_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.2: Available extension points</p>
    <p class="normal">Let’s see how to extend Kubernetes with plugins.</p>
    <h3 id="_idParaDest-707" class="heading-3">Extending Kubernetes with plugins</h3>
    <p class="normal">Kubernetes <a id="_idIndexMarker1630"/>defines several interfaces that allow it <a id="_idIndexMarker1631"/>to interact with a wide variety of plugins from infrastructure providers. We discussed some of these interfaces and plugins in detail in previous chapters. We will just list them here for completeness:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Container networking interface</strong> (<strong class="keyWord">CNI</strong>) – the CNI supports a large number of networking solutions for connecting nodes and containers </li>
      <li class="bulletList"><strong class="keyWord">Container storage interface</strong> (<strong class="keyWord">CSI</strong>) – the CSI supports a large number of storage options for Kubernetes </li>
      <li class="bulletList">Device plugins – allows nodes to discover new node resources beyond CPU and memory (e.g., a GPU)</li>
    </ul>
    <h3 id="_idParaDest-708" class="heading-3">Extending Kubernetes with the cloud controller manager</h3>
    <p class="normal">Kubernetes<a id="_idIndexMarker1632"/> needs to be deployed <a id="_idIndexMarker1633"/>eventually on some nodes and use some storage and networking resources. Initially, Kubernetes supported only Google Cloud Platform and AWS. Other cloud providers had to customize multiple Kubernetes core components (Kubelet, the Kubernetes controller manager, and the Kubernetes API server) in order to integrate with Kubernetes. The Kubernetes developers identified it as a problem for adoption and created<a id="_idIndexMarker1634"/> the <strong class="keyWord">cloud controller manager</strong> (<strong class="keyWord">CCM</strong>). The CCM cleanly defines the interaction between Kubernetes and the infrastructure layer it is deployed on. Now, cloud providers just provide an implementation of the CCM tailored to their infrastructure, and they can utilize <a id="_idIndexMarker1635"/>upstream Kubernetes without costly and error-prone modification to the Kubernetes code. All the Kubernetes components interact with the CCM via the predefined<a id="_idIndexMarker1636"/> interfaces and Kubernetes is blissfully unaware of which cloud (or no cloud) it is running on. </p>
    <p class="normal">The following diagram demonstrates the interaction between Kubernetes and a cloud provider via the CCM:</p>
    <figure class="mediaobject"><img src="../Images/B18998_15_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.3: Interaction between Kubernetes and a cloud provider via the CCM</p>
    <p class="normal">If you want to learn <a id="_idIndexMarker1637"/>more about the CCM, check out this concise article I wrote a few years ago: <a href="https://medium.com/@the.gigi/kubernetes-and-cloud-providers-b7a6227d3198"><span class="url">https://medium.com/@the.gigi/kubernetes-and-cloud-providers-b7a6227d3198</span></a>.</p>
    <h3 id="_idParaDest-709" class="heading-3">Extending Kubernetes with webhooks</h3>
    <p class="normal">Plugins run in<a id="_idIndexMarker1638"/> the cluster, but in some cases, a <a id="_idIndexMarker1639"/>better extensibility pattern is to delegate some functions to an out-of-cluster service. This is very common in the area of access control where companies and organizations may already have a centralized solution for identity and access control. In those cases, the webhook extensibility pattern is useful. The idea is that you can configure Kubernetes with an endpoint (webhook). Kubernetes<a id="_idIndexMarker1640"/> will call the endpoint where you can implement your own custom functionality and Kubernetes will take action based <a id="_idIndexMarker1641"/>on the response. We saw this pattern when we discussed authentication, authorization, and dynamic admission control in <em class="chapterRef">Chapter 4</em>, <em class="italic">Securing Kubernetes</em>.</p>
    <p class="normal">Kubernetes defines the expected payloads for each webhook. The webhook implementation must adhere to them in order to successfully interact with Kubernetes.</p>
    <h3 id="_idParaDest-710" class="heading-3">Extending Kubernetes with controllers and operators</h3>
    <p class="normal">The <a id="_idIndexMarker1642"/>controller pattern is where <a id="_idIndexMarker1643"/>you write a program that can run inside the cluster or outside the cluster, watch for events, and respond to them. The conceptual model for a controller is to reconcile the current state of the cluster (the parts the controller is interested in) with the desired state. A common practice for controllers is to read the <code class="inlineCode">Spec</code> of an object, take some actions, and update its <code class="inlineCode">Status</code>. A lot of the core logic of Kubernetes is implemented by a large set of controllers managed by the controller manager, but there is nothing stopping us from deploying our own controllers to the cluster or running controllers that access the API server remotely.</p>
    <p class="normal">The <a id="_idIndexMarker1644"/>operator pattern is another flavor of the controller pattern. Think of an operator as a controller that also has its own set of custom resources, which represents an application it manages. The goal of operators is to manage the lifecycle of an application that is deployed in the <a id="_idIndexMarker1645"/>cluster or some out-of-cluster infrastructure. Check out <a href="https://operatorhub.io"><span class="url">https://operatorhub.io</span></a> for examples of existing operators.</p>
    <p class="normal">If you plan to build <a id="_idIndexMarker1646"/>your own controllers, I recommend starting with<a id="_idIndexMarker1647"/> Kubebuilder (<a href="https://github.com/kubernetes-sigs/kubebuilder"><span class="url">https://github.com/kubernetes-sigs/kubebuilder</span></a>). It is an open project maintained by the Kubernetes API Machinery SIG and has support for defining multiple custom APIs using CRDs, and scaffolds out the controller code to watch these resources. You will implement your controller in Go.</p>
    <p class="normal">However, there are multiple other frameworks for writing controllers and operators with different approaches and using other programming languages:</p>
    <ul>
      <li class="bulletList">The Operator Framework</li>
      <li class="bulletList">Kopf </li>
      <li class="bulletList">kube-rs</li>
      <li class="bulletList">KubeOps</li>
      <li class="bulletList">KUDO</li>
      <li class="bulletList">Metacontroller</li>
    </ul>
    <p class="normal">Check them out before you make your decision.</p>
    <h3 id="_idParaDest-711" class="heading-3">Extending Kubernetes scheduling</h3>
    <p class="normal">Kubernetes’ primary job, in one sentence, is to schedule pods on nodes. Scheduling is at the heart <a id="_idIndexMarker1648"/>of what Kubernetes does, and it does it very well. The Kubernetes scheduler can be configured in very advanced ways (daemon sets, taints, tolerations, etc.). But still, the Kubernetes developers recognize that there may be extraordinary circumstances where you may want to control the core scheduling algorithm. It is possible to replace the core Kubernetes scheduler with your own scheduler or run another scheduler side by side with the built-in scheduler to control the scheduling of a subset of the pods. We will see how to do that later in the chapter.</p>
    <h3 id="_idParaDest-712" class="heading-3">Extending Kubernetes with custom container runtimes</h3>
    <p class="normal">Kubernetes<a id="_idIndexMarker1649"/> originally supported only <a id="_idIndexMarker1650"/>Docker as a container runtime. The Docker support was embedded into the core Kubernetes codebase. Later, dedicated support for rkt was added. The Kubernetes developers saw the light and introduced <a id="_idIndexMarker1651"/>the <strong class="keyWord">container runtime interface</strong> (<strong class="keyWord">CRI</strong>), a gRPC interface that enables any container runtime that implements it to communicate with the kubelet. Eventually, the hard-coded support for Docker and rkt was phased out and now the kubelet talks to the container runtime only through the CRI:</p>
    <figure class="mediaobject"><img src="../Images/B18998_15_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.4: Kubelet talking to the container runtime through the CRI</p>
    <p class="normal">Since the introduction of the <a id="_idIndexMarker1652"/>CRI, the number of container <a id="_idIndexMarker1653"/>runtimes that <a id="_idIndexMarker1654"/>work with Kubernetes has exploded.</p>
    <p class="normal">We’ve covered multiple ways to extend different aspects of Kubernetes. Let’s turn our attention to the major concept of custom resources, which allow you to extend the Kubernetes API itself.</p>
    <h2 id="_idParaDest-713" class="heading-2">Introducing custom resources</h2>
    <p class="normal">One of the <a id="_idIndexMarker1655"/>primary ways to extend Kubernetes is to define new types of resources called custom resources. What can you do with custom resources? Plenty. You can use them to manage, through the Kubernetes API, resources that live outside the Kubernetes cluster but that your pods communicate with. By adding those external resources as custom resources, you get a full picture of your system, and you benefit from many Kubernetes API features such as:</p>
    <ul>
      <li class="bulletList">Custom CRUD REST endpoints</li>
      <li class="bulletList">Versioning</li>
      <li class="bulletList">Watches</li>
      <li class="bulletList">Automatic integration with generic Kubernetes tooling</li>
    </ul>
    <p class="normal">Other use cases for custom resources are metadata for custom controllers and automation programs.</p>
    <p class="normal">Let’s dive in and see what custom resources are all about.</p>
    <p class="normal">In order to play nice with the Kubernetes API server, custom resources must conform to some basic requirements. Similar to built-in API objects, they must have the following fields:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">apiVersion</code>: <code class="inlineCode">apiextensions.k8s.io/v1</code></li>
      <li class="bulletList"><code class="inlineCode">metadata</code>: Standard Kubernetes object metadata</li>
      <li class="bulletList"><code class="inlineCode">kind</code>: <code class="inlineCode">CustomResourceDefinition</code></li>
      <li class="bulletList"><code class="inlineCode">spec</code>: Describes how the resource appears in the API and tools</li>
      <li class="bulletList"><code class="inlineCode">status</code>: Indicates the current status of the CRD</li>
    </ul>
    <p class="normal">The <code class="inlineCode">spec</code> has an internal structure that includes fields like <code class="inlineCode">group</code>, <code class="inlineCode">names</code>, <code class="inlineCode">scope</code>, <code class="inlineCode">validation</code>, and <code class="inlineCode">version</code>. The <code class="inlineCode">status</code> includes the fields <code class="inlineCode">acceptedNames</code> and <code class="inlineCode">Conditions</code>. In the next section, I’ll show <a id="_idIndexMarker1656"/>you an example that clarifies the meaning of these fields.</p>
    <h2 id="_idParaDest-714" class="heading-2">Developing custom resource definitions</h2>
    <p class="normal">You develop<a id="_idIndexMarker1657"/> your custom resources using custom resource definitions, AKA CRDs. The intention is for CRDs to integrate smoothly with Kubernetes, its API, and tooling. That means you need to provide a lot of information. Here is an example for a custom resource called Candy:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apiextensions.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">CustomResourceDefinition</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-comment"># name must match the spec fields below, and be in the form: &lt;plural&gt;.&lt;group&gt;</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">candies.awesome.corp.com</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-comment"># group name to use for REST API: /apis/&lt;group&gt;/&lt;version&gt;</span>
  <span class="hljs-attr">group:</span> <span class="hljs-string">awesome.corp.com</span>
  <span class="hljs-comment"># version name to use for REST API: /apis/&lt;group&gt;/&lt;version&gt;</span>
  <span class="hljs-attr">versions:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v1</span>
      <span class="hljs-comment"># Each version can be enabled/disabled by Served flag.</span>
      <span class="hljs-attr">served:</span> <span class="hljs-literal">true</span>
      <span class="hljs-comment"># One and only one version must be marked as the storage version.</span>
      <span class="hljs-attr">storage:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">schema:</span>
        <span class="hljs-attr">openAPIV3Schema:</span>
          <span class="hljs-attr">type:</span> <span class="hljs-string">object</span>
          <span class="hljs-attr">properties:</span>
            <span class="hljs-attr">spec:</span>
              <span class="hljs-attr">type:</span> <span class="hljs-string">object</span>
              <span class="hljs-attr">properties:</span>
                <span class="hljs-attr">flavor:</span>
                  <span class="hljs-attr">type:</span> <span class="hljs-string">string</span>
  <span class="hljs-comment"># either Namespaced or Cluster</span>
  <span class="hljs-attr">scope:</span> <span class="hljs-string">Namespaced</span>
  <span class="hljs-attr">names:</span>
    <span class="hljs-comment"># plural name to be used in the URL: /apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;</span>
    <span class="hljs-attr">plural:</span> <span class="hljs-string">candies</span>
    <span class="hljs-comment"># singular name to be used as an alias on the CLI and for display</span>
    <span class="hljs-attr">singular:</span> <span class="hljs-string">candy</span>
    <span class="hljs-comment"># kind is normally the CamelCased singular type. Your resource manifests use this.</span>
    <span class="hljs-attr">kind:</span> <span class="hljs-string">Candy</span>
    <span class="hljs-comment"># shortNames allow shorter string to match your resource on the CLI</span>
    <span class="hljs-attr">shortNames:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">cn</span>
</code></pre>
    <p class="normal">The<a id="_idIndexMarker1658"/> Candy CRD has several interesting parts. The metadata has a fully qualified name, which should be unique since CRDs are cluster-scoped. The spec has a <code class="inlineCode">versions</code> section, which can contain multiple versions with a schema for each version that specifies the field of the custom resource. The schema follows the OpenAPI v3 specification (<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject"><span class="url">https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject</span></a>). The <code class="inlineCode">scope</code> field could be either <code class="inlineCode">Namespaced</code> or <code class="inlineCode">Cluster</code>. If the scope is <code class="inlineCode">Namespaced</code>, then the custom resources you create from the CRD will exist only in the namespace they were created in, whereas cluster-scoped custom resources are available in any namespace. Finally, the <code class="inlineCode">names</code> section refers to the names of the custom resource (not the name of the CRD from the <code class="inlineCode">metadata</code> section). The <code class="inlineCode">names</code> section has <code class="inlineCode">plural</code>, <code class="inlineCode">singular</code>, <code class="inlineCode">kind</code>, and <code class="inlineCode">shortNames</code> options.</p>
    <p class="normal">Let’s create the CRD:</p>
    <pre class="programlisting gen"><code class="hljs">$ k create -f candy-crd.yaml
customresourcedefinition.apiextensions.k8s.io/candies.awesome.corp.com created
</code></pre>
    <p class="normal">Note, that the metadata name is returned. It is common to use a plural name. Now, let’s verify we can access it:</p>
    <pre class="programlisting gen"><code class="hljs">$ k get crd
NAME                       CREATED AT
candies.awesome.corp.com   2022-11-24T22:56:27Z
</code></pre>
    <p class="normal">There is also an API endpoint for managing this new resource:</p>
    <pre class="programlisting gen"><code class="hljs">/apis/awesome.corp.com/v1/namespaces/&lt;namespace&gt;/candies/
</code></pre>
    <h2 id="_idParaDest-715" class="heading-2">Integrating custom resources</h2>
    <p class="normal">Once<a id="_idIndexMarker1659"/> the <code class="inlineCode">CustomResourceDefinition</code> object has been created, you can create custom resources of that resource kind – <code class="inlineCode">Candy</code> in this case (candy becomes CamelCase Candy). Custom resources must respect the schema of the CRD. In the following example, the <code class="inlineCode">flavor</code> field is set on the <code class="inlineCode">Candy</code> object with the name <code class="inlineCode">chocolate</code>. The <code class="inlineCode">apiVersion</code> field is derived from the CRD <code class="inlineCode">spec</code> group and <code class="inlineCode">versions</code> fields:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">awesome.corp.com/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Candy</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">chocolate</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">flavor:</span> <span class="hljs-string">sweeeeeeet</span>
</code></pre>
    <p class="normal">Let’s create it:</p>
    <pre class="programlisting gen"><code class="hljs">$ k create -f chocolate.yaml
candy.awesome.corp.com/chocolate created
</code></pre>
    <p class="normal">Note that the spec must contain the <code class="inlineCode">flavor</code> field from the schema.</p>
    <p class="normal">At this point, kubectl can operate on Candy objects just like it works on built-in objects. Resource names are case-insensitive when using kubectl:</p>
    <pre class="programlisting gen"><code class="hljs">$ k get candies
NAME        AGE
chocolate   34s
</code></pre>
    <p class="normal">We can also view the raw JSON data using the standard <code class="inlineCode">-o json</code> flag. Let’s use the short name <code class="inlineCode">cn</code> this time:</p>
    <pre class="programlisting gen"><code class="hljs">$ k get cn -o json
{
    "apiVersion": "v1",
    "items": [
        {
            "apiVersion": "awesome.corp.com/v1",
            "kind": "Candy",
            "metadata": {
                "creationTimestamp": "2022-11-24T23:11:01Z",
                "generation": 1,
                "name": "chocolate",
                "namespace": "default",
                "resourceVersion": "750357",
                "uid": "49f68d80-e9c0-4c20-a87d-0597a60c4ed8"
            },
            "spec": {
                "flavor": "sweeeeeeet"
            }
        }
    ],
    "kind": "List",
    "metadata": {
        "resourceVersion": ""
    }
}
</code></pre>
    <h3 id="_idParaDest-716" class="heading-3">Dealing with unknown fields</h3>
    <p class="normal">The <a id="_idIndexMarker1660"/>schema in the spec was introduced with the <code class="inlineCode">apiextensions.k8s.io/v1</code> version of CRDs that became stable in Kubernetes 1.17. With <code class="inlineCode">apiextensions.k8s.io/v1beta</code>, a schema wasn’t required so arbitrary fields were the way to go. If you just try to change the version of your CRD from v1beta to v1, you’re in for a rude awakening. Kubernetes will let you update the CRD, but when you try to create a custom resource later with unknown fields, it will fail.</p>
    <p class="normal">You must define a schema for all your CRDs. If you must deal with custom resources that may have additional unknown fields, you can turn validation off, but the additional fields will be stripped off.</p>
    <p class="normal">Here is a <code class="inlineCode">Candy</code> resource that has an extra field, <code class="inlineCode">texture</code>, not specified in the schema:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">awesome.corp.com/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Candy</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">gummy-bear</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">flavor:</span> <span class="hljs-string">delicious</span>
  <span class="hljs-attr">texture:</span> <span class="hljs-string">rubbery</span>
</code></pre>
    <p class="normal">If we try to create it with validation, it will fail:</p>
    <pre class="programlisting gen"><code class="hljs">$ k create -f gummy-bear.yaml
Error from server (BadRequest): error when creating "gummy-bear.yaml": Candy in version "v1" cannot be handled as a Candy: strict decoding error: unknown field "spec.texture"
</code></pre>
    <p class="normal">But, if we turn validation off, then all is well, except that only the <code class="inlineCode">flavor</code> field will be present and the <code class="inlineCode">texture</code> field will not:</p>
    <pre class="programlisting gen"><code class="hljs">$ k create -f gummy-bear.yaml --validate=false
candy.awesome.corp.com/gummy-bear created
$ k get cn gummy-bear -o yaml
apiVersion: awesome.corp.com/v1
kind: Candy
metadata:
  creationTimestamp: "2022-11-24T23:13:33Z"
  generation: 1
  name: gummy-bear
  namespace: default
  resourceVersion: "750534"
  uid: d77d9bdc-5a53-4f8e-8468-c29e2d46f919
spec:
  flavor: delicious
</code></pre>
    <p class="normal">Sometimes, it <a id="_idIndexMarker1661"/>can be useful to keep unknown fields. CRDs can support unknown fields by adding a special field to the schema.</p>
    <p class="normal">Let’s delete the current Candy CRD and replace it with a CRD that supports unknown fields:</p>
    <pre class="programlisting gen"><code class="hljs">$ k delete -f candy-crd.yaml
customresourcedefinition.apiextensions.k8s.io "candies.awesome.corp.com" deleted
$ k create -f candy-with-unknown-fields-crd.yaml
customresourcedefinition.apiextensions.k8s.io/candies.awesome.corp.com created
</code></pre>
    <p class="normal">The new CRD has the <code class="inlineCode">x-kubernetes-preserve-unknown-fields</code> field set to <code class="inlineCode">true</code> in the <code class="inlineCode">spec</code> property:</p>
    <pre class="programlisting code"><code class="hljs-code">      <span class="hljs-attr">schema:</span>
        <span class="hljs-attr">openAPIV3Schema:</span>
          <span class="hljs-attr">type:</span> <span class="hljs-string">object</span>
          <span class="hljs-attr">properties:</span>
            <span class="hljs-attr">spec:</span>
              <span class="hljs-attr">type:</span> <span class="hljs-string">object</span>
              <span class="hljs-attr">x-kubernetes-preserve-unknown-fields:</span> <span class="hljs-literal">true</span>
              <span class="hljs-attr">properties:</span>
                <span class="hljs-attr">flavor:</span>
                  <span class="hljs-attr">type:</span> <span class="hljs-string">string</span>
</code></pre>
    <p class="normal">Let’s create<a id="_idIndexMarker1662"/> our gummy bear again WITH validation and check that the unknown <code class="inlineCode">texture</code> field is present:</p>
    <pre class="programlisting gen"><code class="hljs">$ k create -f gummy-bear.yaml
candy.awesome.corp.com/gummy-bear created
$ k get cn gummy-bear -o yaml
apiVersion: awesome.corp.com/v1
kind: Candy
metadata:
  creationTimestamp: "2022-11-24T23:38:01Z"
  generation: 1
  name: gummy-bear
  namespace: default
  resourceVersion: "752234"
  uid: 6863f767-5dc0-43f7-91f3-1c734931b979
spec:
  flavor: delicious
  texture: rubbery
</code></pre>
    <h3 id="_idParaDest-717" class="heading-3">Finalizing custom resources</h3>
    <p class="normal">Custom resources <a id="_idIndexMarker1663"/>support finalizers just like standard API objects. A finalizer is a mechanism where objects are not deleted immediately but have to wait for special controllers that run in the background and watch for deletion requests. The controller may perform any necessary cleanup options and then remove its finalizer from the target object. There may be multiple finalizers on an object. Kubernetes will wait until all finalizers have been removed and only then delete the object. The finalizers in the metadata are just arbitrary strings that their corresponding controller can identify. Kubernetes doesn’t know what they mean. </p>
    <p class="normal">It just waits patiently for all the finalizers to be removed before deleting the object. Here is an example with a <code class="inlineCode">Candy</code> object that has two finalizers: <code class="inlineCode">eat-me</code> and <code class="inlineCode">drink-me</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">awesome.corp.com/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Candy</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">chocolate</span>
  <span class="hljs-attr">finalizers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">eat-me</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">drink-me</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">flavor:</span> <span class="hljs-string">sweeeeeeet</span>
</code></pre>
    <h3 id="_idParaDest-718" class="heading-3">Adding custom printer columns</h3>
    <p class="normal">By <a id="_idIndexMarker1664"/>default, when you list custom resources with kubectl, you get only the name and the age of the resource:</p>
    <pre class="programlisting gen"><code class="hljs">$ k get cn
NAME         AGE
chocolate    11h
gummy-bear   16m
</code></pre>
    <p class="normal">But the CRD schema allows you to add your own columns. Let’s add the flavor and the age as printable columns to our <code class="inlineCode">Candy</code> objects:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apiextensions.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">CustomResourceDefinition</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">candies.awesome.corp.com</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">group:</span> <span class="hljs-string">awesome.corp.com</span>
  <span class="hljs-attr">versions:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v1</span>
        <span class="hljs-string">...</span>
      <span class="hljs-attr">additionalPrinterColumns:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Flavor</span>
          <span class="hljs-attr">type:</span> <span class="hljs-string">string</span>
          <span class="hljs-attr">description:</span> <span class="hljs-string">The</span> <span class="hljs-string">flavor</span> <span class="hljs-string">of</span> <span class="hljs-string">the</span> <span class="hljs-string">candy</span>
          <span class="hljs-attr">jsonPath:</span> <span class="hljs-string">.spec.flavor</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Age</span>
          <span class="hljs-attr">type:</span> <span class="hljs-string">date</span>
          <span class="hljs-attr">jsonPath:</span> <span class="hljs-string">.metadata.creationTimestamp</span>
   <span class="hljs-string">...</span> 
</code></pre>
    <p class="normal">Then we can apply it, add our candies again, and list them:</p>
    <pre class="programlisting gen"><code class="hljs">$ k apply -f candy-with-flavor-crd.yaml
customresourcedefinition.apiextensions.k8s.io/candies.awesome.corp.com configured
$ k get cn
NAME         FLAVOR       AGE
chocolate    sweeeeeeet   13m
gummy-bear   delicious    18m
</code></pre>
    <h2 id="_idParaDest-719" class="heading-2">Understanding API server aggregation</h2>
    <p class="normal">CRDs are great <a id="_idIndexMarker1665"/>when all you need is some CRUD operations on your own types. You can just piggyback on the Kubernetes API server, which will store your objects and provide API support and integration with tooling like kubectl. If you need more power, you can run controllers that watch for your custom resources and perform some operations when they are created, updated, or deleted. The Kubebuilder (<a href="https://github.com/kubernetes-sigs/kubebuilder"><span class="url">https://github.com/kubernetes-sigs/kubebuilder</span></a>) project is a great framework for building Kubernetes APIs on top of CRDs with your own controllers.</p>
    <p class="normal">But CRDs have limitations. If you need more advanced features and customization, you can use API server aggregation and write your own API server, which the Kubernetes API server will delegate to. Your API server will use the same API machinery as the Kubernetes API server itself. Some<a id="_idIndexMarker1666"/> advanced capabilities are available only through the aggregation layer:</p>
    <ul>
      <li class="bulletList">Make your API server adopt different storage APIs rather than etcd</li>
      <li class="bulletList">Extend long-running subresources/endpoints like WebSocket for your own resources</li>
      <li class="bulletList">Integrate your API server with any other external systems</li>
      <li class="bulletList">Control the storage of your objects (custom resources are always stored in etcd)</li>
      <li class="bulletList">Custom operations beyond CRUD (e.g., exec or scale)</li>
      <li class="bulletList">Use protocol buffer payloads</li>
    </ul>
    <p class="normal">Writing an extension API server is a non-trivial effort. If you decide you need all that power, there are a couple of good starting points. You can look at the sample API server for inspiration (<a href="https://github.com/kubernetes/sample-apiserver"><span class="url">https://github.com/kubernetes/sample-apiserver</span></a>). You may want to check out the <code class="inlineCode">apiserver-builder-alpha</code> project (<a href="https://github.com/kubernetes-sigs/apiserver-builder-alpha"><span class="url">https://github.com/kubernetes-sigs/apiserver-builder-alpha</span></a>). It takes care of a lot of the necessary boilerplate code. The API builder provides the following capabilities:</p>
    <ul>
      <li class="bulletList">Bootstrap complete type definitions, controllers, and tests as well as documentation</li>
      <li class="bulletList">An extension control plane you can run on a local cluster or on an actual remote cluster</li>
      <li class="bulletList">Your generated controllers will be able to watch and update API objects</li>
      <li class="bulletList">Add resources (including sub-resources)</li>
      <li class="bulletList">Default values you can override if needed</li>
    </ul>
    <p class="normal">There is also a walkthrough here: <a href="https://kubernetes.io/docs/tasks/extend-kubernetes/setup-extension-api-server/"><span class="url">https://kubernetes.io/docs/tasks/extend-kubernetes/setup-extension-api-server/</span></a>.</p>
    <h2 id="_idParaDest-720" class="heading-2">Building Kubernetes-like control planes</h2>
    <p class="normal">What if <a id="_idIndexMarker1667"/>you want to use the Kubernetes model to manage other things and not just pods? It turns out that this is a very desirable capability. There is a project with a lot of momentum that provides it: <a href="https://github.com/kcp-dev/kcp"><span class="url">https://github.com/kcp-dev/kcp</span></a>.</p>
    <p class="normal">kcp also ventures into multi-cluster management.</p>
    <p class="normal">What does kcp bring to the table?</p>
    <ul>
      <li class="bulletList">It is a control plane for multiple conceptual clusters called workspaces</li>
      <li class="bulletList">It enables external API service providers to integrate with the central control plane using multi-tenant operators</li>
      <li class="bulletList">Users can consume APIs easily in their workspaces</li>
      <li class="bulletList">Scheduling workloads flexibly to physical clusters</li>
      <li class="bulletList">Move workloads transparently between compatible physical clusters</li>
      <li class="bulletList">Users can deploy their workloads while taking advantage of capabilities such as geographic replication and cross-cloud replication.</li>
    </ul>
    <p class="normal">We have covered different ways to extend Kubernetes by adding controllers and aggregated API servers. Let’s take a look at another mode of extending Kubernetes, by writing plugins.</p>
    <h1 id="_idParaDest-721" class="heading-1">Writing Kubernetes plugins</h1>
    <p class="normal">In this <a id="_idIndexMarker1668"/>section, we will dive into the guts of Kubernetes and learn how to take advantage of its famous flexibility and extensibility. We will learn about different aspects that can be customized via plugins and how to implement such plugins and integrate them with Kubernetes.</p>
    <h2 id="_idParaDest-722" class="heading-2">Writing a custom scheduler</h2>
    <p class="normal">Kubernetes is all <a id="_idIndexMarker1669"/>about orchestrating <a id="_idIndexMarker1670"/>containerized workloads. The most fundamental responsibility is to schedule pods to run on cluster nodes. Before we can write our own scheduler, we need to understand how scheduling works in Kubernetes</p>
    <h3 id="_idParaDest-723" class="heading-3">Understanding the design of the Kubernetes scheduler</h3>
    <p class="normal">The Kubernetes scheduler <a id="_idIndexMarker1671"/>has a very simple role – when a new pod needs to be created, assign it to a target node. That’s it. The Kubelet on the target node will take it from there and instruct the container runtime on the node to run the pod’s containers.</p>
    <p class="normal">The Kubernetes scheduler implements the Controller pattern:</p>
    <ul>
      <li class="bulletList">Watch for pending pods</li>
      <li class="bulletList">Select the proper node for the pod</li>
      <li class="bulletList">Update the node’s spec by setting the <code class="inlineCode">nodeName</code> field</li>
    </ul>
    <p class="normal">The only complicated part is selecting the target node. This process involves multiple steps split into two cycles:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The scheduling cycle</li>
      <li class="numberedList">The binding cycle</li>
    </ol>
    <p class="normal">While scheduling cycles are executed sequentially, binding cycles can be executed in parallel. If the target pod is considered unschedulable or an internal error occurs, the cycle will be terminated, and the pod will be placed back in the queue to be retried at a later time.</p>
    <p class="normal">The scheduler is implemented using an extensible scheduler framework. The framework defines multiple extension points that you can plug into to affect the scheduling process. The following diagram shows the overall process and the extension points:</p>
    <figure class="mediaobject"><img src="../Images/B18998_15_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.5: The workflow of the Kubernetes scheduler</p>
    <p class="normal">The scheduler<a id="_idIndexMarker1672"/> takes a tremendous amount of information and configuration into account. Filtering removes nodes that don’t satisfy one of the hard constraints from the candidate list. Ranking nodes assigns a score to each of the remaining nodes and chooses the best node.</p>
    <p class="normal">Here are the factors the scheduler evaluates <a id="_idIndexMarker1673"/>when filtering nodes:</p>
    <ul>
      <li class="bulletList">Verify that the ports requested by the pod are available on the node, ensuring the required network connectivity.</li>
      <li class="bulletList">Ensure that the pod is scheduled on a node whose hostname matches the specified node preference.</li>
      <li class="bulletList">Validate the availability of requested resources (CPU and memory) on the node to meet the pod’s requirements.</li>
      <li class="bulletList">Match the node’s labels with the pod’s node selector or node affinity to ensure proper scheduling.</li>
      <li class="bulletList">Confirm that the node supports the requested volume types, considering any failure zone restrictions for storage.</li>
      <li class="bulletList">Evaluate the node’s capacity to accommodate the pod’s volume requests, accounting for existing mounted volumes.</li>
      <li class="bulletList">Ensure the node’s health by checking for indicators such as memory pressure or PID pressure.</li>
      <li class="bulletList">Evaluate the pod’s tolerations to determine compatibility with the node’s taints, enabling or restricting scheduling accordingly.</li>
    </ul>
    <p class="normal">Once the nodes <a id="_idIndexMarker1674"/>have been filtered, the scheduler will score the modes based on the following policies (which you can configure):</p>
    <ul>
      <li class="bulletList">Distribute pods across hosts while considering pods belonging to the same Service, StatefulSet, or ReplicaSet.</li>
      <li class="bulletList">Give priority to inter-pod affinity, which means favoring pods that have an affinity or preference for running on the same node.</li>
      <li class="bulletList">Apply the “Least requested” priority, which favors nodes with fewer requested resources. This policy aims to distribute pods across all nodes in the cluster.</li>
      <li class="bulletList">Apply the “Most requested” priority, which favors nodes with the highest requested resources. This policy tends to pack pods into a smaller set of nodes.</li>
      <li class="bulletList">Use the “Requested to capacity ratio” priority, which calculates a priority based on the ratio of requested resources to the node’s capacity. It uses a default resource scoring function shape.</li>
      <li class="bulletList">Prioritize nodes with balanced resource allocation, favoring nodes with balanced resource usage.</li>
      <li class="bulletList">Utilize the “Node prefer avoid pods” priority, which prioritizes nodes based on the node annotation <code class="inlineCode">scheduler.alpha.kubernetes.io/preferAvoidPods</code>. This annotation is used to indicate that two different pods should not run on the same node.</li>
      <li class="bulletList">Apply node affinity priority, giving preference to nodes based on the node affinity scheduling preferences specified in <code class="inlineCode">PreferredDuringSchedulingIgnoredDuringExecution</code>.</li>
      <li class="bulletList">Consider taint toleration priority, preparing a priority list for all nodes based on the number of intolerable taints on each node. This policy adjusts a node’s rank, taking taints into account.</li>
      <li class="bulletList">Give priority to nodes that already have the container images required by the pod using the “Image locality” priority.</li>
      <li class="bulletList">Prioritize spreading pods backing a service across different nodes with the “Service spreading” priority.</li>
      <li class="bulletList">Apply pod anti-affinity, which means avoiding running pods on nodes that already have similar pods based on anti-affinity rules.</li>
      <li class="bulletList">Use the “Equal priority map,” where all nodes have the same weight and there are no favorites or biases.</li>
    </ul>
    <p class="normal">Check out <a href="https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/"><span class="url">https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/</span></a> for more details.</p>
    <p class="normal">As you can see, the <a id="_idIndexMarker1675"/>default scheduler is very sophisticated and can be configured in a very fine-grained way to accommodate most of your needs. But, under some circumstances, it might not be the best choice. </p>
    <p class="normal">In particular, in large clusters with many nodes (hundreds or thousands), every time a pod is scheduled, all the nodes need to go through this rigorous and heavyweight procedure of filtering and scoring. Now, consider a situation where you need to schedule a large number of pods at once (e.g., training machine learning models). This can put a lot of pressure on your cluster and lead to performance issues.</p>
    <p class="normal">Kubernetes can make the filtering and scoring process more lightweight by allowing you to filter and score only some of the pods, but still, you may want better control.</p>
    <p class="normal">Fortunately, Kubernetes allows you to influence the scheduling process in several ways. Those ways include:</p>
    <ul>
      <li class="bulletList">Direct scheduling of pods to nodes</li>
      <li class="bulletList">Replacing the scheduler with your own scheduler</li>
      <li class="bulletList">Extending the scheduler with additional filters</li>
      <li class="bulletList">Adding another scheduler that runs side by side with the default scheduler</li>
    </ul>
    <p class="normal">Let’s review various methods you can use to influence pod scheduling.</p>
    <h3 id="_idParaDest-724" class="heading-3">Scheduling pods manually</h3>
    <p class="normal">Guess what? We <a id="_idIndexMarker1676"/>can just tell Kubernetes where to place our pod when we create the pod. All it takes is to specify a node name in the pod’s spec and the scheduler will ignore it. If you think about the loosely coupled nature of the controller pattern, it all makes sense. The scheduler is watching for pending pods that DON’T have a node name assigned yet. If you are passing the node name yourself, then the Kubelet on the target node, which watches for pending pods that DO have a node name, will just go ahead and make sure to create a new pod.</p>
    <p class="normal">Let’s look at the nodes of our k3d cluster:</p>
    <pre class="programlisting gen"><code class="hljs">$ k get no
NAME                       STATUS   ROLES                  AGE    VERSION
k3d-k3s-default-agent-1    Ready    &lt;none&gt;                 155d   v1.23.6+k3s1
k3d-k3s-default-server-0   Ready    control-plane,master   155d   v1.23.6+k3s1
k3d-k3s-default-agent-0    Ready    &lt;none&gt;                 155d   v1.23.6+k3s1```
</code></pre>
    <p class="normal">Here is a <a id="_idIndexMarker1677"/>pod with a pre-defined node name, <code class="inlineCode">k3d-k3s-default-agent-1</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">some-pod-manual-scheduling</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">some-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">registry.k8s.io/pause:3.8</span>
  <span class="hljs-attr">nodeName:</span> <span class="hljs-string">k3d-k3s-default-agent-1</span>
  <span class="hljs-attr">schedulerName:</span> <span class="hljs-literal">no</span><span class="hljs-string">-such-scheduler</span>
</code></pre>
    <p class="normal">Let’s create the pod and see that it was indeed scheduled to the <code class="inlineCode">k3d-k3s-default-agent-1</code> node as requested:</p>
    <pre class="programlisting gen"><code class="hljs">$ k create -f some-pod-manual-scheduling.yaml
pod/some-pod-manual-scheduling created
$ k get po some-pod-manual-scheduling -o wide
NAME                         READY   STATUS    RESTARTS   AGE   IP            NODE                      NOMINATED NODE   READINESS GATES
some-pod-manual-scheduling   1/1     Running   0          26s   10.42.2.213   k3d-k3s-default-agent-1   &lt;none&gt;           &lt;none&gt;
</code></pre>
    <p class="normal">Direct scheduling is also useful for troubleshooting when you want to schedule a temporary pod to a tainted node without mucking around with adding tolerations.</p>
    <p class="normal">Let’s create our own custom scheduler now.</p>
    <h3 id="_idParaDest-725" class="heading-3">Preparing our own scheduler</h3>
    <p class="normal">Our scheduler<a id="_idIndexMarker1678"/> will be super simple. It will just schedule all pending pods that request to be scheduled by the <code class="inlineCode">custom-scheduler</code> to the node <code class="inlineCode">k3d-k3s-default-agent-0</code>. Here is a Python implementation that uses the <code class="inlineCode">kubernetes</code> client package:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> kubernetes <span class="hljs-keyword">import</span> client, config, watch
<span class="hljs-keyword">def</span> <span class="hljs-title">schedule_pod</span>(<span class="hljs-params">cli, name</span>):
    target = client.V1ObjectReference()
    target.kind = <span class="hljs-string">'Node'</span>
    target.apiVersion = <span class="hljs-string">'v1'</span>
    target.name = <span class="hljs-string">'k3d-k3s-default-agent-0'</span>
    meta = client.V1ObjectMeta()
    meta.name = name
    body = client.V1Binding(metadata=meta, target=target)
    <span class="hljs-keyword">return</span> cli.create_namespaced_binding(<span class="hljs-string">'default'</span>, body)
<span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():
    config.load_kube_config()
    cli = client.CoreV1Api()
    w = watch.Watch()
    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> w.stream(cli.list_namespaced_pod, <span class="hljs-string">'default'</span>):
        o = event[<span class="hljs-string">'object'</span>]
        <span class="hljs-keyword">if</span> o.status.phase != <span class="hljs-string">'Pending'</span> <span class="hljs-keyword">or</span> o.spec.scheduler_name != <span class="hljs-string">'custom-scheduler'</span>:
            <span class="hljs-keyword">continue</span>
        schedule_pod(cli, o.metadata.name)
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()
</code></pre>
    <p class="normal">If you want to run a custom scheduler long term, then you should deploy it into the cluster just like any other workload as a deployment. But, if you just want to play around with it, or you’re still developing your custom scheduler logic, you can run it locally as long as it has the correct credentials to access the cluster and has permissions to watch for pending pods and update their node name.</p>
    <p class="normal">Note that I strongly recommend building production custom schedulers on top of the scheduling framework (<a href="https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/"><span class="url">https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/</span></a>).</p>
    <h3 id="_idParaDest-726" class="heading-3">Assigning pods to the custom scheduler</h3>
    <p class="normal">OK. We<a id="_idIndexMarker1679"/> have a custom scheduler that we can run alongside the default scheduler. But how does Kubernetes choose which scheduler to use to schedule a pod when there are multiple schedulers?</p>
    <p class="normal">The answer is that Kubernetes doesn’t care. The pod can specify which scheduler it wants to schedule it. The default scheduler will schedule any pod that doesn’t specify the schedule or that specifies explicitly <code class="inlineCode">default-scheduler</code>. Other custom schedulers should be responsible and only schedule pods that request them. If multiple schedulers try to schedule the same pod, we will probably end up with multiple copies or naming conflicts.</p>
    <p class="normal">For example, our simple custom scheduler is looking for pending pods that specify a scheduler name of <code class="inlineCode">custom-scheduler</code>. All other pods will be ignored by it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">if</span> <span class="hljs-string">o.status.phase</span> <span class="hljs-type">!=</span> <span class="hljs-string">'Pending'</span> <span class="hljs-string">or</span> <span class="hljs-string">o.spec.scheduler_name</span> <span class="hljs-type">!=</span> <span class="hljs-attr">'custom-scheduler':</span>
    <span class="hljs-string">continue</span>
</code></pre>
    <p class="normal">Here is a pod spec that specifies <code class="inlineCode">custom-scheduler</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">some-pod-with-custom-scheduler</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">some-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">registry.k8s.io/pause:3.8</span>
  <span class="hljs-attr">schedulerName:</span> <span class="hljs-string">custom-scheduler</span>
</code></pre>
    <p class="normal">What happens if our custom scheduler is not running and we try to create this pod?</p>
    <pre class="programlisting gen"><code class="hljs">$ k create -f some-pod-with-custom-scheduler.yaml
pod/some-pod-with-custom-scheduler created
$ k get po
NAME                             READY   STATUS    RESTARTS   AGE
some-pod-manual-scheduling       1/1     Running   0          9m33s
some-pod-with-custom-scheduler   0/1     Pending   0          14s
</code></pre>
    <p class="normal">The pod is created just fine (meaning the Kubernetes API server stored it in etcd), but it is pending, which means it wasn’t scheduled yet. Since it specified an explicit scheduler, the default scheduler ignores it.</p>
    <p class="normal">But, if we <a id="_idIndexMarker1680"/>run our scheduler… it will immediately get scheduled:</p>
    <pre class="programlisting gen"><code class="hljs">python custom_scheduler.py
Waiting for pending pods...
Scheduling pod: some-pod-with-custom-scheduler
</code></pre>
    <p class="normal">Now, we can see that the pod was assigned to a node, and it is in a running state:</p>
    <pre class="programlisting gen"><code class="hljs">$ k get po -o wide
NAME                             READY   STATUS    RESTARTS   AGE    IP            NODE                      NOMINATED NODE   READINESS GATES
some-pod-manual-scheduling       1/1     Running   0          4h5m   10.42.2.213   k3d-k3s-default-agent-1   &lt;none&gt;           &lt;none&gt;
some-pod-with-custom-scheduler   1/1     Running   0          87s    10.42.0.125   k3d-k3s-default-agent-0   &lt;none&gt;           &lt;none&gt;
</code></pre>
    <p class="normal">That was a deep dive into scheduling and custom schedulers. Let’s check out kubectl plugins.</p>
    <h2 id="_idParaDest-727" class="heading-2">Writing kubectl plugins</h2>
    <p class="normal">Kubectl is<a id="_idIndexMarker1681"/> the workhorse of the aspiring Kubernetes developer and admin. There <a id="_idIndexMarker1682"/>are <a id="_idIndexMarker1683"/>now very good visual tools like k9s (<a href="https://github.com/derailed/k9s"><span class="url">https://github.com/derailed/k9s</span></a>), octant (<a href="https://github.com/vmware-tanzu/octant"><span class="url">https://github.com/vmware-tanzu/octant</span></a>), and Lens <a id="_idIndexMarker1684"/>Desktop (<a href="https://k8slens.dev"><span class="url">https://k8slens.dev</span></a>). But, for many engineers, kubectl is the most complete way to work interactively with your cluster, as well to participate in automation workflows.</p>
    <p class="normal">Kubectl <a id="_idIndexMarker1685"/>encompasses an impressive list of capabilities, but you will often need to string together multiple commands or a long chain of parameters to accomplish some tasks. You may also want to run some additional tools installed in your cluster.</p>
    <p class="normal">You can package such functionality as scripts or containers, or any other way, but then you’ll run into the issue of where to place them, how to discover them, and how to manage them. Kubectl plugins give you a one-stop shop for those extended capabilities. For example, recently I needed to periodically list and move around files on an SFTP server managed by a containerized application running on a Kubernetes cluster. I quickly wrote a few <a id="_idIndexMarker1686"/>kubectl plugins that took advantage of my KUBECONFIG credentials to get access to secrets in the cluster that contained the credentials to access the SFTP server and then implemented a lot of application-specific logic for accessing and managing those SFTP directories and files.</p>
    <h3 id="_idParaDest-728" class="heading-3">Understanding kubectl plugins</h3>
    <p class="normal">Until <a id="_idIndexMarker1687"/>Kubernetes 1.12, kubectl plugins required a dedicated YAML file where you specified various metadata and other files that implemented the functionality. In Kubernetes 1.12, kubectl started using the Git extension model where any executable on your path with the prefix <code class="inlineCode">kubectl-</code> is treated as a plugin.</p>
    <p class="normal">Kubectl provides the <code class="inlineCode">kubectl plugins list</code> command to list all your current plugins. This model was very successful with Git and it is extremely simple now to add your own kubectl plugins.</p>
    <p class="normal">If you add an executable called <code class="inlineCode">kubectl-foo</code>, then you can run it via <code class="inlineCode">kubectl foo</code>. You can have nested commands too. Add <code class="inlineCode">kubectl-foo-bar</code> to your path and run it via <code class="inlineCode">kubectl foo bar</code>. If you want to use dashes in your commands, then in your executable, use underscores. For example, the executable <code class="inlineCode">kubectl-do_stuff</code> can be run using <code class="inlineCode">kubectl do-stuff</code>.</p>
    <p class="normal">The executable itself can be implemented in any language, have its own command-line arguments and flags, and display its own usage and help information.</p>
    <h3 id="_idParaDest-729" class="heading-3">Managing kubectl plugins with Krew</h3>
    <p class="normal">The<a id="_idIndexMarker1688"/> lightweight plugin model is great for writing your own<a id="_idIndexMarker1689"/> plugins, but what if you want to share your plugins with the community? Krew (<a href="https://github.com/kubernetes-sigs/krew"><span class="url">https://github.com/kubernetes-sigs/krew</span></a>) is <a id="_idIndexMarker1690"/>a package <a id="_idIndexMarker1691"/>manager for kubectl plugins that lets you discover, install, and manage curated plugins.</p>
    <p class="normal">You can install Krew with Brew on Mac or follow the installation instructions for other platforms. Krew is itself a kubectl plugin as its executable is <code class="inlineCode">kubectl-krew</code>. This means you can either run it directly with <code class="inlineCode">kubectl-krew</code> or through kubectl <code class="inlineCode">kubectl krew</code>. If you have a <code class="inlineCode">k</code> alias for <code class="inlineCode">kubectl</code>, you would probably prefer the latter:</p>
    <pre class="programlisting gen"><code class="hljs">$ k krew
krew is the kubectl plugin manager.
You can invoke krew through kubectl: "kubectl krew [command]..."
Usage:
  kubectl krew [command]
Available Commands:
  completion  generate the autocompletion script for the specified shell
  help        Help about any command
  index       Manage custom plugin indexes
  info        Show information about an available plugin
  install     Install kubectl plugins
  list        List installed kubectl plugins
  search      Discover kubectl plugins
  uninstall   Uninstall plugins
  update      Update the local copy of the plugin index
  upgrade     Upgrade installed plugins to newer versions
  version     Show krew version and diagnostics
Flags:
  -h, --help      help for krew
  -v, --v Level   number for the log level verbosity
Use "kubectl krew [command] --help" for more information about a command.
</code></pre>
    <p class="normal">Note<a id="_idIndexMarker1692"/> that the <code class="inlineCode">krew list</code> command shows only<a id="_idIndexMarker1693"/> Krew-managed plugins and not all kubectl plugins. It doesn’t even show itself.</p>
    <p class="normal">I recommend that you check out the available plugins. Some of them are very useful, and they may inspire you to write your own plugins. Let’s see how easy it is to write our own plugin.</p>
    <h3 id="_idParaDest-730" class="heading-3">Creating your own kubectl plugin</h3>
    <p class="normal">Kubectl plugins<a id="_idIndexMarker1694"/> can range from super simple to very complicated. I work a lot these days with AKS node pools created using the Cluster API and CAPZ (the Cluster API provider for Azure). I’m often interested in viewing all the node pools on a specific cloud provider. All the node pools are defined as custom resources in a namespace called <code class="inlineCode">cluster-registry</code>. The following kubectl command lists all the node pools:</p>
    <pre class="programlisting gen"><code class="hljs">$ k get -n cluster-registry azuremanagedmachinepools.infrastructure.cluster.x-k8s.io
aks-centralus-cluster-001-nodepool001         116d
aks-centralus-cluster-001-nodepool002         116d
aks-centralus-cluster-002-nodepool001         139d
aks-centralus-cluster-002-nodepool002         139d
aks-centralus-cluster-002-nodepool003         139d
...
</code></pre>
    <p class="normal">This is not<a id="_idIndexMarker1695"/> a lot of information. I’m interested in information like the SKU (VM type and size) of each node pool, its Kubernetes version, and the number of nodes in each node pool. The following kubectl command can provide this information:</p>
    <pre class="programlisting gen"><code class="hljs">$ k get -n cluster-registry azuremanagedmachinepools.infrastructure.cluster.x-k8s.io -o custom-columns=NAME:.metadata.name,SKU:.spec.sku,VERSION:.status.version,NODES:.status.replicas
NAME                                    SKU                 VERSION   NODES
aks-centralus-cluster-001-nodepool001   Standard_D4s_v4     1.23.8    10
aks-centralus-cluster-001-nodepool002   Standard_D8s_v4     1.23.8    20
aks-centralus-cluster-002-nodepool001   Standard_D16s_v4    1.23.8    30
aks-centralus-cluster-002-nodepool002   Standard_D8ads_v5   1.23.8    40
aks-centralus-cluster-002-nodepool003   Standard_D8ads_v5   1.23.8    50
</code></pre>
    <p class="normal">However, this is a lot to type. I simply put this command in a file called <code class="inlineCode">kubectl-npa-get</code> and stored it in <code class="inlineCode">/usr/local/bin</code>. Now, I can invoke it just by calling <code class="inlineCode">k npa get</code>. I could define a little alias or shell function, but a kubectl plugin is more appropriate as it is a central place for all kubectl-related enhancements. It enforces a uniform convention and it is discoverable via <code class="inlineCode">kubectl list plugins</code>.</p>
    <p class="normal">This was an example of an almost trivial kubectl plugin. Let’s look at a more complicated example – deleting namespaces. It turns out that reliably deleting namespaces in Kubernetes is far from trivial. Under certain conditions, a namespace can be stuck forever in a terminating state after you try to delete it. I created a little Go program to reliably delete namespaces. You can check it out here: <a href="https://github.com/the-gigi/k8s-namespace-deleter"><span class="url">https://github.com/the-gigi/k8s-namespace-deleter</span></a>.</p>
    <p class="normal">This is a perfect use case for a kubectl plugin. The instructions in the README recommend building the executable and then saving it in your path as <code class="inlineCode">kubectl-ns-delete</code>. Now, when you want to delete a namespace, you can just use <code class="inlineCode">k ns delete &lt;namespace&gt;</code> to invoke <code class="inlineCode">k8s-namespace-deleter</code> and reliably get rid of your namespace.</p>
    <p class="normal">If you want to develop plugins and share them on Krew, there is a more rigorous process<a id="_idIndexMarker1696"/> there. I highly recommend developing the plugin in Go and taking advantage of projects like <code class="inlineCode">cli-runtime </code>(<a href="https://github.com/kubernetes/cli-runtime/"><span class="url">https://github.com/kubernetes/cli-runtime/</span></a>) and <code class="inlineCode">krew-plugin-template</code> (<a href="https://github.com/replicatedhq/krew-plugin-template"><span class="url">https://github.com/replicatedhq/krew-plugin-template</span></a>).</p>
    <p class="normal">Kubectl plugins are awesome, but there are some gotchas you should be aware of. I ran into some of these issues when working with kubectl plugins.</p>
    <h4 class="heading-4">Don’t forget your shebangs!</h4>
    <p class="normal">If you don’t <a id="_idIndexMarker1697"/>specify a shebang for your shell-based executables, you will get an obscure error message:</p>
    <pre class="programlisting gen"><code class="hljs">$ k npa get
Error: exec format error
</code></pre>
    <h4 class="heading-4">Naming your plugin</h4>
    <p class="normal">Choosing a<a id="_idIndexMarker1698"/> name for your plugin is not easy. Luckily, there are some good guidelines: <a href="https://krew.sigs.k8s.io/docs/developer-guide/develop/naming-guide"><span class="url">https://krew.sigs.k8s.io/docs/developer-guide/develop/naming-guide</span></a>.</p>
    <p class="normal">Those naming guidelines are not just for Krew plugins, but make sense for any kubectl plugin.</p>
    <h4 class="heading-4">Overriding existing kubectl commands</h4>
    <p class="normal">I originally<a id="_idIndexMarker1699"/> named the plugin <code class="inlineCode">kubectl-get-npa</code>. In theory, kubectl should try to match the longest plugin name to resolve ambiguities. But, apparently, it doesn’t work with built-in commands like <code class="inlineCode">kubectl get</code>. This is the error I got:</p>
    <pre class="programlisting gen"><code class="hljs">$ k get npa
error: the server doesn't have a resource type "npa"
</code></pre>
    <p class="normal">Renaming the plugin to <code class="inlineCode">kubectl-npa-get</code> solved the problem.</p>
    <h4 class="heading-4">Flat namespace for Krew plugins</h4>
    <p class="normal">The space <a id="_idIndexMarker1700"/>of kubectl plugins is flat. If you choose a generic plugin name like <code class="inlineCode">kubectl-login</code>, you’ll have a lot of problems. Even if you qualify it with something like <code class="inlineCode">kubectl-gcp-login</code>, you might conflict with some other plugin. This is a scalability problem. I think the solution should involve a strong naming scheme for plugins like DNS and the ability to define short names and aliases for <a id="_idIndexMarker1701"/>convenience.</p>
    <p class="normal">We have covered kubectl plugins, how to write them, and how to use them. Let’s take a look at extending access control with webhooks.</p>
    <h1 id="_idParaDest-731" class="heading-1">Employing access control webhooks</h1>
    <p class="normal">Kubernetes<a id="_idIndexMarker1702"/> provides several ways for you to customize access control. In Kubernetes, access control can be denoted with triple-A: Authentication, Authorization, and Admission control. In early versions, access control happened through plugins that required Go programming, installing them into your cluster, registration, and other invasive procedures. Now, Kubernetes lets you customize authentication, authorization, and admission control via web hooks. Here is the access control workflow:</p>
    <figure class="mediaobject"><img src="../Images/B18998_15_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.6: Access control workflow</p>
    <h2 id="_idParaDest-732" class="heading-2">Using an authentication webhook</h2>
    <p class="normal">Kubernetes<a id="_idIndexMarker1703"/> lets you extend the authentication process by injecting a webhook for bearer tokens. It requires two pieces of information: how to access the remote authentication service and the duration of the authentication decision (it defaults to two minutes).</p>
    <p class="normal">To provide this information and enable authentication webhooks, start the API server with the following command-line arguments:</p>
    <pre class="programlisting gen"><code class="hljs">- --authentication-token-webhook-config-file=&lt;authentication config file&gt; 
- --authentication-token-webhook-cache-ttl (how long to cache auth decisions, default to 2 minutes)
</code></pre>
    <p class="normal">The <a id="_idIndexMarker1704"/>configuration file uses the kubeconfig file format. Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Kubernetes API version</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-comment"># kind of the API object</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Config</span>
<span class="hljs-comment"># clusters refers to the remote service.</span>
<span class="hljs-attr">clusters:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">name-of-remote-authn-service</span>
    <span class="hljs-attr">cluster:</span>
      <span class="hljs-attr">certificate-authority:</span> <span class="hljs-string">/path/to/ca.pem</span>         <span class="hljs-comment"># CA for verifying the remote service.</span>
      <span class="hljs-attr">server:</span> <span class="hljs-string">https://authn.example.com/authenticate</span> <span class="hljs-comment"># URL of remote service to query. Must use 'https'.</span>
<span class="hljs-comment"># users refers to the API server's webhook configuration.</span>
<span class="hljs-attr">users:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">name-of-api-server</span>
    <span class="hljs-attr">user:</span>
      <span class="hljs-attr">client-certificate:</span> <span class="hljs-string">/path/to/cert.pem</span> <span class="hljs-comment"># cert for the webhook plugin to use</span>
      <span class="hljs-attr">client-key:</span> <span class="hljs-string">/path/to/key.pem</span>          <span class="hljs-comment"># key matching the cert</span>
<span class="hljs-comment"># kubeconfig files require a context. Provide one for the API server.</span>
<span class="hljs-attr">current-context:</span> <span class="hljs-string">webhook</span>
<span class="hljs-attr">contexts:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">context:</span>
    <span class="hljs-attr">cluster:</span> <span class="hljs-string">name-of-remote-authn-service</span>
    <span class="hljs-attr">user:</span> <span class="hljs-string">name-of-api-sever</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">webhook</span>
</code></pre>
    <p class="normal">Note that a client certificate and key must be provided to Kubernetes for mutual authentication against the remote authentication service.</p>
    <p class="normal">The cache TTL is useful because often users will make multiple consecutive requests to Kubernetes. Having the authentication decision cached can save a lot of round trips to the remote authentication service.</p>
    <p class="normal">When <a id="_idIndexMarker1705"/>an API HTTP request comes in, Kubernetes extracts the bearer token from its headers and posts a <code class="inlineCode">TokenReview</code> JSON request to the remote authentication service via the webhook:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"</span><span class="hljs-string">authentication.k8s.io/v1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"kind"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"TokenReview"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"spec"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"token"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&lt;bearer token from original request headers&gt;"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">The remote authentication service will respond with a decision. The status authentication will either be <code class="inlineCode">true</code> or <code class="inlineCode">false</code>. Here is an example of a successful authentication:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"authentication.k8s.io/v1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"kind"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"TokenReview"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"status"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"authenticated"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"user"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"username"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"gigi@gg.com"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"uid"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"42"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"groups"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-string">"developers"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-punctuation">],</span>
      <span class="hljs-attr">"</span><span class="hljs-attr">extra"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"extrafield1"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
          <span class="hljs-string">"extravalue1"</span><span class="hljs-punctuation">,</span>
          <span class="hljs-string">"extravalue2"</span>
        <span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">A rejected response is much more concise:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"authentication.k8s.io/v1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"kind"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"TokenReview"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"</span><span class="hljs-attr">status"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"authenticated"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <h2 id="_idParaDest-733" class="heading-2">Using an authorization webhook</h2>
    <p class="normal">The <a id="_idIndexMarker1706"/>authorization webhook is very similar to the authentication webhook. It requires just a configuration file, which is in the same format as the authentication webhook configuration file. There is no authorization caching because, unlike authentication, the same user may make lots of requests to different API endpoints with different parameters, and authorization decisions may be different, so caching is not a viable option.</p>
    <p class="normal">You configure the webhook by passing the following command-line argument to the API server:</p>
    <pre class="programlisting gen"><code class="hljs">--authorization-webhook-config-file=&lt;configuration filename&gt;
</code></pre>
    <p class="normal">When a request passes authentication, Kubernetes will send a <code class="inlineCode">SubjectAccessReview </code>JSON object to the remote authorization service. It will contain the requesting user (and any user groups it belongs to) and other attributes such as the requested API group, <code class="inlineCode">namespace</code>, <code class="inlineCode">resource</code>, and <code class="inlineCode">verb</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"authorization.k8s.io/v1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"kind"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"SubjectAccessReview"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"spec"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"resourceAttributes"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"namespace"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"awesome-namespace"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"verb"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"get"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"group"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"awesome.example.org"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"resource"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"pods"</span>
    <span class="hljs-punctuation">},</span>
    <span class="hljs-attr">"user"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"</span><span class="hljs-string">gigi@gg.com"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"group"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-string">"group1"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"group2"</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">The request will either be allowed:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"authorization.k8s.io/v1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"kind"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"SubjectAccessReview"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"status"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"allowed"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">Or denied with a reason:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"authorization.k8s.io/v1beta1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"kind"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"</span><span class="hljs-string">SubjectAccessReview"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"status"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"allowed"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"reason"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"user does not have read access to the namespace"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">A user <a id="_idIndexMarker1707"/>may be authorized to access a resource, but not some non-resource attributes, such as <code class="inlineCode">/api</code>, <code class="inlineCode">/apis</code>, <code class="inlineCode">/metrics</code>, <code class="inlineCode">/resetMetrics</code>, <code class="inlineCode">/logs</code>, <code class="inlineCode">/debug</code>, <code class="inlineCode">/healthz</code>, <code class="inlineCode">/swagger-ui/</code>, <code class="inlineCode">/swaggerapi/</code>, <code class="inlineCode">/ui</code>, and <code class="inlineCode">/version</code>.</p>
    <p class="normal">Here is how to request access to the logs:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"authorization.k8s.io/v1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"kind"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"SubjectAccessReview"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"spec"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"nonResourceAttributes"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"path"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"/logs"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"verb"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"</span><span class="hljs-string">get"</span>
    <span class="hljs-punctuation">},</span>
    <span class="hljs-attr">"user"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"gigi@gg.com"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"group"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-string">"group1"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">"group2"</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">We can check, using kubectl, if we are authorized to perform an operation using the <code class="inlineCode">can-i</code> command. For example, let’s see if we can create deployments:</p>
    <pre class="programlisting gen"><code class="hljs">$ k auth can-i create deployments
yes
</code></pre>
    <p class="normal">We can<a id="_idIndexMarker1708"/> also check if other users or service accounts are authorized to do something. The default service account is NOT allowed to create deployments:</p>
    <pre class="programlisting gen"><code class="hljs">$ k auth can-i create deployments --as default
no
</code></pre>
    <h2 id="_idParaDest-734" class="heading-2">Using an admission control webhook</h2>
    <p class="normal">Dynamic admission control <a id="_idIndexMarker1709"/>supports webhooks too. It has been generally available since Kubernetes 1.16. Depending on your Kubernetes version, you may need to enable the <code class="inlineCode">MutatingAdmissionWebhook </code>and <code class="inlineCode">ValidatingAdmissionWebhook</code> admission controllers using <code class="inlineCode">--enable-admission-plugins=Mutating,ValidatingAdmissionWebhook</code> flags to <code class="inlineCode">kube-apiserver</code>. </p>
    <p class="normal">There are several other admission controllers that the Kubernetes developers recommend running (the order matters):</p>
    <pre class="programlisting gen"><code class="hljs">--admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota
</code></pre>
    <p class="normal">In Kubernetes 1.25, these plugins are enabled by default.</p>
    <h3 id="_idParaDest-735" class="heading-3">Configuring a webhook admission controller on the fly</h3>
    <p class="normal">Authentication<a id="_idIndexMarker1710"/> and authorization webhooks must be configured when you start the API server. Admission control webhooks can be configured dynamically by creating <code class="inlineCode">MutatingWebhookConfiguration </code>or <code class="inlineCode">ValidatingWebhookConfiguration</code> API objects. Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">admissionregistration.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ValidatingWebhookConfiguration</span>
<span class="hljs-string">...</span>
<span class="hljs-attr">webhooks:</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">admission-webhook.example.com</span>
  <span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">operations:</span> [<span class="hljs-string">"CREATE"</span>, <span class="hljs-string">"UPDATE"</span>]
    <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">"</span><span class="hljs-string">apps"</span>]
    <span class="hljs-attr">apiVersions:</span> [<span class="hljs-string">"v1"</span>, <span class="hljs-string">"v1beta1"</span>]
    <span class="hljs-attr">resources:</span> [<span class="hljs-string">"deployments"</span>, <span class="hljs-string">"replicasets"</span>]
    <span class="hljs-attr">scope:</span> <span class="hljs-string">"Namespaced"</span>
  <span class="hljs-string">...</span>
</code></pre>
    <p class="normal">An<a id="_idIndexMarker1711"/> admission server accesses <code class="inlineCode">AdmissionReview</code> requests such as:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"admission.k8s.io/v1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"kind"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"AdmissionReview"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"request"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"uid"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"705ab4f5-6393-11e8-b7cc-42010a800002"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"kind"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"group"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"autoscaling"</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"v1"</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"</span><span class="hljs-attr">kind"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"Scale"</span><span class="hljs-punctuation">},</span>
    <span class="hljs-attr">"resource"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"group"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"apps"</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"v1"</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"resource"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"deployments"</span><span class="hljs-punctuation">},</span>
    <span class="hljs-attr">"subResource"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"scale"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"requestKind"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"group"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"autoscaling"</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"v1"</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"</span><span class="hljs-attr">kind"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"Scale"</span><span class="hljs-punctuation">},</span>
    <span class="hljs-attr">"requestResource"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"group"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"apps"</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"v1"</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"resource"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"deployments"</span><span class="hljs-punctuation">},</span>
    <span class="hljs-attr">"requestSubResource"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"scale"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cool-deployment"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"namespace"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cool-namespace"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"</span><span class="hljs-attr">operation"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"UPDATE"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"userInfo"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"username"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"admin"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"uid"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"</span><span class="hljs-string">014fbff9a07c"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"groups"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"system:authenticated"</span><span class="hljs-punctuation">,</span><span class="hljs-string">"my-admin-group"</span><span class="hljs-punctuation">],</span>
      <span class="hljs-attr">"extra"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"some-key"</span><span class="hljs-punctuation">:[</span><span class="hljs-string">"some-value1"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"some-value2"</span><span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">},</span>
    <span class="hljs-attr">"object"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"autoscaling/v1"</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"kind"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"Scale"</span><span class="hljs-punctuation">,</span>...<span class="hljs-punctuation">},</span>
    <span class="hljs-attr">"oldObject"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"autoscaling/v1"</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"kind"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"Scale"</span><span class="hljs-punctuation">,</span>...<span class="hljs-punctuation">},</span>
    <span class="hljs-attr">"options"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"meta.k8s.io/v1"</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"kind"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"UpdateOptions"</span><span class="hljs-punctuation">,</span>...<span class="hljs-punctuation">},</span>
    <span class="hljs-attr">"dryRun"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">If the request is admitted, the response will be:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"admission.k8s.io/v1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"kind"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"AdmissionReview"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"response"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"uid"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&lt;value from request.uid&gt;"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"allowed"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">If the <a id="_idIndexMarker1712"/>request is not admitted, then <code class="inlineCode">allowed</code> will be <code class="inlineCode">False</code>. The admission server may provide a <code class="inlineCode">status</code> section too with an HTTP status code and message:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"apiVersion"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"admission.k8s.io/v1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"kind"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"AdmissionReview"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"response"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"uid"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&lt;value from request.uid&gt;"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"allowed"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"status"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"code"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">403</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"message"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"You cannot do this because I say so!!!!"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">That concludes our discussion of dynamic admission control. Let’s look at some more extension points.</p>
    <h1 id="_idParaDest-736" class="heading-1">Additional extension points</h1>
    <p class="normal">There are<a id="_idIndexMarker1713"/> some additional extension points that don’t fit into the categories we have discussed so far.</p>
    <h3 id="_idParaDest-737" class="heading-3">Providing custom metrics for horizontal pod autoscaling</h3>
    <p class="normal">Prior <a id="_idIndexMarker1714"/>to <a id="_idIndexMarker1715"/>Kubernetes 1.6, custom metrics<a id="_idIndexMarker1716"/> were implemented as a Heapster model. In Kubernetes 1.6, new custom metrics APIs landed and matured gradually. As of Kubernetes 1.9, they are enabled by default. As you may recall, Keda (<a href="https://keda.sh"><span class="url">https://keda.sh</span></a>) is a project that focuses on custom metrics for autoscaling. However, if for some reason Keda doesn’t meet your needs, you can implement<a id="_idIndexMarker1717"/> your own custom metrics. Custom metrics rely on API aggregation. The recommended path is to start with the custom metrics API server boilerplate, available here: <a href="https://github.com/kubernetes-sigs/custom-metrics-apiserver"><span class="url">https://github.com/kubernetes-sigs/custom-metrics-apiserver</span></a>.</p>
    <p class="normal">Then, you<a id="_idIndexMarker1718"/> can<a id="_idIndexMarker1719"/> implement the <code class="inlineCode">CustomMetricsProvider</code> interface:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">type</span> CustomMetricsProvider <span class="hljs-keyword">interface</span> {
    <span class="hljs-comment">// GetRootScopedMetricByName fetches a particular metric for a particular root-scoped object.</span>
    GetRootScopedMetricByName(groupResource schema.GroupResource, name <span class="hljs-type">string</span>, metricName <span class="hljs-type">string</span>) (*custom_metrics.MetricValue, <span class="hljs-type">error</span>)
    <span class="hljs-comment">// GetRootScopedMetricByName fetches a particular metric for a set of root-scoped objects</span>
    <span class="hljs-comment">// matching the given label selector.</span>
    GetRootScopedMetricBySelector(groupResource schema.GroupResource, selector labels.Selector, metricName <span class="hljs-type">string</span>) (*custom_metrics.MetricValueList, <span class="hljs-type">error</span>)
    <span class="hljs-comment">// GetNamespacedMetricByName fetches a particular metric for a particular namespaced object.</span>
    GetNamespacedMetricByName(groupResource schema.GroupResource, namespace <span class="hljs-type">string</span>, name <span class="hljs-type">string</span>, metricName <span class="hljs-type">string</span>) (*custom_metrics.MetricValue, <span class="hljs-type">error</span>)
    <span class="hljs-comment">// GetNamespacedMetricByName fetches a particular metric for a set of namespaced objects</span>
    <span class="hljs-comment">// matching the given label selector.</span>
    GetNamespacedMetricBySelector(groupResource schema.GroupResource, namespace <span class="hljs-type">string</span>, selector labels.Selector, metricName <span class="hljs-type">string</span>) (*custom_metrics.MetricValueList, <span class="hljs-type">error</span>)
    <span class="hljs-comment">// ListAllMetrics provides a list of all available metrics at</span>
    <span class="hljs-comment">// the current time. Note that this is not allowed to return</span>
    <span class="hljs-comment">// an error, so it is recommended that implementors cache and</span>
    <span class="hljs-comment">// periodically update this list, instead of querying every time.</span>
    ListAllMetrics() []CustomMetricInfo
}
</code></pre>
    <h2 id="_idParaDest-738" class="heading-2">Extending Kubernetes with custom storage</h2>
    <p class="normal">Volume plugins <a id="_idIndexMarker1720"/>are yet another type of plugin. Prior to Kubernetes 1.8, you had to write a kubelet plugin, which required registration<a id="_idIndexMarker1721"/> with Kubernetes and linking with the kubelet. Kubernetes 1.8 introduced the FlexVolume, which is much more versatile. Kubernetes 1.9 took it to the next level with <a id="_idIndexMarker1722"/>the CSI, which we covered in <em class="chapterRef">Chapter 6</em>, <em class="italic">Managing Storage</em>. At this point, if you need to write storage plugins, the CSI is the way to go. Since the CSI uses the gRPC protocol, the CSI plugin must implement the following gRPC interface:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">service </span><span class="hljs-title">Controller</span> {
  <span class="hljs-keyword">rpc</span><span class="hljs-function"> CreateVolume (CreateVolumeRequest)</span>
<span class="hljs-function">    </span><span class="hljs-keyword">returns</span><span class="hljs-function"> (CreateVolumeResponse) </span>{}
  <span class="hljs-keyword">rpc</span><span class="hljs-function"> DeleteVolume (DeleteVolumeRequest)</span>
<span class="hljs-function">    </span><span class="hljs-keyword">returns</span><span class="hljs-function"> (DeleteVolumeResponse) </span>{}
  <span class="hljs-keyword">rpc</span><span class="hljs-function"> ControllerPublishVolume (ControllerPublishVolumeRequest)</span>
<span class="hljs-function">    </span><span class="hljs-keyword">returns</span><span class="hljs-function"> (ControllerPublishVolumeResponse) </span>{}
  <span class="hljs-keyword">rpc</span><span class="hljs-function"> ControllerUnpublishVolume (ControllerUnpublishVolumeRequest)</span>
<span class="hljs-function">    </span><span class="hljs-keyword">returns</span><span class="hljs-function"> (ControllerUnpublishVolumeResponse) </span>{}
  <span class="hljs-keyword">rpc</span><span class="hljs-function"> ValidateVolumeCapabilities (ValidateVolumeCapabilitiesRequest)</span>
<span class="hljs-function">    </span><span class="hljs-keyword">returns</span><span class="hljs-function"> (ValidateVolumeCapabilitiesResponse) </span>{}
  <span class="hljs-keyword">rpc</span><span class="hljs-function"> ListVolumes (ListVolumesRequest)</span>
<span class="hljs-function">    </span><span class="hljs-keyword">returns</span><span class="hljs-function"> (ListVolumesResponse) </span>{}
  <span class="hljs-keyword">rpc</span><span class="hljs-function"> GetCapacity (GetCapacityRequest)</span>
<span class="hljs-function">    </span><span class="hljs-keyword">returns</span><span class="hljs-function"> (GetCapacityResponse) </span>{}
  <span class="hljs-keyword">rpc</span><span class="hljs-function"> ControllerGetCapabilities (ControllerGetCapabilitiesRequest)</span>
<span class="hljs-function">    </span><span class="hljs-keyword">returns</span><span class="hljs-function"> (ControllerGetCapabilitiesResponse) </span>{}  
}
</code></pre>
    <p class="normal">This is not a trivial undertaking and typically only storage solution providers should implement CSI plugins.</p>
    <p class="normal">The additional extension points of custom metrics and custom storage solutions demonstrate the commitment of Kubernetes to being truly extensible and allowing its users to customize almost every aspect of its operation. </p>
    <h1 id="_idParaDest-739" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we covered three major topics: working with the Kubernetes API, extending the Kubernetes API, and writing Kubernetes plugins. The Kubernetes API supports the OpenAPI spec and is a great example of REST API design that follows all current best practices. It is very consistent, well organized, and well documented. Yet it is a big API and not easy to understand. You can access the API directly via REST over HTTP, using client libraries including the official Python client, and even by invoking kubectl programmatically.</p>
    <p class="normal">Extending the Kubernetes API may involve defining your own custom resources, writing controllers/operators, and optionally extending the API server itself via API aggregation.</p>
    <p class="normal">Plugins and webhooks are a foundation of Kubernetes design. Kubernetes was always meant to be extended by users to accommodate any needs. We looked at various plugins, such as custom schedulers, kubectl plugins, and access control webhooks. It is very cool that Kubernetes provides such a seamless experience for writing, registering, and integrating all those plugins.</p>
    <p class="normal">We also looked at custom metrics and even how to extend Kubernetes with custom storage options.</p>
    <p class="normal">At this point, you should be well aware of all the major mechanisms to extend, customize, and control Kubernetes via API access, custom resources, controllers, operators, and custom plugins. You are in a great position to take advantage of these capabilities to augment the existing functionality of Kubernetes and adapt it to your needs and your systems.</p>
    <p class="normal">In the next chapter, we will look at governing Kubernetes via policy engines. This will continue the theme of extending Kubernetes as policy engines are dynamic admission controllers on steroids. We will cover what governance is all about, review existing policy engines, and dive deep into Kyverno, which is the best policy engine for Kubernetes in my opinion.</p>
  </div>
</body></html>