- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: GitOps for Infrastructure Automation – Terraform and Flux CD
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitOps与基础设施自动化 – Terraform和Flux CD
- en: In this chapter, we explore the powerful synergy between Terraform and Flux
    CD, two pivotal tools that epitomize the principles of GitOps and **Infrastructure
    as Code** (**IaC**). As cloud architectures become increasingly complex and dynamic,
    the need for sophisticated, automated tooling to manage these environments has
    become critical. Terraform allows users to define and provision cloud infrastructure
    using a high-level configuration language, creating a blueprint of resources that
    can be versioned and reused. Complementing this, Flux CD automates the deployment
    of applications and infrastructure changes by continuously syncing them from Git
    repositories to Kubernetes clusters. This integration not only simplifies the
    management of cloud resources but also ensures consistency and reliability across
    various stages of the deployment pipeline. Through detailed discussions, practical
    examples, and expert insights, this chapter will equip you with the knowledge
    to harness the combined power of Terraform and Flux CD, enabling you to automate
    your infrastructure efficiently and predictably in a cloud-native world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨Terraform和Flux CD之间强大的协同效应，这两个关键工具体现了GitOps和**基础设施即代码**（**IaC**）的原则。随着云架构日益复杂和动态化，需要先进的自动化工具来管理这些环境变得尤为关键。Terraform允许用户使用高级配置语言定义和提供云基础设施，创建一个可版本化和重用的资源蓝图。与之互补，Flux
    CD通过持续同步Git仓库中的应用程序和基础设施变更到Kubernetes集群来实现自动化部署。这种集成不仅简化了云资源的管理，还确保了部署流水线各个阶段的一致性和可靠性。通过详细的讨论、实用的示例和专家见解，本章将帮助你掌握Terraform和Flux
    CD的组合力量，让你能够在云原生世界中高效、可预测地自动化你的基础设施。
- en: 'In this chapter, we will delve into the following key areas:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将深入探讨以下关键内容：
- en: Introducing infrastructure automation with Terraform and Flux CD
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform和Flux CD引入基础设施自动化
- en: Setting up Terraform in a GitOps workflow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GitOps工作流中设置Terraform
- en: Exploring Flux CD – enabling **continuous deployment** (**CD**) in Kubernetes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Flux CD – 在Kubernetes中启用**持续部署**（**CD**）
- en: Combining Terraform and Flux CD for enhanced automation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合Terraform和Flux CD实现更强的自动化
- en: Version control and automation with Terraform and Flux CD
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform和Flux CD进行版本控制和自动化
- en: Multi-environment management with Terraform and Flux CD
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform和Flux CD进行多环境管理
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before diving into the integration of Terraform and Flux CD for GitOps workflows,
    it is essential to have a firm grasp of the foundational concepts discussed in
    earlier chapters of this book. Understanding the fundamentals of IaC, key Kubernetes
    concepts, and `Chapter10` folder of our dedicated GitHub repository: [https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes](https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解Terraform和Flux CD在GitOps工作流中的集成之前，务必牢固掌握本书前几章中讨论的基础概念。理解IaC的基本原理、Kubernetes的关键概念，以及我们专门的GitHub仓库中的`Chapter10`文件夹：[https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes](https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes)。
- en: Introducing infrastructure automation with Terraform and Flux CD
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Terraform和Flux CD引入基础设施自动化
- en: In today’s rapidly evolving cloud computing landscape, the demand for agility,
    scalability, and reliability in managing infrastructure is paramount. Traditional
    manual approaches are no longer sufficient for modern applications. Enter IaC
    and GitOps, reshaping infrastructure management in cloud-native environments.
    Manual work remains crucial for platform engineers, such as understanding cloud
    resources to write effective Terraform scripts, and is often the first step before
    updating the Terraform Git repository. Leverage the GitOps framework to address
    cloud-native delivery challenges such as preventing configuration drifts and ensuring
    secure, error-free deployments. Implementing GitOps on Kubernetes introduces challenges,
    including managing complex configurations and maintaining synchronization between
    the Git repository and clusters. IaC is a methodology that treats infrastructure
    provisioning, configuration, and management as code. In essence, it enables developers
    and operations teams to define infrastructure resources—such as **virtual machines**
    (**VMs**), networks, and storage—using declarative or imperative code. We have
    already explored the concept of IaC in the previous chapter, where we utilized
    Terraform scripts to provision necessary resources in Azure and AWS.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: This code is version-controlled, allowing for reproducible, consistent, and
    automated deployments. By codifying infrastructure configurations, IaC streamlines
    the deployment process, reduces human error, and enhances collaboration between
    development and operations teams.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: GitOps, on the other hand, extends the principles of IaC to the realm of continuous
    delivery and deployment. Changes to the infrastructure are made via Git commits,
    enabling versioning, auditability, and collaboration. GitOps promotes a declarative
    approach to infrastructure management, where desired state configurations stored
    in Git repositories are automatically reconciled with the actual state of the
    infrastructure. This reconciliation is typically facilitated by specialized tools
    such as Flux CD.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Building on the foundational principles of IaC and GitOps introduced earlier,
    let’s consider a practical example, as shown in *Figure 10**.1*, of how companies
    can leverage Terraform and Flux CD for efficient infrastructure management.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a technology company that needs to rapidly scale its operations across
    multiple cloud environments while maintaining strict compliance and security standards.
    By using Terraform, the company can codify its infrastructure requirements into
    version-controlled configurations, which allows for quick deployment and easy
    replication of environments across AWS, Azure, or Google Cloud. With Flux CD integrated
    into this setup, any changes to the Terraform configurations in the Git repository
    automatically trigger updates within the Kubernetes clusters. This seamless integration
    ensures that the infrastructure evolves consistently with the application code,
    reducing discrepancies and potential errors. The result is a robust, scalable,
    and compliant infrastructure that can adapt swiftly to the changing needs of the
    business, all while minimizing manual oversight and intervention:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一家公司需要在多个云环境中快速扩展其业务，同时保持严格的合规性和安全标准。通过使用Terraform，公司可以将基础设施要求编码为版本控制的配置文件，这样可以在AWS、Azure或Google
    Cloud等环境中快速部署和轻松复制环境。通过将Flux CD集成到这一设置中，对Git仓库中Terraform配置的任何更改都会自动触发Kubernetes集群中的更新。这种无缝集成确保基础设施与应用程序代码一致发展，减少了差异和潜在错误。结果是一个强大、可扩展且符合合规要求的基础设施，能够迅速适应业务需求的变化，同时最大限度地减少手动监督和干预：
- en: '![Figure 10.1 – Example of a company leveraging Terraform and Flux CD for efficient
    infrastructure management](img/B22100_10_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 利用Terraform和Flux CD进行高效基础设施管理的公司示例](img/B22100_10_01.jpg)'
- en: Figure 10.1 – Example of a company leveraging Terraform and Flux CD for efficient
    infrastructure management
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 利用Terraform和Flux CD进行高效基础设施管理的公司示例
- en: In the context of modern cloud environments, where agility and scalability are
    imperative, the adoption of IaC and GitOps offers numerous benefits. Firstly,
    it enables organizations to achieve infrastructure automation, allowing for rapid
    provisioning, scaling, and modification of resources. Secondly, it enhances reproducibility
    and consistency across environments, mitigating the risk of configuration drift
    and ensuring reliability. Thirdly, it fosters collaboration and visibility, as
    infrastructure configurations are stored and version-controlled in accessible
    Git repositories. Finally, it promotes resilience and observability, with automated
    reconciliation mechanisms ensuring that the infrastructure remains in the desired
    state. We will delve deeper into the topics of IaC and GitOps in the upcoming
    sections of this chapter, using practical examples.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代云环境中，敏捷性和可扩展性至关重要，采用基础设施即代码（IaC）和GitOps提供了诸多优势。首先，它使组织能够实现基础设施自动化，快速进行资源的配置、扩展和修改。其次，它增强了不同环境间的可复制性和一致性，减少了配置漂移的风险，确保了可靠性。第三，它促进了协作和可见性，因为基础设施配置被存储并在可访问的Git仓库中进行版本控制。最后，它提升了弹性和可观察性，自动化的协调机制确保基础设施保持在期望的状态。我们将在本章的后续部分深入探讨IaC和GitOps的主题，并通过实际示例进行说明。
- en: Now, it’s time to begin configuring our environment.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始配置我们的环境了。
- en: Setting up Terraform in a GitOps workflow
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GitOps工作流中设置Terraform
- en: 'Having established the foundational concepts of IaC and GitOps, we now understand
    how the integration of Terraform and Flux CD can *transform infrastructure management*.
    With this robust groundwork in place, we will guide you through configuring Terraform
    to work seamlessly with Flux CD, setting the stage for a cohesive and automated
    infrastructure deployment process that aligns with modern cloud-native practices.
    Terraform was introduced and briefly discussed in [*Chapter 4*](B22100_04.xhtml#_idTextAnchor065)
    and further explored in the context of *Kubernetes deployments with Azure DevOps
    and AWS CodePipeline* in [*Chapter 9*](B22100_09.xhtml#_idTextAnchor176). For
    the remainder of this chapter, we will assume that the reader has a solid understanding
    of Terraform and that it is already properly set up locally. For more information
    on what Terraform is and how to install it, please visit the following link: [https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli](https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli).
    To check that Terraform is correctly installed, in a new terminal, type the following
    command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding command should be similar to this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In our example of setting up Terraform within a GitOps workflow, we’ll use Flux
    to monitor changes in a Git repository containing Terraform scripts. Flux will
    then apply these changes to manage Azure cloud resources, specifically targeting
    a designated resource group, a virtual network, and a subnet.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'To successfully implement this setup, you must meet the following prerequisites:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '`minikube` installed locally. Alternatively, you could choose a managed cluster
    environment such as **Azure Kubernetes Service** (**AKS**) or **Amazon Elastic
    Kubernetes** **Service** (**EKS**).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Helm and kubectl**: Ensure both tools are installed and configured correctly.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub account**: While this example uses GitHub, Flux bootstrap supports
    other repositories as well. For additional details, refer to the Flux documentation
    at [https://fluxcd.io/flux/installation/#bootstrap-providers](https://fluxcd.io/flux/installation/#bootstrap-providers).'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub personal access token (PAT)**: This is necessary for private repositories
    or for operations that require authentication. More information about PATs is
    available at [https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An Azure account**: You may also use an Azure account, based on your preference
    (please note that the examples in this and the upcoming sections are specifically
    designed for Azure).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before delving deeper into the setup of the workflow, the next section will
    discuss what Tofu Controller is and why it is the engine and core of the reconciliation
    process.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Tofu Controller (formerly Weave TF-Controller)
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Tofu Controller** (refer to https://github.com/flux-iac/tofu-controller),
    formerly known as **Weave TF-Controller**, serves as a pivotal element within
    the Flux ecosystem, enabling the reconciliation of **OpenTofu** and Terraform
    resources in a GitOps manner.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: OpenTofu
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenTofu, formerly known as OpenTF, is an open source, community-driven fork
    of Terraform managed by the Linux Foundation. Designed to enhance the management
    of IaC within cloud-native environments, OpenTofu seamlessly integrates with existing
    GitOps workflows, enabling users to declaratively manage their infrastructure
    using tools such as Terraform. Both OpenTofu and Terraform use declarative **HashiCorp
    Configuration Language** (**HCL**) syntax for provisioning infrastructure but
    differ in their licensing: Terraform now operates under a **Business Source License**
    (**BSL**), while OpenTofu is released under the open source **Mozilla Public License**
    (**MPL**). OpenTofu’s primary goal is to bridge the gap between complex infrastructure
    setups and the scalable, automated management capabilities required by modern
    cloud environments. By leveraging OpenTofu, organizations can efficiently apply
    GitOps principles to their infrastructure, ensuring consistency, reliability,
    and swift deployment of cloud resources.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: With Tofu Controller, organizations can adopt GitOps practices for their infrastructure
    at a pace that suits their operational needs and readiness—meaning that there
    is no requirement to convert all resources to GitOps immediately.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Flexibility and pace emphasizing the **at-your-own-pace** approach, Tofu Controller
    allows for incremental adoption of GitOps. This flexibility is crucial for organizations
    that may want to gradually shift their operations without the need for a full-scale
    immediate transformation. It enables teams to manage changes and adaptations more
    comfortably, ensuring that each step toward GitOps can be thoroughly planned and
    implemented.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Tofu Controller supports various GitOps models, each catering to different
    needs and stages of infrastructure management:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '**GitOps Automation Model**: This model provides a comprehensive approach to
    GitOps, encompassing everything from provisioning to enforcement. For instance,
    it could manage the entire lifecycle of an AKS/EKS cluster via GitOps, automating
    numerous underlying processes.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid GitOps Automation Model**: Ideal for environments with pre-existing
    resources, this model allows selective GitOps adoption. For example, if an organization
    already has an AKS/EKS cluster, it can choose GitOps if only certain components
    such as the node group or security group integrate new capabilities while maintaining
    existing configurations.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TFSTATE`), using GitOps principles to enforce the desired state without making
    additional changes and correcting any deviations to maintain consistency and reliability.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TFSTATE` file and allowing organizations to proactively address and manage
    these changes.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the current example and for the upcoming sections, we will utilize the **GitOps
    Automation** model previously mentioned.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the setup
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have introduced the main topics and outlined the necessary requirements,
    we have reached the hands-on part of the workflow setup. To complete the first
    part of this setup, we need to complete the following numbered steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '`minikube` cluster dedicated to Flux setup, in a new terminal, type the following
    command:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After a few minutes, the output should be like the following:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This indicates that your cluster is ready to be used.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Install the** **Flux CLI**:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To set up the Flux CLI, type the following command:'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`flux bootstrap` GitHub command installs Flux controllers on a Kubernetes cluster,
    enabling synchronization with a GitHub repository. This setup involves committing
    Flux manifests to the repository and configuring Flux for self-updates from Git.
    Once executed, all operations on the cluster, including Flux updates, can be managed
    via `git push`, removing the need for direct cluster interaction. To interact
    with the GitHub API, the command requires a GitHub PAT with administrative permissions,
    which can be set as an environment variable:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, you can run the bootstrap for a repository on your personal GitHub account
    by entering the following command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The execution of the command should take a few minutes, and a successful output
    should look like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By running the following `kubectl` command, you should notice that a `flux-system`
    namespace has been created:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Install the TF-Controller**: Now, we are ready to install the TF-Controller
    previously mentioned:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enter the following command:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we are ready to install the previously mentioned Tofu Controller. Enter
    the following command:'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Contributor` role. To do this, type the following commands:'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output contains sensitive credentials that you must protect. Ensure that
    you do not include these credentials in your code or check them into your source
    control. For more information on managing Azure SPs, visit [https://aka.ms/azadsp-cli](https://aka.ms/azadsp-cli):'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The values correspond to the Terraform variables as follows: `appId` serves
    as the `client_id` variable, `password` is used as the `client_secret` variable,
    and `tenant` is the `tenant_id` variable as defined previously.'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`github-repository-secret.yaml` file located in the definitions folder of the
    chapter’s repository. The content of the file is as follows:'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The username and password need to be `base64` encoded. To encode these using
    the command line, you can use the following command: `echo -n ''your-string''
    | base64`. After encoding, apply the secret using `kubectl` in the usual manner:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we need to create a Kubernetes secret for the Azure credentials of the
    SP we previously created. Use the following command to do so:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To verify the creation of the secret, use the following command:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Kubernetes Secret
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes Secret is a resource used in Kubernetes to hold a small amount
    of sensitive data such as passwords, tokens, or keys. This data is stored in `base64`-encoded
    format and can be used by pods to handle operations that require confidentiality
    and security, helping to prevent sensitive information from being exposed in your
    application code or logs. The term *opaque* in the context of Kubernetes Secrets
    refers to the default type of Secret. It is used when the specific type of Secret
    (such as a service account token or Docker configuration) doesn’t need to be indicated.
    Essentially, *opaque* indicates that the content of the Secret is arbitrary and
    not structured to represent any specific type of confidential data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to link the GitHub repository with the GitHub repository secret
    using the `github-repository-definition.yaml` file located in the definitions
    folder (the `flux-gitops-definitions` folder defined in the repository accompanying
    this chapter). Apply it using the usual command:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Docker image for the TF-Controller**: Now, we need to create a custom Docker
    image to run the TF-Controller. The Dockerfile definition is contained in the
    Docker directory. For Docker commands, please refer to *Publishing the image to
    a container registry* section in [*Chapter 2*](B22100_02.xhtml#_idTextAnchor027).
    To build a custom Docker image, use the following command:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, you need to publish it in a repository reachable from your Kubernetes
    cluster. To push the command, after logging in to Docker, use the following command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At this point, we can commit and push the code to the GitHub repository, concluding
    the first part of our journey of setting up Terraform within our GitOps workflow.
    The next stop on our journey, which will be described in the upcoming sections,
    focuses on enabling CD in Kubernetes with Flux.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Flux CD – enabling CD in Kubernetes
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flux CD automates the application of configurations and updates to a Kubernetes
    cluster based on changes pushed to a Git repository. This approach not only ensures
    consistency across environments but also enhances security and auditability by
    maintaining a clear, version-controlled history of all deployments. Flux continuously
    monitors a designated Git repository for changes to Kubernetes manifests, Helm
    charts, or configuration files. When a change is detected, Flux automatically
    applies these updates to the corresponding Kubernetes cluster. This automation
    is comprehensive, extending not only to applications but also to the Kubernetes
    infrastructure itself, enabling entire environments to be managed as code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Key features of Flux CD include the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated synchronization**: Flux regularly checks the Git repository for
    changes and synchronizes the state of the cluster accordingly'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutable deployments**: By treating infrastructure as immutable, Flux discourages
    manual interventions and promotes reproducibility'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and compliance**: Changes are pulled from Git, ensuring that only
    approved changes are deployed, thereby enhancing security and compliance'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性与合规性**：更改从Git中拉取，确保仅部署批准的更改，从而增强了安全性和合规性。'
- en: It’s time to return to our journey, which we paused at the end of the previous
    section. Now, we need to configure the Flux instance to track its respective directory
    or branch in the Git repository. This is where the beauty of the Terraform Controller
    comes into play—it does all the hard work for you.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候回到我们在上一部分暂停的旅程了。我们需要配置Flux实例，以跟踪Git仓库中相应的目录或分支。此时，Terraform Controller的强大之处便显现出来——它为你完成了所有繁重的工作。
- en: 'We need to create a YAML file (refer to the `azvnet-gitops-automation.yaml`
    file defined in the repository for this chapter) like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个YAML文件（参考本章中仓库中定义的`azvnet-gitops-automation.yaml`文件），如下所示：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This YAML file defines a `Terraform` resource for use within the Flux CD framework,
    specifically designed to manage IaC deployments automatically. The configuration
    details the API version and specifies that the resource type is `Terraform`, indicating
    its role in managing and applying Terraform configurations through Flux.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个YAML文件定义了一个`Terraform`资源，供Flux CD框架内使用，专门设计用于自动管理IaC（基础设施即代码）部署。配置详细说明了API版本，并指定资源类型为`Terraform`，这表明它在通过Flux管理和应用Terraform配置中的作用。
- en: 'The resource is named `gitops-terraform-automation` and is located within the
    `flux-system` namespace, which is typically designated for Flux CD operations.
    The specifications include an interval setting of 1 minute, indicating how frequently
    Flux checks the Git repository for changes in the designated directory. It is
    configured to automatically approve and apply changes (`approvePlan: auto`) and
    to destroy all managed resources if this Terraform configuration is deleted from
    Kubernetes (`destroyResourcesOnDeletion: true`). The `./iac/azure/vnet` path specifies
    where in the Git repository the Terraform configurations are located, which Flux
    will monitor.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '该资源命名为`gitops-terraform-automation`，位于`flux-system`命名空间中，该命名空间通常用于Flux CD操作。规格包括1分钟的间隔设置，指示Flux检查Git仓库中指定目录的变更频率。它被配置为自动批准并应用更改（`approvePlan:
    auto`），并且如果此Terraform配置从Kubernetes中删除，则销毁所有受管理的资源（`destroyResourcesOnDeletion:
    true`）。`./iac/azure/vnet`路径指定了Git仓库中Terraform配置的位置，Flux将监控该路径。'
- en: The `sourceRef` instance points to a Git repository named `flux-system`, identifying
    the specific repository Flux should monitor. This setup allows Flux to automatically
    manage updates and maintain the environment as specified in the repository.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`sourceRef`实例指向名为`flux-system`的Git仓库，标识出Flux应当监控的具体仓库。此设置使Flux能够自动管理更新，并保持仓库中指定的环境。'
- en: The `runnerPodTemplate` section configures the environment variables for the
    pod that executes the Terraform commands, securing access to Azure services. Variables
    such as `ARM_SUBSCRIPTION_ID`, `ARM_CLIENT_ID`, `ARM_CLIENT_SECRET`, and `ARM_TENANT_ID`
    are essential for Azure interactions and are pulled securely from a Kubernetes
    secret named `azure-creds`. This ensures that sensitive credentials are managed
    securely and only made available to the necessary processes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`runnerPodTemplate`部分配置了执行Terraform命令的Pod的环境变量，以确保能够安全访问Azure服务。`ARM_SUBSCRIPTION_ID`、`ARM_CLIENT_ID`、`ARM_CLIENT_SECRET`和`ARM_TENANT_ID`等变量对于Azure的交互至关重要，它们从一个名为`azure-creds`的Kubernetes机密中安全提取。这确保了敏感凭证得到了安全管理，并且只对必要的进程可用。'
- en: By leveraging this configuration, Flux CD automates the deployment and management
    of Azure virtual networks defined in the Terraform configurations at the specified
    path in the repository. The automation encompasses monitoring for changes, applying
    updates, and ensuring the environment remains consistent with the declared state
    in the repository. This setup epitomizes the principles of GitOps by using Git
    as a **single** **source of truth** (**SSOT**) and automating the reconciliation
    process between the desired state defined in Git and the actual state of the infrastructure
    in Azure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用此配置，Flux CD自动化部署和管理在仓库中指定路径的Terraform配置所定义的Azure虚拟网络。自动化包括监控更改、应用更新，并确保环境保持与仓库中声明的状态一致。此设置体现了GitOps的原则，通过使用Git作为**单一****真实来源**（**SSOT**），并自动化Git中定义的期望状态与Azure中基础设施的实际状态之间的对账过程。
- en: 'To make the magic happen and bring the configuration to life, we need to apply
    it using `kubectl`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一魔法并使配置生效，我们需要使用`kubectl`来应用它：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: $ kubectl get terraforms.infra.contrib.fluxcd.io -n flux-system  -w
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: NAME        READY     STATUS                       AGE
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter… Unknown   Reconciliation in progress   9s
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter… Unknown   Initializing                 15s
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter… Unknown   Terraform Planning           22s
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter… Unknown   Plan generated               30s
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter… Unknown   Applying                     30s
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter… Unknown   Applying                     30s
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'gitops-ter… Unknown   Applied successfully: main@sha1:2eeaefba687fbd3d4caea404fc332ee7c5d8b144   43s'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'gitops-ter… True      Applied successfully: main@sha1:2eeaefba687fbd3d4caea404fc332ee7c5d8b144   44s'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: resource "azurerm_subnet" "azure_bastion_subnet" {
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: name                 = «AzureBastionSubnet"
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: resource_group_name  = azurerm_resource_group.gitops_terraform_rg.name
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: virtual_network_name = azurerm_virtual_network.gitops_terraform_vnet.name
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: address_prefixes     = [«10.0.1.0/26"]
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: gitops-ter…   Unknown   Reconciliation in progress    3h12m
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter…   Unknown   Initializing                3h12m
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter…   Unknown   Terraform Planning            3h12m
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter…   Unknown   Plan generated                3h12m
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter…   Unknown   Applying                    3h12m
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'gitops-ter…   Unknown   Applied successfully: main@sha1:a3b32ed48dda027b0c5e40a65c7be56e1cc7dd50       3h13m'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'gitops-ter…   True      Applied successfully: main@sha1:a3b32ed48dda027b0c5e40a65c7be56e1cc7dd50       3h13m'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|---clusters/mgmt'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '|---flux-gitops-definitions'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '|---multi-env'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '|---iac'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '|---azure'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '|---base'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '|---dev'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '|---staging'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '|---prod'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'GITHUB_TOKEN. This can be done by entering the following command in your terminal:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: flux bootstrap github \
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --token-auth \
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --context=mgmt-cluster \
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --owner=[GITHUB_ACCOUNT] \
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --repository=[GITHUB_REPOSITORY] \
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --branch=develop \
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --path=clusters/mgmt \
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --personal
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ► connecting to github.com
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ► cloning branch "develop" from Git repository "https://github.com/...
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ✔ cloned repository
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ► generating component manifests
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '✔ kustomize-controller: deployment ready'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '✔ notification-controller: deployment ready'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '✔ source-controller: deployment ready'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ✔ all components are healthy
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'flux-system namespace or a specific namespace designated for it:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: $ kubectl create secret generic azure-creds \
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --from-literal=ARM_SUBSCRIPTION_ID='SP_SUB_ID' \
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --from-literal=ARM_TENANT_ID='SP_TENANT_ID' \
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --from-literal=ARM_CLIENT_ID='SP_APPID' \
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --from-literal=ARM_CLIENT_SECRET='SP_PASSWORD' \
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'main.tf file in each environment-specific subdirectory (dev, staging, prod)
    within the multi-env/iac/azure main directory. Here’s how to structure the main.tf
    file for each environment:'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: $ kubectl apply -f github-repository-secret.yaml
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: $ kubectl apply -f github-repository-definition.yaml
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: $ kubectl apply -f dev-iac-automation.yaml
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ kubectl apply -f staging-iac-automation.yaml
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ kubectl apply -f prod-iac-automation.yaml
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: $ kubectl get terraforms.infra.contrib.fluxcd.io -n flux-system  -w
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: NAME                          READY   STATUS                                                            AGE
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'dev-cluster-tf-automation       True    No drift: develop@sha1:c93...   3m48s'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'prod-cluster-tf-automation      True    No drift: develop@sha1:c93...   3m31s'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'staging-cluster-tf-automation   True    No drift: develop@sha1:c93...   3m37s'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: dev-cluster-tf-automation       Unknown   Reconciliation in progress                                        3m48s
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: staging-cluster-tf-automation   Unknown   Reconciliation in progress                                        3m38s
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: prod-cluster-tf-automation      Unknown   Reconciliation in progress                                        3m33s
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: variable "environment" {
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: default     = "dev"
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variable "location" {
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variable "rg" {
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: default     = «gitops-dev-rg"
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: $ kubectl get terraforms.infra.contrib.fluxcd.io -n flux-system  -w
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
