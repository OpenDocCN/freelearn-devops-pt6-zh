- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitOps for Infrastructure Automation – Terraform and Flux CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explore the powerful synergy between Terraform and Flux
    CD, two pivotal tools that epitomize the principles of GitOps and **Infrastructure
    as Code** (**IaC**). As cloud architectures become increasingly complex and dynamic,
    the need for sophisticated, automated tooling to manage these environments has
    become critical. Terraform allows users to define and provision cloud infrastructure
    using a high-level configuration language, creating a blueprint of resources that
    can be versioned and reused. Complementing this, Flux CD automates the deployment
    of applications and infrastructure changes by continuously syncing them from Git
    repositories to Kubernetes clusters. This integration not only simplifies the
    management of cloud resources but also ensures consistency and reliability across
    various stages of the deployment pipeline. Through detailed discussions, practical
    examples, and expert insights, this chapter will equip you with the knowledge
    to harness the combined power of Terraform and Flux CD, enabling you to automate
    your infrastructure efficiently and predictably in a cloud-native world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will delve into the following key areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing infrastructure automation with Terraform and Flux CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Terraform in a GitOps workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Flux CD – enabling **continuous deployment** (**CD**) in Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining Terraform and Flux CD for enhanced automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version control and automation with Terraform and Flux CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-environment management with Terraform and Flux CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into the integration of Terraform and Flux CD for GitOps workflows,
    it is essential to have a firm grasp of the foundational concepts discussed in
    earlier chapters of this book. Understanding the fundamentals of IaC, key Kubernetes
    concepts, and `Chapter10` folder of our dedicated GitHub repository: [https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes](https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing infrastructure automation with Terraform and Flux CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today’s rapidly evolving cloud computing landscape, the demand for agility,
    scalability, and reliability in managing infrastructure is paramount. Traditional
    manual approaches are no longer sufficient for modern applications. Enter IaC
    and GitOps, reshaping infrastructure management in cloud-native environments.
    Manual work remains crucial for platform engineers, such as understanding cloud
    resources to write effective Terraform scripts, and is often the first step before
    updating the Terraform Git repository. Leverage the GitOps framework to address
    cloud-native delivery challenges such as preventing configuration drifts and ensuring
    secure, error-free deployments. Implementing GitOps on Kubernetes introduces challenges,
    including managing complex configurations and maintaining synchronization between
    the Git repository and clusters. IaC is a methodology that treats infrastructure
    provisioning, configuration, and management as code. In essence, it enables developers
    and operations teams to define infrastructure resources—such as **virtual machines**
    (**VMs**), networks, and storage—using declarative or imperative code. We have
    already explored the concept of IaC in the previous chapter, where we utilized
    Terraform scripts to provision necessary resources in Azure and AWS.
  prefs: []
  type: TYPE_NORMAL
- en: This code is version-controlled, allowing for reproducible, consistent, and
    automated deployments. By codifying infrastructure configurations, IaC streamlines
    the deployment process, reduces human error, and enhances collaboration between
    development and operations teams.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps, on the other hand, extends the principles of IaC to the realm of continuous
    delivery and deployment. Changes to the infrastructure are made via Git commits,
    enabling versioning, auditability, and collaboration. GitOps promotes a declarative
    approach to infrastructure management, where desired state configurations stored
    in Git repositories are automatically reconciled with the actual state of the
    infrastructure. This reconciliation is typically facilitated by specialized tools
    such as Flux CD.
  prefs: []
  type: TYPE_NORMAL
- en: Building on the foundational principles of IaC and GitOps introduced earlier,
    let’s consider a practical example, as shown in *Figure 10**.1*, of how companies
    can leverage Terraform and Flux CD for efficient infrastructure management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a technology company that needs to rapidly scale its operations across
    multiple cloud environments while maintaining strict compliance and security standards.
    By using Terraform, the company can codify its infrastructure requirements into
    version-controlled configurations, which allows for quick deployment and easy
    replication of environments across AWS, Azure, or Google Cloud. With Flux CD integrated
    into this setup, any changes to the Terraform configurations in the Git repository
    automatically trigger updates within the Kubernetes clusters. This seamless integration
    ensures that the infrastructure evolves consistently with the application code,
    reducing discrepancies and potential errors. The result is a robust, scalable,
    and compliant infrastructure that can adapt swiftly to the changing needs of the
    business, all while minimizing manual oversight and intervention:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Example of a company leveraging Terraform and Flux CD for efficient
    infrastructure management](img/B22100_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Example of a company leveraging Terraform and Flux CD for efficient
    infrastructure management
  prefs: []
  type: TYPE_NORMAL
- en: In the context of modern cloud environments, where agility and scalability are
    imperative, the adoption of IaC and GitOps offers numerous benefits. Firstly,
    it enables organizations to achieve infrastructure automation, allowing for rapid
    provisioning, scaling, and modification of resources. Secondly, it enhances reproducibility
    and consistency across environments, mitigating the risk of configuration drift
    and ensuring reliability. Thirdly, it fosters collaboration and visibility, as
    infrastructure configurations are stored and version-controlled in accessible
    Git repositories. Finally, it promotes resilience and observability, with automated
    reconciliation mechanisms ensuring that the infrastructure remains in the desired
    state. We will delve deeper into the topics of IaC and GitOps in the upcoming
    sections of this chapter, using practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to begin configuring our environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Terraform in a GitOps workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having established the foundational concepts of IaC and GitOps, we now understand
    how the integration of Terraform and Flux CD can *transform infrastructure management*.
    With this robust groundwork in place, we will guide you through configuring Terraform
    to work seamlessly with Flux CD, setting the stage for a cohesive and automated
    infrastructure deployment process that aligns with modern cloud-native practices.
    Terraform was introduced and briefly discussed in [*Chapter 4*](B22100_04.xhtml#_idTextAnchor065)
    and further explored in the context of *Kubernetes deployments with Azure DevOps
    and AWS CodePipeline* in [*Chapter 9*](B22100_09.xhtml#_idTextAnchor176). For
    the remainder of this chapter, we will assume that the reader has a solid understanding
    of Terraform and that it is already properly set up locally. For more information
    on what Terraform is and how to install it, please visit the following link: [https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli](https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli).
    To check that Terraform is correctly installed, in a new terminal, type the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command should be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In our example of setting up Terraform within a GitOps workflow, we’ll use Flux
    to monitor changes in a Git repository containing Terraform scripts. Flux will
    then apply these changes to manage Azure cloud resources, specifically targeting
    a designated resource group, a virtual network, and a subnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To successfully implement this setup, you must meet the following prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: '`minikube` installed locally. Alternatively, you could choose a managed cluster
    environment such as **Azure Kubernetes Service** (**AKS**) or **Amazon Elastic
    Kubernetes** **Service** (**EKS**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Helm and kubectl**: Ensure both tools are installed and configured correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub account**: While this example uses GitHub, Flux bootstrap supports
    other repositories as well. For additional details, refer to the Flux documentation
    at [https://fluxcd.io/flux/installation/#bootstrap-providers](https://fluxcd.io/flux/installation/#bootstrap-providers).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub personal access token (PAT)**: This is necessary for private repositories
    or for operations that require authentication. More information about PATs is
    available at [https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An Azure account**: You may also use an Azure account, based on your preference
    (please note that the examples in this and the upcoming sections are specifically
    designed for Azure).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before delving deeper into the setup of the workflow, the next section will
    discuss what Tofu Controller is and why it is the engine and core of the reconciliation
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Tofu Controller (formerly Weave TF-Controller)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Tofu Controller** (refer to https://github.com/flux-iac/tofu-controller),
    formerly known as **Weave TF-Controller**, serves as a pivotal element within
    the Flux ecosystem, enabling the reconciliation of **OpenTofu** and Terraform
    resources in a GitOps manner.'
  prefs: []
  type: TYPE_NORMAL
- en: OpenTofu
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenTofu, formerly known as OpenTF, is an open source, community-driven fork
    of Terraform managed by the Linux Foundation. Designed to enhance the management
    of IaC within cloud-native environments, OpenTofu seamlessly integrates with existing
    GitOps workflows, enabling users to declaratively manage their infrastructure
    using tools such as Terraform. Both OpenTofu and Terraform use declarative **HashiCorp
    Configuration Language** (**HCL**) syntax for provisioning infrastructure but
    differ in their licensing: Terraform now operates under a **Business Source License**
    (**BSL**), while OpenTofu is released under the open source **Mozilla Public License**
    (**MPL**). OpenTofu’s primary goal is to bridge the gap between complex infrastructure
    setups and the scalable, automated management capabilities required by modern
    cloud environments. By leveraging OpenTofu, organizations can efficiently apply
    GitOps principles to their infrastructure, ensuring consistency, reliability,
    and swift deployment of cloud resources.'
  prefs: []
  type: TYPE_NORMAL
- en: With Tofu Controller, organizations can adopt GitOps practices for their infrastructure
    at a pace that suits their operational needs and readiness—meaning that there
    is no requirement to convert all resources to GitOps immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Flexibility and pace emphasizing the **at-your-own-pace** approach, Tofu Controller
    allows for incremental adoption of GitOps. This flexibility is crucial for organizations
    that may want to gradually shift their operations without the need for a full-scale
    immediate transformation. It enables teams to manage changes and adaptations more
    comfortably, ensuring that each step toward GitOps can be thoroughly planned and
    implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tofu Controller supports various GitOps models, each catering to different
    needs and stages of infrastructure management:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GitOps Automation Model**: This model provides a comprehensive approach to
    GitOps, encompassing everything from provisioning to enforcement. For instance,
    it could manage the entire lifecycle of an AKS/EKS cluster via GitOps, automating
    numerous underlying processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid GitOps Automation Model**: Ideal for environments with pre-existing
    resources, this model allows selective GitOps adoption. For example, if an organization
    already has an AKS/EKS cluster, it can choose GitOps if only certain components
    such as the node group or security group integrate new capabilities while maintaining
    existing configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TFSTATE`), using GitOps principles to enforce the desired state without making
    additional changes and correcting any deviations to maintain consistency and reliability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TFSTATE` file and allowing organizations to proactively address and manage
    these changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the current example and for the upcoming sections, we will utilize the **GitOps
    Automation** model previously mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have introduced the main topics and outlined the necessary requirements,
    we have reached the hands-on part of the workflow setup. To complete the first
    part of this setup, we need to complete the following numbered steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`minikube` cluster dedicated to Flux setup, in a new terminal, type the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After a few minutes, the output should be like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This indicates that your cluster is ready to be used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Install the** **Flux CLI**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To set up the Flux CLI, type the following command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`flux bootstrap` GitHub command installs Flux controllers on a Kubernetes cluster,
    enabling synchronization with a GitHub repository. This setup involves committing
    Flux manifests to the repository and configuring Flux for self-updates from Git.
    Once executed, all operations on the cluster, including Flux updates, can be managed
    via `git push`, removing the need for direct cluster interaction. To interact
    with the GitHub API, the command requires a GitHub PAT with administrative permissions,
    which can be set as an environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can run the bootstrap for a repository on your personal GitHub account
    by entering the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution of the command should take a few minutes, and a successful output
    should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'By running the following `kubectl` command, you should notice that a `flux-system`
    namespace has been created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Install the TF-Controller**: Now, we are ready to install the TF-Controller
    previously mentioned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enter the following command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are ready to install the previously mentioned Tofu Controller. Enter
    the following command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Contributor` role. To do this, type the following commands:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output contains sensitive credentials that you must protect. Ensure that
    you do not include these credentials in your code or check them into your source
    control. For more information on managing Azure SPs, visit [https://aka.ms/azadsp-cli](https://aka.ms/azadsp-cli):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The values correspond to the Terraform variables as follows: `appId` serves
    as the `client_id` variable, `password` is used as the `client_secret` variable,
    and `tenant` is the `tenant_id` variable as defined previously.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`github-repository-secret.yaml` file located in the definitions folder of the
    chapter’s repository. The content of the file is as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The username and password need to be `base64` encoded. To encode these using
    the command line, you can use the following command: `echo -n ''your-string''
    | base64`. After encoding, apply the secret using `kubectl` in the usual manner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create a Kubernetes secret for the Azure credentials of the
    SP we previously created. Use the following command to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the creation of the secret, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes Secret
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes Secret is a resource used in Kubernetes to hold a small amount
    of sensitive data such as passwords, tokens, or keys. This data is stored in `base64`-encoded
    format and can be used by pods to handle operations that require confidentiality
    and security, helping to prevent sensitive information from being exposed in your
    application code or logs. The term *opaque* in the context of Kubernetes Secrets
    refers to the default type of Secret. It is used when the specific type of Secret
    (such as a service account token or Docker configuration) doesn’t need to be indicated.
    Essentially, *opaque* indicates that the content of the Secret is arbitrary and
    not structured to represent any specific type of confidential data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to link the GitHub repository with the GitHub repository secret
    using the `github-repository-definition.yaml` file located in the definitions
    folder (the `flux-gitops-definitions` folder defined in the repository accompanying
    this chapter). Apply it using the usual command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Docker image for the TF-Controller**: Now, we need to create a custom Docker
    image to run the TF-Controller. The Dockerfile definition is contained in the
    Docker directory. For Docker commands, please refer to *Publishing the image to
    a container registry* section in [*Chapter 2*](B22100_02.xhtml#_idTextAnchor027).
    To build a custom Docker image, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you need to publish it in a repository reachable from your Kubernetes
    cluster. To push the command, after logging in to Docker, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, we can commit and push the code to the GitHub repository, concluding
    the first part of our journey of setting up Terraform within our GitOps workflow.
    The next stop on our journey, which will be described in the upcoming sections,
    focuses on enabling CD in Kubernetes with Flux.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Flux CD – enabling CD in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flux CD automates the application of configurations and updates to a Kubernetes
    cluster based on changes pushed to a Git repository. This approach not only ensures
    consistency across environments but also enhances security and auditability by
    maintaining a clear, version-controlled history of all deployments. Flux continuously
    monitors a designated Git repository for changes to Kubernetes manifests, Helm
    charts, or configuration files. When a change is detected, Flux automatically
    applies these updates to the corresponding Kubernetes cluster. This automation
    is comprehensive, extending not only to applications but also to the Kubernetes
    infrastructure itself, enabling entire environments to be managed as code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key features of Flux CD include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated synchronization**: Flux regularly checks the Git repository for
    changes and synchronizes the state of the cluster accordingly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutable deployments**: By treating infrastructure as immutable, Flux discourages
    manual interventions and promotes reproducibility'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and compliance**: Changes are pulled from Git, ensuring that only
    approved changes are deployed, thereby enhancing security and compliance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s time to return to our journey, which we paused at the end of the previous
    section. Now, we need to configure the Flux instance to track its respective directory
    or branch in the Git repository. This is where the beauty of the Terraform Controller
    comes into play—it does all the hard work for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a YAML file (refer to the `azvnet-gitops-automation.yaml`
    file defined in the repository for this chapter) like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This YAML file defines a `Terraform` resource for use within the Flux CD framework,
    specifically designed to manage IaC deployments automatically. The configuration
    details the API version and specifies that the resource type is `Terraform`, indicating
    its role in managing and applying Terraform configurations through Flux.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resource is named `gitops-terraform-automation` and is located within the
    `flux-system` namespace, which is typically designated for Flux CD operations.
    The specifications include an interval setting of 1 minute, indicating how frequently
    Flux checks the Git repository for changes in the designated directory. It is
    configured to automatically approve and apply changes (`approvePlan: auto`) and
    to destroy all managed resources if this Terraform configuration is deleted from
    Kubernetes (`destroyResourcesOnDeletion: true`). The `./iac/azure/vnet` path specifies
    where in the Git repository the Terraform configurations are located, which Flux
    will monitor.'
  prefs: []
  type: TYPE_NORMAL
- en: The `sourceRef` instance points to a Git repository named `flux-system`, identifying
    the specific repository Flux should monitor. This setup allows Flux to automatically
    manage updates and maintain the environment as specified in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: The `runnerPodTemplate` section configures the environment variables for the
    pod that executes the Terraform commands, securing access to Azure services. Variables
    such as `ARM_SUBSCRIPTION_ID`, `ARM_CLIENT_ID`, `ARM_CLIENT_SECRET`, and `ARM_TENANT_ID`
    are essential for Azure interactions and are pulled securely from a Kubernetes
    secret named `azure-creds`. This ensures that sensitive credentials are managed
    securely and only made available to the necessary processes.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging this configuration, Flux CD automates the deployment and management
    of Azure virtual networks defined in the Terraform configurations at the specified
    path in the repository. The automation encompasses monitoring for changes, applying
    updates, and ensuring the environment remains consistent with the declared state
    in the repository. This setup epitomizes the principles of GitOps by using Git
    as a **single** **source of truth** (**SSOT**) and automating the reconciliation
    process between the desired state defined in Git and the actual state of the infrastructure
    in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the magic happen and bring the configuration to life, we need to apply
    it using `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: $ kubectl get terraforms.infra.contrib.fluxcd.io -n flux-system  -w
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: NAME        READY     STATUS                       AGE
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter… Unknown   Reconciliation in progress   9s
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter… Unknown   Initializing                 15s
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter… Unknown   Terraform Planning           22s
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter… Unknown   Plan generated               30s
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter… Unknown   Applying                     30s
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter… Unknown   Applying                     30s
  prefs: []
  type: TYPE_NORMAL
- en: 'gitops-ter… Unknown   Applied successfully: main@sha1:2eeaefba687fbd3d4caea404fc332ee7c5d8b144   43s'
  prefs: []
  type: TYPE_NORMAL
- en: 'gitops-ter… True      Applied successfully: main@sha1:2eeaefba687fbd3d4caea404fc332ee7c5d8b144   44s'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: resource "azurerm_subnet" "azure_bastion_subnet" {
  prefs: []
  type: TYPE_NORMAL
- en: name                 = «AzureBastionSubnet"
  prefs: []
  type: TYPE_NORMAL
- en: resource_group_name  = azurerm_resource_group.gitops_terraform_rg.name
  prefs: []
  type: TYPE_NORMAL
- en: virtual_network_name = azurerm_virtual_network.gitops_terraform_vnet.name
  prefs: []
  type: TYPE_NORMAL
- en: address_prefixes     = [«10.0.1.0/26"]
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: gitops-ter…   Unknown   Reconciliation in progress    3h12m
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter…   Unknown   Initializing                3h12m
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter…   Unknown   Terraform Planning            3h12m
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter…   Unknown   Plan generated                3h12m
  prefs: []
  type: TYPE_NORMAL
- en: gitops-ter…   Unknown   Applying                    3h12m
  prefs: []
  type: TYPE_NORMAL
- en: 'gitops-ter…   Unknown   Applied successfully: main@sha1:a3b32ed48dda027b0c5e40a65c7be56e1cc7dd50       3h13m'
  prefs: []
  type: TYPE_NORMAL
- en: 'gitops-ter…   True      Applied successfully: main@sha1:a3b32ed48dda027b0c5e40a65c7be56e1cc7dd50       3h13m'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '|---clusters/mgmt'
  prefs: []
  type: TYPE_NORMAL
- en: '|---flux-gitops-definitions'
  prefs: []
  type: TYPE_NORMAL
- en: '|---multi-env'
  prefs: []
  type: TYPE_NORMAL
- en: '|---iac'
  prefs: []
  type: TYPE_NORMAL
- en: '|---azure'
  prefs: []
  type: TYPE_NORMAL
- en: '|---base'
  prefs: []
  type: TYPE_NORMAL
- en: '|---dev'
  prefs: []
  type: TYPE_NORMAL
- en: '|---staging'
  prefs: []
  type: TYPE_NORMAL
- en: '|---prod'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'GITHUB_TOKEN. This can be done by entering the following command in your terminal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: flux bootstrap github \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --token-auth \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --context=mgmt-cluster \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --owner=[GITHUB_ACCOUNT] \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --repository=[GITHUB_REPOSITORY] \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --branch=develop \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --path=clusters/mgmt \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --personal
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: ► connecting to github.com
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ► cloning branch "develop" from Git repository "https://github.com/...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ✔ cloned repository
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ► generating component manifests
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '✔ kustomize-controller: deployment ready'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '✔ notification-controller: deployment ready'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '✔ source-controller: deployment ready'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ✔ all components are healthy
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'flux-system namespace or a specific namespace designated for it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ kubectl create secret generic azure-creds \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --from-literal=ARM_SUBSCRIPTION_ID='SP_SUB_ID' \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --from-literal=ARM_TENANT_ID='SP_TENANT_ID' \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --from-literal=ARM_CLIENT_ID='SP_APPID' \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --from-literal=ARM_CLIENT_SECRET='SP_PASSWORD' \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'main.tf file in each environment-specific subdirectory (dev, staging, prod)
    within the multi-env/iac/azure main directory. Here’s how to structure the main.tf
    file for each environment:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ kubectl apply -f github-repository-secret.yaml
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ kubectl apply -f github-repository-definition.yaml
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ kubectl apply -f dev-iac-automation.yaml
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ kubectl apply -f staging-iac-automation.yaml
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ kubectl apply -f prod-iac-automation.yaml
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ kubectl get terraforms.infra.contrib.fluxcd.io -n flux-system  -w
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: NAME                          READY   STATUS                                                            AGE
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'dev-cluster-tf-automation       True    No drift: develop@sha1:c93...   3m48s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'prod-cluster-tf-automation      True    No drift: develop@sha1:c93...   3m31s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'staging-cluster-tf-automation   True    No drift: develop@sha1:c93...   3m37s'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: dev-cluster-tf-automation       Unknown   Reconciliation in progress                                        3m48s
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: staging-cluster-tf-automation   Unknown   Reconciliation in progress                                        3m38s
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: prod-cluster-tf-automation      Unknown   Reconciliation in progress                                        3m33s
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: variable "environment" {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: default     = "dev"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variable "location" {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variable "rg" {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: default     = «gitops-dev-rg"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ kubectl get terraforms.infra.contrib.fluxcd.io -n flux-system  -w
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
