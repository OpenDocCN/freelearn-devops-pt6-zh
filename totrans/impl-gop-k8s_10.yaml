- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: GitOps for Infrastructure Automation – Terraform and Flux CD
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitOps与基础设施自动化 – Terraform和Flux CD
- en: In this chapter, we explore the powerful synergy between Terraform and Flux
    CD, two pivotal tools that epitomize the principles of GitOps and **Infrastructure
    as Code** (**IaC**). As cloud architectures become increasingly complex and dynamic,
    the need for sophisticated, automated tooling to manage these environments has
    become critical. Terraform allows users to define and provision cloud infrastructure
    using a high-level configuration language, creating a blueprint of resources that
    can be versioned and reused. Complementing this, Flux CD automates the deployment
    of applications and infrastructure changes by continuously syncing them from Git
    repositories to Kubernetes clusters. This integration not only simplifies the
    management of cloud resources but also ensures consistency and reliability across
    various stages of the deployment pipeline. Through detailed discussions, practical
    examples, and expert insights, this chapter will equip you with the knowledge
    to harness the combined power of Terraform and Flux CD, enabling you to automate
    your infrastructure efficiently and predictably in a cloud-native world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨Terraform和Flux CD之间强大的协同效应，这两个关键工具体现了GitOps和**基础设施即代码**（**IaC**）的原则。随着云架构日益复杂和动态化，需要先进的自动化工具来管理这些环境变得尤为关键。Terraform允许用户使用高级配置语言定义和提供云基础设施，创建一个可版本化和重用的资源蓝图。与之互补，Flux
    CD通过持续同步Git仓库中的应用程序和基础设施变更到Kubernetes集群来实现自动化部署。这种集成不仅简化了云资源的管理，还确保了部署流水线各个阶段的一致性和可靠性。通过详细的讨论、实用的示例和专家见解，本章将帮助你掌握Terraform和Flux
    CD的组合力量，让你能够在云原生世界中高效、可预测地自动化你的基础设施。
- en: 'In this chapter, we will delve into the following key areas:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将深入探讨以下关键内容：
- en: Introducing infrastructure automation with Terraform and Flux CD
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform和Flux CD引入基础设施自动化
- en: Setting up Terraform in a GitOps workflow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GitOps工作流中设置Terraform
- en: Exploring Flux CD – enabling **continuous deployment** (**CD**) in Kubernetes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Flux CD – 在Kubernetes中启用**持续部署**（**CD**）
- en: Combining Terraform and Flux CD for enhanced automation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合Terraform和Flux CD实现更强的自动化
- en: Version control and automation with Terraform and Flux CD
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform和Flux CD进行版本控制和自动化
- en: Multi-environment management with Terraform and Flux CD
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform和Flux CD进行多环境管理
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before diving into the integration of Terraform and Flux CD for GitOps workflows,
    it is essential to have a firm grasp of the foundational concepts discussed in
    earlier chapters of this book. Understanding the fundamentals of IaC, key Kubernetes
    concepts, and `Chapter10` folder of our dedicated GitHub repository: [https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes](https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解Terraform和Flux CD在GitOps工作流中的集成之前，务必牢固掌握本书前几章中讨论的基础概念。理解IaC的基本原理、Kubernetes的关键概念，以及我们专门的GitHub仓库中的`Chapter10`文件夹：[https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes](https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes)。
- en: Introducing infrastructure automation with Terraform and Flux CD
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Terraform和Flux CD引入基础设施自动化
- en: In today’s rapidly evolving cloud computing landscape, the demand for agility,
    scalability, and reliability in managing infrastructure is paramount. Traditional
    manual approaches are no longer sufficient for modern applications. Enter IaC
    and GitOps, reshaping infrastructure management in cloud-native environments.
    Manual work remains crucial for platform engineers, such as understanding cloud
    resources to write effective Terraform scripts, and is often the first step before
    updating the Terraform Git repository. Leverage the GitOps framework to address
    cloud-native delivery challenges such as preventing configuration drifts and ensuring
    secure, error-free deployments. Implementing GitOps on Kubernetes introduces challenges,
    including managing complex configurations and maintaining synchronization between
    the Git repository and clusters. IaC is a methodology that treats infrastructure
    provisioning, configuration, and management as code. In essence, it enables developers
    and operations teams to define infrastructure resources—such as **virtual machines**
    (**VMs**), networks, and storage—using declarative or imperative code. We have
    already explored the concept of IaC in the previous chapter, where we utilized
    Terraform scripts to provision necessary resources in Azure and AWS.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今快速发展的云计算环境中，管理基础设施时对敏捷性、可扩展性和可靠性的需求至关重要。传统的手动方法已不足以满足现代应用的需求。此时，IaC和GitOps应运而生，重新定义了云原生环境下的基础设施管理。对于平台工程师来说，手动工作仍然至关重要，例如理解云资源以编写有效的Terraform脚本，通常也是更新Terraform
    Git仓库之前的第一步。通过利用GitOps框架，解决云原生交付中面临的挑战，比如防止配置漂移，确保安全、无误的部署。在Kubernetes上实施GitOps会带来一些挑战，包括管理复杂配置和保持Git仓库与集群之间的同步。IaC是一种将基础设施供应、配置和管理视为代码的方法。从本质上讲，它使开发人员和运维团队能够使用声明式或命令式代码来定义基础设施资源，如**虚拟机**（**VMs**）、网络和存储。我们在上一章已经探讨了IaC的概念，当时我们利用Terraform脚本在Azure和AWS上配置了必要的资源。
- en: This code is version-controlled, allowing for reproducible, consistent, and
    automated deployments. By codifying infrastructure configurations, IaC streamlines
    the deployment process, reduces human error, and enhances collaboration between
    development and operations teams.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是版本控制的，可以实现可复现、一致和自动化的部署。通过将基础设施配置编码化，基础设施即代码（IaC）简化了部署过程，减少了人为错误，并增强了开发和运维团队之间的协作。
- en: GitOps, on the other hand, extends the principles of IaC to the realm of continuous
    delivery and deployment. Changes to the infrastructure are made via Git commits,
    enabling versioning, auditability, and collaboration. GitOps promotes a declarative
    approach to infrastructure management, where desired state configurations stored
    in Git repositories are automatically reconciled with the actual state of the
    infrastructure. This reconciliation is typically facilitated by specialized tools
    such as Flux CD.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps则将IaC的原则扩展到持续交付和部署领域。基础设施的变化通过Git提交进行，实现了版本控制、审计和协作。GitOps提倡一种声明式的基础设施管理方法，其中存储在Git仓库中的期望状态配置会自动与基础设施的实际状态进行协调。这一协调过程通常由Flux
    CD等专门的工具来完成。
- en: Building on the foundational principles of IaC and GitOps introduced earlier,
    let’s consider a practical example, as shown in *Figure 10**.1*, of how companies
    can leverage Terraform and Flux CD for efficient infrastructure management.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面介绍的IaC和GitOps的基础原则之上，我们来考虑一个实际的示例，如*图10.1*所示，展示了公司如何利用Terraform和Flux CD来高效地管理基础设施。
- en: 'Imagine a technology company that needs to rapidly scale its operations across
    multiple cloud environments while maintaining strict compliance and security standards.
    By using Terraform, the company can codify its infrastructure requirements into
    version-controlled configurations, which allows for quick deployment and easy
    replication of environments across AWS, Azure, or Google Cloud. With Flux CD integrated
    into this setup, any changes to the Terraform configurations in the Git repository
    automatically trigger updates within the Kubernetes clusters. This seamless integration
    ensures that the infrastructure evolves consistently with the application code,
    reducing discrepancies and potential errors. The result is a robust, scalable,
    and compliant infrastructure that can adapt swiftly to the changing needs of the
    business, all while minimizing manual oversight and intervention:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一家公司需要在多个云环境中快速扩展其业务，同时保持严格的合规性和安全标准。通过使用Terraform，公司可以将基础设施要求编码为版本控制的配置文件，这样可以在AWS、Azure或Google
    Cloud等环境中快速部署和轻松复制环境。通过将Flux CD集成到这一设置中，对Git仓库中Terraform配置的任何更改都会自动触发Kubernetes集群中的更新。这种无缝集成确保基础设施与应用程序代码一致发展，减少了差异和潜在错误。结果是一个强大、可扩展且符合合规要求的基础设施，能够迅速适应业务需求的变化，同时最大限度地减少手动监督和干预：
- en: '![Figure 10.1 – Example of a company leveraging Terraform and Flux CD for efficient
    infrastructure management](img/B22100_10_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 利用Terraform和Flux CD进行高效基础设施管理的公司示例](img/B22100_10_01.jpg)'
- en: Figure 10.1 – Example of a company leveraging Terraform and Flux CD for efficient
    infrastructure management
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 利用Terraform和Flux CD进行高效基础设施管理的公司示例
- en: In the context of modern cloud environments, where agility and scalability are
    imperative, the adoption of IaC and GitOps offers numerous benefits. Firstly,
    it enables organizations to achieve infrastructure automation, allowing for rapid
    provisioning, scaling, and modification of resources. Secondly, it enhances reproducibility
    and consistency across environments, mitigating the risk of configuration drift
    and ensuring reliability. Thirdly, it fosters collaboration and visibility, as
    infrastructure configurations are stored and version-controlled in accessible
    Git repositories. Finally, it promotes resilience and observability, with automated
    reconciliation mechanisms ensuring that the infrastructure remains in the desired
    state. We will delve deeper into the topics of IaC and GitOps in the upcoming
    sections of this chapter, using practical examples.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代云环境中，敏捷性和可扩展性至关重要，采用基础设施即代码（IaC）和GitOps提供了诸多优势。首先，它使组织能够实现基础设施自动化，快速进行资源的配置、扩展和修改。其次，它增强了不同环境间的可复制性和一致性，减少了配置漂移的风险，确保了可靠性。第三，它促进了协作和可见性，因为基础设施配置被存储并在可访问的Git仓库中进行版本控制。最后，它提升了弹性和可观察性，自动化的协调机制确保基础设施保持在期望的状态。我们将在本章的后续部分深入探讨IaC和GitOps的主题，并通过实际示例进行说明。
- en: Now, it’s time to begin configuring our environment.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始配置我们的环境了。
- en: Setting up Terraform in a GitOps workflow
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GitOps工作流中设置Terraform
- en: 'Having established the foundational concepts of IaC and GitOps, we now understand
    how the integration of Terraform and Flux CD can *transform infrastructure management*.
    With this robust groundwork in place, we will guide you through configuring Terraform
    to work seamlessly with Flux CD, setting the stage for a cohesive and automated
    infrastructure deployment process that aligns with modern cloud-native practices.
    Terraform was introduced and briefly discussed in [*Chapter 4*](B22100_04.xhtml#_idTextAnchor065)
    and further explored in the context of *Kubernetes deployments with Azure DevOps
    and AWS CodePipeline* in [*Chapter 9*](B22100_09.xhtml#_idTextAnchor176). For
    the remainder of this chapter, we will assume that the reader has a solid understanding
    of Terraform and that it is already properly set up locally. For more information
    on what Terraform is and how to install it, please visit the following link: [https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli](https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli).
    To check that Terraform is correctly installed, in a new terminal, type the following
    command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了IaC和GitOps的基础概念后，我们现在理解了Terraform和Flux CD的集成如何*改变基础设施管理*。在这一坚实的基础上，我们将引导您配置Terraform，使其与Flux
    CD无缝配合，为符合现代云原生实践的、连贯且自动化的基础设施部署过程打下基础。Terraform在[*第4章*](B22100_04.xhtml#_idTextAnchor065)中介绍并简要讨论，并在[*第9章*](B22100_09.xhtml#_idTextAnchor176)中进一步探讨了与*使用Azure
    DevOps和AWS CodePipeline进行Kubernetes部署*的相关内容。在本章的剩余部分，我们假设读者已经对Terraform有了扎实的理解，并且它已在本地正确安装。有关Terraform是什么以及如何安装的更多信息，请访问以下链接：[https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli](https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli)。要检查Terraform是否正确安装，请在新的终端中键入以下命令：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding command should be similar to this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出应该类似于以下内容：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In our example of setting up Terraform within a GitOps workflow, we’ll use Flux
    to monitor changes in a Git repository containing Terraform scripts. Flux will
    then apply these changes to manage Azure cloud resources, specifically targeting
    a designated resource group, a virtual network, and a subnet.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置Terraform与GitOps工作流的示例中，我们将使用Flux来监视包含Terraform脚本的Git存储库中的更改。然后，Flux将应用这些更改来管理Azure云资源，具体目标是指定的资源组、虚拟网络和子网。
- en: 'To successfully implement this setup, you must meet the following prerequisites:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功实施此设置，您必须满足以下先决条件：
- en: '`minikube` installed locally. Alternatively, you could choose a managed cluster
    environment such as **Azure Kubernetes Service** (**AKS**) or **Amazon Elastic
    Kubernetes** **Service** (**EKS**).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地安装了`minikube`。另外，您也可以选择托管的集群环境，如**Azure Kubernetes Service**（**AKS**）或**Amazon
    Elastic Kubernetes** **Service**（**EKS**）。
- en: '**Helm and kubectl**: Ensure both tools are installed and configured correctly.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Helm和kubectl**：确保这两个工具已正确安装并配置。'
- en: '**GitHub account**: While this example uses GitHub, Flux bootstrap supports
    other repositories as well. For additional details, refer to the Flux documentation
    at [https://fluxcd.io/flux/installation/#bootstrap-providers](https://fluxcd.io/flux/installation/#bootstrap-providers).'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub账户**：虽然本示例使用GitHub，但Flux引导支持其他存储库。有关更多详细信息，请参阅Flux文档：[https://fluxcd.io/flux/installation/#bootstrap-providers](https://fluxcd.io/flux/installation/#bootstrap-providers)。'
- en: '**GitHub personal access token (PAT)**: This is necessary for private repositories
    or for operations that require authentication. More information about PATs is
    available at [https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub个人访问令牌（PAT）**：这对于私有存储库或需要身份验证的操作是必需的。有关PAT的更多信息，请访问[https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens)。'
- en: '**An Azure account**: You may also use an Azure account, based on your preference
    (please note that the examples in this and the upcoming sections are specifically
    designed for Azure).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个Azure账户**：您也可以根据个人喜好使用Azure账户（请注意，本节及后续部分中的示例专门为Azure设计）。'
- en: Before delving deeper into the setup of the workflow, the next section will
    discuss what Tofu Controller is and why it is the engine and core of the reconciliation
    process.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论工作流的设置之前，下一节将讨论Tofu Controller是什么，以及它为何是对账过程的引擎和核心。
- en: Tofu Controller (formerly Weave TF-Controller)
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tofu Controller（前身为Weave TF-Controller）
- en: '**Tofu Controller** (refer to https://github.com/flux-iac/tofu-controller),
    formerly known as **Weave TF-Controller**, serves as a pivotal element within
    the Flux ecosystem, enabling the reconciliation of **OpenTofu** and Terraform
    resources in a GitOps manner.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tofu Controller**（请参考 https://github.com/flux-iac/tofu-controller），前身为 **Weave
    TF-Controller**，是 Flux 生态系统中的关键元素，使得 **OpenTofu** 和 Terraform 资源能够以 GitOps 方式进行协调。'
- en: OpenTofu
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTofu
- en: 'OpenTofu, formerly known as OpenTF, is an open source, community-driven fork
    of Terraform managed by the Linux Foundation. Designed to enhance the management
    of IaC within cloud-native environments, OpenTofu seamlessly integrates with existing
    GitOps workflows, enabling users to declaratively manage their infrastructure
    using tools such as Terraform. Both OpenTofu and Terraform use declarative **HashiCorp
    Configuration Language** (**HCL**) syntax for provisioning infrastructure but
    differ in their licensing: Terraform now operates under a **Business Source License**
    (**BSL**), while OpenTofu is released under the open source **Mozilla Public License**
    (**MPL**). OpenTofu’s primary goal is to bridge the gap between complex infrastructure
    setups and the scalable, automated management capabilities required by modern
    cloud environments. By leveraging OpenTofu, organizations can efficiently apply
    GitOps principles to their infrastructure, ensuring consistency, reliability,
    and swift deployment of cloud resources.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTofu，前身为 OpenTF，是一个由 Linux 基金会管理的开源社区驱动的 Terraform 分支。OpenTofu 旨在增强云原生环境中
    IaC 的管理，能够与现有的 GitOps 工作流无缝集成，使用户能够使用如 Terraform 等工具以声明式方式管理基础设施。OpenTofu 和 Terraform
    都使用声明式的 **HashiCorp 配置语言**（**HCL**）语法来配置基础设施，但在许可上有所不同：Terraform 目前采用 **商业源代码许可证**（**BSL**），而
    OpenTofu 采用开源的 **Mozilla 公共许可证**（**MPL**）。OpenTofu 的主要目标是弥补复杂基础设施设置与现代云环境所需的可扩展、自动化管理能力之间的差距。通过利用
    OpenTofu，组织可以高效地将 GitOps 原则应用于其基础设施，确保一致性、可靠性以及快速部署云资源。
- en: With Tofu Controller, organizations can adopt GitOps practices for their infrastructure
    at a pace that suits their operational needs and readiness—meaning that there
    is no requirement to convert all resources to GitOps immediately.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Tofu Controller，组织可以根据其操作需求和准备情况，按适合的节奏采用 GitOps 实践——这意味着不需要立即将所有资源都转化为 GitOps。
- en: Flexibility and pace emphasizing the **at-your-own-pace** approach, Tofu Controller
    allows for incremental adoption of GitOps. This flexibility is crucial for organizations
    that may want to gradually shift their operations without the need for a full-scale
    immediate transformation. It enables teams to manage changes and adaptations more
    comfortably, ensuring that each step toward GitOps can be thoroughly planned and
    implemented.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 强调灵活性和节奏的 **按自己节奏** 方法，Tofu Controller 允许逐步采用 GitOps。这种灵活性对于那些可能希望逐渐转型的组织至关重要，无需进行大规模的立即转型。它使团队能够更加舒适地管理变更和适应，确保每个向
    GitOps 迈进的步骤都能经过充分规划和实施。
- en: 'Tofu Controller supports various GitOps models, each catering to different
    needs and stages of infrastructure management:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Tofu Controller 支持多种 GitOps 模式，每种模式都针对基础设施管理的不同需求和阶段：
- en: '**GitOps Automation Model**: This model provides a comprehensive approach to
    GitOps, encompassing everything from provisioning to enforcement. For instance,
    it could manage the entire lifecycle of an AKS/EKS cluster via GitOps, automating
    numerous underlying processes.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitOps 自动化模型**：该模型提供了一种全面的 GitOps 方法，涵盖了从配置到执行的各个方面。例如，它可以通过 GitOps 管理整个
    AKS/EKS 集群的生命周期，自动化许多底层过程。'
- en: '**Hybrid GitOps Automation Model**: Ideal for environments with pre-existing
    resources, this model allows selective GitOps adoption. For example, if an organization
    already has an AKS/EKS cluster, it can choose GitOps if only certain components
    such as the node group or security group integrate new capabilities while maintaining
    existing configurations.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合 GitOps 自动化模型**：适用于已有资源的环境，该模型允许选择性地采用 GitOps。例如，如果一个组织已经有 AKS/EKS 集群，它可以选择在只集成某些组件（如节点组或安全组）时使用
    GitOps，同时保持现有配置。'
- en: '`TFSTATE`), using GitOps principles to enforce the desired state without making
    additional changes and correcting any deviations to maintain consistency and reliability.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TFSTATE`），使用 GitOps 原则强制执行期望状态，而不做额外修改，并纠正任何偏差，以保持一致性和可靠性。'
- en: '`TFSTATE` file and allowing organizations to proactively address and manage
    these changes.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TFSTATE` 文件，并允许组织主动处理和管理这些变更。'
- en: For the current example and for the upcoming sections, we will utilize the **GitOps
    Automation** model previously mentioned.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于当前示例以及接下来的部分，我们将使用之前提到的 **GitOps 自动化** 模式。
- en: Getting started with the setup
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始设置
- en: 'Now that we have introduced the main topics and outlined the necessary requirements,
    we have reached the hands-on part of the workflow setup. To complete the first
    part of this setup, we need to complete the following numbered steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了主要主题并概述了必要的要求，我们已经进入了工作流设置的实际操作部分。要完成设置的第一部分，我们需要完成以下编号步骤：
- en: '`minikube` cluster dedicated to Flux setup, in a new terminal, type the following
    command:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`minikube` 集群专门用于 Flux 设置，在新的终端中，输入以下命令：'
- en: '[PRE2]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After a few minutes, the output should be like the following:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 几分钟后，输出应如下所示：
- en: '[PRE3]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This indicates that your cluster is ready to be used.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这表示您的集群已经准备好使用。
- en: '**Install the** **Flux CLI**:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安装** **Flux CLI**：'
- en: 'To set up the Flux CLI, type the following command:'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 Flux CLI，请输入以下命令：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`flux bootstrap` GitHub command installs Flux controllers on a Kubernetes cluster,
    enabling synchronization with a GitHub repository. This setup involves committing
    Flux manifests to the repository and configuring Flux for self-updates from Git.
    Once executed, all operations on the cluster, including Flux updates, can be managed
    via `git push`, removing the need for direct cluster interaction. To interact
    with the GitHub API, the command requires a GitHub PAT with administrative permissions,
    which can be set as an environment variable:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flux bootstrap` GitHub 命令会在 Kubernetes 集群上安装 Flux 控制器，使其能够与 GitHub 仓库同步。此设置涉及将
    Flux 清单提交到仓库，并配置 Flux 从 Git 自行更新。执行后，所有集群操作，包括 Flux 更新，都可以通过 `git push` 管理，免去了直接与集群交互的需求。为了与
    GitHub API 进行交互，该命令需要一个具有管理权限的 GitHub PAT，可以将其设置为环境变量：'
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, you can run the bootstrap for a repository on your personal GitHub account
    by entering the following command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以通过输入以下命令，在您个人的 GitHub 账户上运行仓库的引导程序：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The execution of the command should take a few minutes, and a successful output
    should look like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令应当需要几分钟时间，成功输出应该如下所示：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By running the following `kubectl` command, you should notice that a `flux-system`
    namespace has been created:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下 `kubectl` 命令，您应该会注意到已经创建了一个 `flux-system` 命名空间：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Install the TF-Controller**: Now, we are ready to install the TF-Controller
    previously mentioned:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装 TF-Controller**：现在，我们准备安装之前提到的 TF-Controller：'
- en: 'Enter the following command:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE9]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we are ready to install the previously mentioned Tofu Controller. Enter
    the following command:'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备安装之前提到的 Tofu Controller。输入以下命令：
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Contributor` role. To do this, type the following commands:'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contributor` 角色。为此，请键入以下命令：'
- en: '[PRE11]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output contains sensitive credentials that you must protect. Ensure that
    you do not include these credentials in your code or check them into your source
    control. For more information on managing Azure SPs, visit [https://aka.ms/azadsp-cli](https://aka.ms/azadsp-cli):'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出包含了敏感凭据，您必须保护这些凭据。确保不要将这些凭据包含在您的代码中或将其检查到源代码管理系统中。有关管理 Azure SP 的更多信息，请访问
    [https://aka.ms/azadsp-cli](https://aka.ms/azadsp-cli)：
- en: '[PRE12]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The values correspond to the Terraform variables as follows: `appId` serves
    as the `client_id` variable, `password` is used as the `client_secret` variable,
    and `tenant` is the `tenant_id` variable as defined previously.'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些值对应于 Terraform 变量，具体如下：`appId` 作为 `client_id` 变量，`password` 用作 `client_secret`
    变量，`tenant` 是之前定义的 `tenant_id` 变量。
- en: '`github-repository-secret.yaml` file located in the definitions folder of the
    chapter’s repository. The content of the file is as follows:'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`github-repository-secret.yaml` 文件位于本章仓库的定义文件夹中。文件内容如下：'
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The username and password need to be `base64` encoded. To encode these using
    the command line, you can use the following command: `echo -n ''your-string''
    | base64`. After encoding, apply the secret using `kubectl` in the usual manner:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户名和密码需要进行 `base64` 编码。要使用命令行进行编码，您可以使用以下命令：`echo -n 'your-string' | base64`。编码后，按照常规方式使用
    `kubectl` 应用该秘密：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we need to create a Kubernetes secret for the Azure credentials of the
    SP we previously created. Use the following command to do so:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为之前创建的 SP 的 Azure 凭据创建一个 Kubernetes 秘密。使用以下命令来完成此操作：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To verify the creation of the secret, use the following command:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证秘密的创建，请使用以下命令：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Kubernetes Secret
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 秘密
- en: A Kubernetes Secret is a resource used in Kubernetes to hold a small amount
    of sensitive data such as passwords, tokens, or keys. This data is stored in `base64`-encoded
    format and can be used by pods to handle operations that require confidentiality
    and security, helping to prevent sensitive information from being exposed in your
    application code or logs. The term *opaque* in the context of Kubernetes Secrets
    refers to the default type of Secret. It is used when the specific type of Secret
    (such as a service account token or Docker configuration) doesn’t need to be indicated.
    Essentially, *opaque* indicates that the content of the Secret is arbitrary and
    not structured to represent any specific type of confidential data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Secret 是 Kubernetes 中的一种资源，用于存储少量敏感数据，如密码、令牌或密钥。这些数据以 `base64` 编码格式存储，可以被
    pods 用来处理需要机密性和安全性的操作，帮助防止敏感信息在应用程序代码或日志中暴露。Kubernetes Secrets 中的 *opaque* 一词指的是默认的
    Secret 类型。当不需要指定 Secret 的具体类型（如服务账户令牌或 Docker 配置）时，会使用此类型。实质上，*opaque* 表示 Secret
    的内容是任意的，并未按任何特定类型的机密数据进行结构化表示。
- en: 'Now, we need to link the GitHub repository with the GitHub repository secret
    using the `github-repository-definition.yaml` file located in the definitions
    folder (the `flux-gitops-definitions` folder defined in the repository accompanying
    this chapter). Apply it using the usual command:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要通过位于定义文件夹中的 `github-repository-definition.yaml` 文件（在本章随附的仓库中的 `flux-gitops-definitions`
    文件夹）将 GitHub 仓库与 GitHub 仓库 Secret 关联。使用常规命令应用它：
- en: '[PRE17]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Docker image for the TF-Controller**: Now, we need to create a custom Docker
    image to run the TF-Controller. The Dockerfile definition is contained in the
    Docker directory. For Docker commands, please refer to *Publishing the image to
    a container registry* section in [*Chapter 2*](B22100_02.xhtml#_idTextAnchor027).
    To build a custom Docker image, use the following command:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**TF-Controller 的 Docker 镜像**：现在，我们需要创建一个自定义的 Docker 镜像来运行 TF-Controller。Dockerfile
    定义包含在 Docker 目录中。有关 Docker 命令，请参阅 [*第 2 章*](B22100_02.xhtml#_idTextAnchor027)
    中的 *发布镜像到容器仓库* 部分。要构建自定义 Docker 镜像，请使用以下命令：'
- en: '[PRE18]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, you need to publish it in a repository reachable from your Kubernetes
    cluster. To push the command, after logging in to Docker, use the following command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您需要将其发布到 Kubernetes 集群可以访问的仓库中。登录 Docker 后，使用以下命令推送该镜像：
- en: '[PRE19]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At this point, we can commit and push the code to the GitHub repository, concluding
    the first part of our journey of setting up Terraform within our GitOps workflow.
    The next stop on our journey, which will be described in the upcoming sections,
    focuses on enabling CD in Kubernetes with Flux.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以将代码提交并推送到 GitHub 仓库，结束我们在 GitOps 工作流中设置 Terraform 的第一部分。接下来的一部分，我们将在接下来的章节中描述，重点是使用
    Flux 在 Kubernetes 中启用 CD。
- en: Exploring Flux CD – enabling CD in Kubernetes
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Flux CD – 在 Kubernetes 中启用 CD
- en: Flux CD automates the application of configurations and updates to a Kubernetes
    cluster based on changes pushed to a Git repository. This approach not only ensures
    consistency across environments but also enhances security and auditability by
    maintaining a clear, version-controlled history of all deployments. Flux continuously
    monitors a designated Git repository for changes to Kubernetes manifests, Helm
    charts, or configuration files. When a change is detected, Flux automatically
    applies these updates to the corresponding Kubernetes cluster. This automation
    is comprehensive, extending not only to applications but also to the Kubernetes
    infrastructure itself, enabling entire environments to be managed as code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Flux CD 根据推送到 Git 仓库的更改，自动将配置和更新应用到 Kubernetes 集群。这种方法不仅确保了各环境之间的一致性，还通过维护所有部署的清晰版本控制历史，提高了安全性和可审计性。Flux
    持续监控指定的 Git 仓库，检查 Kubernetes 清单、Helm 图表或配置文件的更改。当检测到更改时，Flux 会自动将这些更新应用到相应的 Kubernetes
    集群中。这种自动化是全面的，不仅适用于应用程序，还适用于 Kubernetes 基础设施本身，使得整个环境能够像代码一样进行管理。
- en: 'Key features of Flux CD include the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Flux CD 的主要功能包括以下几点：
- en: '**Automated synchronization**: Flux regularly checks the Git repository for
    changes and synchronizes the state of the cluster accordingly'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动同步**：Flux 定期检查 Git 仓库的更改，并相应地同步集群的状态。'
- en: '**Immutable deployments**: By treating infrastructure as immutable, Flux discourages
    manual interventions and promotes reproducibility'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变部署**：通过将基础设施视为不可变，Flux 遏制了人工干预，并促进了可重复性。'
- en: '**Security and compliance**: Changes are pulled from Git, ensuring that only
    approved changes are deployed, thereby enhancing security and compliance'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性与合规性**：更改从Git中拉取，确保仅部署批准的更改，从而增强了安全性和合规性。'
- en: It’s time to return to our journey, which we paused at the end of the previous
    section. Now, we need to configure the Flux instance to track its respective directory
    or branch in the Git repository. This is where the beauty of the Terraform Controller
    comes into play—it does all the hard work for you.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候回到我们在上一部分暂停的旅程了。我们需要配置Flux实例，以跟踪Git仓库中相应的目录或分支。此时，Terraform Controller的强大之处便显现出来——它为你完成了所有繁重的工作。
- en: 'We need to create a YAML file (refer to the `azvnet-gitops-automation.yaml`
    file defined in the repository for this chapter) like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个YAML文件（参考本章中仓库中定义的`azvnet-gitops-automation.yaml`文件），如下所示：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This YAML file defines a `Terraform` resource for use within the Flux CD framework,
    specifically designed to manage IaC deployments automatically. The configuration
    details the API version and specifies that the resource type is `Terraform`, indicating
    its role in managing and applying Terraform configurations through Flux.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个YAML文件定义了一个`Terraform`资源，供Flux CD框架内使用，专门设计用于自动管理IaC（基础设施即代码）部署。配置详细说明了API版本，并指定资源类型为`Terraform`，这表明它在通过Flux管理和应用Terraform配置中的作用。
- en: 'The resource is named `gitops-terraform-automation` and is located within the
    `flux-system` namespace, which is typically designated for Flux CD operations.
    The specifications include an interval setting of 1 minute, indicating how frequently
    Flux checks the Git repository for changes in the designated directory. It is
    configured to automatically approve and apply changes (`approvePlan: auto`) and
    to destroy all managed resources if this Terraform configuration is deleted from
    Kubernetes (`destroyResourcesOnDeletion: true`). The `./iac/azure/vnet` path specifies
    where in the Git repository the Terraform configurations are located, which Flux
    will monitor.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '该资源命名为`gitops-terraform-automation`，位于`flux-system`命名空间中，该命名空间通常用于Flux CD操作。规格包括1分钟的间隔设置，指示Flux检查Git仓库中指定目录的变更频率。它被配置为自动批准并应用更改（`approvePlan:
    auto`），并且如果此Terraform配置从Kubernetes中删除，则销毁所有受管理的资源（`destroyResourcesOnDeletion:
    true`）。`./iac/azure/vnet`路径指定了Git仓库中Terraform配置的位置，Flux将监控该路径。'
- en: The `sourceRef` instance points to a Git repository named `flux-system`, identifying
    the specific repository Flux should monitor. This setup allows Flux to automatically
    manage updates and maintain the environment as specified in the repository.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`sourceRef`实例指向名为`flux-system`的Git仓库，标识出Flux应当监控的具体仓库。此设置使Flux能够自动管理更新，并保持仓库中指定的环境。'
- en: The `runnerPodTemplate` section configures the environment variables for the
    pod that executes the Terraform commands, securing access to Azure services. Variables
    such as `ARM_SUBSCRIPTION_ID`, `ARM_CLIENT_ID`, `ARM_CLIENT_SECRET`, and `ARM_TENANT_ID`
    are essential for Azure interactions and are pulled securely from a Kubernetes
    secret named `azure-creds`. This ensures that sensitive credentials are managed
    securely and only made available to the necessary processes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`runnerPodTemplate`部分配置了执行Terraform命令的Pod的环境变量，以确保能够安全访问Azure服务。`ARM_SUBSCRIPTION_ID`、`ARM_CLIENT_ID`、`ARM_CLIENT_SECRET`和`ARM_TENANT_ID`等变量对于Azure的交互至关重要，它们从一个名为`azure-creds`的Kubernetes机密中安全提取。这确保了敏感凭证得到了安全管理，并且只对必要的进程可用。'
- en: By leveraging this configuration, Flux CD automates the deployment and management
    of Azure virtual networks defined in the Terraform configurations at the specified
    path in the repository. The automation encompasses monitoring for changes, applying
    updates, and ensuring the environment remains consistent with the declared state
    in the repository. This setup epitomizes the principles of GitOps by using Git
    as a **single** **source of truth** (**SSOT**) and automating the reconciliation
    process between the desired state defined in Git and the actual state of the infrastructure
    in Azure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用此配置，Flux CD自动化部署和管理在仓库中指定路径的Terraform配置所定义的Azure虚拟网络。自动化包括监控更改、应用更新，并确保环境保持与仓库中声明的状态一致。此设置体现了GitOps的原则，通过使用Git作为**单一****真实来源**（**SSOT**），并自动化Git中定义的期望状态与Azure中基础设施的实际状态之间的对账过程。
- en: 'To make the magic happen and bring the configuration to life, we need to apply
    it using `kubectl`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一魔法并使配置生效，我们需要使用`kubectl`来应用它：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: $ kubectl get terraforms.infra.contrib.fluxcd.io -n flux-system  -w
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: $ kubectl get terraforms.infra.contrib.fluxcd.io -n flux-system  -w
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: NAME        READY     STATUS                       AGE
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 名称    就绪   状态                      时间
- en: gitops-ter… Unknown   Reconciliation in progress   9s
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: gitops-ter… 未知   对账进行中   9秒
- en: gitops-ter… Unknown   Initializing                 15s
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: gitops-ter… 未知   初始化中   15秒
- en: gitops-ter… Unknown   Terraform Planning           22s
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: gitops-ter… 未知   Terraform 计划中   22秒
- en: gitops-ter… Unknown   Plan generated               30s
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: gitops-ter… 未知   计划已生成   30秒
- en: gitops-ter… Unknown   Applying                     30s
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: gitops-ter… 未知   应用中   30秒
- en: gitops-ter… Unknown   Applying                     30s
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: gitops-ter… 未知   应用中   30秒
- en: 'gitops-ter… Unknown   Applied successfully: main@sha1:2eeaefba687fbd3d4caea404fc332ee7c5d8b144   43s'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: gitops-ter… 未知   应用成功：main@sha1:2eeaefba687fbd3d4caea404fc332ee7c5d8b144   43秒
- en: 'gitops-ter… True      Applied successfully: main@sha1:2eeaefba687fbd3d4caea404fc332ee7c5d8b144   44s'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: gitops-ter… True   应用成功：main@sha1:2eeaefba687fbd3d4caea404fc332ee7c5d8b144   44秒
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: resource "azurerm_subnet" "azure_bastion_subnet" {
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 资源 "azurerm_subnet" "azure_bastion_subnet" {
- en: name                 = «AzureBastionSubnet"
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 名称                   = «AzureBastionSubnet"
- en: resource_group_name  = azurerm_resource_group.gitops_terraform_rg.name
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: resource_group_name  = azurerm_resource_group.gitops_terraform_rg.name
- en: virtual_network_name = azurerm_virtual_network.gitops_terraform_vnet.name
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: virtual_network_name = azurerm_virtual_network.gitops_terraform_vnet.name
- en: address_prefixes     = [«10.0.1.0/26"]
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: address_prefixes     = [«10.0.1.0/26"]
- en: '}'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: gitops-ter…   Unknown   Reconciliation in progress    3h12m
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: gitops-ter…   未知   对账进行中   3小时12分钟
- en: gitops-ter…   Unknown   Initializing                3h12m
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: gitops-ter…   未知   初始化中   3小时12分钟
- en: gitops-ter…   Unknown   Terraform Planning            3h12m
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: gitops-ter…   未知   Terraform 计划中   3小时12分钟
- en: gitops-ter…   Unknown   Plan generated                3h12m
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: gitops-ter…   未知   计划已生成   3小时12分钟
- en: gitops-ter…   Unknown   Applying                    3h12m
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: gitops-ter…   未知   应用中   3小时12分钟
- en: 'gitops-ter…   Unknown   Applied successfully: main@sha1:a3b32ed48dda027b0c5e40a65c7be56e1cc7dd50       3h13m'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: gitops-ter…   未知   应用成功：main@sha1:a3b32ed48dda027b0c5e40a65c7be56e1cc7dd50   3小时13分钟
- en: 'gitops-ter…   True      Applied successfully: main@sha1:a3b32ed48dda027b0c5e40a65c7be56e1cc7dd50       3h13m'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: gitops-ter…   True   应用成功：main@sha1:a3b32ed48dda027b0c5e40a65c7be56e1cc7dd50
      3小时13分钟
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|---clusters/mgmt'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '|---clusters/mgmt'
- en: '|---flux-gitops-definitions'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '|---flux-gitops-definitions'
- en: '|---multi-env'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '|---multi-env'
- en: '|---iac'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '|---iac'
- en: '|---azure'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '|---azure'
- en: '|---base'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '|---base'
- en: '|---dev'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '|---dev'
- en: '|---staging'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '|---staging'
- en: '|---prod'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '|---prod'
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'GITHUB_TOKEN. This can be done by entering the following command in your terminal:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GITHUB_TOKEN。这可以通过在终端中输入以下命令来完成：
- en: '[PRE27]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: flux bootstrap github \
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: flux bootstrap github \
- en: --token-auth \
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --token-auth \
- en: --context=mgmt-cluster \
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --context=mgmt-cluster \
- en: --owner=[GITHUB_ACCOUNT] \
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --owner=[GITHUB_ACCOUNT] \
- en: --repository=[GITHUB_REPOSITORY] \
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --repository=[GITHUB_REPOSITORY] \
- en: --branch=develop \
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --branch=develop \
- en: --path=clusters/mgmt \
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --path=clusters/mgmt \
- en: --personal
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --personal
- en: '[PRE28]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ► connecting to github.com
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ► 正在连接到 github.com
- en: ► cloning branch "develop" from Git repository "https://github.com/...
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ► 从 Git 仓库 "https://github.com/..." 克隆分支 "develop"
- en: ✔ cloned repository
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ✔ 已克隆仓库
- en: ► generating component manifests
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ► 正在生成组件清单
- en: …
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: '✔ kustomize-controller: deployment ready'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '✔ kustomize-controller: 部署就绪'
- en: '✔ notification-controller: deployment ready'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '✔ notification-controller: 部署就绪'
- en: '✔ source-controller: deployment ready'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '✔ source-controller: 部署就绪'
- en: ✔ all components are healthy
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ✔ 所有组件正常
- en: '[PRE29]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'flux-system namespace or a specific namespace designated for it:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: flux-system 命名空间或为其指定的特定命名空间：
- en: '[PRE31]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: $ kubectl create secret generic azure-creds \
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ kubectl create secret generic azure-creds \
- en: --from-literal=ARM_SUBSCRIPTION_ID='SP_SUB_ID' \
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --from-literal=ARM_SUBSCRIPTION_ID='SP_SUB_ID' \
- en: --from-literal=ARM_TENANT_ID='SP_TENANT_ID' \
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --from-literal=ARM_TENANT_ID='SP_TENANT_ID' \
- en: --from-literal=ARM_CLIENT_ID='SP_APPID' \
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --from-literal=ARM_CLIENT_ID='SP_APPID' \
- en: --from-literal=ARM_CLIENT_SECRET='SP_PASSWORD' \
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --from-literal=ARM_CLIENT_SECRET='SP_PASSWORD' \
- en: 'main.tf file in each environment-specific subdirectory (dev, staging, prod)
    within the multi-env/iac/azure main directory. Here’s how to structure the main.tf
    file for each environment:'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个环境特定子目录（dev、staging、prod）中的 main.tf 文件，位于 multi-env/iac/azure 主目录内。以下是如何为每个环境结构化
    main.tf 文件：
- en: '[PRE33]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: $ kubectl apply -f github-repository-secret.yaml
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ kubectl apply -f github-repository-secret.yaml
- en: '[PRE35]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: $ kubectl apply -f github-repository-definition.yaml
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ kubectl apply -f github-repository-definition.yaml
- en: '[PRE36]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: $ kubectl apply -f dev-iac-automation.yaml
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ kubectl apply -f dev-iac-automation.yaml
- en: $ kubectl apply -f staging-iac-automation.yaml
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ kubectl apply -f staging-iac-automation.yaml
- en: $ kubectl apply -f prod-iac-automation.yaml
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ kubectl apply -f prod-iac-automation.yaml
- en: '[PRE37]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: $ kubectl get terraforms.infra.contrib.fluxcd.io -n flux-system  -w
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ kubectl get terraforms.infra.contrib.fluxcd.io -n flux-system  -w
- en: NAME                          READY   STATUS                                                            AGE
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: NAME                          准备就绪   状态                                                            年龄
- en: 'dev-cluster-tf-automation       True    No drift: develop@sha1:c93...   3m48s'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'dev-cluster-tf-automation       True    没有漂移: develop@sha1:c93...   3m48s'
- en: 'prod-cluster-tf-automation      True    No drift: develop@sha1:c93...   3m31s'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'prod-cluster-tf-automation      True    没有漂移: develop@sha1:c93...   3m31s'
- en: 'staging-cluster-tf-automation   True    No drift: develop@sha1:c93...   3m37s'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'staging-cluster-tf-automation   True    没有漂移: develop@sha1:c93...   3m37s'
- en: dev-cluster-tf-automation       Unknown   Reconciliation in progress                                        3m48s
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: dev-cluster-tf-automation       未知   正在进行协调                                                          3m48s
- en: staging-cluster-tf-automation   Unknown   Reconciliation in progress                                        3m38s
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: staging-cluster-tf-automation   未知   正在进行协调                                                          3m38s
- en: prod-cluster-tf-automation      Unknown   Reconciliation in progress                                        3m33s
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: prod-cluster-tf-automation      未知   正在进行协调                                                          3m33s
- en: '[PRE38]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: variable "environment" {
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: variable "environment" {
- en: …
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: default     = "dev"
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: default     = "dev"
- en: '}'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: variable "location" {
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: variable "location" {
- en: …
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: '}'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: variable "rg" {
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: variable "rg" {
- en: …
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: default     = «gitops-dev-rg"
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: default     = «gitops-dev-rg"
- en: '}'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE39]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: $ kubectl get terraforms.infra.contrib.fluxcd.io -n flux-system  -w
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ kubectl get terraforms.infra.contrib.fluxcd.io -n flux-system  -w
- en: '[PRE40]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
