<html><head></head><body>
  <div id="_idContainer013" class="Basic-Text-Frame">
    <h1 class="chapterNumber">1</h1>
    <h1 id="_idParaDest-14" class="chapterTitle">Understanding Kubernetes Architecture</h1>
    <p class="normal">In one sentence, Kubernetes is a platform to orchestrate the deployment, scaling, and management of container-based applications. You have probably read about Kubernetes, and maybe even dipped your toes in and used it in a side project or maybe even at work. But to understand what Kubernetes is all about, how to use it effectively, and what the best practices are requires much more.</p>
    <p class="normal">Kubernetes is a big open source project and ecosystem with a lot of code and a lot of functionality. Kubernetes came out of Google, but joined the <strong class="keyWord">Cloud Native Computing Foundation</strong> (<strong class="keyWord">CNCF</strong>) and is <a id="_idIndexMarker000"/>now the de facto standard in the space of container-based applications. According to the 2021 CNCF survey, 96% of organizations use or evaluate Kubernetes.</p>
    <p class="normal">In this chapter, we will build the foundation necessary to utilize Kubernetes to its full potential. We will start by understanding what Kubernetes is, what Kubernetes isn’t, and what container orchestration means exactly. Then we will cover important Kubernetes concepts that will form the vocabulary we will use throughout the book. After that, we will dive into the architecture of Kubernetes properly and look at how it enables all the capabilities it provides for its users. Then, we will discuss how Kubernetes supports multiple container runtimes in a generic way.</p>
    <p class="normal">The topics we will discuss are:</p>
    <ul>
      <li class="bulletList">What is Kubernetes?</li>
      <li class="bulletList">What Kubernetes is not</li>
      <li class="bulletList">Understanding container orchestration</li>
      <li class="bulletList">Kubernetes concepts</li>
      <li class="bulletList">Diving into Kubernetes architecture in depth</li>
      <li class="bulletList">Kubernetes container runtimes</li>
    </ul>
    <p class="normal">At the end of this chapter, you will have a solid understanding of container orchestration, what problems Kubernetes addresses, the rationale of Kubernetes design and architecture, and the different runtime engines it supports.</p>
    <h1 id="_idParaDest-15" class="heading-1">What is Kubernetes?</h1>
    <p class="normal">Kubernetes is a <a id="_idIndexMarker001"/>platform that encompasses a huge number of services and capabilities that keeps growing. The core functionality is scheduling workloads in containers across your infrastructure, but it doesn’t stop there. Here are some of the other <a id="_idIndexMarker002"/>capabilities Kubernetes brings to the table:</p>
    <ul>
      <li class="bulletList">Providing authentication and authorization</li>
      <li class="bulletList">Debugging applications</li>
      <li class="bulletList">Accessing and ingesting logs</li>
      <li class="bulletList">Rolling updates</li>
      <li class="bulletList">Using Cluster Autoscaling</li>
      <li class="bulletList">Using the Horizontal Pod Autoscaler</li>
      <li class="bulletList">Replicating application instances</li>
      <li class="bulletList">Checking application health and readiness</li>
      <li class="bulletList">Monitoring resources</li>
      <li class="bulletList">Balancing loads</li>
      <li class="bulletList">Naming and service discovery</li>
      <li class="bulletList">Distributing secrets</li>
      <li class="bulletList">Mounting storage systems</li>
    </ul>
    <p class="normal">We will cover all these capabilities in great detail throughout the book. At this point, just absorb and appreciate how much value Kubernetes can add to your system.</p>
    <p class="normal">Kubernetes has impressive scope, but it is also important to understand what Kubernetes explicitly doesn’t provide.</p>
    <h1 id="_idParaDest-16" class="heading-1">What Kubernetes is not</h1>
    <p class="normal">Kubernetes is not<a id="_idIndexMarker003"/> a <strong class="keyWord">Platform as a Service</strong> (<strong class="keyWord">PaaS</strong>). It doesn’t dictate many important aspects that are left to you or to other systems built on top of Kubernetes, such as OpenShift and Tanzu. For example:</p>
    <ul>
      <li class="bulletList">Kubernetes doesn’t require a specific application type or framework</li>
      <li class="bulletList">Kubernetes doesn’t require a specific programming language</li>
      <li class="bulletList">Kubernetes doesn’t provide databases or message queues</li>
      <li class="bulletList">Kubernetes doesn’t distinguish apps from services</li>
      <li class="bulletList">Kubernetes doesn’t have a click-to-deploy service marketplace</li>
      <li class="bulletList">Kubernetes doesn’t provide a built-in function as a service solution</li>
      <li class="bulletList">Kubernetes doesn’t mandate logging, monitoring, and alerting systems</li>
      <li class="bulletList">Kubernetes doesn’t provide a CI/CD pipeline</li>
    </ul>
    <h1 id="_idParaDest-17" class="heading-1">Understanding container orchestration</h1>
    <p class="normal">The primary<a id="_idIndexMarker004"/> responsibility of Kubernetes is container orchestration. That means making sure that all the containers that execute various workloads are scheduled to run on physical or virtual machines. The containers must be packed efficiently following the constraints of the deployment environment and the cluster configuration. In addition, Kubernetes must keep an eye on all running containers and replace dead, unresponsive, or otherwise unhealthy containers. Kubernetes provides many more capabilities that you will learn about in the following chapters. In this section, the focus is on containers and their orchestration.</p>
    <h2 id="_idParaDest-18" class="heading-2">Physical machines, virtual machines, and containers</h2>
    <p class="normal">It all <a id="_idIndexMarker005"/>starts and ends with hardware. In order to run your workloads, you<a id="_idIndexMarker006"/> need some real hardware provisioned. That includes actual physical machines, with certain compute capabilities (CPUs or cores), memory, and some local persistent storage (spinning disks or SSDs). In addition, you will need some shared persistent storage and to hook up all these machines using networking, so they can find and talk to each other. At this point, you run multiple virtual machines on the physical machines or stay at the bare-metal level (no virtual machines). Kubernetes can be deployed on a bare-metal cluster (real hardware) or on a cluster of virtual machines. Kubernetes in turn can orchestrate the containers it manages directly on bare-metal or on virtual machines. In theory, a Kubernetes cluster can be composed of a mix of bare-metal and virtual machines, but this is not very common. There are many more esoteric configurations with different levels of encapsulation, such as virtual Kubernetes clusters running inside the namespaces of another Kubernetes cluster.</p>
    <h2 id="_idParaDest-19" class="heading-2">The benefits of containers</h2>
    <p class="normal">Containers <a id="_idIndexMarker007"/>represent a true paradigm shift in the development and operation of large, complicated software systems. Here are some of the benefits compared to more<a id="_idIndexMarker008"/> traditional models:</p>
    <ul>
      <li class="bulletList">Agile application creation and deployment</li>
      <li class="bulletList">Continuous development, integration, and deployment</li>
      <li class="bulletList">Development and operations separation of concerns</li>
      <li class="bulletList">Environmental consistency across development, testing, staging, and production</li>
      <li class="bulletList">Cloud and OS distribution portability</li>
      <li class="bulletList">Application-centric management</li>
      <li class="bulletList">Resource isolation</li>
      <li class="bulletList">Resource utilization</li>
    </ul>
    <h2 id="_idParaDest-20" class="heading-2">Containers in the cloud</h2>
    <p class="normal">Microservices <a id="_idIndexMarker009"/>are the dominant architecture for modern large-scale systems. The primary idea is to break down the system into small services with well-defined responsibilities that manage their own data and communicate with other microservices through well-defined APIs.</p>
    <p class="normal">Containers are ideal to package microservices because, while providing isolation to the microservice, they are very lightweight and you don’t incur a lot of overhead when deploying many microservices, as you do with virtual machines. That makes containers ideal for cloud deployment, where allocating a whole virtual machine for each microservice would be cost-prohibitive.</p>
    <p class="normal">All major cloud providers, such as Amazon AWS, Google’s GCE, and Microsoft’s Azure, provide container hosting services these days. Many other companies jumped on the Kubernetes bandwagon and offer managed Kubernetes services, including IBM IKS, Alibaba Cloud, DigitalOcean DKS, Oracle OKS, OVH Managed Kubernetes, and Rackspace KaaS.</p>
    <p class="normal">Google’s GKE was always based on Kubernetes. AWS <strong class="keyWord">Elastic Kubernetes Service</strong> (<strong class="keyWord">EKS</strong>) was added in addition to the proprietary AWS ECS orchestration solution. Microsoft Azure’s container<a id="_idIndexMarker010"/> service used to be based on Apache Mesos, but later switched to Kubernetes with <strong class="keyWord">Azure Kubernetes Service</strong> (<strong class="keyWord">AKS</strong>). You could always deploy Kubernetes on all the cloud platforms, but it wasn’t deeply integrated with other services. But, at the end of 2017 all cloud providers announced direct support for Kubernetes. Microsoft launched AKS, and AWS released EKS. Also, various other companies offer managed Kubernetes services such as IBM, Oracle, Digital Ocean, Alibaba, Tencent, and Huawei.</p>
    <h2 id="_idParaDest-21" class="heading-2">Cattle versus pets</h2>
    <p class="normal">In the olden days, when systems were small, each server had a name. Developers and users knew exactly what software was running on each machine. I remember that, in many of the companies I worked for, we had multi-day discussions to decide on a naming theme for our servers. For example, composers and Greek mythology characters were popular choices. Everything was very cozy. You treated your servers like beloved pets. When a server died it was a major crisis. Everybody scrambled to try to figure out where to get another server, what was even running on the dead server, and how to get it working on the new server. If the server stored some important data, then hopefully you had an up-to-date backup, and maybe you’d even be able to recover it.</p>
    <p class="normal">Obviously, that approach doesn’t scale. When you have tens or hundreds of servers, you must start treating them like cattle. You think about the collective and not individuals. You may still have some pets like your CI/CD machines (although managed CI/CD solutions are becoming more common), but your web servers and backend services are just cattle.</p>
    <p class="normal">Kubernetes takes the<a id="_idIndexMarker011"/> cattle approach to the extreme and takes full responsibility for allocating containers to specific machines. You don’t need to interact with individual machines (nodes) most of the time. This works best for stateless workloads. For stateful applications, the situation is a little different, but Kubernetes provides a solution called StatefulSet, which we’ll discuss soon.</p>
    <p class="normal">In this section, we covered the idea of container orchestration and discussed the relationships between hosts (physical or virtual) and containers, as well as the benefits of running containers in the cloud. We then finished with a discussion about cattle versus pets. In the following section, we will get to know the world of Kubernetes and learn its concepts and terminology.</p>
    <h1 id="_idParaDest-22" class="heading-1">Kubernetes concepts</h1>
    <p class="normal">In this section, we’ll briefly<a id="_idIndexMarker012"/> introduce many important Kubernetes concepts and give you some context as to why they are needed and how they interact with each other. The goal is to get familiar with these terms and concepts. Later, we will see how these concepts are woven together and organized into API groups and resource categories to achieve awesomeness. You can consider many of these concepts as building blocks. Some concepts, such as nodes and the control plane, are implemented as a set of Kubernetes components. These components are at a different abstraction level, and we will discuss them in detail in a dedicated section, <em class="italic">Kubernetes components</em>.</p>
    <p class="normal">Here is the Kubernetes architecture diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18998_01_01.png" alt="Graphical user interface, application, Teams  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.1: Kubernetes architecture</p>
    <h2 id="_idParaDest-23" class="heading-2">Node</h2>
    <p class="normal">A <a id="_idIndexMarker013"/>node is a<a id="_idIndexMarker014"/> single host. It may be a physical or virtual machine. Its job is to run pods. Each Kubernetes node runs several Kubernetes components, such as the kubelet, the container runtime, and the kube-proxy. Nodes are managed by the Kubernetes control plane. The nodes are the worker bees of Kubernetes and <a id="_idIndexMarker015"/>shoulder all the heavy lifting. In<a id="_idIndexMarker016"/> the past they <a id="_idIndexMarker017"/>were called <strong class="keyWord">minions</strong>. If you read some old documentation or articles, don’t get confused. Minions are just nodes.</p>
    <h2 id="_idParaDest-24" class="heading-2">Cluster</h2>
    <p class="normal">A <a id="_idIndexMarker018"/>cluster is a <a id="_idIndexMarker019"/>collection of hosts (nodes) that provide compute, memory, storage, and networking resources. Kubernetes uses these resources to run the various workloads that comprise your system. Note that your entire system may consist of multiple clusters. We will discuss this advanced use case of multi-cluster systems in detail later.</p>
    <h2 id="_idParaDest-25" class="heading-2">Control plane</h2>
    <p class="normal">The<a id="_idIndexMarker020"/> control plane <a id="_idIndexMarker021"/>of Kubernetes consists of several components, such as an API server, a scheduler, a controller manager and, optionally, a cloud controller manager. The control plane is responsible for the global state of the cluster, cluster-level scheduling of pods, and handling of events. Usually, all the control plane components are set up on the same host although it’s not required. When considering high-availability scenarios or very large clusters, you will want to have control plane redundancy. We will discuss highly available clusters in detail in <em class="chapterRef">Chapter 3</em>, <em class="italic">High Availability and Reliability</em>.</p>
    <h2 id="_idParaDest-26" class="heading-2">Pod</h2>
    <p class="normal">A pod is <a id="_idIndexMarker022"/>the unit of work in Kubernetes. Each pod contains <a id="_idIndexMarker023"/>one or more containers (so you can think of it as a container container). A pod is scheduled as an atomic unit (all its containers run on the same machine). All the containers in a pod have the same IP address and port space; they can communicate with each other using localhost or standard inter-process communication. In addition, all the containers in a pod can have access to shared local storage on the node hosting the pod. Containers don’t get access to local storage or any other storage by default. Volumes of storage must be mounted into each container inside the pod explicitly.</p>
    <p class="normal">Pods are an important feature of Kubernetes. It is possible to run multiple applications inside a single container by having something like supervisord as the main process that runs multiple processes, but this practice is often frowned upon for the following reasons:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Transparency</strong>: Making the containers within the pod visible to the infrastructure enables the infrastructure to provide services to those containers, such as process management and resource monitoring. This facilitates a number of conveniences for users.</li>
      <li class="bulletList"><strong class="keyWord">Decoupling software dependencies</strong>: The individual containers may be versioned, rebuilt, and redeployed independently. Kubernetes may even support live updates of individual containers someday.</li>
      <li class="bulletList"><strong class="keyWord">Ease of use</strong>: Users don’t need to run their own process managers, worry about signal and exit-code propagation, and so on.</li>
      <li class="bulletList"><strong class="keyWord">Efficiency</strong>: Because the infrastructure takes on more responsibility, containers can be more lightweight.</li>
    </ul>
    <p class="normal">Pods <a id="_idIndexMarker024"/>provide <a id="_idIndexMarker025"/>a great solution for managing groups of closely related containers that depend on each other and need to co-operate on the same host to accomplish their purpose. It’s important to remember that pods are considered ephemeral, throwaway entities that can be discarded and replaced at will. Each pod <a id="_idIndexMarker026"/>gets a <strong class="keyWord">unique ID</strong> (<strong class="keyWord">UID</strong>), so you can still distinguish between them if necessary.</p>
    <h2 id="_idParaDest-27" class="heading-2">Label</h2>
    <p class="normal">Labels are<a id="_idIndexMarker027"/> key-value pairs that are used to group together<a id="_idIndexMarker028"/> sets of objects, very often pods via selectors. This is important for several other concepts, such as replica sets, deployments, and services that operate on dynamic groups of objects and need to identify the members of the group. There is an NxN relationship between objects and labels. Each object may have multiple labels, and each label may be applied to different objects. </p>
    <p class="normal">There are certain restrictions by design on labels. Each label on an object must have a unique key. The label key must adhere to a strict syntax. Note that labels are dedicated to identifying objects and are not for attaching arbitrary metadata to objects. This is what annotations are for (see the <em class="italic">Annotation</em> section).</p>
    <h2 id="_idParaDest-28" class="heading-2">Label selector</h2>
    <p class="normal">Label selectors <a id="_idIndexMarker029"/>are used to select objects based on <a id="_idIndexMarker030"/>their labels. Equality-based selectors specify a key name and a value. There are two operators, <code class="inlineCode">=</code> (or <code class="inlineCode">==</code>) and <code class="inlineCode">!=</code>, for equality or inequality based on the value. For example:</p>
    <pre class="programlisting code"><code class="hljs-code">role = webserver
</code></pre>
    <p class="normal">This will select<a id="_idIndexMarker031"/> all objects that have that label key and value.</p>
    <p class="normal">Label selectors<a id="_idIndexMarker032"/> can have multiple requirements separated by a comma. For example:</p>
    <pre class="programlisting code"><code class="hljs-code">role = webserver, application != foo
</code></pre>
    <p class="normal">Set-based selectors extend the capabilities and allow selection based on multiple values:</p>
    <pre class="programlisting code"><code class="hljs-code">role in (webserver, backend)
</code></pre>
    <h2 id="_idParaDest-29" class="heading-2">Annotation</h2>
    <p class="normal">Annotations <a id="_idIndexMarker033"/>let you <a id="_idIndexMarker034"/>associate arbitrary metadata with Kubernetes objects. Kubernetes just stores the annotations and makes their metadata available. Annotation key syntax has similar requirements as label keys.</p>
    <p class="normal">In my experience, you always need such metadata for complicated systems, and it is nice that Kubernetes recognizes this need and provides it out of the box, so you don’t have to come up with your own separate metadata store and mapping object to their metadata.</p>
    <h2 id="_idParaDest-30" class="heading-2">Service</h2>
    <p class="normal">Services are<a id="_idIndexMarker035"/> used to expose some functionality to users or other services. They<a id="_idIndexMarker036"/> usually encompass a group of pods, usually identified by – you guessed it – a label. You can have services that provide access to external resources, or pods you control directly at the virtual IP level. Native Kubernetes services are exposed through convenient endpoints. Note that services operate at layer 3 (TCP/UDP). Kubernetes 1.2 added the Ingress object, which provides access to HTTP objects – more on that later. Services are published or discovered via one of two mechanisms: DNS, or environment variables. Services can be load-balanced inside the cluster by Kubernetes. But, developers can choose to manage load balancing themselves in case of <a id="_idIndexMarker037"/>services that use external resources or require special <a id="_idIndexMarker038"/>treatment.</p>
    <p class="normal">There are many gory details associated with IP addresses, virtual IP addresses, and port spaces. We will discuss them in depth in <em class="chapterRef">Chapter 10</em>, <em class="italic">Exploring Kubernetes Networking</em>.</p>
    <h2 id="_idParaDest-31" class="heading-2">Volume</h2>
    <p class="normal">Local storage <a id="_idIndexMarker039"/>used by the pod is ephemeral and goes away<a id="_idIndexMarker040"/> with the pod in most cases. Sometimes that’s all you need, if the goal is just to exchange data between containers of the node, but sometimes it’s important for the data to outlive the pod, or it’s necessary to share data between pods. The volume concept supports that need. The essence of a volume is a directory with some data that is mounted into a container.</p>
    <p class="normal">There are many volume types. Originally, Kubernetes directly supported many volume types, but the modern approach for extending Kubernetes with volume types is through the <strong class="keyWord">Container Storage Interface</strong> (<strong class="keyWord">CSI</strong>), which<a id="_idIndexMarker041"/> we’ll discuss in detail in <em class="chapterRef">Chapter 6</em>, <em class="italic">Managing Storage</em>. Most of the originally built-in volume types will have been (or are in the process of being) phased out in favor of out-of-tree plugins available through the CSI.</p>
    <h2 id="_idParaDest-32" class="heading-2">Replication controller and replica set</h2>
    <p class="normal">Replication controllers <a id="_idIndexMarker042"/>and replica sets <a id="_idIndexMarker043"/>both manage a group of pods identified by a label selector and ensure that a certain number is always up and running. The main difference between them is that replication controllers test for membership by name equality and replica sets can use set-based selection. Replica sets<a id="_idIndexMarker044"/> are the way to go as they are a superset of replication controllers. I expect replication controllers to be deprecated at some point. Kubernetes guarantees that you will always have the same number of pods running as you specified in a replication controller or a replica set. Whenever the number drops due to a problem with the hosting node or the pod itself, Kubernetes will fire up new instances. Note that, if you manually start pods and exceed the specified number, the replica set controller will kill some extra pods.</p>
    <p class="normal">Replication controllers used to be <a id="_idIndexMarker045"/>central to many workflows, such as rolling updates and running one-off jobs. As Kubernetes evolved, it introduced direct support for many of these workflows, with dedicated objects such as <strong class="keyWord">Deployment</strong>, <strong class="keyWord">Job</strong>, <strong class="keyWord">CronJob</strong>, and <strong class="keyWord">DaemonSet</strong>. We will meet them all later.</p>
    <h2 id="_idParaDest-33" class="heading-2">StatefulSet</h2>
    <p class="normal">Pods <a id="_idIndexMarker046"/>come and go, and if you care about their data then <a id="_idIndexMarker047"/>you can use persistent storage. That’s all good. But sometimes you want Kubernetes to manage a distributed data store <a id="_idIndexMarker048"/>such as <strong class="keyWord">Cassandra</strong> or <strong class="keyWord">CockroachDB</strong>. These<a id="_idIndexMarker049"/> clustered stores keep the data distributed across uniquely identified nodes. You can’t model that with regular pods and services. Enter <strong class="keyWord">StatefulSet</strong>. If you remember earlier, we discussed pets versus cattle and how cattle is the way to go. Well, StatefulSet sits somewhere in the middle. StatefulSet ensures (similar to a ReplicaSet) that a given number of instances with unique identities <a id="_idIndexMarker050"/>are running at any given time. StatefulSet members have the following properties:</p>
    <ul>
      <li class="bulletList">A stable hostname, available in DNS</li>
      <li class="bulletList">An ordinal index</li>
      <li class="bulletList">Stable storage linked to the ordinal and hostname</li>
      <li class="bulletList">Members are created and terminated gracefully in order</li>
    </ul>
    <p class="normal">StatefulSet can help with peer discovery as well as adding or removing members safely.</p>
    <h2 id="_idParaDest-34" class="heading-2">Secret</h2>
    <p class="normal">Secrets<a id="_idIndexMarker051"/> are <a id="_idIndexMarker052"/>small objects that contain sensitive info such as credentials and tokens. They are stored by default as plaintext in etcd, accessible by the Kubernetes API server, and can be mounted as files into pods (using dedicated secret volumes that piggyback on regular data volumes) that need access to them. The same secret can be mounted into multiple pods. Kubernetes itself creates secrets for its components, and you can create your own secrets. Another approach is to use secrets as environment variables. Note that secrets in a pod are always stored in memory (tmpfs in the case of mounted secrets) for better security. The best practice is to enable encryption at rest as well as access control with RBAC. We will discuss it in detail later.</p>
    <h2 id="_idParaDest-35" class="heading-2">Name</h2>
    <p class="normal">Each <a id="_idIndexMarker053"/>object in <a id="_idIndexMarker054"/>Kubernetes is identified by a UID and a name. The name is used to refer to the object in API calls. Names should be up to 253 characters long and use lowercase alphanumeric characters, dashes (-), and dots (.). If you delete an object, you can create another object with the same name as the deleted object, but the UIDs must be unique across the lifetime of the cluster. The UIDs are generated by Kubernetes, so you don’t have to worry about it.</p>
    <h2 id="_idParaDest-36" class="heading-2">Namespace</h2>
    <p class="normal">A<a id="_idIndexMarker055"/> namespace is<a id="_idIndexMarker056"/> a form of isolation that lets you group resources and apply policies. It is also a scope for names. Objects of the same kind must have unique names within a namespace. By default, pods in one namespace can access pods and services in other namespaces.</p>
    <p class="normal">Note that there are cluster-scope objects like node objects and persistent volumes that don’t live in a namespace. Kubernetes may schedule pods from different namespaces to run on the same node. Likewise, pods from different namespaces can use the same persistent storage.</p>
    <p class="normal">In multi-tenancy scenarios, where it’s important to totally isolate namespaces, you can do a passable job with proper network policies and resource quotas to ensure proper access and distribution of the physical cluster resources. But, in general namespaces are considered a weak form of isolation and there are other solutions more appropriated for hard multi-tenancy like virtual clusters, which we will discuss in <em class="chapterRef">Chapter 4</em>, <em class="italic">Securing Kubernetes</em>.</p>
    <p class="normal">We’ve covered most of Kubernetes’ primary concepts; there are a few more I mentioned briefly. In the next section, we will continue our journey into Kubernetes architecture by looking into its design motivations, the internals, and implementation, and even pick at the source code.</p>
    <h1 id="_idParaDest-37" class="heading-1">Diving into Kubernetes architecture in depth</h1>
    <p class="normal">Kubernetes <a id="_idIndexMarker057"/>has very ambitious goals. It aims to manage and simplify the orchestration, deployment, and management of distributed systems across a wide range of environments and cloud providers. It provides many capabilities and services that should work across all these diverse environments and use cases, while evolving and remaining simple enough for mere mortals to use. This is a tall order. Kubernetes achieves this by following a crystal-clear, high-level design and well-thought-out architecture that promotes extensibility and pluggability. </p>
    <p class="normal">Kubernetes originally had many hard-coded or environment-aware components, but the trend is to refactor them into plugins and keep the core small, generic, and abstract.</p>
    <p class="normal">In this section, we will peel Kubernetes like an onion, starting with various distributed systems design patterns and how Kubernetes supports them, then go over the surface of Kubernetes, which is its set of APIs, and then take a look at the actual components that comprise <a id="_idIndexMarker058"/>Kubernetes. Finally, we will take a quick tour of the source-code tree to gain even better insight into the structure of Kubernetes itself.</p>
    <p class="normal">At the end of this section, you will have a solid understanding of Kubernetes architecture and implementation, and why certain design decisions were made.</p>
    <h2 id="_idParaDest-38" class="heading-2">Distributed systems design patterns</h2>
    <p class="normal">All happy (working) distributed<a id="_idIndexMarker059"/> systems are alike, to paraphrase Tolstoy in <em class="italic">Anna Karenina</em>. That means that, to function properly, all<a id="_idIndexMarker060"/> well-designed distributed systems must follow some best practices and principles. Kubernetes doesn’t want to be just a management system. It wants to support and enable these best practices and provide high-level services to developers and administrators. Let’s look at some of those described as design patterns. We will start with single-node patterns such as sidecar, ambassador, and adapter. Then, we will discuss multi-node patterns.</p>
    <h3 id="_idParaDest-39" class="heading-3">Sidecar pattern</h3>
    <p class="normal">The <a id="_idIndexMarker061"/>sidecar pattern is<a id="_idIndexMarker062"/> about co-locating another container in a pod in addition to the main application container. The application container is unaware of the sidecar container and just goes about its business. A great example is a central logging agent. Your main container can just log to stdout, but the sidecar container will send all logs to a central logging service where they will be aggregated with the logs from the entire system. The benefits of using a sidecar container versus adding central logging to the main application container are enormous. First, applications are not burdened anymore with central logging, which could be a nuisance. If you want to upgrade or change your central logging policy or switch to a totally new provider, you just need to update the sidecar container and deploy it. None of your application containers change, so you can’t break them by accident. The Istio service mesh uses the sidecar pattern to inject its proxies into each pod.</p>
    <h3 id="_idParaDest-40" class="heading-3">Ambassador pattern</h3>
    <p class="normal">The<a id="_idIndexMarker063"/> ambassador pattern is about representing a remote service as if it were local and possibly enforcing some policy. A good example of the <a id="_idIndexMarker064"/>ambassador pattern is if you have a Redis cluster with one master for writes and many replicas for reads. A local ambassador container can serve as a proxy and expose Redis to the main application container on the localhost. The main application container simply connects to Redis on <code class="inlineCode">localhost:6379</code> (Redis’s default port), but it connects to the ambassador running in the same pod, which filters the requests, and sends write requests to the real Redis master and read requests randomly to one of the read replicas. Just like with the sidecar pattern, the main application has no idea what’s going on. That can help a lot when testing against a real local Redis cluster. Also, if the Redis cluster configuration changes, only the ambassador needs to be modified; the main application remains blissfully unaware.</p>
    <h3 id="_idParaDest-41" class="heading-3">Adapter pattern</h3>
    <p class="normal">The<a id="_idIndexMarker065"/> adapter pattern is about<a id="_idIndexMarker066"/> standardizing output from the main application container. Consider the case of a service that is being rolled out incrementally: it may generate reports in a format that doesn’t conform to the previous version. Other services and applications that consume that output haven’t been upgraded yet. An adapter container can be deployed in the same pod with the new application container and massage their output to match the old version until all consumers have been upgraded. The adapter container shares the filesystem with the main application container, so it can watch the local filesystem, and whenever the new application writes something, it immediately adapts it.</p>
    <h3 id="_idParaDest-42" class="heading-3">Multi-node patterns</h3>
    <p class="normal">The<a id="_idIndexMarker067"/> single-node patterns described<a id="_idIndexMarker068"/> earlier are all supported directly by Kubernetes via pods scheduled on a single node. Multi-node patterns involve pods scheduled on multiple nodes. Multi-node patterns such as leader election, work queues, and scatter-gather are not supported directly, but composing pods with standard interfaces to accomplish them is a viable approach with Kubernetes.</p>
    <h3 id="_idParaDest-43" class="heading-3">Level-triggered infrastructure and reconciliation</h3>
    <p class="normal">Kubernetes is<a id="_idIndexMarker069"/> all about <a id="_idIndexMarker070"/>control loops. It keeps watching itself and correcting issues. Level-triggered infrastructure means that Kubernetes has a desired state, and it constantly strives toward it. For example, if a<a id="_idIndexMarker071"/> replica set has a desired state of 3 replicas and it drops to 2 replicas, Kubernetes (the <strong class="keyWord">ReplicaSet</strong> controller part of Kubernetes) will notice and work to get back to 3 replicas. The alternative approach of edge-triggering is event-based. If the <a id="_idIndexMarker072"/>number of replicas dropped from 2 to 3, create a new replica. This approach is very brittle and has many edge cases, especially in distributed systems where events like replicas coming and going can happen simultaneously.</p>
    <p class="normal">After covering the Kubernetes architecture in depth let’s study the Kubernetes APIs.</p>
    <h2 id="_idParaDest-44" class="heading-2">The Kubernetes APIs</h2>
    <p class="normal">If you want to <a id="_idIndexMarker073"/>understand the capabilities of a system and what it provides, you must pay a lot of attention to its API. The API provides a comprehensive view of what you can do with the system as a user. Kubernetes exposes several sets of REST APIs for different purposes and audiences via API groups. Some APIs are used primarily by tools and some can be used directly by developers. An important aspect of the APIs is that they are under constant development. The Kubernetes developers keep it manageable by trying to extend (adding new objects, and new fields to existing objects) and avoid renaming or dropping existing objects and fields. In addition, all API endpoints are versioned, and often have an alpha or beta notation too. For example:</p>
    <pre class="programlisting gen"><code class="hljs">/api/v1
/api/v2alpha1
</code></pre>
    <p class="normal">You can access the API through the kubectl CLI, via client libraries, or directly through REST API calls. There are elaborate authentication and authorization mechanisms we will explore in <em class="chapterRef">Chapter 4</em>, <em class="italic">Securing Kubernetes</em>. If you have the right permissions you can list, view, create, update, and delete various Kubernetes objects. At this point, let’s get a glimpse into the surface area of the APIs. </p>
    <p class="normal">The best way to explore the API is via API groups. Some API groups are enabled by default. Other groups can be enabled/disabled via flags. For example, to disable the <code class="inlineCode">autoscaling/v1</code> group and enable the <code class="inlineCode">autoscaling/v2beta2</code> group you can set the <code class="inlineCode">--runtime-config</code> flag when running the API server as follows:</p>
    <pre class="programlisting gen"><code class="hljs">--runtime-config=autoscaling/v1=false,autoscaling/v2beta2=true
</code></pre>
    <p class="normal">Note that<a id="_idIndexMarker074"/> managed Kubernetes clusters in the cloud don’t let you specify flags for the API server (as they manage it).</p>
    <h3 id="_idParaDest-45" class="heading-3">Resource categories</h3>
    <p class="normal">In<a id="_idIndexMarker075"/> addition to API groups, another useful classification of available APIs is by functionality. The Kubernetes API is huge and breaking it down into categories helps a lot when you’re trying to find your way around. Kubernetes defines the following resource categories:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Workloads</strong>: Objects you use to manage and run containers on the cluster.</li>
      <li class="bulletList"><strong class="keyWord">Discovery and load balancing</strong>: Objects you use to expose your workloads to the world as externally accessible, load-balanced services.</li>
      <li class="bulletList"><strong class="keyWord">Config and storage</strong>: Objects you use to initialize and configure your applications, and to persist data that is outside the container.</li>
      <li class="bulletList"><strong class="keyWord">Cluster</strong>: Objects that define how the cluster itself is configured; these are typically used only by cluster operators.</li>
      <li class="bulletList"><strong class="keyWord">Metadata</strong>: Objects you use to configure the behavior of other resources within the cluster, such <a id="_idIndexMarker076"/>as <strong class="keyWord">HorizontalPodAutoscaler</strong> for scaling workloads.</li>
    </ul>
    <p class="normal">In the following subsections, we’ll list the resources that belong to each group with the API group they belong to. We will not specify the version here because APIs move rapidly from alpha to beta <a id="_idIndexMarker077"/>to <strong class="keyWord">GA</strong> (<strong class="keyWord">general availability</strong>) and from V1 to V2, and so on.</p>
    <h4 class="heading-4">Workloads resource category</h4>
    <p class="normal">The <a id="_idIndexMarker078"/>workloads category contains the<a id="_idIndexMarker079"/> following resources with their corresponding API groups:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Container</strong>: core</li>
      <li class="bulletList"><strong class="keyWord">CronJob</strong>: batch</li>
      <li class="bulletList"><strong class="keyWord">ControllerRevision</strong>: apps</li>
      <li class="bulletList"><strong class="keyWord">DaemonSet</strong>: apps</li>
      <li class="bulletList"><strong class="keyWord">Deployment</strong>: apps</li>
      <li class="bulletList"><strong class="keyWord">HorizontalPodAutoscaler</strong>: autoscaling</li>
      <li class="bulletList"><strong class="keyWord">Job</strong>: batch</li>
      <li class="bulletList"><strong class="keyWord">Pod</strong>: core</li>
      <li class="bulletList"><strong class="keyWord">PodTemplate</strong>: core</li>
      <li class="bulletList"><strong class="keyWord">PriorityClass</strong>: scheduling.k8s.io</li>
      <li class="bulletList"><strong class="keyWord">ReplicaSet</strong>: apps</li>
      <li class="bulletList"><strong class="keyWord">ReplicationController</strong>: core</li>
      <li class="bulletList"><strong class="keyWord">StatefulSet</strong>: apps</li>
    </ul>
    <p class="normal">Controllers <a id="_idIndexMarker080"/>create containers <a id="_idIndexMarker081"/>within pods. Pods execute containers and offer necessary dependencies, such as shared or persistent storage volumes, as well as configuration or secret data injected into the containers.</p>
    <p class="normal">Here is a detailed description of one of the most common operations, which gets a list of all the pods across all namespaces as a REST API:</p>
    <pre class="programlisting code"><code class="hljs-code">GET /api/v1/pods
</code></pre>
    <p class="normal">It accepts various query parameters (all optional):</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">fieldSelector</code>: Specifies a selector to narrow down the returned objects based on their fields. The default behavior includes all objects.</li>
      <li class="bulletList"><code class="inlineCode">labelSelector</code>: Defines a selector to filter the returned objects based on their labels. By default, all objects are included.</li>
      <li class="bulletList"><code class="inlineCode">limit</code>/<code class="inlineCode">continue</code>: The <code class="inlineCode">limit</code> parameter specifies the maximum number of responses to be returned in a list call. If there are more items available, the server sets the <code class="inlineCode">continue</code> field in the list metadata. This value can be used with the initial query to fetch the next set of results.</li>
      <li class="bulletList"><code class="inlineCode">pretty</code>: When set to <code class="inlineCode">'true'</code>, the output is formatted in a human-readable manner.</li>
      <li class="bulletList"><code class="inlineCode">resourceVersion</code>: Sets a constraint on the acceptable resource versions that can be served by the request. If not specified, it defaults to unset.</li>
      <li class="bulletList"><code class="inlineCode">resourceVersionMatch</code>: Determines how the <code class="inlineCode">resourceVersion</code> constraint is applied in list calls. If not specified, it defaults to unset.</li>
      <li class="bulletList"><code class="inlineCode">timeoutSeconds</code>: Specifies a timeout duration for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.</li>
      <li class="bulletList"><code class="inlineCode">watch</code>: Enables the monitoring of changes to the described resources and returns a continuous stream of notifications for additions, updates, and removals. The <code class="inlineCode">resourceVersion</code> parameter must be specified.</li>
    </ul>
    <h4 class="heading-4">Discovery and load balancing</h4>
    <p class="normal">Workloads <a id="_idIndexMarker082"/>in a <a id="_idIndexMarker083"/>cluster are only accessible within the cluster by default. To make them accessible externally, either a <code class="inlineCode">LoadBalancer</code> or a <code class="inlineCode">NodePort</code> Service needs to be used. However, for development purposes, internally accessible workloads can be accessed through the API server using the “kubectl proxy” command:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">Endpoints</code>: <code class="inlineCode">core</code></li>
      <li class="bulletList"><code class="inlineCode">EndpointSlice</code>: <code class="inlineCode">discovery.k8s.io/v1</code></li>
      <li class="bulletList"><code class="inlineCode">Ingress</code>: <code class="inlineCode">networking.k8s.io</code></li>
      <li class="bulletList"><code class="inlineCode">IngressClass</code>: <code class="inlineCode">networking.k8s.io</code></li>
      <li class="bulletList"><code class="inlineCode">Service</code>: <code class="inlineCode">core</code></li>
    </ul>
    <h4 class="heading-4">Config and storage</h4>
    <p class="normal">Dynamic <a id="_idIndexMarker084"/>configuration<a id="_idIndexMarker085"/> without redeployment and secret management are cornerstones of Kubernetes and running complex distributed applications on your Kubernetes cluster. The secret and configuration are not baked into container images and are stored in the Kubernetes state store (usually etcd). Kubernetes also provides a lot of abstractions for managing arbitrary storage. Here are some of the primary resources:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">ConfigMap</code>: <code class="inlineCode">core</code></li>
      <li class="bulletList"><code class="inlineCode">CSIDriver</code>: <code class="inlineCode">storage.k8s.io</code></li>
      <li class="bulletList"><code class="inlineCode">CSINode</code>: <code class="inlineCode">storage.k8s.io</code></li>
      <li class="bulletList"><code class="inlineCode">CSIStorageCapacity</code>: <code class="inlineCode">storage.k8s.io</code></li>
      <li class="bulletList"><code class="inlineCode">Secret</code>: <code class="inlineCode">core</code></li>
      <li class="bulletList"><code class="inlineCode">PersistentVolumeClaim</code>: <code class="inlineCode">core</code></li>
      <li class="bulletList"><code class="inlineCode">StorageClass</code>: <code class="inlineCode">storage.k8s.io</code></li>
      <li class="bulletList"><code class="inlineCode">Volume</code>: <code class="inlineCode">core</code></li>
      <li class="bulletList"><code class="inlineCode">VolumeAttachment</code>: <code class="inlineCode">storage.k8s.io</code></li>
    </ul>
    <h4 class="heading-4">Metadata</h4>
    <p class="normal">The <a id="_idIndexMarker086"/>metadata<a id="_idIndexMarker087"/> resources typically show up as sub-resources of the resources they configure. For example, a limit range is defined at the namespace level and can specify:</p>
    <ul>
      <li class="bulletList">The range of compute resource usage (minimum and maximum) for pods or containers within a namespace.</li>
      <li class="bulletList">The range of storage requests (minimum and maximum) per <code class="inlineCode">PersistentVolumeClaim</code> within a namespace.</li>
      <li class="bulletList">The ratio between the resource request and limit for a specific resource within a namespace.</li>
      <li class="bulletList">The default request/limit for compute resources within a namespace, which are automatically injected into containers at runtime.</li>
    </ul>
    <p class="normal">You <a id="_idIndexMarker088"/>will <a id="_idIndexMarker089"/>not interact with these objects directly most of the time. There are many metadata resources. You can find the complete list here: <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#-strong-metadata-apis-strong-"><span class="url">https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#-strong-metadata-apis-strong-</span></a>.</p>
    <h4 class="heading-4">Cluster</h4>
    <p class="normal">The<a id="_idIndexMarker090"/> resources in the cluster category <a id="_idIndexMarker091"/>are designed for use by cluster operators as opposed to developers. There are many resources in this category as well. Here are some of the most important resources:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">Namespace</code>: <code class="inlineCode">core</code></li>
      <li class="bulletList"><code class="inlineCode">Node</code>: <code class="inlineCode">core</code></li>
      <li class="bulletList"><code class="inlineCode">PersistentVolume</code>: <code class="inlineCode">core</code></li>
      <li class="bulletList"><code class="inlineCode">ResourceQuota</code>: <code class="inlineCode">core</code></li>
      <li class="bulletList"><code class="inlineCode">Role</code>: <code class="inlineCode">rbac.authorization.k8s.io</code></li>
      <li class="bulletList"><code class="inlineCode">RoleBinding</code>: <code class="inlineCode">rbac.authorization.k8s.io</code></li>
      <li class="bulletList"><code class="inlineCode">ClusterRole</code>: <code class="inlineCode">rbac.authorization.k8s.io</code></li>
      <li class="bulletList"><code class="inlineCode">ClusterRoleBinding</code>: <code class="inlineCode">rbac.authorization.k8s.io</code></li>
      <li class="bulletList"><code class="inlineCode">NetworkPolicy</code>: <code class="inlineCode">networking.k8s.io</code></li>
    </ul>
    <p class="normal">Now that we understand how Kubernetes organizes and exposes its capabilities via API groups and resource categories, let’s see how it manages the physical infrastructure and keeps it up with the state of the cluster.</p>
    <h2 id="_idParaDest-46" class="heading-2">Kubernetes components</h2>
    <p class="normal">A Kubernetes cluster <a id="_idIndexMarker092"/>has several control plane components used to control the cluster, as well as node components that run on each worker node. Let’s get to know all these components and how they work together.</p>
    <h3 id="_idParaDest-47" class="heading-3">Control plane components</h3>
    <p class="normal">The <a id="_idIndexMarker093"/>control plane components can all run on one node, but in a highly available setup or a very large cluster, they may be spread across multiple nodes.</p>
    <h4 class="heading-4">API server</h4>
    <p class="normal">The<a id="_idIndexMarker094"/> Kubernetes API server exposes the Kubernetes REST API. It <a id="_idIndexMarker095"/>can easily scale horizontally as it is stateless and stores all the data in the etcd cluster (or another data store in Kubernetes distributions like k3s). The API server is the embodiment of the Kubernetes control plane.</p>
    <h4 class="heading-4">etcd</h4>
    <p class="normal">etcd is a<a id="_idIndexMarker096"/> highly reliable distributed data store. Kubernetes<a id="_idIndexMarker097"/> uses it to store the entire cluster state. In small, transient clusters a single instance of etcd can run on the same node with all the other control plane components. But, for more substantial clusters, it is typical to have a 3-node or even 5-node etcd cluster for redundancy and high availability.</p>
    <h4 class="heading-4">Kube controller manager</h4>
    <p class="normal">The <a id="_idIndexMarker098"/>Kube controller manager<a id="_idIndexMarker099"/> is a collection of various managers rolled up into one binary. It contains the replica set controller, the pod controller, the service controller, the endpoints controller, and others. All these managers watch over the state of the cluster via the API, and their job is to steer the cluster into the desired state.</p>
    <h4 class="heading-4">Cloud controller manager</h4>
    <p class="normal">When <a id="_idIndexMarker100"/>running in the cloud, Kubernetes <a id="_idIndexMarker101"/>allows cloud providers to integrate their platform for the purpose of managing nodes, routes, services, and volumes. The cloud provider code interacts with Kubernetes code. It replaces some of the functionality of the Kube controller manager. When running Kubernetes with a cloud controller manager you must set the Kube controller manager flag <code class="inlineCode">--cloud-provider</code> to <code class="inlineCode">external</code>. This will disable the control loops that the cloud controller manager is taking over. </p>
    <p class="normal">The cloud controller manager was introduced in Kubernetes 1.6, and it’s being used by multiple cloud providers already such as:</p>
    <ul>
      <li class="bulletList">GCP</li>
      <li class="bulletList">AWS</li>
      <li class="bulletList">Azure</li>
      <li class="bulletList">BaiduCloud</li>
      <li class="bulletList">Digital Ocean</li>
      <li class="bulletList">Oracle</li>
      <li class="bulletList">Linode</li>
    </ul>
    <p class="normal">OK. Let’s look at some code. The <a id="_idIndexMarker102"/>specific code is not that important. The goal is just to give you a taste of what Kubernetes code <a id="_idIndexMarker103"/>looks like. Kubernetes is implemented in Go. A quick note about Go to help you parse the code: the method name comes first, followed by the method’s parameters in parentheses. Each parameter is a pair, consisting of a name followed by its type. Finally, the return values are specified. Go allows multiple return types. It is very common to return an error object in addition to the actual result. If everything is OK, the error object will be nil.</p>
    <p class="normal">Here is the main interface of the <code class="inlineCode">cloudprovider</code> package:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> cloudprovider
<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"context"</span>
    <span class="hljs-string">"errors"</span>
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"strings"</span>
    v1 <span class="hljs-string">"k8s.io/api/core/v1"</span>
    <span class="hljs-string">"k8s.io/apimachinery/pkg/types"</span>
    <span class="hljs-string">"k8s.io/client-go/informers"</span>
    clientset <span class="hljs-string">"k8s.io/client-go/kubernetes"</span>
    restclient <span class="hljs-string">"k8s.io/client-go/rest"</span>
)
<span class="hljs-comment">// Interface is an abstract, pluggable interface for cloud providers.</span>
<span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> {
    Initialize(clientBuilder ControllerClientBuilder, stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{})
    LoadBalancer() (LoadBalancer, <span class="hljs-type">bool</span>)
    Instances() (Instances, <span class="hljs-type">bool</span>)
    InstancesV2() (InstancesV2, <span class="hljs-type">bool</span>)
    Zones() (Zones, <span class="hljs-type">bool</span>)
    Clusters() (Clusters, <span class="hljs-type">bool</span>)
    Routes() (Routes, <span class="hljs-type">bool</span>)
    ProviderName() <span class="hljs-type">string</span>
    HasClusterID() <span class="hljs-type">bool</span>
}
</code></pre>
    <p class="normal">Most of <a id="_idIndexMarker104"/>the methods return other interfaces <a id="_idIndexMarker105"/>with their own method. For example, here is the <code class="inlineCode">LoadBalancer</code> interface:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">type</span> LoadBalancer <span class="hljs-keyword">interface</span> {
    GetLoadBalancer(ctx context.Context, clusterName <span class="hljs-type">string</span>, service *v1.Service) (status *v1.LoadBalancerStatus, exists <span class="hljs-type">bool</span>, err <span class="hljs-type">error</span>)	
    GetLoadBalancerName(ctx context.Context, clusterName <span class="hljs-type">string</span>, service *v1.Service) <span class="hljs-type">string</span>
    EnsureLoadBalancer(ctx context.Context, clusterName <span class="hljs-type">string</span>, service *v1.Service, nodes []*v1.Node) (*v1.LoadBalancerStatus, <span class="hljs-type">error</span>)
    UpdateLoadBalancer(ctx context.Context, clusterName <span class="hljs-type">string</span>, service *v1.Service, nodes []*v1.Node) <span class="hljs-type">error</span>
    EnsureLoadBalancerDeleted(ctx context.Context, clusterName <span class="hljs-type">string</span>, service *v1.Service) <span class="hljs-type">error</span>
}
</code></pre>
    <h4 class="heading-4">Kube scheduler</h4>
    <p class="normal">The <code class="inlineCode">kube-scheduler</code> is <a id="_idIndexMarker106"/>responsible for scheduling <a id="_idIndexMarker107"/>pods into nodes. This is a very complicated task as it needs to consider multiple interacting factors, such as:</p>
    <ul>
      <li class="bulletList">Resource requirements</li>
      <li class="bulletList">Service requirements</li>
      <li class="bulletList">Hardware/software policy constraints</li>
      <li class="bulletList">Node affinity and anti-affinity specifications</li>
      <li class="bulletList">Pod affinity and anti-affinity specifications</li>
      <li class="bulletList">Taints and tolerations</li>
      <li class="bulletList">Local storage requirements</li>
      <li class="bulletList">Data locality</li>
      <li class="bulletList">Deadlines</li>
    </ul>
    <p class="normal">If you need some special scheduling logic not covered by the default Kube scheduler, you can replace it with your own custom scheduler. You can also run your custom scheduler side by side with the default scheduler and have your custom scheduler schedule only a subset of the pods.</p>
    <h4 class="heading-4">DNS</h4>
    <p class="normal">Starting <a id="_idIndexMarker108"/>with Kubernetes 1.3, a DNS service is part of <a id="_idIndexMarker109"/>the standard Kubernetes cluster. It is scheduled as a regular pod. Every service (except headless services) receives a DNS name. Pods can receive a DNS name too. This is very useful for automatic discovery.</p>
    <p class="normal">We covered all the control plane components. Let’s look at the Kubernetes components running on each node.</p>
    <h3 id="_idParaDest-48" class="heading-3">Node components</h3>
    <p class="normal">Nodes in the <a id="_idIndexMarker110"/>cluster need a couple of components <a id="_idIndexMarker111"/>to interact with the API server, receive workloads to execute, and update the API server regarding their status.</p>
    <h4 class="heading-4">Proxy</h4>
    <p class="normal">The<a id="_idIndexMarker112"/> kube-proxy does low-level network housekeeping on each node. It reflects the Kubernetes services locally and can do TCP and UDP forwarding. It finds cluster IPs via environment variables or DNS.</p>
    <h4 class="heading-4">kubelet</h4>
    <p class="normal">The<a id="_idIndexMarker113"/> kubelet is<a id="_idIndexMarker114"/> the Kubernetes representative on the node. It oversees communicating with the API server and manages the running pods. That includes the following:</p>
    <ul>
      <li class="bulletList">Receive pod specs</li>
      <li class="bulletList">Download pod secrets from the API server</li>
      <li class="bulletList">Mount volumes</li>
      <li class="bulletList">Run the pod’s containers (via the configured container runtime)</li>
      <li class="bulletList">Report the status of the node and each pod</li>
      <li class="bulletList">Run container liveness, readiness, and startup probes</li>
    </ul>
    <p class="normal">In this section, we dug into the guts of Kubernetes and explored its architecture from a very high level of vision and supported design patterns, through its APIs and the components used to control and manage the cluster. In the next section, we will take a quick look at the various runtimes that Kubernetes supports.</p>
    <h1 id="_idParaDest-49" class="heading-1">Kubernetes container runtimes</h1>
    <p class="normal">Kubernetes<a id="_idIndexMarker115"/> originally only supported Docker as a container runtime engine. But that is no longer the case. Kubernetes now supports any runtime that implements the CRI interface.</p>
    <p class="normal">In this section, you’ll get a closer look at the CRI and get to know some runtime engines that implement it. At the end of this section, you’ll be able to make a well-informed decision about which container runtime is appropriate for your use case and under what circumstances you may switch or even combine multiple runtimes in the same system.</p>
    <h2 id="_idParaDest-50" class="heading-2">The Container Runtime Interface (CRI)</h2>
    <p class="normal">The<a id="_idIndexMarker116"/> CRI is a gRPC API, containing<a id="_idIndexMarker117"/> specifications/requirements and libraries for container runtimes to integrate with the kubelet on a node. In Kubernetes 1.7 the internal Docker integration in Kubernetes was replaced with a CRI-based integration. This was a big deal. It opened the door to multiple implementations that can take advantage of advances in the container world. The kubelet doesn’t need to interface directly with multiple runtimes. Instead, it can talk to any CRI-compliant container runtime. The following diagram illustrates the flow:</p>
    <figure class="mediaobject"><img src="../Images/B18998_01_02.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.2: kubelet and cri</p>
    <p class="normal">There are two gRPC service interfaces <code class="inlineCode">ImageService</code> and <code class="inlineCode">RuntimeService</code> that CRI container runtimes (or shims) must implement. The <code class="inlineCode">ImageService</code> is responsible for managing images. Here is the gRPC/protobuf interface (this is not Go):</p>
    <pre class="programlisting code"><code class="hljs-code">service ImageService {
    rpc ListImages(ListImagesRequest) returns (ListImagesResponse) {}
    rpc ImageStatus(ImageStatusRequest) returns (ImageStatusResponse) {}
    rpc PullImage(PullImageRequest) returns (PullImageResponse) {}
    rpc RemoveImage(RemoveImageRequest) returns (RemoveImageResponse) {}
    rpc ImageFsInfo(ImageFsInfoRequest) returns (ImageFsInfoResponse) {}
}
</code></pre>
    <p class="normal">The <code class="inlineCode">RuntimeService</code> is responsible <a id="_idIndexMarker118"/>for managing <a id="_idIndexMarker119"/>pods and containers. Here is the gRPC/protobuf interface:</p>
    <pre class="programlisting code"><code class="hljs-code">service RuntimeService {
    rpc Version(VersionRequest) returns (VersionResponse) {}
    rpc RunPodSandbox(RunPodSandboxRequest) returns (RunPodSandboxResponse) {}
    rpc StopPodSandbox(StopPodSandboxRequest) returns (StopPodSandboxResponse) {}
    rpc RemovePodSandbox(RemovePodSandboxRequest) returns (RemovePodSandboxResponse) {}
    rpc PodSandboxStatus(PodSandboxStatusRequest) returns (PodSandboxStatusResponse) {}
    rpc ListPodSandbox(ListPodSandboxRequest) returns (ListPodSandboxResponse) {}
    rpc CreateContainer(CreateContainerRequest) returns (CreateContainerResponse) {}
    rpc StartContainer(StartContainerRequest) returns (StartContainerResponse) {}
    rpc StopContainer(StopContainerRequest) returns (StopContainerResponse) {}
    rpc RemoveContainer(RemoveContainerRequest) returns (RemoveContainerResponse) {}
    rpc ListContainers(ListContainersRequest) returns (ListContainersResponse) {}
    rpc ContainerStatus(ContainerStatusRequest) returns (ContainerStatusResponse) {}
    rpc UpdateContainerResources(UpdateContainerResourcesRequest) returns (UpdateContainerResourcesResponse) {}
    rpc ExecSync(ExecSyncRequest) returns (ExecSyncResponse) {}
    rpc Exec(ExecRequest) returns (ExecResponse) {}
    rpc Attach(AttachRequest) returns (AttachResponse) {}
    rpc PortForward(PortForwardRequest) returns (PortForwardResponse) {}
    rpc ContainerStats(ContainerStatsRequest) returns (ContainerStatsResponse) {}
    rpc ListContainerStats(ListContainerStatsRequest) returns (ListContainerStatsResponse) {}
    rpc UpdateRuntimeConfig(UpdateRuntimeConfigRequest) returns (UpdateRuntimeConfigResponse) {}
    rpc Status(StatusRequest) returns (StatusResponse) {}
}
</code></pre>
    <p class="normal">The<a id="_idIndexMarker120"/> data types used as <a id="_idIndexMarker121"/>arguments and return types are called messages and are also defined as part of the API. Here is one of them:</p>
    <pre class="programlisting code"><code class="hljs-code">message CreateContainerRequest {
    <span class="hljs-type">string</span> pod_sandbox_id = <span class="hljs-number">1</span>;
    ContainerConfig config = <span class="hljs-number">2</span>;
    PodSandboxConfig sandbox_config = <span class="hljs-number">3</span>;
}
</code></pre>
    <p class="normal">As you can see messages can be embedded inside each other. The <code class="inlineCode">CreateContainerRequest</code> message has one string field and two other fields, which are themselves messages: <code class="inlineCode">ContainerConfig</code> and <code class="inlineCode">PodSandboxConfig</code>.</p>
    <div class="note">
      <p class="normal">To learn more about gRPC and CRI check out the following resources:</p>
      <p class="normal"><a href="https://grpc.io"><span class="url">https://grpc.io</span></a></p>
      <p class="normal"><a href="https://kubernetes.io/docs/concepts/architecture/cri/"><span class="url">https://kubernetes.io/docs/concepts/architecture/cri/</span></a></p>
    </div>
    <p class="normal">Now that you are familiar at the code level with what Kubernetes considers a runtime engine, let’s look at the individual runtime engines briefly.</p>
    <h2 id="_idParaDest-51" class="heading-2">Docker</h2>
    <p class="normal">Docker<a id="_idIndexMarker122"/> used to be the 800-pound gorilla of containers. Kubernetes <a id="_idIndexMarker123"/>was originally designed to only manage Docker containers. The multi-runtime capability was first introduced in Kubernetes 1.3 and the CRI in Kubernetes 1.5. Until then, Kubernetes could only manage Docker containers. Even after the CRI was introduced a Dockershim remained in the Kubernetes source code, and it was only removed in Kubernetes 1.24. Since then, Docker doesn’t get any special treatment anymore.</p>
    <p class="normal">I assume you’re very familiar with Docker and what it brings to the table if you are reading this book. Docker<a id="_idIndexMarker124"/> enjoys tremendous popularity and growth, but there is also a lot of criticism towards it. Critics often mention the following concerns:</p>
    <ul>
      <li class="bulletList">Security</li>
      <li class="bulletList">Difficulty setting up multi-container applications (in particular, networking)</li>
      <li class="bulletList">Development, monitoring, and logging</li>
      <li class="bulletList">Limitations of Docker containers running one command</li>
      <li class="bulletList">Releasing half-baked features too fast</li>
    </ul>
    <p class="normal">Docker is<a id="_idIndexMarker125"/> aware of the criticisms and has addressed some of these concerns. In particular, Docker invested in its Docker Swarm product. Docker Swarm is a Docker-native orchestration solution that competes with Kubernetes. It is simpler to use than Kubernetes, but it’s not as powerful or mature.</p>
    <p class="normal">Starting with Docker 1.11, released in April 2016, Docker has changed the way it runs containers. The runtime now uses containerd and runC to <a id="_idIndexMarker126"/>run <strong class="keyWord">Open Container Initiative</strong> (<strong class="keyWord">OCI</strong>) images in containers:</p>
    <figure class="mediaobject"><img src="../Images/B18998_01_03.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.3: Docker and OCI</p>
    <p class="normal">Starting with Docker 1.12, swarm mode is included in the Docker daemon natively, which upset some people due to bloat and scope creep. As a result, more people turned to other container runtimes.</p>
    <p class="normal">In September 2021, Docker <a id="_idIndexMarker127"/>required a paid subscription to <a id="_idIndexMarker128"/>Docker Desktop for large organizations. This wasn’t popular, as you might expect, and lots of organizations scrambled to find an alternative. Docker Desktop is a client-side distribution and UI for Docker and doesn’t impact the container runtime. But it eroded Docker’s reputation and goodwill with the community even further.</p>
    <h2 id="_idParaDest-52" class="heading-2">containerd</h2>
    <p class="normal">containerd <a id="_idIndexMarker129"/>has been a graduated CNCF project <a id="_idIndexMarker130"/>since 2019. It is now a mainstream option for Kubernetes containers. All major cloud providers support it and as of Kubernetes 1.24, it is the default container runtime.</p>
    <p class="normal">In addition, the Docker container runtime is built on top of containerd as well.</p>
    <h2 id="_idParaDest-53" class="heading-2">CRI-O</h2>
    <p class="normal">CRI-O is a<a id="_idIndexMarker131"/> CNCF incubator project. It is designed to <a id="_idIndexMarker132"/>provide an integration path between Kubernetes and OCI-compliant container runtimes like Docker. CRI-O <a id="_idIndexMarker133"/>provides the following capabilities:</p>
    <ul>
      <li class="bulletList">Support for multiple image formats including the existing Docker image format</li>
      <li class="bulletList">Support for multiple means to download images including trust and image verification</li>
      <li class="bulletList">Container image management (managing image layers, overlay filesystems, etc.)</li>
      <li class="bulletList">Container process life cycle management</li>
      <li class="bulletList">Monitoring and logging required to satisfy the CRI</li>
      <li class="bulletList">Resource isolation as required by the CRI</li>
    </ul>
    <p class="normal">It supports runC and Kata containers right now, but any OCI-compliant container runtime can be plugged in and integrated with Kubernetes.</p>
    <h2 id="_idParaDest-54" class="heading-2">Lightweight VMs</h2>
    <p class="normal">Kubernetes<a id="_idIndexMarker134"/> runs containers from different applications on the same node, sharing the same OS. This allows for running a lot of <a id="_idIndexMarker135"/>containers in a very efficient manner. However, container isolation is a serious security concern and multiple cases of privilege escalation occurred, which drove a lot of interest in a different approach. Lightweight VMs provide strong VM-level isolation, but are not as heavyweight as standard VMs, which allow them to operate as container runtimes on Kubernetes. Some prominent projects are:</p>
    <ul>
      <li class="bulletList">AWS Firecracker</li>
      <li class="bulletList">Google gVisor</li>
      <li class="bulletList">Kata Containers</li>
      <li class="bulletList">Singularity</li>
      <li class="bulletList">SmartOS</li>
    </ul>
    <p class="normal">In this section, we covered the various runtime engines that Kubernetes supports as well as the trend toward standardization, convergence, and externalizing the runtime support from core Kubernetes.</p>
    <h1 id="_idParaDest-55" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we covered a lot of ground. You learned about the organization, design, and architecture of Kubernetes. Kubernetes is an orchestration platform for microservice-based applications running as containers. Kubernetes clusters have a control plane and worker nodes. Containers run within pods. Each pod runs on a single physical or virtual machine. Kubernetes directly supports many concepts, such as services, labels, and persistent storage. You can implement various distributed systems design patterns on Kubernetes. Container runtimes just need to implement the CRI. Docker, containerd, CRI-O, and more are supported.</p>
    <p class="normal">In <em class="chapterRef">Chapter 2</em>, <em class="italic">Creating Kubernetes Clusters</em>, we will explore the various ways to create Kubernetes clusters, discuss when to use different options, and build a local multi-node cluster.</p>
    <h1 id="_idParaDest-56" class="heading-1">Join us on Discord!</h1>
    <p class="normal">Read this book alongside other users, cloud experts, authors, and like-minded professionals.</p>
    <p class="normal">Ask questions, provide solutions to other readers, chat with the authors via. Ask Me Anything sessions and much more.</p>
    <p class="normal">Scan the QR code or visit the link to join the community now.</p>
    <p class="normal"><a href="https://packt.link/cloudanddevops"><span class="url">https://packt.link/cloudanddevops</span></a></p>
    <p class="normal"><img src="../Images/QR_Code844810820358034203.png" alt=""/></p>
  </div>
</body></html>