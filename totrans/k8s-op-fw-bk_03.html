<html><head></head><body>
		<div id="_idContainer016">
			<h1 id="_idParaDest-33"><em class="italic"><a id="_idTextAnchor032"/>Chapter 2</em>: Understanding How Operators Interact with Kubernetes</h1>
			<p>Now that we understand <em class="italic">what</em> kinds of things an Operator does (and <em class="italic">why</em> it does them), we can begin to explore <em class="italic">how</em> it performs these tasks. After identifying a use case for an Operator, taking the steps to lay out its technical design is the next step of the process. Though this is the period before any actual coding begins, it is still an essential part of development. This is the standard approach for almost any software project, and in this chapter, we will frame it in the context of Kubernetes.</p>
			<p>During this planning phase, there are several factors to consider and questions to answer that will help guide the Operator's design. These factors are both technical and organic since your Operator needs to interact with not only the Kubernetes resources in your cluster but also the human resources of your engineers and administrators.</p>
			<p>This chapter will explain some of the key considerations that should factor into your Operator's design. First, we will provide an introduction to some of the native Kubernetes components and resources that many Operators interact with. By looking at the ways that Operators consume these resources and the use cases for doing so, we can start looking at some of the patterns for functional Operator design. Next, we'll look at designing an Operator while keeping its unique user base in mind and the ways that the design can benefit users. Finally, we'll discuss some of the best practices for futureproofing an Operator for ongoing developments.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Interacting with Kubernetes cluster resources</li>
				<li>Identifying your users and maintainers</li>
				<li>Designing beneficial features for your Operator</li>
				<li>Planning for evolving changes in your Operator</li>
			</ul>
			<p>The goal of this chapter is to help guide you through the early design process of an Operator. Poorly planning an Operator's design can lead to many changes and updates being needed during the Operator's life cycle. This puts stress on engineering resources, but it can also confuse and frustrate users. That is why most of this chapter will focus on non-technical specifics. However, we do need to know some baseline technical interactions to shape these for our users. By the end of this chapter, you may find that you are not currently able to address all of the pre-design concerns that are described here. This is fine – the important part is to understand certain concepts that you must be aware of as you head into development.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Interacting with Kubernetes cluster resources</h1>
			<p>Before you decide on how to design an Operator with users' experiences in mind, it is important to <a id="_idIndexMarker072"/>understand what an Operator is capable of from a technical standpoint. Having a mindset for the specific capabilities of the Operator's code base will help guide the rest of the design process around what is truly possible. Otherwise, trying to define the scope of an Operator based solely on user requests without considering feasibility could lead to over-promising and under-delivering on functionality and usability.</p>
			<p>The possibilities of any Operator are inherently limited by the underlying features of the Kubernetes platform. This platform is composed of different native cluster resources, some of which you may already be familiar with. This section will examine the most common resources that Operators work with and explain how they can and should use them. When you're developing an Operator, these resources will usually be consumed via the Kubernetes client libraries, which allow any application to interact with cluster resources.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Pods, ReplicaSets, and Deployments</h2>
			<p>Perhaps the <a id="_idIndexMarker073"/>most basic unit of a Kubernetes cluster <a id="_idIndexMarker074"/>architecture is the <strong class="bold">Pod</strong>. These objects represent one or more running containers. Under the hood, a Pod is essentially a definition <a id="_idIndexMarker075"/>of container images that the <strong class="bold">Kubelet</strong> can use to instruct the container runtime where and how to run certain containers. Applications are deployed on Kubernetes as Pods, Kubernetes itself is made up of many system Pods, and Operators are deployed as Pods as well.</p>
			<p>While Pods are essential to a Kubernetes cluster, they are usually too atomic to manage manually. It is also often necessary to run multiple copies of an application, which is where <strong class="bold">ReplicaSets</strong> come in. The <a id="_idIndexMarker076"/>role of ReplicaSets is to define several replicas for a certain template of Pods.</p>
			<p>However, ReplicaSets <a id="_idIndexMarker077"/>are also limited in their abilities. They simply maintain the number of replicas of a Pod on the cluster. <strong class="bold">Deployments</strong> add even <a id="_idIndexMarker078"/>more functionality to <a id="_idIndexMarker079"/>this by encompassing ReplicaSets and defining further controls such as rollout strategies and revision management for rollbacks.</p>
			<p>From an Operator developer's perspective, Deployments are usually the most important resources to interact with. The advanced mechanics of Deployments provide flexibility for an application's runtime. These mechanics can be abstracted or restricted from users since they will only be interacting with the Operator through its CRD (rather than using the Deployment directly). However, the flexibility is still there to add it later or automatically program it into the Operator's reconciliation logic.</p>
			<p>The following diagram shows how the encapsulation of application workload Pods within ReplicaSets and Deployments can still be managed by an Operator. In this example, the Operator only cares about the Deployment, but the status of that Deployment reflects the health of the actual workloads within it:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B18147_Figure_2.1.jpg" alt="Figure 2.1 – An Operator managing a Deployment with two ReplicaSets, each with several Pods"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – An Operator managing a Deployment with two ReplicaSets, each with several Pods</p>
			<p>An Operator will usually be installed and managed by a Deployment. The Deployment then provides a good owner reference of all the resource components that comprise the Operator for garbage collection. This is useful for upgrading and uninstalling the Operator.</p>
			<p>Although it <a id="_idIndexMarker080"/>is not uncommon for an Operator <a id="_idIndexMarker081"/>to directly manage some Pods or <a id="_idIndexMarker082"/>ReplicaSets, there are certainly tradeoffs. For one, such an Operator's design would lead to a simpler application architecture at the expense of the capabilities and conveniences of using Deployments. So, when you're deciding if your Operator will directly manage Pods or a Deployment, it is important to consider the intent of the application itself and the needs of the design.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Custom resource definitions</h2>
			<p>As we mentioned in <a href="B18147_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introducing the Operator Framework</em>, most Operators <a id="_idIndexMarker083"/>are dependent on <strong class="bold">CustomResourceDefinitions</strong> (<strong class="bold">CRDs</strong>). CRDs are native Kubernetes resources that allow users to extend the Kubernetes platform with their resource definitions at runtime. They are <a id="_idIndexMarker084"/>like plugins to the Kubernetes API. Upon installing a CRD in the cluster, it provides the API server with information on how to handle and validate objects of that custom type.</p>
			<p>The most common use case for an Operator to consume CRDs is to provide its configuration object as one. Once the Kubernetes API knows how to handle this CRD, the Operator or user will then create the Operator object from YAML (just like when creating a Pod or Deployment).</p>
			<p>Users can then interact solely with the Operator resource, rather than having to manually tweak the Operator's Deployment to adjust its settings. This allows developers to present a curated frontend user experience and abstract away the Kubernetes internals of the application, all in an interface that feels just like any other native Kubernetes resource object.</p>
			<p>But Operators can package more than just their configuration in a CRD. Depending on the application that's being managed, an Operator can also install and monitor custom resources that are needed by the application. Because of the many use cases for CRDs, it's not unusual for an application to provide and depend on its custom resource objects. An application Operator should know these resources and be able to install and manage them too.</p>
			<p>CRDs are a core aspect of Operator development because, without them, all that is left are the core Kubernetes resources (such as Pods, ReplicaSets, and Deployments) to achieve our goals. While these resources can accomplish many things, they do not have the inherent <a id="_idIndexMarker085"/>flexibility to be customized to any specific need. An Operator's custom resource object provides a user interface that seamlessly <a id="_idIndexMarker086"/>fits into a cluster with other Kubernetes objects. In addition, the Kubernetes API clients and Operator SDK provide code tools so that you can easily interact with these custom resources, just like they were any other cluster resource. </p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>ServiceAccounts, roles, and RoleBindings (RBAC)</h2>
			<p>Access policies are often overlooked but can be critical to ensuring the stability and security <a id="_idIndexMarker087"/>of your and your users' clusters. Just like an application manages other cluster components, an Operator is going to require <a id="_idIndexMarker088"/>certain RBAC policies to complete its job within the necessary access.</p>
			<p>Operators require RBAC policies to manage their Operands. Defining an RBAC policy for any application <a id="_idIndexMarker089"/>in Kubernetes starts with a <strong class="bold">role</strong>. Roles define the types of API objects that an application or user has access to, as well as the verbs that are allowed to be used with those objects. The following is an example of a role:</p>
			<pre class="source-code">apiVersion: rbac.authorization.k8s.io/v1</pre>
			<pre class="source-code">kind: Role</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  namespace: my-operators-namespace</pre>
			<pre class="source-code">  name: my-operator-role</pre>
			<pre class="source-code">rules:</pre>
			<pre class="source-code">- apiGroups:</pre>
			<pre class="source-code">  - operator.sample.com</pre>
			<pre class="source-code">  resources:</pre>
			<pre class="source-code">  - "*"</pre>
			<pre class="source-code">  verbs:</pre>
			<pre class="source-code">  - "*"</pre>
			<pre class="source-code">- apiGroups:</pre>
			<pre class="source-code">  - ""</pre>
			<pre class="source-code">  resources:</pre>
			<pre class="source-code">  - pods</pre>
			<pre class="source-code">  verbs:</pre>
			<pre class="source-code">  - get</pre>
			<pre class="source-code">  - watch</pre>
			<pre class="source-code">  - list</pre>
			<p>This sample <a id="_idIndexMarker090"/>creates a role that allows an Operator to <em class="italic">get</em>, <em class="italic">watch</em>, and <em class="italic">list</em> the Pods in the specified namespace. It also allows the <a id="_idIndexMarker091"/>Operator to access all the resources under the <strong class="source-inline">operator.sample.com</strong> API group. This is included to indicate how an <a id="_idIndexMarker092"/>Operator gains access to its CRD. Since there is nothing inherently tying the Operator to the CRD, it still needs RBAC access to that object, just like it would with any other API object. In this case, the CRD would be created under that API group.</p>
			<p>Roles can be scoped to a single namespace, or they can be cluster-scoped with <strong class="bold">ClusterRoles</strong>. Either way, the role is bound to a <strong class="bold">ServiceAccount</strong> with a <strong class="bold">RoleBinding</strong> (or <strong class="bold">ClusterRoleBinding</strong>). ServiceAccounts <a id="_idIndexMarker093"/>are specified on <a id="_idIndexMarker094"/>Pods to complete the chain of identifying what RBAC-based access a Pod has within the cluster:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B18147_Figure_2.2.jpg" alt="Figure 2.2 – Diagram of cluster versus namespace-scoped roles&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – Diagram of cluster versus namespace-scoped roles</p>
			<p>The difference between roles and ClusterRoles depends on the breadth of access an Operator will need within a cluster. Specifically, this is mostly based on the namespaces that an Operator, its Operand, and their dependencies are installed in. </p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Namespaces</h2>
			<p>All Kubernetes <a id="_idIndexMarker095"/>applications run within <strong class="bold">namespaces</strong>. A namespace is a logical partition for application resources to reside in that separates components and allows <a id="_idIndexMarker096"/>certain degrees of access control. Operators are also deployed within namespaces, but they sometimes require access to other namespaces as well.</p>
			<p>The breadth of an Operator's namespace coverage is called its scope. Operators can either be scoped to <a id="_idIndexMarker097"/>a single namespace (<strong class="bold">namespace-scoped</strong>), or they <a id="_idIndexMarker098"/>can be <strong class="bold">cluster-scoped</strong>. When an Operator is cluster-scoped, it can observe and interact with resources in multiple namespaces. In contrast, a namespace-scoped operator is installed on a single namespace and manages the resources within that namespace. Which scope a developer chooses for their Operator depends on the resources the Operator will manage. </p>
			<p>If the Operator must be able to manage resources that are created in any namespace, then it should be cluster-scoped. This could be an Operator that manages an Operand in a specific separate namespace from the Operator itself. Or, it could simply need to manage Operands that exist in many namespaces (such as a resource provisioner where users request development environments to be deployed). </p>
			<p>On the other hand, namespace-scoped Operators have some benefits. Specifically, restricting an <a id="_idIndexMarker099"/>Operator to a single namespace allows for easier debugging and failure isolation. It also allows for flexible installation (including installing multiples of <a id="_idIndexMarker100"/>the same Operator across multiple namespaces).</p>
			<p>The Operator's scope is ultimately defined by its CRD and access roles. Cluster-scoped custom resources are created outside of any specific namespace. This can be good for Operators that will only have one instance in a cluster (for example, Operators that manage core Kubernetes components, such as the API server). The access roles an Operator needs will usually follow the scope of the Operator's CRD.</p>
			<p>In summary, the resources we have covered here (Pods, ReplicaSets, Deployments, CRDs, RBAC, and namespaces) are only a few of the possible resources an Operator will depend on. However, they are the most common and likely the first ones you should consider when you're designing your Operator's cluster interactions. In the next section, we'll look at the other side of an Operator's interactions: how it interacts with humans.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Identifying users and maintainers</h1>
			<p>The other way that an Operator interacts with Kubernetes is through its users. While Operators exist <a id="_idIndexMarker101"/>to automate many of the cluster interactions that are <a id="_idIndexMarker102"/>required by humans, the organic element in a Kubernetes cluster is still present. Users must still interact with the Operator somehow, and the ways that different users will want and need to engage in that interaction can influence an Operator's design. </p>
			<p>Therefore, it is important to identify what type of user your Operator is intended for; there are a few categories. Each category will have different needs and opinions on what their Operator should do. So, by identifying the target audience for your Operator, you can ensure that the Operator has been designed to appeal to the widest user base and fulfill the most use cases.</p>
			<p>For most Operators, the type <a id="_idIndexMarker103"/>of users that will be interacting with them <a id="_idIndexMarker104"/>can be broken into a couple of groups based on the level of access those users have in the cluster and the role those users play in the application at large. These user groups are usually as follows:</p>
			<ul>
				<li><strong class="bold">Cluster administrators</strong>: The <a id="_idIndexMarker105"/>admin users of a cluster that are responsible for its maintenance and stability.</li>
				<li><strong class="bold">Cluster users</strong>: Individual <a id="_idIndexMarker106"/>users with internal access to a cluster, such as the engineers on a team.</li>
				<li><strong class="bold">End-users/customers</strong>: The <a id="_idIndexMarker107"/>external users of a cluster for a public or enterprise product. These users don't directly interact with a cluster, but they use the applications that run on the cluster.</li>
			</ul>
			<p>These types of users all have similar motivations and use cases, but also some stark differences. Thinking about each group individually helps highlight these comparisons.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Cluster administrators</h2>
			<p>Cluster administrators are commonly the consumers of Operators. These are the users that have the <a id="_idIndexMarker108"/>most access to and knowledge about a cluster's architecture. As such, they require the most power and flexibility.</p>
			<p>Foremost, a cluster administrator's job is to ensure the stability of their cluster. This is why they need the broadest array of tools and controls at their disposal to modify cluster settings as necessary. But, as the saying goes, <em class="italic">with great power comes great responsibility</em>. In this case, an Operator can provide administrators with great power to run their cluster however they need to. But that power can backfire and harm the cluster if it doesn't work exactly as intended.</p>
			<p>So, the developer of an Operator that is going to be used by cluster administrators may consider restricting its capabilities to a defined set that is known to be supportable. This can help them design the Operator so that it doesn't become <em class="italic">too powerful</em> and expose settings that can inadvertently damage the cluster.</p>
			<p>However, if an administrator finds that their cluster is suddenly <em class="italic">on fire</em> or critically failing, they will need to fix that problem as soon as possible. If this is due to the component that an Operator is managing (or the Operator itself), then the administrator will require direct access to the Operator, Operand, or both. At times like this, a restricted feature set may hinder the recovery time to restore cluster stability.</p>
			<p>One benefit of developing Operators for cluster administrators is that they are very knowledgeable about their clusters and have high levels of internal access to them. This provides some <a id="_idIndexMarker109"/>trust that allows more powerful functionality to be created. Also, having homogenous consumers limits the different workflows that need to be supported in an Operator. </p>
			<p>The following diagram shows the simple layout of an internal cluster administrator interacting with an Operator to manage the Operands in their cluster:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B18147_Figure_2.3.jpg" alt="Figure 2.3 – A single cluster administrator directly managing an Operator via its CRD"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – A single cluster administrator directly managing an Operator via its CRD</p>
			<p>Ultimately, it is up to the developers of the Operator to determine what to provide for the cluster administrators (if that is the target audience). Depending on the application the Operator is going to manage, it may make sense and be safe and limit the administrator's direct access to the Operand through the Operator. But if there is the potential for an Operand deployment to go haywire and require manual intervention, then emergency accessibility should be provided.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Cluster users</h2>
			<p>The users of a <a id="_idIndexMarker110"/>cluster interact with the cluster but without the access and control of an administrator. For example, these could be developers working on a shared cluster who need certain resources to be deployed and destroyed on-demand. Provisioning development resources involves having users request those resources from the Operator.</p>
			<p>Cluster users require less control over underlying cluster components. They also are less likely to be touching parts of a cluster and potentially breaking it. These are two reassurances for developing an Operator that helps limit the scope of features that must be supported by these users. Additionally, these users may have personal access to a cluster administrator if they require more than the Operator provides.</p>
			<p>Cluster users may also interact with Operators through internal applications. It is not uncommon for <a id="_idIndexMarker111"/>organizations to deploy custom applications within their intranets. Using an internal application like this can provide a more user-friendly frontend for your cluster users. It also allows the cluster users' access to be restricted below the underlying Operator's actual capabilities.</p>
			<p>The following diagram shows a setup where multiple internal users are using an Operator to provision resources in the cluster. Some of these users are interacting with the Operator directly, while others must go through an internal application to interact with the Operator (the Operator could even be managing this frontend application). With patterns like this, intra-organizational privilege hierarchies can be defined for working with the internal tools that are provided by Operators:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B18147_Figure_2.4.jpg" alt="Figure 2.4 – Internal cluster users requesting resources, either directly from the Operator or via an intermediary internal application"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – Internal cluster users requesting resources, either directly from the Operator or via an intermediary internal application</p>
			<p>The options for exposing an Operator to internal cluster users are some of the most flexible. These users benefit from a level of trust and investment in the cluster's stability that's high enough that the risk of negligent or malicious behavior is mitigated. However, there is still a risk in exposing application management controls to a broader audience. So, you must think about this when you're designing the capabilities of your Operator.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>End users and customers</h2>
			<p>The end users of a product can also benefit from Operators. These users may not even know they are interacting with an Operator since the architectural design of the product is usually not <a id="_idIndexMarker112"/>apparent to everyday users. But it is still important to know how the users of a product will expect it to function, especially in this case, where we are designing a critical component of the product.</p>
			<p>These end users will likely not be directly interacting with the Operator. This would mean that your users and customers have access to the Kubernetes cluster themselves, which is not ideal for security or usability. The customers of an application benefit from an interactive frontend, whether this is a website or mobile app. But that frontend is just a tool for interacting with a backend, which could be made up of many different components, including Operators.</p>
			<p>In this case, your user might be yourself – that is, you (or your organization) will be developing the Operator but also probably developing the frontend applications that depend on it. In situations like this, cross-project collaboration is necessary to elaborate on the needs and expectations of each team. Operators in this kind of scenario will benefit the most from elegant API design that communicates easily with other programs, rather than human users:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B18147_Figure_2.5.jpg" alt="Figure 2.5 – External end users interacting with an Operator via an external-facing application"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – External end users interacting with an Operator via an external-facing application</p>
			<p>The end users of an application will usually be completely detached from interacting with an Operator. However, this doesn't mean that an application and its resources can't still be managed by one. In this scenario, the Operator is still an important and helpful tool <a id="_idIndexMarker113"/>for maintaining the state of the cluster that end users expect, even if those users don't need to know they are interacting with it.</p>
			<p>End users are the final type of users we'll discuss that interact with your Operator in a functional capacity. However, there are other people we must consider when we're designing an Operator: the people who maintain the Operator and its code.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Maintainers</h2>
			<p>The final type of user who will interact with your Operator does so in a different way than the other three. These are the maintainers of the project, who work on the code to resolve issues <a id="_idIndexMarker114"/>and implement new features. The role of a maintainer in any software project is an important one, but in an open source ecosystem such as Kubernetes, there are additional points to consider.</p>
			<p>If your Operator's source code is going to be open and accepting contributions from anyone, it will be essential to appoint trusted owners to review code changes. This is true for any open source project, but for an Operator, it is very beneficial that these reviewers are familiar with the core Kubernetes concepts that any Operator depends on.</p>
			<p>From an enterprise perspective, investing in a reliable team of engineers to build and maintain an Operator provides a long-term incentive for your maintainers to continue building the Operator's source code. This also creates a level of trust between the maintainers of the Operator and its primary stakeholders. Ongoing maintenance for the Operator code base will be necessary, especially given the changing nature of the Kubernetes platform. Maintainers who are familiar with the Kubernetes community are an important addition to teams that use Operators.</p>
			<p>These are just a few of the types of users that your Operator may interact with. This list is by no means exhaustive, but it is intended to provoke thoughts about your user base. Identifying the type of user for an Operator helps narrow down what kind of features an Operator will need. It also provides a starting point for determining what features are necessary. In the next section, we'll look at some ideas for thinking about feature design that benefits users the most.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Designing beneficial features for your operator</h1>
			<p>Once you've identified the target audience for your Operator, the next step is to define what the Operator will do. Listing the problems that must be solved by the Operator will give you a <a id="_idIndexMarker115"/>better understanding of the goals of the project. It will also highlight whether or not those goals provide a tangible, measurable benefit to your users.</p>
			<p>Figuring out what kind of functions are truly beneficial is hard to define. The exact definition of "helpful" is different on a case-by-case basis. Some beneficial Operators solve widespread headaches in a novel and intuitive way. Others address more niche problems that may only affect small communities of users, but the impact of eliminating those problems is significant. However, it is a bit easier to describe beneficial functions in terms of what is not useful.</p>
			<p>Foremost, useful Operators are not redundant. In specific examples, redundancy can mean a lot of different things. But it is fundamentally the essence of nonduplication that Operator designers should strive for. The most basic example of this is not rewriting an Operator that already exists elsewhere without having a sufficient reason to do so. Researching the proposed area of your Operator can prevent this. Researching the approaches that others have undertaken will also reveal potential pitfalls to avoid in the process.</p>
			<p>Operators can also be redundant in terms of Kubernetes concepts. Since an Operator is essentially interacting with the cluster and exposing some of that interaction to users, the Operator is an extension of Kubernetes. Because of this, it can be inadvertently tempting to "reinvent the wheel" when it comes to brainstorming functions for the Operator. This kind of functional redundancy can be related to the next issue we'll discuss, wherein developers try to address nonexistent problems.</p>
			<p>The next issue concerns beneficial tasks, which are not hypothetical. The world of software development benefits from many passionate engineers who are eager to fix the problems they run into. This zeal for contribution can extend to fixing potential issues, even if they have not been witnessed in practice. This is certainly a good mentality to have, and in no way should this kind of passion be stifled. There are, of course, many types of issues and bugs that can be identified and should be patched – hopefully before anyone runs into them in production. But occasionally, real solutions are proposed for purely theoretical problems. </p>
			<p>These hypothetical use cases may be proposed without any actual evidence that users are seeking such a solution. This can be tricky because sometimes, the use case seems obvious enough that it almost shouldn't necessitate any explicit demand. But when each new feature costs resources to implement and binds the maintainers to support it, paying close attention to silence can reveal unnecessary work.</p>
			<p>While there could be many breakthrough ideas for features, it is important to try to validate a feature's <a id="_idIndexMarker116"/>proposal with real demand. This type of research can also uncover redundancy in the idea and lead to more effective alternative solutions that already exist.</p>
			<p>There are, of course, an infinite number of criteria that could be used to define the usefulness of features. In the context of Kubernetes Operators, however, these are just some initial thoughts to get started with. By thinking about your Operator in terms of its benefits, and by asking "What makes this useful?" you can avoid excessive or unnecessary changes that will require maintenance later down the road.</p>
			<p>That foresight will come in handy as your Operator grows and evolves. Like most software, Operators are prone to changes over time, especially given their dependence on the upstream Kubernetes code base. In the next section, we'll learn how to prepare for and navigate these changes as they arrive.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Planning for changes in your Operator</h1>
			<p>Over any software project's lifespan, changes will be made to the code base. These include bug <a id="_idIndexMarker117"/>fixes, refactors, new features, and old features being removed. This is true for Kubernetes, its subprojects, and projects that are built on the platform, such as Operators.</p>
			<p>While it's impossible to predict the future of what your Operator will evolve into one day, there are a few ideas that can help you during the design phase to ease transitions and new developments later. These are as follows:</p>
			<ul>
				<li>Start small.</li>
				<li>Iterate effectively.</li>
				<li>Deprecate gracefully.</li>
			</ul>
			<p>These decisions have significant benefits in practice when you're maintaining an Operator. However, these are not definitive or strictly specific to Kubernetes Operators. Consider them as general suggestions for developing any software project. But here, we will be examining them in the context of writing an Operator.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Starting small</h2>
			<p>When planning the original design for an Operator, considering how the Operator may change over <a id="_idIndexMarker118"/>time can prevent future challenges. Designing with growth in mind also helps limit the initial scope of the project so that it only covers essential purposes. This allows adequate resources to be allocated to the development of a strong first product that can be efficiently iterated over time.</p>
			<p>While it may seem like the best goal for developing an Operator is to start with as many features as possible, in reality, the opposite is often true. After all, one purpose of an Operator is to create a layer of abstraction between its users and the underlying cluster functions. By exposing too many options, you may lose the benefit of automation by requiring your users to understand more of the native Kubernetes cluster functionality. This also makes your users more vulnerable to changes in the Kubernetes platform that shouldn't directly affect them.</p>
			<p>When you're deciding whether to add a feature to an Operator or not, think critically about the importance of the feature, as well as the risks and costs of implementing it. This goes back to the topics of avoiding redundancy and addressing hypothetical problems, which we looked at in the previous section. It also relates to the topic of deprecation, which we will cover shortly.</p>
			<p>Ultimately, most of the time, it is better to lack features than to ship a complex and confusing Operator. Every new feature has maintenance costs and the potential to introduce bugs later. These are some of the biggest reasons for starting small and building as you listen to feedback from your users.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Iterating effectively</h2>
			<p>Once you have <a id="_idIndexMarker119"/>a minimal set of features, it will eventually be necessary to add improvements. Fortunately, it is much easier to add new things than it is to take old things away.</p>
			<p>You should actively seek feedback from users on what kind of features they need. This can be done in many ways, from maintaining an active presence online around your Operator and its related projects to implementing detailed usage metrics in the Operator's code. In addition, having an awareness of the broader Kubernetes project communities can help highlight upcoming changes in the underlying platform that you may want to support in your Operator.</p>
			<p>As you add features, continue to monitor their usage to gauge their effectiveness. Keeping the <a id="_idIndexMarker120"/>guidelines for the initial design of an Operator, such as its user base and feature tips, in mind will also make sure that each new feature is just as effective as the original set of features you designed when you first built the Operator.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Deprecating gracefully</h2>
			<p>One type of change that can be incredibly inconvenient for users is deprecation. Many aspects of large <a id="_idIndexMarker121"/>software projects inevitably have to be replaced or have their support dropped by official maintainers. With a minimal Operator design, the possibility of your users' experience having to be changed is also minimized. </p>
			<p>Starting with a small design and thoughtful, effective iterations after that will help reduce the need to remove features. Unfortunately, it may be inevitable at some point. In this case, it is important to give users plenty of notice so that they have sufficient time to transition to an alternative, if applicable.</p>
			<p>The Kubernetes community has defined policies for deprecation, which will be covered in detail <a href="B18147_08_ePub.xhtml#_idTextAnchor126"><em class="italic">Chapter 8</em></a>, <em class="italic">Preparing for Ongoing Maintenance of Your Operator</em>. But these guidelines serve as a good template for your deprecation. Kubernetes users will be familiar with the timelines and processes for deprecation, so by remaining consistent with those processes, your users will benefit from a familiarity they already have.</p>
			<p>Just as all good things must come to an end, so too must some good features be eventually retired. Fortunately, this is not a foreign concept to the Kubernetes community, which offers a well-established template for deprecation. As a responsible citizen of the open source community, you and your users will benefit from a respectful, considerate approach to removing and changing aspects of your project.</p>
			<p>Keeping all these practices in mind during the design stage of an Operator will pay off by limiting the scope of the project. This allows resources to focus on building a stable tool that does not radically change over time. Users and maintainers will both benefit from this stability, as users can seamlessly work with different versions of the Operator without changing their workflows, and maintainers can invest long-term effort into growing the project and passing knowledge about it to others.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>Summary</h1>
			<p>This chapter focused on the different ways in which an Operator can interact with a Kubernetes cluster. Besides the literal technical interactions between an Operator's code base and the cluster's native resources, we also explored some other interactions that are worth considering in an Operator's design. These include an Operator's users and an Operator's lifecycle over time.</p>
			<p>Kubernetes clusters comprise many different types of native resources. These are the fundamental building blocks of all the applications that are deployed on Kubernetes. Operators are no different in that sense compared to any other application, so they must be able to natively consume these resources. This chapter focused on breaking down a few Operator resources, including Pods, Deployments, CRDs, and RBAC policies, so that you know how to define how Operators consume them.</p>
			<p>How humans interact with an Operator is one of the most important design concepts to consider. Operators are designed to work for humans by automating various tasks, but like any power tool that automates manual labor, they still require human input to operate and produce output for humans. Due to this, we discussed some of the types of users that your Operator can be built for and the unique needs and expectations of each type.</p>
			<p>Finally, we covered some good approaches to feature design. To help you set up an Operator for success, we discussed ideas for drafting an initial design that provides tangible benefits to users. We then proposed some more concepts you should keep in mind as your Operator evolves.</p>
			<p>In the next chapter, we'll apply these lessons to hands-on Operator design. We will begin by building a sample Operator, starting with designing for its CRD, API, and reconciliation loop. Here, we will begin building an actual Operator, which we will then code and deploy in the remainder of this book.</p>
		</div>
	</body></html>