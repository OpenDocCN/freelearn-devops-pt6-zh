<html><head></head><body>
		<div id="_idContainer071">
			<h1 id="_idParaDest-102" class="chapter-number"><a id="_idTextAnchor101"/>6</h1>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor102"/>Securing Microservices Communication</h1>
			<p>Istio secures communication between microservices without microservices requiring any code changes. In <span class="No-Break"><em class="italic">Chapter 4</em></span>, we briefly touched upon the topic of security. We configured transport layer security by exposing our sockshop application over HTTPS. We created certificates and configured the Istio Ingress gateway to bind those certificates to hostnames in SIMPLE TLS mode. We also implemented TLS-based security for multiple hosts managed by a single <span class="No-Break">Ingress gateway.</span></p>
			<p>In this chapter, we will dive deeper into some advanced topics of security. We will start by understanding Istio security architecture. We will implement mutual TLS for service communication with other services in the mesh, and we will also implement mutual TLS with downstream clients outside the mesh. We will then perform various hands-on exercises to create custom security policies for authentication and authorization. We will go through these topics in the <span class="No-Break">following order:</span></p>
			<ul>
				<li>Istio <span class="No-Break">security architecture</span></li>
				<li>Authenticating using <span class="No-Break">mutual TLS</span></li>
				<li>How to configure a custom authentication and <span class="No-Break">authorization policy</span></li>
			</ul>
			<p class="callout-heading">Important note</p>
			<p class="callout">The technical prerequisites for this chapter are the same as <em class="italic">Chapters 4</em> <span class="No-Break">and </span><span class="No-Break"><em class="italic">5</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Understanding Istio security architecture</h1>
			<p>In <span class="No-Break"><em class="italic">Chapter 3</em></span>, we discussed how the Istio control <a id="_idIndexMarker541"/>plane is responsible for the injection of sidecars and establishing trust so that sidecars can communicate with the control plane securely and security policies are eventually enforced by the sidecar. When deployed in Kubernetes, Istio relies on Kubernetes service accounts to identify the roles of workloads in a Service Mesh. The Istio CA watches the Kubernetes API server for the addition/deletion/modification of any service accounts in the namespace with Istio injection enabled. It creates a key and certificates for each service account and, during Pod creation, the certificate and key are mounted onto the sidecar. The Istio CA is responsible for managing the life cycle of the certificates distributed to the sidecars, including the rotation and management of private keys. Using the <strong class="bold">Secure Production Identity Framework for Everyone</strong> (<strong class="bold">SPIFFE</strong>) format identities, Istio provides a <a id="_idIndexMarker542"/>strong identity to each service along with service naming, which represents the role that can be taken up by the identity assigned to <span class="No-Break">the service.</span></p>
			<p>SPIFFE is a set of open source standards for software identity. SPIFFE provides platform-agnostic <a id="_idIndexMarker543"/>interoperable software identities along with interfaces and documents required to obtain and validate cryptographic identity in a fully <span class="No-Break">automated fashion.</span></p>
			<p>In Istio, each <a id="_idIndexMarker544"/>workload is automatically assigned an identity represented in the X.509 certificate format. The creation and signing of <strong class="bold">certificate signing request</strong> (<strong class="bold">CSRs</strong>) are managed by the Istio control plane, as discussed in <span class="No-Break"><em class="italic">Chapter 3</em></span>. The X.509 <a id="_idIndexMarker545"/>certificate follows the <span class="No-Break">SPIFFE format.</span></p>
			<p>Let’s redeploy the <strong class="source-inline">envoydummy</strong> service and inspect the <span class="No-Break"><strong class="source-inline">envoydummy</strong></span><span class="No-Break"> Pods:</span></p>
			<pre class="console">
$ kubectl apply -f Chapter6/01-envoy-dummy.yaml
$ istioctl proxy-config all po/envoydummy-2-7488b58cd7-m5vpv -n utilities -o json | jq -r '.. |."secret"?' | jq -r 'select(.name == "default")' | jq -r '.tls_certificate.certificate_chain.inline_bytes' | base64 -d - | step certificate inspect  --short
X.509v3 TLS Certificate (RSA 2048) [Serial: 3062...1679]
  Subject:     spiffe://cluster.local/ns/utilities/sa/default
  Issuer:
  Valid from:  2022-09-11T22:18:13Z
          to:  2022-09-12T22:20:13Z</pre>
			<p class="callout-heading">step CLI</p>
			<p class="callout">You will need to install step <strong class="source-inline">CLI</strong> to be able to run the preceding command. To install it, please follow <a id="_idIndexMarker546"/>the documentation <span class="No-Break">at </span><a href="https://smallstep.com/docs/step-cli"><span class="No-Break">https://smallstep.com/docs/step-cli</span></a><span class="No-Break">.</span></p>
			<p>In the output of the <a id="_idIndexMarker547"/>preceding command, you will notice that the <strong class="bold">Subject Alternative Name</strong> (<strong class="bold">SAN</strong>) is <strong class="source-inline">spiffe://cluster.local/ns/utilities/sa/default</strong>. This is the SPIFFE ID, which functions as the <span class="No-Break">unique name:</span></p>
			<ul>
				<li><strong class="source-inline">spifee</strong> is the <span class="No-Break">URI scheme</span></li>
				<li><strong class="source-inline">cluster.local</strong> is the <span class="No-Break">trust domain</span></li>
				<li><strong class="source-inline">/ns/utilities/sa/default</strong> is the URI identifying the service account associated with <span class="No-Break">the workload:</span><ul><li><strong class="source-inline">ns</strong> stands <span class="No-Break">for namespace</span></li><li><strong class="source-inline">sa</strong> stands for <span class="No-Break">service account</span></li></ul></li>
			</ul>
			<p>The value default for service accounts comes from the service account attached to the workload. In our example of <strong class="source-inline">envoydummy</strong>, we didn’t associate any service accounts so, by default, Kubernetes associated <a id="_idIndexMarker548"/>the <strong class="source-inline">default</strong> service account. You can find the service account name associated with a Pod using the <span class="No-Break">following command:</span></p>
			<pre class="console">
kubectl get po/envoydummy-2-7488b58cd7-m5vpv -n utilities -o json | jq .spec.serviceAccountName
"default"</pre>
			<p>You will notice that <strong class="source-inline">default</strong> is the default name for service accounts associated with all Pods in all namespaces, such as <strong class="source-inline">sock-shop</strong>, <strong class="source-inline">utilities</strong>, and so on. Kubernetes creates a service account named <strong class="source-inline">default</strong> in <span class="No-Break">every namespace:</span></p>
			<pre class="console">
% kubectl get sa -n utilities
NAME      SECRETS   AGE
default   1         13d
% kubectl get sa -n sock-shop
NAME      SECRETS   AGE
default   1         27d</pre>
			<p class="callout-heading">Kubernetes service accounts</p>
			<p class="callout">A service account is an identity assigned to workloads in Kubernetes. When processes running inside a <a id="_idIndexMarker549"/>workload try to access other Kubernetes resources, they are identified and authenticated as per the details of their service accounts. You can <a id="_idIndexMarker550"/>find more details about service accounts <span class="No-Break">at </span><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/"><span class="No-Break">https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/</span></a><span class="No-Break">.</span></p>
			<p>Secure Naming is a technology <a id="_idIndexMarker551"/>that decouples the name of services from the identities the services are running as. In the previous example, <strong class="source-inline">spiffe://cluster.local/ns/utilities/sa/default</strong> is the identity of the service presented during mutual TLS presented by the istio-proxy sidecar in <strong class="source-inline">envoydummy-2-7488b58cd7-m5vpv workload</strong>. From the SPIFFE ID, the other party (istio-proxy in another Pod) in the MTLS session can validate that the endpoint has the identity of <a id="_idIndexMarker552"/>a service account named <strong class="source-inline">default</strong> in the <strong class="source-inline">utilities</strong> namespace. The Istio control plane propagates the secure naming information to all sidecars in the mesh and during mutual TLS, the sidecar not only verifies that the identity is correct but also that the respective service is assuming the <span class="No-Break">correct identity.</span></p>
			<p>The following diagram summarizes the Istio <span class="No-Break">security architecture:</span></p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B17989_06_01.jpg" alt="Figure 6.1 – Istio security architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Istio security architecture</p>
			<p>These are the key concepts <span class="No-Break">to remember:</span></p>
			<ul>
				<li>The Istio CA manages keys and certificates and the SANs in certificates are in <span class="No-Break">SPIFFE format</span></li>
				<li>Istiod distributes authentication and authorization security policies to all sidecars in <span class="No-Break">the mesh</span></li>
				<li>Sidecars <a id="_idIndexMarker553"/>enforce authentication and authorization as per security policies distributed <span class="No-Break">by Istiod</span></li>
			</ul>
			<p class="callout-heading">Reminder</p>
			<p class="callout">Make sure to clean up <strong class="source-inline">Chapter6/01-envoy-dummy.yaml</strong> to avoid conflict in <span class="No-Break">upcoming exercises.</span></p>
			<p>In the next section, we will read about how to secure data in transit between microservices in a <span class="No-Break">Service Mesh.</span></p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>Authentication using mutual TLS</h1>
			<p><strong class="bold">Mutual TLS</strong> (<strong class="bold">mTLS)</strong> is a technique for authenticating two parties at each end of a network <a id="_idIndexMarker554"/>connection. Through mTLS, each party can verify that the other party is <a id="_idIndexMarker555"/>what they are claiming to be. Certificate authorities <a id="_idIndexMarker556"/>play a critical role in mTLS, and hence we had the previous section on Istio security architecture describing certificate authorities and secure naming <span class="No-Break">in Istio.</span></p>
			<p>mTLS is one of the most frequently used authentication mechanisms for implementing the zero-trust security framework, in which no party trusts another party by default, irrespective of where the other party is placed in the network. Zero trust assumes that there are no traditional network edges and boundaries and hence every party needs to be authenticated and authorized. This helps to eliminate many security vulnerabilities that arise because of the assumption-based <span class="No-Break">trust model.</span></p>
			<p>In the following two subsections, we will look at how Istio helps you implement mTLS for service-to-service authentication inside a mesh, also called east-west traffic, and mTLS between client/downstream systems that are outside the mesh, with services in the mesh called <span class="No-Break">north-south communication.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>Service-to-service authentication</h2>
			<p>Istio provides service-to-service authentication by using mTLS for transport authentication. During <a id="_idIndexMarker557"/>traffic processing, Istio performs <span class="No-Break">the following:</span></p>
			<ul>
				<li>All outbound traffic from Pods is rerouted <span class="No-Break">to istio-proxy.</span></li>
				<li>istio-proxy starts an mTLS handshake with the server-side istio-proxy. During the handshake, it also does a secure naming check to verify that the service account presented in the server certificate can run <span class="No-Break">the Pod.</span></li>
				<li>The server-side istio-proxy verifies the client-side istio-proxy in the same fashion and if all is okay, a secure channel is established between the <span class="No-Break">two proxies.</span></li>
			</ul>
			<p>Istio provides the following two options when <span class="No-Break">implementing mTLS:</span></p>
			<ul>
				<li><strong class="bold">Permissive mode</strong>: In permissive <a id="_idIndexMarker558"/>mode, Istio <a id="_idIndexMarker559"/>allows traffic in both mTLS and non-mTLS mode. This feature is primarily to improve the onboarding of clients to mTLS. Clients <a id="_idIndexMarker560"/>who are not <a id="_idIndexMarker561"/>yet ready to communicate over mTLS can continue communicating over TLS with the view that they will eventually migrate to mTLS whenever they <span class="No-Break">are ready.</span></li>
				<li><strong class="bold">Strict mode</strong>: In strict mode, Istio <a id="_idIndexMarker562"/>enforces strict mTLS and <a id="_idIndexMarker563"/>any non-mTLS traffic is <span class="No-Break">not allowed.</span></li>
			</ul>
			<p>Mutual TLS traffic can be established between clients outside of a mesh trying to access a workload within the mesh, as well as clients within the mesh trying to access other workloads in the mesh. For the former, we will discuss the details in the next section. For the latter set of clients, we will go through some examples in <span class="No-Break">this section.</span></p>
			<p>Let’s set up service-to-service communication <span class="No-Break">using mTLS:</span></p>
			<ol>
				<li>Create a <a id="_idIndexMarker564"/>namespace called <strong class="source-inline">chapter6</strong> with <a id="_idIndexMarker565"/>Istio injection enabled and deploy the <span class="No-Break"><strong class="source-inline">httpbin</strong></span><span class="No-Break"> service:</span><pre class="console">
<strong class="bold">$ kubectl apply -f Chapter6/01-httpbin-deployment.yaml</strong></pre></li>
			</ol>
			<p>Most of the config in this deployment is the usual, except that we have also created a default Kubernetes service account called <strong class="source-inline">httpbin</strong> in the <span class="No-Break"><strong class="source-inline">Chapter6</strong></span><span class="No-Break"> namespace:</span></p>
			<pre class="console">
apiVersion: v1
kind: ServiceAccount
metadata:
  name: httpbin
  namespace: chapter6</pre>
			<p>The <strong class="source-inline">httpbin</strong> identity is then assigned to an <strong class="source-inline">httpbin</strong> Pod by following <span class="No-Break">these specs:</span></p>
			<pre class="console">
  Spec:
      serviceAccountName: httpbin
      containers:
      - image: docker.io/kennethreitz/httpbin
        imagePullPolicy: IfNotPresent
        name: httpbin
        ports:
        - containerPort: 80</pre>
			<ol>
				<li value="2">Next, we will create a client in the form of a <strong class="source-inline">curl</strong> Pod to access the <strong class="source-inline">httpbin</strong> service. Create a <strong class="source-inline">utilities</strong> namespace with Istio injection disabled, and create a <strong class="source-inline">curl</strong> Deployment with its own <span class="No-Break">service account:</span><pre class="console">
<strong class="bold">$ kubectl apply -f Chapter6/01-curl-deployment.yaml</strong></pre></li>
			</ol>
			<p>Make <a id="_idIndexMarker566"/>sure the <strong class="source-inline">istio-injection</strong> label is not applied. If it is, you can remove it using the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker567"/></span><span class="No-Break">command:</span></p>
			<pre class="console">
<strong class="bold">$ kubectl label ns utilities istio-injection-</strong></pre>
			<ol>
				<li value="3">From the <strong class="source-inline">curl</strong> Pod, try to access the <strong class="source-inline">httpbin</strong> Pod and you should get a <span class="No-Break">response back:</span><pre class="console">
<strong class="bold">$ kubectl exec -it curl -n utilities – curl -v http://httpbin.chapter6.svc.cluster.local:8000/get</strong>
<strong class="bold">{</strong>
<strong class="bold">  "args": {},</strong>
<strong class="bold">  "headers": {</strong>
<strong class="bold">    "Accept": "*/*",</strong>
<strong class="bold">    "Host": "httpbin.chapter6.svc.cluster.local:8000",</strong>
<strong class="bold">    "User-Agent": "curl/7.87.0-DEV",</strong>
<strong class="bold">    "X-B3-Sampled": "1",</strong>
<strong class="bold">    "X-B3-Spanid": "a00a50536c3ec2f5",</strong>
<strong class="bold">    "X-B3-Traceid": "49b6942c85c7c1f2a00a50536c3ec2f5"</strong>
<strong class="bold">  },</strong>
<strong class="bold">  "origin": "127.0.0.6",</strong>
<strong class="bold">  "url": "http://httpbin.chapter6.svc.cluster.local:8000/get"</strong></pre></li>
				<li>So far, we have the <strong class="source-inline">httpbin</strong> Pod running in the mesh, but by default, in <em class="italic">permissive</em> TLS mode. We will now create a <strong class="source-inline">PeerAuthentication</strong> policy <a id="_idIndexMarker568"/>to enforce <strong class="source-inline">STRICT</strong> mTLS. The <strong class="source-inline">PeerAuthentication</strong>  policy defines how traffic will be tunneled <a id="_idIndexMarker569"/><span class="No-Break">via sidecars:</span><pre class="console">
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: "httpbin-strict-tls"
  namespace: chapter6
spec:
  mtls:
    mode: STRICT
  selector:
    matchLabels:
      app: httpbin</pre></li>
			</ol>
			<p>In the <strong class="source-inline">PeerAuthentication</strong> policy, we defined the following <span class="No-Break">configuration parameters:</span></p>
			<ul>
				<li><strong class="source-inline">mtls</strong>: This defines the mTLS setting. If not specified, the value is inherited from the default mesh-wide setting. It has one field called <strong class="source-inline">mode</strong>, which can have the <span class="No-Break">following values:</span><ul><li><strong class="source-inline">UNSET</strong>: With this value, the mTLS settings are inherited from the parent and if the parent does not have any settings, then the value is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">PERMISSIVE</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">MTLS</strong>: With this value, the sidecar accepts both mTLS and <span class="No-Break">non-mTLS connections.</span></li><li><strong class="source-inline">STRICT</strong>: This enforces strict mTLS – any non-mTLS connection will <span class="No-Break">be dropped.</span></li><li><strong class="source-inline">DISABLE</strong>: mTLS is disabled and connections are <span class="No-Break">not tunneled.</span></li></ul></li>
				<li><strong class="source-inline">Selector</strong>: This defines the criteria that need to be satisfied by a workload to be part of this per authentication policy. It has a field named <strong class="source-inline">matchLabels</strong>, which takes label information in the <span class="No-Break"><strong class="source-inline">key:value</strong></span><span class="No-Break"> format.</span></li>
			</ul>
			<p>To summarize the configuration, we have created <strong class="source-inline">httpbin-strict-tls</strong>, which <a id="_idIndexMarker570"/>is a <strong class="source-inline">PeerAuthentication</strong> policy in the <strong class="source-inline">Chapter6</strong> namespace. The policy enforces <a id="_idIndexMarker571"/>string mTLS for all workloads that have a label of <strong class="source-inline">app=httpbin</strong>. The configuration is available <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">Chapter6/02-httpbin-strictTLS.yaml</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="5">Apply the changes via the <span class="No-Break">following command:</span><pre class="console">
<strong class="bold">$ kubectl apply -f Chapter6/02-httpbin-strictTLS.yaml</strong>
<strong class="bold">peerauthentication.security.istio.io/httpbin-strict-tls created</strong></pre></li>
				<li>Now try to connect to the <strong class="source-inline">httpbin</strong> service from the <span class="No-Break"><strong class="source-inline">curl</strong></span><span class="No-Break"> Pod:</span><pre class="console">
<strong class="bold">$ kubectl exec -it curl -n utilities – curl -v http://httpbin.chapter6.svc.cluster.local:8000/get</strong>
<strong class="bold">* Connected to httpbin.chapter6.svc.cluster.local (172.20.147.104) port 8000 (#0)</strong>
<strong class="bold">&gt; GET /get HTTP/1.1</strong>
<strong class="bold">&gt; Host: httpbin.chapter6.svc.cluster.local:8000</strong>
<strong class="bold">&gt; User-Agent: curl/7.87.0-DEV</strong>
<strong class="bold">&gt; Accept: */*</strong>
<strong class="bold">&gt;</strong>
<strong class="bold">* Recv failure: Connection reset by peer</strong>
<strong class="bold">* Closing connection 0</strong>
<strong class="bold">curl: (56) Recv failure: Connection reset by peer</strong>
<strong class="bold">command terminated with exit code 56</strong></pre></li>
			</ol>
			<p><strong class="source-inline">curl</strong> is not able to connect because the <strong class="source-inline">curl</strong> Pod is running in a namespace with Istio injection disabled, whereas the <strong class="source-inline">httpbin</strong> Pod is running in the mesh with the <strong class="source-inline">PeerAuthentication</strong> policy enforcing <strong class="source-inline">STRICT</strong> mTLS. One option is to <a id="_idIndexMarker572"/>manually establish an mTLS connection, which is equivalent to modifying your application code to <a id="_idIndexMarker573"/>perform mTLS. In this case, as we are trying to simulate service communication within the mesh, we can simply turn on Istio injection and let Istio take care of client-side mTLS <span class="No-Break">as well.</span></p>
			<ol>
				<li value="7">Enable Istio injection for the <strong class="source-inline">curl</strong> Pod using the <span class="No-Break">following steps:</span><ol><li>Delete the resource created <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">Chapter6/01-curl-deployment.yaml</strong></span><span class="No-Break">.</span></li><li>Modify the value of Istio injection to <span class="No-Break">be enabled.</span></li><li>Apply the <span class="No-Break">updated configuration.</span></li></ol></li>
			</ol>
			<p>Once the <strong class="source-inline">curl</strong> Pod is in the <strong class="source-inline">RUNNING</strong> state, along with the istio-proxy sidecar, you <a id="_idIndexMarker574"/>can perform <strong class="source-inline">curl</strong> on the <strong class="source-inline">httpbin</strong> service <a id="_idIndexMarker575"/>and you will see the <span class="No-Break">following output:</span></p>
			<pre class="console">
<strong class="bold">$ kubectl exec -it curl -n utilities -- curl -s http://httpbin.chapter6.svc.cluster.local:8000/get</strong>
<strong class="bold">{</strong>
<strong class="bold">  "args": {},</strong>
<strong class="bold">  "headers": {</strong>
<strong class="bold">    "Accept": "*/*",</strong>
<strong class="bold">    "Host": "httpbin.chapter6.svc.cluster.local:8000",</strong>
<strong class="bold">    "User-Agent": "curl/7.85.0-DEV",</strong>
<strong class="bold">    "X-B3-Parentspanid": "a35412ed46b7ec46",</strong>
<strong class="bold">    "X-B3-Sampled": "1",</strong>
<strong class="bold">    "X-B3-Spanid": "0728b578e88b72fb",</strong>
<strong class="bold">    "X-B3-Traceid": "830ed3d5d867a460a35412ed46b7ec46",</strong>
<strong class="bold">    "X-Envoy-Attempt-Count": "1",</strong>
<strong class="bold">    "X-Forwarded-Client-Cert": "By=spiffe://cluster.local/ns/chapter6/sa/</strong>
<strong class="bold">httpbin;Hash=b1b88fe241c557bd1281324b458503274eec3f04b1d439758508842d6d5b7018;Subject=\"\";URI=spiffe://cluster.local/ns/utilities/sa/curl"</strong>
<strong class="bold">  },</strong>
<strong class="bold">  "origin": "127.0.0.6",</strong>
<strong class="bold">  "url": "http://httpbin.chapter6.svc.cluster.local:8000/get"</strong>
<strong class="bold">}</strong></pre>
			<p>In the response from the <strong class="source-inline">httpbin</strong> service, you will notice all the headers that were received <a id="_idIndexMarker576"/>by the <strong class="source-inline">httpbin</strong> Pod. The <a id="_idIndexMarker577"/>most interesting header is <strong class="source-inline">X-Forwarded-Client-Cert</strong>, also called <strong class="source-inline">XFCC</strong>. There are two parts of the <strong class="source-inline">XFCC</strong> header value that shed light <span class="No-Break">on mTLS:</span></p>
			<ul>
				<li><strong class="source-inline">By</strong>: This is filled with the SAN, which is the SPIFFE ID of the istio-proxy’s client certificate of the <strong class="source-inline">httpbin</strong> <span class="No-Break">Pod (</span><span class="No-Break"><strong class="source-inline">spiffe://cluster.local/ns/chapter6/sa/httpbin</strong></span><span class="No-Break">)</span></li>
				<li><strong class="source-inline">URI</strong>: This contains the SAN, which is the SPIFFE ID of the <strong class="source-inline">curl</strong> Pod’s client certificate presented during <span class="No-Break">mTLS (</span><span class="No-Break"><strong class="source-inline">spiffe://cluster.local/ns/utilities/sa/curl</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>There is also <strong class="source-inline">Hash</strong>, which is the SHA256 digest of istio-proxy’s client certificate of the <span class="No-Break"><strong class="source-inline">httpbin</strong></span><span class="No-Break"> Pod.</span></p>
			<p>You can selectively apply mTLS configuration at the port level also. In the following configuration, we are implying that mTLS is enforced strictly for all ports except port <strong class="source-inline">8080</strong>, which should allow permissive connections. The configuration is available <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">Chapter6/03-httpbin-strictTLSwithException.yaml</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: "httpbin-strict-tls"
  namespace: chapter6
spec:
  portLevelMtls:
    8080:
      mode: PERMISSIVE
    8000:
      mode: STRICT
  selector:
    matchLabels:
      app: httpbin</pre>
			<p>So, in this <a id="_idIndexMarker578"/>section, we learned how <a id="_idIndexMarker579"/>to perform mTLS between services inside the mesh. mTLS can be enabled at the service level as well as at the port level. In the next section, we will read about performing mTLS with clients outside <span class="No-Break">the mesh.</span></p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">Make sure to clean up <strong class="source-inline">Chapter6/01-httpbin-deployment.yaml</strong>, <strong class="source-inline">Chapter6/01-curl-deployment.yaml</strong> and <strong class="source-inline">Chapter6/02-httpbin-strictTLS.yaml</strong> to avoid conflict in <span class="No-Break">upcoming exercises.</span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Authentication with clients outside the mesh</h2>
			<p>For clients outside <a id="_idIndexMarker580"/>the mesh, Istio supports mTLS with the Istio Ingress gateway. In <span class="No-Break"><em class="italic">Chapter 5</em></span>, we configured HTTPS at the Ingress gateway. In this section, we will extend that configuration to also <span class="No-Break">support mTLS.</span></p>
			<p>We will now configure mTLS for the <strong class="source-inline">httpbin</strong> Pod. Notice that the first five steps are very similar to <em class="italic">steps 1-5 </em>of <em class="italic">Exposing Ingress over HTTPS</em> of <span class="No-Break"><em class="italic">Chapter 5</em></span>. The steps are <span class="No-Break">as follows:</span></p>
			<ol>
				<li value="1">Create a CA. Here, we are creating a CA with a <strong class="bold">Common Name</strong> (<strong class="bold">CN</strong>) <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">sock.inc</strong></span><span class="No-Break">:</span><pre class="console">
<strong class="bold">$ openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj '/O=sock Inc./CN=sock.inc' -keyout sock.inc.key -out sock.inc.crt</strong></pre></li>
				<li>Generate a <a id="_idIndexMarker581"/>CSR for <strong class="source-inline">httpbin.org</strong>. Here, we are generating a <strong class="bold">Certificate Signing Request</strong> (<strong class="bold">CSR</strong>) for <strong class="source-inline">httpbin.org</strong>, which also generates a <span class="No-Break">private key:</span><pre class="console">
<strong class="bold">$ openssl req -out httpbin.org.csr -newkey rsa:2048 -nodes -keyout httpbin.org.key -subj "/CN=httpbin.org/O=sockshop.inc"</strong>
<strong class="bold">Generating a 2048 bit RSA private key</strong>
<strong class="bold">.........+++</strong>
<strong class="bold">..+++</strong>
<strong class="bold">writing new private key to 'httpbin.org.key'</strong></pre></li>
				<li>Sign the CSR using the CA created in <span class="No-Break"><em class="italic">step 1</em></span><span class="No-Break">:</span><pre class="console">
<strong class="bold">$ openssl x509 -req -sha256 -days 365 -CA sock.inc.crt -CAkey sock.inc.key -set_serial 0 -in httpbin.org.csr -out httpbin.org.crt</strong>
<strong class="bold">Signature ok</strong>
<strong class="bold">subject=/CN=httpbin.org/O=sockshop.inc</strong>
<strong class="bold">Getting CA Private Key</strong></pre></li>
				<li>Load the certificate and private key as a Kubernetes secret along with the CA certificate against which client certificates must <span class="No-Break">be verified:</span><pre class="console">
<strong class="bold">$ kubectl create -n istio-system secret generic httpbin-credential --from-file=tls.key=httpbin.org.key --from-file=tls.crt=httpbin.org.crt --from-file=ca.crt=sock.inc.crt</strong>
<strong class="bold">secret/httpbin-credential created</strong></pre></li>
				<li>Configure the Ingress gateway to enforce mTLS for all incoming connections and use <a id="_idIndexMarker582"/>the secret created in <em class="italic">step 4</em> as the secret containing TLS certificate and the <span class="No-Break">CA certificate:</span><pre class="console">
  tls:
      mode: MUTUAL
      credentialName: httpbin-credential</pre></li>
				<li>Deploy the <strong class="source-inline">httpbin</strong> Pod, the Ingress gateway, and the <span class="No-Break">virtual service:</span><pre class="console">
<strong class="bold">$ kubectl apply -f Chapter6/02-httpbin-deployment-MTLS.yaml</strong></pre></li>
				<li>To perform mTLS, you also need to generate client certificates that can be used to prove the client’s identity. For that, perform the <span class="No-Break">following steps:</span><pre class="console">
<strong class="bold">$ openssl req -out bootstrapistio.packt.com.csr -newkey rsa:2048 -nodes -keyout bootstrapistio.packt.com.key -subj "/CN= bootstrapistio.packt.com/O=packt.com"</strong>
<strong class="bold">$ openssl x509 -req -sha256 -days 365 -CA sock.inc.crt -CAkey sock.inc.key -set_serial 0 -in bootstrapistio.packt.com.csr -out bootstrapistio.packt.com.crt</strong></pre></li>
				<li>Test the <a id="_idIndexMarker583"/>connection to <strong class="source-inline">httpbin.org</strong> by passing client certificates in <span class="No-Break">the request:</span><pre class="console">
<strong class="bold">% curl -v -HHost:httpbin.org --connect-to "httpbin.org:443:a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com" --cacert sock.inc.crt --cert bootstrapistio.packt.com.crt --key bootstrapistio.packt.com.key https://httpbin.org:443/get</strong></pre></li>
			</ol>
			<p class="callout-heading">Reminder</p>
			<p class="callout">Don’t forget to clean up using <strong class="source-inline">kubectl delete -n istio-system secret httpbin-credential</strong> and <strong class="source-inline">kubectl delete -</strong><span class="No-Break"><strong class="source-inline">f Chapter6/02-httpbin-deployment-MTLS.yaml</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>Configuring RequestAuthentication</h1>
			<p>Like service-to-service authentication, Istio can also authenticate an end user or validate that an end user <a id="_idIndexMarker584"/>has been authenticated based on assertions presented by the end user. The <strong class="source-inline">RequestAuthentication</strong> policy is used to specify what authentication methods are supported by a workload. This policy identifies the authenticated identity but doesn’t enforce whether the request should be allowed or denied. Rather, it provides information about the authenticated identity to the authorization policy, which we will go through in the next section. In this section, we will learn how to make use of the Istio <strong class="source-inline">RequestAuthentication</strong> policy to validate an end user who has been authenticated by Auth0 and is providing a bearer token as security credentials to Istio. If you are not <a id="_idIndexMarker585"/>familiar with OAuth then you can read more about it <span class="No-Break">at </span><a href="https://auth0.com/docs/authenticate/protocols/oauth"><span class="No-Break">https://auth0.com/docs/authenticate/protocols/oauth</span></a><span class="No-Break">.</span></p>
			<p>We will follow the hands-on steps to configure Auth0 and perform an OAuth flow while at the same time demystifying all that is happening under <span class="No-Break">the hood:</span></p>
			<ol>
				<li value="1">Sign up <span class="No-Break">for Auth0:</span></li>
			</ol>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B17989_06_02.jpg" alt="Figure 6.2 – Auth0 signup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Auth0 signup</p>
			<ol>
				<li value="2">After <a id="_idIndexMarker586"/>signing up, create an application <span class="No-Break">in Auth0:</span></li>
			</ol>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B17989_06_03.jpg" alt="Figure 6.3 – Create application in Auth0"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Create application in Auth0</p>
			<ol>
				<li value="3">After creating the application, you will need to create an API. You can provide the Ingress URL as <span class="No-Break">the identifier:</span></li>
			</ol>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B17989_06_04.jpg" alt="Figure 6.4 – Create an API in Auth0"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Create an API in Auth0</p>
			<ol>
				<li value="4">Declare <a id="_idIndexMarker587"/>permissions the consumer of this API needs to have to be able to access <span class="No-Break">the API:</span></li>
			</ol>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B17989_06_05.jpg" alt="Figure 6.5 – API scopes in Auth0"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – API scopes in Auth0</p>
			<ol>
				<li value="5">Enable <a id="_idIndexMarker588"/>RBAC for the API from <span class="No-Break"><strong class="bold">General Settings</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B17989_06_06.jpg" alt="Figure 6.6 – Enable RBAC for the API in Auth0"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Enable RBAC for the API in Auth0</p>
			<ol>
				<li value="6">After creating the API, go back to the application and authorize the application for access to the EnvoyDummy API, and while doing so, please also <span class="No-Break">configure scopes:</span></li>
			</ol>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B17989_06_07.jpg" alt="Figure 6.7 – Grant permission to the application in Auth0"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Grant permission to the application in Auth0</p>
			<ol>
				<li value="7">As the last <a id="_idIndexMarker589"/>step, go to the application page to get the request you can use to get the <span class="No-Break">access token:</span></li>
			</ol>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B17989_06_08.jpg" alt="Figure 6.8 – Quickstart example to get the access token in Auth0"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Quickstart example to get the access token in Auth0</p>
			<p>Copy the <strong class="source-inline">curl</strong> string, including <strong class="source-inline">client_id</strong>, <strong class="source-inline">client_secret</strong>, and so on, and with this, we <a id="_idIndexMarker590"/>have completed all the steps <span class="No-Break">in Auth0.</span></p>
			<p>Now, using the <strong class="source-inline">curl</strong> string you copied in the previous steps, get the access token from <span class="No-Break">the terminal:</span></p>
			<pre class="console">
$ curl --request POST --url https://dev-0ej7x7k2.us.auth0.com/oauth/token --header 'content-type:application/json' --data '{"client_id":"XXXXXX-id","client_secret":"XXXXX-secret"," "audience":"http://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com/","grant_type":"client_credentials"}'
{"access_token":"xxxxxx-accesstoken" "scope":"read:dummyData","expires_in":86400,"token_type":"Bearer"}%</pre>
			<p>Once we have received the access token, we will apply the <strong class="source-inline">RequestAuthentication</strong> policy. The <strong class="source-inline">RequestAuthentication</strong> policy specifies the details of how to validate the JWT provided during authentication. Following is the <span class="No-Break"><strong class="bold">RequestAuthentication</strong></span><span class="No-Break"> policy:</span></p>
			<pre class="source-code">
apiVersion: security.istio.io/v1beta1
kind: <strong class="bold">RequestAuthentication</strong>
metadata:
  name: "auth0"
  namespace: chapter6
spec:
  selector:
    matchLabels:
      name: envoydummy
  jwtRules:
  - issuer: "https://dev-0ej7x7k2.us.auth0.com/"
    jwksUri: "https://dev-0ej7x7k2.us.auth0.com/.well-known/jwks.json"</pre>
			<p>In the preceding <a id="_idIndexMarker591"/>configuration, also available in <strong class="source-inline">Chapter6/01-requestAuthentication.yaml</strong>, we are declaring a <strong class="bold">RequestAuthentication</strong> policy with the name <strong class="source-inline">auth0</strong> in the <strong class="source-inline">chapter6</strong> namespace with the <span class="No-Break">following specifications:</span></p>
			<ul>
				<li><strong class="source-inline">issuer</strong>: This is the value of the domain of the Auth0 application. You can fetch the value from the <span class="No-Break">following screen:</span></li>
			</ul>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B17989_06_09.jpg" alt="Figure 6.9 – Application domain"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Application domain</p>
			<ul>
				<li><strong class="source-inline">jwksUri</strong>: This is the JWKS endpoint, which can be used by Istio to verify the signature. Auth0 exposes a JWKS endpoint for each tenant, which is found at <strong class="source-inline">https://DOMAIN/.well-known/jwks.json</strong>. This endpoint will contain the JWK used to verify all Auth0-issued JWTs for this tenant. Replace the <strong class="source-inline">DOMAIN</strong> value with the value in <span class="No-Break">the application.</span></li>
			</ul>
			<p>When using the <strong class="source-inline">RequestAuthentication</strong> policy, it is best practice to also configure the <strong class="source-inline">RequestAuthentication</strong> and <strong class="source-inline">AuthorizationPolicy</strong> together and enforce a <a id="_idIndexMarker592"/>rule that any request with an empty principal should not be allowed. Following is an example of a sample authorization policy – you will read more about authorization policies in the <span class="No-Break">next section:</span></p>
			<pre class="source-code">
apiVersion: security.istio.io/v1beta1
kind: <strong class="bold">AuthorizationPolicy</strong>
metadata:
  name: auth0-authz
  namespace: chapter6
spec:
  action: DENY
  selector:
    matchLabels:
      name: envoydummy
  rules:
  - from:
    - source:
        notPrincipals: ["*"]</pre>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Configuring RequestAuthorization </h1>
			<p>In the previous section, we configured a <strong class="source-inline">RequestAuthentication</strong> policy, which verifies a JWT token <a id="_idIndexMarker593"/>against the issuer and JWK details as per the JWKS location. We configured Auth0 as the authentication provider and the one that generates the bearer token. In this section, we will learn about how to make use of the information provided by authentication policies such as peer authentication and request authentication to authorize client access to the server (the requested resource, Pod, workload, <span class="No-Break">service, etc.).</span></p>
			<p>We will first focus on implementing an authorization policy in conjunction with the <strong class="source-inline">RequestAuthentication</strong> policy from the <span class="No-Break">previous section.</span></p>
			<p>To let <strong class="source-inline">curl</strong> access the envoy dummy using the access token issued by Auth0, we need to create <span class="No-Break">an </span><span class="No-Break"><strong class="source-inline">AuthorizationPolicy</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
apiVersion: "security.istio.io/v1beta1"
kind: "<strong class="bold">AuthorizationPolicy</strong>"
metadata:
  name: "envoydummy-authz-policy"
  namespace: utilities
spec:
  <strong class="bold">action</strong>: ALLOW
  <strong class="bold">selector</strong>:
    matchLabels:
      name: envoydummy
  <strong class="bold">rules</strong>:
  - when:
    - key: request.auth.claims[permissions]
      values: ["read:profile"]</pre>
			<p><strong class="source-inline">AuthorizationPolicy</strong> contains the <span class="No-Break">following data:</span></p>
			<ul>
				<li><strong class="source-inline">action</strong>: This defines the type of action to be taken when the request matches the defined rule. Possible values for <strong class="source-inline">action</strong> are <strong class="source-inline">ALLOW</strong>, <strong class="source-inline">DENY</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">AUDIT</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">selector</strong>: This defines what workload this policy should be applied to. Here, you provide a set of labels that should match the workload’s label to be part of <span class="No-Break">a selection.</span></li>
				<li><strong class="source-inline">rules</strong>: Here, we are defining a set of rules that should be matched with the request. Rules contain the <span class="No-Break">following sub-configurations:</span><ul><li><strong class="source-inline">source</strong>: This provides the rule about the origin of <span class="No-Break">the request.</span></li><li><strong class="source-inline">to</strong>: This provides rules about the request such as to what host it was addressed, what the method name is, and what resource identified by the URI <span class="No-Break">is requested.</span></li><li><strong class="source-inline">when</strong>: This specifies a list of additional conditions. You can find a detailed list of all parameters <span class="No-Break">at </span><a href="https://istio.io/latest/docs/reference/config/security/conditions/"><span class="No-Break">https://istio.io/latest/docs/reference/config/security/conditions/</span></a><span class="No-Break">.</span></li></ul></li>
			</ul>
			<p>In this <a id="_idIndexMarker594"/>example, we are defining an authorization policy that allows access to Pods with the label <strong class="source-inline">name:envoydummy</strong> if the request contains an authenticated JWT token with a claim <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">read:profile</strong></span><span class="No-Break">.</span></p>
			<p>Before we apply the changes, make sure that you can access the dummy data and make sure you have the Ingress gateway and <strong class="source-inline">envoydummy</strong> Pods deployed in the <strong class="source-inline">utilities</strong> namespace – if not, you can do that by applying the <span class="No-Break">following commands:</span></p>
			<pre class="console">
$ curl -Hhost:mockshop.com http://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com/
V1----------Bootstrap Service Mesh Implementation with Istio----------V1%</pre>
			<p>Go ahead and apply both of <span class="No-Break">the policies:</span></p>
			<pre class="console">
% kubectl apply -f Chapter6/01-requestAuthentication.yaml
requestauthentication.security.istio.io/auth0 created
% kubectl apply -f Chapter6/02-requestAuthorization.yaml
authorizationpolicy.security.istio.io/envoydummy-authz-policy created</pre>
			<p>Check that you are able to <span class="No-Break">access </span><span class="No-Break"><strong class="source-inline">mockshop.com</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
% curl -Hhost:mockshop.com http://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com/
RBAC: access denied</pre>
			<p>The access is denied because we need to provide a valid access token as part of the request. Copy the <a id="_idIndexMarker595"/>access token you got from the previous request and try again in the <span class="No-Break">following fashion:</span></p>
			<pre class="console">
$ curl -Hhost:mockshop.com -H "authorization: Bearer xxxxxx-accesstoken " http://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com/
RBAC: access denied%</pre>
			<p>Although the JWT verification succeeded, the request failed due to RBAC controls. The error is deliberate because instead of providing <strong class="source-inline">read:dummyData</strong> in <strong class="source-inline">Chapter6/02-requestAuthorization.yaml</strong>, we provide <strong class="source-inline">read:profile</strong>. The changes are updated in <strong class="source-inline">Chapter6/03-requestAuthorization.yaml</strong>. Apply the changes and test <span class="No-Break">the APIs:</span></p>
			<pre class="console">
% kubectl apply -f Chapter6/03-requestAuthorization.yaml
authorizationpolicy.security.istio.io/envoydummy-authz-policy configured
$ curl -Hhost:mockshop.com -H "authorization: Bearer xxxxxx-accesstoken " http://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com/
V2----------Bootstrap Service Mesh Implementation with Istio----------V2%</pre>
			<p>To summarize, we did the following, including the <span class="No-Break">previous section:</span></p>
			<ol>
				<li value="1">We configured Auth0 as the authentication provider and <span class="No-Break">OAuth server.</span></li>
				<li>We created a <strong class="source-inline">RequestAuthentication</strong> policy to validate the bearer token provided in <span class="No-Break">the request.</span></li>
				<li>We created an <strong class="source-inline">AuthorizationPolicy</strong> to verify claims presented in the JWT token and whether the claim matched the desired value, then let the request go through <span class="No-Break">the upstream.</span></li>
			</ol>
			<p>Next, we will learn how to configure request authorization in conjunction with <strong class="source-inline">PeerAuthentication</strong>, which we configured in the <em class="italic">Service-to-service </em><span class="No-Break"><em class="italic">authentication</em></span><span class="No-Break"> section.</span></p>
			<p>We will <a id="_idIndexMarker596"/>modify the <strong class="source-inline">curl</strong> Pod to use a different service account, and let’s call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">chapter6sa</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
apiVersion: v1
kind: ServiceAccount
metadata:
  name: chapter6sa
  namespace: utilities</pre>
			<p>As you cannot change the service account of an existing Pod, you need to delete the previous deployment and redeploy with a new <span class="No-Break">service account:</span></p>
			<pre class="console">
Kubectl delete -f Chapter6/01-curl-deployment.yaml
kubectl apply -f Chapter6/02-curl-deployment.yaml</pre>
			<p>You can check that the <strong class="source-inline">curl</strong> Pod is running with the identity of the <strong class="source-inline">chapter6sa</strong> service account. After this, let’s create an <strong class="source-inline">AuthorizationPolicy</strong> to allow a request to the <strong class="source-inline">httpbin</strong> Pod if the principal of the requestor <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">cluster.local/ns/utilities/sa/curl</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
apiVersion: "security.istio.io/v1beta1"
kind: "AuthorizationPolicy"
metadata:
  name: "httpbin-authz-policy"
  namespace: chapter6
spec:
  action: ALLOW
  selector:
    matchLabels:
      app: httpbin
  rules:
  - from:
    - source:
        principals: ["cluster.local/ns/utilities/sa/curl"]
    to:
    - operation:
        methods: ['*']</pre>
			<p>Previously, we looked at <strong class="source-inline">AuthorizationPolicy</strong> and you will be familiar with most of the configuration in this example. In this example, we are building <strong class="source-inline">AuthorizationPolicy</strong> on top of peer authentication rather than request authentication. The <a id="_idIndexMarker597"/>most interesting part is the <strong class="source-inline">source</strong> field in the <strong class="source-inline">rules</strong> section. In the <strong class="source-inline">source</strong> configuration, we define the source identities of the request. All fields in the source request need to match for the rule to <span class="No-Break">be successful.</span></p>
			<p>The following fields can be defined in the <span class="No-Break"><strong class="source-inline">source</strong></span><span class="No-Break"> configuration:</span></p>
			<ul>
				<li><strong class="source-inline">principals</strong>: This is a <a id="_idIndexMarker598"/>list of accepted identities that are derived from the client certificate during mTLS. The values are in the <strong class="source-inline">&lt;TRUST_DOMAIN NAME &gt;/ns/&lt;NAMESPACE NAME&gt;/sa/&lt;SERVICE_ACCOUNT NAME&gt;</strong> format. In this example, the value of principals will <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">cluster.local/ns/utilities/sa/curl</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">notPrincipals</strong>: This is a list of identities from which the request will not <span class="No-Break">be accepted.</span>
The values are derived the same way <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">principals</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">requestPrincipals</strong>: This is a list of accepted identities where the request principal is derived from JWT and is in the <span class="No-Break">format </span><span class="No-Break"><strong class="source-inline">&lt;ISS&gt;/&lt;SUB&gt;</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">notRequestPrincipals</strong>: This is a list of identities from which the request will not be accepted. The principal is derived from the JWT and is in the <span class="No-Break">format </span><span class="No-Break"><strong class="source-inline">&lt;ISS&gt;/&lt;SUB&gt;</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">namespaces</strong>: This is a list of namespaces from which the request will <span class="No-Break">be accepted.</span>
The namespaces are derived from the peer <span class="No-Break">certificate details.</span></li>
				<li><strong class="source-inline">notNamespaces</strong>: This is a list of namespaces from which a request will not <span class="No-Break">be allowed.</span>
The namespaces are derived from the peer <span class="No-Break">certificate details.</span></li>
				<li><strong class="source-inline">ipBlocks</strong>: This is a list of IPs or CIDR blocks from which a request will be accepted. The IP is populated <a id="_idIndexMarker599"/>from the source address of the <span class="No-Break">IP packet.</span></li>
				<li><strong class="source-inline">notIpBlocks</strong>: This is a list of IP blocks from which a request will <span class="No-Break">be rejected.</span></li>
				<li><strong class="source-inline">remoteIpBlocks</strong>: This is a list of IP blocks, populated from the <strong class="source-inline">X-Forwarded-For</strong> header or <span class="No-Break">proxy protocol.</span></li>
				<li><strong class="source-inline">notRemoteIpBlocks</strong>: This is a negative list <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">remoteIpBlocks</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Go ahead and <a id="_idIndexMarker600"/>apply the configuration and test whether you are able to <strong class="source-inline">curl</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">httpbin</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$ kubectl apply -f Chapter6/04-httpbinAuthorizationForSpecificSA.yaml
authorizationpolicy.security.istio.io/httpbin-authz-policy configured
$ kubectl exec -it curl -n utilities -- curl -v http://httpbin.chapter6.svc.cluster.local:8000/headers
*   Trying 172.20.152.62:8000...
* Connected to httpbin.chapter6.svc.cluster.local (172.20.152.62) port 8000 (#0)
&gt; GET /headers HTTP/1.1
&gt; Host: httpbin.chapter6.svc.cluster.local:8000
&gt; User-Agent: curl/7.85.0-DEV
&gt; Accept: */*
&gt;
* Mark bundle as not supporting multiuse
&lt; HTTP/1.1 403 Forbidden
&lt; content-length: 19
&lt; content-type: text/plain
&lt; date: Tue, 20 Sep 2022 02:20:39 GMT
&lt; server: envoy
&lt; x-envoy-upstream-service-time: 15
&lt;
* Connection #0 to host httpbin.chapter6.svc.cluster.local left intact
RBAC: access denied%</pre>
			<p>Istio denies the request from the <strong class="source-inline">curl</strong> Pod to <strong class="source-inline">httpbin</strong> because the peer certificate presented <a id="_idIndexMarker601"/>by the <strong class="source-inline">curl</strong> Pod contains <strong class="source-inline">cluster.local/ns/utilities/sa/chapter6sa</strong> instead of <strong class="source-inline">cluster.local/ns/utilities/sa/curl</strong> as the principal. Although the <strong class="source-inline">curl</strong> Pod is part of the mesh and contains a valid certificate, it is not authorized to access the <span class="No-Break"><strong class="source-inline">httpbin</strong></span><span class="No-Break"> Pod.</span></p>
			<p>Go ahead and fix the problem by assigning the correct service account to the <span class="No-Break"><strong class="source-inline">curl</strong></span><span class="No-Break"> Pod.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You can use the following commands to fix <span class="No-Break">the problem:</span></p>
			<pre class="console">
$ kubectl delete -f Chapter6/02-curl-deployment.yaml
$ kubectl apply -f Chapter6/03-curl-deployment.yaml</pre>
			<p>We will implement one more authorization policy, but this time the policy will enforce that using the <strong class="source-inline">utilities</strong> or <strong class="source-inline">curl</strong> service account, the requestor can access only <strong class="source-inline">/headers</strong> <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">httpbin</strong></span><span class="No-Break">.</span></p>
			<p>Following <a id="_idIndexMarker602"/>is the <span class="No-Break">authorization policy:</span></p>
			<pre class="source-code">
apiVersion: "security.istio.io/v1beta1"
kind: "AuthorizationPolicy"
metadata:
  name: "httpbin-authz-policy"
  namespace: chapter6
spec:
  action: ALLOW
  selector:
    matchLabels:
      app: httpbin
  rules:
  - from:
    - source:
        requestPrincipals: ["cluster.local/ns/utilities/sa/curl"]
  - to:
    - operation:
        methods: ["GET"]
        paths: ["/get"]</pre>
			<p>In this policy, we have defined the <strong class="source-inline">HTTP</strong> method and <strong class="source-inline">HTTP</strong> paths in the <strong class="source-inline">to</strong> field on the rule. The <strong class="source-inline">to</strong> field contains a list of operations on which the rules will be applied. The operation field supports the <span class="No-Break">following parameters:</span></p>
			<ul>
				<li><strong class="source-inline">hosts</strong>: This specifies <a id="_idIndexMarker603"/>a list of hostnames for which the request will be accepted. If it’s not set, then any host <span class="No-Break">is allowed.</span></li>
				<li><strong class="source-inline">notHosts</strong>: This is a negative list <span class="No-Break">of hosts.</span></li>
				<li><strong class="source-inline">ports</strong>: This is a list of ports for which a request will <span class="No-Break">be accepted.</span></li>
				<li><strong class="source-inline">notPorts</strong>: This is a list of negative matches <span class="No-Break">of ports.</span></li>
				<li><strong class="source-inline">methods</strong>: This is a list of methods as specified in the HTTP request. If not set, any method <span class="No-Break">is allowed.</span></li>
				<li><strong class="source-inline">notMethods</strong>: This is a list of negative matches of methods as specified in the <span class="No-Break">HTTP request.</span></li>
				<li><strong class="source-inline">paths</strong>: This is a list of paths as specified in the HTTP request. Paths are normalized as <span class="No-Break">per </span><a href="https://istio.io/latest/docs/reference/config/security/normalization/"><span class="No-Break">https://istio.io/latest/docs/reference/config/security/normalization/</span></a><span class="No-Break">.</span></li>
				<li><strong class="source-inline">notPaths</strong>: This is a list of negative matches <span class="No-Break">of paths.</span></li>
			</ul>
			<p>Apply <span class="No-Break">the changes:</span></p>
			<pre class="console">
kubectl apply -f Chapter6/05-httpbinAuthorizationForSpecificPath.yaml</pre>
			<p>And then <a id="_idIndexMarker604"/>try to <span class="No-Break">access </span><span class="No-Break"><strong class="source-inline">httpbin</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
kubectl exec -it curl -n utilities -- curl -X GET -v http://httpbin.chapter6.svc.cluster.local:8000/headers
……
RBAC: access denied%</pre>
			<p>Access to the request is denied because the authorization policy only allows the <strong class="source-inline">/get</strong> request made using the HTTP GET method. The following is the <span class="No-Break">correct request:</span></p>
			<pre class="console">
kubectl exec -it curl -n utilities -- curl -X GET -v http://httpbin.chapter6.svc.cluster.local:8000/get</pre>
			<p>This concludes our lesson on how you can build custom policies for performing request authentication and request authorization. To get more familiar with them, I suggest going through the examples in this chapter a few times and maybe building your own variations to learn how to use these <span class="No-Break">policies effectively.</span></p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>Summary</h1>
			<p>In this chapter, we read about how Istio provides authentication and authorization. We also read about how to implement service-to-service authentication using mutual TLS within a Service Mesh using the <strong class="source-inline">PeerAuthentication</strong> policy, as well as mutual TLS with clients external to a Service Mesh by using the <em class="italic">mutual</em> TLS mode at the Ingress gateway. We then read about end user authentication using the <strong class="source-inline">RequestAuthentication</strong> policy. We configured Auth0 to gain some real-life experience in using authentication and <span class="No-Break">identity providers.</span></p>
			<p>To finish off, we then read about <strong class="source-inline">AuthorizationPolicy</strong> and how it can be used to enforce various authorization checks to ensure that the authenticated identity is authorized to access the <span class="No-Break">requested resources.</span></p>
			<p>In the next chapter, we will read about how Istio helps in making microservices observable and how various observability tools and software can be integrated <span class="No-Break">with Istio.</span></p>
		</div>
	</body></html>