<html><head></head><body>
<div id="_idContainer044">
<h1 class="chapter-number" id="_idParaDest-165"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-166"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.2.1">Exploring Cloud Secret Store on Azure</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Previously, we did a deep dive into Secrets Manager on AWS. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we shall focus on another popular cloud provider, Microsoft Azure. </span><span class="koboSpan" id="kobo.3.3">We will learn about Azure Key Vault, a solution provided by Azure to store Secrets and perform encryption and decryption. </span><span class="koboSpan" id="kobo.3.4">We will utilize Azure Key Vault in order to store Secrets and use them on our Kubernetes workloads and we also utilize Key Vault to encrypt the Secrets that reside </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">on etcd.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Overview of Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">Key Vault</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Introduction to </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Workload Identity</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">AKS cluster and Azure Key </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Vault integration</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Auditing </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">and logging</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Azure Key Vault for </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">secret encryption</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">By the end of this chapter, we should be able to store our Secrets in Azure Key Vault, retrieve them on a Kubernetes deployment, monitor secret access through auditing, and encrypt Kubernetes Secrets using Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Key Vault.</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">To link concepts with hands-on examples, we are leveraging a series of tools and platforms commonly used to interact with the Azure API </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">and Kubernetes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.22.1">Azure (az) CLI</span></strong><span class="koboSpan" id="kobo.23.1"> (</span><a href="https://learn.microsoft.com/en-us/cli/azure/"><span class="koboSpan" id="kobo.24.1">https://learn.microsoft.com/en-us/cli/azure/</span></a><span class="koboSpan" id="kobo.25.1">) is a multi-platform set of </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.26.1">command-line tools used in order to create and manage </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Azure resources</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.28.1">Terraform</span></strong><span class="koboSpan" id="kobo.29.1"> (</span><a href="https://www.terraform.io/"><span class="koboSpan" id="kobo.30.1">https://www.terraform.io/</span></a><span class="koboSpan" id="kobo.31.1">) is an infrastructure-as-code software solution that can be </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.32.1">used to provision and manage infrastructure on </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">the cloud</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.34.1">kubectl</span></strong><span class="koboSpan" id="kobo.35.1"> (</span><a href="https://kubernetes.io/docs/reference/kubectl/"><span class="koboSpan" id="kobo.36.1">https://kubernetes.io/docs/reference/kubectl/</span></a><span class="koboSpan" id="kobo.37.1">) is the command-line tool used for </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.38.1">communicating with a Kubernetes cluster through the </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">Kubernetes API</span></span></li>
</ul>
<h1 id="_idParaDest-168"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.40.1">Overview of Azure Key Vault</span></h1>
<p><span class="koboSpan" id="kobo.41.1">Azure Key Vault is a </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.42.1">versatile service. </span><span class="koboSpan" id="kobo.42.2">It can be used as a secret storage. </span><span class="koboSpan" id="kobo.42.3">On Azure Key Vault, we can store cryptographic keys. </span><span class="koboSpan" id="kobo.42.4">Also, Azure Key Vault can be used to perform encryption and </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">decryption operations.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Since it is a managed Azure service, it benefits from the features that Azure provides by default on </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">its services.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">The features of interest are </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.48.1">Azure RBAC and </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">access policy</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.50.1">High availability</span></span></li>
<li><span class="koboSpan" id="kobo.51.1">Logging, auditing, </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">and monitoring</span></span></li>
<li><span class="koboSpan" id="kobo.53.1">Integration with other </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">Azure components</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.55.1">We will take some time to examine these features that are crucial to the security of </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">our Secrets.</span></span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.57.1">Azure RBAC and access policy</span></h2>
<p><span class="koboSpan" id="kobo.58.1">Every</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.59.1"> service on Azure is protected from unauthorized usage through an identity access management layer that Azure provides. </span><span class="koboSpan" id="kobo.59.2">This layer comes in the form of Azureâ€™s RBAC and access policy. </span><span class="koboSpan" id="kobo.59.3">A security principal</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.60.1"> is an entity that has an identity on Azure and can be a user account, group account, or computer account. </span><span class="koboSpan" id="kobo.60.2">The legacy way of assigning permissions to security principals is </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.61.1">through </span><em class="italic"><span class="koboSpan" id="kobo.62.1">access policies</span></em><span class="koboSpan" id="kobo.63.1">. </span><span class="koboSpan" id="kobo.63.2">The recommended way to </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.64.1">assign permissions is through </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">Azure role-based access control</span></strong><span class="koboSpan" id="kobo.66.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.67.1">Azure RBAC</span></strong><span class="koboSpan" id="kobo.68.1">). </span><span class="koboSpan" id="kobo.68.2">Azure RBAC will be our choice to secure Azure Key Vault as we progress through the chapter. </span><span class="koboSpan" id="kobo.68.3">By using Azure RBAC, we will control access to resources by creating </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">role assignments.</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.70.1">High availability</span></h2>
<p><span class="koboSpan" id="kobo.71.1">When we</span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.72.1"> create a Key Vault, we must specify the region where the Key Vault would be located. </span><span class="koboSpan" id="kobo.72.2">The contents of the Key Vault are replicated within this region. </span><span class="koboSpan" id="kobo.72.3">Also, the contents of the Key Vault will be replicated to a secondary region. </span><span class="koboSpan" id="kobo.72.4">Azure Key Vault contents are regionally highly available but also, they support disaster </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">recovery out-of-the-box.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">Imagine the scenario of a region becoming unavailable. </span><span class="koboSpan" id="kobo.74.2">Once the region becomes unavailable, the requests toward Azure Key Vault will be routed to the secondary region. </span><span class="koboSpan" id="kobo.74.3">This will happen automatically; there is no need to provision any extra Azure Key Vault resources or configure a fallback to a Key Vault residing in </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">another region.</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.76.1">Logging, auditing, and monitoring</span></h2>
<p><span class="koboSpan" id="kobo.77.1">In Azure, we have </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.78.1">the option to audit the usage of a Key Vault. </span><span class="koboSpan" id="kobo.78.2">By enabling auditing, we can identify who accessed the data hosted on Azure Key Vault. </span><span class="koboSpan" id="kobo.78.3">We can achieve this by</span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.79.1"> collecting the logs through </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">Diagnostic settings</span></strong><span class="koboSpan" id="kobo.81.1">. </span><span class="koboSpan" id="kobo.81.2">Resources on Azure produce logs, and those logs contain information about the resources and the operations that take place involving each resource. </span><span class="koboSpan" id="kobo.81.3">Based on the</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.82.1"> resource, the content of the logs </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">may vary.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.84.1">Diagnostic settings</span></strong><span class="koboSpan" id="kobo.85.1"> give us the option to stream those logs to various locations. </span><span class="koboSpan" id="kobo.85.2">By default, the logs will be streamed to an Azure storage account. </span><span class="koboSpan" id="kobo.85.3">Other options are to stream the logs to the Log Analytics workspace or to the Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">Event Hub.</span></span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.87.1">Integration with other Azure components</span></h2>
<p><span class="koboSpan" id="kobo.88.1">An important </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.89.1">benefit of Azure Key Vault is the integration with other Azure components. </span><span class="koboSpan" id="kobo.89.2">Azure Key Vault can be integrated with the Azure Application Gateway for traffic encryption or with the SQL Server offering from Azure, to encrypt the data. </span><span class="koboSpan" id="kobo.89.3">One of the components of interest is the Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">Kubernetes Service.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">This is enabled using the Kubernetes Secrets Store CSI Driver for Azure Key Vault. </span><span class="koboSpan" id="kobo.91.2">We saw in the previous chapter how the CSI Secret </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">Store works.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">The</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.94.1"> following figure shows how the </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">integration works:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.96.1"><img alt="Figure 9.1 â€“ Azure Key Vault integration" src="image/B20970_09_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.97.1">Figure 9.1 â€“ Azure Key Vault integration</span></p>
<p><span class="koboSpan" id="kobo.98.1">In this chapter, we will take advantage of Azure CSI Key Vault plugin and integrate it with Azure securely. </span><span class="koboSpan" id="kobo.98.2">The integration will involve a </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.99.1">Kubernetes cluster in Azure using </span><strong class="bold"><span class="koboSpan" id="kobo.100.1">Azure Kubernetes Service</span></strong><span class="koboSpan" id="kobo.101.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.102.1">AKS</span></strong><span class="koboSpan" id="kobo.103.1">). </span><span class="koboSpan" id="kobo.103.2">To integrate these two components, Azure Key Vault and the Kubernetes cluster, it is crucial to have fine-grained permissions from the cluster toward Azure Key Vault. </span><span class="koboSpan" id="kobo.103.3">For this, Azure provides us with the concept of </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">Workload Identity.</span></span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.105.1">Introduction to Workload Identity</span></h1>
<p><span class="koboSpan" id="kobo.106.1">Workload Identity on AKS on </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.107.1">Azure enables us to assign permissions to Kubernetes workloads so they can interact with Azure resources. </span><span class="koboSpan" id="kobo.107.2">For example, we have an Azure Key Vault that we use to store sensitive information. </span><span class="koboSpan" id="kobo.107.3">To interact with Azure Key Vault, we need some form of credentials. </span><span class="koboSpan" id="kobo.107.4">Workload Identities are machine identities representing software workloads that require identities to interact with Azure resources. </span><span class="koboSpan" id="kobo.107.5">Instead of creating an identity or a service principal, we can use Workload Identity by manually attaching their credentials to the service. </span><span class="koboSpan" id="kobo.107.6">This way, each service can have its own identity and authenticate </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">by itself.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">In Kubernetes, we can assign a Workload Identity to our Pods. </span><span class="koboSpan" id="kobo.109.2">By granting the RBAC permissions to this identity, we will be able to interact with Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">Key Vault.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">Here is an example of how </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.112.1">Workload </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">Identity works:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.114.1"><img alt="Figure 9.2 â€“ ï»¿ Workload Identity behind the scenes (ï»¿source: https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview?tabs=dotnet)" src="image/B20970_09_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.115.1">Figure 9.2 â€“  Workload Identity behind the scenes (source: </span><a href="https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview?tabs=dotnet"><span class="koboSpan" id="kobo.116.1">https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview?tabs=dotnet</span></a><span class="koboSpan" id="kobo.117.1">)</span></p>
<p><span class="koboSpan" id="kobo.118.1">The official documentation of Azure has a detailed overview of how a Workload Identity requests a token from the Azure Active Directory and then uses that token to interact with an Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">resource (</span></span><a href="https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview"><span class="No-Break"><span class="koboSpan" id="kobo.120.1">https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.121.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">Since weâ€™ve acquired an understanding of the Workload Identity concept, we can proceed and learn more about how Azure enables the interaction between AKS and other Azure resources, such as Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">Key Vault.</span></span></p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.124.1">Integrating an AKS cluster and Azure Key Vault</span></h1>
<p><span class="koboSpan" id="kobo.125.1">To integrate </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.126.1">Kubernetes with Azure Key Vault, we need to have a cluster set up. </span><span class="koboSpan" id="kobo.126.2">There are various options to create a cluster and each choice applies to the needs of certain circumstances. </span><span class="koboSpan" id="kobo.126.3">We shall create a simple AKS cluster; the master will be publicly available, but the nodes will reside on a private subnet of a </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">virtual network.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">We will provide some Terraform code for the scope of creating the cluster. </span><span class="koboSpan" id="kobo.128.2">Also, we shall provide the commands needed in case Terraform is </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">not applicable.</span></span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.130.1">Configuring the Terraform project</span></h2>
<p><span class="koboSpan" id="kobo.131.1">While creating the </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.132.1">Terraform project, we will configure the state. </span><span class="koboSpan" id="kobo.132.2">The state can be saved in a </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">storage account:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.134.1">
terraform {
...
</span><span class="koboSpan" id="kobo.134.2">Â Â Â Â Â Â backend "azurerm" {
Â Â Â Â Â Â Â Â resource_group_nameÂ Â = "resource-group"
Â Â Â Â Â Â Â Â storage_account_name = "storage-account"
Â Â Â Â Â Â Â Â container_nameÂ Â Â Â Â Â Â = "tfstate"
Â Â Â Â Â Â Â Â keyÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â = "aks.tfstate"
Â Â Â Â }
}</span></pre> <p><span class="koboSpan" id="kobo.135.1">By setting up the Terraform configuration, we can proceed and provision resources </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">on Azure.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">It is crucial to provision the resources for this chapter under one </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">resource group:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.139.1">
resource "azurerm_resource_group" "ksm_resource_group" {
Â Â nameÂ Â Â Â Â = "ksm-resource-group"
}</span></pre> <p><span class="koboSpan" id="kobo.140.1">By using a resource group, we logically separate our resources from other resources on our Azure account, specifically to the solution we want </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">to implement.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">Also, we shall create a storage account to persist logs from </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">our services:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.144.1">
resource "azurerm_storage_account" "ksm_storage_account" {
Â Â name = "ksmlogs"
Â Â resource_group_name = azurerm_resource_group.ksm_resource_group.name
Â Â â€¦
}</span></pre> <p><span class="koboSpan" id="kobo.145.1">As mentioned in the </span><em class="italic"><span class="koboSpan" id="kobo.146.1">Overview of Azure Key Vault</span></em><span class="koboSpan" id="kobo.147.1"> section, through </span><strong class="bold"><span class="koboSpan" id="kobo.148.1">Diagnostics settings</span></strong><span class="koboSpan" id="kobo.149.1">, we</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.150.1"> can enable the logs of an Azure resource to be streamed to a storage account. </span><span class="koboSpan" id="kobo.150.2">The storage account we provisioned will serve </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">this purpose.</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">We can now proceed with creating </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">the network.</span></span></p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.154.1">Provisioning the network</span></h2>
<p><span class="koboSpan" id="kobo.155.1">We will create a virtual</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.156.1"> network, and we will allocate a subset of private IPs. </span><span class="koboSpan" id="kobo.156.2">We shall also create a subnet on which we will be able to host the Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">cluster nodes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.158.1">
resource "azurerm_virtual_network" "ksm_virtual_network" {
Â Â nameÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â = "ksm-virtual-network"
Â Â ...
</span><span class="koboSpan" id="kobo.158.2">Â Â address_spaceÂ Â Â Â Â Â Â = ["10.1.0.0/16"]
}
resource "azurerm_subnet" "ksm_subnet" {
Â Â nameÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â = "ksm-private-subnt"
Â Â ...
</span><span class="koboSpan" id="kobo.158.3">Â Â address_prefixesÂ Â Â Â Â = ["10.1.0.0/24"]
Â Â enforce_private_link_endpoint_network_policies = true
}</span></pre> <p><span class="koboSpan" id="kobo.159.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">enforce_private_link_endpoint_network_policies</span></strong><span class="koboSpan" id="kobo.161.1"> option is enabled. </span><span class="koboSpan" id="kobo.161.2">Through this option, the applications hosted in this subnet can access Azure components through the </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">internal network.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.163.1">Provisioning the AKS cluster</span></h2>
<p><span class="koboSpan" id="kobo.164.1">We will create an </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.165.1">AKS cluster by creating the master and adding a default </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">node pool:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.167.1">
resource "azurerm_kubernetes_cluster" "ksm_aks" {
Â Â name = "ksm-aks"
Â Â ...
</span><span class="koboSpan" id="kobo.167.2">Â Â dns_prefix = "private-aks-cluster"
Â Â private_cluster_enabled = false
Â Â oidc_issuer_enabled = true
Â Â workload_identity_enabled = true
Â Â role_based_access_control_enabled = true
...
</span><span class="koboSpan" id="kobo.167.3">Â Â default_node_pool {
Â Â Â Â nameÂ Â Â Â Â Â Â Â Â Â Â = "default"
Â Â Â Â node_countÂ Â Â Â Â = 1
Â Â Â Â vm_sizeÂ Â Â Â Â Â Â Â = "Standard_A2_v2"
Â Â Â Â vnet_subnet_id = azurerm_subnet.ksm_subnet.id
Â Â }
}</span></pre> <p><span class="koboSpan" id="kobo.168.1">An important</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.169.1"> thing to note is that we </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.170.1">enable the </span><strong class="bold"><span class="koboSpan" id="kobo.171.1">OpenID Connect</span></strong><span class="koboSpan" id="kobo.172.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.173.1">OIDC</span></strong><span class="koboSpan" id="kobo.174.1">) feature and the Workload Identity. </span><span class="koboSpan" id="kobo.174.2">This gives us the ability to assign roles to our Kubernetes workloads so that they can interact with Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">Key Vault.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">After using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">terraform apply</span></strong><span class="koboSpan" id="kobo.178.1"> command, the cluster will </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">be provisioned:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.180.1">
$ terraform init
...
</span><span class="koboSpan" id="kobo.180.2">$ terraform apply</span></pre> <p><span class="koboSpan" id="kobo.181.1">We have the option to implement a fully private cluster using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">private_cluster_enabled</span></strong><span class="koboSpan" id="kobo.183.1"> option. </span><span class="koboSpan" id="kobo.183.2">In the repo, you can find the settings to create the bastion host to enable this </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">action (</span></span><a href="https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook/blob/main/ch09/bastion.tf"><span class="No-Break"><span class="koboSpan" id="kobo.185.1">https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook/blob/main/ch09/bastion.tf</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.186.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">Alternatively, if we do not want to provision the cluster through Terraform, we can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">command line:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.189.1">
$ az aks create -n ksm-aks -g ksm-resource-group --enable-addons azure-keyvault-secrets-provider --enable-oidc-issuer --enable-workload-identity</span></pre> <p><span class="koboSpan" id="kobo.190.1">We can now successfully log in to </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">our cluster:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.192.1">
$ az aks get-credentials --name ksm-aks \
Â Â Â Â --resource-group ksm-resource-group \
Â Â Â Â --subscription $subscription \
Â Â Â Â --admin</span></pre> <p><span class="koboSpan" id="kobo.193.1">By</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.194.1"> executing the preceding command, we will set up a configuration for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">kubectl</span></strong><span class="koboSpan" id="kobo.196.1"> command. </span><span class="koboSpan" id="kobo.196.2">This configuration resides on the local </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">~/.kube/config</span></strong><span class="koboSpan" id="kobo.198.1"> path of the workstation used to execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">kubectl</span></strong><span class="koboSpan" id="kobo.200.1"> commands. </span><span class="koboSpan" id="kobo.200.2">Now we should be able to execute commands toward </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">the cluster.</span></span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.202.1">Creating a Key Vault</span></h2>
<p><span class="koboSpan" id="kobo.203.1">We shall proceed and create a</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.204.1"> Key Vault resource; then, on that Key Vault, we shall create a key and a secret. </span><span class="koboSpan" id="kobo.204.2">We will assign fine-grained permissions to make it feasible to interact with the Key Vault through </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">RBAC</span></span><span class="No-Break"><a id="_idIndexMarker535"/></span><span class="No-Break"><span class="koboSpan" id="kobo.206.1"> permissions.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">First, we create the Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">Key Vault:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.209.1">
resource "azurerm_key_vault" "ksm_key_vault" {
Â Â nameÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â = "ksm-key-vault"
Â Â ...
</span><span class="koboSpan" id="kobo.209.2">Â Â sku_nameÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â = "standard"
Â Â enable_rbac_authorization = true
Â Â soft_delete_retention_days = 7
}</span></pre> <p><span class="koboSpan" id="kobo.210.1">As you can see, we enabled the RBAC option. </span><span class="koboSpan" id="kobo.210.2">Since we enabled RBAC, we will create an identity that can be used with our </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">Kubernetes workloads:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.212.1">
resource "azurerm_user_assigned_identity" "keyvault_reader" {
Â Â nameÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â = "keyvault-reader"
Â Â ...
</span><span class="koboSpan" id="kobo.212.2">}
resource "azurerm_role_assignment" "ksm_key_vault_reader" {
Â Â scope = azurerm_key_vault.ksm_key_vault.id
Â Â role_definition_name = "Key Vault Reader"
Â Â principal_idÂ Â Â Â Â Â Â Â Â = azurerm_user_assigned_identity.keyvault_reader.principal_id
}
...</span></pre> <p><span class="koboSpan" id="kobo.213.1">We created the identity and attached the permissions enabling us to use the Secrets and view them. </span><span class="koboSpan" id="kobo.213.2">The next step is to set up the credentials for the federated identity. </span><span class="koboSpan" id="kobo.213.3">We need to use the OIDC</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.214.1"> issuer URL from</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.215.1"> the cluster we </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">provisioned previously:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.217.1">
resource "azurerm_federated_identity_credential" "cred" {
 nameÂ Â Â = "ksm-reader-identity"
 ...
 </span><span class="koboSpan" id="kobo.217.2">Issuer =azurerm_kubernetes_cluster.ksm_aks.oidc_issuer_url
 audienceÂ Â = ["api://AzureADTokenExchange"]
 parent_id = azurerm_user_assigned_identity.keyvault_reader.id
Â Â subject = "system:serviceaccount:default:service-token-reader"
}</span></pre> <p><span class="koboSpan" id="kobo.218.1">Alternatively, we can create the Key Vault through the </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">command line:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.220.1">
$ az keyvault create -n ksm-key-vault -g ksm-resource-groupÂ Â -l eastus --enable-rbac-authorization
az identity create --name keyvault-reader --resource-group ksm-resource-group
...
</span><span class="koboSpan" id="kobo.220.2">az identity federated-credential create \
Â Â --name "ksm-reader-identity" ...</span></pre> <p><span class="koboSpan" id="kobo.221.1">By provisioning the identity credential, we can now interact with Azure Key Vault through Kubernetes. </span><span class="koboSpan" id="kobo.221.2">The federated identity credentials enable us to access resources protected by Active</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.222.1"> Directory. </span><span class="koboSpan" id="kobo.222.2">The</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.223.1"> federated credential that we used establishes a trust relationship with the identity provider of our AKS cluster and Active Directory. </span><span class="koboSpan" id="kobo.223.2">We allow the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">service-token-reader</span></strong><span class="koboSpan" id="kobo.225.1"> service account to </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">impersonate </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">ksm-reader-identity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.229.1">Reading Secrets from the Key Vault</span></h3>
<p><span class="koboSpan" id="kobo.230.1">We have our AKS cluster</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.231.1"> set up and our </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">kubectl</span></strong><span class="koboSpan" id="kobo.233.1"> command is ready</span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.234.1"> to execute commands to the cluster. </span><span class="koboSpan" id="kobo.234.2">So far, we have not had to install any plugins. </span><span class="koboSpan" id="kobo.234.3">This is because the plugins were enabled when creating the </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">AKS cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">We can check this by running the following command on the </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">CSI plugin:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.238.1">
kubectl get pods -n kube-system -l 'app in (secrets-store-csi-driver,secrets-store-provider-azure)'
NAMEÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â READYÂ Â Â STATUSÂ Â Â Â RESTARTSÂ Â AGE
aks-secrets-store-csi-driver-t6n7hÂ Â Â Â 3/3Â Â Â Â Â RunningÂ Â Â 0Â Â Â Â Â Â Â Â Â 80m
aks-secrets-store-provider-azure-htmqkÂ 1/1Â Â Â Â Â RunningÂ Â Â 0Â Â Â Â Â Â Â Â 80m</span></pre> <p><span class="koboSpan" id="kobo.239.1">The CSI </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.240.1">driver that will enable us to fetch credentials from the Key Vault is already enabled. </span><span class="koboSpan" id="kobo.240.2">Along with the CSI driver, we have a new object type </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.241.1">created on Kubernetes: </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">SecretProviderClass</span></strong><span class="koboSpan" id="kobo.243.1">. </span><span class="koboSpan" id="kobo.243.2">This custom resource is used to provide driver configurations and provider-specific parameters to the CSI driver. </span><span class="koboSpan" id="kobo.243.3">In Kubernetes, a </span><strong class="bold"><span class="koboSpan" id="kobo.244.1">custom resource</span></strong><span class="koboSpan" id="kobo.245.1"> is an extension of the Kubernetes API. </span><span class="koboSpan" id="kobo.245.2">We specify a new kind of object that is </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.246.1">accessed through the Kubernetes API just like all the other Kubernetes resources. </span><span class="koboSpan" id="kobo.246.2">We can find more information on custom resources through the official </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">documentation (</span></span><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/"><span class="No-Break"><span class="koboSpan" id="kobo.248.1">https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.249.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">We will </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">create </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">SecretProviderClass</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.254.1">
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
Â Â name: keyvault-secrets
spec:
Â Â provider: azure
Â Â parameters:
Â Â Â Â usePodIdentity: "false"
Â Â Â Â clientID: #the identity provisioned
Â Â Â Â keyvaultName: #keyvault name
Â Â Â Â ...
</span><span class="koboSpan" id="kobo.254.2">Â Â Â Â objects:Â Â |
Â Â Â Â Â Â array:
Â Â Â Â Â Â Â Â - |
Â Â Â Â Â Â Â Â Â Â objectName: secret1
Â Â Â Â Â Â Â Â Â Â objectType: secret
Â Â Â Â Â Â Â Â - |
Â Â Â Â Â Â Â Â Â Â objectName: key1
Â Â Â Â Â Â Â Â Â Â objectType: key
Â Â Â Â tenantId: #kubernetes tenant id</span></pre> <p><span class="koboSpan" id="kobo.255.1">We can</span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.256.1"> now provision the service account that will have the</span><a id="_idIndexMarker546"/> <span class="No-Break"><span class="koboSpan" id="kobo.257.1">identity attached:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.258.1">
apiVersion: v1
kind: ServiceAccount
metadata:
Â Â annotations:
Â Â Â Â azure.workload.identity/client-id: #identity with Key Vault access
Â Â labels:
Â Â Â Â azure.workload.identity/use: "true"
Â Â name: service-token-reader
Â Â namespace: default</span></pre> <p><span class="koboSpan" id="kobo.259.1">Essentially, the identity used is the identity that we provisioned previously with the purpose of interacting with Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">Key Vault.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">After applying the following, we can set up a Pod that will use the Key </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">Vault credentials:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.263.1">
kind: Pod
apiVersion: v1
metadata:
Â Â name: nginx
spec:
Â Â serviceAccountName: service-token-reader
Â Â containers:
Â Â Â Â - name: nginx
Â Â Â Â Â Â image: nginx
Â Â Â Â Â Â volumeMounts:
Â Â Â Â Â Â - name: keyvault-secrets
Â Â Â Â Â Â Â Â mountPath: "/mnt/secrets-store"
Â Â Â Â Â Â Â Â readOnly: true
Â Â volumes:
Â Â Â Â - name: keyvault-secrets
Â Â Â Â Â Â csi:
Â Â Â Â Â Â Â Â driver: secrets-store.csi.k8s.io
Â Â Â Â Â Â Â Â readOnly: true
Â Â Â Â Â Â Â Â volumeAttributes:
Â Â Â Â Â Â Â Â Â Â secretProviderClass: "keyvault-secrets"</span></pre> <p><span class="koboSpan" id="kobo.264.1">As of now, we </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.265.1">have achieved our main goal, which is to use </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.266.1">Key Vault Secrets through Azure Key Vault. </span><span class="koboSpan" id="kobo.266.2">We did achieve access to the Key Vault Secrets, so the next thing to check is whether auditing of Key Vault access </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">is feasible.</span></span></p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.268.1">Auditing and logging</span></h1>
<p><span class="koboSpan" id="kobo.269.1">In the previous </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.270.1">section, we created the Key Vault on Azure. </span><span class="koboSpan" id="kobo.270.2">Azure provides us with the option to enable auditing for the resources </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">we provision.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">In our case, we add a block that enables us to store the audit logs of Key Vault access to a </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">storage account.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">Let us perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">Terraform code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.276.1">
resource "azurerm_monitor_diagnostic_setting" "ksm_key_vault_logs" {
Â Â nameÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â = "ksm-key-vault-logs"
Â Â target_resource_id = azurerm_key_vault.ksm_key_vault.id
Â Â storage_account_id = azurerm_storage_account.ksm_storage_account.id
Â Â log {
Â Â Â Â category = "AuditEvent"
Â Â Â Â enabledÂ Â = true
Â Â Â Â retention_policy {
Â Â Â Â Â Â enabled = false
Â Â Â Â }
Â Â }
...
</span><span class="koboSpan" id="kobo.276.2">}</span></pre> <p><span class="koboSpan" id="kobo.277.1">Weâ€™ve enabled Azure to capture the logs needed for auditing through a </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">storage account.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.279.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.280.1">Take note that we have set a retention policy on the log. </span><span class="koboSpan" id="kobo.280.2">At the time of writing, it has been announced that the </span><strong class="bold"><span class="koboSpan" id="kobo.281.1">Diagnostic Settings Storage Retention</span></strong><span class="koboSpan" id="kobo.282.1"> feature</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.283.1"> is being deprecated, thus the retention for logs and metrics should be configured through Azure Storage </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">Lifecycle Management.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">If we navigate</span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.286.1"> to the bucket, there should be a container created on that storage account. </span><span class="koboSpan" id="kobo.286.2">The container will have the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">insights-logs-auditevent</span></strong><span class="koboSpan" id="kobo.288.1">, and the files in the container will be in the </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">JSON format.</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">Let us examine one of </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">the files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.292.1">
{
Â Â "time": "2023-08-30T09:07:19.8593007Z",
Â Â "category": "AuditEvent",
Â Â "operationName": "KeyGet",
Â Â "resultType": "Success",
Â Â "correlationId": "fa11ea42-67c0-47cd-8a6b-f7bcb349414f",
Â Â "identity": {
Â Â Â Â "claim": {
Â Â Â Â Â Â "oid": "80dd018c-ede7-42f4-99a8-00e278868a7c",
Â Â Â Â Â Â "appid": "b1967275-af7b-4d75-9804-c935ecb22226",
Â Â Â Â Â Â "xms_mirid": "/subscriptions/.../userAssignedIdentities/keyvault-reader",
Â Â Â Â Â Â "xms_az_nwperimid": []
Â Â Â Â }
Â Â },
Â Â "properties": {
Â Â Â Â "id": "https://ksm-key-vault.vault.azure.net/keys/key1",
Â Â Â Â "requestUri": "https://ksm-key-vault.vault.azure.net/keys/key1/?api-version=2016-10-01",
Â Â Â Â "isRbacAuthorized": true,
Â Â Â Â ...
</span><span class="koboSpan" id="kobo.292.2">Â Â },
Â Â ...
</span><span class="koboSpan" id="kobo.292.3">}</span></pre> <p><span class="koboSpan" id="kobo.293.1">We can see the</span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.294.1"> category and the operation. </span><span class="koboSpan" id="kobo.294.2">Also, the identity is the one we attached to Kubernetes previously. </span><span class="koboSpan" id="kobo.294.3">Through audit logs, we can identify the actions that took place, the actor of those actions, and the resource upon which the actions took place, which in our case is the Key Vault </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">we provisioned.</span></span></p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.296.1">Azure Key Vault for secret encryption</span></h1>
<p><span class="koboSpan" id="kobo.297.1">So far, weâ€™ve used Azure Key Vault to store </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.298.1">sensitive Secrets. </span><span class="koboSpan" id="kobo.298.2">What we want to identify is whether we can use Azure Key Vault to encrypt the Secrets that reside </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">on etcd.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">Weâ€™ve already created a Key Vault. </span><span class="koboSpan" id="kobo.300.2">We shall use that Key Vault to create a </span><em class="italic"><span class="koboSpan" id="kobo.301.1">key</span></em><span class="koboSpan" id="kobo.302.1"> used for </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">KMS purposes.</span></span></p>
<p><span class="koboSpan" id="kobo.304.1">We</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.305.1"> will create a </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">key first:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.307.1">
resource "azurerm_key_vault_key" "ksm_encryption_key" {
Â Â nameÂ Â Â Â Â Â Â Â Â = "ksm-encryption-key"
Â Â key_vault_id = azurerm_key_vault.ksm_key_vault.id
Â Â key_typeÂ Â Â Â Â = "RSA"
Â Â key_sizeÂ Â Â Â Â = 2048
Â Â Â Â key_opts = [
Â Â Â Â "decrypt",
Â Â Â Â "encrypt",
Â Â Â Â "sign",
Â Â Â Â "unwrapKey",
Â Â Â Â "verify",
Â Â Â Â "wrapKey",
Â Â ]
 }</span></pre> <p><span class="koboSpan" id="kobo.308.1">Take note that we can also specify a </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">rotation policy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.310.1">
rotation_policy {Â Â Â Â automatic {Â Â Â Â Â Â time_before_expiry = "P30D"Â Â Â Â }Â Â Â Â expire_afterÂ Â Â Â Â Â Â Â Â = "P90D"Â Â Â Â notify_before_expiry = "P29D"Â Â }</span></pre> <p><span class="koboSpan" id="kobo.311.1">When we create the Kubernetes cluster, we can use this key to encrypt the Secrets </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">we create.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">In the AKS </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.314.1">section, we shall put </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">this option:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.316.1">
resource "azurerm_kubernetes_cluster" "ksm_aks" {
Â Â name = "ksm-aks"
Â Â ...
</span><span class="koboSpan" id="kobo.316.2">Â Â key_management_service {
Â Â Â Â key_vault_key_id = azurerm_key_vault_key.ksm_encryption_key.id
Â Â Â Â key_vault_network_access = "Public"
Â Â }
Â Â ...
</span><span class="koboSpan" id="kobo.316.3">}</span></pre> <p><span class="koboSpan" id="kobo.317.1">Weâ€™ve</span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.318.1"> successfully encrypted our Secrets on etcd using Azure Key Vault as a KMS. </span><span class="koboSpan" id="kobo.318.2">We can also check this through the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">audit logs:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
{
Â Â "time": "2023-09-03T11:46:27.5820050Z",
Â Â "category": "AuditEvent",
Â Â "operationName": </span><strong class="bold"><span class="koboSpan" id="kobo.321.1">"KeyDecrypt"</span></strong><span class="koboSpan" id="kobo.322.1">,
Â Â "resultType": "Success",
Â Â "identity": {
Â Â Â Â "claim": {
Â Â Â Â Â Â "xms_az_rid": "/subscriptions/.../managedClusters/ksm-aks",
Â Â Â Â Â Â "xms_az_nwperimid": []
Â Â Â Â }
Â Â },
Â Â "properties": {
Â Â Â Â "id": "https://ksm-key-vault.vault.azure.net/keys/ksm-encryption-key/0c24b95c67534a3eb85c71854dc8a7bd",
Â Â Â Â "algorithm": "RSA-OAEP-256",
Â Â Â Â "clientInfo": "... </span><span class="koboSpan" id="kobo.322.2">k8s-kms-keyvault/v0.5.0 (linux/amd64) 84fa3b7/2023-05-17-21:13",
Â Â Â Â "httpStatusCode": 200,
Â Â Â Â ..
</span><span class="koboSpan" id="kobo.322.3">Â Â Â Â "tlsVersion": "TLS1_2"
Â Â },
}</span></pre> <p><span class="koboSpan" id="kobo.323.1">As we can </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.324.1">see, Azure Key Vault is actively being used to decrypt the Secrets hosted on AKS. </span><span class="koboSpan" id="kobo.324.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">KeyDecrypt</span></strong><span class="koboSpan" id="kobo.326.1"> operation indicates the decryption operations. </span><span class="koboSpan" id="kobo.326.2">An equivalent operation will take place for encrypting the Secrets on AKS. </span><span class="koboSpan" id="kobo.326.3">This hardens the security of our </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">Secrets management.</span></span></p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.328.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.329.1">In this chapter, we managed to create an AKS cluster that would be able to read Secrets from Azure Key Vault. </span><span class="koboSpan" id="kobo.329.2">We identified the RBAC permissions needed to achieve encrypting and decrypting of the Secrets. </span><span class="koboSpan" id="kobo.329.3">We also increased the security by encrypting the Secrets on etcd, using Azure Key Vault as a KMS for Kubernetes. </span><span class="koboSpan" id="kobo.329.4">Lastly, we could identify the usage of Azure Key Vault through the </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">audit logs.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">In the next chapter, we will focus on another popular cloud provider, Google Cloud Platform. </span><span class="koboSpan" id="kobo.331.2">We will explore the secret storage option on GCP and its integration with the Kubernetes offering of GCP, as well as the secret </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">encryption options.</span></span></p>
</div>
</body></html>