<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Cluster Administration and Extension</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In previous chapters, we familiarized ourselves with basic DevOps skills and Kubernetes objects. </span><span class="koboSpan" id="kobo.2.2">This included looking at many areas, such as how to containerize our application and deploy our containerized software into Kubernetes. </span><span class="koboSpan" id="kobo.2.3">It is now time to gain a deeper insight into Kubernetes cluster administration. </span></p>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we'll learn about the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.4.1">Utilizing namespaces to set administrative boundaries</span></li>
<li><span class="koboSpan" id="kobo.5.1">Using kubeconfig to switch between multiple clusters</span></li>
<li><span class="koboSpan" id="kobo.6.1">Kubernetes authentication</span></li>
<li><span class="koboSpan" id="kobo.7.1">Kubernetes authorization</span></li>
<li><span class="koboSpan" id="kobo.8.1">Dynamic admission control</span></li>
<li><span class="koboSpan" id="kobo.9.1">Kubernetes </span><strong><span class="koboSpan" id="kobo.10.1">Custom Resources Definition</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong><span class="koboSpan" id="kobo.12.1">CRD</span></strong><span class="koboSpan" id="kobo.13.1">) and controllers </span></li>
</ul>
<p><span class="koboSpan" id="kobo.14.1">While minikube is a fairly simple environment, we will use the </span><strong><span class="koboSpan" id="kobo.15.1">Google Kubernetes Engine</span></strong><span class="koboSpan" id="kobo.16.1"> (</span><strong><span class="koboSpan" id="kobo.17.1">GKE</span></strong><span class="koboSpan" id="kobo.18.1">) in this chapter. </span><span class="koboSpan" id="kobo.18.2">For cluster deployment in GKE, please refer to </span><a href=""/><a href=""/><a href="d4de05e3-eb24-4e8e-bfd3-e68819b5e66c.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.19.1">Chapter 11</span></span></a><span class="koboSpan" id="kobo.20.1">, </span><em><span class="koboSpan" id="kobo.21.1">Kubernetes on GCP</span></em><span class="koboSpan" id="kobo.22.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Kubernetes namespaces</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We already learned about Kubernetes namespaces in </span><a href="a5cf080a-372a-406e-bb48-019af313c676.xhtml"><span class="koboSpan" id="kobo.3.1">Chapter 3</span></a><span class="koboSpan" id="kobo.4.1">, </span><em><span class="koboSpan" id="kobo.5.1">Getting Started with Kubernetes</span></em><span class="koboSpan" id="kobo.6.1">, which are used to divide the resources from a cluster into multiple virtual clusters. </span><span class="koboSpan" id="kobo.6.2">Namespaces make each group </span><span><span class="koboSpan" id="kobo.7.1">share the same physical cluster with isolation</span></span><span><span class="koboSpan" id="kobo.8.1">.</span></span><span class="koboSpan" id="kobo.9.1"> Each namespace provides the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">A scope of names; the object name in each namespace is unique</span></li>
<li><span class="koboSpan" id="kobo.11.1">Policies to ensure trusted authentication</span></li>
<li><span class="koboSpan" id="kobo.12.1">The ability to set up resource quotas for resource management</span></li>
</ul>
<p><span class="koboSpan" id="kobo.13.1">Now, let's learn how to use context to switch between different namespaces.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Context</span></h1>
                </header>
            
            <article>
                
<p><strong><span class="koboSpan" id="kobo.2.1">Context</span></strong><span class="koboSpan" id="kobo.3.1"> is the concept of the combination of cluster information, a user for authentication, and a namespace. </span><span class="koboSpan" id="kobo.3.2">For example, the following is the context information for one of our clusters in GKE:</span></p>
<pre><strong><span class="koboSpan" id="kobo.4.1">- context:
  cluster: gke_devops-with-kubernetes_us-central1-b_cluster
  user: gke_devops-with-kubernetes_us-central1-b_cluster
name: gke_devops-with-kubernetes_us-central1-b_cluster</span></strong></pre>
<p><span class="koboSpan" id="kobo.5.1">We could use the </span><kbd><span class="koboSpan" id="kobo.6.1">kubectl config current-context</span></kbd><span class="koboSpan" id="kobo.7.1"> command to list the current context:</span></p>
<pre><strong><span class="koboSpan" id="kobo.8.1"># kubectl config current-context
gke_devops-with-kubernetes_us-central1-b_cluster</span></strong></pre>
<div class="packt_infobox"><span class="koboSpan" id="kobo.9.1">To list all config information, including contexts, you could use the </span><kbd><span class="koboSpan" id="kobo.10.1">kubectl config view</span></kbd><span class="koboSpan" id="kobo.11.1"> command. </span><span class="koboSpan" id="kobo.11.2">To check out what context is currently in use, use the </span><kbd><span class="koboSpan" id="kobo.12.1">kubectl config get-contexts</span></kbd><span class="koboSpan" id="kobo.13.1"> command.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Creating a context</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The next step is to create a context. </span><span class="koboSpan" id="kobo.2.2">As we did in the preceding example, we'll need to set a user and cluster name for the context. </span><span class="koboSpan" id="kobo.2.3">If we don't specify those, the empty value will be set. </span><span class="koboSpan" id="kobo.2.4">The command to create a context is as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.3.1">$ kubectl config set-context &lt;context_name&gt; --namespace=&lt;namespace_name&gt; --cluster=&lt;cluster_name&gt; --user=&lt;user_name&gt;</span></strong></pre>
<p><span class="koboSpan" id="kobo.4.1">Multiple contexts can be created in the same cluster. </span><span class="koboSpan" id="kobo.4.2">The following is an example of how to create a context for </span><kbd><span class="koboSpan" id="kobo.5.1">chapter5</span></kbd><span class="koboSpan" id="kobo.6.1"> in my GKE cluster, </span><kbd><span class="koboSpan" id="kobo.7.1">gke_devops-with-kubernetes_us-central1-b_cluster</span></kbd><span class="koboSpan" id="kobo.8.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.9.1">// create a context with my GKE cluster
# kubectl config set-context chapter5 --namespace=chapter5 --cluster=gke_devops-with-kubernetes_us-central1-b_cluster --user=gke_devops-with-kubernetes_us-central1-b_cluster
Context "chapter5" created.</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Switching the current context</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We could switch the context using the </span><kbd><span class="koboSpan" id="kobo.3.1">use-context</span></kbd><span class="koboSpan" id="kobo.4.1"> subcommand:</span></p>
<pre><strong><span class="koboSpan" id="kobo.5.1"># kubectl config use-context chapter5
Switched to context "chapter5".</span></strong></pre>
<p><span class="koboSpan" id="kobo.6.1">After the context is switched, every command we invoke via </span><kbd><span class="koboSpan" id="kobo.7.1">kubectl</span></kbd><span class="koboSpan" id="kobo.8.1"> is under the </span><kbd><span class="koboSpan" id="kobo.9.1">chapter5</span></kbd><span class="koboSpan" id="kobo.10.1"> context. </span><span class="koboSpan" id="kobo.10.2">There is no need to explicitly specify the namespace when listing your pods.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Kubeconfig</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Kubeconfig is a file that you can use to switch multiple clusters by switching context. </span><span class="koboSpan" id="kobo.2.2">We can use </span><kbd><span class="koboSpan" id="kobo.3.1">kubectl config view</span></kbd><span class="koboSpan" id="kobo.4.1"> to view the setting and the </span><kbd><span class="koboSpan" id="kobo.5.1">kubectl config current-context</span></kbd><span class="koboSpan" id="kobo.6.1"> command to check the context you're currently using. </span><span class="koboSpan" id="kobo.6.2">The following is an example of a GCP cluster in a </span><kbd><span class="koboSpan" id="kobo.7.1">kubeconfig</span></kbd><span class="koboSpan" id="kobo.8.1"> file:</span></p>
<pre><strong><span class="koboSpan" id="kobo.9.1"># kubectl config view
apiVersion: v1
clusters:  </span></strong><br/><strong><span class="koboSpan" id="kobo.10.1">- cluster:</span></strong><br/><strong><span class="koboSpan" id="kobo.11.1">    certificate-authority-data: DATA+OMITTED</span></strong><br/><strong><span class="koboSpan" id="kobo.12.1">    server: https://35.0.0.200</span></strong><br/><strong><span class="koboSpan" id="kobo.13.1">  name: gke_devops-with-kubernetes_us-central1-b_cluster</span></strong><br/><strong><span class="koboSpan" id="kobo.14.1">contexts:</span></strong><br/><strong><span class="koboSpan" id="kobo.15.1">- context:</span></strong><br/><strong><span class="koboSpan" id="kobo.16.1">    cluster: gke_devops-with-kubernetes_us-central1-b_cluster</span></strong><br/><strong><span class="koboSpan" id="kobo.17.1">    user: gke_devops-with-kubernetes_us-central1-b_cluster</span></strong><br/><strong><span class="koboSpan" id="kobo.18.1">  name: gke_devops-with-kubernetes_us-central1-b_cluster</span></strong><br/><strong><span class="koboSpan" id="kobo.19.1">current-context: gke_devops-with-kubernetes_us-central1-b_cluster</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">kind: Config</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">preferences: {}</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">users:</span></strong><br/><strong><span class="koboSpan" id="kobo.23.1">- name: gke_devops-with-kubernetes_us-central1-b_cluster</span></strong><br/><strong><span class="koboSpan" id="kobo.24.1">  user:</span></strong><br/><strong><span class="koboSpan" id="kobo.25.1">    auth-provider:</span></strong><br/><strong><span class="koboSpan" id="kobo.26.1">      config:</span></strong><br/><strong><span class="koboSpan" id="kobo.27.1">        access-token: XXXXX</span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">        cmd-args: config config-helper --format=json</span></strong><br/><strong><span class="koboSpan" id="kobo.29.1">        cmd-path: /Users/devops/k8s/bin/gcloud</span></strong><br/><strong><span class="koboSpan" id="kobo.30.1">        expiry: 2018-12-16T02:51:21Z</span></strong><br/><strong><span class="koboSpan" id="kobo.31.1">        expiry-key: '{.credential.token_expiry}'</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">        token-key: '{.credential.access_token}'</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">      name: gcp</span></strong></pre>
<p><span class="koboSpan" id="kobo.34.1">As we </span><span><span class="koboSpan" id="kobo.35.1">learned previously, w</span></span><span><span class="koboSpan" id="kobo.36.1">e can use</span></span> <kbd><span class="koboSpan" id="kobo.37.1">kubectl config use-context CONTEXT_NAME</span></kbd><span><span class="koboSpan" id="kobo.38.1"> to switch the context. </span><span class="koboSpan" id="kobo.38.2">We can also specify</span></span> <kbd><span class="koboSpan" id="kobo.39.1">kubeconfig</span></kbd> <span><span class="koboSpan" id="kobo.40.1">files according to the</span></span> <kbd><span class="koboSpan" id="kobo.41.1">$KUBECONFIG</span></kbd><span><span class="koboSpan" id="kobo.42.1"> environment variable to determine which kubeconfig files are used. </span><span class="koboSpan" id="kobo.42.2">In this way, config files could be merged. </span><span class="koboSpan" id="kobo.42.3">For example, the following command will merge</span></span> <kbd><span class="koboSpan" id="kobo.43.1">kubeconfig-file1</span></kbd> <span><span class="koboSpan" id="kobo.44.1">and</span></span> <kbd><span class="koboSpan" id="kobo.45.1">kubeconfig-file2</span></kbd><span><span class="koboSpan" id="kobo.46.1">: </span></span></p>
<pre><span class="koboSpan" id="kobo.47.1">export KUBECONFIG=$KUBECONFIG: kubeconfig-file1: kubeconfig-file2</span></pre>
<div class="packt_infobox"><span class="koboSpan" id="kobo.48.1">We could also use </span><kbd><span class="koboSpan" id="kobo.49.1">kubectl config --kubeconfig=&lt;config file name&gt; set-cluster &lt;cluster name&gt;</span></kbd><span class="koboSpan" id="kobo.50.1"> to specify the target cluster in the target </span><kbd><span class="koboSpan" id="kobo.51.1">kubeconfig</span></kbd><span class="koboSpan" id="kobo.52.1"> file. </span></div>
<p><span class="koboSpan" id="kobo.53.1">By default, the </span><kbd><span class="koboSpan" id="kobo.54.1">kubeconfig</span></kbd><span class="koboSpan" id="kobo.55.1"> file is located at </span><kbd><span class="koboSpan" id="kobo.56.1">$HOME/.kube/config</span></kbd><span class="koboSpan" id="kobo.57.1">. </span><span class="koboSpan" id="kobo.57.2">This file will be loaded if none of the preceding settings are set.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Service account</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In Kubernetes, there are two kinds of user account: </span><strong><span class="koboSpan" id="kobo.3.1">service account</span></strong><span class="koboSpan" id="kobo.4.1"> and </span><strong><span class="koboSpan" id="kobo.5.1">user account</span></strong><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">All the requests to the API server are sent either by a service account or a user account. </span><span class="koboSpan" id="kobo.6.3">Service accounts are managed by the Kubernetes API. </span><span class="koboSpan" id="kobo.6.4">In contrast, user accounts are not managed and stored in Kubernetes. </span><span class="koboSpan" id="kobo.6.5">The following is a simple comparison of service and user accounts:</span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td/>
<td><strong><span class="koboSpan" id="kobo.7.1">Service account</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.8.1">User account</span></strong></td>
</tr>
<tr>
<td><strong><span class="koboSpan" id="kobo.9.1">Scope</span></strong></td>
<td><span class="koboSpan" id="kobo.10.1">Namespaced</span></td>
<td><span class="koboSpan" id="kobo.11.1">Global </span></td>
</tr>
<tr>
<td><strong><span class="koboSpan" id="kobo.12.1">Used by</span></strong></td>
<td><span class="koboSpan" id="kobo.13.1">Processes</span></td>
<td><span class="koboSpan" id="kobo.14.1">Normal user</span></td>
</tr>
<tr>
<td><strong><span class="koboSpan" id="kobo.15.1">Created by</span></strong></td>
<td><span class="koboSpan" id="kobo.16.1">API server or via API calls</span></td>
<td><span class="koboSpan" id="kobo.17.1">Administrators, not by API calls</span></td>
</tr>
<tr>
<td><strong><span class="koboSpan" id="kobo.18.1">Managed by</span></strong></td>
<td><span class="koboSpan" id="kobo.19.1">API server</span></td>
<td><span class="koboSpan" id="kobo.20.1">Outside the cluster</span></td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.21.1">By default, a Kubernetes cluster creates different service accounts for different purposes. </span><span class="koboSpan" id="kobo.21.2">In GKE, there are a bunch of service accounts that have been created:</span></p>
<pre><strong><span class="koboSpan" id="kobo.22.1">// list service account across all namespaces
# kubectl get serviceaccount --all-namespaces
NAMESPACE     NAME                         SECRETS   AGE
default       default                      1         5d
kube-public   default                      1         5d
kube-system   namespace-controller         1         5d
kube-system   resourcequota-controller     1         5d
kube-system   service-account-controller   1         5d
kube-system   service-controller           1         5d
chapter5      default                      1         2h
... </span></strong> </pre>
<p><span class="koboSpan" id="kobo.23.1">Kubernetes will create a default service account in each namespace, which will be used if no service account is specified in pod </span><span><span class="koboSpan" id="kobo.24.1">specification</span></span><span class="koboSpan" id="kobo.25.1"> during pod creation. </span><span class="koboSpan" id="kobo.25.2">Let's take a look at how the default service account acts for our </span><kbd><span class="koboSpan" id="kobo.26.1">chapter5</span></kbd><span class="koboSpan" id="kobo.27.1"> namespace:</span></p>
<pre><strong><span class="koboSpan" id="kobo.28.1"># kubectl describe serviceaccount/default
Name: default</span><br/><span class="koboSpan" id="kobo.29.1">Namespace: default</span><br/><span class="koboSpan" id="kobo.30.1">Labels: &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.31.1">Annotations: &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.32.1">Image pull secrets: &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.33.1">Mountable secrets: default-token-52qnr</span><br/><span class="koboSpan" id="kobo.34.1">Tokens: default-token-52qnr</span><br/><span class="koboSpan" id="kobo.35.1">Events: &lt;none&gt;</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.36.1">We can see that the service account is basically using mountable secrets as tokens. </span><span class="koboSpan" id="kobo.36.2">Let's dig into what content is inside the token:</span></p>
<pre><strong><span class="koboSpan" id="kobo.37.1">// describe the secret, the name is default-token-52qnr here
# kubectl describe secret default-token-52qnr
Name:       default-token-52qnr
Namespace:  chapter5
Annotations:  kubernetes.io/service-account.name: default</span><br/><span class="koboSpan" id="kobo.38.1">              kubernetes.io/service-account.uid: 6bc2f108-dae5-11e8-b6f4-42010a8a0244</span></strong><strong><span class="koboSpan" id="kobo.39.1">
Type: kubernetes.io/service-account-token
Data
====
ca.crt:     # the public CA of api server. </span><span class="koboSpan" id="kobo.39.2">Base64 encoded.
</span><span class="koboSpan" id="kobo.39.3">namespace:  # the name space associated with this service account. </span><span class="koboSpan" id="kobo.39.4">Base64 encoded
token:      # bearer token. </span><span class="koboSpan" id="kobo.39.5">Base64 encoded</span></strong></pre>
<p><span class="koboSpan" id="kobo.40.1">The service account secret will be automatically mounted to the </span><kbd><span class="koboSpan" id="kobo.41.1">/var/run/secrets/kubernetes.io/serviceaccount</span></kbd> <span><span class="koboSpan" id="kobo.42.1">directory</span></span><span><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">When the pod accesses the API server, the API server will check the cert and token to do the authentication. </span></span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.44.1">Specifying </span><kbd><span class="koboSpan" id="kobo.45.1">automountServiceAccountToken: false</span></kbd><span><span class="koboSpan" id="kobo.46.1"> in the service account or pod specification could disable the auto-mount service account secret.</span></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Authentication and authorization</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Authentication and authorization are </span><span><span><span class="koboSpan" id="kobo.3.1">important components</span></span></span><span class="koboSpan" id="kobo.4.1"> in Kubernetes. </span><span class="koboSpan" id="kobo.4.2">Authentication verifies users and checks that the user is who they claim to be. </span><span class="koboSpan" id="kobo.4.3">Authorization, on the other hand, checks what permission levels users have. </span><span class="koboSpan" id="kobo.4.4">Kubernetes supports different authentication and authorization modules.</span></p>
<p><span class="koboSpan" id="kobo.5.1">The following is an illustration that shows how the Kubernetes API server processes access control when it receives a request:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.6.1"><img class=" image-border" src="assets/1ad4c779-ce36-4ace-ac4d-54fcaaaa50d8.png" style="width:46.08em;height:11.67em;"/></span></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.7.1">Access control in the Kubernetes API server</span></div>
<p><span class="koboSpan" id="kobo.8.1">When the request goes to the API server, first it establishes a TLS connection by validating the clients' certificate with the </span><strong><span class="koboSpan" id="kobo.9.1">Certificate Authority</span></strong><span class="koboSpan" id="kobo.10.1"> (</span><strong><span class="koboSpan" id="kobo.11.1">CA</span></strong><span class="koboSpan" id="kobo.12.1">) in the API server. </span><span class="koboSpan" id="kobo.12.2">The CA in the API server is usually at </span><kbd><span class="koboSpan" id="kobo.13.1">/etc/kubernetes/</span></kbd><span class="koboSpan" id="kobo.14.1">, and the clients' certificate is usually at </span><kbd><span class="koboSpan" id="kobo.15.1">$HOME/.kube/config</span></kbd><span class="koboSpan" id="kobo.16.1">. </span><span class="koboSpan" id="kobo.16.2">After the handshake, it moves into the authentication stage. </span><span class="koboSpan" id="kobo.16.3">In Kubernetes, authentication modules are chain-based. </span><span class="koboSpan" id="kobo.16.4">More than one authentication module can be used here. </span><span class="koboSpan" id="kobo.16.5">When receiving the request, Kubernetes will try all the authenticators one by one until it succeeds. </span><span class="koboSpan" id="kobo.16.6">If the request fails on all authentication modules, it will be rejected with an </span><span class="packt_screen"><span class="koboSpan" id="kobo.17.1">HTTP 401 Unauthorized</span></span><span class="koboSpan" id="kobo.18.1"> error. </span><span class="koboSpan" id="kobo.18.2">If not, one of the authenticators verifies the user's identity and the requests are authenticated. </span><span class="koboSpan" id="kobo.18.3">At this point, Kubernetes authorization modules come into play.</span></p>
<p><span class="koboSpan" id="kobo.19.1">Authorization modules verify whether or not the user has sufficient permissions to perform the action that they have requested to perform. </span><span class="koboSpan" id="kobo.19.2">Authorization modules are also chain-based. </span><span class="koboSpan" id="kobo.19.3">The authorization request needs to pass through every module until it succeeds. </span><span class="koboSpan" id="kobo.19.4">If the request fails for all modules, the requester will get a </span><span class="packt_screen"><span class="koboSpan" id="kobo.20.1">HTTP 403 Forbidden</span></span><span class="koboSpan" id="kobo.21.1"> response.</span></p>
<p><span class="koboSpan" id="kobo.22.1">Admission control is a set of configurable plugins in an API server that determine whether a request is admitted or denied. </span><span class="koboSpan" id="kobo.22.2">At this stage, if the request doesn't pass through one of the plugins, then it is denied immediately.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Authentication</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">By default, a service account is token-based. </span><span class="koboSpan" id="kobo.2.2">When you create a service account or a namespace with a default service account, Kubernetes creates the token, stores it as a secret that is encoded by Base64, and mounts the secret as a volume into the pod. </span><span class="koboSpan" id="kobo.2.3">Then, the processes inside the pod have the ability to talk to the cluster. </span><span class="koboSpan" id="kobo.2.4">The user account, on the other hand, represents a normal user who might use</span></span> <kbd><span class="koboSpan" id="kobo.3.1">kubectl</span></kbd> <span><span class="koboSpan" id="kobo.4.1">to </span></span><span><span class="koboSpan" id="kobo.5.1">directly </span></span><span><span class="koboSpan" id="kobo.6.1">manipulate the resource.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Service account token authentication</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">When we create a service account, a signed bearer token will be </span><span><span class="koboSpan" id="kobo.3.1">automatically</span></span><span><span class="koboSpan" id="kobo.4.1"> </span></span><span><span class="koboSpan" id="kobo.5.1">created by the Kubernetes service account admission controller plugin. </span><span class="koboSpan" id="kobo.5.2">We can use that service account token to authenticate a user. </span></span></p>
<p><span class="koboSpan" id="kobo.6.1">Let's try creating a service account named </span><kbd><span class="koboSpan" id="kobo.7.1">myaccount</span></kbd><span class="koboSpan" id="kobo.8.1"> in the </span><kbd><span class="koboSpan" id="kobo.9.1">chapter5</span></kbd><span class="koboSpan" id="kobo.10.1"> namespace:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">// the configuration file of service account object</span><br/><strong><span class="koboSpan" id="kobo.12.1"># cat service-account.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.13.1">apiVersion: v1</span></strong><br/><strong><span class="koboSpan" id="kobo.14.1">kind: ServiceAccount</span></strong><br/><strong><span class="koboSpan" id="kobo.15.1">metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.16.1"> name: myaccount</span></strong><br/><strong><span class="koboSpan" id="kobo.17.1"> namespace: chapter5</span></strong><br/><br/><span class="koboSpan" id="kobo.18.1">// create myaccount</span><br/><strong><span class="koboSpan" id="kobo.19.1"># kubectl create -f service-account.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">serviceaccount/myaccount created</span></strong></pre>
<p><span class="koboSpan" id="kobo.21.1">In </span><a href="acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml"><span class="koboSpan" id="kobo.22.1">C</span><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.23.1">hapter 9</span></span></a><span class="koboSpan" id="kobo.24.1">, </span><em><span class="koboSpan" id="kobo.25.1">Continuous Delivery</span></em><span class="koboSpan" id="kobo.26.1">, in the example in which we demonstrated how to deploy </span><kbd><span class="koboSpan" id="kobo.27.1">my-app</span></kbd><span class="koboSpan" id="kobo.28.1">, we created a namespace named </span><kbd><span class="koboSpan" id="kobo.29.1">cd</span></kbd><span class="koboSpan" id="kobo.30.1">, and used </span><kbd><span class="koboSpan" id="kobo.31.1">get-sa-token.sh</span></kbd><span class="koboSpan" id="kobo.32.1"> </span><span><span class="koboSpan" id="kobo.33.1">script</span></span><span><span class="koboSpan" id="kobo.34.1"> </span></span><span><span class="koboSpan" id="kobo.35.1">(</span></span><a href="https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/blob/master/chapter9/9-2_service-account-for-ci-tool/utils/push-cd/get-sa-token.sh"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/blob/master/chapter9/9-2_service-account-for-ci-tool/utils/push-cd/get-sa-token.sh</span></a><span><span class="koboSpan" id="kobo.37.1">) to export the token for us:</span></span></p>
<pre><span class="koboSpan" id="kobo.38.1">// export ca.crt and sa.token from myaccount in namespace chapter5</span><br/><strong><span class="koboSpan" id="kobo.39.1"># sh ./chapter9/9-2_service-account-for-ci-tool/utils/push-cd/get-sa-token.sh -n chapter5 -a myaccount</span></strong></pre>
<p><span class="koboSpan" id="kobo.40.1">Then, we created a user named </span><kbd><span class="koboSpan" id="kobo.41.1">mysa</span></kbd><span class="koboSpan" id="kobo.42.1"> via the </span><kbd><span class="koboSpan" id="kobo.43.1">kubectl config set-credentials &lt;user&gt; --token=$TOKEN</span></kbd><span class="koboSpan" id="kobo.44.1"> command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.45.1">// CI_ENV_K8S_SA_TOKEN=`cat sa.token`</span><br/><span class="koboSpan" id="kobo.46.1"># kubectl config set-credentials mysa --token=${K8S_SA_TOKEN}</span></strong></pre>
<p><span class="koboSpan" id="kobo.47.1">Next, we set the context to bind with a user and namespace:</span></p>
<pre><strong><span class="koboSpan" id="kobo.48.1">// Here we set K8S_CLUSTER=gke_devops-with-kubernetes_us-central1-b_cluster</span><br/><span class="koboSpan" id="kobo.49.1"># kubectl config set-context myctxt --cluster=${K8S_CLUSTER} --user=mysa</span></strong></pre>
<p><span class="koboSpan" id="kobo.50.1">Finally, we set our </span><kbd><span class="koboSpan" id="kobo.51.1">myctxt</span></kbd><span class="koboSpan" id="kobo.52.1"> </span><span><span class="koboSpan" id="kobo.53.1">context</span></span><span><span class="koboSpan" id="kobo.54.1"> </span></span><span><span class="koboSpan" id="kobo.55.1">as the default context:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.56.1">// set the context to myctxt</span><br/><span class="koboSpan" id="kobo.57.1"># kubectl config use-context myctxt</span></strong></pre>
<p><span class="koboSpan" id="kobo.58.1">When we send a request, the token will be verified by the API server, which checks whether the requester is eligible and is what it claims to be. </span><span class="koboSpan" id="kobo.58.2">Let's see if we can use this token to list the pods in the default namespace:</span></p>
<pre><strong><span class="koboSpan" id="kobo.59.1"># kubectl get po</span></strong><br/><strong><span class="koboSpan" id="kobo.60.1">Error from server (Forbidden): pods is forbidden: User "system:serviceaccount:chapter5:myaccount" cannot list pods in the namespace "default"</span></strong></pre>
<p><span class="koboSpan" id="kobo.61.1">Seems like something went wrong! </span><span class="koboSpan" id="kobo.61.2">This is because we haven't granted any permissions to this service account yet. </span><span class="koboSpan" id="kobo.61.3">We'll learn how to do this using </span><kbd><span class="koboSpan" id="kobo.62.1">Role</span></kbd><span class="koboSpan" id="kobo.63.1"> and </span><kbd><span class="koboSpan" id="kobo.64.1">RoleBinding</span></kbd><span class="koboSpan" id="kobo.65.1"> </span><span><span class="koboSpan" id="kobo.66.1">later i</span></span><span><span class="koboSpan" id="kobo.67.1">n this chapter.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">User account authentication</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There are several implementations for user account authentication. </span><span class="koboSpan" id="kobo.2.2">This includes anything from client certificates, bearer tokens, and static files to OpenID connect tokens. </span><span class="koboSpan" id="kobo.2.3">You can choose more than one as authentication chains. </span><span class="koboSpan" id="kobo.2.4">Here, we'll demonstrate how client certificates work.</span></p>
<p><span class="koboSpan" id="kobo.3.1">In </span><a href="acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml"><span class="koboSpan" id="kobo.4.1">Chapter 9</span></a><span class="koboSpan" id="kobo.5.1">, </span><em><span class="koboSpan" id="kobo.6.1">Continuous Delivery</span></em><span class="koboSpan" id="kobo.7.1">, and earlier in this chapter, we learned how to export certificates and tokens for service accounts. </span><span class="koboSpan" id="kobo.7.2">Now, let's learn how to do this for a user. </span><span class="koboSpan" id="kobo.7.3">Let's assume that we are still inside the </span><kbd><span class="koboSpan" id="kobo.8.1">chapter5</span></kbd><span class="koboSpan" id="kobo.9.1"> namespace, and we want to create a user for our new DevOps member, Linda, who will help us do the deployment for </span><kbd><span class="koboSpan" id="kobo.10.1">my-app</span></kbd><span class="koboSpan" id="kobo.11.1">:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.12.1">First, we'll generate a private key via OpenSSL (</span><a href="https://www.openssl.org" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.13.1">https://www.openssl.org</span></span></a><span class="koboSpan" id="kobo.14.1">):</span></li>
</ol>
<pre style="padding-left: 90px"><strong><span class="koboSpan" id="kobo.15.1">// generate a private key for Linda
# openssl genrsa -out linda.key 2048</span></strong></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.16.1">Next, we'll create a certificate sign request (</span><kbd><span class="koboSpan" id="kobo.17.1">.csr</span></kbd><span class="koboSpan" id="kobo.18.1">) for Linda:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.19.1">// making CN as your username
# openssl req -new -key linda.key -out linda.csr -subj "/CN=linda" </span></strong></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.20.1">Now, </span><kbd><span class="koboSpan" id="kobo.21.1">linda.key</span></kbd><span class="koboSpan" id="kobo.22.1"> and </span><kbd><span class="koboSpan" id="kobo.23.1">linda.csr</span></kbd><span class="koboSpan" id="kobo.24.1"> should be located in the current folder. </span><span><span class="koboSpan" id="kobo.25.1">To let the </span></span><span><span class="koboSpan" id="kobo.26.1">API server validate Linda's certificate, we'll need to find the cluster CA</span></span><span class="koboSpan" id="kobo.27.1">.</span></li>
</ol>
<div class="packt_infobox"><span class="koboSpan" id="kobo.28.1">In minikube, </span><span><span class="koboSpan" id="kobo.29.1">the root CA is</span></span><span class="koboSpan" id="kobo.30.1"> under </span><kbd><span class="koboSpan" id="kobo.31.1">~/.minikube/</span></kbd><span class="koboSpan" id="kobo.32.1">. </span><span class="koboSpan" id="kobo.32.2">For other self-hosted solutions, it's normally </span><span><span class="koboSpan" id="kobo.33.1">under</span></span> <kbd><span class="koboSpan" id="kobo.34.1">/etc/kubernetes/</span></kbd><span><span class="koboSpan" id="kobo.35.1">. </span><span class="koboSpan" id="kobo.35.2">If you use </span><kbd><span class="koboSpan" id="kobo.36.1">kops</span></kbd><span class="koboSpan" id="kobo.37.1"> to deploy the cluster, the location is under</span></span> <kbd><span class="koboSpan" id="kobo.38.1">/srv/kubernetes</span></kbd><span><span class="koboSpan" id="kobo.39.1">, and you will find the path in</span></span><span class="koboSpan" id="kobo.40.1"> the </span><kbd><span class="koboSpan" id="kobo.41.1">/etc/kubernetes/manifests/kube-apiserver.manifest</span></kbd> <span><span class="koboSpan" id="kobo.42.1">file. </span><span class="koboSpan" id="kobo.42.2">In GKE, the cluster root CA is non-exportable.</span></span></div>
<p><span class="koboSpan" id="kobo.43.1">Let's assume we have </span><kbd><span class="koboSpan" id="kobo.44.1">ca.crt</span></kbd><span class="koboSpan" id="kobo.45.1"> and </span><kbd><span class="koboSpan" id="kobo.46.1">ca.key</span></kbd><span class="koboSpan" id="kobo.47.1"> under the current folder; by using these, we could generate a new CA for the user. </span><span class="koboSpan" id="kobo.47.2">By using the </span><kbd><span class="koboSpan" id="kobo.48.1">-days</span></kbd><span class="koboSpan" id="kobo.49.1"> parameter, we can define the expired date:</span></p>
<pre><strong><span class="koboSpan" id="kobo.50.1">// generate the cert for Linda, this cert is only valid for 30 days.
</span><span class="koboSpan" id="kobo.50.2"># openssl x509 -req -in linda.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out linda.crt -days 30
Signature ok
subject=/CN=linda
Getting CA Private Key</span></strong></pre>
<p><span class="koboSpan" id="kobo.51.1">After we have cert signed by our cluster, we could set a user in the cluster, as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.52.1"># kubectl config set-credentials linda --client-certificate=linda.crt --client-key=linda.key
User "linda" set.</span></strong></pre>
<p><span class="koboSpan" id="kobo.53.1">Remember the concept of context: this is the combination of cluster information, a user for authentication, and a namespace. </span><span class="koboSpan" id="kobo.53.2">Now, we'll set a context entry in </span><kbd><span class="koboSpan" id="kobo.54.1">kubeconfig</span></kbd><span class="koboSpan" id="kobo.55.1">. </span><span class="koboSpan" id="kobo.55.2">Remember to replace your cluster name, namespace, and user in the following example:</span></p>
<pre><strong><span class="koboSpan" id="kobo.56.1"># kubectl config set-context devops-context --cluster=${K8S_CLUSTER} --namespace=chapter5 --user=linda
Context "devops-context" modified.</span></strong></pre>
<p><span class="koboSpan" id="kobo.57.1">Now, Linda should have zero permission:</span></p>
<pre><strong><span class="koboSpan" id="kobo.58.1">// test for getting a pod 
# kubectl --context=devops-context get pods
Error from server (Forbidden): User "linda" cannot list pods in the namespace "chapter5". </span><span class="koboSpan" id="kobo.58.2">(get pods)</span></strong></pre>
<p><span class="koboSpan" id="kobo.59.1">Linda can now pass the authentication stage as Kubernetes knows she is Linda. </span><span class="koboSpan" id="kobo.59.2">However, to give Linda permission to do the deployment, we need to set up the policies in authorization modules.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Authorization</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Kubernetes supports several authorization modules. </span><span class="koboSpan" id="kobo.2.2">At the time of writing this book, it supports the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">ABAC</span></li>
<li><span class="koboSpan" id="kobo.4.1">RBAC</span></li>
<li><span class="koboSpan" id="kobo.5.1">Node authorization</span></li>
<li><span class="koboSpan" id="kobo.6.1">Webhook</span></li>
<li><span class="koboSpan" id="kobo.7.1">Custom modules</span></li>
</ul>
<p><strong><span class="koboSpan" id="kobo.8.1">Attribute-Based Access Control</span></strong><span class="koboSpan" id="kobo.9.1"> (</span><strong><span class="koboSpan" id="kobo.10.1">ABAC</span></strong><span class="koboSpan" id="kobo.11.1">) was the major authorization mode before </span><strong><span class="koboSpan" id="kobo.12.1">Role-Based Access Control</span></strong><span class="koboSpan" id="kobo.13.1"> (</span><strong><span class="koboSpan" id="kobo.14.1">RBAC</span></strong><span class="koboSpan" id="kobo.15.1">) was introduced. </span><span class="koboSpan" id="kobo.15.2">Node authorization is used by kubelet to make a request to the API server. </span><span class="koboSpan" id="kobo.15.3">Kubernetes supports the webhook authorization mode to establish a HTTP callback with an external RESTful service. </span><span class="koboSpan" id="kobo.15.4">It'll do a POST whenever it faces an authorization decision. </span><span class="koboSpan" id="kobo.15.5">Another common way to do this is by implementing your in-house module by following along with the pre-defined authorizer interface. </span><span class="koboSpan" id="kobo.15.6">For more implementation information, refer to </span><a href="https://kubernetes.io/docs/admin/authorization/#custom-modules" target="_blank"><span class="koboSpan" id="kobo.16.1">https://kubernetes.io/docs/admin/authorization/#custom-modules</span></a><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">In this section, we'll walk though how to leverage and utilize RBAC in Kubernetes.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Role-based access control (RBAC)</span></h1>
                </header>
            
            <article>
                
<p><span><span><span class="koboSpan" id="kobo.2.1">Since </span></span></span><span class="koboSpan" id="kobo.3.1">Kubernetes 1.6, RBAC is enabled by default. </span><span class="koboSpan" id="kobo.3.2">In RBAC, the admin creates several </span><kbd><span class="koboSpan" id="kobo.4.1">Roles</span></kbd><span class="koboSpan" id="kobo.5.1"> or </span><kbd><span class="koboSpan" id="kobo.6.1">ClusterRoles</span></kbd><span class="koboSpan" id="kobo.7.1"> that define the fine-grained permissions that specify a set of resources and actions (verbs) that roles can access and manipulate. </span><span class="koboSpan" id="kobo.7.2">After that, the admin grants the </span><kbd><span class="koboSpan" id="kobo.8.1">Role</span></kbd><span class="koboSpan" id="kobo.9.1"> permission to users through </span><kbd><span class="koboSpan" id="kobo.10.1">RoleBinding</span></kbd><span class="koboSpan" id="kobo.11.1"> or </span><kbd><span class="koboSpan" id="kobo.12.1">ClusterRoleBindings</span></kbd><span class="koboSpan" id="kobo.13.1">.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.14.1">If you're running minikube, add </span><kbd><span class="koboSpan" id="kobo.15.1">--extra-config=apiserver.Authorization.Mode=RBAC</span></kbd><span class="koboSpan" id="kobo.16.1"> when using </span><kbd><span class="koboSpan" id="kobo.17.1">minikube start</span></kbd><span class="koboSpan" id="kobo.18.1">. </span><span class="koboSpan" id="kobo.18.2">If you're running a self-hosted cluster on AWS via kops, add </span><kbd><span class="koboSpan" id="kobo.19.1">--authorization=rbac</span></kbd><span class="koboSpan" id="kobo.20.1"> when launching the cluster. </span><span class="koboSpan" id="kobo.20.2">Kops launches an API server as a pod; using the </span><kbd><span class="koboSpan" id="kobo.21.1">kops edit cluster</span></kbd><span class="koboSpan" id="kobo.22.1"> command could modify the </span><kbd><span class="koboSpan" id="kobo.23.1">spec</span></kbd><span class="koboSpan" id="kobo.24.1"> of the containers. </span><span class="koboSpan" id="kobo.24.2">EKS and GKE support RBAC natively.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Roles and ClusterRoles</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A </span><kbd><span class="koboSpan" id="kobo.3.1">Role</span></kbd><span class="koboSpan" id="kobo.4.1"> in Kubernetes is bound within a namespace. </span><span class="koboSpan" id="kobo.4.2">A </span><kbd><span class="koboSpan" id="kobo.5.1">ClusterRole</span></kbd><span class="koboSpan" id="kobo.6.1">, on the other hand, is cluster-wide. </span><span class="koboSpan" id="kobo.6.2">The following is an example of </span><kbd><span class="koboSpan" id="kobo.7.1">Role</span></kbd><span class="koboSpan" id="kobo.8.1">, which can perform all operations, including </span><kbd><span class="koboSpan" id="kobo.9.1">get</span></kbd><span class="koboSpan" id="kobo.10.1">, </span><kbd><span class="koboSpan" id="kobo.11.1">watch</span></kbd><span class="koboSpan" id="kobo.12.1">, </span><kbd><span class="koboSpan" id="kobo.13.1">list</span></kbd><span class="koboSpan" id="kobo.14.1">, </span><kbd><span class="koboSpan" id="kobo.15.1">create</span></kbd><span class="koboSpan" id="kobo.16.1">, </span><kbd><span class="koboSpan" id="kobo.17.1">update</span></kbd><span class="koboSpan" id="kobo.18.1">, </span><kbd><span class="koboSpan" id="kobo.19.1">delete</span></kbd><span class="koboSpan" id="kobo.20.1">, and </span><kbd><span class="koboSpan" id="kobo.21.1">patch</span></kbd><span class="koboSpan" id="kobo.22.1">, on the </span><kbd><span class="koboSpan" id="kobo.23.1">deployments</span></kbd><span class="koboSpan" id="kobo.24.1">, </span><kbd><span class="koboSpan" id="kobo.25.1">replicasets</span></kbd><span class="koboSpan" id="kobo.26.1">, and </span><kbd><span class="koboSpan" id="kobo.27.1">pods</span></kbd><span class="koboSpan" id="kobo.28.1"> resources:</span></p>
<pre><strong><span class="koboSpan" id="kobo.29.1">// configuration file for a role named devops-role</span><br/><span class="koboSpan" id="kobo.30.1"># cat 5-2_rbac/5-2_role.yaml
kind: Role</span></strong><br/><strong><span class="koboSpan" id="kobo.31.1">apiVersion: rbac.authorization.k8s.io/v1</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">  namespace: chapter5</span></strong><br/><strong><span class="koboSpan" id="kobo.34.1">  name: devops-role</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">rules:</span></strong><br/><strong><span class="koboSpan" id="kobo.36.1">- apiGroups: ["", "extensions", "apps"]</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">  resources:</span></strong><br/><strong><span class="koboSpan" id="kobo.38.1">    - "deployments"</span></strong><br/><strong><span class="koboSpan" id="kobo.39.1">    - "replicasets"</span></strong><br/><strong><span class="koboSpan" id="kobo.40.1">    - "pods"</span></strong><br/><strong><span class="koboSpan" id="kobo.41.1">  verbs: ["*"]</span><br/><br/><span class="koboSpan" id="kobo.42.1">// create the role</span><br/><span class="koboSpan" id="kobo.43.1"># kubectl create -f 5-2_rbac/5-2_role.yaml</span><br/><span class="koboSpan" id="kobo.44.1">role.rbac.authorization.k8s.io/devops-role created</span></strong></pre>
<div class="packt_infobox"><span class="koboSpan" id="kobo.45.1">In GKE, the admin doesn't have permission to create a role by default</span><span><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">Instead, you must grant the user access to this with the following command: </span></span><kbd><span class="koboSpan" id="kobo.47.1">kubectl create clusterrolebinding cluster-admin-binding --clusterrole cluster-admin --user ${USER_ACCOUNT}</span></kbd><span class="koboSpan" id="kobo.48.1">.</span></div>
<p><span class="koboSpan" id="kobo.49.1">In </span><kbd><span class="koboSpan" id="kobo.50.1">apiGroups</span></kbd><span class="koboSpan" id="kobo.51.1">, an empty string </span><kbd><span class="koboSpan" id="kobo.52.1">[""]</span></kbd><span class="koboSpan" id="kobo.53.1"> indicates the core API group. </span><span class="koboSpan" id="kobo.53.2">The API group is part of the RESTful API call. </span><span class="koboSpan" id="kobo.53.3">The core indicates the original API call path, such as </span><kbd><span class="koboSpan" id="kobo.54.1">/api/v1</span></kbd><span class="koboSpan" id="kobo.55.1">. </span><span class="koboSpan" id="kobo.55.2">The newer REST path has the group name and API version in it, such as </span><kbd><span class="koboSpan" id="kobo.56.1">/apis/$GROUP_NAME/$VERSION</span></kbd><span class="koboSpan" id="kobo.57.1">. </span><span class="koboSpan" id="kobo.57.2">To look up API groups you'd like to use, check out API references at </span><a href="https://kubernetes.io/docs/reference" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.58.1">https://kubernetes.io/docs/reference</span></span></a><span class="koboSpan" id="kobo.59.1">. </span><span class="koboSpan" id="kobo.59.2">Under </span><kbd><span class="koboSpan" id="kobo.60.1">resources</span></kbd><span class="koboSpan" id="kobo.61.1">, you could add the </span><kbd><span class="koboSpan" id="kobo.62.1">resources</span></kbd><span class="koboSpan" id="kobo.63.1"> you'd like to grant access to, and under </span><kbd><span class="koboSpan" id="kobo.64.1">verbs</span></kbd><span class="koboSpan" id="kobo.65.1">, you could list a set of actions that this role could perform. </span><span class="koboSpan" id="kobo.65.2">Let's get into a more advanced example for </span><kbd><span class="koboSpan" id="kobo.66.1">ClusterRoles</span></kbd><span class="koboSpan" id="kobo.67.1">, which we used in </span><a href="acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml"><span class="koboSpan" id="kobo.68.1">Chapter 9</span></a><span class="koboSpan" id="kobo.69.1">, </span><em><span class="koboSpan" id="kobo.70.1">Continuous Delivery</span></em><span class="koboSpan" id="kobo.71.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.72.1">// configuration file for a cluster role</span><br/><span class="koboSpan" id="kobo.73.1"># cat 5-2_rbac/5-2_clusterrole.yaml
apiVersion: rbac.authorization.k8s.io/v1</span><br/><span class="koboSpan" id="kobo.74.1">kind: ClusterRole</span><br/><span class="koboSpan" id="kobo.75.1">metadata:</span><br/><span class="koboSpan" id="kobo.76.1">  name: cd-role</span><br/><span class="koboSpan" id="kobo.77.1">rules:</span><br/><span class="koboSpan" id="kobo.78.1">- apiGroups: ["extensions", "apps"]</span><br/><span class="koboSpan" id="kobo.79.1">  resources:</span><br/><span class="koboSpan" id="kobo.80.1">    - deployments</span><br/><span class="koboSpan" id="kobo.81.1">    - replicasets</span><br/><span class="koboSpan" id="kobo.82.1">    - ingresses</span><br/><span class="koboSpan" id="kobo.83.1">  verbs: ["*"]</span><br/><span class="koboSpan" id="kobo.84.1">- apiGroups: [""]</span><br/><span class="koboSpan" id="kobo.85.1">  resources:</span><br/><span class="koboSpan" id="kobo.86.1">    - namespaces</span><br/><span class="koboSpan" id="kobo.87.1">    - events</span><br/><span class="koboSpan" id="kobo.88.1">  verbs: ["get", "list", "watch"]</span><br/><span class="koboSpan" id="kobo.89.1">- apiGroups: [""]</span><br/><span class="koboSpan" id="kobo.90.1">  resources:</span><br/><span class="koboSpan" id="kobo.91.1">    - pods</span><br/><span class="koboSpan" id="kobo.92.1">    - services</span><br/><span class="koboSpan" id="kobo.93.1">    - secrets</span><br/><span class="koboSpan" id="kobo.94.1">    - replicationcontrollers</span><br/><span class="koboSpan" id="kobo.95.1">    - persistentvolumeclaims</span><br/><span class="koboSpan" id="kobo.96.1">    - jobs</span><br/><span class="koboSpan" id="kobo.97.1">    - cronjobs</span><br/><span class="koboSpan" id="kobo.98.1">  verbs: ["*"]</span><br/><br/><span class="koboSpan" id="kobo.99.1">// create the cluster role</span><br/><span class="koboSpan" id="kobo.100.1"># kubectl create -f 5-2_rbac/5-2_clusterrole.yaml</span><br/><span class="koboSpan" id="kobo.101.1">clusterrole.rbac.authorization.k8s.io/cd-role created</span></strong></pre>
<p><kbd><span class="koboSpan" id="kobo.102.1">ClusterRole</span></kbd><span class="koboSpan" id="kobo.103.1"> is cluster-wide. </span><span class="koboSpan" id="kobo.103.2">Some resources don't belong to any namespace, such as nodes, and can only be controlled by </span><kbd><span class="koboSpan" id="kobo.104.1">ClusterRole</span></kbd><span class="koboSpan" id="kobo.105.1">. </span><span class="koboSpan" id="kobo.105.2">The namespaces it can access depends on the </span><kbd><span class="koboSpan" id="kobo.106.1">namespaces</span></kbd><span class="koboSpan" id="kobo.107.1"> field that it associates with</span><span><span class="koboSpan" id="kobo.108.1"> </span></span><kbd><span class="koboSpan" id="kobo.109.1">ClusterRoleBinding</span></kbd><span><span class="koboSpan" id="kobo.110.1">. </span><span class="koboSpan" id="kobo.110.2">In the preceding example, we granted the permission to allow this role read and write</span></span> <kbd><span class="koboSpan" id="kobo.111.1">deployments</span></kbd><span><span class="koboSpan" id="kobo.112.1">, </span><kbd><span class="koboSpan" id="kobo.113.1">replicasets</span></kbd></span><span class="koboSpan" id="kobo.114.1">, </span><span><span class="koboSpan" id="kobo.115.1">and </span><kbd><span class="koboSpan" id="kobo.116.1">ingresses</span></kbd><span class="koboSpan" id="kobo.117.1"> in both extensions and apps groups. </span><span class="koboSpan" id="kobo.117.2">In the core API group, we only </span></span><span><span class="koboSpan" id="kobo.118.1">grant</span></span><span><span class="koboSpan" id="kobo.119.1"> </span></span><span><span class="koboSpan" id="kobo.120.1">access for namespace and events, as well as all permissions for other resources, such as pods and services.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">RoleBinding and ClusterRoleBinding</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A </span><kbd><span class="koboSpan" id="kobo.3.1">RoleBinding</span></kbd><span class="koboSpan" id="kobo.4.1"> binds a </span><kbd><span class="koboSpan" id="kobo.5.1">Role</span></kbd><span class="koboSpan" id="kobo.6.1"> or </span><kbd><span class="koboSpan" id="kobo.7.1">ClusterRole</span></kbd><span class="koboSpan" id="kobo.8.1"> to a list of users or service accounts. </span><span class="koboSpan" id="kobo.8.2">If a </span><kbd><span class="koboSpan" id="kobo.9.1">ClusterRole</span></kbd><span class="koboSpan" id="kobo.10.1"> is bound with a </span><kbd><span class="koboSpan" id="kobo.11.1">RoleBinding</span></kbd><span class="koboSpan" id="kobo.12.1"> instead of a </span><kbd><span class="koboSpan" id="kobo.13.1">ClusterRoleBinding</span></kbd><span class="koboSpan" id="kobo.14.1">, it will only </span><span><span class="koboSpan" id="kobo.15.1">be</span></span><span><span class="koboSpan" id="kobo.16.1"> </span></span><span><span class="koboSpan" id="kobo.17.1">granted the permissions within the namespace where </span></span><kbd><span class="koboSpan" id="kobo.18.1">RoleBinding</span></kbd><span class="koboSpan" id="kobo.19.1"> was </span><span><span class="koboSpan" id="kobo.20.1">specified.</span></span></p>
<p><span><span class="koboSpan" id="kobo.21.1">The following is an example of the </span></span><kbd><span class="koboSpan" id="kobo.22.1">RoleBinding</span></kbd> <span><span class="koboSpan" id="kobo.23.1">spec:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.24.1">// configuration file for RoleBinding resource</span><br/><span class="koboSpan" id="kobo.25.1"># cat 5-2_rbac/rolebinding_user.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.26.1">kind: RoleBinding</span></strong><br/><strong><span class="koboSpan" id="kobo.27.1">apiVersion: rbac.authorization.k8s.io/v1</span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.29.1">  name: devops-role-binding</span></strong><br/><strong><span class="koboSpan" id="kobo.30.1">  namespace: chapter5</span></strong><br/><strong><span class="koboSpan" id="kobo.31.1">subjects:</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">- kind: User</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">  name: linda</span></strong><br/><strong><span class="koboSpan" id="kobo.34.1">  apiGroup: rbac.authorization.k8s.io</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">roleRef:</span></strong><br/><strong><span class="koboSpan" id="kobo.36.1">  kind: Role</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">  name: devops-role</span></strong><br/><strong><span class="koboSpan" id="kobo.38.1">  apiGroup: rbac.authorization.k8s.io</span></strong><br/><br/><span class="koboSpan" id="kobo.39.1">// create a RoleBinding for User linda</span><br/><strong><span class="koboSpan" id="kobo.40.1"># kubectl create -f 5-2_rbac/rolebinding_user.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.41.1">rolebinding.rbac.authorization.k8s.io/devops-role-binding created</span></strong></pre>
<p><span class="koboSpan" id="kobo.42.1">­In this example, we bind a </span><kbd><span class="koboSpan" id="kobo.43.1">Role</span></kbd><span class="koboSpan" id="kobo.44.1"> with a user through </span><kbd><span class="koboSpan" id="kobo.45.1">roleRef</span></kbd><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">This grants Linda the permission that we defined in the </span><kbd><span class="koboSpan" id="kobo.47.1">devops-role</span></kbd><span class="koboSpan" id="kobo.48.1">.</span></p>
<p><span class="koboSpan" id="kobo.49.1">On the other hand, a </span><kbd><span class="koboSpan" id="kobo.50.1">ClusterRoleBinding</span></kbd><span class="koboSpan" id="kobo.51.1"> is used to grant permission in all namespaces. </span><span class="koboSpan" id="kobo.51.2">Here, we'll leverage the same concept from </span><a href="acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml"><span class="koboSpan" id="kobo.52.1">Chapter 9</span></a><span class="koboSpan" id="kobo.53.1">,</span><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.54.1"> </span><em><span class="koboSpan" id="kobo.55.1">Continuous Delivery</span></em></span><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">First, we created a service account named </span><kbd><span class="koboSpan" id="kobo.57.1">cd-agent</span></kbd><span class="koboSpan" id="kobo.58.1">, then created a </span><kbd><span class="koboSpan" id="kobo.59.1">ClusterRole</span></kbd><span class="koboSpan" id="kobo.60.1"> named </span><kbd><span class="koboSpan" id="kobo.61.1">cd-role</span></kbd><span class="koboSpan" id="kobo.62.1">, and a </span><kbd><span class="koboSpan" id="kobo.63.1">ClusterRoleBinding</span></kbd><span class="koboSpan" id="kobo.64.1"> for </span><kbd><span class="koboSpan" id="kobo.65.1">cd-agent</span></kbd><span class="koboSpan" id="kobo.66.1"> and </span><kbd><span class="koboSpan" id="kobo.67.1">cd-role</span></kbd><span class="koboSpan" id="kobo.68.1">. </span><span class="koboSpan" id="kobo.68.2">We then used </span><kbd><span class="koboSpan" id="kobo.69.1">cd-agent</span></kbd><span class="koboSpan" id="kobo.70.1"> to do the deployment on our behalf:</span></p>
<pre><strong><span class="koboSpan" id="kobo.71.1">// configuration file for ClusterRoleBinding</span><br/><span class="koboSpan" id="kobo.72.1"># cat 5-2_rbac/cluster_rolebinding_user.yaml
apiVersion: rbac.authorization.k8s.io/v1</span><br/><span class="koboSpan" id="kobo.73.1">kind: ClusterRoleBinding
metadata:
  name: cd-agent
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
   name: cd-role
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: system:serviceaccount:cd:cd-agent  </span><br/><br/><span class="koboSpan" id="kobo.74.1">// create the ClusterRoleBinding</span><br/><span class="koboSpan" id="kobo.75.1"># kubectl create -f 5-2_rbac/cluster_rolebinding_user.yaml</span><br/><span class="koboSpan" id="kobo.76.1">clusterrolebinding.rbac.authorization.k8s.io/cd-agent created</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.77.1">The </span><kbd><span class="koboSpan" id="kobo.78.1">cd-agent</span></kbd><span class="koboSpan" id="kobo.79.1"> is bound with a </span><kbd><span class="koboSpan" id="kobo.80.1">ClusterRole</span></kbd><span class="koboSpan" id="kobo.81.1"> via </span><kbd><span class="koboSpan" id="kobo.82.1">ClusterRoleBinding</span></kbd><span class="koboSpan" id="kobo.83.1">, so it can have the permission that's specified in </span><kbd><span class="koboSpan" id="kobo.84.1">cd-role</span></kbd><span class="koboSpan" id="kobo.85.1"> across namespaces. </span><span class="koboSpan" id="kobo.85.2">Since a service account is created in a namespace, we'll need to specify its full name, including its </span><kbd><span class="koboSpan" id="kobo.86.1">namespace</span></kbd><span class="koboSpan" id="kobo.87.1">: </span></p>
<pre><strong><span class="koboSpan" id="kobo.88.1">system:serviceaccount:&lt;namespace&gt;:&lt;serviceaccountname&gt;</span></strong> </pre>
<p><kbd><span class="koboSpan" id="kobo.89.1">ClusterRoleBinding</span></kbd><span class="koboSpan" id="kobo.90.1"> also supports </span><kbd><span class="koboSpan" id="kobo.91.1">Group</span></kbd><span class="koboSpan" id="kobo.92.1"> as a subject.</span></p>
<p><span class="koboSpan" id="kobo.93.1">Now, let's try to get pods again via </span><kbd><span class="koboSpan" id="kobo.94.1">devops-context</span></kbd><span class="koboSpan" id="kobo.95.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.96.1"># kubectl --context=devops-context get pods
No resources found.</span></strong></pre>
<p><span><span class="koboSpan" id="kobo.97.1">We are no longer getting a forbidden response. </span></span><span class="koboSpan" id="kobo.98.1">What about if Linda wants to list namespaces—is this allowed?</span></p>
<pre><strong><span class="koboSpan" id="kobo.99.1"># kubectl --context=devops-context get namespaces
Error from server (Forbidden): User "linda" cannot list namespaces at the cluster scope. </span><span class="koboSpan" id="kobo.99.2">(get namespaces)</span></strong></pre>
<p><span class="koboSpan" id="kobo.100.1">The answer is no, since Linda has not been granted permission to list namespaces.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Admission control</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Admission control takes place before Kubernetes processes the request and after authentication and authorization is passed. </span><span class="koboSpan" id="kobo.2.2">It's enabled when launching an API server by adding the </span><kbd><span class="koboSpan" id="kobo.3.1">--admission-control</span></kbd><span class="koboSpan" id="kobo.4.1"> parameter. </span><span class="koboSpan" id="kobo.4.2">Kubernetes recommends having the following plugins within the cluster if the cluster version is greater than or equal to 1.10.0:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">--enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota</span></pre>
<p><span class="koboSpan" id="kobo.6.1">The following sections introduce these plugins and why we need them. </span><span class="koboSpan" id="kobo.6.2">For the latest information about supported admission control plugins, please visit the official documentation: </span><a href="https://kubernetes.io/docs/admin/admission-controllers" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.7.1">https://kubernetes.io/docs/admin/admission-controllers</span></span></a><span class="koboSpan" id="kobo.8.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">NamespaceLifecycle</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As we learned earlier, when a namespace is deleted, all objects in that namespace will be evicted as well. </span><span class="koboSpan" id="kobo.2.2">This plugin ensures that no new object creation requests can be made in a namespace that is terminating or non-existent. </span><span class="koboSpan" id="kobo.2.3">It also prevents Kubernetes native namespaces from being deleted.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">LimitRanger</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This plugin ensures that </span><kbd><span class="koboSpan" id="kobo.3.1">LimitRange</span></kbd><span class="koboSpan" id="kobo.4.1"> can work properly. </span><span class="koboSpan" id="kobo.4.2">With </span><kbd><span class="koboSpan" id="kobo.5.1">LimitRange</span></kbd><span class="koboSpan" id="kobo.6.1">, we can set default requests and limits in a namespace, which will be used when launching a pod without specifying the requests and limits.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">ServiceAccount</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The service account plugin must be added if you use service account objects. </span><span class="koboSpan" id="kobo.2.2">For more information about </span><kbd><span class="koboSpan" id="kobo.3.1">ServiceAccount</span></kbd><span class="koboSpan" id="kobo.4.1">, revisit the </span><span><em><span class="koboSpan" id="kobo.5.1">Service account token authentication</span></em><span class="koboSpan" id="kobo.6.1"> section of this chapter.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">PersistentVolumeLabel</span></h1>
                </header>
            
            <article>
                
<p><kbd><span class="koboSpan" id="kobo.2.1">PersistentVolumeLabel</span></kbd><span class="koboSpan" id="kobo.3.1"> adds labels to newly created PVs, based on the labels provided by the underlying cloud provider. </span><span class="koboSpan" id="kobo.3.2">This admission controller has been deprecated since the 1.8 release.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">DefaultStorageClass</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This plugin ensures that default storage classes work as expected if no </span><kbd><span class="koboSpan" id="kobo.3.1">StorageClass</span></kbd><span class="koboSpan" id="kobo.4.1"> is set in a PVC. </span><span class="koboSpan" id="kobo.4.2">Different cloud providers implement their own </span><kbd><span class="koboSpan" id="kobo.5.1">DefaultStorageClass</span></kbd><span class="koboSpan" id="kobo.6.1"> (such as how GKE uses Google Cloud Persistent Disk). </span><span class="koboSpan" id="kobo.6.2">Make sure you have this enabled.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">ResourceQuota</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Just like the </span><kbd><span class="koboSpan" id="kobo.3.1">LimitRange</span></kbd><span class="koboSpan" id="kobo.4.1">, if you're using the </span><kbd><span class="koboSpan" id="kobo.5.1">ResourceQuota</span></kbd><span class="koboSpan" id="kobo.6.1"> object to administer a different level of QoS, this plugin must be enabled. </span><span class="koboSpan" id="kobo.6.2">The </span><kbd><span class="koboSpan" id="kobo.7.1">ResourceQuota</span></kbd><span class="koboSpan" id="kobo.8.1"> should always be put at the end of the admission control plugin list. </span><span class="koboSpan" id="kobo.8.2">As we mentioned in the </span><em><span class="koboSpan" id="kobo.9.1">ResourceQuota</span></em><span class="koboSpan" id="kobo.10.1"> section, </span><kbd><span class="koboSpan" id="kobo.11.1">ResourceQuota</span></kbd><span class="koboSpan" id="kobo.12.1"> is used to limit the resource usage per namespace. Putting the </span><kbd><span class="koboSpan" id="kobo.13.1">ResourceQuota</span></kbd><span class="koboSpan" id="kobo.14.1"> controller at the end of the admission controller list could prevent the request from increasing quota usage prematurely if it eventually gets rejected by controllers that are put after it, if any are.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">DefaultTolerationSeconds</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">DefaultTolerationSeconds</span></kbd><span class="koboSpan" id="kobo.4.1"> plugin is used to set pods without any toleration sets. </span><span class="koboSpan" id="kobo.4.2">It will then apply for the default toleration for the </span><kbd><span class="koboSpan" id="kobo.5.1">notready:NoExecute</span></kbd><span class="koboSpan" id="kobo.6.1"> and </span><kbd><span class="koboSpan" id="kobo.7.1">unreachable:NoExecute</span></kbd><span class="koboSpan" id="kobo.8.1"> taints for 300 seconds. </span><span class="koboSpan" id="kobo.8.2">If you don't want this behavior to occur in the cluster, disable this plugin. </span><span class="koboSpan" id="kobo.8.3">For more information, please refer to the taints and tolerations section of </span><a href="a7a72300-181d-41ad-a08a-7e42744d365f.xhtml"><span class="koboSpan" id="kobo.9.1">Chapter 8</span></a><span class="koboSpan" id="kobo.10.1">, </span><em><span class="koboSpan" id="kobo.11.1">Resource Management and Scaling</span></em><span class="koboSpan" id="kobo.12.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">PodNodeSelector</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This plugin is used to set the </span><kbd><span class="koboSpan" id="kobo.3.1">node-selector</span></kbd><span class="koboSpan" id="kobo.4.1"> annotation to the namespace. </span><span class="koboSpan" id="kobo.4.2">When the plugin is enabled, pass along a configuration file with the </span><kbd><span class="koboSpan" id="kobo.5.1">--admission-control-config-file</span></kbd><span class="koboSpan" id="kobo.6.1"> command using the following format:</span></p>
<pre><strong><span class="koboSpan" id="kobo.7.1">podNodeSelectorPluginConfig:</span></strong><br/><strong><span class="koboSpan" id="kobo.8.1">  clusterDefaultNodeSelector: &lt;default-node-selectors-  </span></strong><br/><strong><span class="koboSpan" id="kobo.9.1">  labels&gt;
  namespace1: &lt;namespace-node-selectors-labels-1&gt;
  namespace2: &lt;namespace-node-selectors-labels-2&gt;</span></strong></pre>
<p><span class="koboSpan" id="kobo.10.1">By doing this, the </span><kbd><span class="koboSpan" id="kobo.11.1">node-selector</span></kbd><span class="koboSpan" id="kobo.12.1"> annotation will be applied to the </span><kbd><span class="koboSpan" id="kobo.13.1">namespace</span></kbd><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">The pods on that namespace will then run on those matched nodes.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">AlwaysPullImages</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The pull policy defines the behavior when kubelet pulls images. </span><span class="koboSpan" id="kobo.2.2">The default pull policy is </span><kbd><span class="koboSpan" id="kobo.3.1">IfNotPresent</span></kbd><span class="koboSpan" id="kobo.4.1">, that is, it will pull the image if it is not present locally. </span><span class="koboSpan" id="kobo.4.2">If this plugin is enabled, the default pull policy will become </span><kbd><span class="koboSpan" id="kobo.5.1">Always</span></kbd><span class="koboSpan" id="kobo.6.1">, which is to always pull the latest image. </span><span class="koboSpan" id="kobo.6.2">This plugin also brings another benefit if your cluster is shared by different teams. </span><span class="koboSpan" id="kobo.6.3">Whenever a pod is scheduled, it'll always pull the latest image, regardless of whether the image exists locally or not. </span><span class="koboSpan" id="kobo.6.4">Then, we can ensure that a pod creation request always goes through an authorization check against the image.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">DenyEscalatingExec</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This plugin prevents any </span><kbd><span class="koboSpan" id="kobo.3.1">kubectl exec</span></kbd><span class="koboSpan" id="kobo.4.1"> or </span><kbd><span class="koboSpan" id="kobo.5.1">kubectl attach</span></kbd><span class="koboSpan" id="kobo.6.1"> commands from making pods escalate to privilege mode. </span><span class="koboSpan" id="kobo.6.2">Pods within privilege mode have access to the host namespace, which could become a security risk.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Other admission controller plugins</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There are many other admission controller plugins we could use, such as </span><kbd><span class="koboSpan" id="kobo.3.1">NodeRestriciton</span></kbd><span class="koboSpan" id="kobo.4.1"> to limit kubelet's permission, </span><kbd><span class="koboSpan" id="kobo.5.1">ImagePolicyWebhook</span></kbd><span class="koboSpan" id="kobo.6.1"> to establish a webhook to control the access of the images, and </span><kbd><span class="koboSpan" id="kobo.7.1">SecurityContextDeny</span></kbd><span class="koboSpan" id="kobo.8.1"> for controlling the privilege for a pod or a container. </span><span class="koboSpan" id="kobo.8.2">Please refer to the official documentation at </span><a href="https://kubernetes.io/docs/admin/admission-controllers/"><span class="URLPACKT"><span class="koboSpan" id="kobo.9.1">https://kubernetes.io/docs/admin/admission-controllers</span></span></a><span class="koboSpan" id="kobo.10.1"> to learn more about other plugins.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Dynamic admission control</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Before Kubernetes 1.7, admission controllers were compiled with Kubernetes API server, so they could </span><span><span class="koboSpan" id="kobo.3.1">only</span></span><span><span class="koboSpan" id="kobo.4.1"> be configured before the API server started. </span><span class="koboSpan" id="kobo.4.2">Dynamic admission control aimed to break this limitation. </span><span class="koboSpan" id="kobo.4.3">There are </span></span><span><span class="koboSpan" id="kobo.5.1">two methods to implement custom dynamic admission control: via initializer and admission webhooks. </span><span class="koboSpan" id="kobo.5.2">The Initializer webhook can watch an uninitialized workload and check whether it needs to take any action against it.</span></span></p>
<p><span><span class="koboSpan" id="kobo.6.1">The Admission webhook intercepts the request and checks the preset rules from its configuration before deciding whether the requests are allowed or not. </span></span><span><span class="koboSpan" id="kobo.7.1">Both the initializer and admission webhooks can admit and mutate the resource request on certain operations, so we can leverage them to force policies or validate whether the requests fulfill the requirement of your organization. </span><span class="koboSpan" id="kobo.7.2">Buggy initializer and admission webhooks might block all the target resources from being created. </span><span class="koboSpan" id="kobo.7.3">However, the Admission webhook provides a failure policy, which can address when the webhook server doesn't respond as expected. </span></span></p>
<p><span class="koboSpan" id="kobo.8.1">At the time of writing this book, the admission webhook has been promoted to beta, but the </span><span><span class="koboSpan" id="kobo.9.1">Initializer is still alpha. </span><span class="koboSpan" id="kobo.9.2">In this section, we'll implement a simple Admission webhook controller, which will verify whether the </span><kbd><span class="koboSpan" id="kobo.10.1">{"chapter": "5"}</span></kbd><span class="koboSpan" id="kobo.11.1"> annotation is set to the </span><kbd><span class="koboSpan" id="kobo.12.1">podSpec</span></kbd><span class="koboSpan" id="kobo.13.1"> during pod creation. </span><span class="koboSpan" id="kobo.13.2">The request will go through if the annotation is set. </span><span class="koboSpan" id="kobo.13.3">If not, the request will fail.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Admission webhook</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There are two major components to implementing an Admission webhook controller: a webhook HTTP server to receive the resource life event and a </span><kbd><span class="koboSpan" id="kobo.3.1">ValidatingWebhookConfiguration</span></kbd><span class="koboSpan" id="kobo.4.1"> or </span><kbd><span class="koboSpan" id="kobo.5.1">MutatingWebhookConfiguration</span></kbd><span class="koboSpan" id="kobo.6.1"> resource configuration file. </span><span class="koboSpan" id="kobo.6.2">Please refer to </span><a href="https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter5/5-3_admission-webhook/sample-validating-admission-webhook"><span class="koboSpan" id="kobo.7.1">https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter5/5-3_admission-webhook/sample-validating-admission-webhook</span></a><span class="koboSpan" id="kobo.8.1"> for the source code of our sample Admission webhook. </span></p>
<p><span class="koboSpan" id="kobo.9.1">Let's look at how to write a </span><kbd><span class="koboSpan" id="kobo.10.1">ValidatingWebhookConfiguration</span></kbd><span><span class="koboSpan" id="kobo.11.1">. </span><span class="koboSpan" id="kobo.11.2">As we can see in the following code, like normal objects, </span></span><kbd><span class="koboSpan" id="kobo.12.1">ValidatingWebhookConfiguration</span></kbd> <span><span class="koboSpan" id="kobo.13.1">has an API version, a kind, and metadata with a name and labels. </span><span class="koboSpan" id="kobo.13.2">The important session is named </span><kbd><span class="koboSpan" id="kobo.14.1">webhooks</span></kbd><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">In </span><kbd><span class="koboSpan" id="kobo.16.1">webhooks</span></kbd><span class="koboSpan" id="kobo.17.1">, one or more rules need to be defined. </span><span class="koboSpan" id="kobo.17.2">Here, we are defining a rule that is triggered on any pod's creation request (</span><kbd><span class="koboSpan" id="kobo.18.1">operations=CREATE, resources=pods</span></kbd><span class="koboSpan" id="kobo.19.1">). </span><span class="koboSpan" id="kobo.19.2">The </span></span><kbd><span class="koboSpan" id="kobo.20.1">failurePolicy</span></kbd> <span><span class="koboSpan" id="kobo.21.1">is used to determine the action if an error occurs when calling the webhook. </span><span class="koboSpan" id="kobo.21.2">The option of </span><kbd><span class="koboSpan" id="kobo.22.1">failurePolicy</span></kbd><span class="koboSpan" id="kobo.23.1"> is either </span><kbd><span class="koboSpan" id="kobo.24.1">Fail</span></kbd><span class="koboSpan" id="kobo.25.1"> or ignore (</span><kbd><span class="koboSpan" id="kobo.26.1">Fail</span></kbd><span class="koboSpan" id="kobo.27.1"> means making the request fail, while ignore means the webhook error will be ignored). </span><span class="koboSpan" id="kobo.27.2">The</span></span> <kbd><span class="koboSpan" id="kobo.28.1">clientConfig</span></kbd> <span><span class="koboSpan" id="kobo.29.1">session defines the endpoint of the webhook server. </span><span class="koboSpan" id="kobo.29.2">Here, we are leveraging a Kubernetes service named</span></span> <kbd><span class="koboSpan" id="kobo.30.1">sample-webhook-service-svc</span></kbd><span><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">If it's an external server, the URL could be specified directly rather than using</span></span><span class="koboSpan" id="kobo.32.1"> a service</span><span><span class="koboSpan" id="kobo.33.1">. </span><span class="koboSpan" id="kobo.33.2">The</span></span> <kbd><span class="koboSpan" id="kobo.34.1">caBundle</span></kbd> <span><span class="koboSpan" id="kobo.35.1">is used to validate the webhook's server certificate. </span><span class="koboSpan" id="kobo.35.2">If not specified, by default, it'll use API server's system trust roots.</span></span></p>
<p><span><span class="koboSpan" id="kobo.36.1">To export</span></span> <kbd><span class="koboSpan" id="kobo.37.1">caBundle</span></kbd> <span><span class="koboSpan" id="kobo.38.1">from Kubernetes Service, use the </span><kbd><span class="koboSpan" id="kobo.39.1">kubectl get configmap -n kube-system extension-apiserver-authentication -o=jsonpath='{.data.client-ca-file}' | base64 | tr -d '\n'</span></kbd><span class="koboSpan" id="kobo.40.1"> command and replace the </span></span><kbd><span class="koboSpan" id="kobo.41.1">${CA_BUNDLE}</span></kbd> <span><span class="koboSpan" id="kobo.42.1">field as follows:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.43.1"># cat chapter5/5-3_admission-webhook/sample-validating-admission-webhook/validatingwebhookconfiguration.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.44.1">apiVersion: admissionregistration.k8s.io/v1beta1</span></strong><br/><strong><span class="koboSpan" id="kobo.45.1">kind: ValidatingWebhookConfiguration</span></strong><br/><strong><span class="koboSpan" id="kobo.46.1">metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.47.1">  name: sample-webhook-service</span></strong><br/><strong><span class="koboSpan" id="kobo.48.1">  labels:</span></strong><br/><strong><span class="koboSpan" id="kobo.49.1">    app: sample-webhook-service</span></strong><br/><strong><span class="koboSpan" id="kobo.50.1">webhooks:</span></strong><br/><strong><span class="koboSpan" id="kobo.51.1">  - name: devops.kubernetes.com</span></strong><br/><strong><span class="koboSpan" id="kobo.52.1">    rules:</span></strong><br/><strong><span class="koboSpan" id="kobo.53.1">      - apiGroups:</span></strong><br/><strong><span class="koboSpan" id="kobo.54.1">          - ""</span></strong><br/><strong><span class="koboSpan" id="kobo.55.1">        apiVersions:</span></strong><br/><strong><span class="koboSpan" id="kobo.56.1">          - v1</span></strong><br/><strong><span class="koboSpan" id="kobo.57.1">        operations:</span></strong><br/><strong><span class="koboSpan" id="kobo.58.1">          - CREATE</span></strong><br/><strong><span class="koboSpan" id="kobo.59.1">        resources:</span></strong><br/><strong><span class="koboSpan" id="kobo.60.1">          - pods</span></strong><br/><strong><span class="koboSpan" id="kobo.61.1">    failurePolicy: Fail</span></strong><br/><strong><span class="koboSpan" id="kobo.62.1">    clientConfig:</span></strong><br/><strong><span class="koboSpan" id="kobo.63.1">      service:</span></strong><br/><strong><span class="koboSpan" id="kobo.64.1">        name: sample-webhook-service-svc</span></strong><br/><strong><span class="koboSpan" id="kobo.65.1">        namespace: default</span></strong><br/><strong><span class="koboSpan" id="kobo.66.1">        path: "/"</span></strong><br/><strong><span class="koboSpan" id="kobo.67.1">      caBundle: ${CA_BUNDLE}</span></strong></pre>
<p><span class="koboSpan" id="kobo.68.1">To make a webhook HTTP server, we create a simple </span><span><span class="koboSpan" id="kobo.69.1">express</span></span><span class="koboSpan" id="kobo.70.1"> web application in Node.js (</span><a href="https://expressjs.com/"><span class="koboSpan" id="kobo.71.1">https://expressjs.com/</span></a><span class="koboSpan" id="kobo.72.1">). </span><span class="koboSpan" id="kobo.72.2">The main logic of the application is to receive a pod creation event and send an </span><kbd><span><span class="koboSpan" id="kobo.73.1">admissionResponse</span></span></kbd><span><span class="koboSpan" id="kobo.74.1"> (</span><a href="https://github.com/kubernetes/api/blob/master/admission/v1beta1/types.go#L81"><span class="koboSpan" id="kobo.75.1">https://github.com/kubernetes/api/blob/master/admission/v1beta1/types.go#L81</span></a><span class="koboSpan" id="kobo.76.1">) back. </span><span class="koboSpan" id="kobo.76.2">Here, we'll return an </span></span><kbd><span class="koboSpan" id="kobo.77.1">admissionResponse</span></kbd><span><span class="koboSpan" id="kobo.78.1"> with the </span></span><kbd><span class="koboSpan" id="kobo.79.1">allowed</span></kbd> <span><span class="koboSpan" id="kobo.80.1">field, which indicates whether a request is allowed or denied:</span></span></p>
<pre><span class="koboSpan" id="kobo.81.1">function webhook(req, res) {</span><br/><span class="koboSpan" id="kobo.82.1">  var admissionRequest = req.body;</span><br/><span class="koboSpan" id="kobo.83.1">  var object = admissionRequest.request.object;</span><br/><br/><span class="koboSpan" id="kobo.84.1">  var allowed = false;</span><br/><span class="koboSpan" id="kobo.85.1">  if (!isEmpty(object.metadata.annotations) &amp;&amp; !isEmpty(object.metadata.annotations.chapter) &amp;&amp; object.metadata.annotations.chapter == "5") {</span><br/><span class="koboSpan" id="kobo.86.1">    allowed = true;</span><br/><span class="koboSpan" id="kobo.87.1">  }</span><br/><br/><span class="koboSpan" id="kobo.88.1">  var admissionResponse = {</span><br/><span class="koboSpan" id="kobo.89.1">    allowed: allowed</span><br/><span class="koboSpan" id="kobo.90.1">  };</span><br/><br/><span class="koboSpan" id="kobo.91.1">  for (var container of object.spec.containers) {</span><br/><span class="koboSpan" id="kobo.92.1">    console.log(container.securityContext);</span><br/><span class="koboSpan" id="kobo.93.1">    var image = container.image;</span><br/><span class="koboSpan" id="kobo.94.1">        var admissionReview = {</span><br/><span class="koboSpan" id="kobo.95.1">          response: admissionResponse</span><br/><span class="koboSpan" id="kobo.96.1">        };</span><br/><span class="koboSpan" id="kobo.97.1">        console.log("Response: " + JSON.stringify(admissionReview));</span><br/><span class="koboSpan" id="kobo.98.1">        res.setHeader('Content-Type', 'application/json');</span><br/><span class="koboSpan" id="kobo.99.1">        res.send(JSON.stringify(admissionReview));</span><br/><span class="koboSpan" id="kobo.100.1">        res.status(200).end();</span><br/><span class="koboSpan" id="kobo.101.1">    };</span><br/><span class="koboSpan" id="kobo.102.1">};</span></pre>
<p><span class="koboSpan" id="kobo.103.1">In the preceding function, we checked whether </span><kbd><span class="koboSpan" id="kobo.104.1">object.metadata.annotations.chapter</span></kbd><span class="koboSpan" id="kobo.105.1"> is annotated in the pod and whether the chapter is equal to </span><kbd><span class="koboSpan" id="kobo.106.1">5</span></kbd><span class="koboSpan" id="kobo.107.1">. </span><span class="koboSpan" id="kobo.107.2">If it is, the webhook server will pass the request. </span><span class="koboSpan" id="kobo.107.3">The webhook and API servers need to establish a mutual trust. </span><span class="koboSpan" id="kobo.107.4">To do this, we'll generate a certificate for the webhook server by requesting a certificate signing through the </span><kbd><span class="koboSpan" id="kobo.108.1">certificates.k8s.io</span></kbd><span class="koboSpan" id="kobo.109.1"> API. </span><span class="koboSpan" id="kobo.109.2">The popular service mesh implementation, Istio (</span><a href="https://istio.io/"><span class="koboSpan" id="kobo.110.1">https://istio.io/</span></a><span class="koboSpan" id="kobo.111.1">), has a useful tool for us (</span><a href="https://raw.githubusercontent.com/istio/istio/41203341818c4dada2ea5385cfedc7859c01e957/install/kubernetes/webhook-create-signed-cert.sh"><span class="koboSpan" id="kobo.112.1">https://raw.githubusercontent.com/istio/istio/41203341818c4dada2ea5385cfedc7859c01e957/install/kubernetes/webhook-create-signed-cert.sh</span></a><span class="koboSpan" id="kobo.113.1">): </span></p>
<pre><strong><span class="koboSpan" id="kobo.114.1"># wget https://raw.githubusercontent.com/istio/istio/41203341818c4dada2ea5385cfedc7859c01e957/install/kubernetes/webhook-create-signed-cert.sh</span></strong><br/><strong><span class="koboSpan" id="kobo.115.1">// create the cert</span></strong><br/><strong><span class="koboSpan" id="kobo.116.1"># sh webhook-create-signed-cert.sh --service sample-webhook-service-svc --secret sample-webhook-service-certs --namespace default</span></strong></pre>
<p><kbd><span class="koboSpan" id="kobo.117.1">server-key.pem</span></kbd><span class="koboSpan" id="kobo.118.1"> and </span><kbd><span class="koboSpan" id="kobo.119.1">server-cert.pem</span></kbd><span class="koboSpan" id="kobo.120.1"> will be generated via the script under the default </span><kbd><span class="koboSpan" id="kobo.121.1">temp</span></kbd><span class="koboSpan" id="kobo.122.1"> folder in your operating system. </span><span class="koboSpan" id="kobo.122.2">Copying them can put them under the </span><kbd><span class="koboSpan" id="kobo.123.1">src/keys</span></kbd><span class="koboSpan" id="kobo.124.1"> folder inside our sample webhook HTTP server. Now, it's time to build the application with docker via </span><kbd><span class="koboSpan" id="kobo.125.1">docker build -t $registry/$repository:$tag .</span></kbd><span class="koboSpan" id="kobo.126.1"> and push the target docker image to the registry (here, we used </span><kbd><span class="koboSpan" id="kobo.127.1">devopswithkubernetes/sample-webhook-service:latest</span></kbd><span class="koboSpan" id="kobo.128.1">). </span><span class="koboSpan" id="kobo.128.2">After doing this, we can launch the webserver:</span></p>
<pre><strong><span class="koboSpan" id="kobo.129.1"># cat chapter5/5-3_admission-webhook/sample-validating-admission-webhook/deployment.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.130.1">apiVersion: apps/v1</span></strong><br/><strong><span class="koboSpan" id="kobo.131.1">kind: Deployment</span></strong><br/><strong><span class="koboSpan" id="kobo.132.1">metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.133.1">  name: sample-webhook-service</span></strong><br/><strong><span class="koboSpan" id="kobo.134.1">  labels:</span></strong><br/><strong><span class="koboSpan" id="kobo.135.1">    app: sample-webhook-service</span></strong><br/><strong><span class="koboSpan" id="kobo.136.1">spec:</span></strong><br/><strong><span class="koboSpan" id="kobo.137.1">  replicas: 1</span></strong><br/><strong><span class="koboSpan" id="kobo.138.1">  selector:</span></strong><br/><strong><span class="koboSpan" id="kobo.139.1">    matchLabels:</span></strong><br/><strong><span class="koboSpan" id="kobo.140.1">      app: sample-webhook-service</span></strong><br/><strong><span class="koboSpan" id="kobo.141.1">  template:</span></strong><br/><strong><span class="koboSpan" id="kobo.142.1">    metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.143.1">      labels:</span></strong><br/><strong><span class="koboSpan" id="kobo.144.1">        app: sample-webhook-service</span></strong><br/><strong><span class="koboSpan" id="kobo.145.1">    spec:</span></strong><br/><strong><span class="koboSpan" id="kobo.146.1">      containers:</span></strong><br/><strong><span class="koboSpan" id="kobo.147.1">      - name: sample-webhook-service</span></strong><br/><strong><span class="koboSpan" id="kobo.148.1">        image: devopswithkubernetes/sample-webhook-service:latest</span></strong><br/><strong><span class="koboSpan" id="kobo.149.1">        imagePullPolicy: Always</span></strong><br/><strong><span class="koboSpan" id="kobo.150.1">---</span></strong><br/><strong><span class="koboSpan" id="kobo.151.1">apiVersion: v1</span></strong><br/><strong><span class="koboSpan" id="kobo.152.1">kind: Service</span></strong><br/><strong><span class="koboSpan" id="kobo.153.1">metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.154.1">  name: sample-webhook-service-svc</span></strong><br/><strong><span class="koboSpan" id="kobo.155.1">  labels:</span></strong><br/><strong><span class="koboSpan" id="kobo.156.1">    app: sample-webhook-service</span></strong><br/><strong><span class="koboSpan" id="kobo.157.1">spec:</span></strong><br/><strong><span class="koboSpan" id="kobo.158.1">  ports:</span></strong><br/><strong><span class="koboSpan" id="kobo.159.1">  - port: 443</span></strong><br/><strong><span class="koboSpan" id="kobo.160.1">    targetPort: 443</span></strong><br/><strong><span class="koboSpan" id="kobo.161.1">  selector:</span></strong><br/><strong><span class="koboSpan" id="kobo.162.1">    app: sample-webhook-service</span></strong><br/> <br/><strong><span class="koboSpan" id="kobo.163.1"># kubectl create -f chapter5/5-3_admission-webhook/sample-validating-admission-webhook/deployment.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.164.1">deployment.apps/sample-webhook-service created</span></strong><br/><strong><span class="koboSpan" id="kobo.165.1">service/sample-webhook-service-svc created</span></strong></pre>
<p><span class="koboSpan" id="kobo.166.1">After checking that the pod is up and running, we can create a </span><kbd><span class="koboSpan" id="kobo.167.1">ValidatingWebhookConfiguration</span></kbd><span class="koboSpan" id="kobo.168.1"> resource:</span></p>
<pre><strong><span class="koboSpan" id="kobo.169.1"># kubectl create -f chapter5/5-3_admission-webhook/sample-validating-admission-webhook/validatingwebhookconfiguration.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.170.1">validatingwebhookconfiguration.admissionregistration.k8s.io/sample-webhook-service </span></strong><br/><strong><span class="koboSpan" id="kobo.171.1">created</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.172.1"># kubectl get validatingwebhookconfiguration</span></strong><br/><strong><span class="koboSpan" id="kobo.173.1">NAME CREATED AT</span></strong><br/><strong><span class="koboSpan" id="kobo.174.1">sample-webhook-service 2018-12-27T21:04:50Z</span></strong></pre>
<p><span class="koboSpan" id="kobo.175.1">Let's try deploying two </span><kbd><span class="koboSpan" id="kobo.176.1">nginx</span></kbd><span class="koboSpan" id="kobo.177.1"> pods without any annotations:</span></p>
<pre><strong><span class="koboSpan" id="kobo.178.1"># cat chapter5/5-3_admission-webhook/sample-validating-admission-webhook/test-sample.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.179.1">apiVersion: apps/v1</span></strong><br/><strong><span class="koboSpan" id="kobo.180.1">kind: Deployment</span></strong><br/><strong><span class="koboSpan" id="kobo.181.1">metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.182.1">  name: nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.183.1">  labels:</span></strong><br/><strong><span class="koboSpan" id="kobo.184.1">    app: nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.185.1">spec:</span></strong><br/><strong><span class="koboSpan" id="kobo.186.1">  replicas: 2</span></strong><br/><strong><span class="koboSpan" id="kobo.187.1">  selector:</span></strong><br/><strong><span class="koboSpan" id="kobo.188.1">    matchLabels:</span></strong><br/><strong><span class="koboSpan" id="kobo.189.1">      app: nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.190.1">  template:</span></strong><br/><strong><span class="koboSpan" id="kobo.191.1">    metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.192.1">      labels:</span></strong><br/><strong><span class="koboSpan" id="kobo.193.1">        app: nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.194.1">      #annotations:</span></strong><br/><strong><span class="koboSpan" id="kobo.195.1">      #  chapter: "5"</span></strong><br/><strong><span class="koboSpan" id="kobo.196.1">    spec:</span></strong><br/><strong><span class="koboSpan" id="kobo.197.1">      containers:</span></strong><br/><strong><span class="koboSpan" id="kobo.198.1">      - name: nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.199.1">        image: nginx</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.200.1"># kubectl create -f chapter5/5-3_admission-webhook/sample-validating-admission-webhook/test-sample.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.201.1">Hdeployment.apps/nginx created</span></strong></pre>
<p><span class="koboSpan" id="kobo.202.1">This is supposed to create two pods; however, we did not see any </span><kbd><span class="koboSpan" id="kobo.203.1">nginx</span></kbd><span class="koboSpan" id="kobo.204.1"> pods being created. </span><span class="koboSpan" id="kobo.204.2">We can only see our webhook service pod:</span></p>
<pre><strong><span class="koboSpan" id="kobo.205.1"># kubectl get po</span></strong><br/><strong><span class="koboSpan" id="kobo.206.1">NAME READY STATUS RESTARTS AGE</span></strong><br/><strong><span class="koboSpan" id="kobo.207.1">sample-webhook-service-789d87b8b7-m58wq 1/1 Running 0 7h</span></strong></pre>
<p><span class="koboSpan" id="kobo.208.1">If we check the corresponding </span><kbd><span class="koboSpan" id="kobo.209.1">ReplicaSet</span></kbd><span class="koboSpan" id="kobo.210.1">, and use </span><kbd><span class="koboSpan" id="kobo.211.1">kubectl describe rs $RS_NAME</span></kbd><span class="koboSpan" id="kobo.212.1"> to check the events, we will get the following result:</span></p>
<pre><strong><span class="koboSpan" id="kobo.213.1"># kubectl get rs</span></strong><br/><strong><span class="koboSpan" id="kobo.214.1">NAME DESIRED CURRENT READY AGE</span></strong><br/><strong><span class="koboSpan" id="kobo.215.1">nginx-78f5d695bd 2 0 0 1m</span></strong><br/><strong><span class="koboSpan" id="kobo.216.1">sample-webhook-service-789d87b8b7 1 1 1 7h</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.217.1"># kubectl describe rs nginx-78f5d695bd</span></strong><br/><strong><span class="koboSpan" id="kobo.218.1">Name: nginx-78f5d695bd</span></strong><br/><strong><span class="koboSpan" id="kobo.219.1">Namespace: default</span></strong><br/><strong><span class="koboSpan" id="kobo.220.1">Selector: app=nginx,pod-template-hash=3491825168</span></strong><br/><strong><span class="koboSpan" id="kobo.221.1">Labels: app=nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.222.1">                pod-template-hash=3491825168</span></strong><br/><strong><span class="koboSpan" id="kobo.223.1">Annotations: deployment.kubernetes.io/desired-replicas: 2</span></strong><br/><strong><span class="koboSpan" id="kobo.224.1">                deployment.kubernetes.io/max-replicas: 3</span></strong><br/><strong><span class="koboSpan" id="kobo.225.1">                deployment.kubernetes.io/revision: 1</span></strong><br/><strong><span class="koboSpan" id="kobo.226.1">Controlled By: Deployment/nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.227.1">Replicas: 0 current / 2 desired</span></strong><br/><strong><span class="koboSpan" id="kobo.228.1">Pods Status: 0 Running / 0 Waiting / 0 Succeeded / 0 Failed</span></strong><br/><strong><span class="koboSpan" id="kobo.229.1">Pod Template:</span></strong><br/><strong><span class="koboSpan" id="kobo.230.1">  Labels: app=nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.231.1">           pod-template-hash=3491825168</span></strong><br/><strong><span class="koboSpan" id="kobo.232.1">  Containers:</span></strong><br/><strong><span class="koboSpan" id="kobo.233.1">   nginx:</span></strong><br/><strong><span class="koboSpan" id="kobo.234.1">    Image: nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.235.1">    Port: &lt;none&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.236.1">    Host Port: &lt;none&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.237.1">    Environment: &lt;none&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.238.1">    Mounts: &lt;none&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.239.1">  Volumes: &lt;none&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.240.1">Conditions:</span></strong><br/><strong><span class="koboSpan" id="kobo.241.1">  Type Status Reason</span></strong><br/><strong><span class="koboSpan" id="kobo.242.1">  ---- ------ ------</span></strong><br/><strong><span class="koboSpan" id="kobo.243.1">  ReplicaFailure True FailedCreate</span></strong><br/><strong><span class="koboSpan" id="kobo.244.1">Events:</span></strong><br/><strong><span class="koboSpan" id="kobo.245.1">  Type Reason Age From Message</span></strong><br/><strong><span class="koboSpan" id="kobo.246.1">  ---- ------ ---- ---- -------</span></strong><br/><strong><span class="koboSpan" id="kobo.247.1">  Warning FailedCreate 28s (x15 over 110s) replicaset-controller Error creating: Internal error occurred: admission webhook "devops.kubernetes.com" denied the request without explanation</span></strong></pre>
<p><span class="koboSpan" id="kobo.248.1">From this, we can see that the admission webhook denies the request. </span><span class="koboSpan" id="kobo.248.2">Delete and recreate the deployment by using the </span><kbd><span class="koboSpan" id="kobo.249.1">uncom</span><span><span class="koboSpan" id="kobo.250.1">men</span></span><span><span class="koboSpan" id="kobo.251.1">t</span></span></kbd> <span><span class="koboSpan" id="kobo.252.1">annotation in the preceding code block:</span></span></p>
<pre><span class="koboSpan" id="kobo.253.1"> // uncomment this annotation.</span><br/>     <strong><span class="koboSpan" id="kobo.254.1"> #annotations:</span></strong><br/><strong><span class="koboSpan" id="kobo.255.1">      #  chapter: "5"</span></strong></pre>
<p><span class="koboSpan" id="kobo.256.1">If we do this, we should be able to see that the </span><kbd><span class="koboSpan" id="kobo.257.1">nginx</span></kbd><span class="koboSpan" id="kobo.258.1"> pods are created accordingly:</span></p>
<pre><strong><span class="koboSpan" id="kobo.259.1"># kubectl get po</span></strong><br/><strong><span class="koboSpan" id="kobo.260.1">NAME READY STATUS RESTARTS AGE</span></strong><br/><strong><span class="koboSpan" id="kobo.261.1">nginx-978c784c5-v8xk9 0/1 ContainerCreating 0 2s</span></strong><br/><strong><span class="koboSpan" id="kobo.262.1">nginx-978c784c5-wrmdb 1/1 Running 0 2s</span></strong><br/><strong><span class="koboSpan" id="kobo.263.1">sample-webhook-service-789d87b8b7-m58wq 1/1 Running 0 7h</span></strong></pre>
<p><span class="koboSpan" id="kobo.264.1">The request passed through the authentication, authorization, and admission controls, including our webhook service. </span><span class="koboSpan" id="kobo.264.2">The pod objects were </span><span><span class="koboSpan" id="kobo.265.1">created and </span></span><span class="koboSpan" id="kobo.266.1">scheduled accordingly.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.267.1">Please remember to clean up after testing the dynamic admission controllers. </span><span class="koboSpan" id="kobo.267.2">It might block pod creation in future experiments.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Custom resources</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Custom resources, </span><span><span class="koboSpan" id="kobo.3.1">which were first introduced in Kubernetes 1.7,</span></span><span class="koboSpan" id="kobo.4.1"> were designed as an extension point to let users create custom API objects and act as native Kubernetes objects. </span><span class="koboSpan" id="kobo.4.2">This was done so that users could extend Kubernetes to support the custom objects for their application or specific use cases. </span><span class="koboSpan" id="kobo.4.3">Custom resources can be dynamically registered and unregistered. </span><span class="koboSpan" id="kobo.4.4">There are two ways to create custom resources: by using a CRD or aggregated API. </span><span class="koboSpan" id="kobo.4.5">CRDs are much easier, while an aggregated API requires additional coding in Go. </span><span class="koboSpan" id="kobo.4.6">In this section, we'll learn how to write a CRD from scratch.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Custom resources definition</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Creating a </span><strong><span class="koboSpan" id="kobo.3.1">Custom Resources Definition</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">CRD</span></strong><span class="koboSpan" id="kobo.6.1">) object includes two steps: CRD registration and object creation. </span></p>
<p><span class="koboSpan" id="kobo.7.1">Let's create a CRD configuration first:</span></p>
<pre><strong><span class="koboSpan" id="kobo.8.1"># cat chapter5/5-4_crd/5-4-1_crd.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.9.1">apiVersion: apiextensions.k8s.io/v1beta1</span></strong><br/><strong><span class="koboSpan" id="kobo.10.1">kind: CustomResourceDefinition</span></strong><br/><strong><span class="koboSpan" id="kobo.11.1">metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.12.1">  name: books.devops.kubernetes.com</span></strong><br/><strong><span class="koboSpan" id="kobo.13.1">spec:</span></strong><br/><strong><span class="koboSpan" id="kobo.14.1">  group: devops.kubernetes.com</span></strong><br/><strong><span class="koboSpan" id="kobo.15.1">  version: v1alpha1</span></strong><br/><strong><span class="koboSpan" id="kobo.16.1">  scope: Namespaced</span></strong><br/><strong><span class="koboSpan" id="kobo.17.1">  names:</span></strong><br/><strong><span class="koboSpan" id="kobo.18.1">    plural: books</span></strong><br/><strong><span class="koboSpan" id="kobo.19.1">    singular: book</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">    kind: Book</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">    shortNames:</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">    - bk</span></strong><br/><strong><span class="koboSpan" id="kobo.23.1">  validation:</span></strong><br/><strong><span class="koboSpan" id="kobo.24.1">    openAPIV3Schema:</span></strong><br/><strong><span class="koboSpan" id="kobo.25.1">      required: ["spec"]</span></strong><br/><strong><span class="koboSpan" id="kobo.26.1">      properties:</span></strong><br/><strong><span class="koboSpan" id="kobo.27.1">        spec:</span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">          required: ["name", "edition"]</span></strong><br/><strong><span class="koboSpan" id="kobo.29.1">          properties:</span></strong><br/><strong><span class="koboSpan" id="kobo.30.1">            name:</span></strong><br/><strong><span class="koboSpan" id="kobo.31.1">              type: string</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">              minimum: 50</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">            edition:</span></strong><br/><strong><span class="koboSpan" id="kobo.34.1">              type: string</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">              minimum: 10</span></strong><br/><strong><span class="koboSpan" id="kobo.36.1">            chapter:</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">              type: integer</span></strong><br/><strong><span class="koboSpan" id="kobo.38.1">              minimum: 1</span></strong><br/><strong><span class="koboSpan" id="kobo.39.1">              maximum: 2</span></strong></pre>
<p><span class="koboSpan" id="kobo.40.1">With </span><kbd><span class="koboSpan" id="kobo.41.1">CustomResourceDefinition</span></kbd><span class="koboSpan" id="kobo.42.1">, we can define our own spec for the custom object. </span><span class="koboSpan" id="kobo.42.2">First, we'll have to decide on the name of the CRD. </span><span class="koboSpan" id="kobo.42.3">The naming convention for a CRD must be </span><kbd><span class="koboSpan" id="kobo.43.1">spec.names.plural+"."+spec.group</span></kbd><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">Next, we'll define the group, version, scope, and names. </span><span class="koboSpan" id="kobo.44.3">The scope is either </span><kbd><span class="koboSpan" id="kobo.45.1">Namespaced</span></kbd><span class="koboSpan" id="kobo.46.1"> or </span><kbd><span class="koboSpan" id="kobo.47.1">Cluster</span></kbd><span class="koboSpan" id="kobo.48.1"> (non-namespaced). </span><span class="koboSpan" id="kobo.48.2">After Kubernetes 1.13, we can add a validation section to validate the custom objects via the OpenAPI v3 schema (</span><a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject"><span class="koboSpan" id="kobo.49.1">https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject</span></a><span class="koboSpan" id="kobo.50.1">). </span><span class="koboSpan" id="kobo.50.2">We can define the required fields, as well as the spec and validation condition for each field. </span><span class="koboSpan" id="kobo.50.3">In the preceding example, we created a custom object named </span><kbd><span class="koboSpan" id="kobo.51.1">books.devops.kubernetes.com</span></kbd><span class="koboSpan" id="kobo.52.1"> that has three properties: </span><kbd><span class="koboSpan" id="kobo.53.1">name</span></kbd><span class="koboSpan" id="kobo.54.1">, </span><kbd><span class="koboSpan" id="kobo.55.1">edition</span></kbd><span class="koboSpan" id="kobo.56.1">, and </span><kbd><span class="koboSpan" id="kobo.57.1">chapter</span></kbd><span class="koboSpan" id="kobo.58.1">. </span><kbd><span class="koboSpan" id="kobo.59.1">name</span></kbd><span class="koboSpan" id="kobo.60.1"> and </span><kbd><span class="koboSpan" id="kobo.61.1">edition</span></kbd><span class="koboSpan" id="kobo.62.1"> are required during object creation. </span><span class="koboSpan" id="kobo.62.2">Let's create the CRD via the </span><kbd><span class="koboSpan" id="kobo.63.1">kubectl</span></kbd><span class="koboSpan" id="kobo.64.1"> command. </span><span class="koboSpan" id="kobo.64.2">We can also list all the CRDs via the </span><kbd><span class="koboSpan" id="kobo.65.1">kubectl get crd</span></kbd><span class="koboSpan" id="kobo.66.1"> command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.67.1"># kubectl create -f chapter5/5-4_crd/5-4-1_crd.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.68.1">customresourcedefinition.apiextensions.k8s.io/books.devops.kubernetes.com created</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.69.1"># kubectl get crd</span></strong><br/><strong><span class="koboSpan" id="kobo.70.1">NAME CREATED AT</span></strong><br/><strong><span class="koboSpan" id="kobo.71.1">backendconfigs.cloud.google.com 2018-12-22T20:48:00Z</span></strong><br/><strong><span class="koboSpan" id="kobo.72.1">books.devops.kubernetes.com 2018-12-28T16:14:34Z</span></strong><br/><strong><span class="koboSpan" id="kobo.73.1">scalingpolicies.scalingpolicy.kope.io 2018-12-22T20:48:30Z</span></strong></pre>
<p><span class="koboSpan" id="kobo.74.1">Next, we'll create an object accordingly. </span><span class="koboSpan" id="kobo.74.2">In </span><kbd><span class="koboSpan" id="kobo.75.1">spec</span></kbd><span class="koboSpan" id="kobo.76.1">, </span><kbd><span class="koboSpan" id="kobo.77.1">name</span></kbd><span class="koboSpan" id="kobo.78.1">, and </span><kbd><span class="koboSpan" id="kobo.79.1">edition</span></kbd><span class="koboSpan" id="kobo.80.1"> are required. </span><span class="koboSpan" id="kobo.80.2">The </span><kbd><span class="koboSpan" id="kobo.81.1">apiVersion</span></kbd><span class="koboSpan" id="kobo.82.1"> will be the </span><kbd><span class="koboSpan" id="kobo.83.1">&lt;group&gt;/&lt;version&gt;</span></kbd><span class="koboSpan" id="kobo.84.1"> we defined in the preceding CRD configuration:</span></p>
<pre><strong><span class="koboSpan" id="kobo.85.1"># cat chapter5/5-4_crd/5-4-2_objectcreation.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.86.1">apiVersion: devops.kubernetes.com/v1alpha1</span></strong><br/><strong><span class="koboSpan" id="kobo.87.1">kind: Book</span></strong><br/><strong><span class="koboSpan" id="kobo.88.1">metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.89.1">  name: book-object</span></strong><br/><strong><span class="koboSpan" id="kobo.90.1">spec:</span></strong><br/><strong><span class="koboSpan" id="kobo.91.1">  name: DevOps-with-Kubernetes</span></strong><br/><strong><span class="koboSpan" id="kobo.92.1">  edition: second</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.93.1"># kubectl create -f chapter5/5-4_crd/5-4-2_objectcreation.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.94.1">book.devops.kubernetes.com/book-object created</span></strong></pre>
<p><span><span class="koboSpan" id="kobo.95.1">If we set the </span><kbd><span class="koboSpan" id="kobo.96.1">edition</span></kbd><span class="koboSpan" id="kobo.97.1"> to </span><kbd><span class="koboSpan" id="kobo.98.1">second</span></kbd><span class="koboSpan" id="kobo.99.1">, an error will be thrown, as follows:</span></span></p>
<pre><span class="koboSpan" id="kobo.100.1">spec.edition in body must be of type string: "integer"</span><br/><span class="koboSpan" id="kobo.101.1">spec.edition in body should be greater than or equal to 10</span></pre>
<p><span class="koboSpan" id="kobo.102.1">Now, we should be able to get and describe it, just like a normal API object:</span></p>
<pre><strong><span class="koboSpan" id="kobo.103.1"># kubectl get books</span></strong><br/><strong><span class="koboSpan" id="kobo.104.1">NAME AGE</span></strong><br/><strong><span class="koboSpan" id="kobo.105.1">book-object 3s</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.106.1"># kubectl describe books book-object</span></strong><br/><strong><span class="koboSpan" id="kobo.107.1">Name: book-object</span></strong><br/><strong><span class="koboSpan" id="kobo.108.1">Namespace: default</span></strong><br/><strong><span class="koboSpan" id="kobo.109.1">Labels: &lt;none&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.110.1">Annotations: &lt;none&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.111.1">API Version: devops.kubernetes.com/v1alpha1</span></strong><br/><strong><span class="koboSpan" id="kobo.112.1">Kind: Book</span></strong><br/><strong><span class="koboSpan" id="kobo.113.1">Metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.114.1"> /apis/devops.kubernetes.com/v1alpha1/namespaces/default/books/book-object</span></strong><br/><strong><span class="koboSpan" id="kobo.115.1"> UID: c6912ab5-0abd-11e9-be06-42010a8a0078</span></strong><br/><strong><span class="koboSpan" id="kobo.116.1">Spec:</span></strong><br/><strong><span class="koboSpan" id="kobo.117.1"> Edition: second</span></strong><br/><strong><span class="koboSpan" id="kobo.118.1"> Name: DevOps-with-Kubernetes</span></strong><br/><strong><span class="koboSpan" id="kobo.119.1">Events: &lt;none&gt;</span></strong></pre>
<p><span class="koboSpan" id="kobo.120.1">After registering a CRD, a custom </span><span><span class="koboSpan" id="kobo.121.1">controller</span></span><span><span class="koboSpan" id="kobo.122.1"> </span></span><span class="koboSpan" id="kobo.123.1">might be needed to handle custom object operations. </span><span class="koboSpan" id="kobo.123.2">The custom controller requires additional programming effort. </span><span class="koboSpan" id="kobo.123.3">There are also multiple tools available in the community that can help us create a skeleton controller, such as the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.124.1">Controller: </span><a href="https://github.com/kubernetes/sample-controller"><span class="koboSpan" id="kobo.125.1">https://github.com/kubernetes/sample-controller</span></a></li>
<li><span class="koboSpan" id="kobo.126.1">Kubebuilder: </span><a href="https://github.com/kubernetes-sigs/kubebuilder"><span class="koboSpan" id="kobo.127.1">https://github.com/kubernetes-sigs/kubebuilder</span></a></li>
<li><span class="koboSpan" id="kobo.128.1">Operator: </span><a href="https://coreos.com/operators/"><span class="koboSpan" id="kobo.129.1">https://coreos.com/operators/</span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.130.1">With the sample controller (provided by Kubernetes), a set of </span><kbd><span class="koboSpan" id="kobo.131.1">ResourceEventHandlerFuncs</span></kbd> <span><span class="koboSpan" id="kobo.132.1">will be added into</span></span><span class="koboSpan" id="kobo.133.1"> </span><span><kbd><span class="koboSpan" id="kobo.134.1">EventHandler</span></kbd><span class="koboSpan" id="kobo.135.1"> for handling object life cycle events, such as </span><kbd><span class="koboSpan" id="kobo.136.1">AddFunc</span></kbd><span class="koboSpan" id="kobo.137.1"> for </span><kbd><span class="koboSpan" id="kobo.138.1">UpdateFunc</span></kbd><span class="koboSpan" id="kobo.139.1"> and </span><kbd><span class="koboSpan" id="kobo.140.1">DeleteFunc</span></kbd><span class="koboSpan" id="kobo.141.1">. </span></span></p>
<p><span class="koboSpan" id="kobo.142.1">Both </span><strong><span class="koboSpan" id="kobo.143.1">Kubebuilder</span></strong><span class="koboSpan" id="kobo.144.1"> and </span><span><strong><span class="koboSpan" id="kobo.145.1">Operator</span></strong></span><span><span class="koboSpan" id="kobo.146.1"> </span></span><span class="koboSpan" id="kobo.147.1">can simplify the preceding steps. </span><span class="koboSpan" id="kobo.147.2">Kubebuilder provides support for building APIs via CRDs, controllers, and admission webhooks. </span><span><span class="koboSpan" id="kobo.148.1">Operator, which was </span></span><span><span class="koboSpan" id="kobo.149.1">introduced by CoreOS, is an application-specific controller that's implemented with CRD. </span></span><span><span class="koboSpan" id="kobo.150.1">There are existing operators being implemented by the community, and they can be found at </span></span><a href="https://github.com/operator-framework/awesome-operators"><span class="koboSpan" id="kobo.151.1">https://github.com/operator-framework/awesome-operators</span></a><span class="koboSpan" id="kobo.152.1">. </span><span class="koboSpan" id="kobo.152.2">We'll introduce how to leverage the operator SDK in the Operator framework to build a simple controller with the same book CRD.</span></p>
<p><span class="koboSpan" id="kobo.153.1">First, we'll have to install the operator SDK (</span><a href="https://github.com/operator-framework/operator-sdk"><span class="koboSpan" id="kobo.154.1">https://github.com/operator-framework/operator-sdk</span></a><span class="koboSpan" id="kobo.155.1">). </span><span class="koboSpan" id="kobo.155.2">We are using v.0.3.0 in the following example:</span></p>
<pre><strong><span class="koboSpan" id="kobo.156.1">// Check the prerequisites at https://github.com/operator-framework/operator-sdk#prerequisites</span></strong><br/><strong><span class="koboSpan" id="kobo.157.1"># mkdir -p </span><span class="pl-smi"><span class="koboSpan" id="kobo.158.1">$GOPATH</span></span><span class="koboSpan" id="kobo.159.1">/src/github.com/operator-framework
# </span><span class="pl-c1"><span class="koboSpan" id="kobo.160.1">cd</span></span> <span class="pl-smi"><span class="koboSpan" id="kobo.161.1">$GOPATH</span></span><span class="koboSpan" id="kobo.162.1">/src/github.com/operator-framework
# git clone https://github.com/operator-framework/operator-sdk
# </span><span class="pl-c1"><span class="koboSpan" id="kobo.163.1">cd</span></span><span class="koboSpan" id="kobo.164.1"> operator-sdk
# git checkout master
# make dep
# make install</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.165.1">// check version</span></strong><br/><strong><span class="koboSpan" id="kobo.166.1"># operator-sdk --version</span></strong><br/><strong><span class="koboSpan" id="kobo.167.1"># operator-sdk version v0.3.0+git</span></strong></pre>
<p><span class="koboSpan" id="kobo.168.1">Let's create a new operator named </span><kbd><span class="koboSpan" id="kobo.169.1">devops-operator</span></kbd><span class="koboSpan" id="kobo.170.1"> via the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.171.1">// operator-sdk new &lt;operator_name&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.172.1"># operator-sdk new devops-operator</span></strong><br/><strong><span class="koboSpan" id="kobo.173.1">INFO[0076] Run git init done</span></strong><br/><strong><span class="koboSpan" id="kobo.174.1">INFO[0076] Project creation complete.</span></strong></pre>
<p><span class="koboSpan" id="kobo.175.1">After the operator is initialized, we can start adding components to it. </span><span class="koboSpan" id="kobo.175.2">Let's add </span><kbd><span class="koboSpan" id="kobo.176.1">api</span></kbd><span class="koboSpan" id="kobo.177.1"> to create an API object and </span><kbd><span class="koboSpan" id="kobo.178.1">controller</span></kbd><span class="koboSpan" id="kobo.179.1"> to handle object operations:</span></p>
<pre><strong><span class="koboSpan" id="kobo.180.1">// operator-sdk add api --api-version &lt;group&gt;/&lt;version&gt; --kind &lt;kind&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.181.1"># operator-sdk add api --api-version devops.kubernetes.com/v1alpha1 --kind Book</span></strong><br/><strong><span class="koboSpan" id="kobo.182.1">INFO[0000] Generating api version devops.kubernetes.com/v1alpha1 for kind Book.</span></strong><br/><strong><span class="koboSpan" id="kobo.183.1">INFO[0000] Create pkg/apis/devops/v1alpha1/book_types.go</span></strong><br/><strong><span class="koboSpan" id="kobo.184.1">INFO[0000] Create pkg/apis/addtoscheme_devops_v1alpha1.go</span></strong><br/><strong><span class="koboSpan" id="kobo.185.1">INFO[0000] Create pkg/apis/devops/v1alpha1/register.go</span></strong><br/><strong><span class="koboSpan" id="kobo.186.1">INFO[0000] Create pkg/apis/devops/v1alpha1/doc.go</span></strong><br/><strong><span class="koboSpan" id="kobo.187.1">INFO[0000] Create deploy/crds/devops_v1alpha1_book_cr.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.188.1">INFO[0000] Create deploy/crds/devops_v1alpha1_book_crd.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.189.1">INFO[0008] Running code-generation for Custom Resource group versions: [devops:[v1alpha1], ]</span></strong><br/><strong><span class="koboSpan" id="kobo.190.1">INFO[0009] Code-generation complete.</span></strong><br/><strong><span class="koboSpan" id="kobo.191.1">INFO[0009] Api generation complete.</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.192.1"># operator-sdk add controller --api-version devops.kubernetes.com/v1alpha1 --kind Book</span></strong><br/><strong><span class="koboSpan" id="kobo.193.1">INFO[0000] Generating controller version devops.kubernetes.com/v1alpha1 for kind Book.</span></strong><br/><strong><span class="koboSpan" id="kobo.194.1">INFO[0000] Create pkg/controller/book/book_controller.go</span></strong><br/><strong><span class="koboSpan" id="kobo.195.1">INFO[0000] Create pkg/controller/add_book.go</span></strong><br/><strong><span class="koboSpan" id="kobo.196.1">INFO[0000] Controller generation complete.</span></strong></pre>
<p><span class="koboSpan" id="kobo.197.1">There are multiple files we need to modify. </span><span class="koboSpan" id="kobo.197.2">The first one is API spec. </span><span class="koboSpan" id="kobo.197.3">In the previous CRD example, we added three custom properties in the </span><kbd><span class="koboSpan" id="kobo.198.1">book</span></kbd><span class="koboSpan" id="kobo.199.1"> resource: </span><kbd><span class="koboSpan" id="kobo.200.1">name</span></kbd><span class="koboSpan" id="kobo.201.1">, </span><kbd><span class="koboSpan" id="kobo.202.1">edition</span></kbd><span class="koboSpan" id="kobo.203.1">, and </span><kbd><span class="koboSpan" id="kobo.204.1">chapter</span></kbd><span class="koboSpan" id="kobo.205.1">. </span><span class="koboSpan" id="kobo.205.2">We'll need to add that into spec here, too. </span><span class="koboSpan" id="kobo.205.3">This can be found under </span><kbd><span class="koboSpan" id="kobo.206.1">pkg/apis/devops/v1alpha1/book_types.go</span></kbd><span class="koboSpan" id="kobo.207.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.208.1">// in pkg/apis/devops/v1alpha1/book_types.go</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.209.1">type BookSpec struct {</span></strong><br/>  <strong><span class="koboSpan" id="kobo.210.1">// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster</span></strong><br/><strong><span class="koboSpan" id="kobo.211.1">  // Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file</span></strong><br/>  <strong><span class="koboSpan" id="kobo.212.1">Name string `json:"name"`</span></strong><br/><strong><span class="koboSpan" id="kobo.213.1">  Edition string `json:"edition"`</span></strong><br/><strong><span class="koboSpan" id="kobo.214.1">  Chapter int32 `json:"chapter"`</span></strong><br/><strong><span class="koboSpan" id="kobo.215.1">}</span></strong></pre>
<p><span class="koboSpan" id="kobo.216.1">Run </span><span><kbd><span class="koboSpan" id="kobo.217.1">operator-sdk generate k8s</span></kbd><span class="koboSpan" id="kobo.218.1"> after modifying the file, as shown in the preceding code. </span><span class="koboSpan" id="kobo.218.2">Next, we will add some custom logic to the controller logic. </span><span class="koboSpan" id="kobo.218.3">This is located in the </span><kbd><span class="koboSpan" id="kobo.219.1">Reconcile</span></kbd><span class="koboSpan" id="kobo.220.1"> function in </span><kbd><span class="koboSpan" id="kobo.221.1">pkg/controller/book/book_controller.go</span></kbd><span class="koboSpan" id="kobo.222.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">In the existing example that was created by the framework, the controller will receive a </span><kbd><span class="koboSpan" id="kobo.224.1">podSpec</span></kbd><span class="koboSpan" id="kobo.225.1">. </span><span class="koboSpan" id="kobo.225.2">This is exactly what we need, and we'll just get the </span><kbd><span class="koboSpan" id="kobo.226.1">name</span></kbd><span class="koboSpan" id="kobo.227.1"> and </span><kbd><span class="koboSpan" id="kobo.228.1">edition</span></kbd><span class="koboSpan" id="kobo.229.1"> from the </span><kbd><span class="koboSpan" id="kobo.230.1">Spec</span></kbd><span class="koboSpan" id="kobo.231.1"> and print it out in </span><kbd><span class="koboSpan" id="kobo.232.1">busybox</span></kbd> <kbd><span class="koboSpan" id="kobo.233.1">stdout</span></kbd><span class="koboSpan" id="kobo.234.1">:</span></p>
<pre><span class="koboSpan" id="kobo.235.1">// in pkg/controller/book/book_controller.go</span><br/><span class="koboSpan" id="kobo.236.1">func newPodForCR(cr *devopsv1alpha1.Book) *corev1.Pod {</span><br/><span class="koboSpan" id="kobo.237.1">  labels := map[string]string{</span><br/><span class="koboSpan" id="kobo.238.1">    "app": cr.Name,</span><br/><span class="koboSpan" id="kobo.239.1">  }</span><br/>  <strong><span class="koboSpan" id="kobo.240.1">name := cr.Spec.Name</span></strong><br/><strong><span class="koboSpan" id="kobo.241.1">  edition := cr.Spec.Edition</span></strong><br/><span class="koboSpan" id="kobo.242.1">  return &amp;corev1.Pod{</span><br/><span class="koboSpan" id="kobo.243.1">    ObjectMeta: metav1.ObjectMeta{</span><br/><span class="koboSpan" id="kobo.244.1">      Name: cr.Name + "-pod",</span><br/><span class="koboSpan" id="kobo.245.1">      Namespace: cr.Namespace,</span><br/><span class="koboSpan" id="kobo.246.1">      Labels: labels,</span><br/><span class="koboSpan" id="kobo.247.1">    },</span><br/><span class="koboSpan" id="kobo.248.1">    Spec: corev1.PodSpec{</span><br/><span class="koboSpan" id="kobo.249.1">      Containers: []corev1.Container{</span><br/><span class="koboSpan" id="kobo.250.1">        {</span><br/><span class="koboSpan" id="kobo.251.1">          Name: "busybox",</span><br/><span class="koboSpan" id="kobo.252.1">          Image: "busybox",</span><br/>         <strong><span class="koboSpan" id="kobo.253.1"> Command: []string{"echo", "Please support", name, edition, "Edition :-) "},</span></strong><br/><span class="koboSpan" id="kobo.254.1">          Stdin: true,</span><br/><span class="koboSpan" id="kobo.255.1">        },</span><br/><span class="koboSpan" id="kobo.256.1">      },</span><br/><span class="koboSpan" id="kobo.257.1">    },</span><br/><span class="koboSpan" id="kobo.258.1">  }</span><br/><span class="koboSpan" id="kobo.259.1">}</span></pre>
<p><span class="koboSpan" id="kobo.260.1">Then, we can run </span><kbd><span class="koboSpan" id="kobo.261.1">operator-sdk build devopswithkubernetes/sample-operator</span></kbd><span class="koboSpan" id="kobo.262.1"> to build the docker image and push it to a registry. </span><span class="koboSpan" id="kobo.262.2">Here, we'll just push it to our public docker hub, </span><kbd><span class="koboSpan" id="kobo.263.1">docker push devopswithkubernetes/sample-operator</span></kbd><span class="koboSpan" id="kobo.264.1">.</span></p>
<p><span class="koboSpan" id="kobo.265.1">The operator is done! After that, we can start looking into how to deploy it. </span><span class="koboSpan" id="kobo.265.2">The deployment scripts are automatically created in the </span><kbd><span class="koboSpan" id="kobo.266.1">deploy</span></kbd><span class="koboSpan" id="kobo.267.1"> folder. </span><span class="koboSpan" id="kobo.267.2">The file we need to change is </span><kbd><span class="koboSpan" id="kobo.268.1">operator.yaml</span></kbd><span class="koboSpan" id="kobo.269.1">, which specifies the operator container image. </span><span class="koboSpan" id="kobo.269.2">Find the </span><kbd><span class="koboSpan" id="kobo.270.1">image: REPLACE_IMAGE</span></kbd><span class="koboSpan" id="kobo.271.1"> line in </span><kbd><span class="koboSpan" id="kobo.272.1">podSpec</span></kbd><span class="koboSpan" id="kobo.273.1"> and update that so that it points into your registry (here, we'll point it to </span><kbd><span class="koboSpan" id="kobo.274.1">devopswithkubernetes/sample-operator</span></kbd><span class="koboSpan" id="kobo.275.1">). </span><span class="koboSpan" id="kobo.275.2">Now, it's good to deploy:</span></p>
<pre><strong><span class="koboSpan" id="kobo.276.1"># kubectl create -f deploy/service_account.yaml
# kubectl create -f deploy/role.yaml
# kubectl create -f deploy/role_binding.yaml
# kubectl create -f deploy/crds/app_v1alpha1_appservice_crd.yaml
# kubectl create -f deploy/operator.yaml</span></strong></pre>
<p><span class="koboSpan" id="kobo.277.1">Now, you should be able to see an operator pod when listing the pods:</span></p>
<pre><strong><span class="koboSpan" id="kobo.278.1"># kubectl get po</span></strong><br/><strong><span class="koboSpan" id="kobo.279.1">NAME READY STATUS RESTARTS AGE</span></strong><br/><strong><span class="koboSpan" id="kobo.280.1">devops-operator-58476dbcdd-s5m5v 1/1 Running 0 41m</span></strong></pre>
<p><span class="koboSpan" id="kobo.281.1">Now, let's create a </span><kbd><span class="koboSpan" id="kobo.282.1">Book</span></kbd><span class="koboSpan" id="kobo.283.1"> resource. </span><span class="koboSpan" id="kobo.283.2">You could modify </span><kbd><span class="koboSpan" id="kobo.284.1">deploy/crds/devops_v1alpha1_book_cr.yaml</span></kbd><span class="koboSpan" id="kobo.285.1"> in the current folder or reuse </span><kbd><span class="koboSpan" id="kobo.286.1">5-4_crd/5-4-2_objectcreation.yaml</span></kbd><span class="koboSpan" id="kobo.287.1"> from our repo:</span></p>
<pre><strong><span class="koboSpan" id="kobo.288.1"># kubectl create -f deploy/crds/devops_v1alpha1_book_cr.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.289.1">book.devops.kubernetes.com/book-object created</span></strong></pre>
<p><span class="koboSpan" id="kobo.290.1">Then, we should be able to see that another pod was created by the CRD, and we can also check its logs:</span></p>
<pre><strong><span class="koboSpan" id="kobo.291.1"># kubectl get po</span></strong><br/><strong><span class="koboSpan" id="kobo.292.1">NAME READY STATUS RESTARTS AGE</span></strong><br/><strong><span class="koboSpan" id="kobo.293.1">book-object-pod 0/1 Completed 0 2s</span></strong><br/><strong><span class="koboSpan" id="kobo.294.1">devops-operator-58476dbcdd-s5m5v 1/1 Running 0 45m</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.295.1"># kubectl logs book-object-pod</span></strong><br/><strong><span class="koboSpan" id="kobo.296.1">Please support DevOps-with-Kubernetes second Edition :-)</span></strong></pre>
<p><span class="koboSpan" id="kobo.297.1">Hurray! </span><span class="koboSpan" id="kobo.297.2">Everything looks fine. </span><span class="koboSpan" id="kobo.297.3">Here, we have demonstrated a very simple example. </span><span class="koboSpan" id="kobo.297.4">Of course, we could leverage this concept and evolve more sophisticated logic and handlers.</span></p>
<div class="packt_infobox"><span class="packt_screen"><span class="koboSpan" id="kobo.298.1">Application CRD</span></span><span class="koboSpan" id="kobo.299.1">:</span><br/><span class="koboSpan" id="kobo.300.1">
A containerized application might contain multiple Kubernetes resources, such as deployments, services, </span><kbd><span class="koboSpan" id="kobo.301.1">ConfigMaps</span></kbd><span class="koboSpan" id="kobo.302.1">, secrets, as well as custom CRDs. </span><span class="koboSpan" id="kobo.302.2">An application CRD has been implemented at </span><a href="https://github.com/kubernetes-sigs/application"><span class="koboSpan" id="kobo.303.1">https://github.com/kubernetes-sigs/application</span></a><span class="koboSpan" id="kobo.304.1">, providing a bridge to make application metadata describable. </span><span class="koboSpan" id="kobo.304.2">It also has application level health checks so that users don't need to list all the resources after deployment and check whether the application has been deployed properly. </span><span class="koboSpan" id="kobo.304.3">Instead, they list the application CRD and check its status. </span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, we learned about what </span><kbd><span class="koboSpan" id="kobo.3.1">namespace</span></kbd><span class="koboSpan" id="kobo.4.1"> and </span><kbd><span class="koboSpan" id="kobo.5.1">context</span></kbd><span class="koboSpan" id="kobo.6.1"> are, </span><span><span class="koboSpan" id="kobo.7.1">including how they work, and a how to switch between a physical cluster and virtual cluster by setting the context. </span><span class="koboSpan" id="kobo.7.2">We then learned about an important object—service account, which provides the ability to identify processes that are running within a pod. </span><span class="koboSpan" id="kobo.7.3">Then, we familiarized ourselves with how to control access flow in Kubernetes. </span><span class="koboSpan" id="kobo.7.4">We learned what the difference is between authentication and authorization, and how these work in Kubernetes. </span><span class="koboSpan" id="kobo.7.5">We also learned how to leverage RBAC to have fine-grained permission for users. </span><span class="koboSpan" id="kobo.7.6">In addition, we looked at a couple of admission controller plugins and dynamic admission controls, which are the last goalkeepers in the access control flow. </span><span class="koboSpan" id="kobo.7.7">Finally, we learned about what the CRD is and implemented it and its controller via the operator SDK (</span></span><a href="https://github.com/operator-framework/operator-sdk"><span class="koboSpan" id="kobo.8.1">https://github.com/operator-framework/operator-sdk</span></a><span><span class="koboSpan" id="kobo.9.1">) in the operator framework.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">In </span><a href="fc67e008-b601-45a6-8297-d2fa28360b1f.xhtml"><span class="koboSpan" id="kobo.11.1">Chapter 6</span></a><span class="koboSpan" id="kobo.12.1">, </span><em><span class="koboSpan" id="kobo.13.1">Kubernetes Network</span></em><span class="koboSpan" id="kobo.14.1">, we'll move on and learn more about cluster networking.</span></p>


            </article>

            
        </section>
    </body></html>