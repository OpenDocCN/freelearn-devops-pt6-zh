<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer327">
    <h1 class="chapterNumber">16</h1>
    <h1 class="chapterTitle" id="_idParaDest-532">Launching a Kubernetes Cluster on Amazon Web Services with Amazon Elastic Kubernetes Service</h1>
    <p class="normal">Let’s build on what we learned in the previous chapter. We launched a Kubernetes cluster in a public cloud, taking our first steps to run Kubernetes on one of the “big three” public cloud providers.</p>
    <p class="normal">Now that we know what the <strong class="keyWord">Google Cloud Platform</strong> (<strong class="keyWord">GCP</strong>) Kubernetes offering looks like, we will move on to <strong class="keyWord">Amazon Elastic Kubernetes Service</strong> (<strong class="keyWord">EKS</strong>) by <strong class="keyWord">Amazon Web Services</strong> (<strong class="keyWord">AWS</strong>).</p>
    <p class="normal">In this chapter, you will learn how to set up an AWS account and install the supporting toolsets on macOS, Windows, and Linux, before finally launching and interacting with an Amazon EKS cluster.</p>
    <p class="normal">We will be covering the following topics in this chapter:</p>
    <ul>
      <li class="bulletList">What are Amazon Web Services and Amazon Elastic Kubernetes Service?</li>
      <li class="bulletList">Preparing your local environment</li>
      <li class="bulletList">Launching your Amazon Elastic Kubernetes Service cluster</li>
      <li class="bulletList">Deploying a workload and interacting with your cluster</li>
      <li class="bulletList">Deleting your Amazon Elastic Kubernetes Service cluster</li>
    </ul>
    <h1 class="heading-1" id="_idParaDest-533">Technical requirements</h1>
    <p class="normal">If you plan to follow along with this chapter, you will need an AWS account with a valid payment attached.</p>
    <div class="note">
      <p class="normal">Following the instructions in this chapter will incur a cost, and you must terminate any resources you launch once you have finished using them. All prices quoted in this chapter are correct as of when this book was written, and we recommend that you review the current costs before launching any resources.</p>
    </div>
    <h1 class="heading-1" id="_idParaDest-534">What are Amazon Web Services and Amazon Elastic Kubernetes Service?</h1>
    <p class="normal">You may have already heard of Amazon Web Services, or AWS, as we will refer to it. It was one of the first public cloud providers and has the largest market share at the time of writing (June 2024): 31%, with Microsoft Azure second at 25% and GCP third at 11%.</p>
    <h2 class="heading-2" id="_idParaDest-535">Amazon Web Services</h2>
    <p class="normal">As you may have already <a id="_idIndexMarker1391"/>guessed, Amazon owns and operates AWS. What began as Amazon experimenting with cloud services in 2000, by developing and deploying <strong class="keyWord">application programming interfaces</strong> (<strong class="keyWord">APIs</strong>) for its retail partners, has since evolved into AWS, a global leader in cloud computing, powering businesses of all sizes across various industries.</p>
    <p class="normal">Based on this work, Amazon realized that they needed to build a better and more standardized infrastructure platform not only to host the services they had been developing but also to ensure they could quickly scale as more of their retail outlets consumed the software services and grew at an expedient rate.</p>
    <p class="normal">Chris Pinkham and Benjamin Black wrote a white paper in 2003 that was approved by Jeff Bezos in 2004, which described an infrastructure platform where compute and storage resources can all be deployed programmatically.</p>
    <p class="normal">The first public acknowledgment of AWS’s existence was made in late 2004; however, the term was used to describe a collection of tools and APIs that would allow third parties to interact with Amazon’s retail product catalog, rather than what we know today.</p>
    <p class="normal">It wasn’t until 2006 that a rebranded <a id="_idIndexMarker1392"/>AWS was launched, starting in March <a id="_idIndexMarker1393"/>with <strong class="keyWord">Simple Storage Service</strong> (<strong class="keyWord">S3</strong>). This service allowed developers to write and serve individual files using a web API, rather than writing and reading from a traditional local or remote filesystem.</p>
    <p class="normal">The next service to<a id="_idIndexMarker1394"/> launch, <strong class="keyWord">Amazon Simple Queue Service</strong> (<strong class="keyWord">SQS</strong>), had formed part of the original AWS collection of tools. This was a distributed message system that, again, could be controlled and consumed by developers using an API.</p>
    <p class="normal">The final service, launched in 2006, was a beta of <strong class="keyWord">Amazon Elastic Compute Cloud</strong> (<strong class="keyWord">Amazon EC2</strong>), limited to <a id="_idIndexMarker1395"/>existing AWS customers. Again, you could use the APIs developed by Amazon to launch Amazon EC2 resources.</p>
    <p class="normal">This was the final piece of the puzzle for Amazon. They now had the foundations of a public cloud platform on which they could not only use their own retail platform but also sell space to other companies and the public, such as you and me.</p>
    <p class="normal">Let’s fast-forward from 2006, when there were 3 services, to the time of writing, mid-2024, where there are over 200 services available, all of which run in over 125 physical data centers across 39 Regions, which comprise over 38 million square feet in total.</p>
    <p class="normal">All 200+ services adhere to the core principles laid out in the 2003 white paper. Each service is software-defined, meaning that developers must make a simple API request to launch, configure, and, in some cases, consume the service before finally making another API request to terminate it.</p>
    <div class="note">
      <p class="normal">You may have already noticed this from the services that have already been mentioned up to this point, but services running in AWS are prefixed with either Amazon or AWS – why is this? Well, services that start with Amazon are standalone services, unlike those prefixed with AWS, which are services designed to be used alongside the services that are prefixed with Amazon.</p>
    </div>
    <p class="normal">Long gone are the days of having to order a service, have someone build and deploy it, and then hand it over to you; this reduces deployment times to seconds from what could sometimes take weeks or months.</p>
    <p class="normal">Rather than discussing all 200+ services, which would be an entire series of books, we should discuss the service we will examine in this chapter.</p>
    <h2 class="heading-2" id="_idParaDest-536">Amazon Elastic Kubernetes Service</h2>
    <p class="normal">While AWS was the first of<a id="_idIndexMarker1396"/> the major public cloud providers, it was one of the last to launch a standalone Kubernetes service. Amazon EKS was first announced in late 2017. It became generally available in the United States (US), starting with the East (N. Virginia) and West (Oregon) Regions in June 2018.</p>
    <p class="normal">The service is built to work with and take advantage of other AWS services and features, such as the following:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">AWS Identity and Access Management</strong> (<strong class="keyWord">IAM</strong>) allows you to control and manage<a id="_idIndexMarker1397"/> end-user and programmatic access to other AWS services.</li>
      <li class="bulletList"><strong class="keyWord">Amazon Route 53</strong> is Amazon’s <strong class="keyWord">Domain Name System</strong> (<strong class="keyWord">DNS</strong>) service. Amazon EKS can use <a id="_idIndexMarker1398"/>it as a source of DNS for clusters, meaning service <a id="_idIndexMarker1399"/>discovery and routing can easily be managed within your cluster.</li>
      <li class="bulletList"><strong class="keyWord">Amazon Elastic Block Store</strong> (<strong class="keyWord">EBS</strong>): If you need persistent block storage for containers running within your Amazon EKS cluster, <strong class="keyWord">Amazon Elastic Block Store</strong> (<strong class="keyWord">EBS</strong>) provides this storage, just as it does for your EC2 compute resources</li>
      <li class="bulletList"><strong class="keyWord">EC2 Auto Scaling</strong>: If your<a id="_idIndexMarker1400"/> cluster needs to scale, the same technology is employed to scale your EC2 instances.</li>
      <li class="bulletList"><strong class="keyWord">Multi-Availability Zones</strong> (<strong class="keyWord">AZs</strong>) can <a id="_idIndexMarker1401"/>be a useful feature. The Amazon EKS management layer and cluster nodes can be configured to be spread across multiple AZs within a given Region to bring <strong class="keyWord">High Availability</strong> (<strong class="keyWord">HA</strong>) and<a id="_idIndexMarker1402"/> resilience to your deployment.</li>
    </ul>
    <p class="normal">Before we launch our Amazon EKS cluster, we will need to download, install, and configure a few tools.</p>
    <h1 class="heading-1" id="_idParaDest-537">Preparing your local environment</h1>
    <p class="normal">We need to install two command-line tools, but before we do, we should quickly discuss the steps to sign up for a new AWS account. If you already have an AWS account, skip this task and move straight to the <em class="italic">Installing the AWS command-line interface</em> section.</p>
    <h2 class="heading-2" id="_idParaDest-538">Signing up for an AWS account</h2>
    <p class="normal">Signing up for an AWS<a id="_idIndexMarker1403"/> account is a straightforward process, as detailed here:</p>
    <ol>
      <li class="numberedList" value="1">Go to <a href="https://aws.amazon.com/"><span class="url">https://aws.amazon.com/</span></a> and click the <strong class="screenText">Create an AWS account </strong>button at the top right of the page.</li>
    </ol>
    <div class="note-one">
      <p class="normal">Amazon offers a free tier for new users. It is limited to certain services and instance sizes and lasts 12 months. For information on the AWS Free Tier, see <a href="https://aws.amazon.com/free/"><span class="url">https://aws.amazon.com/free/</span></a>.</p>
    </div>
    <ol>
      <li class="numberedList" value="2">Fill out the initial form that asks for an email address. This will be used for account recovery and some basic administrative functions. Also, provide your chosen AWS account name. Don’t worry if you change your mind; you can change this in your account settings after you sign up. You will then need to verify your email address. Once the email address has been verified, you will be asked to set the password for your “root” account.</li>
      <li class="numberedList">Once you enter your password, click <strong class="screenText">Continue</strong> and follow the onscreen instructions. There are five steps; these will involve you confirming your payment details and identity via an automated phone call.</li>
    </ol>
    <p class="normal">Once you have created and enabled your account, you will be notified when you can start using AWS services – most of the time, this will be straight away, but it can take up to 48 hours.</p>
    <p class="normal">Now, we need to install the command-line tools that we will be using to launch our Amazon EKS cluster.</p>
    <h2 class="heading-2" id="_idParaDest-539">Installing the AWS command-line interface</h2>
    <p class="normal">Next<a id="_idIndexMarker1404"/> on our list of tasks is to install the AWS <strong class="keyWord">Command-Line Interface</strong> (<strong class="keyWord">CLI</strong>). As we did in the previous chapter, <em class="chapterRef">Chapter 15</em>, <em class="italic">Kubernetes Clusters on Google Kubernetes Engine</em>, we will target Windows, Linux, and macOS, which we will look at first.</p>
    <h3 class="heading-3" id="_idParaDest-540">Installing on macOS</h3>
    <p class="normal">Installing the AWS CLI<a id="_idIndexMarker1405"/> on<a id="_idIndexMarker1406"/> macOS using Homebrew is as simple as running the following command:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>brew install awscli
</code></pre>
    <p class="normal">Once it’s installed, run the following command, which should give you the version number:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>aws –version
</code></pre>
    <p class="normal">This will output the version of the AWS CLI, along with some of the support services it needs, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img alt="A screenshot of a computer&#10;&#10;Description automatically generated" src="image/B22019_16_01.png"/></figure>
    <p class="packt_figref">Figure 16.1: Checking the version of the AWS CLI</p>
    <p class="normal">Once installed, you can move on to the AWS CLI configuration section.</p>
    <h3 class="heading-3" id="_idParaDest-541">Installing on Linux</h3>
    <p class="normal">While packages are<a id="_idIndexMarker1407"/> available for<a id="_idIndexMarker1408"/> each distribution, the easiest way to install the AWS CLI on Linux is to download and run the installer.</p>
    <div class="note">
      <p class="normal">These instructions assume that you have the <code class="inlineCode">curl</code> and <code class="inlineCode">unzip</code> packages installed. If you don’t, please install them using your distribution’s package manager. For example, on Ubuntu, you would need to run <code class="inlineCode">sudo apt-get install unzip curl</code> to install both packages.</p>
    </div>
    <p class="normal">To download and install the AWS CLI, run the following commands:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>curl <span class="hljs-con-string">"https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip"</span> -o <span class="hljs-con-string">"awscliv2.zip"</span>
<span class="hljs-con-meta">$ </span>unzip awscliv2.zip
<span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">sudo</span> ./aws/install
</code></pre>
    <p class="normal">Once installed, you should be able to execute the <code class="inlineCode">aws --version</code> command, and you will get something like the output shown in the <em class="italic">Installing on macOS</em> section, and the Windows version, which we will look at next.</p>
    <h3 class="heading-3" id="_idParaDest-542">Installing on Windows</h3>
    <p class="normal">As with macOS, you <a id="_idIndexMarker1409"/>can install the<a id="_idIndexMarker1410"/> AWS CLI with a package manager. As in <em class="chapterRef">Chapter 15</em>, <em class="italic">Kubernetes Clusters on Google Kubernetes Engine</em>, we will use Chocolatey. The command you need to run is shown here:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>choco install awscli
</code></pre>
    <p class="normal">Once installed using Chocolatey, executing the command below will give you a similar output to what we saw on macOS, with changes to the OS and Python versions being used:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>aws --version
</code></pre>
    <p class="normal">Again, once installed, you can move on to the <em class="italic">AWS CLI configuration</em> section below.</p>
    <h2 class="heading-2" id="_idParaDest-543">AWS CLI configuration</h2>
    <p class="normal">Once you have installed the <a id="_idIndexMarker1411"/>AWS CLI and checked that it is running properly by issuing the <code class="inlineCode">aws --version</code> command, you must link your local CLI install to your AWS account. To do this, you must log in to the AWS console, which can be accessed at <a href="http://console.aws.amazon.com/"><span class="url">http://console.aws.amazon.com/</span></a>.</p>
    <p class="normal">Once logged in, type <strong class="screenText">IAM</strong> into the search box, which is located at the top left of the page, next to the <strong class="screenText">Services</strong> button. Then, click on the <strong class="screenText">IAM Identity Center</strong> service link in the Services results to be taken to the <strong class="screenText">IAM Identity Center</strong> page.</p>
    <p class="normal">We need to create a user with programmatic access; to do this, follow these steps:</p>
    <ol>
      <li class="numberedList" value="1">Depending on your AWS account’s age or access level, you may need to enable <strong class="screenText">IAM Identity Center</strong>. My AWS account is for my own projects, so after clicking the <strong class="keyWord">Enable</strong> button, I chose the <strong class="screenText">Enable in only this AWS account</strong> option rather than the recommended <strong class="screenText">Enable with AWS Organizations</strong>. I did this because I do not have or require managing multiple AWS accounts within a single organization. Follow the onscreen instructions to enable the service.</li>
      <li class="numberedList">Once the <strong class="screenText">IAM Identity Center</strong> service is enabled, we must create a user with programmatic-only access. To do this, return to the search box in the menu at the top of the screen and search for <strong class="screenText">IAM</strong> again, but this time select <strong class="screenText">IAM</strong>, which is listed as <strong class="screenText">Manage access to AWS resources</strong>. Once the page loads, click on <strong class="screenText">Users</strong>, which can be found in the <strong class="screenText">Access Management</strong> section of the left-hand-side menu, and then click the <strong class="screenText">Create user</strong> button.</li>
      <li class="numberedList">Enter the username of <strong class="screenText">ekscluster</strong> and ensure you do not select the <strong class="screenText">Provide user access to the AWS Management Console – optional</strong> option, then click <strong class="screenText">Next</strong>. We will discuss this <a id="_idIndexMarker1412"/>option later in the chapter, once we have launched our cluster.</li>
    </ol>
    <figure class="mediaobject"><img alt="A screenshot of a computer&#10;&#10;Description automatically generated" src="image/B22019_16_02.png"/></figure>
    <p class="packt_figref">Figure 16.2: Adding a user</p>
    <ol>
      <li class="numberedList" value="4">Rather than create a group, we will grant our user an existing policy. To do this, select <strong class="screenText">Attach existing policies directly</strong>, select the <strong class="screenText">AdministratorAccess</strong> policy, and then click <strong class="screenText">Next</strong>.</li>
    </ol>
    <figure class="mediaobject"><img alt="A screenshot of a computer&#10;&#10;Description automatically generated" src="image/B22019_16_03.png"/></figure>
    <p class="packt_figref">Figure 16.3: Assigning permissions</p>
    <div class="note-one">
      <p class="normal">As this is a test in a non-production AWS account and we are going to remove this user at the end of the chapter, I am using quite a permissive policy. If you are going to be deploying this into a more production-like environment, I recommend referring to the AWS documentation for a more detailed guide on setting the correct permissions and policies.</p>
    </div>
    <ol>
      <li class="numberedList" value="5">Once you <a id="_idIndexMarker1413"/>have reviewed the information, click on the <strong class="screenText">Create user</strong> button. Once your user has been created, select the <strong class="screenText">ekscluster</strong> user from the list, select the <strong class="screenText">Security credentials</strong> tab, and click the <strong class="screenText">Create access key</strong> button in the <strong class="screenText">Access keys</strong> section. Select <strong class="screenText">Command Line Interface (CLI)</strong> and proceed to create the access key by clicking the <strong class="screenText">Next</strong> and then <strong class="screenText">Create access key</strong> buttons; once the key has been created, click on <strong class="screenText">Download .csv file</strong> and, finally, the <strong class="screenText">Done</strong> button.</li>
    </ol>
    <div class="note-one">
      <p class="normal">Keep the file you have downloaded safe, as it contains valid credentials for accessing your AWS account.</p>
    </div>
    <p class="normal">Return to your terminal<a id="_idIndexMarker1414"/> and then run the following command to create a default profile:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>aws configure
</code></pre>
    <p class="normal">This will ask for a few bits of information, as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">AWS access key identifier</strong> (<strong class="keyWord">ID</strong>): This is the access key ID from the <strong class="keyWord">comma-separated values</strong> (<strong class="keyWord">CSV</strong>) file we downloaded.</li>
      <li class="bulletList"><strong class="keyWord">AWS secret access key</strong>: This is the key from the CSV file.</li>
      <li class="bulletList"><strong class="keyWord">Default region name</strong>: I entered <code class="inlineCode">us-west-2</code>.</li>
      <li class="bulletList"><strong class="keyWord">Default output format</strong>: I left this blank.</li>
    </ul>
    <p class="normal">To test that everything is working, you can run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>aws ec2 describe-regions
</code></pre>
    <p class="normal">This will list the AWS Regions that are available, and the output should look something like this:</p>
    <figure class="mediaobject"><img alt="A computer screen with white text&#10;&#10;Description automatically generated" src="image/B22019_16_04.png"/></figure>
    <p class="packt_figref">Figure 16.4: Testing the AWS CLI</p>
    <p class="normal">Now that we have the AWS CLI installed and configured for our account, we need to install the second command-line tool, which we’ll use to launch the Amazon EKS cluster.</p>
    <h2 class="heading-2" id="_idParaDest-544">Installing eksctl, the official CLI for Amazon EKS</h2>
    <p class="normal">While it is possible to<a id="_idIndexMarker1415"/> launch an Amazon EKS cluster using the AWS CLI, it is complicated and has many steps. To get around this, Weaveworks created a simple command-line tool that generates an AWS CloudFormation template and then launches your cluster.</p>
    <p class="normal">Unfortunately, Weaveworks stopped commercial operations in early 2024, but before ceasing operations, they passed control of the project to the AWS team.</p>
    <div class="note">
      <p class="normal">AWS CloudFormation is Amazon’s <strong class="keyWord">Infrastructure-as-Code</strong> (<strong class="keyWord">IaC</strong>) definition language. It lets you define your AWS <a id="_idIndexMarker1416"/>resources so that they can be deployed across multiple accounts or repeatedly in the same one. This is useful if you have to keep spinning up an environment, for example, as part of a <strong class="keyWord">continuous integration</strong> (<strong class="keyWord">CI</strong>) build.</p>
    </div>
    <p class="normal">As you may have already guessed, installing on macOS and Windows follows the same pattern we have been using; macOS users can run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>brew install eksctl
</code></pre>
    <p class="normal">Likewise, on Windows, you can run:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>choco install eksctl
</code></pre>
    <p class="normal">Installing <code class="inlineCode">eksctl</code> on Linux, like the other tools, is slightly different, with the commands being:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>PLATFORM=$(<span class="hljs-con-built_in">uname</span> -s)_$(<span class="hljs-con-built_in">uname</span> -m)
<span class="hljs-con-meta">$ </span>curl -sLO <span class="hljs-con-string">"https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_</span><span class="hljs-con-variable">$PLATFORM</span><span class="hljs-con-string">.tar.gz"</span>
<span class="hljs-con-meta">$ </span>tar -xzf eksctl_<span class="hljs-con-variable">$PLATFORM</span>.tar.gz -C /tmp &amp;&amp; <span class="hljs-con-built_in">rm</span> eksctl_<span class="hljs-con-variable">$PLATFORM</span>.tar.gz
<span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">sudo</span> <span class="hljs-con-built_in">mv</span> /tmp/eksctl /usr/local/bin
</code></pre>
    <p class="normal">Once installed, you should be able to run the command below to get the version number:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>eksctl version
</code></pre>
    <p class="normal">So, we are now ready to launch our Amazon EKS cluster.</p>
    <h1 class="heading-1" id="_idParaDest-545">Launching your Amazon Elastic Kubernetes Service cluster</h1>
    <p class="normal">With all of the <a id="_idIndexMarker1417"/>prerequisites installed, we can finally start deploying our Amazon EKS cluster. Once deployed, we will be able to start interacting with it to launch a workload like we did in <em class="chapterRef">Chapter 15</em>, <em class="italic">Kubernetes Clusters on Google Kubernetes Engine</em>.</p>
    <p class="normal">To do this, we will use the defaults built into the <code class="inlineCode">eksctl</code> command, as this is just a sandbox Amazon EKS against which we can run some commands. This will launch an Amazon EKS cluster with the following attributes:</p>
    <ul>
      <li class="bulletList">In the <strong class="keyWord">us-west-1</strong> Region</li>
      <li class="bulletList">With two worker nodes, using the <strong class="keyWord">m5.large</strong> instance type</li>
      <li class="bulletList">Uses the official AWS EKS <strong class="keyWord">Amazon Machine Image</strong> (<strong class="keyWord">AMI</strong>)</li>
      <li class="bulletList">Uses <strong class="keyWord">Amazon’s Virtual Private Cloud</strong> (<strong class="keyWord">VPC</strong>) for its networking service</li>
      <li class="bulletList">With an automatically generated random name</li>
    </ul>
    <p class="normal">So, without further ado, let’s launch our cluster by running the following command:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>eksctl create cluster
</code></pre>
    <p class="normal">You should go and make a drink or catch up on emails, as this process can take up to 30 minutes to complete. If you are not deploying an Amazon EKS cluster, here is my output when running the command.</p>
    <p class="normal">First of all, some basic information is displayed about the version of <code class="inlineCode">eksctl</code> and which Region will be used:</p>
    <pre class="programlisting con"><code class="hljs-con">[i]  eksctl version 0.180.0-dev+763027060.2024-05-29T21:36:10Z
[i]  using region us-west-2
</code></pre>
    <p class="normal">Next up, it will give some information on the networking and AZs it will be deploying resources into, as illustrated in the following code snippet:</p>
    <pre class="programlisting con"><code class="hljs-con">[i]  setting availability zones to [us-west-2d us-west-2b us-west-2c]
[i]  subnets for us-west-2d - public:192.168.0.0/19 private:192.168.96.0/19
[i]  subnets for us-west-2b - public:192.168.32.0/19 private:192.168.128.0/19
[i]  subnets for us-west-2c - public:192.168.64.0/19 private:192.168.160.0/19
</code></pre>
    <p class="normal">It will now give details of which version of the AMI it is going to use, along with the Kubernetes version that the image supports, as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">[i]  nodegroup "ng-11c87ff4" will use "[AmazonLinux2/1.29]"
[i]  using Kubernetes version 1.29
</code></pre>
    <p class="normal">Now it knows all the<a id="_idIndexMarker1418"/> elements, it is going to create a cluster. Here, you can see it making a start on the deployment:</p>
    <pre class="programlisting con"><code class="hljs-con">[i]  creating EKS cluster "hilarious-wardrobe-1717847351" in "us-west-2" region with managed nodes
[i]  will create 2 separate CloudFormation stacks for cluster itself and the initial managed nodegroup
[i]  if you encounter any issues, check CloudFormation console or try 'eksctl utils describe-stacks --region=us-west-2 --cluster=hilarious-wardrobe-1717847351'
[i]  Kubernetes API endpoint access will use default of {publicAccess=true, privateAccess=false} for cluster "hilarious-wardrobe-1717847351" in "us-west-2"
</code></pre>
    <p class="normal">As you can see, it has called my cluster <code class="inlineCode">hilarious-wardrobe-1717847351</code>; this will be referenced throughout the build. By default, logging is not enabled, as we can see here:</p>
    <pre class="programlisting con"><code class="hljs-con">[i]  CloudWatch logging will not be enabled for cluster "hilarious-wardrobe-1717847351" in "us-west-2"
[i]  you can enable it with 'eksctl utils update-cluster-logging --enable-types={SPECIFY-YOUR-LOG-TYPES-HERE (e.g. all)} --region=us-west-2 --cluster=hilarious-wardrobe-1717847351'
</code></pre>
    <p class="normal">Now is the point where we wait as the control plane and cluster are deploying:</p>
    <pre class="programlisting con"><code class="hljs-con">[i]2 sequential tasks: { create cluster control plane "hilarious-wardrobe-1717847351",2 sequential sub-tasks: {wait for control plane to become ready, create managed nodegroup "ng-11c87ff4",}}
[i]  building cluster stack "eksctl-hilarious-wardrobe-1717847351-cluster"
[i]  waiting for CloudFormation stack "eksctl-hilarious-wardrobe-1717847351-cluster"
[i]  building managed nodegroup stack "eksctl-hilarious-wardrobe-1717847351-nodegroup-ng-11c87ff4"
[i]  deploying stack "eksctl-hilarious-wardrobe-1717847351-nodegroup-ng-11c87ff4"
[i]  waiting for CloudFormation stack "eksctl-hilarious-wardrobe-1717847351-nodegroup-ng-11c87ff4"
[i]  waiting for the control plane to become ready
</code></pre>
    <p class="normal">Once deployed, it will download the cluster credentials and configure <code class="inlineCode">kubectl</code>, as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">[✔]  saved kubeconfig as "/Users/russ.mckendrick/.kube/config"
[i]  no tasks
[✔]  all EKS cluster resources for "hilarious-wardrobe-1717847351" have been created
</code></pre>
    <p class="normal">The final step is to<a id="_idIndexMarker1419"/> wait for the nodes to become available, as is happening here:</p>
    <pre class="programlisting con"><code class="hljs-con">2024-06-08 13:03:34 [✔]  created 0 nodegroup(s) in cluster "hilarious-wardrobe-1717847351"
2024-06-08 13:03:35 [i]  node "ip-192-168-34-120.us-west-2.compute.internal" is ready
2024-06-08 13:03:35 [i]  node "ip-192-168-67-233.us-west-2.compute.internal" is ready
2024-06-08 13:03:35 [i]  waiting for at least 2 node(s) to become ready in "ng-11c87ff4"
2024-06-08 13:03:35 [i]  nodegroup "ng-11c87ff4" has 2 node(s)
2024-06-08 13:03:35 [i]  node "ip-192-168-34-120.us-west-2.compute.internal" is ready
2024-06-08 13:03:35 [i]  node "ip-192-168-67-233.us-west-2.compute.internal" is ready
2024-06-08 13:03:35 [✔]  created 1 managed nodegroup(s) in cluster "hilarious-wardrobe-1717847351"
</code></pre>
    <p class="normal">Now that we have both nodes online and ready, it is time to display a message confirming that everything is ready, as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">2024-06-08 13:03:36 [i]  kubectl command should work with "/Users/russ.mckendrick/.kube/config", try 'kubectl get nodes'
2024-06-08 13:03:36 [✔]  EKS cluster "hilarious-wardrobe-1717847351" in "us-west-2" region is ready
</code></pre>
    <p class="normal">Now that the cluster is ready, let’s do as the output suggests and run <code class="inlineCode">kubectl get nodes</code>. As expected, this gives us details on the two nodes that make up our cluster, as illustrated in the<a id="_idIndexMarker1420"/> following screenshot:</p>
    <figure class="mediaobject"><img alt="A screenshot of a computer screen&#10;&#10;Description automatically generated" src="image/B22019_16_05.png"/></figure>
    <p class="packt_figref">Figure 16.5: Viewing the two Amazon EKS cluster nodes</p>
    <p class="normal">Now that we have a cluster up and running, let’s deploy the same workload we launched when we worked with our <strong class="keyWord">Google Kubernetes Engine</strong> (<strong class="keyWord">GKE</strong>) cluster.</p>
    <h1 class="heading-1" id="_idParaDest-546">Deploying a workload and interacting with your cluster</h1>
    <p class="normal">In <em class="chapterRef">Chapter 15</em>, <em class="italic">Kubernetes Clusters on Google Kubernetes Engine</em>, we used the Guestbook example from the GCP GKE examples GitHub repository. In this section, first we will deploy the workload before exploring the web-based AWS console. So now let’s start on our Guestbook deployment.</p>
    <h2 class="heading-2" id="_idParaDest-547">Deploying the workload</h2>
    <p class="normal">Even though our cluster runs in<a id="_idIndexMarker1421"/> AWS using Amazon EKS, we will use the same set of YAML files we used to launch our workload in GKE using our local <code class="inlineCode">kubectl</code>; to do this, follow the steps below:</p>
    <ol>
      <li class="numberedList" value="1"> As before, our first step is launching the Redis Leader deployment and service by running the two commands below:
        <pre class="programlisting con-one"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl apply -f https://raw.githubusercontent.com/GoogleCloudPlatform/kubernetes-engine-samples/main/quickstarts/guestbook/redis-leader-deployment.yaml
<span class="hljs-con-meta">$ </span>kubectl apply -f https://raw.githubusercontent.com/GoogleCloudPlatform/kubernetes-engine-samples/main/quickstarts/guestbook/redis-leader-service.yaml
</code></pre>
      </li>
      <li class="numberedList">Once the Redis Leader is deployed, we need to launch the Redis Follower deployment and service, as follows:
        <pre class="programlisting con-one"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl apply -f https://raw.githubusercontent.com/GoogleCloudPlatform/kubernetes-engine-samples/main/quickstarts/guestbook/redis-follower-deployment.yaml
<span class="hljs-con-meta">$ </span>kubectl apply -f https://raw.githubusercontent.com/GoogleCloudPlatform/kubernetes-engine-samples/main/quickstarts/guestbook/redis-follower-service.yaml
</code></pre>
      </li>
      <li class="numberedList">Once the Redis <a id="_idIndexMarker1422"/>Leader and Follower are up and running, it’s time to launch the frontend deployment and service using the following commands:
        <pre class="programlisting con-one"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl apply -f https://raw.githubusercontent.com/GoogleCloudPlatform/kubernetes-engine-samples/main/quickstarts/guestbook/frontend-deployment.yaml
<span class="hljs-con-meta">$ </span>kubectl apply -f https://raw.githubusercontent.com/GoogleCloudPlatform/kubernetes-engine-samples/main/quickstarts/guestbook/frontend-service.yaml
</code></pre>
      </li>
      <li class="numberedList">After a few minutes, we will be able to run the following command to get information on the service we have just launched, which should include details on where to access our workload:
        <pre class="programlisting con-one"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get service frontend
</code></pre>
      </li>
    </ol>
    <p class="normal">You will notice that, this time, the output is slightly different from the output we got when running the workload on GKE, as we can see in the following screenshot:</p>
    <figure class="mediaobject"><img alt="A screenshot of a computer&#10;&#10;Description automatically generated" src="image/B22019_16_06.png"/></figure>
    <p class="packt_figref">Figure 16.6: Getting information on the frontend service</p>
    <p class="normal">As you can see, rather than<a id="_idIndexMarker1423"/> an <strong class="keyWord">Internet Protocol</strong> (<strong class="keyWord">IP</strong>) address, we get<a id="_idIndexMarker1424"/> a <strong class="keyWord">Uniform Resource Locator</strong> (<strong class="keyWord">URL</strong>). Copy that into your browser.</p>
    <p class="normal">Once you have opened the URL, given that we have used the same commands and workload configuration, you won’t be surprised to see the <strong class="screenText">Guestbook</strong> application, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img alt="A screenshot of a computer&#10;&#10;Description automatically generated" src="image/B22019_16_07.png"/></figure>
    <p class="packt_figref">Figure 16.7: The Guestbook application with a few examples</p>
    <p class="normal">Now that our workload is up and running, let’s explore what we can see about our cluster within the AWS console.</p>
    <h2 class="heading-2" id="_idParaDest-548">Exploring the AWS console</h2>
    <p class="normal">This section will <a id="_idIndexMarker1425"/>examine our newly deployed workload using the AWS console. First, log in to the AWS console at <a href="https://console.aws.amazon.com/"><span class="url">https://console.aws.amazon.com/</span></a>. Once logged in, select the <strong class="keyWord">US West (Oregon) us-west-2</strong> Region in the Region selector at the top right of the screen, next to your username.</p>
    <figure class="mediaobject"><img alt="A screenshot of a computer&#10;&#10;Description automatically generated" src="image/B22019_16_08.png"/></figure>
    <p class="packt_figref">Figure 16.8: Selecting the correct Region</p>
    <p class="normal">Once the correct Region is selected, search for <strong class="screenText">Elastic Kubernetes Service</strong> in the search bar on the top right and select the service, which should be the first result, to be taken to the EKS page in<a id="_idIndexMarker1426"/> the Oregon Region.</p>
    <figure class="mediaobject"><img alt="A screenshot of a computer&#10;&#10;Description automatically generated" src="image/B22019_16_09.png"/></figure>
    <p class="packt_figref">Figure 16.9: Our first look at our EKS cluster in the AWS console</p>
    <p class="normal">So far, so good; well, we will talk about it in a moment – click on your cluster name, and you will be presented with something that looks like the following page:</p>
    <figure class="mediaobject"><img alt="A screenshot of a computer&#10;&#10;Description automatically generated" src="image/B22019_16_10.png"/></figure>
    <p class="packt_figref">Figure 16.10: Access denied!</p>
    <p class="normal">So, let’s unpack <a id="_idIndexMarker1427"/>what is happening here. You may think, <em class="italic">“This is my main user, and surely it has full access?”.</em></p>
    <p class="normal">There is a good reason for this; when <code class="inlineCode">eksctl</code> launched our cluster, it granted the <strong class="screenText">ekscluster</strong> user we created earlier in the chapter permission to interact with the cluster using AWS services as we configured the AWS CLI to connect using this user and not the main user we are currently logged in as.</p>
    <p class="normal">This means that to view workloads and the like within the AWS console, we need to log in as the user we created earlier. To do this, return to IAM in the AWS console, go to the <strong class="screenText">Users</strong> page, and select the <strong class="screenText">ekscluster</strong> user; go to the <strong class="screenText">Security Credentials</strong> tab and then click on the <strong class="screenText">Enable console access</strong> button:</p>
    <figure class="mediaobject"><img alt="A screenshot of a computer&#10;&#10;Description automatically generated" src="image/B22019_16_11.png"/></figure>
    <p class="packt_figref">Figure 16.11: Enabling console access for the ekscluster user</p>
    <p class="normal">Select the <strong class="screenText">Autogenerated password</strong> option and enable access; finally, download the CSV file containing the credentials as before.</p>
    <p class="normal">Once downloaded, sign out of the AWS console and open the CSV file you downloaded. Go to the console sign-in URL. This is a URL that allows IAM users, like the one we created, to sign in to your account; use the username and password in the CSV file.</p>
    <p class="normal">Once you have signed in, return to<a id="_idIndexMarker1428"/> the EKS page and select your cluster; this time, you will not see any complaints about permissions.</p>
    <p class="normal">When you first open the cluster, you will see several tabs. These are:</p>
    <ul>
      <li class="bulletList"><strong class="screenText">Overview</strong>: Displays various cluster details, such as the version of Kubernetes running, endpoint information, the cluster status, creation time and date, etc.</li>
      <li class="bulletList"><strong class="screenText">Resources</strong>: Provides information on nodes, Pods, namespaces, and workloads</li>
      <li class="bulletList"><strong class="screenText">Compute</strong>: Shows node information, node groups, and details on any Fargate profiles associated with the cluster</li>
      <li class="bulletList"><strong class="screenText">Networking</strong>: Details the VPC configuration</li>
      <li class="bulletList"><strong class="screenText">Add-ons</strong>: Lists installed and available add-ons for the cluster</li>
      <li class="bulletList"><strong class="screenText">Access</strong>: Displays IAM roles, AWS auth ConfigMap, and Kubernetes RBAC role bindings</li>
      <li class="bulletList"><strong class="screenText">Observability</strong>: Configures and shows logging, monitoring, and recent events</li>
      <li class="bulletList"><strong class="screenText">Upgrade insights</strong>: Lists available Kubernetes version upgrades and compatibility checks</li>
      <li class="bulletList"><strong class="screenText">Update history</strong>: Provides a history of cluster and node group updates</li>
      <li class="bulletList"><strong class="screenText">Tags</strong>: Lists and manages tags associated with the EKS cluster</li>
    </ul>
    <p class="normal">Below, you can see details<a id="_idIndexMarker1429"/> on the nodes:</p>
    <figure class="mediaobject"><img alt="A screenshot of a computer&#10;&#10;Description automatically generated" src="image/B22019_16_12.png"/></figure>
    <p class="packt_figref">Figure 16.12: Viewing the two nodes in the cluster in the Compute tab</p>
    <p class="normal">Clicking on <strong class="screenText">Resources</strong>, selecting <strong class="screenText">Deployments</strong>, and filtering down to the <strong class="screenText">default</strong> workspace will show the workload we launched:</p>
    <figure class="mediaobject"><img alt="A screenshot of a computer&#10;&#10;Description automatically generated" src="image/B22019_16_13.png"/></figure>
    <p class="packt_figref">Figure 16.13: Viewing our workload</p>
    <p class="normal">Clicking on one of the deployments will give you more information on the deployment – this includes details of the Pods, configuration, and so on. However, as you click around, you will find that all you can really do is view information on the services; there are no graphs, logging output, or anything that gives more than a basic overview of our workloads. This is because the AWS console is mostly just exposing information from Kubernetes itself.</p>
    <p class="normal">Moving away from the <a id="_idIndexMarker1430"/>EKS service page and going to the EC2 service section of the AWS console will display the two nodes, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img alt="A screenshot of a computer&#10;&#10;Description automatically generated" src="image/B22019_16_14.png"/></figure>
    <p class="packt_figref">Figure 16.14: Looking at the raw EC2 compute resource</p>
    <p class="normal">Here, you can drill down and find out more information on the instance, including CPU, RAM, and network utilization; however, this is only for the instance itself and not our Kubernetes workload.</p>
    <p class="normal">Selecting <strong class="screenText">Load Balancers</strong> from the <strong class="screenText">Load Balancing</strong> section of the left-hand-side menu will show you the elastic load balancer that was launched and configured when we applied the frontend service, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img alt="A screenshot of a computer&#10;&#10;Description automatically generated" src="image/B22019_16_15.png"/></figure>
    <p class="packt_figref">Figure 16.15: Looking at the raw load balancer resource</p>
    <p class="normal">One final AWS service we are using is AWS CloudFormation, so entering <strong class="screenText">CloudFormation</strong> in the Services menu and clicking on the link will take you to the CloudFormation service page.</p>
    <p class="normal">Here, you will see two <a id="_idIndexMarker1431"/>stacks: one for the EKS nodes, our two EC2 instances, and one for the EKS cluster, which is our Kubernetes management plane. These stacks are illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img alt="A screenshot of a computer&#10;&#10;Description automatically generated" src="image/B22019_16_16.png"/></figure>
    <p class="packt_figref">Figure 16.16: The two stacks that make up our cluster</p>
    <p class="normal">Selecting one of the stacks will give you details on what happened when the stack was launched. It will list all the many resources created during the launch of the Amazon EKS cluster using <code class="inlineCode">eksctl</code>.</p>
    <p class="normal">You select a template and then view it in the designer; you can even see the CloudFormation template generated by <code class="inlineCode">eksctl</code>, which is quite a complicated JSON file – if you click on the <strong class="screenText">View in Application Composer</strong> button, you will be able to get a more digestible visual representation of the stack. A screenshot of this view can be seen below:</p>
    <figure class="mediaobject"><img alt="A screenshot of a computer&#10;&#10;Description automatically generated" src="image/B22019_16_17.png"/></figure>
    <p class="packt_figref">Figure 16.17: Reviewing the CloudFormation template in Application Composer</p>
    <p class="normal">That is about all we can see in the <a id="_idIndexMarker1432"/>AWS console. As we have seen, while Amazon EKS is relatively simple to launch using <code class="inlineCode">eksctl</code>, its level of integration with the AWS console could be better compared to the GKE cluster we launched in the previous chapter.</p>
    <p class="normal">While we were able to explore and view our workload, we could not interact with too much; also, the feedback on the cluster is tied to the basic monitoring offered by the Amazon EC2 service.</p>
    <p class="normal">Once you have finished with your Amazon EKS cluster, you can delete it.</p>
    <h1 class="heading-1" id="_idParaDest-549">Deleting your Amazon Elastic Kubernetes Service cluster</h1>
    <p class="normal">You can <a id="_idIndexMarker1433"/>delete your cluster by running the following command, making sure to replace the cluster name with that of your own:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>eksctl delete cluster --name hilarious-wardrobe-1717847351
</code></pre>
    <p class="normal">Deleting the cluster takes less time to run than when we launched it; in fact, it takes around 5 minutes.</p>
    <p class="normal">As before, <code class="inlineCode">eksctl</code> gives you details on what it is doing as it deletes the resources:</p>
    <pre class="programlisting con"><code class="hljs-con">[i]  deleting EKS cluster "hilarious-wardrobe-1717847351"
[i]  will drain 0 unmanaged nodegroup(s) in cluster "hilarious-wardrobe-1717847351"
[i]  starting parallel draining, max in-flight of 1
[i]  deleted 0 Fargate profile(s)
</code></pre>
    <p class="normal">The first thing that is updated is the local kubectl configuration, as we can see here:</p>
    <pre class="programlisting con"><code class="hljs-con">[✔]  kubeconfig has been updated
</code></pre>
    <p class="normal">Then, any resources that have been launched as part of deploying workloads into our cluster are terminated:</p>
    <pre class="programlisting con"><code class="hljs-con">[i]  cleaning up AWS load balancers created by Kubernetes objects of Kind Service or Ingress
</code></pre>
    <p class="normal">Then, the two AWS <a id="_idIndexMarker1434"/>CloudFormation stacks are removed, which in turn removes all of the resources they created and configured, as illustrated in the following code snippet:</p>
    <pre class="programlisting con"><code class="hljs-con">[i]  2 sequential tasks: { delete nodegroup "ng-11c87ff4", delete cluster control plane "hilarious-wardrobe-1717847351" [async] }
[i]  will delete stack "eksctl-hilarious-wardrobe-1717847351-nodegroup-ng-11c87ff4"
[i]  waiting for stack "eksctl-hilarious-wardrobe-1717847351-nodegroup-ng-11c87ff4" to get deleted
[i]  waiting for CloudFormation stack "eksctl-hilarious-wardrobe-1717847351-nodegroup-ng-11c87ff4"
[i]  will delete stack "eksctl-hilarious-wardrobe-1717847351-cluster"
[✔]  all cluster resources were deleted
</code></pre>
    <p class="normal">At this point, our cluster has been completely deleted.</p>
    <div class="note">
      <p class="normal">Please double-check the EC2, EKS, and CloudFormation sections in the AWS console to ensure that all services have been correctly deleted, as you will be charged for any orphaned or idle resources left behind. While this is an unlikely scenario, it is best to double-check now rather than receive an unexpected bill at the end of the month.</p>
    </div>
    <p class="normal">So, how much would our Amazon EKS cluster have cost us to run for a month?</p>
    <p class="normal">There are two sets <a id="_idIndexMarker1435"/>of costs that we need to consider:</p>
    <ul>
      <li class="bulletList">The first is for the Amazon EKS cluster itself. It is US Dollars (USD) 0.10 per hour for each Amazon EKS cluster you create; however, each Amazon EKS cluster can run multiple node groups, so you shouldn’t have to launch more than one per Region. This means that the Amazon EKS cluster costs around $73 per month.</li>
      <li class="bulletList">The next consideration is the AWS resources used by the cluster, for example, the EC2 cluster nodes, in our case, would have cost around $70 each, and the total cost to run our cluster for a month would be around $213. I say around because there are<a id="_idIndexMarker1436"/> charges for bandwidth and the AWS <strong class="keyWord">Elastic Load Balancing</strong> (<strong class="keyWord">ELB</strong>) service, which will increase the cost of our workload further.</li>
    </ul>
    <p class="normal">A link to the pricing overview page can be found in the <em class="italic">Further reading</em> section at the end of this chapter.</p>
    <h1 class="heading-1" id="_idParaDest-550">Summary</h1>
    <p class="normal">In this chapter, we discussed the origins of AWS and Amazon EKS before walking through how to sign up for an account and how to install and configure the two command-line tools required to easily launch an Amazon EKS cluster.</p>
    <p class="normal">Once our cluster was up and running, we deployed the same workload as when we launched our GKE cluster. We did not have to make any allowances for the workload running on a different cloud provider – it just worked, even deploying a load balancer using the AWS native load balancing service without us having to instruct it to do so.</p>
    <p class="normal">However, we did find that Amazon EKS is less integrated with the AWS console than the Google service we looked at. We also learned that we had to install a second command-line tool to easily launch our cluster due to the complications of trying to do so using the AWS CLI. This would have been around eight steps, assuming the Amazon VPC configuration and IAM roles had been created and deployed.</p>
    <p class="normal">This lack of integration and complexity in launching and maintaining clusters compared to other providers would put me off running my Kubernetes workloads on Amazon EKS – it all feels a little disjointed and not as slick as the Google offering.</p>
    <p class="normal">In the next chapter, we will examine launching an <strong class="keyWord">Azure Kubernetes Service</strong> (<strong class="keyWord">AKS</strong>) cluster on Microsoft Azure, the last of the three public providers we will cover.</p>
    <h1 class="heading-1" id="_idParaDest-551">Further reading</h1>
    <p class="normal">Here are links to more information on some of the topics and tools we have covered in this chapter:</p>
    <ul>
      <li class="bulletList">AWS: <a href="https://aws.amazon.com/&#13;"><span class="url">https://aws.amazon.com/</span></a></li>
      <li class="bulletList">Amazon EKS: <a href="https://aws.amazon.com/eks/&#13;"><span class="url">https://aws.amazon.com/eks/</span></a></li>
      <li class="bulletList">The AWS CLI: <a href="https://aws.amazon.com/cli/&#13;"><span class="url">https://aws.amazon.com/cli/</span></a></li>
      <li class="bulletList">eksctl: <a href="https://eksctl.io/&#13;"><span class="url">https://eksctl.io/</span></a></li>
      <li class="bulletList">eksctl support status update: <a href="https://github.com/aws/containers-roadmap/issues/2280&#13;"><span class="url">https://github.com/aws/containers-roadmap/issues/2280</span></a></li>
      <li class="bulletList">Official documentation: <a href="https://docs.aws.amazon.com/eks/latest/userguide/what-is-eks.html&#13;"><span class="url">https://docs.aws.amazon.com/eks/latest/userguide/what-is-eks.html</span></a></li>
      <li class="bulletList">Amazon EKS pricing: <a href="https://aws.amazon.com/eks/pricing/&#13;"><span class="url">https://aws.amazon.com/eks/pricing/</span></a></li>
    </ul>
    <h1 class="heading-1" id="_idParaDest-552">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the authors and other readers:</p>
    <p class="normal"><a href="https://packt.link/cloudanddevops"><span class="url">https://packt.link/cloudanddevops</span></a></p>
    <p class="normal"><img alt="" src="image/QR_Code119001106479081656.png"/></p>
  </div>
</body></html>