<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Kubernetes Network</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In </span><a href="a5cf080a-372a-406e-bb48-019af313c676.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.3.1">Chapter 3</span></span></a><span><span class="koboSpan" id="kobo.4.1">, </span></span><em><span class="koboSpan" id="kobo.5.1">Getting Started with Kubernetes</span></em><span><span class="koboSpan" id="kobo.6.1">,</span></span><span class="koboSpan" id="kobo.7.1"> we learned how to deploy containers with different resources and also looked at how to use volumes to persist data, dynamic provisioning, different storage classes, and advanced administration in Kubernetes. </span><span class="koboSpan" id="kobo.7.2">In this chapter, we'll learn how Kubernetes routes traffic to make all of this possible. </span><span class="koboSpan" id="kobo.7.3">Networking always plays an important role in the software world. </span><span class="koboSpan" id="kobo.7.4">We'll learn about Kubernetes networking step by step, looking at the communication between containers on a single host, multiple hosts, and inside a cluster.</span></p>
<p><span class="koboSpan" id="kobo.8.1">The following are the topics we'll cover in this chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Kubernetes networking</span></li>
<li><span class="koboSpan" id="kobo.10.1">Docker networking</span></li>
<li><span class="koboSpan" id="kobo.11.1">Ingress</span></li>
<li><span class="koboSpan" id="kobo.12.1">Network policy</span></li>
<li><span class="koboSpan" id="kobo.13.1">Service mesh</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Kubernetes networking</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There are plenty of options when it comes to implementing networking in Kubernetes. </span><span class="koboSpan" id="kobo.2.2">Kubernetes itself doesn't care about how you implement it, but you must meet its three fundamental requirements:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">All containers should be accessible to each other without NAT, regardless of which nodes they are on</span></li>
<li><span class="koboSpan" id="kobo.4.1">All nodes should communicate with all containers</span></li>
<li><span class="koboSpan" id="kobo.5.1">The IP container should see itself in the same way as others see it</span></li>
</ul>
<p><span class="koboSpan" id="kobo.6.1">Before getting any further into this, we'll first examine how default container networking works.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Docker networking</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's now review how docker networking works before getting into Kubernetes networking. </span><span class="koboSpan" id="kobo.2.2">For container networking, there are different modes: bridge, none, overlay, macvlan, and host. </span><span class="koboSpan" id="kobo.2.3">We've learned about the major modes in</span><span><span class="koboSpan" id="kobo.3.1"> </span></span><a href="05e2d0b4-0e70-4480-b5a0-f3860ddb24f2.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.4.1">Chapter 2</span></span></a><span><span class="koboSpan" id="kobo.5.1">, </span></span><em><span class="koboSpan" id="kobo.6.1">DevOps with Containers. </span></em><span class="koboSpan" id="kobo.7.1">Bridge is the default networking model. </span><span class="koboSpan" id="kobo.7.2">Docker creates and attaches a virtual Ethernet device (also known as </span><kbd><span class="koboSpan" id="kobo.8.1">veth</span></kbd><span class="koboSpan" id="kobo.9.1">) and assigns a network namespace to each container.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.10.1">The </span><strong><span class="koboSpan" id="kobo.11.1">network namespace</span></strong><span class="koboSpan" id="kobo.12.1"> is a feature in Linux that is logically another copy of a network stack. </span><span class="koboSpan" id="kobo.12.2">It has its own routing tables, ARP tables, and network devices. </span><span class="koboSpan" id="kobo.12.3">This is a fundamental concept of container networking.</span></div>
<p><kbd><span class="koboSpan" id="kobo.13.1">Veth</span></kbd><span class="koboSpan" id="kobo.14.1"> always comes in pairs; one is in the network namespace and the other is in the bridge. </span><span class="koboSpan" id="kobo.14.2">When the traffic comes into the host network, it will be routed into the bridge. </span><span class="koboSpan" id="kobo.14.3">The packet will be dispatched to its </span><kbd><span class="koboSpan" id="kobo.15.1">veth</span></kbd><span class="koboSpan" id="kobo.16.1">, and will go into the namespace inside the container, as shown in the following diagram:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.17.1"><img class=" image-border" src="assets/35ce4055-4fd3-410d-b57e-e795da30a0c9.png" style="width:33.25em;height:28.42em;"/></span></div>
<p><span class="koboSpan" id="kobo.18.1">Let's take a closer look at this. </span><span class="koboSpan" id="kobo.18.2">In the following example, we'll use a minikube node as the docker host. </span><span class="koboSpan" id="kobo.18.3">First, we'll have to use </span><kbd><span class="koboSpan" id="kobo.19.1">minikube ssh</span></kbd><span class="koboSpan" id="kobo.20.1"> to ssh into the node because we're not using Kubernetes yet. </span><span class="koboSpan" id="kobo.20.2">After we get into the minikube node, we'll launch a container to interact with us:</span></p>
<pre><strong><span class="koboSpan" id="kobo.21.1">// launch a busybox container with `top` command, also, expose container port 8080 to host port 8000.
</span><span class="koboSpan" id="kobo.21.2"># docker run -d -p 8000:8080 --name=busybox busybox top
737e4d87ba86633f39b4e541f15cd077d688a1c8bfb83156d38566fc5c81f469 </span></strong></pre>
<p><span class="koboSpan" id="kobo.22.1">Let's see the implementation of outbound traffic within a container. </span><kbd><span class="koboSpan" id="kobo.23.1">docker exec &lt;container_name or container_id&gt;</span></kbd><span class="koboSpan" id="kobo.24.1"> can run a command in a running container. </span><span class="koboSpan" id="kobo.24.2">Let's use </span><kbd><span class="koboSpan" id="kobo.25.1">ip link list</span></kbd><span class="koboSpan" id="kobo.26.1"> to list all the interfaces:</span></p>
<pre><strong><span class="koboSpan" id="kobo.27.1">// show all the network interfaces in busybox container
// docker exec &lt;container_name&gt; &lt;command&gt;
# docker exec busybox ip link list
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1
   link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: sit0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop qlen 1
   link/sit 0.0.0.0 brd 0.0.0.0
53: eth0@if54: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; </span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">    mtu 1500 qdisc noqueue
   link/ether 02:42:ac:11:00:07 brd ff:ff:ff:ff:ff:ff</span></strong></pre>
<p><span class="koboSpan" id="kobo.29.1">We can see that we have three interfaces inside the </span><kbd><span class="koboSpan" id="kobo.30.1">busybox</span></kbd><span class="koboSpan" id="kobo.31.1"> container. </span><span class="koboSpan" id="kobo.31.2">One has an ID of </span><kbd><span class="koboSpan" id="kobo.32.1">53</span></kbd><span class="koboSpan" id="kobo.33.1"> with the name </span><kbd><span class="koboSpan" id="kobo.34.1">eth0@if54</span></kbd><span class="koboSpan" id="kobo.35.1">. </span><span class="koboSpan" id="kobo.35.2">The number after </span><kbd><span class="koboSpan" id="kobo.36.1">if</span></kbd><span class="koboSpan" id="kobo.37.1"> is the other interface ID in the pair. </span><span class="koboSpan" id="kobo.37.2">In this case, the pair ID is </span><kbd><span class="koboSpan" id="kobo.38.1">54</span></kbd><span class="koboSpan" id="kobo.39.1">. </span><span class="koboSpan" id="kobo.39.2">If we run the same command on the host, we can see that the </span><kbd><span class="koboSpan" id="kobo.40.1">veth</span></kbd><span class="koboSpan" id="kobo.41.1"> in the host is pointing to </span><kbd><span class="koboSpan" id="kobo.42.1">eth0</span></kbd><span class="koboSpan" id="kobo.43.1"> inside the container:</span></p>
<pre><strong><span class="koboSpan" id="kobo.44.1">// show all the network interfaces from the host
# ip link list
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue</span></strong><br/><strong><span class="koboSpan" id="kobo.45.1">   state UNKNOWN mode DEFAULT group default qlen 1
   link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc </span></strong><br/><strong><span class="koboSpan" id="kobo.46.1">   pfifo_fast state UP mode DEFAULT group default qlen  </span></strong><br/><strong><span class="koboSpan" id="kobo.47.1">   1000
   link/ether 08:00:27:ca:fd:37 brd ff:ff:ff:ff:ff:ff
...
</span><span class="koboSpan" id="kobo.47.2">54: vethfeec36a@if53: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; </span></strong><br/><strong><span class="koboSpan" id="kobo.48.1">    mtu 1500 qdisc noqueue master docker0 state UP mode  </span></strong><br/><strong><span class="koboSpan" id="kobo.49.1">    DEFAULT group default
   link/ether ce:25:25:9e:6c:07 brd ff:ff:ff:ff:ff:ff link-netnsid 5</span></strong></pre>
<p><span class="koboSpan" id="kobo.50.1">We have a </span><kbd><span class="koboSpan" id="kobo.51.1">veth</span></kbd><span class="koboSpan" id="kobo.52.1"> on the host named </span><kbd><span class="koboSpan" id="kobo.53.1">vethfeec36a@if53</span></kbd><span class="koboSpan" id="kobo.54.1">. </span><span class="koboSpan" id="kobo.54.2">This pairs with </span><kbd><span class="koboSpan" id="kobo.55.1">eth0@if54</span></kbd><span class="koboSpan" id="kobo.56.1"> in the container network namespace. </span><kbd><span class="koboSpan" id="kobo.57.1">veth</span></kbd><span class="koboSpan" id="kobo.58.1"> 54 is attached to the </span><kbd><span class="koboSpan" id="kobo.59.1">docker0</span></kbd><span class="koboSpan" id="kobo.60.1"> bridge, and eventually accesses the internet via </span><kbd><span class="koboSpan" id="kobo.61.1">eth0</span></kbd><span class="koboSpan" id="kobo.62.1">. </span><span class="koboSpan" id="kobo.62.2">If we take a look at the </span><kbd><span class="koboSpan" id="kobo.63.1">iptables</span></kbd><span class="koboSpan" id="kobo.64.1"> rules, we can find a masquerading rule (also known as SNAT) on the host that docker creates for outbound traffic, which will make internet access available for containers:</span></p>
<pre><strong><span class="koboSpan" id="kobo.65.1">// list iptables nat rules. </span><span class="koboSpan" id="kobo.65.2">Showing only POSTROUTING rules which allows packets to be altered before they leave the host.
</span><span class="koboSpan" id="kobo.65.3"># sudo iptables -t nat -nL POSTROUTING
Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
...
</span><span class="koboSpan" id="kobo.65.4">MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0
...</span></strong></pre>
<p><span class="koboSpan" id="kobo.66.1">On the other hand, as regards the inbound traffic, docker creates a custom filter chain on prerouting and </span><span><span class="koboSpan" id="kobo.67.1">dynamically </span></span><span><span class="koboSpan" id="kobo.68.1">creates forwarding rules in the</span></span> <kbd><span class="koboSpan" id="kobo.69.1">DOCKER</span></kbd> <span><span class="koboSpan" id="kobo.70.1">filter chain. </span><span class="koboSpan" id="kobo.70.2">If we expose a container port,</span></span> <kbd><span class="koboSpan" id="kobo.71.1">8080</span></kbd><span class="koboSpan" id="kobo.72.1">, </span><span><span class="koboSpan" id="kobo.73.1">and map it to a host port, </span></span><kbd><span class="koboSpan" id="kobo.74.1">8000</span></kbd><span><span class="koboSpan" id="kobo.75.1">, we can see that we're listening to port</span></span> <kbd><span class="koboSpan" id="kobo.76.1">8000</span></kbd> <span><span class="koboSpan" id="kobo.77.1">on any IP address (</span></span><kbd><span class="koboSpan" id="kobo.78.1">0.0.0.0/0</span></kbd><span><span class="koboSpan" id="kobo.79.1">), which will then be routed to container port</span></span> <kbd><span class="koboSpan" id="kobo.80.1">8080</span></kbd><span><span class="koboSpan" id="kobo.81.1">:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.82.1">// list iptables nat rules
# sudo iptables -t nat -nL
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination
...
</span><span class="koboSpan" id="kobo.82.2">DOCKER     all  --  0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL
...
</span><span class="koboSpan" id="kobo.82.3">Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
DOCKER     all  --  0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL
...
</span><span class="koboSpan" id="kobo.82.4">Chain DOCKER (2 references)
target     prot opt source               destination
RETURN     all  --  0.0.0.0/0            0.0.0.0/0
...
</span><span class="koboSpan" id="kobo.82.5">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:8000 to:172.17.0.7:8080
...</span></strong></pre>
<p><span class="koboSpan" id="kobo.83.1">Now that we know how a packet goes in/out of containers, let's look at how containers in a pod communicate with each other.</span></p>
<div class="packt_infobox"><span class="packt_screen"><span class="koboSpan" id="kobo.84.1">User-defined custom bridges</span></span><span class="koboSpan" id="kobo.85.1">:</span><br/><span class="koboSpan" id="kobo.86.1">
As well as the default bridge network, docker also supports user-defined bridges. </span><span class="koboSpan" id="kobo.86.2">Users can create the custom bridge on the fly. </span><span class="koboSpan" id="kobo.86.3">This provides better network isolation, supports DNS resolution through embedded DNS server, and can be attached and detached from the container at runtime. </span><span class="koboSpan" id="kobo.86.4">For more information, please refer to the following documentation: </span><a href="https://docs.docker.com/network/bridge/#manage-a-user-defined-bridge"><span class="koboSpan" id="kobo.87.1">https://docs.docker.com/network/bridge/#manage-a-user-defined-bridge</span></a><span class="koboSpan" id="kobo.88.1">.</span><a href="https://docs.docker.com/network/bridge/#manage-a-user-defined-bridge"><br/>
<br/></a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Container-to-container communications</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Pods in Kubernetes have their own real IP addresses. </span><span class="koboSpan" id="kobo.2.2">Containers within a pod share network namespace, so they see each other as </span><em><span class="koboSpan" id="kobo.3.1">localhost</span></em><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">This is implemented by the </span><strong><span class="koboSpan" id="kobo.5.1">network container</span></strong><span class="koboSpan" id="kobo.6.1"> by default, which acts as a bridge to dispatch traffic for every container in a pod. </span><span class="koboSpan" id="kobo.6.2">Let's see how this works in the following example. </span><span class="koboSpan" id="kobo.6.3">Let's use the first example from </span><span class="ChapterrefPACKT"><a href="a5cf080a-372a-406e-bb48-019af313c676.xhtml"><span class="koboSpan" id="kobo.7.1">Chapter 3</span></a><span class="koboSpan" id="kobo.8.1">, </span><em><span class="koboSpan" id="kobo.9.1">Getting Started with Kubernetes</span></em></span><span class="koboSpan" id="kobo.10.1">, which includes two containers, </span><kbd><span class="koboSpan" id="kobo.11.1">nginx</span></kbd><span class="koboSpan" id="kobo.12.1"> and </span><kbd><span class="koboSpan" id="kobo.13.1">centos</span></kbd><span class="koboSpan" id="kobo.14.1">, inside one pod:</span></p>
<pre><strong><span class="koboSpan" id="kobo.15.1">#cat 6-1-1_pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: example
spec:
  containers:
   - name: web
     image: nginx
   - name: centos
     image: centos
     command: ["/bin/sh", "-c", "while : ;do curl http://localhost:80/; sleep 10; done"]
  </span></strong><br/><strong><span class="koboSpan" id="kobo.16.1">  
// create the Pod
#kubectl create -f 6-1-1_pod.yaml
pod/example created</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.17.1">Then, we will describe the pod and look at its </span><kbd><span class="koboSpan" id="kobo.18.1">Container ID</span></kbd><span class="koboSpan" id="kobo.19.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.20.1"># kubectl describe pods example
Name:       example
Node:       minikube/192.168.99.100
...
</span><span class="koboSpan" id="kobo.20.2">Containers:
  web:
    Container ID: docker:// d9bd923572ab186870284535044e7f3132d5cac11ecb18576078b9c7bae86c73
    Image:        nginx
...
</span><span class="koboSpan" id="kobo.20.3">centos:
    Container ID: docker: //f4c019d289d4b958cd17ecbe9fe22a5ce5952cb380c8ca4f9299e10bf5e94a0f
    Image:        centos
...</span></strong></pre>
<p><span class="koboSpan" id="kobo.21.1">In this example, </span><kbd><span class="koboSpan" id="kobo.22.1">web</span></kbd><span class="koboSpan" id="kobo.23.1"> has the container ID </span><kbd><span class="koboSpan" id="kobo.24.1">d9bd923572ab</span></kbd><span class="koboSpan" id="kobo.25.1">, and </span><kbd><span class="koboSpan" id="kobo.26.1">centos</span></kbd><span class="koboSpan" id="kobo.27.1"> has the container ID </span><kbd><span class="koboSpan" id="kobo.28.1">f4c019d289d4</span></kbd><span class="koboSpan" id="kobo.29.1">. </span><span class="koboSpan" id="kobo.29.2">If we go into the </span><kbd><span class="koboSpan" id="kobo.30.1">minikube/192.168.99.100</span></kbd><span class="koboSpan" id="kobo.31.1"> node using </span><kbd><span class="koboSpan" id="kobo.32.1">docker ps</span></kbd><span class="koboSpan" id="kobo.33.1">, we can check how many containers Kubernetes actually launches since we're in minikube, which launches lots of other cluster containers. </span><span class="koboSpan" id="kobo.33.2">Check out the latest launch time by using the </span><kbd><span class="koboSpan" id="kobo.34.1">CREATED</span></kbd><span class="koboSpan" id="kobo.35.1"> column, where we will find that there are three containers that have just been launched:</span></p>
<pre><strong><span class="koboSpan" id="kobo.36.1"># docker ps
CONTAINER ID        IMAGE                                      COMMAND                  CREATED             STATUS              PORTS                                      NAMES
f4c019d289d4        36540f359ca3                               "/bin/sh -c 'while : "   2 minutes ago        Up 2 minutes k8s_centos_example_default_9843fc27-677b-11e7-9a8c-080027cafd37_1
d9bd923572ab        e4e6d42c70b3                               "nginx -g 'daemon off"   2 minutes ago        Up 2 minutes k8s_web_example_default_9843fc27-677b-11e7-9a8c-080027cafd37_1
4ddd3221cc47        gcr.io/google_containers/pause-amd64:3.0   "/pause"                 2 minutes ago        Up 2 minutes  </span></strong></pre>
<p><span class="koboSpan" id="kobo.37.1">There is an additional container, </span><kbd><span class="koboSpan" id="kobo.38.1">4ddd3221cc47</span></kbd><span class="koboSpan" id="kobo.39.1">, that was launched. </span><span class="koboSpan" id="kobo.39.2">Before digging into which container it is, let's check the network mode of our </span><kbd><span class="koboSpan" id="kobo.40.1">web</span></kbd><span class="koboSpan" id="kobo.41.1"> container. </span><span class="koboSpan" id="kobo.41.2">We will find that the containers in our example pod are running in containers with a mapped container mode:</span></p>
<pre><strong><span class="koboSpan" id="kobo.42.1"># docker inspect d9bd923572ab | grep NetworkMode
"NetworkMode": "container:4ddd3221cc4792207ce0a2b3bac5d758a5c7ae321634436fa3e6dd627a31ca76",</span></strong></pre>
<p><span class="koboSpan" id="kobo.43.1">The </span><kbd><span class="koboSpan" id="kobo.44.1">4ddd3221cc47</span></kbd><span class="koboSpan" id="kobo.45.1"> container is the so-called network container in this case. </span><span class="koboSpan" id="kobo.45.2">This holds the network namespace to let the </span><kbd><span class="koboSpan" id="kobo.46.1">web</span></kbd><span class="koboSpan" id="kobo.47.1"> and </span><kbd><span class="koboSpan" id="kobo.48.1">centos</span></kbd><span class="koboSpan" id="kobo.49.1"> containers join. </span><span class="koboSpan" id="kobo.49.2">Containers in the same network namespace share the same IP address and network configuration. </span><span class="koboSpan" id="kobo.49.3">This is the default implementation in Kubernetes for achieving container-to-container communications, which is mapped to the first requirement.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Pod-to-pod communications</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Pod IP addresses are accessible from other pods, no matter which nodes they're on. </span><span class="koboSpan" id="kobo.2.2">This fits the second requirement. </span><span class="koboSpan" id="kobo.2.3">We'll describe the pods' communication within the same node and across nodes in the upcoming section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Pod communication within the same node</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Pod-to-pod communication within the same node goes through the bridge by default. </span><span class="koboSpan" id="kobo.2.2">Let's say we have two pods that have their own network namespaces. </span><span class="koboSpan" id="kobo.2.3">When pod 1 wants to talk to pod 2, the packet passes through pod 1's namespace to the corresponding </span><kbd><span class="koboSpan" id="kobo.3.1">veth</span></kbd><span class="koboSpan" id="kobo.4.1"> pair, </span><kbd><strong><span class="koboSpan" id="kobo.5.1">vethXXXX</span></strong></kbd><span class="koboSpan" id="kobo.6.1">, and eventually goes to the bridge. </span><span class="koboSpan" id="kobo.6.2">The bridge then broadcasts the destination IP to help the packet find its way. </span><kbd><span class="koboSpan" id="kobo.7.1">vethYYYY</span></kbd><span class="koboSpan" id="kobo.8.1"> responds with the broadcasts. </span><span class="koboSpan" id="kobo.8.2">The packet then arrives at pod 2:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.9.1"><img class=" image-border" src="assets/766d9c4b-d680-429b-af61-4f0f3e5325f9.png" style="width:40.17em;height:34.33em;"/></span></div>
<p><span class="koboSpan" id="kobo.10.1">Now that we know how the packet travels in a single node, we will move on and talk about how traffic gets routed when the pods are in different nodes.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Pod communication across nodes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">According to the second requirement, all nodes must communicate with all containers. </span><span class="koboSpan" id="kobo.2.2">Kubernetes delegates implementation to the </span><strong><span class="koboSpan" id="kobo.3.1">container network interface</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">CNI</span></strong><span class="koboSpan" id="kobo.6.1">). </span><span class="koboSpan" id="kobo.6.2">Users can choose different implementations, by L2, L3, or overlay. </span><span class="koboSpan" id="kobo.6.3">Overlay networking, also known as packet encapsulation, is one of the most common solutions. </span><span class="koboSpan" id="kobo.6.4">This wraps a message before leaving the source, delivers it, and unwraps the message at its destination. </span><span class="koboSpan" id="kobo.6.5">This leads to a situation in which the overlay increases the network latency and complexity. </span><span class="koboSpan" id="kobo.6.6">As long as all the containers can access each other across nodes, you're free to use any technology, such as L2 adjacency or the L3 gateway. </span><span class="koboSpan" id="kobo.6.7">For more information about CNI, refer to its spec (</span><a href="https://github.com/containernetworking/cni/blob/master/SPEC.md" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.7.1">https://github.com/containernetworking/cni/blob/master/SPEC.md</span></span></a><span class="koboSpan" id="kobo.8.1">):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.9.1"><img src="assets/f8a72fe0-d350-4899-916f-39d07a47b72f.png" style="width:68.33em;height:47.25em;"/></span></div>
<p><span class="koboSpan" id="kobo.10.1">Let's say we have a packet moving from pod 1 to pod 4. </span><span class="koboSpan" id="kobo.10.2">The packet leaves the container interface and reaches the </span><kbd><span class="koboSpan" id="kobo.11.1">veth</span></kbd><span class="koboSpan" id="kobo.12.1"> pair, and then passes through the bridge and the node's network interface. </span><span class="koboSpan" id="kobo.12.2">Network implementation comes into play in step 4. </span><span class="koboSpan" id="kobo.12.3">As long as the packet can be routed to the target node, you are free to use any options. </span><span class="koboSpan" id="kobo.12.4">In the following example, we'll launch minikube with the </span><kbd><span class="koboSpan" id="kobo.13.1">--network-plugin=cni</span></kbd><span class="koboSpan" id="kobo.14.1"> option. </span><span class="koboSpan" id="kobo.14.2">With CNI enabled, the parameters will be passed through kubelet in the node. </span><span class="koboSpan" id="kobo.14.3">Kubelet has a default network plugin, but you can probe any supported plugin when it starts up. </span><span class="koboSpan" id="kobo.14.4">Before starting </span><kbd><span class="koboSpan" id="kobo.15.1">minikube</span></kbd><span class="koboSpan" id="kobo.16.1">, you can use </span><kbd><span class="koboSpan" id="kobo.17.1">minikube stop</span></kbd><span class="koboSpan" id="kobo.18.1"> first if it has been started or </span><kbd><span class="koboSpan" id="kobo.19.1">minikube delete</span></kbd><span class="koboSpan" id="kobo.20.1"> to delete the whole cluster thoroughly before doing anything else. </span><span class="koboSpan" id="kobo.20.2">Although </span><kbd><span class="koboSpan" id="kobo.21.1">minikube</span></kbd><span class="koboSpan" id="kobo.22.1"> is a single node environment that might not completely represent the production scenario we'll encounter, this just gives you a basic idea of how all of this works. </span><span class="koboSpan" id="kobo.22.2">We will learn about the deployment of networking options in the real world in </span><a href="acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.23.1">Chapter 9</span></span></a><span class="koboSpan" id="kobo.24.1">, </span><em><span class="koboSpan" id="kobo.25.1">Continuous Delivery</span></em><span class="koboSpan" id="kobo.26.1">, and </span><a href="f55d3fa8-e791-4473-83ba-ed8c4f848a90.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.27.1">Chapter 10</span></span></a><span class="koboSpan" id="kobo.28.1">, </span><em><span class="koboSpan" id="kobo.29.1">Kubernetes on AWS</span></em><span class="koboSpan" id="kobo.30.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.31.1">// start minikube with cni option
# minikube start --network-plugin=cni
...
</span><span class="koboSpan" id="kobo.31.2">Loading cached images from config file.</span><br/><span class="koboSpan" id="kobo.32.1">Everything looks great. </span><span class="koboSpan" id="kobo.32.2">Please enjoy minikube!</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.33.1">When we specify the </span><kbd><span class="koboSpan" id="kobo.34.1">network-plugin</span></kbd><span class="koboSpan" id="kobo.35.1"> option, </span><kbd><span class="koboSpan" id="kobo.36.1">minikube</span></kbd><span class="koboSpan" id="kobo.37.1"> will use the directory specified in </span><kbd><span class="koboSpan" id="kobo.38.1">--network-plugin-dir</span></kbd><span class="koboSpan" id="kobo.39.1"> for plugins on startup. </span><span class="koboSpan" id="kobo.39.2">In the CNI plugin, the default plugin directory is </span><kbd><span class="koboSpan" id="kobo.40.1">/opt/cni/net.d</span></kbd><span class="koboSpan" id="kobo.41.1">. </span><span class="koboSpan" id="kobo.41.2">After the cluster comes up, we can log into the node and look at the network interface configuration inside the minikube via </span><kbd><span class="koboSpan" id="kobo.42.1">minikube ssh</span></kbd><span class="koboSpan" id="kobo.43.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.44.1"># minikube ssh
$ ifconfig 
...
</span><span class="koboSpan" id="kobo.44.2">mybridge  Link encap:Ethernet  HWaddr 0A:58:0A:01:00:01
          inet addr:10.1.0.1  Bcast:0.0.0.0  </span></strong><br/><strong><span class="koboSpan" id="kobo.45.1">          Mask:255.255.0.0
...</span></strong></pre>
<p><span class="koboSpan" id="kobo.46.1">We will find that there is one new bridge in the node, and if we create the example pod again by using </span><kbd><span class="koboSpan" id="kobo.47.1">5-1-1_pod.yml</span></kbd><span class="koboSpan" id="kobo.48.1">, we will find that the IP address of the pod becomes </span><kbd><span class="koboSpan" id="kobo.49.1">10.1.0.x</span></kbd><span class="koboSpan" id="kobo.50.1">, which is attaching to </span><kbd><span class="koboSpan" id="kobo.51.1">mybridge</span></kbd><span class="koboSpan" id="kobo.52.1"> instead of </span><kbd><span class="koboSpan" id="kobo.53.1">docker0</span></kbd><span class="koboSpan" id="kobo.54.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.55.1"># kubectl create -f 6-1-1_pod.yaml
pod/example created
# kubectl describe po example
Name:       example
Namespace:  default
Node:       minikube/10.0.2.15
Start Time: Sun, 23 Jul 2017 14:24:24 -0400
Labels:           &lt;none&gt;
Annotations:      &lt;none&gt;
Status:           Running
IP:         10.1.0.4  </span></strong></pre>
<p><span class="koboSpan" id="kobo.56.1">This is because we have specified that we'll use CNI as the network plugin, and </span><kbd><span class="koboSpan" id="kobo.57.1">docker0</span></kbd><span class="koboSpan" id="kobo.58.1"> will not be used (also known as the </span><strong><span class="koboSpan" id="kobo.59.1">container network model</span></strong><span class="koboSpan" id="kobo.60.1">, or </span><strong><span class="koboSpan" id="kobo.61.1">libnetwork</span></strong><span class="koboSpan" id="kobo.62.1">). </span><span class="koboSpan" id="kobo.62.2">The CNI creates a virtual interface, attaches it to the underlay network, sets the IP address, and </span><span><span class="koboSpan" id="kobo.63.1">eventually </span></span><span><span class="koboSpan" id="kobo.64.1">routes and maps it to the pods' namespace. </span><span class="koboSpan" id="kobo.64.2">Let's take a</span></span><span class="koboSpan" id="kobo.65.1"> look </span><span><span class="koboSpan" id="kobo.66.1">at the configuration that's located at</span></span> <kbd><span class="koboSpan" id="kobo.67.1">/etc/cni/net.d/k8s.conf</span></kbd> <span><span class="koboSpan" id="kobo.68.1">in minikube:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.69.1"># cat /etc/cni/net.d/k8s.conf
{
  "name": "rkt.kubernetes.io",
  "type": "bridge",
  "bridge": "mybridge",
  "mtu": 1460,
  "addIf": "true",
  "isGateway": true,
  "ipMasq": true,
  "ipam": {
    "type": "host-local",
    "subnet": "10.1.0.0/16",
    "gateway": "10.1.0.1",
    "routes": [
      {
       "dst": "0.0.0.0/0"
      }
    ]
  }
}</span></strong></pre>
<p><span class="koboSpan" id="kobo.70.1">In this example, we are using the bridge CNI plugin to reuse the L2 bridge for pod containers. </span><span class="koboSpan" id="kobo.70.2">If the packet is from </span><kbd><span class="koboSpan" id="kobo.71.1">10.1.0.0/16</span></kbd><span class="koboSpan" id="kobo.72.1">, and its destination is to anywhere, it'll go through this gateway. </span><span class="koboSpan" id="kobo.72.2">Just like the diagram we saw earlier, we could have another node with CNI enabled with the </span><kbd><span class="koboSpan" id="kobo.73.1">10.1.2.0/16</span></kbd><span class="koboSpan" id="kobo.74.1"> subnet so that ARP packets can go out to the physical interface on the node where the target pod is located. </span><span class="koboSpan" id="kobo.74.2">This then achieves pod-to-pod communication across nodes.</span></p>
<p><span class="koboSpan" id="kobo.75.1">Let's check the rules in </span><kbd><span class="koboSpan" id="kobo.76.1">iptables</span></kbd><span class="koboSpan" id="kobo.77.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.78.1">// check the rules in iptables 
# sudo iptables -t nat -nL
... 
</span><span class="koboSpan" id="kobo.78.2">Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
KUBE-POSTROUTING  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes postrouting rules */
MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0
CNI-25df152800e33f7b16fc085a  all  --  10.1.0.0/16          0.0.0.0/0            /* name: "rkt.kubernetes.io" id: "328287949eb4d4483a3a8035d65cc326417ae7384270844e59c2f4e963d87e18" */
CNI-f1931fed74271104c4d10006  all  --  10.1.0.0/16          0.0.0.0/0            /* name: "rkt.kubernetes.io" id: "08c562ff4d67496fdae1c08facb2766ca30533552b8bd0682630f203b18f8c0a" */</span></strong></pre>
<p><span class="koboSpan" id="kobo.79.1">All the related rules have been switched to </span><kbd><span class="koboSpan" id="kobo.80.1">10.1.0.0/16</span></kbd><span class="koboSpan" id="kobo.81.1"> CIDR.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Pod-to-service communications</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Kubernetes is dynamic. </span><span class="koboSpan" id="kobo.2.2">Pods are created and deleted all the time. </span><span class="koboSpan" id="kobo.2.3">The Kubernetes service is an abstraction to define a set of pods by label selectors. </span><span class="koboSpan" id="kobo.2.4">We normally use the service to access pods instead of specifying a pod explicitly. </span><span class="koboSpan" id="kobo.2.5">When we create a service, an </span><kbd><span class="koboSpan" id="kobo.3.1">endpoint</span></kbd><span class="koboSpan" id="kobo.4.1"> object will be created, which describes a set of pod IPs that the label selector in that service has selected.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.5.1">In some cases, the </span><kbd><span class="koboSpan" id="kobo.6.1">endpoint</span></kbd><span class="koboSpan" id="kobo.7.1"> object will not be created upon creation of the service. </span><span class="koboSpan" id="kobo.7.2">For example, services without selectors will not create a corresponding </span><kbd><span class="koboSpan" id="kobo.8.1">endpoint</span></kbd><span class="koboSpan" id="kobo.9.1"> object. </span><span class="koboSpan" id="kobo.9.2">For more information, refer to the </span><em><span class="koboSpan" id="kobo.10.1">S</span><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.11.1">ervice without selectors</span></span></em><span class="koboSpan" id="kobo.12.1"> section in </span><span class="ChapterrefPACKT"><a href="a5cf080a-372a-406e-bb48-019af313c676.xhtml"><span class="koboSpan" id="kobo.13.1">Chapter 3</span></a><span class="koboSpan" id="kobo.14.1">, </span><em><span class="koboSpan" id="kobo.15.1">Getting Started with Kubernetes</span></em></span><span class="koboSpan" id="kobo.16.1">.</span></div>
<p><span class="koboSpan" id="kobo.17.1">So, how does traffic get from pod to the pod behind the service? </span><span class="koboSpan" id="kobo.17.2">By default, Kubernetes uses </span><kbd><span class="koboSpan" id="kobo.18.1">iptables</span></kbd><span class="koboSpan" id="kobo.19.1"> to perform this magic, and does so by using </span><kbd><span class="koboSpan" id="kobo.20.1">kube-proxy</span></kbd><span class="koboSpan" id="kobo.21.1">. </span><span class="koboSpan" id="kobo.21.2">This is explained in the following diagram:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.22.1"><img class=" image-border" src="assets/db7f1486-dc97-4352-8dd9-05253454ae78.png" style="width:33.42em;height:34.08em;"/></span></div>
<p><span><span class="koboSpan" id="kobo.23.1">Let's reuse the</span></span> <kbd><span class="koboSpan" id="kobo.24.1">3-2-3_rc1.yaml</span></kbd> <span><span class="koboSpan" id="kobo.25.1">and</span></span> <kbd><span class="koboSpan" id="kobo.26.1">3-2-3_nodeport.yaml</span></kbd> <span><span class="koboSpan" id="kobo.27.1">examples from</span></span> <a href="a5cf080a-372a-406e-bb48-019af313c676.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.28.1">Chapter 3</span></span></a><span><span class="koboSpan" id="kobo.29.1">,</span></span> <em><span class="koboSpan" id="kobo.30.1">Getting Started with Kubernetes</span></em><span><span class="koboSpan" id="kobo.31.1">, to observe the default behavior:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.32.1">// create two pods with nginx and one service to observe default networking. </span><span class="koboSpan" id="kobo.32.2">Users are free to use any other kind of solution.
</span><span class="koboSpan" id="kobo.32.3"># kubectl create -f chapter3/3-2-3_Service/3-2-3_rs1.yaml
replicaset.apps/nginx-1.12 created
# kubectl create -f chapter3/3-2-3_Service/3-2-3_nodeport.yaml
service/nginx-nodeport created </span></strong></pre>
<p><span class="koboSpan" id="kobo.33.1">Let's observe the </span><kbd><span class="koboSpan" id="kobo.34.1">iptable</span></kbd><span class="koboSpan" id="kobo.35.1"> rules and see how this works. </span><span class="koboSpan" id="kobo.35.2">As you can see in the following code, our service IP is </span><kbd><span class="koboSpan" id="kobo.36.1">10.0.0.167</span></kbd><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">The two pods' IP addresses underneath are </span><kbd><span class="koboSpan" id="kobo.38.1">10.1.0.4</span></kbd><span class="koboSpan" id="kobo.39.1"> and </span><kbd><span class="koboSpan" id="kobo.40.1">10.1.0.5</span></kbd><span class="koboSpan" id="kobo.41.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.42.1"># kubectl describe svc nginx-nodeport
Name:             nginx-nodeport
Namespace:        default
Selector:         project=chapter3,service=web
Type:             NodePort
IP:               10.0.0.167
Port:             &lt;unset&gt;     80/TCP
NodePort:         &lt;unset&gt;     32261/TCP
Endpoints:        10.1.0.4:80,10.1.0.5:80
...</span></strong></pre>
<p><span class="koboSpan" id="kobo.43.1">Let's get into the minikube node by using </span><kbd><span class="koboSpan" id="kobo.44.1">minikube ssh</span></kbd><span class="koboSpan" id="kobo.45.1"> and check its </span><kbd><span class="koboSpan" id="kobo.46.1">iptables</span></kbd><span class="koboSpan" id="kobo.47.1"> rules:</span></p>
<pre><strong><span class="koboSpan" id="kobo.48.1"># sudo iptables -t nat -nL
...
</span><span class="koboSpan" id="kobo.48.2">Chain KUBE-SERVICES (2 references)
target     prot opt source               destination
KUBE-SVC-37ROJ3MK6RKFMQ2B  tcp  --  0.0.0.0/0            10.0.0.167           /* default/nginx-nodeport: cluster IP */ tcp dpt:80
KUBE-NODEPORTS  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes service nodeports; NOTE: this must be the last rule in this chain */ ADDRTYPE match dst-type LOCAL
    
Chain KUBE-SVC-37ROJ3MK6RKFMQ2B (2 references)
target     prot opt source               destination
KUBE-SEP-SVVBOHTYP7PAP3J5  all  --  0.0.0.0/0            0.0.0.0/0            /* default/nginx-nodeport: */ statistic mode random probability 0.50000000000
KUBE-SEP-AYS7I6ZPYFC6YNNF  all  --  0.0.0.0/0            0.0.0.0/0            /* default/nginx-nodeport: */
Chain KUBE-SEP-SVVBOHTYP7PAP3J5 (1 references)
target     prot opt source               destination
KUBE-MARK-MASQ  all  --  10.1.0.4             0.0.0.0/0            /* default/nginx-nodeport: */
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/nginx-nodeport: */ tcp to:10.1.0.4:80
Chain KUBE-SEP-AYS7I6ZPYFC6YNNF (1 references)
target     prot opt source               destination
KUBE-MARK-MASQ  all  --  10.1.0.5             0.0.0.0/0            /* default/nginx-nodeport: */
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/nginx-nodeport: */ tcp to:10.1.0.5:80
... </span></strong> </pre>
<p><span class="koboSpan" id="kobo.49.1">The key point here is that the service exposes the cluster IP to outside traffic from </span><kbd><span class="KeyPACKT"><span class="koboSpan" id="kobo.50.1">KUBE-SVC-37ROJ3MK6RKFMQ2B</span></span></kbd><span class="koboSpan" id="kobo.51.1">, which links to two custom chains, </span><kbd><span class="KeyPACKT"><span class="koboSpan" id="kobo.52.1">KUBE-SEP-SVVBOHTYP7PAP3J5</span></span></kbd><span class="koboSpan" id="kobo.53.1"> and </span><kbd><span class="KeyPACKT"><span class="koboSpan" id="kobo.54.1">KUBE-SEP-AYS7I6ZPYFC6YNNF</span></span></kbd><span class="koboSpan" id="kobo.55.1">, with a statistic mode random probability of 0.5. </span><span class="koboSpan" id="kobo.55.2">This means that </span><kbd><span class="koboSpan" id="kobo.56.1">iptables</span></kbd><span class="koboSpan" id="kobo.57.1"> will generate a random number and tune it based on the probability distribution of 0.5 to the destination. </span><span class="koboSpan" id="kobo.57.2">These two custom chains have the </span><kbd><span class="koboSpan" id="kobo.58.1">DNAT</span></kbd><span class="koboSpan" id="kobo.59.1"> target set to the corresponding pod IP. </span><span class="koboSpan" id="kobo.59.2">The </span><kbd><span class="koboSpan" id="kobo.60.1">DNAT</span></kbd><span class="koboSpan" id="kobo.61.1"> target is responsible for changing the packets' destination IP address. </span><span class="koboSpan" id="kobo.61.2">By default, conntrack is enabled to track the destination and source of connection when the traffic comes in. </span><span class="koboSpan" id="kobo.61.3">All of this results in a routing behavior. </span><span class="koboSpan" id="kobo.61.4">When the traffic comes to the service, </span><kbd><span class="koboSpan" id="kobo.62.1">iptables</span></kbd><span class="koboSpan" id="kobo.63.1"> will randomly pick one of the pods to route and modify the destination IP from the service IP to the real pod IP. </span><span class="koboSpan" id="kobo.63.2">It then gets the response and un-DNAT on the reply packets and sends them back to the requester.</span></p>
<div class="packt_infobox"><span class="packt_screen"><span class="koboSpan" id="kobo.64.1">IPVS-based kube-proxy</span></span><span class="koboSpan" id="kobo.65.1">:</span><br/><span class="koboSpan" id="kobo.66.1">
In Kubernetes 1.11, the IPVS-based </span><kbd><span class="koboSpan" id="kobo.67.1">kube-proxy</span></kbd><span class="koboSpan" id="kobo.68.1"> feature graduated to GA. </span><span class="koboSpan" id="kobo.68.2">This could deal with the scaling problem of </span><kbd><span class="koboSpan" id="kobo.69.1">iptables</span></kbd><span class="koboSpan" id="kobo.70.1"> to tens of thousands of services. </span><span class="koboSpan" id="kobo.70.2">The </span><strong><span class="koboSpan" id="kobo.71.1">IP Virtual Server</span></strong><span class="koboSpan" id="kobo.72.1"> (</span><strong><span><span class="koboSpan" id="kobo.73.1">IPVS</span></span></strong><span class="koboSpan" id="kobo.74.1">) is part of the Linux kernel, which can direct TCP or UDP requests to real servers. </span><kbd><span class="koboSpan" id="kobo.75.1">ipvs</span></kbd><span class="koboSpan" id="kobo.76.1"> proxier is a good fit if your application contains a huge number of services. </span><span class="koboSpan" id="kobo.76.2">However, it will fall back on </span><kbd><span class="koboSpan" id="kobo.77.1">iptables</span></kbd><span class="koboSpan" id="kobo.78.1"> in some specific cases. </span><span class="koboSpan" id="kobo.78.2">For more information, please refer to </span><a href="https://kubernetes.io/blog/2018/07/09/ipvs-based-in-cluster-load-balancing-deep-dive/"><span class="koboSpan" id="kobo.79.1">https://kubernetes.io/blog/2018/07/09/ipvs-based-in-cluster-load-balancing-deep-dive/</span></a><span class="koboSpan" id="kobo.80.1">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">External-to-service communications</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The ability to serve external traffic to Kubernetes is critical. </span><span class="koboSpan" id="kobo.2.2">Kubernetes provides two API objects to achieve this:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.3.1">Service</span></strong><span class="koboSpan" id="kobo.4.1">: External network LoadBalancer or NodePort (L4)</span></li>
<li><strong><span class="koboSpan" id="kobo.5.1">Ingress</span></strong><span class="koboSpan" id="kobo.6.1">: HTTP(S) LoadBalancer (L7)</span></li>
</ul>
<p><span class="koboSpan" id="kobo.7.1">We'll learn more about ingress in the next section. </span><span class="koboSpan" id="kobo.7.2">For now, we'll focus on the L4 service. </span><span class="koboSpan" id="kobo.7.3">Based on what we've learned about pod-to-pod communication across nodes, the packet goes in and out between the service and pod. </span><span class="koboSpan" id="kobo.7.4">The following diagram is an illustration of this process. </span><span class="koboSpan" id="kobo.7.5">Let's say we have two services: service A has three pods (pod a, pod b, and pod c) and service B gets only one pod (pod d). </span><span class="koboSpan" id="kobo.7.6">When the traffic comes in from the LoadBalancer, the packet will be dispatched to one of the nodes. </span><span class="koboSpan" id="kobo.7.7">Most of the LoadBalancer </span><span><span class="koboSpan" id="kobo.8.1">cloud</span></span><span><span class="koboSpan" id="kobo.9.1"> </span></span><span><span class="koboSpan" id="kobo.10.1">itself is not aware of pods or containers; it only knows about the node. </span><span class="koboSpan" id="kobo.10.2">If the node passes the health check, then it will be the candidate for the destination.</span></span></p>
<p><span><span class="koboSpan" id="kobo.11.1">Let's assume that we want to access service B; this currently only has one pod running on one node. </span><span class="koboSpan" id="kobo.11.2">However, LoadBalancer sends the packet to another node that doesn't have any of our desired pods running. </span><span class="koboSpan" id="kobo.11.3">In this case, the traffic route will look like this:</span></span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1"><img class=" image-border" src="assets/baef9510-6fb1-4435-9ae0-862dc2d234bf.png" style="width:43.08em;height:21.00em;"/></span></div>
<p class="packt_figure CDPAlignLeft CDPAlign"><span><span class="koboSpan" id="kobo.13.1">The packet routing journey will be as follows:</span></span></p>
<ol start="1">
<li><span class="koboSpan" id="kobo.14.1">LoadBalancer will choose one of the nodes to forward to the packet. </span><span class="koboSpan" id="kobo.14.2">In GCE, it selects the instance based on a hash of the source IP and port, destination IP and port, and protocol. </span><span class="koboSpan" id="kobo.14.3">In AWS, load balancing is based on a round-robin algorithm.</span></li>
<li><span class="koboSpan" id="kobo.15.1">Here, the routing destination will be changed to pod d (DNAT) and will forward the packet to the other node, similar to pod-to-pod communication across nodes.</span></li>
<li><span class="koboSpan" id="kobo.16.1">Then comes service-to-pod communication. </span><span class="koboSpan" id="kobo.16.2">The packet arrives at pod d and pod d returns the response.</span></li>
<li><span class="koboSpan" id="kobo.17.1">Pod-to-service communication is manipulated by </span><kbd><span class="koboSpan" id="kobo.18.1">iptables</span></kbd><span class="koboSpan" id="kobo.19.1"> as well.</span></li>
<li><span class="koboSpan" id="kobo.20.1">The packet will be forwarded to the original node.</span></li>
<li><span class="koboSpan" id="kobo.21.1">The source and destination will be un-DNAT to the LoadBalancer and client, and will be sent all the way back to the requester.</span></li>
</ol>
<div class="packt_infobox"><span class="koboSpan" id="kobo.22.1">From Kubernetes 1.7, there is a new attribute in this service called </span><kbd><span class="koboSpan" id="kobo.23.1">externalTrafficPolicy</span></kbd><span class="koboSpan" id="kobo.24.1">. </span><span class="koboSpan" id="kobo.24.2">Here, you can set its value to local, and then, after the traffic goes into a node, Kubernetes will route the pods on that node if possible, as follows:</span><br/>
<strong><kbd><span class="koboSpan" id="kobo.25.1">kubectl patch $service_name nodeport -p '{"spec":{"externalTrafficPolicy":"Local"}}'</span></kbd></strong></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Ingress</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Pods and services in Kubernetes have their own IPs. </span><span class="koboSpan" id="kobo.2.2">However, this is normally not the interface you'd provide to the external internet. </span><span class="koboSpan" id="kobo.2.3">Though there is a service with a node IP configured, the port in the node IP can't be duplicated among the services. </span><span class="koboSpan" id="kobo.2.4">It is cumbersome to decide which port to manage with which service. </span><span class="koboSpan" id="kobo.2.5">Furthermore, the node comes and goes; it wouldn't be clever to provide a static node IP to an external service.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Ingress defines a set of rules that allows the inbound connection to access Kubernetes cluster services. </span><span class="koboSpan" id="kobo.3.2">This brings the traffic into the cluster at L7, and allocates and forwards a port on each VM to the service port. </span><span class="koboSpan" id="kobo.3.3">This is shown in the following diagram. </span><span class="koboSpan" id="kobo.3.4">We define a set of rules and post them as source type ingress to the API server. </span><span class="koboSpan" id="kobo.3.5">When the traffic comes in, the ingress controller will then fulfill and route the ingress according to the ingress rules. </span><span class="koboSpan" id="kobo.3.6">As shown in the following diagram, ingress is used to route external traffic to the kubernetes endpoints by different URLs:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1"><img src="assets/48b60b52-c612-47c2-9f77-169aa3f41111.png" style="width:24.50em;height:20.58em;"/></span></div>
<p><span class="koboSpan" id="kobo.5.1">Now, we will go through an example and see how this works. </span><span class="koboSpan" id="kobo.5.2">In this example, we'll create two services named </span><kbd><span class="koboSpan" id="kobo.6.1">nginx</span></kbd><span class="koboSpan" id="kobo.7.1"> and </span><kbd><span class="koboSpan" id="kobo.8.1">echoserver</span></kbd><span class="koboSpan" id="kobo.9.1">, with the ingress paths </span><kbd><span class="koboSpan" id="kobo.10.1">/welcome</span></kbd><span class="koboSpan" id="kobo.11.1"> and </span><kbd><span class="koboSpan" id="kobo.12.1">/echoserver</span></kbd><span class="koboSpan" id="kobo.13.1"> configured. </span><span class="koboSpan" id="kobo.13.2">We can run this in </span><kbd><span class="koboSpan" id="kobo.14.1">minikube</span></kbd><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">The old version of </span><kbd><span class="koboSpan" id="kobo.16.1">minikube</span></kbd><span class="koboSpan" id="kobo.17.1"> doesn't enable ingress by default; we'll have to enable it first:</span></p>
<pre><strong><span class="koboSpan" id="kobo.18.1">// start over our minikube local</span><br/><span class="koboSpan" id="kobo.19.1"># minikube delete &amp;&amp; minikube start
    
// enable ingress in minikube</span><br/><span class="koboSpan" id="kobo.20.1"># minikube addons enable ingress
ingress was successfully enabled 
    
// check current setting for addons in minikube
# minikube addons list
- registry: disabled
- registry-creds: disabled
- addon-manager: enabled
- dashboard: enabled
- default-storageclass: enabled
- kube-dns: enabled
- heapster: disabled
- ingress: enabled </span></strong></pre>
<p><span class="koboSpan" id="kobo.21.1">Enabling ingress in </span><kbd><span class="koboSpan" id="kobo.22.1">minikube</span></kbd><span class="koboSpan" id="kobo.23.1"> will create an </span><kbd><span class="koboSpan" id="kobo.24.1">nginx</span></kbd><span class="koboSpan" id="kobo.25.1"> ingress controller (</span><a href="https://github.com/kubernetes/ingress-nginx"><span class="koboSpan" id="kobo.26.1">https://github.com/kubernetes/ingress-nginx</span></a><span class="koboSpan" id="kobo.27.1">) and a </span><kbd><span class="koboSpan" id="kobo.28.1">ConfigMap</span></kbd><span class="koboSpan" id="kobo.29.1"> to store </span><kbd><span class="koboSpan" id="kobo.30.1">nginx</span></kbd><span class="koboSpan" id="kobo.31.1"> configuration, as well as a </span><kbd><span class="koboSpan" id="kobo.32.1">Deployment</span></kbd><span class="koboSpan" id="kobo.33.1"> and service as default HTTP backends for handling unmapped requests. </span><span class="koboSpan" id="kobo.33.2">We can observe these by adding </span><kbd><span class="koboSpan" id="kobo.34.1">--namespace=kube-system</span></kbd><span class="koboSpan" id="kobo.35.1"> in the </span><kbd><span class="koboSpan" id="kobo.36.1">kubectl</span></kbd><span class="koboSpan" id="kobo.37.1"> command. </span><span class="koboSpan" id="kobo.37.2">Next, let's create our backend resources. </span><span class="koboSpan" id="kobo.37.3">Here is our </span><kbd><span class="koboSpan" id="kobo.38.1">nginx</span></kbd> <kbd><span class="koboSpan" id="kobo.39.1">Deployment</span></kbd><span class="koboSpan" id="kobo.40.1"> and </span><kbd><span class="koboSpan" id="kobo.41.1">Service</span></kbd><span class="koboSpan" id="kobo.42.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.43.1"># cat chapter6/6-2-1_nginx.yaml</span><br/><span class="koboSpan" id="kobo.44.1">apiVersion: apps/v1</span></strong><br/><strong><span class="koboSpan" id="kobo.45.1">kind: Deployment</span></strong><br/><strong><span class="koboSpan" id="kobo.46.1">metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.47.1">  name: nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.48.1">spec:</span></strong><br/><strong><span class="koboSpan" id="kobo.49.1">  replicas: 2</span></strong><br/><strong><span class="koboSpan" id="kobo.50.1">  template:</span></strong><br/><strong><span class="koboSpan" id="kobo.51.1">    metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.52.1">    labels:</span></strong><br/><strong><span class="koboSpan" id="kobo.53.1">      project: chapter6</span></strong><br/><strong><span class="koboSpan" id="kobo.54.1">      service: nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.55.1">    spec:</span></strong><br/><strong><span class="koboSpan" id="kobo.56.1">      containers:</span></strong><br/><strong><span class="koboSpan" id="kobo.57.1">       - name: nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.58.1">         image: nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.59.1">         ports:</span></strong><br/><strong><span class="koboSpan" id="kobo.60.1">        - containerPort: 80</span></strong><br/><strong><span class="koboSpan" id="kobo.61.1">---</span></strong><br/><strong><span class="koboSpan" id="kobo.62.1">kind: Service</span></strong><br/><strong><span class="koboSpan" id="kobo.63.1">apiVersion: v1</span></strong><br/><strong><span class="koboSpan" id="kobo.64.1">metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.65.1">  name: nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.66.1">spec:</span></strong><br/><strong><span class="koboSpan" id="kobo.67.1">  type: NodePort</span></strong><br/><strong><span class="koboSpan" id="kobo.68.1">  selector:</span></strong><br/><strong><span class="koboSpan" id="kobo.69.1">    project: chapter6</span></strong><br/><strong><span class="koboSpan" id="kobo.70.1">    service: nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.71.1">  ports:</span></strong><br/><strong><span class="koboSpan" id="kobo.72.1">    - protocol: TCP</span></strong><br/><strong><span class="koboSpan" id="kobo.73.1">      port: 80</span></strong><br/><strong><span class="koboSpan" id="kobo.74.1">      targetPort: 80</span></strong><br/><strong><span class="koboSpan" id="kobo.75.1">// create nginx RS and service</span></strong><br/><strong><span class="koboSpan" id="kobo.76.1"># kubectl create -f chapter6/6-2-1_nginx.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.77.1">deployment.apps/nginx created</span></strong><br/><strong><span class="koboSpan" id="kobo.78.1">service/nginx created</span></strong></pre>
<p><span class="koboSpan" id="kobo.79.1">Then, we'll create another service with </span><kbd><span class="koboSpan" id="kobo.80.1">Deployment</span></kbd><span class="koboSpan" id="kobo.81.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.82.1">// another backend named echoserver</span><br/><span class="koboSpan" id="kobo.83.1"># cat chapter6/6-2-1_echoserver.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: echoserver
spec:
  replicas: 1
  template:
    metadata:
     name: echoserver
     labels:
      project: chapter6
      service: echoserver
   spec:
     containers:
     - name: echoserver
       image: gcr.io/google_containers/echoserver:1.4
      ports:
     - containerPort: 8080
---
    
kind: Service
apiVersion: v1
metadata:
  name: echoserver
spec:
  type: NodePort
  selector:
    project: chapter6
    service: echoserver
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
    
// create RS and SVC by above configuration file
# kubectl create -f chapter6/6-2-1_echoserver.yaml
deployment.apps/echoserver created</span><br/><span class="koboSpan" id="kobo.84.1">service/echoserver created</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.85.1">Next, we'll create the ingress resource. </span><span class="koboSpan" id="kobo.85.2">There is an annotation named </span><kbd><span class="koboSpan" id="kobo.86.1">nginx.ingress.kubernetes.io/rewrite-target</span></kbd><span class="koboSpan" id="kobo.87.1">. </span><span class="koboSpan" id="kobo.87.2">This is required if the </span><kbd><span class="koboSpan" id="kobo.88.1">service</span></kbd><span class="koboSpan" id="kobo.89.1"> requests are coming from the root URL. </span><span class="koboSpan" id="kobo.89.2">Without a rewrite annotation, we'll get </span><span class="packt_screen"><span class="koboSpan" id="kobo.90.1">404</span></span><span class="koboSpan" id="kobo.91.1"> as a response. </span><span class="koboSpan" id="kobo.91.2">Refer to </span><a href="https://github.com/kubernetes/ingress-nginx/tree/master/docs/examples/rewrite"><span class="koboSpan" id="kobo.92.1">https://github.com/kubernetes/ingress-nginx/tree/master/docs/examples/rewrite</span></a><span class="koboSpan" id="kobo.93.1"> for more annotation that's supported in the </span><kbd><span class="koboSpan" id="kobo.94.1">nginx</span></kbd><span class="koboSpan" id="kobo.95.1"> ingress controller:</span></p>
<pre><strong><span class="koboSpan" id="kobo.96.1"># cat chapter6/6-2-1_ingress.yaml
apiVersion: extensions/v1beta1</span><br/><span class="koboSpan" id="kobo.97.1">kind: Ingress</span><br/><span class="koboSpan" id="kobo.98.1">metadata:</span><br/><span class="koboSpan" id="kobo.99.1">  name: ingress-example</span><br/><span class="koboSpan" id="kobo.100.1">  annotations:</span><br/><span class="koboSpan" id="kobo.101.1">    nginx.ingress.kubernetes.io/rewrite-target: /</span><br/><span class="koboSpan" id="kobo.102.1">spec:</span><br/><span class="koboSpan" id="kobo.103.1">  rules:</span><br/><span class="koboSpan" id="kobo.104.1">  - host: devops.k8s</span><br/><span class="koboSpan" id="kobo.105.1">    http:</span><br/><span class="koboSpan" id="kobo.106.1">      paths:</span><br/><span class="koboSpan" id="kobo.107.1">      - path: /welcome</span><br/><span class="koboSpan" id="kobo.108.1">        backend:</span><br/><span class="koboSpan" id="kobo.109.1">          serviceName: nginx</span><br/><span class="koboSpan" id="kobo.110.1">          servicePort: 80</span><br/><span class="koboSpan" id="kobo.111.1">      - path: /echoserver</span><br/><span class="koboSpan" id="kobo.112.1">        backend:</span><br/><span class="koboSpan" id="kobo.113.1">          serviceName: echoserver</span><br/><span class="koboSpan" id="kobo.114.1">          servicePort: 8080
    
// create ingress
# kubectl create -f chapter6/6-2-1_ingress.yaml
ingress.extensions/ingress-example created</span><br/></strong></pre>
<div class="packt_infobox"><span class="koboSpan" id="kobo.115.1">In some cloud providers, the service LoadBalancer controller is supported. </span><span class="koboSpan" id="kobo.115.2">This can be integrated with ingress via the </span><kbd><span class="koboSpan" id="kobo.116.1">status.loadBalancer.ingress</span></kbd><span class="koboSpan" id="kobo.117.1"> syntax in the configuration file. </span><span class="koboSpan" id="kobo.117.2">For more information, refer to </span><a href="https://github.com/kubernetes/contrib/tree/master/service-loadbalancer" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.118.1">https://github.com/kubernetes/contrib/tree/master/service-loadbalancer</span></span></a><span class="koboSpan" id="kobo.119.1">.</span></div>
<p><span class="koboSpan" id="kobo.120.1">Since our host is set to </span><kbd><span class="koboSpan" id="kobo.121.1">devops.k8s</span></kbd><span class="koboSpan" id="kobo.122.1">, it will only return if we access it from that hostname. </span><span class="koboSpan" id="kobo.122.2">You could either configure the DNS record in the DNS server, or modify the host's file in local. </span><span class="koboSpan" id="kobo.122.3">For simplicity, we'll just add a line with the </span><kbd><span class="koboSpan" id="kobo.123.1">ip hostname</span></kbd><span class="koboSpan" id="kobo.124.1"> format in the host file:</span></p>
<pre><strong><span class="koboSpan" id="kobo.125.1">// normally host file located in /etc/hosts in linux
# sudo sh -c "echo `minikube ip` devops.k8s &gt;&gt; /etc/hosts"  </span></strong></pre>
<p><span class="koboSpan" id="kobo.126.1">Then, we should be able to access our service by the URL directly:</span></p>
<pre><strong><span class="koboSpan" id="kobo.127.1"># curl http://devops.k8s/welcome
...
</span><span class="koboSpan" id="kobo.127.2">&lt;title&gt;Welcome to nginx!&lt;/title&gt;
...
</span><span class="koboSpan" id="kobo.127.3">// check echoserver 
# curl http://devops.k8s/echoserver
CLIENT VALUES:
client_address=172.17.0.4
command=GET
real path=/
query=nil
request_version=1.1
request_uri=http://devops.k8s:8080/  </span></strong></pre>
<p><span class="koboSpan" id="kobo.128.1">The pod ingress controller dispatches the traffic based on the URL's path. </span><span class="koboSpan" id="kobo.128.2">The routing path is similar to external-to-service communication. </span><span class="koboSpan" id="kobo.128.3">The packet hops between nodes and pods. </span><span class="koboSpan" id="kobo.128.4">Kubernetes is pluggable; lots of third-party implementation is going on. </span><span class="koboSpan" id="kobo.128.5">We have only scratched the surface here, even though </span><kbd><span class="koboSpan" id="kobo.129.1">iptables</span></kbd><span class="koboSpan" id="kobo.130.1"> is just a default and common implementation. </span><span class="koboSpan" id="kobo.130.2">Networking evolves a lot with every single release. </span><span class="koboSpan" id="kobo.130.3">At the time of writing, Kubernetes had just released version 1.13.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Network policy</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The network policy works as a software firewall to the pods. </span><span class="koboSpan" id="kobo.2.2">By default, every pod can communicate with each other without any boundaries. </span><span class="koboSpan" id="kobo.2.3">The network policy is one of the isolations you could apply to these pods. </span><span class="koboSpan" id="kobo.2.4">This defines who can access which pods in which port by namespace selector and pod selector. </span><span class="koboSpan" id="kobo.2.5">The network policy in a namespace is additive, and once a pod enables the network policy, it denies any other ingress (also known as deny all).</span></p>
<p><span class="koboSpan" id="kobo.3.1">Currently, there are multiple network providers that support the network policy, such as Calico (</span><span class="URLPACKT"><a href="https://www.projectcalico.org/calico-network-policy-comes-to-kubernetes/" target="_blank"><span class="koboSpan" id="kobo.4.1">https://www.projectcalico.org/calico-network-policy-comes-to-kubernetes/</span></a><span class="koboSpan" id="kobo.5.1">),</span></span><span class="koboSpan" id="kobo.6.1"> Romana (</span><a href="https://github.com/romana/romana"><span class="URLPACKT"><span class="koboSpan" id="kobo.7.1">https://github.com/romana/romana</span></span></a><span class="koboSpan" id="kobo.8.1">), Weave Net (</span><a href="https://www.weave.works/docs/net/latest/kube-addon/#npc)"><span class="URLPACKT"><span class="koboSpan" id="kobo.9.1">https://www.weave.works/docs/net/latest/kube-addon/#npc</span></span></a><span class="koboSpan" id="kobo.10.1">), Contiv (</span><a href="http://contiv.github.io/documents/networking/policies.html)"><span class="URLPACKT"><span class="koboSpan" id="kobo.11.1">http://contiv.github.io/documents/networking/policies.html</span></span></a><span class="koboSpan" id="kobo.12.1">), and Trireme (</span><a href="https://github.com/aporeto-inc/trireme-kubernetes" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.13.1">https://github.com/aporeto-inc/trireme-kubernetes</span></span></a><span class="koboSpan" id="kobo.14.1">). </span><span class="koboSpan" id="kobo.14.2">Users are free to choose between any of these. </span><span class="koboSpan" id="kobo.14.3">For the purpose of simplicity, though, we're going to use Calico with minikube. </span><span class="koboSpan" id="kobo.14.4">To do that, we'll have to launch minikube with the </span><kbd><span class="koboSpan" id="kobo.15.1">--network-plugin=cni</span></kbd><span class="koboSpan" id="kobo.16.1"> option. </span><span class="koboSpan" id="kobo.16.2">The network policy is still pretty new in Kubernetes at this point. </span><span class="koboSpan" id="kobo.16.3">We're running Kubernetes version v.1.7.0 with the v.1.0.7 minikube ISO to deploy Calico by self-hosted solution (</span><a href="http://docs.projectcalico.org/v1.5/getting-started/kubernetes/installation/hosted/" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.17.1">http://docs.projectcalico.org/v1.5/getting-started/kubernetes/installation/hosted/</span></span></a><span class="koboSpan" id="kobo.18.1">). </span><span class="koboSpan" id="kobo.18.2">Calico can be installed with etcd datastore or the Kubernetes API datastore. </span><span class="koboSpan" id="kobo.18.3">For convenience, we'll demonstrate how to install Calico with the Kubernetes API datastore here. </span><span class="koboSpan" id="kobo.18.4">Since rbac is enabled in minikube, we'll have to configure the roles and bindings for Calico:</span></p>
<pre><strong><span class="koboSpan" id="kobo.19.1"># kubectl apply -f \</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/rbac-kdd.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">clusterrole.rbac.authorization.k8s.io/calico-node configured</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">clusterrolebinding.rbac.authorization.k8s.io/calico-node configured</span></strong></pre>
<p><span class="koboSpan" id="kobo.23.1">Now, let's deploy Calico:</span></p>
<pre><strong><span class="koboSpan" id="kobo.24.1"># kubectl apply -f https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.25.1">configmap/calico-config created</span></strong><br/><strong><span class="koboSpan" id="kobo.26.1">service/calico-typha created</span></strong><br/><strong><span class="koboSpan" id="kobo.27.1">deployment.apps/calico-typha created</span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">poddisruptionbudget.policy/calico-typha created</span></strong><br/><strong><span class="koboSpan" id="kobo.29.1">daemonset.extensions/calico-node created</span></strong><br/><strong><span class="koboSpan" id="kobo.30.1">serviceaccount/calico-node created</span></strong><br/><strong><span class="koboSpan" id="kobo.31.1">customresourcedefinition.apiextensions.k8s.io/felixconfigurations.crd.projectcalico....</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">customresourcedefinition.apiextensions.k8s.io/networkpolicies.crd.projectcalico.org created</span></strong></pre>
<p><span class="koboSpan" id="kobo.33.1">After doing this, we can list the Calico pods and see whether it's launched successfully:</span></p>
<pre><strong><span class="koboSpan" id="kobo.34.1"># kubectl get pods --namespace=kube-system</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">NAME READY STATUS RESTARTS AGE</span></strong><br/><strong><span class="koboSpan" id="kobo.36.1">calico-node-ctxq8 2/2 Running 0 14m</span></strong></pre>
<p><span class="koboSpan" id="kobo.37.1">Let's reuse </span><kbd><span class="koboSpan" id="kobo.38.1">6-2-1_nginx.yaml</span></kbd><span class="koboSpan" id="kobo.39.1"> for our example:</span></p>
<pre><strong><span class="koboSpan" id="kobo.40.1"># kubectl create -f chapter6/6-2-1_nginx.yaml
replicaset "nginx" created
service "nginx" created
// list the services
# kubectl get svc</span><br/><span class="koboSpan" id="kobo.41.1">NAME TYPE  CLUSTER-IP EXTERNAL-IP PORT(S) AGE</span><br/><span class="koboSpan" id="kobo.42.1">kubernetes ClusterIP  10.96.0.1    &lt;none&gt; 443/TCP 36m</span><br/><span class="koboSpan" id="kobo.43.1">nginx      NodePort   10.96.51.143 &lt;none&gt; 80:31452/TCP 5s</span></strong></pre>
<p><span class="koboSpan" id="kobo.44.1">We will find that our </span><kbd><span class="koboSpan" id="kobo.45.1">nginx</span></kbd><span class="koboSpan" id="kobo.46.1"> service has an IP address of </span><kbd><span class="koboSpan" id="kobo.47.1">10.96.51.143</span></kbd><span class="koboSpan" id="kobo.48.1">. </span><span class="koboSpan" id="kobo.48.2">Let's launch a simple bash and use </span><kbd><span class="koboSpan" id="kobo.49.1">wget</span></kbd><span class="koboSpan" id="kobo.50.1"> to see whether we can access our </span><kbd><span class="koboSpan" id="kobo.51.1">nginx</span></kbd><span class="koboSpan" id="kobo.52.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.53.1"># kubectl run busybox -i -t --image=busybox /bin/sh
If you don't see a command prompt, try pressing enter.
</span><span class="koboSpan" id="kobo.53.2">/ # wget --spider 10.96.51.143</span><br/><span class="koboSpan" id="kobo.54.1">Connecting to 10.96.51.143 (10.96.51.143:80)</span></strong></pre>
<p><span class="koboSpan" id="kobo.55.1">The </span><kbd><span class="koboSpan" id="kobo.56.1">--spider</span></kbd><span class="koboSpan" id="kobo.57.1"> parameter is used to check whether the URL exists. </span><span class="koboSpan" id="kobo.57.2">In this case, </span><kbd><span class="koboSpan" id="kobo.58.1">busybox</span></kbd><span class="koboSpan" id="kobo.59.1"> can access </span><kbd><span class="koboSpan" id="kobo.60.1">nginx</span></kbd><span class="koboSpan" id="kobo.61.1"> successfully. </span><span class="koboSpan" id="kobo.61.2">Next, let's apply a </span><kbd><span class="koboSpan" id="kobo.62.1">NetworkPolicy</span></kbd><span class="koboSpan" id="kobo.63.1"> to our </span><kbd><span class="koboSpan" id="kobo.64.1">nginx</span></kbd><span class="koboSpan" id="kobo.65.1"> pods:</span></p>
<pre><strong><span class="koboSpan" id="kobo.66.1">// declare a network policy
# cat chapter6/6-3-1_networkpolicy.yaml
kind: NetworkPolicy</span><br/><span class="koboSpan" id="kobo.67.1">apiVersion: networking.k8s.io/v1</span><br/><span class="koboSpan" id="kobo.68.1">metadata:</span><br/><span class="koboSpan" id="kobo.69.1">  name: nginx-networkpolicy</span><br/><span class="koboSpan" id="kobo.70.1">spec:</span><br/><span class="koboSpan" id="kobo.71.1">  podSelector:</span><br/><span class="koboSpan" id="kobo.72.1">    matchLabels:</span><br/><span class="koboSpan" id="kobo.73.1">      service: nginx</span><br/><span class="koboSpan" id="kobo.74.1">  ingress:</span><br/><span class="koboSpan" id="kobo.75.1">  - from:</span><br/><span class="koboSpan" id="kobo.76.1">    - podSelector:</span><br/><span class="koboSpan" id="kobo.77.1">        matchLabels:</span><br/><span class="koboSpan" id="kobo.78.1">          project: chapter6</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.79.1">We can see some important syntax here. </span><span class="koboSpan" id="kobo.79.2">The </span><kbd><span class="koboSpan" id="kobo.80.1">podSelector</span></kbd><span class="koboSpan" id="kobo.81.1"> is used to select pods that should match the labels of the target pod. </span><span class="koboSpan" id="kobo.81.2">Another one is </span><kbd><span class="koboSpan" id="kobo.82.1">ingress[].from[].podSelector</span></kbd><span class="koboSpan" id="kobo.83.1">, which is used to define who can access these pods. </span><span class="koboSpan" id="kobo.83.2">In this case, all the pods with </span><kbd><span class="koboSpan" id="kobo.84.1">project=chapter6</span></kbd><span class="koboSpan" id="kobo.85.1"> labels are eligible to access the pods with </span><kbd><span class="koboSpan" id="kobo.86.1">server=nginx</span></kbd><span class="koboSpan" id="kobo.87.1"> labels. </span><span class="koboSpan" id="kobo.87.2">If we go back to our busybox pod, we're unable to contact </span><kbd><span class="koboSpan" id="kobo.88.1">nginx</span></kbd><span class="koboSpan" id="kobo.89.1"> any more because, right now, the </span><kbd><span class="koboSpan" id="kobo.90.1">nginx</span></kbd><span class="koboSpan" id="kobo.91.1"> pod has </span><kbd><span class="koboSpan" id="kobo.92.1">NetworkPolicy</span></kbd><span class="koboSpan" id="kobo.93.1"> on it.</span></p>
<p><span class="koboSpan" id="kobo.94.1">By default, it is deny all, so busybox won't be able to talk to </span><kbd><span class="koboSpan" id="kobo.95.1">nginx</span></kbd><span class="koboSpan" id="kobo.96.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.97.1">// in busybox pod, or you could use `kubectl attach &lt;pod_name&gt; -c busybox -i -t` to re-attach to the pod 
# wget --spider --timeout=1 10.96.51.143
Connecting to 10.96.51.143 (10.96.51.143:80)
wget: download timed out  </span></strong></pre>
<p><span class="koboSpan" id="kobo.98.1">We can use </span><kbd><span class="koboSpan" id="kobo.99.1">kubectl edit deployment busybox</span></kbd><span class="koboSpan" id="kobo.100.1"> to add the </span><kbd><span class="koboSpan" id="kobo.101.1">project=chapter6</span></kbd><span class="koboSpan" id="kobo.102.1"> label in busybox pods.</span></p>
<p><span class="koboSpan" id="kobo.103.1">After that, we can contact the </span><kbd><span class="koboSpan" id="kobo.104.1">nginx</span></kbd><span class="koboSpan" id="kobo.105.1"> pod again:</span></p>
<pre><strong><span class="koboSpan" id="kobo.106.1">// inside busybox pod
/ # wget --spider 10.96.51.143 
Connecting to 10.96.51.143 (10.96.51.143:80)  </span></strong></pre>
<p><span class="koboSpan" id="kobo.107.1">With the help of the preceding example, we now have an idea of how to apply a network policy. </span><span class="koboSpan" id="kobo.107.2">We could also apply some default polices to deny all, or allow all, by tweaking the selector to select nobody or everybody. </span><span class="koboSpan" id="kobo.107.3">For example, the deny all behavior can be achieved as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.108.1"># cat chapter6/6-3-1_np_denyall.yaml
apiVersion: networking.k8s.io/v1</span><br/><span class="koboSpan" id="kobo.109.1">kind: NetworkPolicy</span><br/><span class="koboSpan" id="kobo.110.1">metadata:</span><br/><span class="koboSpan" id="kobo.111.1">  name: default-deny</span><br/><span class="koboSpan" id="kobo.112.1">spec:</span><br/><span class="koboSpan" id="kobo.113.1">  podSelector: {}</span><br/><span class="koboSpan" id="kobo.114.1">  policyTypes:</span><br/><span class="koboSpan" id="kobo.115.1">  - Ingress</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.116.1">This way, all pods that don't match labels will deny all other traffic. </span><span class="koboSpan" id="kobo.116.2">Alternatively, we could create a </span><kbd><span class="koboSpan" id="kobo.117.1">NetworkPolicy</span></kbd><span class="koboSpan" id="kobo.118.1"> whose ingress is listed everywhere. </span><span class="koboSpan" id="kobo.118.2">By doing this, the pods running in this namespace can be accessed by anyone:</span></p>
<pre><strong><span class="koboSpan" id="kobo.119.1"># cat chapter6/6-3-1_np_allowall.yaml
apiVersion: networking.k8s.io/v1</span><br/><span class="koboSpan" id="kobo.120.1">kind: NetworkPolicy</span><br/><span class="koboSpan" id="kobo.121.1">metadata:</span><br/><span class="koboSpan" id="kobo.122.1">  name: allow-all</span><br/><span class="koboSpan" id="kobo.123.1">spec:</span><br/><span class="koboSpan" id="kobo.124.1">  podSelector: {}</span><br/><span class="koboSpan" id="kobo.125.1">  ingress:</span><br/><span class="koboSpan" id="kobo.126.1">  - {}</span><br/></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Service mesh</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A service mesh is an infrastructure layer for handling service-to-service communication. </span><span class="koboSpan" id="kobo.2.2">Especially in the microservice world, the application at hand might contain hundreds of thousands of services. </span><span class="koboSpan" id="kobo.2.3">The network topology can be very complicated here. </span><span class="koboSpan" id="kobo.2.4">A service mesh can provide the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">Traffic management (such as A/B testing and canary deployment)</span></li>
<li><span class="koboSpan" id="kobo.4.1">Security (such as TLS and key management)</span></li>
<li><span class="koboSpan" id="kobo.5.1">Observability (such as providing traffic visibility. </span><span class="koboSpan" id="kobo.5.2">This is easy to integrate with monitoring systems such as Prometheus (</span><a href="https://prometheus.io/"><span class="koboSpan" id="kobo.6.1">https://prometheus.io/</span></a><span class="koboSpan" id="kobo.7.1">), tracing systems such as Jaeger (</span><a href="https://www.jaegertracing.io"><span class="koboSpan" id="kobo.8.1">https://www.jaegertracing.io</span></a><span class="koboSpan" id="kobo.9.1">) or Zipkin (</span><a href="https://github.com/openzipkin/zipkin"><span class="koboSpan" id="kobo.10.1">https://github.com/openzipkin/zipkin</span></a><span class="koboSpan" id="kobo.11.1">), and logging systems)</span></li>
</ul>
<p class="CDPAlignLeft CDPAlign"><span class="koboSpan" id="kobo.12.1">There are two major service mesh implementations on the market—Istio (</span><a href="https://istio.io"><span class="koboSpan" id="kobo.13.1">https://istio.io</span></a><span class="koboSpan" id="kobo.14.1">) and Linkerd (</span><a href="https://linkerd.io"><span class="koboSpan" id="kobo.15.1">https://linkerd.io</span></a><span class="koboSpan" id="kobo.16.1">). </span><span class="koboSpan" id="kobo.16.2">Both of these deploy network proxy containers alongside the application container (the so-called sidecar container) and provide Kubernetes support. </span><span class="koboSpan" id="kobo.16.3">The following diagram is a simplified common architecture of the service mesh:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.17.1"><img src="assets/9227a449-08f6-4594-80bf-ca003f10c738.png" style="width:42.50em;height:27.17em;"/></span></div>
<p><span class="koboSpan" id="kobo.18.1">A service mesh normally contains a control plane, which is the brain of the mesh. </span><span class="koboSpan" id="kobo.18.2">This can manage and enforce the policies for route traffic, as well as collect telemetry data that can be integrated with other systems. </span><span class="koboSpan" id="kobo.18.3">It also carries out identity and credential management for services or end users. </span><span class="koboSpan" id="kobo.18.4">The service mesh sidecar container, which acts as a network proxy, lives side by side with the application container. </span><span class="koboSpan" id="kobo.18.5">The communication between services is passed through the sidecar container, which means that it can control the traffic by user-defined policies, secure the traffic via TLS encryption, do the load balancing and retries, control the ingress/egress, collect the metrics, and so on.</span></p>
<p><span><span class="koboSpan" id="kobo.19.1">In the following section, we'll use Istio as the example, but you're free to use any implementation in your organization. </span><span class="koboSpan" id="kobo.19.2">First, let's get the latest version of Istio. </span><span class="koboSpan" id="kobo.19.3">At the time of writing, the latest version is 1.0.5:</span></span></p>
<pre><strong><span class="token function"><span class="koboSpan" id="kobo.20.1">// get the latest istio</span><br/><span class="koboSpan" id="kobo.21.1"># curl</span></span><span><span class="koboSpan" id="kobo.22.1"> -L https://git.io/</span></span><span class="wordhighlight_ext wordhighlight_word0"><span class="koboSpan" id="kobo.23.1">get</span></span><span class="wordhighlight_ext wordhighlight_word1"><span class="koboSpan" id="kobo.24.1">Latest</span></span><span class="wordhighlight_ext wordhighlight_word2"><span class="koboSpan" id="kobo.25.1">Istio</span></span><span> </span><span class="token operator"><span class="koboSpan" id="kobo.26.1">|</span></span></strong><span><strong><span class="koboSpan" id="kobo.27.1"> sh -</span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">Downloading istio-1.0.5 from https://github.com/istio/istio/releases/download/1.0.5/istio-1.0.5-osx.tar.gz ...</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.29.1">// get into the folder</span></strong><br/><strong><span class="koboSpan" id="kobo.30.1"># cd istio-1.0.5/</span></strong><br/></span></pre>
<p><span class="koboSpan" id="kobo.31.1">Next, let's create a </span><strong><span class="koboSpan" id="kobo.32.1">Custom Resource Definition</span></strong><span class="koboSpan" id="kobo.33.1"> (</span><strong><span class="koboSpan" id="kobo.34.1">CRD</span></strong><span class="koboSpan" id="kobo.35.1">) for Istio:</span></p>
<pre><strong><span class="koboSpan" id="kobo.36.1"># kubectl apply -f install/kubernetes/helm/istio/templates/crds.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">customresourcedefinition.apiextensions.k8s.io/virtualservices.networking.istio.io created</span></strong><br/><strong><span class="koboSpan" id="kobo.38.1">customresourcedefinition.apiextensions.k8s.io/destinationrules.networking.istio.io created</span></strong><br/><strong><span class="koboSpan" id="kobo.39.1">customresourcedefinition.apiextensions.k8s.io/serviceentries.networking.istio.io created</span></strong><br/><strong><span class="koboSpan" id="kobo.40.1">customresourcedefinition.apiextensions.k8s.io/gateways.networking.istio.io created</span></strong><br/><strong><span class="koboSpan" id="kobo.41.1">...</span></strong></pre>
<p><span class="koboSpan" id="kobo.42.1">In the following example, we're installing Istio with default mutual TLS authentication. </span><span class="koboSpan" id="kobo.42.2">The resource definition is under the </span><span><kbd><span class="koboSpan" id="kobo.43.1">install/kubernetes/istio-demo-auth.yaml</span></kbd><span class="koboSpan" id="kobo.44.1"> file. </span><span class="koboSpan" id="kobo.44.2">If you'd like to deploy it without TLS authentication, you can use </span><kbd><span class="koboSpan" id="kobo.45.1">install/kubernetes/istio-demo.yaml</span></kbd><span class="koboSpan" id="kobo.46.1"> instead:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.47.1"># kubectl apply -f install/kubernetes/istio-demo-auth.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.48.1">namespace/istio-system created</span></strong><br/><strong><span class="koboSpan" id="kobo.49.1">configmap/istio-galley-configuration created</span></strong><br/><strong><span class="koboSpan" id="kobo.50.1">...</span></strong></pre>
<pre><strong><span class="koboSpan" id="kobo.51.1">kubernetes.config.istio.io/attributes created</span></strong><br/><strong><span class="koboSpan" id="kobo.52.1">destinationrule.networking.istio.io/istio-policy created</span></strong><br/><strong><span class="koboSpan" id="kobo.53.1">destinationrule.networking.istio.io/istio-telemetry created</span></strong></pre>
<p><span class="koboSpan" id="kobo.54.1">After deployment, let's check that the services and pods have all been deployed successfully into the </span><kbd><span class="koboSpan" id="kobo.55.1">istio-system</span></kbd><span class="koboSpan" id="kobo.56.1"> namespace:</span></p>
<pre><strong><span class="koboSpan" id="kobo.57.1">// check services are launched successfully</span></strong><br/><strong><span class="koboSpan" id="kobo.58.1"># kubectl get svc -n istio-system</span></strong><br/><strong><span class="koboSpan" id="kobo.59.1">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE</span></strong><br/><strong><span class="koboSpan" id="kobo.60.1">grafana ClusterIP 10.98.182.66 &lt;none&gt; 3000/TCP 13s</span></strong><br/><strong><span class="koboSpan" id="kobo.61.1">istio-citadel ClusterIP 10.105.65.6 &lt;none&gt; 8060/TCP,9093/TCP 13s</span></strong><br/><strong><span class="koboSpan" id="kobo.62.1">istio-egressgateway ClusterIP 10.105.178.212 &lt;none&gt; 80/TCP,443/TCP 13s</span></strong><br/><strong><span class="koboSpan" id="kobo.63.1">istio-galley ClusterIP 10.103.123.213 &lt;none&gt; 443/TCP,9093/TCP 13s</span></strong><br/><strong><span class="koboSpan" id="kobo.64.1">istio-ingressgateway LoadBalancer 10.107.243.112 &lt;pending&gt; 80:31380/TCP,443:31390/TCP,31400:31400/TCP,15011:32320/TCP,8060:31750/TCP,853:30790/TCP,15030:30313/TCP,15031:30851/TCP 13s</span></strong><br/><strong><span class="koboSpan" id="kobo.65.1">istio-pilot ClusterIP 10.104.123.60 &lt;none&gt; 15010/TCP,15011/TCP,8080/TCP,9093/TCP 13s</span></strong><br/><strong><span class="koboSpan" id="kobo.66.1">istio-policy ClusterIP 10.111.227.237 &lt;none&gt; 9091/TCP,15004/TCP,9093/TCP 13s</span></strong><br/><strong><span class="koboSpan" id="kobo.67.1">istio-sidecar-injector ClusterIP 10.107.43.206 &lt;none&gt; 443/TCP 13s</span></strong><br/><strong><span class="koboSpan" id="kobo.68.1">istio-telemetry ClusterIP 10.103.118.119 &lt;none&gt; 9091/TCP,15004/TCP,9093/TCP,42422/TCP 13s</span></strong><br/><strong><span class="koboSpan" id="kobo.69.1">jaeger-agent ClusterIP None &lt;none&gt; 5775/UDP,6831/UDP,6832/UDP 11s</span></strong><br/><strong><span class="koboSpan" id="kobo.70.1">jaeger-collector ClusterIP 10.110.234.134 &lt;none&gt; 14267/TCP,14268/TCP 11s</span></strong><br/><strong><span class="koboSpan" id="kobo.71.1">jaeger-query ClusterIP 10.103.19.74 &lt;none&gt; 16686/TCP 12s</span></strong><br/><strong><span class="koboSpan" id="kobo.72.1">prometheus ClusterIP 10.96.62.77 &lt;none&gt; 9090/TCP 13s</span></strong><br/><strong><span class="koboSpan" id="kobo.73.1">servicegraph ClusterIP 10.100.191.216 &lt;none&gt; 8088/TCP 13s</span></strong><br/><strong><span class="koboSpan" id="kobo.74.1">tracing ClusterIP 10.107.99.50 &lt;none&gt; 80/TCP 11s</span></strong><br/><strong><span class="koboSpan" id="kobo.75.1">zipkin ClusterIP 10.98.206.168 &lt;none&gt; 9411/TCP 11s</span></strong></pre>
<p><span class="koboSpan" id="kobo.76.1">After waiting for a few minutes, check that the pods are all in </span><kbd><span class="koboSpan" id="kobo.77.1">Running</span></kbd><span class="koboSpan" id="kobo.78.1"> and </span><kbd><span class="koboSpan" id="kobo.79.1">Completed</span></kbd><span class="koboSpan" id="kobo.80.1"> states, as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.81.1"># kubectl get pods -n istio-system</span></strong><br/><strong><span class="koboSpan" id="kobo.82.1">NAME READY STATUS RESTARTS AGE</span></strong><br/><strong><span class="koboSpan" id="kobo.83.1">grafana-7ffdd5fb74-hzwcn 1/1 Running 0 5m1s</span></strong><br/><strong><span class="koboSpan" id="kobo.84.1">istio-citadel-55cdfdd57c-zzs2s 1/1 Running 0 5m1s</span></strong><br/><strong><span class="koboSpan" id="kobo.85.1">istio-cleanup-secrets-qhbvk 0/1 Completed 0 5m3s</span></strong><br/><strong><span class="koboSpan" id="kobo.86.1">istio-egressgateway-687499c95f-fbbwq 1/1 Running 0 5m1s</span></strong><br/><strong><span class="koboSpan" id="kobo.87.1">istio-galley-76bbb946c8-9mw2g 1/1 Running 0 5m1s</span></strong><br/><strong><span class="koboSpan" id="kobo.88.1">istio-grafana-post-install-8xxps 0/1 Completed 0 5m3s</span></strong><br/><strong><span class="koboSpan" id="kobo.89.1">istio-ingressgateway-54f5457d68-n7xsj 1/1 Running 0 5m1s</span></strong><br/><strong><span class="koboSpan" id="kobo.90.1">istio-pilot-7bf5674b9f-jnnvx 2/2 Running 0 5m1s</span></strong><br/><strong><span class="koboSpan" id="kobo.91.1">istio-policy-75dfcf6f6d-nwvdn 2/2 Running 0 5m1s</span></strong><br/><strong><span class="koboSpan" id="kobo.92.1">istio-security-post-install-stv2c 0/1 Completed 0 5m3s</span></strong><br/><strong><span class="koboSpan" id="kobo.93.1">istio-sidecar-injector-9c6698858-gr86p 1/1 Running 0 5m1s</span></strong><br/><strong><span class="koboSpan" id="kobo.94.1">istio-telemetry-67f94c555b-4mt4l 2/2 Running 0 5m1s</span></strong><br/><strong><span class="koboSpan" id="kobo.95.1">istio-tracing-6445d6dbbf-8r5r4 1/1 Running 0 5m1s</span></strong><br/><strong><span class="koboSpan" id="kobo.96.1">prometheus-65d6f6b6c-qrp6f 1/1 Running 0 5m1s</span></strong><br/><strong><span class="koboSpan" id="kobo.97.1">servicegraph-5c6f47859-qzlml 1/1 Running 2 5m1s</span></strong></pre>
<p><span class="koboSpan" id="kobo.98.1">Since we have </span><kbd><span class="koboSpan" id="kobo.99.1">istio-sidecar-injector</span></kbd><span class="koboSpan" id="kobo.100.1"> deployed, we can simply use </span><kbd><span class="koboSpan" id="kobo.101.1">kubectl label namespace default istio-injection=enabled</span></kbd><span class="koboSpan" id="kobo.102.1"> to enable the sidecar container injection for every pod in the </span><kbd><span class="koboSpan" id="kobo.103.1">default</span></kbd><span class="koboSpan" id="kobo.104.1"> namespace. </span><kbd><span class="koboSpan" id="kobo.105.1">istio-sidecar-injector</span></kbd><span class="koboSpan" id="kobo.106.1"> acts as a mutating admission controller, which will inject the sidecar container to the pod if the namespace is labelled with </span><kbd><span class="koboSpan" id="kobo.107.1">istio-injection=enabled</span></kbd><span class="koboSpan" id="kobo.108.1">. </span><span class="koboSpan" id="kobo.108.2">Next, we can launch a sample application from the </span><kbd><span class="koboSpan" id="kobo.109.1">samples</span></kbd><span class="koboSpan" id="kobo.110.1"> folder. </span><span class="koboSpan" id="kobo.110.2">Helloworld demonstrates the use of canary deployment (</span><a href="https://en.wikipedia.org/wiki/Deployment_environment"><span class="koboSpan" id="kobo.111.1">https://en.wikipedia.org/wiki/Deployment_environment</span></a><span class="koboSpan" id="kobo.112.1">), which will distribute the traffic to the helloworld-v1 and helloworld-v2 services:</span></p>
<pre><strong><span class="koboSpan" id="kobo.113.1">// launch sample application</span></strong><br/><strong><span class="koboSpan" id="kobo.114.1"># kubectl run nginx --image=nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.115.1">deployment.apps/nginx created</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.116.1">// list pods</span></strong><br/><strong><span class="koboSpan" id="kobo.117.1"># kubectl get po</span></strong><br/><strong><span class="koboSpan" id="kobo.118.1">NAME READY STATUS RESTARTS AGE</span></strong><br/><strong><span class="koboSpan" id="kobo.119.1">nginx-64f497f8fd-b7d4k 2/2 Running 0 3s</span></strong></pre>
<p><span class="koboSpan" id="kobo.120.1">If we inspect one of the pods, we'll find that the </span><kbd><span class="koboSpan" id="kobo.121.1">istio-proxy</span></kbd><span class="koboSpan" id="kobo.122.1"> container was injected into it:</span></p>
<pre><strong><span class="koboSpan" id="kobo.123.1"># kubectl describe po nginx-64f497f8fd-b7d4k</span></strong><br/><strong><span class="koboSpan" id="kobo.124.1">Name: nginx-64f497f8fd-b7d4k</span></strong><br/><strong><span class="koboSpan" id="kobo.125.1">Namespace: default</span></strong><br/><strong><span class="koboSpan" id="kobo.126.1">Labels: pod-template-hash=2090539498</span></strong><br/><strong><span class="koboSpan" id="kobo.127.1">                    run=nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.128.1">Annotations: kubernetes.io/limit-ranger: LimitRanger plugin set: cpu request for container nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.129.1">                    sidecar.istio.io/status:</span></strong><br/><strong><span class="koboSpan" id="kobo.130.1">                      {"version":"50128f63e7b050c58e1cdce95b577358054109ad2aff4bc4995158c06924a43b","initContainers":["istio-init"],"containers":["istio-proxy"]...</span></strong><br/><strong><span class="koboSpan" id="kobo.131.1">Status: Running</span></strong><br/><strong><span class="koboSpan" id="kobo.132.1">Init Containers:</span></strong><br/><strong><span class="koboSpan" id="kobo.133.1">  istio-init:</span></strong><br/><strong><span class="koboSpan" id="kobo.134.1">    Container ID: docker://3ec33c4cbc66682f9a6846ae6f310808da3a2a600b3d107a0d361b5deb6d3018</span></strong><br/><strong><span class="koboSpan" id="kobo.135.1">    Image: docker.io/istio/proxy_init:1.0.5</span></strong><br/><strong><span class="koboSpan" id="kobo.136.1">...</span></strong><br/><strong><span class="koboSpan" id="kobo.137.1">Containers:</span></strong><br/><strong><span class="koboSpan" id="kobo.138.1">  nginx:</span></strong><br/><strong><span class="koboSpan" id="kobo.139.1">    Container ID: docker://42ab7df7366c1838489be0c7264a91235d8e5d79510f3d0f078726165e95665a</span></strong><br/><strong><span class="koboSpan" id="kobo.140.1">    Image: nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.141.1">   ...</span></strong><br/><strong><span class="koboSpan" id="kobo.142.1">  istio-proxy:</span></strong><br/><strong><span class="koboSpan" id="kobo.143.1">    Container ID: docker://7bdf7b82ce3678174dea12fafd2c7f0726bfffc562ed3505a69991b06cf32d0d</span></strong><br/><strong><span class="koboSpan" id="kobo.144.1">    Image: docker.io/istio/proxyv2:1.0.5</span></strong><br/><strong><span class="koboSpan" id="kobo.145.1">    Image ID: docker-pullable://istio/proxyv2@sha256:8b7d549100638a3697886e549c149fb588800861de8c83605557a9b4b20343d4</span></strong><br/><strong><span class="koboSpan" id="kobo.146.1">    Port: 15090/TCP</span></strong><br/><strong><span class="koboSpan" id="kobo.147.1">    Host Port: 0/TCP</span></strong><br/><strong><span class="koboSpan" id="kobo.148.1">    Args:</span></strong><br/><strong><span class="koboSpan" id="kobo.149.1">      proxy</span></strong><br/><strong><span class="koboSpan" id="kobo.150.1">      sidecar</span></strong><br/><strong><span class="koboSpan" id="kobo.151.1">      --configPath</span></strong><br/><strong><span class="koboSpan" id="kobo.152.1">      /etc/istio/proxy</span></strong><br/><strong><span class="koboSpan" id="kobo.153.1">      --binaryPath</span></strong><br/><strong><span class="koboSpan" id="kobo.154.1">      /usr/local/bin/envoy</span></strong><br/><strong><span class="koboSpan" id="kobo.155.1">      --serviceCluster</span></strong><br/><strong><span class="koboSpan" id="kobo.156.1">      istio-proxy</span></strong><br/><strong><span class="koboSpan" id="kobo.157.1">      --drainDuration</span></strong><br/><strong><span class="koboSpan" id="kobo.158.1">      45s</span></strong><br/><strong><span class="koboSpan" id="kobo.159.1">      --parentShutdownDuration</span></strong><br/><strong><span class="koboSpan" id="kobo.160.1">      1m0s</span></strong><br/><strong><span class="koboSpan" id="kobo.161.1">      --discoveryAddress</span></strong><br/><strong><span class="koboSpan" id="kobo.162.1">      istio-pilot.istio-system:15005</span></strong><br/><strong><span class="koboSpan" id="kobo.163.1">      --discoveryRefreshDelay</span></strong><br/><strong><span class="koboSpan" id="kobo.164.1">      1s</span></strong><br/><strong><span class="koboSpan" id="kobo.165.1">      --zipkinAddress</span></strong><br/><strong><span class="koboSpan" id="kobo.166.1">      zipkin.istio-system:9411</span></strong><br/><strong><span class="koboSpan" id="kobo.167.1">      --connectTimeout</span></strong><br/><strong><span class="koboSpan" id="kobo.168.1">      10s</span></strong><br/><strong><span class="koboSpan" id="kobo.169.1">      --proxyAdminPort</span></strong><br/><strong><span class="koboSpan" id="kobo.170.1">      15000</span></strong><br/><strong><span class="koboSpan" id="kobo.171.1">      --controlPlaneAuthPolicy</span></strong><br/><strong><span class="koboSpan" id="kobo.172.1">      MUTUAL_TLS</span></strong></pre>
<p><span class="koboSpan" id="kobo.173.1">Taking a closer look, we can see that the </span><kbd><span class="koboSpan" id="kobo.174.1">istio-proxy</span></kbd><span class="koboSpan" id="kobo.175.1"> container was launched with the configuration of its control plane address, tracing system address, and connection configuration. </span><span class="koboSpan" id="kobo.175.2">Istio has </span><span><span class="koboSpan" id="kobo.176.1">now</span></span><span><span class="koboSpan" id="kobo.177.1"> </span></span><span><span class="koboSpan" id="kobo.178.1">been verified. </span><span class="koboSpan" id="kobo.178.2">There are</span></span><span class="koboSpan" id="kobo.179.1"> lots of to do </span><span><span class="koboSpan" id="kobo.180.1">with Istio traffic management, which is beyond of the scope of this book. </span><span class="koboSpan" id="kobo.180.2">Istio has a variety of detailed samples for us to try, which can be found in the </span></span><kbd><span class="koboSpan" id="kobo.181.1">istio-1.0.5/samples</span></kbd> <span><span class="koboSpan" id="kobo.182.1">folder that we just downloaded. </span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, we learned how containers communicate with each other. </span><span class="koboSpan" id="kobo.2.2">We also introduced how pod-to-pod communication works. </span><span class="koboSpan" id="kobo.2.3">A service is an abstraction that routes traffic to any of the pods underneath it if the label selectors match. </span><span class="koboSpan" id="kobo.2.4">We also learned how a service works with a pod using </span><kbd><span class="koboSpan" id="kobo.3.1">iptables</span></kbd><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">We also familiarized ourselves with how packet routes from external services to a pod using DNAT and un-DAT packets. </span><span class="koboSpan" id="kobo.4.3">In addition to this, we looked at new API objects such as ingress, which allows us to use the URL path to route to different services in the backend. </span><span class="koboSpan" id="kobo.4.4">In the end, another </span><kbd><span class="koboSpan" id="kobo.5.1">NetworkPolicy</span></kbd><span class="koboSpan" id="kobo.6.1"> </span><span><span class="koboSpan" id="kobo.7.1">object</span></span><span><span class="koboSpan" id="kobo.8.1"> </span></span><span><span class="koboSpan" id="kobo.9.1">was introduced. </span><span class="koboSpan" id="kobo.9.2">This provides a second layer of security, and acts as a software firewall rule. </span><span class="koboSpan" id="kobo.9.3">With the network policy, we can make certain pods communicate with certain other pods. </span><span class="koboSpan" id="kobo.9.4">For example, only data retrieval services can talk to the database container. </span><span class="koboSpan" id="kobo.9.5">In the last section, we got a glimpse at Istio, one of the popular implementations of service mesh. </span></span><span><span class="koboSpan" id="kobo.10.1">All of these things make Kubernetes more flexible, secure, robust, and powerful. </span></span></p>
<p><span class="koboSpan" id="kobo.11.1">Before this chapter, we covered the basic concepts of Kubernetes. </span><span class="koboSpan" id="kobo.11.2">In </span><a href="9a41a50b-33a5-4ec1-9e40-be08c9ccb1ae.xhtml"><span class="koboSpan" id="kobo.12.1">Chapter 7</span></a><span><span class="koboSpan" id="kobo.13.1">, </span></span><em><span class="koboSpan" id="kobo.14.1">Monitoring and Logging</span></em><span class="koboSpan" id="kobo.15.1">, we'll get a clearer understanding of what is happening inside your cluster by monitoring cluster metrics and analyzing applications and system logs for Kubernetes. </span><span class="koboSpan" id="kobo.15.2">Monitoring and logging tools are essential for every DevOps, which also plays an extremely important role in dynamic clusters such as Kubernetes. </span><span class="koboSpan" id="kobo.15.3">Consequently, we'll get an insight into the activities of the cluster, such as scheduling, deployment, scaling, and service discovery. </span><a href="9a41a50b-33a5-4ec1-9e40-be08c9ccb1ae.xhtml"><span class="koboSpan" id="kobo.16.1">Chapter 7</span></a><span class="koboSpan" id="kobo.17.1">, </span><em><span class="koboSpan" id="kobo.18.1">Monitoring and Logging</span></em><span class="koboSpan" id="kobo.19.1">, will help you to better understand the act of operating Kubernetes in the real world.</span></p>


            </article>

            
        </section>
    </body></html>