- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: GitOps at Scale and Multitenancy
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitOps的规模化与多租户
- en: This chapter delves into advanced **GitOps** applications, focusing on scaling
    and **multitenancy** within Kubernetes environments. It’s tailored for those with
    a foundational understanding of tools such as **Argo CD** and who are looking
    to expand their knowledge in more complex scenarios.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了**GitOps**的高级应用，重点是Kubernetes环境中的扩展性和**多租户**问题。内容针对那些已具备如**Argo CD**等工具基础知识的人，并希望在更复杂的场景中扩展知识。
- en: We’ll start by discussing strategies to build scalable cluster infrastructures
    using GitOps. This includes designing Kubernetes clusters that can adapt to increasing
    demands, all managed through GitOps methodologies. A significant part of this
    discussion involves deploying applications across multiple clusters efficiently,
    focusing on scalability and customization.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论如何使用GitOps构建可扩展的集群基础设施开始。这包括设计能够适应日益增长的需求的Kubernetes集群，所有这些都通过GitOps方法进行管理。讨论的一个重要部分是如何高效地在多个集群间部署应用，重点关注可扩展性和定制化。
- en: A critical aspect we’ll address is enforcing multitenancy in shared Kubernetes
    environments. We’ll explore how to achieve this using GitOps tools such as Argo
    CD, adhering to their operational philosophies. Complementary to this, we’ll introduce
    tools such as **vCluster** that simplify multitenancy enforcement while maintaining
    GitOps principles.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点讨论在共享的Kubernetes环境中强制实施多租户。我们将探讨如何使用GitOps工具（如Argo CD）实现这一目标，并遵循其操作哲学。与此同时，我们还将介绍如**vCluster**等工具，这些工具简化了多租户的强制执行，同时保持GitOps原则。
- en: The emphasis throughout this chapter is on concepts over tools. While tools
    may evolve, the underlying principles remain constant, providing a stable foundation
    for understanding these technologies.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是概念而非工具。尽管工具可能会发展变化，但其背后的基本原则保持不变，为理解这些技术提供了稳定的基础。
- en: We’ll also cover the implementation of a lightweight **internal developer platform**
    (**IDP**) to facilitate the **deployment** of third-party tools through **Kubernetes
    Service Catalog** (**KSC**). This approach simplifies application management within
    Kubernetes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论如何实现轻量级的**内部开发平台**(**IDP**)，以便通过**Kubernetes服务目录**(**KSC**)促进第三方工具的**部署**。这种方法简化了Kubernetes中的应用管理。
- en: Real-world insights form a significant part of this chapter, drawing from experiences
    and lessons learned in diverse project environments. This practical perspective
    is invaluable for understanding the real-world application of these strategies.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界的见解是本章的重要组成部分，借鉴了在不同项目环境中积累的经验和教训。这个实践视角对于理解这些策略在实际应用中的效果至关重要。
- en: This chapter, which is aimed at **intermediate learners**, won’t delve into
    the setup or basic operations of Argo CD. Instead, it will focus on their application
    in complex, real-world scenarios, demonstrating the practical use of the most
    suitable tools for each case. The goal is to equip you with a comprehensive understanding
    of scaling and managing multitenancy in Kubernetes using GitOps, enriched with
    real-world applications and insights, by staying focused on the approaches and
    not the tools.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章面向**中级学习者**，不会深入探讨Argo CD的安装或基本操作。相反，它将重点介绍这些工具在复杂的现实场景中的应用，展示为每种情况选择最合适工具的实际使用。目标是通过关注方法而非工具，帮助你全面理解如何使用GitOps在Kubernetes中扩展和管理多租户环境，并结合现实世界的应用和见解。
- en: The chapter is tough, but I hope you’ll have learned a lot by the time you finish
    it. I’ve tried to share all the insights from projects in a compact way with you.
    This chapter can be logically divided into two sections. The first section covers
    approaches to using GitOps at scale and the necessary setup via KSC. The second
    section, starting on page 45, focuses on multitenancy with GitOps to get the most
    out of the setup.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容较为艰难，但我希望你在完成后能够学到很多。我尽量以简洁的方式将项目中的所有见解与您分享。本章可以逻辑上分为两个部分。第一部分涵盖了使用GitOps进行规模化应用的策略及通过KSC进行的必要设置。第二部分，从第45页开始，侧重于使用GitOps进行多租户管理，以便最大化地利用设置。
- en: 'We will cover the following main topics in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Understanding the App of Apps approach
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解“应用之应用”方法
- en: Understanding multi-cluster management
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解多集群管理
- en: Understanding effective Git repository strategies
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解有效的Git仓库策略
- en: Building a service catalog for Kubernetes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Kubernetes的服务目录
- en: Exploring native multitenancy with Argo CD
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索使用Argo CD实现本地多租户功能
- en: Exploring multitenancy with vCluster and Argo CD
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 vCluster 和 Argo CD 探索多租户
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Due to the limited space available, many examples have been shortened or are
    incomplete. Therefore, we have a repository with complete examples. This follows
    the `chapter05`/`section` pattern – that is, `chapter05`/`chapter-5-building-a-service-catalog-for-kubernetes`.
    For all the code examples discussed, along with additional resources, please refer
    to the `Chapter05` folder in the book’s GitHub repository at [https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes](https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空间有限，许多示例已被简化或不完整。因此，我们提供了一个包含完整示例的代码库。它遵循 `chapter05`/`section` 的模式 —— 即
    `chapter05`/`chapter-5-building-a-service-catalog-for-kubernetes`。所有讨论过的代码示例以及其他资源，请参考书籍
    GitHub 仓库中的 `Chapter05` 文件夹，网址为 [https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes](https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes)。
- en: Traditional CI/CD versus GitOps CD
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统 CI/CD 与 GitOps CD 的对比
- en: The main difference between traditional CI/CD and Argo CD is in how deployments
    are handled
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 传统 CI/CD 和 Argo CD 之间的主要区别在于部署处理方式
- en: ':'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ：
- en: '![Figure 5.1 – Traditional CI/CD versus GitOps CD](img/B22100_05_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 传统 CI/CD 与 GitOps CD 的对比](img/B22100_05_01.jpg)'
- en: Figure 5.1 – Traditional CI/CD versus GitOps CD
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 传统 CI/CD 与 GitOps CD 的对比
- en: Traditional CI/CD follows a workflow where changes are automatically integrated,
    tested, and deployed, while Argo CD uses a synchronization mechanism to ensure
    the actual state matches the desired state in the Git repository. Argo CD relies
    on a CI step, meaning any change must go through a CI process before Argo CD can
    detect and act on it. This ensures that only verified changes are deployed. Unlike
    CI/CD, which might require manual interventions that can lead to discrepancies,
    Argo CD continuously monitors and synchronizes the system state with the Git repository,
    reducing the risk of drifts and maintaining consistency.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 传统 CI/CD 遵循一种工作流，在该工作流中，变更会自动集成、测试并部署，而 Argo CD 使用同步机制确保实际状态与 Git 仓库中的期望状态匹配。Argo
    CD 依赖 CI 步骤，这意味着任何更改必须经过 CI 流程，Argo CD 才能检测到并采取行动。这确保了只有经过验证的更改会被部署。与 CI/CD 不同，CI/CD
    可能需要手动干预，这可能导致不一致，而 Argo CD 持续监控并同步系统状态与 Git 仓库，减少漂移的风险并保持一致性。
- en: In the following section, we’ll look at the difference between platform engineering
    and IDPs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将探讨平台工程与 IDP 之间的区别
- en: Platform engineering versus IDPs
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台工程与 IDP 的对比
- en: 'In my opinion, a distinction between **internal developer platforms** (**IDPs**)
    and **internal developer portals** (**IDPOs**) is becoming increasingly relevant
    and is already a topic of much debate. To clarify the different approaches, here’s
    how I differentiate these terms:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，**内部开发平台**（**IDP**）和**内部开发门户**（**IDPO**）之间的区别变得越来越重要，已经成为许多讨论的话题。为了澄清这些不同的概念，以下是我对这些术语的区分：
- en: '**Platform engineering**: This is the traditional approach where a dedicated
    team owns, operates, and continuously improves the Kubernetes platform itself.
    Their focus is on the underlying infrastructure, ensuring its stability, scalability,
    and security. Developers working on applications typically consume this platform
    and concentrate solely on their software or third-party tools that aren’t offered
    by the platform team. This is a common approach in many projects today.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台工程**：这是传统的方法，专门的团队负责拥有、运营和持续改进 Kubernetes 平台本身。团队的关注点是底层基础设施，确保其稳定性、可扩展性和安全性。开发人员通常使用这个平台，专注于他们的软件或平台团队未提供的第三方工具。这是许多项目中常见的方法。'
- en: '**Internal developer platform (IDP)**: This approach introduces an IDP solution,
    such as backstage.io from Spotify. The IDP team is responsible for providing and
    maintaining the IDP itself, which includes extensive documentation, building blocks,
    and templates for developers and acts like a portal (IDPO) for developers. Developers
    can then leverage these resources to self-deploy their applications within a defined
    Kubernetes environment. This allows developers to have some influence on the content
    and functionality of the IDP through contributions or requests. The engineering
    focus of the platform team shifts from core Kubernetes operations to managing
    and evolving the IDP. However, developers are still responsible for the day-to-day
    operations of their deployed Kubernetes environments, including updates and troubleshooting.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部开发平台 (IDP)**：该方法引入了一种 IDP 解决方案，如 Spotify 的 backstage.io。IDP 团队负责提供和维护 IDP
    本身，其中包括广泛的文档、构建块和开发人员模板，并充当开发人员的门户（IDPO）。开发人员可以利用这些资源，在定义的 Kubernetes 环境中自我部署应用。这样，开发人员就可以通过贡献或请求对
    IDP 的内容和功能产生一定的影响。平台团队的工程重点从核心 Kubernetes 操作转向管理和发展 IDP。然而，开发人员仍然负责其部署的 Kubernetes
    环境的日常操作，包括更新和故障排除。'
- en: Now, let’s explore the App of Apps approach.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索“应用之应用”方法。
- en: Understanding the App of Apps approach
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解“应用之应用”方法
- en: 'In managing multiple applications, there are primarily two established strategies:
    the **App of Apps** approach and **ApplicationSets**. This section will address
    several key questions:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理多个应用时，主要有两种成熟的策略：**应用之应用**方法和**应用集**。本节将解决几个关键问题：
- en: What challenges does the App of Apps approach overcome?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “应用之应用”方法克服了哪些挑战？
- en: In which situations is the App of Apps approach most beneficial?
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在哪些情况下“应用之应用”方法最为有利？
- en: How does the App of Apps approach enhance GitOps practices?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “应用之应用”方法如何提升 GitOps 实践？
- en: An *application* in this context refers to the Git repository and folder where
    manifests, which are essential definitions that allow your app to run in Kubernetes,
    are stored. Argo CD is versatile as it supports raw **YAML** manifests, custom
    configuration management, and popular tools such as **Kustomize**, **Helm**, and
    **Jsonnet**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，*应用* 指的是存储清单的 Git 仓库和文件夹，这些清单是运行应用在 Kubernetes 中所需的基本定义。Argo CD 很灵活，它支持原始
    **YAML** 清单、自定义配置管理以及流行的工具，如 **Kustomize**、**Helm** 和 **Jsonnet**。
- en: But what about scenarios where we must deploy multiple applications? How should
    we manage these manifests? Each application being deployed requires an application
    definition. However, when these applications are a collection of related entities,
    it would be beneficial if Argo CD could recognize this relationship. To address
    this need, the Argo community developed the App of Apps approach. Essentially,
    this approach allows a root Argo CD *application* to be defined, which, in turn,
    defines and synchronizes multiple child applications. This method streamlines
    the management process, especially in complex deployments, by leveraging a hierarchical
    folder structure.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，对于必须部署多个应用的场景怎么办？我们应该如何管理这些清单？每个部署的应用都需要一个应用定义。然而，当这些应用是相关实体的集合时，如果 Argo
    CD 能识别这种关系，将会更有利。为了解决这一需求，Argo 社区开发了“应用之应用”方法。实际上，这种方法允许定义一个根 Argo CD *应用*，进而定义和同步多个子应用。这种方法通过利用分层的文件夹结构，简化了管理流程，特别是在复杂部署中。
- en: '*Figure 5**.2* illustrates an instance of the App of Apps approach. In this
    example, a single Argo CD *application* corresponds to just one specific web application:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5**.2* 说明了“应用之应用”方法的一个示例。在此示例中，单个 Argo CD *应用* 仅对应一个特定的 Web 应用：'
- en: '![Figure 5.2 – The App of Apps approach](img/B22100_05_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 应用之应用方法](img/B22100_05_02.jpg)'
- en: Figure 5.2 – The App of Apps approach
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 应用之应用方法
- en: 'Examining the application manifest reveals key details:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 检查应用清单可揭示关键细节：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, `path` is set to directly point to the specific application. Next, let’s
    explore the App of Apps approach shown in *Figure 5**.3* for a more comprehensive
    understanding:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`path` 被设置为直接指向特定应用。接下来，让我们探索 *图 5**.3* 中展示的“应用之应用”方法，以便更全面地理解：
- en: '![Figure 5.3 – App of Apps](img/B22100_05_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 应用之应用](img/B22100_05_03.jpg)'
- en: Figure 5.3 – App of Apps
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 应用之应用
- en: 'Rather than directing toward a singular application manifest, as it did previously,
    the root app now references a specific folder within a Git repository. This folder
    contains all the individual application manifests that define and facilitate the
    creation and deployment of each application. By adopting this approach, it’s possible
    to declare all your applications within a unified YAML manifest. The following
    example demonstrates this pattern for enhanced comprehension:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前指向单个应用程序清单不同，根应用现在引用 Git 仓库中的特定文件夹。该文件夹包含所有单独的应用程序清单，这些清单定义并促进每个应用程序的创建和部署。通过采用这种方法，您可以在统一的
    YAML 清单中声明所有应用程序。以下示例展示了这一模式，以便更好地理解：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the provided definition, the `path` attribute instructs Argo CD to target
    a specific directory – in this case, named `simple-webapps` – located within the
    repository. This directory contains Kubernetes manifests that define the applications,
    as well as supporting various formats such as Helm, Kustomize, or plain YAML files.
    In the provided configuration, there are two notable attributes worth highlighting:
    `selfHeal: true` and `directory.recurse: true`. The `selfHeal` feature ensures
    automatic updates of the child applications in response to any changes detected,
    maintaining consistent deployment states. Additionally, the `recurse` setting
    enables the iteration through the `webapps` folders, facilitating the deployment
    of all applications contained within.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '在提供的定义中，`path` 属性指示 Argo CD 定位到仓库中的特定目录——在此例中为 `simple-webapps`。该目录包含定义应用程序的
    Kubernetes 清单，并支持诸如 Helm、Kustomize 或普通 YAML 文件等多种格式。在所提供的配置中，有两个值得注意的属性：`selfHeal:
    true` 和 `directory.recurse: true`。`selfHeal` 功能确保在检测到任何变化时自动更新子应用程序，保持一致的部署状态。此外，`recurse`
    设置允许迭代 `webapps` 文件夹，从而促进所有包含应用程序的部署。'
- en: Therefore, the App of Apps approach enables you to administer your *application*
    resources by simply updating your manifests in the Git repository – adding or
    removing application resources as needed. This approach reduces reliance on direct
    interactions with Argo CD *applications* through the web UI or **CLI**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，App of Apps 方法使您能够通过简单地更新 Git 仓库中的清单来管理您的*应用程序*资源——根据需要添加或删除应用程序资源。这种方法减少了对通过
    Web UI 或 **CLI** 与 Argo CD *应用程序*直接交互的依赖。
- en: Use cases of App of Apps combined with examples
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: App of Apps 的用例及示例
- en: 'The App of Apps approach in Argo CD is highly advantageous for managing multiple
    applications as a single entity while ensuring their isolation during deployment.
    This is particularly useful in scenarios such as cluster bootstrapping and managing
    Argo CD applications without relying on the CLI or UI. Let’s explore these use
    cases with relevant examples:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 中的 App of Apps 方法对于将多个应用程序作为单个实体进行管理，同时确保它们在部署过程中的隔离性非常有利。这在诸如集群引导和管理
    Argo CD 应用程序而不依赖 CLI 或 UI 等场景中特别有用。让我们通过相关示例来探讨这些用例：
- en: '**Cluster bootstrapping**: Imagine that you have a standard set of applications
    that need to be installed in every new Kubernetes cluster. Rather than deploying
    each application individually, you can group them into a single “root” application.
    This simplifies the process, allowing you to deploy the entire set of applications
    simultaneously, enhancing efficiency and consistency across different deployments.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群引导**：假设您有一组标准的应用程序，需要在每个新的 Kubernetes 集群中安装。与其单独部署每个应用程序，不如将它们分组为一个“根”应用程序。这样可以简化过程，允许您同时部署整个应用程序集，从而提高不同部署之间的效率和一致性。'
- en: '**Example for developers and service providers**: Let’s say you’re developing
    or providing services that involve deploying a custom yet similar stack for each
    deployment, such as the following:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**开发者和服务提供者示例**：假设您正在开发或提供涉及为每个部署部署一个自定义但相似的技术栈的服务，如下所示：'
- en: Frontend
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端
- en: Backend for frontend
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端与前端
- en: Database
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库
- en: The App of Apps approach allows you to encapsulate these components into a single
    deployment entity, streamlining the process.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: App of Apps 方法允许您将这些组件封装为一个单一的部署实体，从而简化过程。
- en: '**Managing Argo CD applications without the CLI or GUI**: You can modify an
    existing root application using Git operations, such as adding new folders to
    the paths it monitors. This capability lets Argo CD automatically deploy new applications
    or update existing ones without needing to interact through the CLI or web UI,
    aligning with GitOps principles of version control and auditability.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无需 CLI 或 GUI 管理 Argo CD 应用程序**：你可以使用 Git 操作修改现有的根应用程序，例如添加新的文件夹到其监视的路径中。这个功能让
    Argo CD 能够自动部署新的应用程序或更新现有应用程序，而无需通过 CLI 或 Web UI 进行交互，这与 GitOps 的版本控制和可审计性原则保持一致。'
- en: '**Example for platform engineers**: As a platform engineer, let’s say you’re
    providing a similar stack on Kubernetes for each customer, such as the following:'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**平台工程师示例**：作为平台工程师，假设你为每个客户在 Kubernetes 上提供类似的技术栈，例如如下所示：'
- en: '**Ingress-Controller**'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ingress-Controller**'
- en: '**Cert-Manager**'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cert-Manager**'
- en: '**External-DNS**'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**External-DNS**'
- en: The App of Apps approach is beneficial here as it allows you to manage these
    components effectively, ensuring that each customer’s environment is consistently
    configured with the necessary tools.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: “应用的应用”方法在这里非常有用，因为它使你能够有效地管理这些组件，确保每个客户的环境都能始终如一地配置所需的工具。
- en: In both use cases, the App of Apps approach facilitates a more streamlined,
    efficient, and consistent deployment process, whether you’re dealing with different
    client requirements as a service provider or ensuring uniformity across various
    Kubernetes clusters as a platform engineer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种使用场景中，“应用的应用”方法使得部署过程更加简洁、高效和一致，无论你是在作为服务提供商处理不同的客户需求，还是作为平台工程师确保多个 Kubernetes
    集群的一致性。
- en: The ApplicationSets approach
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ApplicationSets 方法
- en: In this section, you’ll discover the process of creating, updating, managing,
    and removing numerous Argo CD *applications* through the use of an *ApplicationSet*
    [*1*] controller.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解通过使用*ApplicationSet* [*1*] 控制器来创建、更新、管理和删除多个 Argo CD *应用程序*的过程。
- en: 'We will delve into the concept of an *ApplicationSet* and address key questions
    such as the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入探讨*ApplicationSet*的概念，并解答以下关键问题：
- en: What exactly constitutes an *ApplicationSet*?
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ApplicationSet*究竟由什么组成？'
- en: What are the functionalities and advantages of an *ApplicationSet*?
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ApplicationSet*的功能和优势是什么？'
- en: Why is a generator necessary, and what varieties exist?
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要生成器，且有哪些不同种类？
- en: In the Argo CD framework, an *ApplicationSet* [*2*] significantly enhances the
    GitOps strategy for **continuous deployment** (**CD**) within Kubernetes. This
    tool adeptly handles the complexity involved in managing a variety of Kubernetes
    manifests, such as deployments, services, secrets, and configuration files, all
    within a Git repository. Unlike the Argo CD *application* resource, which is limited
    to deploying resources from a single git repository to one cluster or namespace,
    the ApplicationSet extends this functionality. It utilizes templated automation
    to concurrently create, modify, and oversee multiple Argo CD applications, thereby
    broadening its operational scope to encompass several clusters and namespaces.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Argo CD 框架中，*ApplicationSet* [*2*] 显著提升了 Kubernetes 中**持续部署**（**CD**）的 GitOps
    策略。该工具巧妙地处理了管理各种 Kubernetes 清单的复杂性，例如部署、服务、密钥和配置文件，所有这些都保存在 Git 仓库中。与 Argo CD
    *应用程序*资源不同，后者仅限于从单一 Git 仓库部署资源到一个集群或命名空间，而 ApplicationSet 扩展了这一功能。它利用模板化自动化来同时创建、修改和管理多个
    Argo CD 应用程序，从而扩大了其操作范围，涵盖多个集群和命名空间。
- en: The ApplicationSet controller, which is installed in the same namespace as Argo
    CD, plays a crucial role. It generates a multitude of Argo CD applications from
    the ApplicationSet’s **custom resource** (**CR**). This arrangement ensures that
    your Argo CD applications are in sync with your specified resources, effectively
    transforming the ApplicationSet into one or more Argo CD applications, thus enhancing
    overall deployment efficiency and scalability.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 安装在与 Argo CD 相同命名空间中的 ApplicationSet 控制器发挥着至关重要的作用。它通过 ApplicationSet 的**自定义资源**（**CR**）生成多个
    Argo CD 应用程序。这种安排确保你的 Argo CD 应用程序与指定的资源保持同步，实质上将 ApplicationSet 转化为一个或多个 Argo
    CD 应用程序，从而提升整体部署效率和可扩展性。
- en: '*Generate* refers to the process employed by the controller using various **generators**,
    but what exactly are these generators? Generators in the ApplicationSet resource
    play a crucial role by creating parameters that are incorporated into the template
    fields, ultimately generating Argo CD Applications. For a practical example of
    this process, refer to this chapter’s introduction. The functionality of generators
    is determined by their data sources. For instance, the List generator derives
    parameters from a predefined list, the Cluster generator utilizes the Argo CD
    cluster list, and the Git generator gets sources from files or directories in
    a Git repository.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*生成* 指的是控制器使用各种 **生成器** 的过程，那么这些生成器到底是什么呢？在 ApplicationSet 资源中，生成器通过创建将被纳入模板字段的参数，从而发挥重要作用，最终生成
    Argo CD 应用程序。关于这一过程的实际示例，请参阅本章引言。生成器的功能由其数据源决定。例如，List 生成器从预定义的列表中获取参数，Cluster
    生成器使用 Argo CD 集群列表，Git 生成器从 Git 仓库中的文件或目录中获取源。'
- en: There are numerous generators for different use cases and roles within ApplicationSets.
    For instance, there’s the Cluster generator, which is ideal for **platform engineers**
    to scale their platforms, and the Pull Request generator, which allows developers
    to deploy features for QA through GitOps. Additionally, the **Matrix generator**
    allows you to combine up to two generators to meet more specific requirements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ApplicationSets 中有许多不同的生成器，适用于不同的使用场景和角色。例如，Cluster 生成器非常适合 **平台工程师** 用于扩展他们的平台，而
    Pull Request 生成器则允许开发人员通过 GitOps 部署功能给 QA。此外，**Matrix 生成器** 允许将最多两个生成器组合在一起，以满足更具体的需求。
- en: 'We’ll be utilizing the Cluster generator to implement GitOps at scale. Moving
    beyond theory, let’s dive into its practical application. We’ll start with a single
    cluster, tagging it with a label such as *env=prod*. This can be done in the Argo
    CD UI by navigating to **Settings** | **Clusters** | **Select In-Cluster** |**Edit**
    | **Add Labels**:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用 Cluster 生成器来大规模实现 GitOps。超越理论，让我们深入探讨它的实际应用。我们将从一个单一集群开始，给它添加一个标签，如 *env=prod*。可以在
    Argo CD 用户界面中通过导航到 **设置** | **集群** | **选择集群内** | **编辑** | **添加标签** 来完成：
- en: '![Figure 5.4 – Adding labels](img/B22100_05_04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 添加标签](img/B22100_05_04.jpg)'
- en: Figure 5.4 – Adding labels
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 添加标签
- en: 'Now, create an `ApplicationSet` manifest, like so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个 `ApplicationSet` 清单，如下所示：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we’re employing the Cluster generator, which is designed to deploy our
    `simple-webapp` across various Kubernetes clusters. By using the `env=prod` selector,
    the *ApplicationController* will create several applications corresponding to
    the count of your clusters. Each application’s name will be modified to include
    the cluster name – for example, `in-cluster-simple-webapp`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 Cluster 生成器，它旨在将我们的 `simple-webapp` 部署到多个 Kubernetes 集群中。通过使用 `env=prod`
    选择器，*ApplicationController* 会根据集群的数量创建多个应用程序。每个应用程序的名称将被修改为包含集群名称，例如 `in-cluster-simple-webapp`。
- en: 'To apply `ApplicationSet`, use the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用 `ApplicationSet`，请使用以下命令：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To view `ApplicationSet`, run the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `ApplicationSet`，请运行以下命令：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also view a templated application like so:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过以下方式查看模板化的应用程序：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you check the Argo CD UI, you won’t find the ApplicationSet directly,
    but you will see the templated application, named `in-cluster-simple-webapp`.
    This application is managed by the application controller in the following manner:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查 Argo CD 用户界面时，你不会直接找到 ApplicationSet，但你会看到名为 `in-cluster-simple-webapp`
    的模板化应用程序。该应用程序由应用程序控制器以如下方式管理：
- en: '![Figure 5.5 – The application templated through an ApplicationSet, managed
    by the application controller, and informed over the Cluster generator](img/B22100_05_05.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 通过 ApplicationSet 模板化的应用程序，由应用程序控制器管理，并通过 Cluster 生成器提供信息](img/B22100_05_05.jpg)'
- en: Figure 5.5 – The application templated through an ApplicationSet, managed by
    the application controller, and informed over the Cluster generator
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 通过 ApplicationSet 模板化的应用程序，由应用程序控制器管理，并通过 Cluster 生成器提供信息
- en: The templated application is visible through the `ApplicationSet` manifest,
    where the application controller uses the Cluster generator to set the necessary
    parameters.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `ApplicationSet` 清单可以查看模板化的应用程序，其中应用程序控制器使用 Cluster 生成器来设置必要的参数。
- en: Which approach should be used?
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应该使用哪种方法？
- en: In most projects I’ve been involved in, teams prefer using individual applications
    and ApplicationSets over the App of Apps approach. From a platform engineer’s
    [*3*] perspective, for creating scalable infrastructure with GitOps, the ApplicationSets
    approach seems to be the most logical choice.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我参与的多数项目中，团队倾向于使用单独的应用程序和 ApplicationSets，而不是应用程序的应用程序方法。从平台工程师的[*3*]角度来看，为了通过
    GitOps 创建可扩展的基础设施，ApplicationSets 方法似乎是最合逻辑的选择。
- en: 'The App of Apps pattern in Argo CD is suitable for the following aspects:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 中的“应用程序的应用程序”模式适用于以下方面：
- en: '**Bootstrapping multiple applications**: Efficiently deploy numerous applications
    simultaneously.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引导多个应用程序**：高效地同时部署多个应用程序。'
- en: '**Managing applications as a single unit**: Simplify the management of multiple
    applications.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将应用程序作为单一单元进行管理**：简化多个应用程序的管理。'
- en: '**Enhancing the deployment workflow**: Streamline the process of deploying
    and updating applications.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化部署工作流**：简化应用程序的部署和更新过程。'
- en: 'ApplicationSets can be particularly beneficial in the following scenarios:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ApplicationSets 在以下场景中特别有用：
- en: '**Creating flexible deployment strategies for diverse environments**: Deploy
    to multiple Kubernetes clusters, to different namespaces in different clusters,
    or to different namespaces on a single cluster (developer, DevOps, and platform
    engineer).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为多样化的环境创建灵活的部署策略**：可以部署到多个 Kubernetes 集群，部署到不同集群中的不同命名空间，或部署到单一集群中的不同命名空间（开发人员、DevOps
    和平台工程师）。'
- en: '**Managing Applications in Monorepos**: Deploy from different Git repositories,
    SCM providers, or folders (developer, DevOps, platform engineer).'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在 Monorepos 中管理应用程序**：从不同的 Git 仓库、SCM 提供商或文件夹中部署（开发人员、DevOps、平台工程师）。'
- en: '**Enabling self-service for multi-tenant clusters**: ApplicationSets can facilitate
    a self-service model, particularly with the Pull Request generator. This allows
    developers to deploy applications in multi-tenant clusters with greater autonomy,
    without needing cluster-level permissions (collaboration between developers and
    platform engineers).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为多租户集群启用自服务**：ApplicationSets 可以促进自服务模型，特别是通过 Pull Request 生成器。这允许开发人员在多租户集群中更自主地部署应用程序，无需集群级别的权限（开发人员与平台工程师的协作）。'
- en: '**Deploying cluster add-ons across multiple clusters**: Using the Cluster generator,
    you can target add-ons to specific clusters managed within Argo CD, which is useful
    for large-scale, multi-cluster environments (platform engineers, **Site Reliability
    Engineers** (**SREs**) and DevSecOps engineering).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨多个集群部署集群附加组件**：通过集群生成器，你可以将附加组件部署到 Argo CD 管理的特定集群，这对于大规模的多集群环境非常有用（平台工程师、**站点可靠性工程师**（**SREs**）和
    DevSecOps 工程师）。'
- en: Contrasting this with the App of Apps approach, which is more suited for managing
    a collection of related applications within a single repository or cluster, ApplicationSets
    offer more flexibility and scalability, especially in environments with diverse
    deployment needs. They allow for more granular and distributed control, aligning
    with complex infrastructure requirements and multi-cluster strategies.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与“应用程序的应用程序”方法相比，后者更适合在单一仓库或集群内管理一组相关的应用程序，ApplicationSets 提供了更多的灵活性和可扩展性，特别是在具有多样化部署需求的环境中。它们允许更细粒度和分布式的控制，与复杂的基础设施需求和多集群策略保持一致。
- en: Later, we will adopt an ApplicationSet to develop a scalable model for an IDP,
    referred to as KSC. This platform aims to efficiently manage a large number of
    Kubernetes clusters while ensuring up-to-date security measures are maintained.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将采用 ApplicationSet 来开发一个 IDP 的可扩展模型，称为 KSC。该平台旨在高效管理大量 Kubernetes 集群，同时确保持续更新的安全措施得到维护。
- en: Next, we’ll take a deep dive to understand what multi-cluster management means
    in the context of GitOps with Argo CD and what possibilities it opens.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入了解在 Argo CD 的 GitOps 环境中，多集群管理意味着什么以及它为我们打开了哪些可能性。
- en: Understanding multi-cluster management
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多集群管理
- en: 'In this section, we’ll delve into our experiences with two different approaches
    to managing multi-cluster environments within the GitOps framework. Our focus
    is not on the tools themselves, but rather on the overarching strategy of orchestrating
    and managing these clusters as though they were a singular platform. Through this
    exploration, we aim to impart a deeper understanding of these methodologies, emphasizing
    that the key lies in effective orchestration rather than a comparison of specific
    tools. We’ll discuss two distinct concepts:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨两种不同的方法，来管理GitOps框架中的多集群环境。我们的重点不在于工具本身，而是在于如何将这些集群作为一个统一的平台来协调和管理的总体战略。通过这次探索，我们希望能够传达一种更深入的理解，强调有效的协调才是关键，而不是具体工具的对比。我们将讨论两个不同的概念：
- en: '**One cockpit to rule them all**: This concept emphasizes centralized management
    and orchestration of multiple clusters as a unified platform'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个控制台，统领一切**：该概念强调以集中管理和协调多个集群，作为一个统一的平台。'
- en: '**One cockpit – diverse fleet management**: This concept focuses on managing
    a diverse range of Argo CD clusters from a single control point while considering
    security aspects of inter-cluster communication'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个控制台 – 多样化舰队管理**：该概念侧重于从单一控制点管理多个Argo CD集群，同时考虑集群间通信的安全性问题。'
- en: In terms of tool selection, our experience suggests that Argo CD, with its support
    for clusters, ApplicationSets, and generators, is better suited for scaling with
    GitOps in multi-cluster environments compared to Flux, which lacks a dedicated
    multi-cluster management concept. This differentiation becomes clearer in contexts
    where management extends beyond dedicated clusters to scenarios such as **vCluster**
    approaches within a host cluster.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具选择方面，我们的经验表明，Argo CD由于其支持集群、ApplicationSets和生成器，比Flux更适合在多集群环境中通过GitOps进行扩展，后者缺乏专门的多集群管理概念。当管理扩展到超出专用集群的场景，如主机集群中的**vCluster**方法时，这种差异更为明显。
- en: 'Here are some additional considerations for multi-cluster management in a GitOps
    framework:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于在GitOps框架中进行多集群管理的额外考虑因素：
- en: '**High availability and disaster recovery**: This includes deploying across
    multiple regions or even using multiple providers to ensure robustness and resilience'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高可用性和灾难恢复**：包括在多个区域部署，甚至使用多个提供商，以确保系统的稳健性和恢复力。'
- en: '**Existing expertise**: The level of knowledge in Kubernetes, the cloud, or
    GitOps within the organization plays a critical role'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现有专业知识**：组织内Kubernetes、云计算或GitOps的知识水平起着至关重要的作用。'
- en: '**Budget constraints**: The costs involved in multi-cluster management should
    not exceed a predetermined amount'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预算限制**：多集群管理的成本不应超过预定的金额。'
- en: '**Compliance and regulatory requirements**: Ensuring adherence to industry
    standards and legal regulations in different regions or sectors'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合规性和法规要求**：确保在不同区域或行业遵守行业标准和法律法规。'
- en: '**Network infrastructure and latency**: Optimizing for network performance
    and reducing latency, something that’s especially important in geographically
    dispersed clusters'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络基础设施和延迟**：优化网络性能和减少延迟，这在地理分布较广的集群中尤其重要。'
- en: '**Cloud or service provider implementation**: For example, AKS works with Flux
    CD for its GitOps implementation, while OpenShift uses Argo CD for GitOps deployments'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云或服务提供商实现**：例如，AKS与Flux CD一起使用进行GitOps实现，而OpenShift使用Argo CD进行GitOps部署。'
- en: Overall, the choice between Argo CD and Flux CD hinges on their respective capabilities
    in orchestrating and managing multi-cluster environments and specific use case
    requirements.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，选择Argo CD或Flux CD的关键在于它们在协调和管理多集群环境方面的能力，以及具体的使用案例需求。
- en: One cockpit to rule them all
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个控制台，统领一切
- en: 'In this approach, there is a single Argo CD instance that’s shared by both
    developers and platform engineers (*Figure 5**.6*). This shared instance allows
    platform engineers to offer centralized management functions and comprehensive
    control over various Kubernetes clusters. They manage and monitor all deployments,
    ensuring developers have access to the required resources while upholding company
    policies and security standards. This method promotes collaboration and provides
    a unified view of all clusters, effectively reducing complexity in large, distributed
    organizations:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，开发人员和平台工程师共享一个 Argo CD 实例（*图 5.6*）。这个共享实例使平台工程师能够提供集中式管理功能，并对各个 Kubernetes
    集群进行全面控制。他们管理和监控所有的部署，确保开发人员能够访问所需的资源，同时遵循公司政策和安全标准。这种方法促进了协作，并提供了所有集群的统一视图，有效地减少了大型分布式组织中的复杂性：
- en: '![Figure 5.6 – One cockpit to rule them all – with a common Argo CD instance](img/B22100_05_06.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 一机掌控 – 使用共享 Argo CD 实例](img/B22100_05_06.jpg)'
- en: Figure 5.6 – One cockpit to rule them all – with a common Argo CD instance
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 一机掌控 – 使用共享 Argo CD 实例
- en: 'In the *one cockpit to rule them all* approach for GitOps with Argo CD, the
    following are some crucial considerations:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitOps 使用 Argo CD 的 *一机掌控* 方法中，以下是一些关键的考虑事项：
- en: '**Developer access**: Determining developer access to the Argo CD UI involves
    establishing **role-based access control** (**RBAC**) associated with groups,
    projects, and roles, potentially including Dex and OIDC provider integration.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发人员访问**：确定开发人员访问 Argo CD UI 需要建立与组、项目和角色相关的 **基于角色的访问控制** (**RBAC**)，可能还包括
    Dex 和 OIDC 提供者的集成。'
- en: '**Project access control**: Limiting team access to specific projects to prevent
    unauthorized deployments across clusters.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目访问控制**：限制团队对特定项目的访问，以防止在集群间未经授权的部署。'
- en: '**Resources allocation**: Are savings being made in the right areas? This question
    prompts a critical evaluation of resource allocation, questioning whether cost
    savings are effectively targeted in areas that maximize efficiency and overall
    value.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源分配**：节省是否在正确的领域进行？这个问题促使对资源分配进行关键评估，质疑成本节省是否有效地集中在最大化效率和整体价值的领域。'
- en: '**Version updates**: Coordinating updates for Argo CD across teams on a shared
    instance used by multiple teams is crucial. This coordination ensures version
    compatibility and prevents issues related to API deprecations, maintaining a stable
    and functional GitOps environment for all teams.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本更新**：协调多个团队共享实例中 Argo CD 的更新至关重要。这种协调确保版本兼容性，防止与 API 废弃相关的问题，保持一个稳定和功能齐全的
    GitOps 环境供所有团队使用。'
- en: Working with multiple teams on this approach brings a multitude of questions
    and considerations that need to be addressed, emphasizing the complexity and planning
    required for effective implementation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与多个团队合作时，这种方法带来了众多问题和考虑因素，需要解决，强调了有效实施所需的复杂性和规划。
- en: 'Here are some points based on our experience with this approach:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在使用这种方法时的几点经验：
- en: Shared Argo CD usage often led to increased system load, occasionally causing
    outages
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享 Argo CD 的使用常常导致系统负载增加，偶尔引发故障
- en: Integration of features such as Argo CD’s PR-Generator added complexity
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argo CD 的 PR-生成器等功能的集成增加了复杂性
- en: It necessitated robust multitenancy frameworks and tools
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这需要强大的多租户框架和工具
- en: Argo CD, as the sole point of control, introduced a heightened risk of system
    failure
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argo CD 作为唯一的控制点，引入了系统故障的更高风险
- en: The increase in teams significantly raised the requirements for communication
    and system maintenance
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队数量的增加显著提高了沟通和系统维护的要求
- en: While there were savings in hardware resources, these were counterbalanced by
    greater demands on human resources for management and coordination
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然在硬件资源上有节省，但这些节省被对人力资源的更大需求所抵消，这些人力资源用于管理和协调。
- en: We employ this approach for shared clusters to facilitate cold starts, save
    money and resources, provide a learning platform, and offer shared services such
    as documentation and runners. A shared cluster is more relevant for incubating
    projects, and when a project is mature or needs to head for production, it should
    be moved onto its own cluster.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采用这种方法来共享集群，以便促进冷启动、节省资金和资源、提供学习平台，并提供共享服务，如文档和执行器。共享集群更适合孵化项目，当一个项目成熟或需要进入生产阶段时，应该转移到自己的集群上。
- en: One cockpit – multiple fleet and commander concept
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一机掌控 – 多舰队指挥官概念
- en: 'In this concept, one Argo CD instance will be used by the platform team to
    deploy and manage the whole infrastructure that’s needed by developer teams. The
    platform team also deploys dedicated Argo CD instances with a **dedicated UI**
    for every team. The focus is the same, but it’s more so about the orchestration
    process and managing those clusters as if they were a single platform. The developer
    will get their dedicated Argo CD instance:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一概念中，平台团队将使用一个Argo CD实例来部署和管理开发团队所需的整个基础设施。平台团队还会为每个团队部署专用的Argo CD实例，并为每个团队提供**专用UI**。重点依然相同，但更侧重于编排过程以及将这些集群管理为一个统一平台的方式。开发者将获得自己的专用Argo
    CD实例：
- en: '![Figure 5.7: One cockpit – diverse fleet management with dedicated Argo CD
    instances per cluster](img/B22100_05_07.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7：一个驾驶舱 – 多样化舰队管理，每个集群都有专用的Argo CD实例](img/B22100_05_07.jpg)'
- en: 'Figure 5.7: One cockpit – diverse fleet management with dedicated Argo CD instances
    per cluster'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：一个驾驶舱 – 多样化舰队管理，每个集群都有专用的Argo CD实例
- en: 'In contrast to the *one cockpit to rule them all* approach, this approach involves
    the following aspects:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与*一个驾驶舱掌控一切*的方法相比，这种方法涉及以下几个方面：
- en: '**Dedicated Argo CD instances**: Each cluster is managed by its own Argo CD
    instance, enhancing individual cluster autonomy and reducing risks associated
    with a single point of failure.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专用的Argo CD实例**：每个集群由其自身的Argo CD实例管理，从而增强了每个集群的自主性并减少了单点故障的风险。'
- en: '**Autonomous project management**: Each team manages projects within their
    designated clusters, allowing for greater control and customization.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自主项目管理**：每个团队在其指定的集群内管理项目，从而实现更大的控制和定制化。'
- en: '**Resource allocation**: Instead of leveraging a shared Argo CD instance, each
    cluster operates its own stack. While this may offer focused resource management
    within individual Argo CD instances per cluster, it potentially leads to higher
    overall resource consumption.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源分配**：与其依赖共享的Argo CD实例，不如每个集群运行自己的堆栈。虽然这种方式可以在每个集群的独立Argo CD实例内提供集中的资源管理，但可能会导致整体资源消耗增加。'
- en: '**Version control autonomy**: Each team controls the version updates of their
    Argo CD instance, ensuring smooth operation and compatibility within their cluster
    environment.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制自主性**：每个团队控制其Argo CD实例的版本更新，确保在其集群环境内的平稳运行和兼容性。'
- en: 'Here are some insights from our experience with the *one cockpit – diverse
    fleet* *management* approach:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们在使用*一个驾驶舱 – 多样化舰队* *管理*方法中的一些经验：
- en: '**Increased autonomy**: Dedicated resources and UI access grant more **freedom**,
    **flexibility**, and **responsibility**. This setup allows for self-service and
    extended control for developers, enabling them to focus on development.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更高的自主性**：专用资源和UI访问权限赋予更多的**自由**、**灵活性**和**责任**。这种设置允许开发者进行自助服务并扩展控制，让他们专注于开发。'
- en: '**Ease of onboarding**: This model simplifies GitOps adoption, making it suitable
    for both newcomers and experienced teams. Onboarding new colleagues requires less
    time with this approach.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻松上手**：这种模式简化了GitOps的采用，使其适合新手和有经验的团队。采用这种方法，新的同事上手所需的时间更少。'
- en: '**Resource consumption**: While offering clear team separation, this approach
    can lead to greater resource usage.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源消耗**：尽管提供了明确的团队隔离，但这种方法可能导致更高的资源使用。'
- en: '**Enhanced security**: The compromise of one Argo CD instance doesn’t impact
    others, increasing overall security.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的安全性**：一个Argo CD实例的被攻破不会影响其他实例，从而提高了整体安全性。'
- en: '**Platform team focus**: Platform teams concentrate on scaling and engineering
    services for a scalable, self-service approach. Less time is needed for interactions
    with development teams and for creating and hardening multitenancy aspects related
    to the shared Argo CD instance.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台团队专注**：平台团队专注于为可扩展的自助式方法扩展和工程化服务。与开发团队的互动时间减少，同时创建和加固与共享Argo CD实例相关的多租户功能所需的时间也更少。'
- en: '**Resilience and isolation**: This approach enhances resilience and isolation
    for each project or development team. It eliminates issues with noisy neighbors,
    and upgrades to Kubernetes or infrastructure by other teams or projects do not
    affect individual teams, ensuring smoother operations and reduced disruptions.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**韧性和隔离**：这种方法增强了每个项目或开发团队的韧性和隔离性。它消除了邻居噪声问题，其他团队或项目对Kubernetes或基础设施的升级不会影响单个团队，确保更平稳的操作并减少干扰。'
- en: This approach is adopted for handling **critical workloads**, ensuring strict
    tenant separation, enhancing developers’ self-service capabilities, and bolstering
    security in compliance with stringent requirements for security, governance, and
    compliance. In the realm of GitOps, which is central to continuously delivering
    software into clusters, this approach becomes even more crucial when scaling,
    particularly from a security perspective in DevOps practices.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法用于处理**关键工作负载**，确保严格的租户隔离，增强开发人员的自服务能力，并在符合安全、治理和合规性严格要求的情况下增强安全性。在 GitOps
    领域，尤其是在从安全角度进行 DevOps 实践时，随着规模的扩大，这种方法变得尤为重要。
- en: In managing multi-cluster environments at scale with GitOps, the emphasis extends
    beyond just overseeing dedicated Kubernetes clusters. It involves leveraging Argo
    CD to address varied needs and deploy diverse workloads, including both customer
    applications and infrastructure components, while maintaining security compliance
    across different clusters. This approach aims to bridge the gap between developers
    and platform engineers, fostering scalability and boosting productivity in both
    domains.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模管理多集群环境时，GitOps 的重点不仅仅是监督专用 Kubernetes 集群。它还涉及利用 Argo CD 来满足不同的需求并部署多种工作负载，包括客户应用程序和基础设施组件，同时在不同集群之间维持安全合规性。这种方法旨在弥合开发人员和平台工程师之间的差距，促进可扩展性，并提高两个领域的生产力。
- en: However, there is another gap with GitOps that relates to the best way to set
    up a staging concept. This will be explained in more detail in the next section.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，GitOps 还有另一个缺口，涉及如何设定最佳的暂存概念。这将在下一节中进行更详细的解释。
- en: Understanding effective Git repository strategies
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解有效的 Git 仓库策略
- en: Understanding how to effectively promote applications between stages in a GitOps
    framework, especially at scale, is a crucial challenge for both developers and
    platform engineers. Deploying an application to various environments involves
    navigating complexities beyond a single deployment scenario. With Argo CD, the
    process becomes more manageable, allowing deployment across multiple clusters
    without needing multiple CD pipelines.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitOps 框架中有效地推动应用程序在各个阶段之间的推广，尤其是在大规模操作时，是开发人员和平台工程师面临的一个关键挑战。将应用程序部署到不同的环境涉及超越单一部署场景的复杂性。使用
    Argo CD 后，整个过程变得更加可管理，能够在多个集群间部署，而无需多个 CD 管道。
- en: 'This section delves into various approaches for managing environments: environment
    branches, environment per Git, and folders for environments. Each has its pros
    and cons, and the choice largely depends on the specific needs of the project
    and the team’s expertise. Companies such as **Codefresh** [*4*] have developed
    solutions to facilitate stage propagation with Argo CD. However, this book focuses
    more on understanding these approaches rather than specific tools, guiding you
    to choose the most suitable strategy for your environment.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本节深入探讨了管理环境的各种方法：环境分支、每个 Git 的环境以及环境文件夹。每种方法都有其优缺点，选择通常取决于项目的具体需求和团队的专业知识。像**Codefresh**
    [*4*]这样的公司已经开发了解决方案，以便通过 Argo CD 促进阶段传播。然而，本书更侧重于理解这些方法，而非具体工具，引导你选择最适合你环境的策略。
- en: Environment branches
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境分支
- en: The environment-per-branch [*4*] approach in GitOps, which involves using branches
    to represent different environments such as staging or production, is often considered
    an anti-pattern. This approach can complicate pull requests and merges between
    branches, create configuration drifts, and increase maintenance challenges with
    a large number of environments. It also contrasts with the Kubernetes ecosystem
    and is generally better suited for legacy applications. In GitOps, it’s recommended
    to separate application source code and environment configuration into different
    repositories, avoiding the branch-per-environment model. For deployment promotions,
    Git merges can be problematic due to conflicts and unintended changes, making
    promotion management more complex than it appears.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps 中的每分支一个环境[*4*]方法，涉及使用分支来表示不同的环境，如暂存环境或生产环境，通常被认为是一种反模式。这种方法可能会使拉取请求和分支之间的合并变得复杂，产生配置漂移，并在管理大量环境时增加维护难度。它也与
    Kubernetes 生态系统相矛盾，通常更适合传统应用程序。在 GitOps 中，建议将应用程序源代码和环境配置分开存储在不同的仓库中，避免使用每分支一个环境的模式。对于部署推广，Git
    合并可能会因为冲突和无意更改而变得复杂，这使得推广管理比看起来更为复杂。
- en: Advantages of the environment-per-branch approach include familiarity for many
    developers and the theoretical simplicity of promoting releases through git merges.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分支环境方法的优点包括对许多开发人员的熟悉性，以及通过git合并推广版本的理论简单性。
- en: 'However, the disadvantages are significant if you’re working with GitOps and
    Kubernetes:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你正在使用GitOps和Kubernetes，缺点是显而易见的：
- en: '**Complex merges**: Promotion through Git merges can lead to conflicts and
    unintended changes'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂合并**：通过Git合并的推广可能会导致冲突和意外的更改'
- en: '**Configuration drift**: Different branches might lead to environment-specific
    code, causing configuration drift'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置漂移**：不同的分支可能导致环境特定的代码，造成配置漂移'
- en: '**Maintenance challenges**: Managing a large number of branches can become
    unwieldy'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护挑战**：管理大量分支可能变得难以控制'
- en: '**Dependent changes**: Difficulties arise in managing changes that have dependencies
    as not all commits can be cleanly cherry-picked'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖变更**：管理有依赖的变更会遇到困难，因为并非所有提交都能干净地挑选出来'
- en: Now, let’s explore a straightforward deployment manifest as an illustrative
    example.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索一个简单的部署清单作为示例。
- en: '![Figure 5.8: How to propagate between stages](img/B22100_05_08.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8：如何在各阶段之间传播](img/B22100_05_08.jpg)'
- en: 'Figure 5.8: How to propagate between stages'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：如何在各阶段之间传播
- en: This basic example illustrates the need to incorporate propagation logic in
    deployment manifests, ensuring that specific values, such as the number of replicas,
    are appropriately scaled for each stage according to its unique requirements.
    Using tools such as Helm or Kustomize with GitOps can present challenges as Helm
    uses different `values.yaml` files for stages, and Kustomize relies on overlays.
    Additionally, GitOps, based on the Kubernetes ecosystem, brings its own complexities
    that must be managed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本示例说明了在部署清单中结合传播逻辑的必要性，确保特定的值，例如副本数量，能够根据每个阶段的独特需求进行适当扩展。使用Helm或Kustomize与GitOps一起时可能会遇到挑战，因为Helm为各个阶段使用不同的`values.yaml`文件，而Kustomize依赖于覆盖。此外，基于Kubernetes生态系统的GitOps也带来了自身的复杂性，必须加以管理。
- en: While this approach might suit legacy applications, it’s less ideal for modern
    Kubernetes environments. Branches can still be used for features and PRs for testing
    changes. However, you still need pipelines or workflows to commit the changes
    into Git. There is an option for writing back to Git outside of Argo CD. Tools
    like Argo CD and its PR-Generator can help manage these processes, but note that
    the PR generator is used to manifest Git content into the cluster, not the other
    way around.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法可能适用于传统应用程序，但对于现代的Kubernetes环境来说并不理想。分支仍然可以用于功能开发和PR用于测试变更。然而，你仍然需要管道或工作流将变更提交到Git中。也有一种在Argo
    CD外部将变更写回Git的选项。像Argo CD及其PR生成器这样的工具可以帮助管理这些过程，但请注意，PR生成器是将Git内容传递到集群中，而不是反向操作。
- en: Environment per Git
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个环境一个Git
- en: 'The `main` but through pull requests and review workflows. For heightened security
    needs, organizations can use two git repositories: one for all production-related
    configurations and environments, and another for non-production elements, balancing
    security with a manageable number of repositories.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`分支通过拉取请求和审查工作流。对于需要更高安全性的需求，组织可以使用两个git仓库：一个用于所有与生产相关的配置和环境，另一个用于非生产元素，在确保安全的同时平衡可管理的仓库数量。'
- en: Throughout my career, I’ve only encountered one team that adopted this approach
    specifically to prevent junior developers from accidentally accessing and exposing
    sensitive data.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，我只遇到过一个团队采用这种方法，专门为了防止初级开发人员无意中访问和暴露敏感数据。
- en: Folders for environments
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境文件夹
- en: Adopting the **environment-per-folder** approach in GitOps and Kubernetes involves
    organizing different environment configurations within separate folders of a single
    Git repository. Each folder represents a specific environment such as **development**,
    **staging**, or **production**. This structure allows for clear separation and
    management of configurations for each environment, facilitating easier updates
    and maintenance. It streamlines the deployment process in Kubernetes, aligning
    with the principles of GitOps by keeping all environment configurations in a unified
    repository, ensuring consistency and traceability of changes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitOps 和 Kubernetes 中采用 **按环境分文件夹** 的方法，涉及将不同环境的配置组织在单个 Git 仓库的独立文件夹中。每个文件夹代表一个特定的环境，如
    **development**、**staging** 或 **production**。这种结构使得每个环境的配置能够清晰地分离和管理，简化了更新和维护。它使得
    Kubernetes 的部署过程更加简洁，与 GitOps 原则保持一致，通过将所有环境配置保存在统一的仓库中，确保更改的一致性和可追溯性。
- en: To effectively create a folder structure for Kubernetes, start by understanding
    your business needs, such as developing highly available portals for different
    countries and their specific version requirements. Then, integrate business-related
    values, such as a company logo, into all environments. Also, consider dynamic
    customer-related values, such as customer status levels such as *silver*, *gold*,
    or *platinum*. This approach ensures that your Kubernetes settings, such as the
    minimum replica count, are aligned with both general and specific business requirements.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要有效地为 Kubernetes 创建文件夹结构，首先需要了解你的业务需求，例如为不同国家开发高度可用的门户以及各自的版本要求。然后，将与业务相关的值（如公司徽标）整合到所有环境中。此外，还要考虑动态的客户相关值，例如客户状态等级，如
    *silver*、*gold* 或 *platinum*。这种方法确保你的 Kubernetes 设置（如最小副本数）与通用和特定的业务需求保持一致。
- en: 'We will use the same example we did previously for the environment-per-folder
    approach:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前在按文件夹分环境方法中所做的相同示例：
- en: '![Figure 5.9: How to propagate between stages with folders for environments](img/B22100_05_09.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9：如何通过环境文件夹在阶段之间传播](img/B22100_05_09.jpg)'
- en: 'Figure 5.9: How to propagate between stages with folders for environments'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：如何通过环境文件夹在阶段之间传播
- en: 'We will showcase the ease of change propagation across environments using **Kustomize**.
    The first step involves setting up a specific folder structure to facilitate this
    process:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何使用 **Kustomize** 轻松实现跨环境的变更传播。第一步是设置特定的文件夹结构来促进这一过程：
- en: '![Figure 5.10: Example stages with folders for environments](img/B22100_05_10.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10：带有环境文件夹的示例阶段](img/B22100_05_10.jpg)'
- en: 'Figure 5.10: Example stages with folders for environments'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：带有环境文件夹的示例阶段
- en: 'Exploring the file structure, the base directory contains configurations that
    are shared across all environments and typically undergoes infrequent changes.
    For simultaneous modifications across multiple environments, the `base` folder
    is the ideal location to manage these changes as it provides a centralized point
    for updates affecting various deployment settings:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 探索文件结构时，`base` 目录包含跨所有环境共享的配置，通常进行的更改较少。对于多个环境同时修改的情况，`base` 文件夹是管理这些更改的理想位置，因为它为影响不同部署设置的更新提供了一个集中的更新点：
- en: ./base/deployment.yaml
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ./base/deployment.yaml
- en: '[PRE6]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this simple example, you can see that we cover all the points, such as the
    specific version, business-related values, and more from the previous description:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的示例中，你可以看到我们涵盖了之前描述中所有的要点，比如具体版本、与业务相关的值等：
- en: './base/kustomization.yaml:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: './base/kustomization.yaml:'
- en: '[PRE7]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `base` folder, also known as mixins or components, contains configurations
    common to different environments. Its contents are defined based on what you consider
    to be shared characteristics across your environments, a decision guided by your
    application’s specific needs. In our example, this folder includes configurations
    for the QA, staging, and production environments.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`base` 文件夹，也称为 mixins 或组件，包含不同环境共享的配置。其内容根据你认为在各个环境中共享的特性来定义，这一决策由你的应用程序的具体需求来指导。在我们的示例中，这个文件夹包括
    QA、staging 和生产环境的配置。'
- en: 'In this section, we’ll modify the base deployment by applying QA-specific configurations
    using a `patch.yaml` file. This approach allows us to customize the base setup
    for the QA environment without altering the common deployment settings:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过应用 QA 特定的配置，使用 `patch.yaml` 文件修改基础部署。这种方法允许我们为 QA 环境自定义基础设置，而无需更改通用的部署设置：
- en: './overlays/qa/kustomization.yaml:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: './overlays/qa/kustomization.yaml:'
- en: '[PRE8]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code shows how to overwrite the color in the base with a patch
    and thus allow a stage that’s specific for `qa` configuration:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用补丁覆盖基础版本中的颜色，从而允许针对 `qa` 配置的特定阶段：
- en: './overlays/qa/patch.yaml:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: './overlays/qa/patch.yaml:'
- en: '[PRE9]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Important note
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `kustomize` tool in Kubernetes allows you to customize your YAML configurations
    without having to modify the original files. It enables you to manage configuration
    variations in a more structured and scalable way by using patches, overlays, and
    other techniques to generate final configuration manifests.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的 `kustomize` 工具允许你自定义 YAML 配置，而无需修改原始文件。它通过使用补丁、覆盖层和其他技术，以更结构化和可扩展的方式管理配置变化，从而生成最终的配置清单。
- en: 'You can easily check the patching changes by executing the `kustomize` CLI
    tool from inside the `..chapter05/chapter-5-effective-git-repository-strategies/folders-for-environments`
    folder with the following command, which will show that the base overlay has been
    patched:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 `..chapter05/chapter-5-effective-git-repository-strategies/folders-for-environments`
    文件夹内执行以下命令，轻松查看补丁更改，这将显示基础覆盖层已被打补丁：
- en: '[PRE10]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this stage, we will conduct tests on a specific version that incorporates
    business-related values. This version is intended to eventually become the new
    release for our “gold” customers in the future.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一阶段，我们将对一个包含业务相关值的特定版本进行测试。这个版本将最终成为我们未来“黄金”客户的新版本。
- en: 'The following code block shows how to reference the base, link it to the correct
    patch, and set a corresponding name prefix for all generated resources:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块展示了如何引用基础版本，链接到正确的补丁，并为所有生成的资源设置相应的名称前缀：
- en: './overlays/stage/kustomization.yaml:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: './overlays/stage/kustomization.yaml:'
- en: '[PRE11]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This process follows a similar patching method to what’s used for QA.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程遵循与 QA 环境类似的补丁方法。
- en: 'The following code block shows how to overwrite the color in the base with
    a patch and thus allow a stage that’s specific for stage configuration:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块展示了如何使用补丁覆盖基础版本中的颜色，从而允许针对 Staging 配置的特定阶段：
- en: './overlays/stage/patch.yaml:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: './overlays/stage/patch.yaml:'
- en: '[PRE12]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The folder-based approach in GitOps offers a streamlined overview of all stages,
    eliminating the need to switch and compare across different branches. This simpler
    example, however, only scratches the surface. In practice, you would manage a
    variety of files and environment-specific configurations. The structure’s adaptability
    also allows for expansion into region-specific environments such as `qa-europe`
    or `qa-asia`, enabling customization based on unique regional requirements and
    business objectives.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps 中基于文件夹的方法提供了一个简化的所有阶段概览，消除了在不同分支间切换和比较的需要。然而，这个简单的示例只是表面上的一点。实际上，你将管理各种文件和环境特定的配置。该结构的适应性还允许扩展到区域特定的环境，如
    `qa-europe` 或 `qa-asia`，并根据独特的区域需求和业务目标进行定制。
- en: 'The following scenarios showcase how mighty this approach is:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下场景展示了这个方法的强大之处：
- en: Important note
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This process is an external workflow to Argo CD that greatly simplifies deployment
    management by enabling easy comparison and propagation between stages.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程是一个外部工作流，独立于 Argo CD，极大地简化了部署管理，通过便于在各个阶段之间进行比较和传播。
- en: '`diff` command in Linux compares two files or directories, showing the differences
    in their content in a line-by-line format.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 中的 `diff` 命令用于比较两个文件或目录，以行对行的格式显示它们内容的差异。
- en: You can see the difference between the QA and staging environments by running
    `diff` `qa/patch.yaml stage/patch.yaml`.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以通过运行 `diff` `qa/patch.yaml stage/patch.yaml` 来查看 QA 和 Staging 环境之间的差异。
- en: '**Use case 2**: Promote the application version from QA to staging:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例 2**：将应用版本从 QA 环境推广到 Staging 环境：'
- en: Important note
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `cp` command in Linux is used to copy files and directories from one location
    to another.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 中的 `cp` 命令用于将文件和目录从一个位置复制到另一个位置。
- en: First, copy the new version file with `cp` `qa/version.yaml staging-us/version.yaml`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用 `cp` 命令将新版本文件复制到 `qa/version.yaml` 和 `staging-us/version.yaml`。
- en: Then, commit and push the changes to Git.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，提交并推送更改到 Git。
- en: '`base`.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base`。'
- en: Now, again, commit and push the changes to Git.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，再次提交并推送更改到 Git。
- en: At this point, you can remove additional config from QA, staging, and production
    because the config already exists in `base`.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此时，你可以从 QA、Staging 和生产环境中移除多余的配置，因为配置已经存在于 `base` 中。
- en: For the final time, commit and push the changes to Git.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一次，提交并推送更改到 Git。
- en: This approach greatly simplifies managing deployments by allowing you to easily
    compare stages. You can quickly compare differences by selecting files or folders,
    eliminating the need for complex Git operations such as **cherry-picking**. Changes
    between stages, such as moving from QA to staging, are efficiently handled by
    copying and pasting files. The flexibility of this method extends to different
    regions, countries, Kubernetes distributions, and tools, limited only by your
    own requirements. It offers a customizable and adaptable solution for a variety
    of deployment scenarios and can be automated with any workflow mechanism.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通过允许你轻松比较不同的阶段，大大简化了部署的管理。你可以通过选择文件或文件夹快速比较差异，避免了像 **挑选提交** 这样复杂的 Git 操作。不同阶段之间的变化，例如从
    QA 到 staging，能够通过复制和粘贴文件高效处理。此方法的灵活性扩展到不同地区、国家、Kubernetes 发行版和工具，只受限于你的需求。它为多种部署场景提供了可定制和适应性强的解决方案，并且可以通过任何工作流机制实现自动化。
- en: What makes this approach particularly effective for Kubernetes and especially
    for scaling GitOps operations?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，是什么使得这种方法在 Kubernetes 和尤其是在扩展 GitOps 操作时如此有效呢？
- en: The suitability of this approach for Kubernetes and GitOps at scale is inherent
    in Kubernetes itself. Designed to be declarative and configuration-centric, Kubernetes
    seamlessly integrates with the structured, folder-based approach. This method
    supports GitOps’ focus on version control and traceability, which is crucial for
    managing configurations effectively in large-scale Kubernetes environments. The
    approach’s simplicity and organizational clarity make it an ideal match for the
    scalable and systematic deployment needs of Kubernetes and GitOps frameworks.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在大规模 Kubernetes 和 GitOps 中的适用性固有于 Kubernetes 本身。Kubernetes 设计为声明式和以配置为中心，能够与结构化的、基于文件夹的方法无缝集成。这种方法支持
    GitOps 强调版本控制和可追溯性的核心特性，这对于在大规模 Kubernetes 环境中有效管理配置至关重要。该方法的简洁性和组织性使其成为 Kubernetes
    和 GitOps 框架在可扩展性和系统化部署需求中的理想选择。
- en: Scaling with ApplicationSet generators
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ApplicationSet 生成器进行扩展
- en: We’ve already delved into the distinction between the App of Apps [*5*] approach
    and *ApplicationSets* in GitOps at scale with Kubernetes. Now, we will explore
    how to use *ApplicationSets* with generators to develop a streamlined developer
    platform, known as the KSC in this book. Specifically, we will demonstrate deploying
    an ingress controller across different clusters using *ApplicationSet*, each tailored
    with cluster-specific values. Our focus will be on using `kube-prometheus-stack`,
    which employs an **umbrella chart** with **subcharts**, such as Grafana.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经深入探讨了在 Kubernetes 上以大规模 GitOps 操作中，App of Apps [*5*] 方法与 *ApplicationSets*
    之间的区别。现在，我们将探讨如何使用带生成器的 *ApplicationSets* 来开发一个简化的开发者平台，在本书中被称为 KSC。具体来说，我们将展示如何通过
    *ApplicationSet* 在不同的集群中部署 ingress 控制器，每个控制器根据集群特定的值进行定制。我们的重点是使用 `kube-prometheus-stack`，它采用了带有
    **子图** 的 **伞形图**，例如 Grafana。
- en: 'Here’s a brief overview of using an umbrella `ingress-nginx` `Chart.yaml` file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用伞形 `ingress-nginx` `Chart.yaml` 文件的简要概述：
- en: '[PRE13]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the case of the `ingress-nginx` umbrella chart, using the same name for both
    the `ingress-nginx.controller.resources` – for specific overrides. This distinction
    is crucial for those unfamiliar with umbrella charts as many teams struggle with
    values not being applied as expected due to this naming overlap.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ingress-nginx` 伞形图，使用相同的名称来处理 `ingress-nginx.controller.resources` —— 用于特定的覆盖设置。这个区别对于不熟悉伞形图的人来说至关重要，因为许多团队因命名重叠而难以将值按预期应用。
- en: 'Now, let’s understand why and which part allows us to build scalable deployments
    with Argo CD by looking at the following extract with `nginx-ingress-applicationset.yaml`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解一下，哪些部分使得我们能够通过 Argo CD 构建可扩展的部署，下面是 `nginx-ingress-applicationset.yaml`
    的相关摘录：
- en: '[PRE14]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can find the complete example in this book’s GitHub repository via the name
    provided.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过提供的名称，在本书的 GitHub 仓库中找到完整的示例。
- en: 'The concept of the generator, as previously explained, remains the same. The
    change lies in how the ApplicationController sources the umbrella chart (see **1**
    in *Figure. 5.11*), retrieves custom values for the specific target cluster (see
    **2** in *Figure. 5.11*), then uses Helm to template these values and deploys
    them to the target cluster (see **3** in *Figure. 5.11*). The following figure
    will further clarify the underlying processes, enhancing understanding of the
    operations taking place behind the scenes:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，生成器的概念保持不变。变化在于应用控制器如何获取主图（见 **1**，*图 5.11*），为特定目标集群获取自定义值（见 **2**，*图 5.11*），然后使用
    Helm 对这些值进行模板化，并将其部署到目标集群（见 **3**，*图 5.11*）。以下图示将进一步澄清潜在的过程，增强对后台操作的理解：
- en: '![Figure 5.11: Example stages with folders for environments](img/B22100_05_11.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11：带有环境文件夹的示例阶段](img/B22100_05_11.jpg)'
- en: 'Figure 5.11: Example stages with folders for environments'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：带有环境文件夹的示例阶段
- en: This ApplicationSet, utilized by the application controller, employs generator
    clusters to modify the Helm charts, including both umbrella and subcharts. This
    methodology facilitates the implementation of GitOps at scale. Argo CD, a widely
    used tool in the market, plays a crucial role in enabling this approach, supporting
    the dynamic and scalable management of application deployments.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个由应用控制器使用的 ApplicationSet，利用生成器集群修改 Helm 图表，包括主图和子图。该方法有助于在大规模实施 GitOps。市场上广泛使用的工具
    Argo CD 在支持这一方法的实施中起着至关重要的作用，支持应用部署的动态和可扩展管理。
- en: In the next section, we will see how to build KSG, which allows you to deploy
    different services from this catalog distributed across the clusters with a scaling
    approach.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示如何构建 KSG，允许您从该目录中部署跨集群分布的不同服务，并采用扩展方式。
- en: Building a service catalog for Kubernetes
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Kubernetes 的服务目录
- en: In this section, we will develop a service catalog for Kubernetes as a lightweight
    IDP. This platform will streamline providing necessary infrastructure through
    Kubernetes deployments. The lightweight IDP is designed to scale Kubernetes cluster
    flexibly via GitOps as projects grow, ensuring rapid time to market. Additionally,
    it will facilitate the extension of services such as **security**, **FinOps**,
    and **service-mesh** as needed, while ensuring that clusters are up to date and
    simplifying their management, regardless of the number of clusters involved. This
    approach underscores the synergy between Kubernetes, GitOps, and scalable infrastructure
    management.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为 Kubernetes 作为轻量级 IDP 开发一个服务目录。该平台将通过 Kubernetes 部署简化必要基础设施的提供。轻量级
    IDP 旨在通过 GitOps 灵活地扩展 Kubernetes 集群，随着项目的增长，确保快速的市场交付时间。此外，它还将根据需要促进安全性（**security**）、财务运营（**FinOps**）和服务网格（**service-mesh**）等服务的扩展，同时确保集群保持最新，并简化集群管理，无论涉及多少个集群。这种方法强调了
    Kubernetes、GitOps 和可扩展基础设施管理之间的协同作用。
- en: 'Before proceeding, it’s important to establish your labeling or tagging strategy,
    especially if you prefer not to deploy the entire stack to every cluster. Additionally,
    providing the opportunity to create and expand a service catalog can be beneficial.
    In such cases, it might be advisable to deploy a basic Kubernetes cluster tailored
    for various specific purposes. One potential approach could be as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，建立您的标签或标记策略非常重要，特别是如果您不希望将整个堆栈部署到每个集群。此时，提供创建和扩展服务目录的机会可能是有益的。在这种情况下，建议部署一个针对不同特定目的的基础
    Kubernetes 集群。一个潜在的方式可能如下：
- en: '| **Labels** | **Stack will** **be Deployed** | **Notes** |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| **标签** | **堆栈将** **被部署** | **备注** |'
- en: '| --- | --- | --- |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `env: dev`, `staging`, `prod` | `none`, `plain cluster` | No stack will be
    deployed. Dev should only be used for testing purposes. It is not stable. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `env: dev`、`staging`、`prod` | `none`、`plain cluster` | 不会部署任何堆栈。Dev 应仅用于测试目的，不稳定。
    |'
- en: '| `core-basic: enabled` | `argocd`, `external-dns`, and `ingress-nginx` | Should
    be deployed with security-basic if you want to issue certificates over cert-manager.
    |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `core-basic: enabled` | `argocd`、`external-dns` 和 `ingress-nginx` | 如果您希望通过
    cert-manager 颁发证书，应与 security-basic 一起部署。 |'
- en: '| `security-basic: enabled` | `cert-manager`, `acme-issuer`, `falco`, `kyverno`,
    `sealed-secrets`, `external-secrets`, and `rbac` | Should be deployed on every
    cluster to keep the cluster secure. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `security-basic: enabled` | `cert-manager`、`acme-issuer`、`falco`、`kyverno`、`sealed-secrets`、`external-secrets`
    和 `rbac` | 应该在每个集群上部署以保持集群安全。 |'
- en: '| `monitoring-basic: enabled` | `grafana`, `victoria metrics`, `msteams-proxy`,
    `mailhog`, `stunnel`, `prometheus-node-exporter`, `prometheus-alertmanager`, `falco-exporter`,
    and `cluster-alerting` | Will deploy a monitoring stack without the logging stack.
    |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| `monitoring-medium: enabled` | `loki`, `promtail`, and `minio-loki-tenant`
    | This stack requires storage and should be deployed with `storage-basic: enabled`.
    |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| `storage-basic: enabled` | `minio-operator` and `nfs-subdir-provisioner`
    | This stack is needed for the `monitoring-medium` stack. You can also deploy
    the stack without the `monitoring-medium` stack to use object storage or NFS for
    other purposes. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1: One potential approach of using labeling to manage different tech
    stacks'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: For instance, using an operator or a CI/CD pipeline based on your workflow,
    you can efficiently map and transfer labels from your Kubernetes cluster to your
    Argo CD cluster.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Building the service catalog
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To avoid exceeding the scope, we will focus on a handful of services when building
    the service catalog, and we’ll be using the following folder structure:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Example of possible services in the catalog](img/B22100_05_12.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: Example of possible services in the catalog'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Here, `applicationsets` is a directory dedicated to deploying various services
    across multiple Kubernetes clusters using labels. Inside, the `cluster` directory
    contains multiple clusters, each iterated within the *ApplicationSet* and enhanced
    with parameters from the Cluster generator. Other directories, such as `dns`,
    `networking`, and others, group services logically. They comprise Helm umbrella
    charts along with subcharts for specific services, such as `external-dns` or `ingress-nginx`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now review the well-known `nginx-ingress-applicationset.yaml` file,
    which has been updated to include the labels approach:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, `ApplicationController` deploys exclusively to clusters matching the `env
    = dev | prod` and `core-basic = enabled` labels. Structurally akin to other ApplicationSets
    for services shown in *Figure 5**.11*, there is a unique aspect in cert-manager
    from the security folder, incorporating an additional label, `security-basic:
    enabled`, in its `ApplicationSet`.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block shows how to implement it:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, Argo CD’s application controller only deploys `cert-manager` to clusters
    tagged with the specific additional label.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Labels are powerful tools that allow you to manage different stacks for on-premises
    and public cloud environments through a single central Argo CD unit. This versatility
    allows for seamless management across multiple environments. Integrating this
    with the varied perspectives of different roles, labels facilitate the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Platform engineers can employ this method to deliver scalable Cluster-as-a-Service
    while incorporating SRE principles
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevSecOps engineers can implement policies across all clusters, ensuring governance
    and compliance
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers can utilize this approach to deploy scalable applications across
    various customer clusters with customized values
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This unified approach streamlines operations and ensures consistency across
    diverse environments and roles.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you possess extra manifests tailored to your specific requirements where
    the service needs to be extended – for example, if Argo CD requires an optional
    ingress during deployment to a target cluster for external access over ingress,
    and not direct via the Kubernetes API – you can introduce an additional `templates`
    folder under `system.argocd`. In this folder, you can include a manifest similar
    to the following extract from `templates.ingress.yaml`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This approach enables you to override the values in the umbrella chart and,
    if necessary, deploy an additional ingress, like so:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If your organization uses common certificates from a root CA required by all
    external DNS, you could utilize `kustomize` to establish a folder structure. For
    instance, you could create `kustomize.dns.external-dns-secrets` with your `root-ca.yaml`
    file. Then, you could integrate this into your `external-dns` ApplicationSet using
    just a few lines, like so:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With that, we have successfully created a catalog that will broaden the scope
    of our services, policies, and application portfolio.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: A crucial point is focusing on the overarching approach to achieving GitOps
    at scale, rather than fixating on specific tools such as Argo CD. Tools may come
    and go, such as Flux or successors to Argo CD, but what remains vital is an adaptable
    strategy. This is akin to development practices evolving across different frameworks
    and languages while maintaining their foundational methods. By carefully organizing
    folders for various environments and merging this structure with an *ApplicationSet*,
    an efficient and scalable GitOps solution is formed. Such a strategy not only
    streamlines management but also significantly reduces the maintenance required
    for any given environment. KSC describes the power of joining CNCF/OSS projects
    together to create a secured, self-managed serving platform for developers, platform
    engineers, and SREs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Bonus – maintenance with GitOps at scale and KSC
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that you’re managing hundreds of Kubernetes clusters, each with different
    stacks, and in every cluster, a core service is deployed. This results in approximately
    2,000 applications being distributed across the clusters. The key requirement
    is to keep everything up-to-date and secure. You’ve scaled up brilliantly and
    kept your applications in sync. Suddenly, on the same day, two critical **Common
    Vulnerabilities and Exposures** (**CVEs**) for the Ingress-NGINX image you’re
    using are exposed, along with a bug fix for Cert-Manager and an extra configuration
    for External-DNS to enhance its resilience. All your clusters are affected. How
    do you maintain all clusters at once, considering everything is managed through
    Helm charts? Here’s how:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: You could manually check all the Helm chart versions, look at the deltas, then
    upgrade the versions and deploy them across all clusters using Argo CD. However,
    CVEs and changes don’t always get published at a specific time; they’re released
    when a vulnerability is discovered.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a pipeline or a job in your Kubernetes cluster that runs against your
    service catalog at set intervals to check for newer versions of a Helm chart.
    If a new version is found, it creates a pull request, displays all the changed
    values, and automatically merges if all criteria are met or after a review.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second option sounds much better, and there is a script you can run in a
    pipeline that does precisely this. Alternatively, you can use a GitHub Action
    for this purpose.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a pull request looks like:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Afterward, the GitOps approach takes over, rolling out the changes across all
    clusters. This way, you minimize maintenance by centrally managing changes and
    deploying them via GitOps, regardless of the number of clusters involved.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The following section is about how to implement a multi-tenancy concept using
    only the board resources that Argo CD provides.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Exploring native multitenancy with Argo CD
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is not about setting up the most secure, optimal multitenancy environment
    with Argo CD. That’s because *best* is based on your specific SRE motivations,
    security team constraints, governance, the compliance policies of your company,
    your industry, and the skill level of your team. Additionally, tools change frequently,
    often multiple times a year, with minor releases introducing new features. Therefore,
    our focus here is on the approach to creating multitenancy with Argo CD while
    considering the aspects you should pay attention to, what you can address now,
    and future considerations.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: But why opt for a multitenancy setup with Argo CD instead of using a dedicated
    cluster for each project?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several reasons:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the count of clusters makes it easy to maintain aspects such as upgrading
    Kubernetes versions.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To maximize resource utilization and efficiency, multitenancy is essential.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In non-dynamic, ticket-based cold start environments, especially when not every
    Kubernetes cluster operates in the cloud, multitenancy becomes a necessity.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By implementing FinOps practices, each machine’s cost is closely monitored and
    optimized. Multitenancy helps reduce overall costs by maximizing the utilization
    of resources across multiple teams or projects, ensuring efficient spending and
    minimizing waste.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, you will learn how to implement a multitenancy setup using
    Argo CD as the central management tool for workloads from different teams.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The setting for this setup is a Kubernetes platform in a company-owned data
    center, constrained by resources such as storage. A core Argo CD instance, provided
    by the platform team, is employed for the GitOps approach. This core instance
    delivers platform context (such as **ExternalDNS**, **Cert Manager**, and more)
    declaratively. Developer teams maintain their own Git repositories, with access
    to the Kubernetes cluster facilitated through **Active Directory** (**AD**) groups.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The challenge lies in deploying over the same core Argo CD instance without
    allowing teams to misuse it and break out of their isolated environments.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the requirements to enable secure multi-client operation:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Teams should work autonomously
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each team can only access its designated namespace
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teams must not negatively impact others, for instance, through improper resource
    provisioning
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A declarative GitOps approach is maintained
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitOps at scale is managed declaratively for new projects and teams
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there needs to be a clear understanding of where the platform
    team’s responsibilities begin and end. For this, you can consider the following
    approaches:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'The platform team provides the platform and context but stops at the initial
    repository setup:'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pros**: No need to manage credentials such as **personal access tokens**
    (**PATs**) or **SSH keys**.'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**: **Disaster recovery** is more challenging; developers must reinitialize
    access to the repo after, for instance, rotating a cluster'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The platform team provides the platform, context, and the initial repository:'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pros**: Disaster recovery is simplified. A stateless cluster can be discarded
    or migrated, and the GitOps approach will restore everything correctly.'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**: Managing credentials for different team repos becomes necessary.'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: By understanding and implementing these strategies, you can effectively manage
    a multitenancy environment in a resource-limited, Kubernetes-based infrastructure
    using Argo CD. The implementation of those strategies is based on the GitOps experience
    of the development and platform teams.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the second approach from the view of the platform team and create
    a folder in our Git repository to be aggregated by Argo CD, with a specific folder
    structure. But first, let’s look at *Figure 5**.13*. Here, you can see that the
    different teams have access to a specific namespace, which is regulated by **RBAC**,
    **quotas**, and **network policies** and managed over a common Argo CD instance
    with projects and applications. The Argo CD instance is also used by the platform
    team to provide a new namespace as a service for new projects of the developer
    teams:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: Multitenancy with GitOps and Argo CD](img/B22100_05_13.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: Multitenancy with GitOps and Argo CD'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'The folder structure that will be created for every team looks like this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: Multitenancy with GitOps and Argo CD](img/B22100_05_14.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: Multitenancy with GitOps and Argo CD'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: A project on Argo CD represents the team’s dos and don’ts. You can define the
    relevant set of rules by setting a project per development team. With this, the
    platform team gives just enough of a playground for the developers.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at `argocd-project-devteam-a.yaml`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this context, `AppProject` is structured simply, encompassing elements such
    as `sourceRepos`, `destinations`, `roles`, `clusterResourcesBlackList`, or `WhiteList`,
    and `namespaceResourceBlacklist` or `WhiteList`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The operational flow involves determining the origins of resources, the clusters
    they can be deployed to, and the namespaces within a project where deployment
    is permitted. It defines which resources and namespace resources can be created
    within the cluster by the project, with options to either allow or explicitly
    disallow (`!`) actions.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Global projects can be set up to distribute configurations to other projects.
    This means you can implement cluster-wide restrictions that are inherited by other
    *AppProjects*, eliminating the need to replicate the entire configuration block
    for each project.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Project roles can be used to grant or deny access to specific resources within
    the project. Global roles (`argo-rbac-cm`) and team or project roles are also
    used here. However, if a user’s Kubernetes RBAC permissions are more extensive
    than those defined by the project, the project settings won’t limit their ability
    to access or modify resources. Therefore, it’s essential to constrain user rights
    at the RBAC cluster level.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Important note
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Here, you have explicitly forbidden deployment to `kube-system` while allowing
    deployments to the `devteam-a` namespace. However, this also inadvertently permits
    deployments to other namespaces, such as `devteam-b`, because they don’t match
    the deny pattern. This scenario underscores the importance of a deep understanding
    of Kubernetes and the relevant tools for implementing a multitenancy approach
    with GitOps at scale.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s examine how you would set up an application in this environment:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The resources are collected by the Argo CD core instance and deployed via the
    GitOps approach. At this point, the platform team takes care of applications and
    doesn’t allow the developer to deploy their own applications (see the limitations).
    You should be careful because restriction to create resources is not the same
    as manipulating resources. So, you might have to configure additional policies
    and **WebHook** validations, depending on your environment, corporate governance,
    and security guidelines.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '`devteam-a` has a folder named `applicationset` in their repository. The folder
    represents the start of Argo CD. The developers can determine the order and deploy
    their application over `kustomize`, Helm, or a direct Kubernetes manifest file.
    In this configuration, developers are unable to create custom resources such as
    applications, ApplicationSets, and AppProjects.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach to multitenancy with GitOps presents certain limitations:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '**Limited team access to the Argo CD UI/CLI**: Teams typically can’t create
    and manage applications through Argo CD’s UI or CLI. If you wish to provide such
    access, you will need to use a Dex server, create policies in the **RBAC ConfigMap**,
    map groups to roles, or utilize project roles.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restricted access to monitoring stacks**: Teams may not have access to a
    monitoring stack. Implementing multitenancy at this level is also necessary.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Potential conflicts with CRD versions**: If two teams opt to deploy different
    versions of CRDs for the same service, these conflicts must be mitigated. One
    way to do this is by blocking such actions and handling them through pull requests.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Challenges with declarative management**: The concept of declarative management
    can conflict with multitenancy principles. This is because Argo CD requires that
    custom resources, such as applications, be in the same namespace as Argo CD itself.
    A beta feature currently in development may allow applications to be deployed
    in different namespaces.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When opting for multitenancy with GitOps, you can conserve hardware resources.
    However, it’s important to consider that the engineering resources required to
    maintain and enforce multitenancy setups might increase. GitOps can simplify management
    and enforcement, but it also comes with its own set of constraints, depending
    on the tools used and the underlying Kubernetes version and core approach.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: This is why *AppProject* is not enough for multi-tenancy. To get the full GitOps
    experience for development teams, Argo CD by itself needs some enforcement. Due
    to the limits described here, some tools can be used to reduce them. We’ll cover
    this in the next section.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Exploring multitenancy with vCluster and Argo CD
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we explored how multitenancy is implemented natively
    with Argo CD, along with its current limitations at the time of writing. While
    these limitations may be addressed in the future, there’s no certainty.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll expand the multitenancy approach by introducing a tool
    called vCluster. This tool addresses most of the limitations discussed earlier
    by enabling scaling through GitOps in a declarative manner, facilitated by Argo
    CD. This method shifts from a Namespaces-as-a-Service model to a more comprehensive
    **Virtual-Kubernetes-as-a-Service** (**VKaaS**) or **Kubernetes-as-a-Service**
    (**KaaS**) approach.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: vCluster, an open source solution for creating and managing virtual Kubernetes
    clusters, presents a novel approach to Kubernetes cluster management. It functions
    by establishing a host cluster, on top of which vClusters – akin to seed clusters
    – operate within namespaces. This setup allows multiple clusters to be deployed.
    Necessary Kubernetes components and an additional **syncer** operate as pods within
    the namespace, offering a unique virtual cluster with its dedicated API. These
    virtual clusters, although running within a single namespace of a host cluster,
    provide the illusion of being independent, full-fledged clusters. This is particularly
    useful in scenarios where namespace limitations are a concern, and specific configurations
    incompatible with the host cluster’s multitenancy setup are needed.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: The focus here is not just on the tool itself, but on how it enables us to meet
    the requirements outlined in the previous section. We will maintain the same requirements
    and explore how vCluster can overcome the previously discussed limitations.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'In our context, a **tenant** (*Figure 5**.15*) refers to a project managed
    by vCluster on dedicated nodes, each with its own Argo CD instance. Thus, in our
    framework, every project is a tenant, and every tenant corresponds to a namespace,
    aligning with vCluster’s namespace-based approach within the shared cluster:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: Example of how a tenant can be grouped by services](img/B22100_05_15.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: Example of how a tenant can be grouped by services'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: After this setup process, as illustrated in *Figure 5**.16*, your system will
    feature a configuration where shared and isolated workloads exist simultaneously
    on the host cluster. The degree of this simultaneous existence hinges on how you
    apply taints and tolerations, along with other strategies, to guide Kubernetes’
    deployment decisions. This ability is key to distributing shared workloads throughout
    the cluster effectively.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'The method we’re about to delve into shows how to distinguish between the workloads
    of customer seed clusters, which operate on dedicated node pools, and those of
    the default node pool and host cluster. It’s important to note that these host
    cluster workloads are vital for either Kubernetes or your platform team’s operations,
    such as deploying the seed clusters:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16: Multitenancy setup with vCluster](img/B22100_05_16.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.16: Multitenancy setup with vCluster'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'We will split the workflow into four steps. However, only the first two steps
    are necessary to build a multitenancy setup with vCluster:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1 –** **deploy vCluster**:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: For this part, KSC is extended by optimization/vCluster.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an extract from the application and can be found on GitHub
    in the `vcluster-application.yaml` file, which focuses on the essentials. It is
    important to understand that several repos are referenced as sources, and a Helm
    release is created and overwritten with specific values:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Additionally, we’ll deploy specific Kubernetes resources, such as `networkpolicy-deny-ingress.yaml`
    and `rbac.yaml`, to effectively manage access control at the namespace level.
    These resources are crucial for ensuring proper security and access protocols
    within the multitenancy environment.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2 – connect Argo CD running on the host cluster to** **the vCluster**:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This step involves setting up a multitenancy environment using vCluster and
    Argo CD. The focus is on establishing a connection between Argo CD, which operates
    on the host cluster, and the vCluster running on the host cluster. This process
    begins with connecting to the vCluster. You can achieve this with a single command.
    For a port forwarding connection, the following command can be used:'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When utilizing an ingress for SSL passthrough, you can establish a connection
    using the following command:'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember to configure certain vCluster and ingress-controller-specific parameters
    to enable SSL passthrough.
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once this is set up, connecting Argo CD on the host system to the vCluster
    is a straightforward process and can be achieved with a single command line:'
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Important note
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we have effectively addressed the challenge of multitenancy.
    Teams are now equipped to connect to the virtual cluster using the familiar `vcluster
    connect` command. This capability is crucial in fostering self-sufficiency among
    teams.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3 – point** **to KSC**:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, the focus shifts to integrating the virtual Kubernetes environment with
    a service catalog. This step involves creating an application that points to a
    repository containing a suite of applications specifically designed for the virtual
    cluster. This is like the application example provided earlier. By establishing
    a **virtual KSC** (**vKSC**), you can delineate the difference between various
    environments and adopt your approach with labels to deploy in a manner akin to
    how you manage dedicated Kubernetes clusters.
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To implement this, you can follow the step-by-step guide available on my blog
    [*7*]. This guide provides detailed instructions and insights into building a
    vKSC. This resource is particularly useful for understanding how to effectively
    manage and deploy applications in a multi-tenant setup using vCluster, ensuring
    a smooth and scalable operation within your Kubernetes environment.
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Step 4 – deploy Argo CD into vCluster while running Argo CD on the** **host
    cluster**:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While setting up a multitenancy environment with vCluster, we have already established
    a folder structure that represents our vKSC. This structure is crucial for organizing
    various services and applications within the vCluster. After integrating Argo
    CD into this service catalog, similarly to other services in the KSC, we must
    now use Argo CD running on the host cluster to deploy Argo CD across all clusters
    using GitOps. This approach allows for an automated and consistent deployment
    process. It helps in avoiding code redundancy and enables individual patching
    of manifests for each cluster. This setup ensures efficient management and deployment
    in a multi-tenant Kubernetes environment by uniformly deploying Argo CD across
    all clusters.
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Bonus – simplified connection to multiple vClusters – a handy bash script
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Managing multiple vClusters can often become a cumbersome and noisy process,
    particularly when it involves connecting to each cluster individually. To address
    this challenge and streamline the workflow, I have developed a straightforward
    bash script. This script simplifies the process significantly. It operates based
    on the context of the host cluster and utilizes a consistent naming pattern, such
    as a namespace named `vcluster-demo` and an ingress formatted like `vcluster-team-a.example.com`.
    With this script, you can efficiently iterate over and establish connections to
    all vClusters, thereby saving considerable time and effort in managing your multi-cluster
    environment
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Limitations solved in multitenancy with GitOps – a review
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation of multitenancy using vCluster and Argo CD, as outlined
    in the earlier steps, addresses several key limitations:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '**Limited team access to Argo CD UI/CLI**: This can be resolved by implementing
    *Steps 3* and *4*. Each team receives an Argo CD instance, complete with UI and
    CLI access, enhancing autonomy and operational efficiency.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restricted access to monitoring stacks**: This can be solved by deploying
    an additional monitoring stack within vCluster. This step ensures that teams have
    the necessary monitoring tools at their disposal for effective cluster management.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Potential conflicts with CRD versions**: This is no longer an issue because
    each virtual Kubernetes cluster maintains a key-value store with distinct CRDs.
    This separation effectively eliminates conflicts arising from CRD version discrepancies.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Challenges with declarative management**: This is addressed through the platform
    team’s ability to provision virtual clusters over Argo CD, enabling teams to manage
    their dedicated vClusters effectively. From a developer’s perspective, following
    the implementation of *Steps 3* and *4* (refer to the Exploring multitenancy with
    vCluster and Argo CD section) ensures a smooth declarative management process.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, it’s important to note the inherent trade-offs in this approach. While
    this concept appears resource-efficient, especially compared to the dedicated
    approach of one cluster per project/team, vCluster does consume additional resources
    compared to the native approach. Most resources from the virtual cluster can be
    synced into the host cluster, and **loft.sh**, the creator behind vCluster, is
    working on expanding this bidirectional synchronization. There’s also a vCluster
    Pro enterprise version offering further enhancements such as custom syncs between
    the host and vCluster, hibernating vClusters, creating templates, and more. Nevertheless,
    the focus here is not strictly on the tool but on the approach – how to effectively
    implement a multitenancy strategy using GitOps at scale.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: As this chapter draws to a close, the following section summarizes the key points.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up – insights and lessons from multitenancy experiences
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we wrap up this chapter, it’s insightful to revisit the key themes and lessons
    that have emerged. Beginning with the *App of Apps approach*, we set the stage
    for understanding the complexities of managing applications in a Kubernetes environment.
    This approach emphasized the importance of a structured and scalable method to
    handle application deployment and orchestration.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Moving on to *multi-cluster management*, we explored the intricacies of managing
    numerous Kubernetes clusters, a critical aspect for organizations operating at
    scale. This exploration was complemented by the section on effective Git repository
    strategies, where the focus was on optimizing the management of repositories to
    enhance operational efficiency in a GitOps-centric environment.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The journey further unfolded with *ApplicationSet generators* and *building
    a service catalog for Kubernetes*. These sections delved into the techniques and
    tools necessary for effectively scaling applications and services across multiple
    Kubernetes clusters, underscoring Kubernetes’ inherent scalability and flexibility.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: The *Native multitenancy with Argo CD* and *Multitenancy with vCluster and Argo
    CD* sections provided a thorough understanding of different methodologies and
    tools for achieving efficient multitenancy. They highlighted how multitenancy
    can be implemented and managed using Argo CD and vCluster, offering insights into
    creating isolated, efficient multi-tenant environments.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this exploration, several key lessons and insights emerged:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: The strategy often outweighs the choice of tools, reinforcing the importance
    of approach over specific technologies
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing multitenancy natively can save hardware resources but may increase
    the demand for engineering resources
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of patterns such as App of Apps and ApplicationSets can greatly aid
    in building scalable deployment strategies for different roles and use cases
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing multiple clusters with Argo CD is simplified, especially when combined
    with the effective use of labels and a GitOps approach
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labels, when used with ApplicationSets and Cluster generators, can facilitate
    selective and flexible deployment strategies across clusters
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While native multitenancy approaches appear resource-efficient, they can introduce
    complexities and necessitate more engineering resources
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools such as vCluster offer a more isolated approach to multitenancy while
    maintaining declarative management and utilizing GitOps
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The balance between conserving hardware resources and the increase in engineering
    and developer onboarding efforts needs to be carefully managed
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitOps at scale empowers platform engineering teams and developers, allowing
    them to focus on application development rather than operational burdens
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In concluding this chapter, it becomes evident that understanding the underlying
    approach opens a myriad of possibilities for creating diverse and impactful real-world
    solutions and products.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'These include products:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '**Platform as a Service (PaaS) products**: As a platform engineering team,
    understanding these concepts enables the creation of a PaaS product. This platform
    offers a suite of tools and services that are essential for streamlined application
    development and deployment.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software as a Service (SaaS) solutions development for diverse clients**:
    By leveraging GitOps and Argo CD, developers can create customizable SaaS solutions
    that are easy to deploy across different Kubernetes clusters in various regions
    and versions. This approach ensures automated, consistent deployment, allowing
    developers to efficiently cater to the unique requirements of a diverse client
    base.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment solutions for SRE teams**: SRE teams can leverage this knowledge
    to improve their deployment strategies, ensuring high availability and efficiency
    in their operations.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Governance and compliance tools for security teams**: Security teams can
    use these strategies to implement robust governance and compliance measures across
    all clusters. By utilizing labels effectively, they can establish comprehensive
    service packages that ensure adherence to security standards and regulatory requirements.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These applications demonstrate the versatility and real-world impact of the
    strategies discussed in this chapter, highlighting how a deep understanding of
    GitOps and multitenancy can lead to the creation of diverse, scalable, and secure
    technological solutions.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In conclusion, this chapter has not only illuminated various strategies and
    tools for achieving multitenancy and scaling in Kubernetes but also highlighted
    the crucial role of understanding these concepts deeply. The journey through GitOps
    at scale and multitenancy reveals that while there are multiple approaches to
    achieving efficiency in Kubernetes, each comes with its trade-offs. The ultimate
    choice should be aligned with the organization’s specific needs and the goals
    of its development teams.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce different architectures that have already
    been partially utilized in this chapter to illustrate concepts such as *One cockpit
    rule them all* approach for multi-cluster management, as well as discuss their
    advantages, disadvantages, use cases, and insights gathered from various projects.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: References
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*1*] [https://docs.akuity.io/tutorials/cluster-addons-with-applicationsets/](https://docs.akuity.io/tutorials/cluster-addons-with-applicationsets/)'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*2*] [https://argocd-applicationset.readthedocs.io/en/stable/Generators/](https://argocd-applicationset.readthedocs.io/en/stable/Generators/)'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*3*] [https://codefresh.io/blog/argo-cd-best-practices/](https://codefresh.io/blog/argo-cd-best-practices/)'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*4*] [https://codefresh.io/docs/docs/pipelines/deployment-environments/](https://codefresh.io/docs/docs/pipelines/deployment-environments/)'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*5*] [https://codefresh.io/blog/codefresh-gitops-app-of-apps/](https://codefresh.io/blog/codefresh-gitops-app-of-apps/)'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*6*] [https://www.vcluster.com/docs/using-vclusters/access](https://www.vcluster.com/docs/using-vclusters/access)'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*7*] [https://medium.com/devops-dev/multi-tenancy-with-vcluster-794de061fff1](https://medium.com/devops-dev/multi-tenancy-with-vcluster-794de061fff1)'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
