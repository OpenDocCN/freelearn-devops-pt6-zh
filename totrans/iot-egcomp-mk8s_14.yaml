- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hardware Virtualization for Securing Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how to create a highly available MicroK8s
    Kubernetes cluster using the stacked cluster **high-availability** (**HA**) topology.
    We have used the three nodes to install and configure MicroK8s on each of them,
    as well as simulating node failure to see whether the cluster could withstand
    component failures and still work normally. We’ve also gone over some best practices
    for deploying Kubernetes applications on a production-ready cluster. We noticed
    that MicroK8s’ HA option has also been streamlined and is now activated by default.
  prefs: []
  type: TYPE_NORMAL
- en: Container technologies have dominated the industry in recent years and have
    become the de facto standard for building modern IT infrastructure. They are frequently
    preferred over standard **virtual machines (VMs)** due to their lightweight design
    and bare-metal-like performance. However, security and isolation are two of the
    most common adoption issues (refer to the recent Kubernetes and cloud-native operations
    report, published in 2022, at [https://juju.is/cloud-native-kubernetes-usage-report-2022](https://juju.is/cloud-native-kubernetes-usage-report-2022)).
    In this chapter, we’ll look at how to use Kata Containers to create a secure container
    runtime and leverage hardware virtualization technology to give better workload
    isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Before understanding what Kata Containers is, let us review how containers operate
    and how they relate to virtualization technology. A container is more like a **VM**
    that allows the packaging of software and all of its dependencies into a single
    entity that can execute in any supported environment.
  prefs: []
  type: TYPE_NORMAL
- en: VMs, on the other hand, are larger and require longer to set up. Containers
    have a substantially lower footprint than VMs and are thus much faster to set
    up (and tear down). Containers, unlike VMs, which keep entire copies of the operating
    system, only share the host system’s operating system kernel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – VMs versus containers ](img/Figure_14.1_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – VMs versus containers
  prefs: []
  type: TYPE_NORMAL
- en: The container runtime is the bridging software that allows a host system to
    separate its resources for containers, tear down container images, and manage
    container life cycles. Every node on the Kubernetes cluster must have a container
    runtime installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Canonical MicroK8s has made it easy to enable Kata Containers (a container
    runtime), which can greatly improve the security and isolation of your container
    operations, with just a single command. It combines the advantages of a hypervisor,
    such as increased security, with Kubernetes’ container orchestration capabilities.
    In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of Kata Containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling the Kata add-on and running a sample application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container security best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of Kata Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Open Container Interface** (**OCI**) is a Linux Foundation initiative
    that aims to establish principles, standards, and specifications for Linux containers.
    The OCI runtime specifications are primarily concerned with container life cycle
    management and configuration for multiple systems, including Linux, Windows, and
    Solaris. Low-level runtimes are container runtimes that comply with the OCI specification.
    Container creation and management are primarily the responsibility of low-level
    container runtimes. Designed by Docker, runC is an example of low-level container
    runtime and the standard for low-level container runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: Low-level runtimes are native runtimes, which means they run containerized processes
    on the host kernel. There are also a few sandboxed and virtualized runtimes that
    provide improved process isolation by not running them on the host kernel. Kata
    Containers is one of the virtualized runtimes. To run containerized processes,
    these runtimes use a VM interface that behaves similarly to containers, but with
    the workload isolation and security benefits of VMs.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker runtime was the default container runtime when Kubernetes was initially
    published. As the platform developed, so did the need to support different runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: The **Container Runtime Interface** (**CRI**) was launched to make Kubernetes
    more runtime agnostic. It’s a high-level specification that’s mostly focused on
    container orchestration. Unlike the OCI, the CRI handles extra aspects of container
    administration such as image management, snapshots, and networking while leaving
    container execution to an OCI-compliant runtime (such as runC).
  prefs: []
  type: TYPE_NORMAL
- en: Kata Containers ([https://katacontainers.io/](https://katacontainers.io/)) is
    an open source project that seeks to create a secure and OCI-compliant container
    runtime that improves the security and isolation of container workloads by encapsulating
    each one in a lightweight VM and employing hardware virtualization. Every VM has
    its own kernel that it uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'As depicted in *Figure 14.2*, traditional containers employ runC as a container
    runtime, which relies on kernel features such as cgroups and namespaces to achieve
    isolation with the shared kernel; however, Kata Containers leverages hardware
    virtualization to isolate containers in their own lightweight VM as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Traditional containers versus Kata Containers ](img/Figure_14.2_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Traditional containers versus Kata Containers
  prefs: []
  type: TYPE_NORMAL
- en: Kata Containers has a number of advantages over standard VMs, including the
    ability to effortlessly integrate with existing container orchestration technologies
    such as Kubernetes. Native Kubernetes capabilities such as auto-scaling and rolling
    updates are still available while you’re launching VMs. This enables the benefits
    of virtualization technology to be combined with container orchestration capabilities.
    In the following section, we can look at how the Kata containers are instantiated
    using kata-runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How Kata Containers works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a Kubernetes cluster is configured with a high-level runtime, such as containerd
    or CRI-O, a container runtime shim is installed to allow smooth communication
    between the CRI (containerd or CRI-O) and a low-level container runtime, such
    as runC (the default runtime), and this low-level container runtime is responsible
    for running the containers in the pod.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Working of Kata Containers ](img/Figure_14.3_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – Working of Kata Containers
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for creating Kata containers with segregated kernel and namespace
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes is configured with a high-level container runtime such as **containerd**
    or **CRI-O**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A container runtime shim (**containerd-shim**) acts as a bridge between the
    CRI (containerd or CRI-O) and a low-level container runtime, such as runC (the
    default runtime), for smooth communication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The low-level container runtime (such as runC or kata-runtime) takes care of
    running the containers in the pod.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kata Containers uses a runtime class (kata-runtime) to run containers in a separate
    kernel and namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Containers can be run in a lightweight VM using `containerd-shim-kata-v2`, a
    new shim that acts as a bridge between containerd and `kata-runtime`, Kata Containers’
    runtime class should also be enabled for running containers in a separate kernel
    and namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, Kata is a container runtime that provides greater isolation
    between containers while maintaining the performance and efficiency of other runtimes.
    The following are some of its prominent features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**: It runs in a dedicated and isolated kernel and can be easily
    integrated with containerd or any other container runtime. It also supports several
    hypervisors such as QEMU, Cloud Hypervisor, and Firecracker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compatibility with Docker and Kubernetes**: By providing kata-runtime as
    a container runtime, it works easily with Docker and Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: It has the same consistency as any other Linux container but
    with more isolation. It also supports AMD64, ARM, IBM pSeries, and IBM zSeries
    platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified**: No need for nested containers inside VMs or sacrificing container
    speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from virtualized runtimes or Kata Containers, there are various techniques
    to isolate containers (refer to [https://thenewstack.io/how-to-implement-secure-containers-using-googles-gvisor/](https://thenewstack.io/how-to-implement-secure-containers-using-googles-gvisor/)),
    each with its own set of attributes that will suit certain applications. The appropriate
    one for your apps is a crucial aspect of your container security architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve grasped the fundamentals of how Kata Containers works, we can
    move on to the following step of enabling the Kata add-on and running a sample
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Kata add-on and running a sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we can go through the process of enabling the Kata add-on in
    your MicroK8s Kubernetes cluster. Then, to demonstrate Kata’s capabilities, we’ll
    deploy a sample application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be using an Ubuntu VM for this section. The instructions for setting up
    the MicroK8s cluster are the same as in [*Chapter 5*](B18115_05.xhtml#_idTextAnchor070)*,*
    *Creating and Implementing Updates on Multi-Node Raspberry Pi Kubernetes Clusters*.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – Enabling the Kata add-on
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with MicroK8s v1.24, you must issue the `enable community` command
    to enable the community add-ons repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to enable the `community` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It will take some time to finish activating the add-on; the following command
    execution output shows that the `community` repository has been successfully enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Enabling the community repository ](img/Figure_14.4_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – Enabling the community repository
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the `community` repository enabled, we can move on to the following
    step of enabling the Kata add-on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to enable the Kata add-on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output indicates that the Kata add-on is being
    enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Enabling the Kata add-on ](img/Figure_14.5_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Enabling the Kata add-on
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding command execution output, we can see that `kata runtimeClassName`
    (kata) is added, which allows us to specify which workloads should be launched
    in Kata Containers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `--runtime-path` parameter can also be used to specify the location where
    the Kata runtime is installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to enable the Kata add-on with the runtime path:'
  prefs: []
  type: TYPE_NORMAL
- en: '`microk8s enable kata --runtime-path=<<kata-runtime-binary-path>>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to the following step, let’s make sure that the Kata add-on
    has been activated successfully using the `microk8s status` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6 – The Kata add-on is enabled ](img/Figure_14.6_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – The Kata add-on is enabled
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Kata add-on has been enabled, we may deploy a sample nginx application
    in the following step.
  prefs: []
  type: TYPE_NORMAL
- en: Note for using Kata Containers on multi-node clusters
  prefs: []
  type: TYPE_NORMAL
- en: '`microk8s enable kata` must be executed on each node in a multi-node cluster
    in order for the Kata runtime to be enabled on the desired nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Deploying a sample application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this step, we will be deploying the following sample nginx application deployment
    manifest, which uses the Kata runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to create a sample nginx deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output indicates that there is no error in
    the deployment and in the following steps, we can ensure that the pods are created
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7 – Sample nginx application deployed ](img/Figure_14.7_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – Sample nginx application deployed
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the deployment is successful, let’s use the following `kubectl` command
    to check whether the pods are in a `Running` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8 – Checking whether the pods are in a Running state ](img/Figure_14.8_B18115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – Checking whether the pods are in a Running state
  prefs: []
  type: TYPE_NORMAL
- en: The fact that `nginx-kata` is now in the `Running` state means that containers
    are running in a lightweight VM utilizing the containerd runtime. It used `containerd-shim-kata-v2`,
    which acts as a bridge between containerd and kata-runtime—a runtime class that
    comes with Kata Containers that allows containers to run in their own kernel and
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how easy is to enable the Kata add-on and run a sample application,
    let’s move on to the following section where we discuss the best practices for
    running containers.
  prefs: []
  type: TYPE_NORMAL
- en: Container security best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers provide a lot of advantages, but they also have some security issues
    that might be tough to solve. Because of the enormous number of containers based
    on many different underlying images, each of which could potentially have vulnerabilities,
    containers create a wider attack surface than traditional workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Another important consideration is the kernel architecture shared by containers.
    Securing the host is insufficient to ensure security. You must also keep secure
    configurations to limit container permissions and ensure effective container isolation.
    For example, a container with an exploitable vulnerability, exposed metadata,
    and incorrect credentials configuration could jeopardize your entire infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll go through some of the most important factors to consider when running
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing DevSecOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The seamless integration of security testing and protection across the software
    development and deployment life cycle is referred to as DevSecOps. You may scan
    your code for defects or possibly vulnerable code before shipping or even building
    your application. There are various **Static Application Security Testing** (**SAST**)
    tools for application code, such as **SonarQube**, which provides vulnerability
    scanners for various languages and detects vulnerabilities based on rules, linters,
    and so on. You can use them on the development workstation, but including code
    scanning tools in the CI/CD workflow ensures a minimal degree of code quality.
    For example, if some checks fail, you can deny pull requests by default.
  prefs: []
  type: TYPE_NORMAL
- en: Also, remove any components that your application doesn’t require. For example,
    remove the `sed` and `awk` binaries, which are installed by default on any UNIX
    system. This can assist you in lowering the attack surface.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning external vulnerabilities via dependency scanning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: External dependencies, such as third-party libraries or frameworks that are
    used in your application, may contain flaws and vulnerabilities. Any application
    build process should incorporate dependency scanning as a best practice.
  prefs: []
  type: TYPE_NORMAL
- en: A vulnerability database (such as NVD) can also be matched with your application
    dependencies using package management tools such as `npm`, `maven`, `go`, and
    others to produce helpful alerts/warnings.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing container images using image scanning tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Analyze your container images with an image scanner. The image scanning tool
    will find vulnerabilities in the operating system packages provided by the container
    image base distribution (`rpm`, `dpkg`, `apk`, and so on). It will discover vulnerabilities
    in package dependencies for Java, Node.js, Python, and other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Automating and enforcing image scanning is simple. It can be integrated into
    your CI/CD pipelines, triggered when new images are sent to a registry to ensure
    that non-compliant images are no longer permitted to run.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing image content trust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you aren’t making the image from scratch, you should pick images that are
    reliable. Anyone can utilize public image repositories such as Docker Hub, and
    they may contain viruses or misconfigurations.
  prefs: []
  type: TYPE_NORMAL
- en: Container image integrity can also be enforced by using Docker Notary or a comparable
    service to add digital signatures to the image, which can then be validated in
    the container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Securing registries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Container images are often saved in either private or public registries. It’s
    crucial to keep these registries safe so that all team members and collaborators
    can use images that are as secure as possible.
  prefs: []
  type: TYPE_NORMAL
- en: If you have your own private registry, you must set up access controls that
    specify who can and cannot access and publish images. Access control is a fundamental
    security measure that can prevent unauthorized parties from altering, publishing,
    or deleting your images.
  prefs: []
  type: TYPE_NORMAL
- en: Securing your host
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s just as critical to secure your host as it is to secure your containers.
    The host where the containers operate is often made up of an operating system
    with a Linux kernel, a collection of libraries, a container runtime, and various
    background services and helpers. Any of these components could be insecure or
    misconfigured, allowing unauthorized access to running containers or a **Denial
    of Service** (**DoS**) attack.
  prefs: []
  type: TYPE_NORMAL
- en: For example, difficulties with the container runtime itself, such as a DoS attack
    that prohibits the creation of new containers in a host, can have an impact on
    your operating containers. You could use host scanning utilities to identify known
    security holes in the host’s container runtime, services, standard libraries such
    glibc, and the kernel (quite similar to what image scanning does for a container
    image).
  prefs: []
  type: TYPE_NORMAL
- en: Securing your runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some best practices for ensuring runtime security:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Create separate virtual networks for your containers*: This adds a layer of
    isolation that can help limit the attack surface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Use the principle of least privilege*: Only allow connectivity between containers
    that genuinely require it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Only expose the ports required by the application*: Except for SSH, do not
    expose any additional ports. Apply this idea to both containers and underlying
    computers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Use TLS to secure service communication*: This method encrypts traffic and
    ensures that only authorized endpoints are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Use the Docker image policy plugin*: This plugin prevents any process from
    retrieving images that have not previously been allow-listed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing container privileges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The scope of a vulnerability exploited inside a container is largely determined
    by the container’s privileges and isolation from the host and other resources.
    The existing and prospective vulnerabilities can be mitigated by using runtime
    settings in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the container as a user, not as a root. Use randomized UIDs if possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker and Kubernetes both allow for the removal of capabilities and the disabling
    of privileged containers. Seccomp and AppArmor can limit the types of actions
    that a container can execute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid a container taking all of the memory or CPUs and starving other apps,
    use resource limits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine shared storage or volumes on a regular basis, paying special attention
    to the host path and sharing the filesystem from the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pod Security Policies can be used to create guardrails in your cluster and prevent
    misconfigured containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using real-time event and log auditing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Threats to container security can be detected by evaluating aberrant activity
    and auditing several sources of logs and events. The following are some examples
    of sources of events:'
  prefs: []
  type: TYPE_NORMAL
- en: Logs from the host and Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container calls to the operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use tools (such as Falco and Sysdig Secure) that can track the system calls
    that are made and send out alerts if anything unusual happens. It should come
    with a pre-configured library of rules as well as the option to write your own
    using a simple syntax. It should also be able to monitor the Kubernetes audit
    log.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring resource usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Excessive resource utilization (CPU, RAM, and network), a rapid drop in available
    disc space, an above-average error rate, or increased latency could all be signs
    that something is wrong with your system.
  prefs: []
  type: TYPE_NORMAL
- en: Collect metrics in the same way as Prometheus (refer to [*Chapter 8*](B18115_08.xhtml#_idTextAnchor121),
    *Monitoring the Health of Infrastructure and Applications*) does. Set up alerts
    to be notified as soon as the data exceeds the predicted thresholds. Use useful
    dashboards to track the evolution of metrics and see how they relate to other
    metrics and events in your system.
  prefs: []
  type: TYPE_NORMAL
- en: Common security misconfigurations and remediation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Incorrectly configured hosts, container runtimes, clusters, resources, and so
    on may give an attacker a way to increase their privileges and move upward.
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to spot configuration errors, why they’re problematic, and how to
    correct them by using benchmarks, best practices, and hardening guidelines. The
    **Center for Internet Security** (**CIS**) ([https://www.cisecurity.org/benchmark/kubernetes](https://www.cisecurity.org/benchmark/kubernetes))
    is the most authoritative source of information that provides free benchmarks
    for a variety of situations, and anyone and any firm can contribute their expertise.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest method to ensure security is to automate as much as possible. There
    are a number of tools, such as kube-bench ([https://github.com/aquasecurity/kube-bench](https://github.com/aquasecurity/kube-bench)),
    most of which are based on static configuration analysis, allow you to evaluate
    configuration parameters at various levels, and provide recommendations on how
    to change them.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, security controls that safeguard containers and the underlying infrastructure
    should be implemented and maintained as part of container security. Integrating
    security into the development pipeline can ensure that all components are protected
    from the beginning of their development phase to the end of their life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We looked at how to use Kata Containers to build a secure container runtime
    and how to employ hardware virtualization technology to improve workload isolation.
    We have also looked at how to enable the Kata add-on and run a sample application.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed best practices for establishing container security on your production-grade
    cluster. We also noticed how the MicroK8s add-on option has made it simpler to
    activate Kata Containers, which can dramatically improve the security and isolation
    of your container operations.
  prefs: []
  type: TYPE_NORMAL
- en: With Kata Containers maturing into a production-ready container runtime and
    subsequent uptake, there is a great opportunity to improve the hosted build and
    development environment approach to address the noisy neighbor problem and handle
    unique and privileged requirements without affecting current host settings or
    policies.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will continue our next use case of implementing
    strict confinement for isolated containers.
  prefs: []
  type: TYPE_NORMAL
