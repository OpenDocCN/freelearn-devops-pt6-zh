<html><head></head><body>
		<div id="_idContainer087">
			<h1 id="_idParaDest-122" class="chapter-number"><a id="_idTextAnchor134"/>6</h1>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor135"/>Tracing Technicalities with Grafana Tempo</h1>
			<p><strong class="bold">Grafana Tempo</strong> is the third telemetry storage tool<a id="_idIndexMarker538"/> from Grafana that we’ll discuss; it provides the capability<a id="_idIndexMarker539"/> to store and query trace data. This chapter will introduce the <strong class="bold">Tempo query language</strong> (<strong class="bold">TraceQL</strong>). TraceQL can be used to select and filter traces generated by your applications to gather insights from across traces; the language is very similar to LogQL and PromQL but tailored to trace data. In this chapter, we will explore the major tracing protocols and how they can be used to output traces from applications; this will help you make informed choices on which protocol to use in an application, or which protocols to support when collecting data. We’ll then explore the architecture of Tempo to understand how it can fulfill the need for a scalable platform <span class="No-Break">for tracing.</span></p>
			<p>We will cover the following main topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Introducing Tempo and the TraceQL <span class="No-Break">query language</span></li>
				<li>Exploring <span class="No-Break">tracing protocols</span></li>
				<li>Understanding the <span class="No-Break">Tempo architecture</span></li>
			</ul>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor136"/>Technical requirements</h1>
			<p>In this chapter, you will use the demo application and Grafana Cloud instance (set up in <a href="B18277_03.xhtml#_idTextAnchor063"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>). You'll find the code for the chapter in the GitHub repository at <a href="https://github.com/PacktPublishing/Observability-with-Grafana/tree/main/chapter6">https://github.com/PacktPublishing/Observability-with-Grafana/tree/main/chapter6</a>. You'll find the <em class="italic">Code in Action</em> videos <span class="No-Break">at </span><a href="https://packt.link/fJVXi"><span class="No-Break">https://packt.link/fJVXi</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor137"/>Updating the OpenTelemetry Demo application</h1>
			<p>For this chapter, we have provided<a id="_idIndexMarker540"/> an updated <strong class="source-inline">OTEL-Collector.yaml</strong> with additional tracing configuration. This updated configuration is in the GitHub repository in the <strong class="source-inline">chapter6</strong> directory. Full details on the update process are available from the GitHub repository <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">README.md</strong></span><span class="No-Break">.</span></p>
			<p>To apply this updated configuration<a id="_idIndexMarker541"/> to the OpenTelemetry Collector, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Upgrade the Collector <span class="No-Break">with Helm:</span><pre class="source-code">
<strong class="bold">$ helm upgrade --version '0.73.1' --values chapter6/OTEL-Collector.yaml --values OTEL-Creds.yaml owg open-telemetry/opentelemetry-collector</strong>
<strong class="bold">NAME: owg-otel-collector</strong>
<strong class="bold">LAST DEPLOYED: Sat Aug 19 12:42:36 2023</strong>
<strong class="bold">NAMESPACE: default</strong>
<strong class="bold">STATUS: deployed</strong>
<strong class="bold">REVISION: 4</strong>
<strong class="bold">…</strong></pre></li>				<li>Validate that the upgrade <span class="No-Break">was successful:</span><pre class="source-code">
<strong class="bold">$ kubectl get pods --selector=component=standalone-collector</strong>
<strong class="bold">NAME  READY   STATUS    RESTARTS   AGE</strong>
<strong class="bold">owg-otel-collector-594fddd656-tfstk   1/1     Terminating   1 (70s ago)   2m8s</strong>
<strong class="bold">owg-otel-collector-7b7fb876bd-vxgwg   1/1     Running       0             3s</strong></pre><p class="list-inset">Your traces will now have more labels, and will also produce service graphs and <span class="No-Break">span metrics.</span></p></li>			</ol>
			<p>Now that our local installation<a id="_idIndexMarker542"/> is updated, let’s begin by exploring the third query <span class="No-Break">language, TraceQL.</span></p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor138"/>Introducing Tempo and the TraceQL query language</h1>
			<p>Tempo and TraceQL are the newest of the tools<a id="_idIndexMarker543"/> and query languages we will explore in depth in this book. Like LogQL, TraceQL was built using PromQL as an inspiration and offers developers and operators a familiar set of filtering, aggregation, and mathematical tools that aid in the observability flow between metrics, logs, <span class="No-Break">and traces.</span></p>
			<p>Let’s have a quick look at how Tempo sees <span class="No-Break">trace data:</span></p>
			<ul>
				<li><strong class="bold">Trace collection</strong>: Introduced in <a href="B18277_02.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, a trace (or distributed trace) is a collection of data<a id="_idIndexMarker544"/> that represents a request propagating through a system. Traces are often collected from multiple applications. Spans are sent by each application to some form of collection architecture and, ultimately, to Tempo for storage <span class="No-Break">and querying.</span></li>
				<li><strong class="bold">Trace fields</strong>: The following diagram introduces a simplified <a id="_idIndexMarker545"/>structure of a trace, similar to the simplified structure of logs, seen in <a href="B18277_04.xhtml#_idTextAnchor092"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, and traces, seen in <a href="B18277_05.xhtml#_idTextAnchor106"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><span class="No-Break">:</span></li>
			</ul>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B18277_Figure_6.1.jpg" alt="Figure 6.1 – A simplified view of a trace containing four spans"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – A simplified view of a trace containing four spans</p>
			<p class="list-inset">Back in <a href="B18277_02.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we introduced the common fields of a trace. In the preceding figure, we can see that all four spans have the same <strong class="source-inline">trace_id</strong>, which is the unique identifier of the whole trace. Each span has a unique identifier, the <strong class="source-inline">span_id</strong>. Each span also records where it came from, using the <strong class="source-inline">parent_id</strong> field. Finally, the start<a id="_idIndexMarker546"/> and end times<a id="_idIndexMarker547"/> are recorded. This simplified<a id="_idIndexMarker548"/> view does exclude several of the fields seen in the <strong class="bold">OpenTelemetry Protocol</strong> (<strong class="bold">OTLP</strong>), <strong class="bold">Zipkin</strong>, and <strong class="bold">Jaeger</strong>, which are used to capture<a id="_idIndexMarker549"/> a lot of contextual information. We will discuss these later in <span class="No-Break">this chapter.</span></p>
			<p>Now that we’ve seen the structure of trace data, let’s now explore the Tempo interface and how we can <span class="No-Break">query data.</span></p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor139"/>Exploring the Tempo features</h2>
			<p>In this section, we will introduce<a id="_idIndexMarker550"/> the major features of Tempo, the tracing platform available in Grafana, and its query language, TraceQL. In <em class="italic">Chapters 4</em> and <em class="italic">5</em>, we introduced the LogQL and PromQL languages, which focus on being able to select log or metric data and offer detailed functionality to perform a powerful analysis of the selected data. Currently, PromQL only offers the ability to select trace data. While there are powerful tools to select this data, there are no tools to perform an analysis. Such functionality is an eventual aim for the product, but we wanted to highlight the current state of Tempo <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">v2.3.x</strong></span><span class="No-Break">.</span></p>
			<p>Let’s begin by exploring the user interface for Tempo and how it represents <span class="No-Break">trace data.</span></p>
			<h3>The Tempo interface</h3>
			<p>The main view used to explore<a id="_idIndexMarker551"/> data in Tempo is split into two parts, the <strong class="bold">query editor</strong>, and the <strong class="bold">trace view</strong>. In the following screenshot, the query editor<a id="_idIndexMarker552"/> is on the left and the trace<a id="_idIndexMarker553"/> view is on the right. When you first enter the view, you will only see the query editor. The trace view is opened when a trace ID or span ID is <span class="No-Break">clicked on:</span></p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B18277_Figure_6.2.jpg" alt="Figure 6.2 – The query editor (left) and the trace view (right)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The query editor (left) and the trace view (right)</p>
			<p>The results panel is contextual. If we use TraceQL to run<a id="_idIndexMarker554"/> a search, it will return a list of traces and spans that match; this is shown on the left in the preceding screenshot. However, if we search for a specific trace ID, we will be shown the trace view on the right, where we can explore the spans in <span class="No-Break">the trace.</span></p>
			<p>While we are examining the query panel, let’s look at two of the different search modes we can use, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B18277_Figure_6.3.jpg" alt="Figure 6.3 – Search modes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Search modes</p>
			<p>The two search modes<a id="_idIndexMarker555"/> shown in the preceding screenshot are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Basic Search mode</strong>: Here, you are presented with drop-down menus to select the traces<a id="_idIndexMarker556"/> you are interested in. This is especially useful for people who are new to Tempo and want to get data quickly, but we will not explore this search mode in this book. Be aware that this mode is due to be deprecated in <span class="No-Break">Grafana 10.3.</span></li>
				<li><strong class="bold">TraceQL mode</strong>: This allows you to use TraceQL to search in a very granular way for the data<a id="_idIndexMarker557"/> you need. This is the default <span class="No-Break">search mode.</span></li>
			</ul>
			<p>As well as these, three search modes <span class="No-Break">are available:</span></p>
			<ul>
				<li><strong class="bold">Loki Search mode</strong>: This should be familiar to you from <a href="B18277_04.xhtml#_idTextAnchor092"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>; it is available in Tempo, so you can<a id="_idIndexMarker558"/> pivot between logs containing trace and span IDs and a full trace view <span class="No-Break">very quickly.</span></li>
				<li><strong class="bold">JSON File mode</strong>: This allows for a trace saved in the JSON format to be imported and viewed<a id="_idIndexMarker559"/> directly. Combined with the export functionality, this allows for the simple preservation and sharing of interesting traces. Exploring the data in an exported JSON file is a good exercise for understanding the underlying data structures used <span class="No-Break">in tracing.</span></li>
				<li><strong class="bold">Service Graph mode</strong>: One of the most powerful features of collecting distributed traces<a id="_idIndexMarker560"/> is the ability to visualize the connections between those services. This tool gives anyone a clear graphical representation of how applications in a system communicate with each other. This functionality leverages metrics and traces together to represent a system’s current state. The tool will also indicate erroring requests in red and successful requests <span class="No-Break">in green.</span><p class="list-inset">The following screenshot <a id="_idIndexMarker561"/>shows the default view of a <span class="No-Break">service graph:</span></p></li>
			</ul>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B18277_Figure_6.4.jpg" alt="Figure 6.4 – Service graphs"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Service graphs</p>
			<p>As well as representing the connections between services, the preceding screenshot shows the request rates and average<a id="_idIndexMarker562"/> latency of the responses. Above the service graph, the <strong class="bold">Requests, Errors, and Duration</strong> (<strong class="bold">RED</strong>) metrics are shown. We will discuss these metrics in greater detail in <a href="B18277_09.xhtml#_idTextAnchor183"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">.</span></p>
			<p>At the time of writing, this aspect of OpenTelemetry and Tempo is under active development, and the authors<a id="_idIndexMarker563"/> are looking forward to the features that <span class="No-Break">are coming.</span></p>
			<p>Now that we have seen the interface for Tempo, let us understand how to use TraceQL to query <span class="No-Break">trace data.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor140"/>Exploring the Tempo Query language</h2>
			<p>Like Prometheus and<a id="_idIndexMarker564"/> Loki, Tempo offers a query language, <strong class="bold">TraceQL</strong>. Now that you are familiar<a id="_idIndexMarker565"/> with the interface of Tempo and the structure of traces, let’s explore the features <span class="No-Break">of TraceQL.</span></p>
			<h3>Field types</h3>
			<p>TraceQL uses two field types, <strong class="bold">intrinsic fields</strong> and <strong class="bold">attribute fields</strong>. Let’s look at these <span class="No-Break">in detail:</span></p>
			<ul>
				<li><strong class="bold">Intrinsic fields</strong>: These are the fundamental information<a id="_idIndexMarker566"/> of spans and traces. These are used to show information in the trace view. The intrinsic fields are <span class="No-Break">as follows:</span><ul><li><strong class="source-inline">status</strong>: The value could be <strong class="source-inline">error</strong>, <strong class="source-inline">ok</strong>, or <span class="No-Break">unset (</span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">)</span></li><li><strong class="source-inline">statusMessage</strong>: Optional text to clarify <span class="No-Break">the status</span></li><li><strong class="source-inline">duration</strong>: The time between the start and end of <span class="No-Break">the span</span></li><li><strong class="source-inline">name</strong>: The operation or <span class="No-Break">span name</span></li><li><strong class="source-inline">kind</strong>: The value could be <strong class="source-inline">server</strong>, <strong class="source-inline">client</strong>, <strong class="source-inline">producer</strong>, <strong class="source-inline">consumer</strong>, <strong class="source-inline">internal</strong>, or <strong class="source-inline">unspecified</strong>, which is a <span class="No-Break">fallback value</span></li><li><strong class="source-inline">traceDuration</strong>: Number of milliseconds between the start and end of all spans in <span class="No-Break">the trace</span></li><li><strong class="source-inline">rootName</strong>: The name of the first span of <span class="No-Break">the trace</span></li><li><strong class="source-inline">rootServiceName</strong>: The name of the first service of <span class="No-Break">the trace</span></li></ul></li>
				<li><strong class="bold">Attribute fields</strong>: These are the customizable fields that have been added to a span, either by the application<a id="_idIndexMarker567"/> or the collection tooling. Attribute fields are either span fields or resource fields, which is a distinction derived from the implementation <span class="No-Break">of OpenTelemetry:</span><ul><li><strong class="bold">Span attributes</strong> are the fields added to the span by the submitting application; examples include <strong class="source-inline">span.http.method</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">span.app.ads.ad_response_type</strong></span><span class="No-Break">.</span></li><li><strong class="bold">Resource attributes</strong>, conversely, represent the entity producing telemetry; examples<a id="_idIndexMarker568"/> include <strong class="source-inline">resource.container.id</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">resource.k8s.node.name</strong></span><span class="No-Break">.</span></li></ul><p class="list-inset">For efficient querying, it is best practice to always include <strong class="source-inline">span.</strong> and <strong class="source-inline">resource.</strong> in an attribute query. However, it is possible to use a leading <strong class="source-inline">.</strong> to query when you are unsure whether a field is a span or resource – for example, <strong class="source-inline">.http.method</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">.k8s.node.name</strong></span><span class="No-Break">.</span></p><p class="list-inset">When looking at an individual span, you can see the fields available under <strong class="bold">Span Attributes</strong> and <strong class="bold">Resource Attributes</strong>. This expanded view of a single trace shows the fields that are contained in <span class="No-Break">the span:</span></p></li>
			</ul>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B18277_Figure_6.5.jpg" alt="Figure 6.5 – Attributes for a span"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Attributes for a span</p>
			<p>Now that you have a good grasp of the fields available when searching traces in Tempo, let’s have a look at how to search for traces <span class="No-Break">and spans.</span></p>
			<h3>Selecting traces and spans</h3>
			<p>TraceQL offers tools to select data<a id="_idIndexMarker569"/> to show in a dashboard, or just to explore<a id="_idIndexMarker570"/> the current state of the system. These are described in the <span class="No-Break">following table:</span></p>
			<table id="table001-5" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Syntax</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Operators</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Scope</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Field selector</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">{field = " </strong><span class="No-Break"><strong class="source-inline">value"}</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">=</strong>, <strong class="source-inline">!=</strong>, <strong class="source-inline">&gt;</strong>, <strong class="source-inline">&gt;=</strong>, <strong class="source-inline">&lt;</strong>, <strong class="source-inline">&lt;=</strong>, <strong class="source-inline">=~</strong>, <strong class="source-inline">!~</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Selects spans on the value of <span class="No-Break">a field</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Field expressions</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">{field1="value1" &amp;&amp; </strong><span class="No-Break"><strong class="source-inline">field2="value2"}</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">&amp;&amp;</strong>, <strong class="source-inline">||</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Selects spans on the values of <span class="No-Break">multiple fields</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Logical operators</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">{field1="value1} &amp;&amp; {</strong><span class="No-Break"><strong class="source-inline">field1="value2}</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">&amp;&amp;</strong>, <strong class="source-inline">||</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Selects spans where a logical check between sets of spans is <strong class="source-inline">true</strong>. This can check <span class="No-Break">multiple fields.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Structural operators</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">{field1="value1"} &gt; {</strong><span class="No-Break"><strong class="source-inline">field2="value2}</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">&gt;</strong>, <strong class="source-inline">&gt;&gt;</strong>, <strong class="source-inline">~</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Searches for spans in the second filter where they are related to the <span class="No-Break">first filter.</span></p>
							<p>These are explained in more detail after <span class="No-Break">this table.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.1 – The selection operators available in TraceQL</p>
			<p>Structural operators offer the ability to carry out queries that take account of where conditions are met upstream (parent) or downstream (child) in a trace. Let’s look at <span class="No-Break">some examples:</span></p>
			<ul>
				<li><strong class="source-inline">&gt;</strong> or the <strong class="bold">child operator</strong> refers to the direct<a id="_idIndexMarker571"/> child, such as<a id="_idIndexMarker572"/> <span class="No-Break">the following:</span><pre class="source-code">
{.service.name="frontend"} &gt; {.service.name="productcatalogservice"}</pre><p class="list-inset">The preceding line would search for any span from the product catalog service, where the frontend service was the <span class="No-Break">immediate parent.</span></p></li>				<li><strong class="source-inline">&gt;&gt;</strong> or the <strong class="bold">descendent operator</strong> refers to any descendent, such<a id="_idIndexMarker573"/> as <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker574"/></span><span class="No-Break"> following:</span><pre class="source-code">
{.service.name="frontend"} &gt;&gt; {.service.name="cartservice"}</pre><p class="list-inset">This would search for any span from the cart service where the frontend service was a parent in the trace but could have passed through another service first, such as the <span class="No-Break">checkout service.</span></p></li>				<li><strong class="source-inline">~</strong> or the <strong class="bold">sibling operator</strong> refers to any spans that share<a id="_idIndexMarker575"/> the same parent, such<a id="_idIndexMarker576"/> as <span class="No-Break">the following:</span><pre class="source-code">
{.service.name="frontend"} ~ {.service.name="frontend"}</pre><p class="list-inset">This would search for any span that visited the frontend multiple times. In the demo application, the frontend service would be <span class="No-Break">the parent.</span></p></li>			</ul>
			<p>These operators allow us to select data. TraceQL also allows tools to carry out aggregation and mathematical functions on <span class="No-Break">trace data.</span></p>
			<h3>Aggregators and arithmetic</h3>
			<p>Aggregators and mathematical functions <a id="_idIndexMarker577"/>allow for more complex queries. These can display<a id="_idIndexMarker578"/> information aggregated across all traces. Some of these are described in the <span class="No-Break">following table:</span></p>
			<table id="table002-4" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Syntax</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Operators</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Scope</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Count aggregator</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">| count()</strong> <strong class="source-inline">&gt;</strong> <span class="No-Break"><strong class="source-inline">10</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">count()</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Refines the returned spans by the total count of spans in the <span class="No-Break">span set</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Numeric aggregators</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">|</strong> <strong class="source-inline">avg(duration) &gt; </strong><span class="No-Break"><strong class="source-inline">20ms</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">avg()</strong>, <strong class="source-inline">max()</strong>, <strong class="source-inline">min()</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">sum()</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Refines the returned spans by the field in the <span class="No-Break">span set</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Arithmetic operators</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">{field1 &lt; field2 * </strong><span class="No-Break"><strong class="source-inline">10}</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">+</strong>, <strong class="source-inline">-</strong>, <strong class="source-inline">*</strong>, <strong class="source-inline">/</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">^</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Performs arithmetic on <span class="No-Break">numeric fields</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.2 – Aggregation and mathematical operators in TraceQL</p>
			<p>It is worth noting that TraceQL is in active development<a id="_idIndexMarker579"/> at the time of writing, so this list <a id="_idIndexMarker580"/>of operators is expected <span class="No-Break">to grow.</span></p>
			<p>Now that you have seen how to search trace data, let’s discuss the important topic of moving seamlessly between data types to get a <span class="No-Break">full picture.</span></p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor141"/>Pivoting between data types</h2>
			<p>When correctly instrumented, an application <a id="_idIndexMarker581"/>will produce data that can be used to move between traces, logs, and metrics to truly understand what <span class="No-Break">is happening.</span></p>
			<p>Let’s consider the following span, where an error was seen in <strong class="source-inline">checkoutservice</strong>. This could be a problematic error in a real shop, as it suggests a customer got to the checkout and was unable to complete their sale for <span class="No-Break">some reason:</span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B18277_Figure_6.6.jpg" alt="Figure 6.6 – Finding the logs for an error"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Finding the logs for an error</p>
			<p>The query interface for Tempo offers a helpful link, <strong class="bold">Logs for this span</strong>, which will open a Loki query. This functionality uses the <strong class="source-inline">service_name</strong> and <strong class="source-inline">service_namespace</strong> fields from the trace to query Loki. In a similar way, services can inject the trace context (<strong class="source-inline">traceId</strong> and <strong class="source-inline">spanId</strong>) into their log output where available. Loki can then be configured to provide contextual linking to Tempo, to see the trace view. Finally, as mentioned in <a href="B18277_05.xhtml#_idTextAnchor106"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, metrics can present exemplars, which allow users to see a sample trace from a <span class="No-Break">metric graph.</span></p>
			<p>We’ve explored the ways of seeing<a id="_idIndexMarker582"/> the data produced by applications. In the next section, we will understand the different protocols that are available to produce trace data for <span class="No-Break">Grafana Tempo.</span></p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor142"/>Exploring tracing protocols</h1>
			<p>In <a href="B18277_02.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we introduced the three main <strong class="bold">tracing protocols</strong>, OTLP, Zipkin, and Jaeger. In this section, we will explore<a id="_idIndexMarker583"/> some of the features of these protocols, how well-supported they are, and how to use them in the software services that you write. We will also discuss the different <strong class="bold">headers</strong> used by these protocols to propagate<a id="_idIndexMarker584"/> context to other services. A tracing protocol is made up of a set of headers that are added to the HTTP requests made by an instrumented application. These headers are what propagate the information of individual spans to downstream services. Once all of these spans are collected, they form a fully <span class="No-Break">distributed trace.</span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor143"/>What are the main tracing protocols?</h2>
			<p>First, let’s look at the features and support of the main tracing protocols – OTLP, Zipkin, <span class="No-Break">and Jaeger.</span></p>
			<h3>OTLP</h3>
			<p>OTLP tracing offers support<a id="_idIndexMarker585"/> for C++, .NET, Erlang, Go, Java, JavaScript, PHP, Python, Ruby, Rust, and<a id="_idIndexMarker586"/> Swift. There is good support for OTLP in popular development frameworks such as Spring, Django, ASP.NET, and Gin. With this wide support, it is best practice to search the documentation for your framework of choice on how to instrument an application; in most cases, instrumentation can be as simple as adding a few lines <span class="No-Break">of dependencies.</span></p>
			<p>Tracing is an inherently distributed process, and there have been several standards to propagate trace fields. This means that applications may need to use different HTTP or gRPC headers when handling traces, depending on other applications in their operating environment. OTLP provides native support for W3C TraceContext, B3, and Jaeger propagation headers, as well as support for W3C baggage headers, used to propagate other context information. The support of B3 and Jaeger headers means that applications instrumented with Zipkin and Jaeger libraries are natively supported. However, other trace headers such as AWS’s X-Ray protocol are not maintained as part of the mainline distribution. If these protocols are used, it is recommended to use the relevant vendor’s distribution<a id="_idIndexMarker587"/> of OpenTelemetry – for example, the <em class="italic">AWS Distro for OpenTelemetry</em> when X-Ray is used in a monitored <span class="No-Break">environment (</span><a href="https://aws.amazon.com/otel/"><span class="No-Break">https://aws.amazon.com/otel/</span></a><span class="No-Break">).</span></p>
			<p>In the data collection space, OTLP<a id="_idIndexMarker588"/> trace data has good support from the OpenTelemetry Collector, Grafana<a id="_idIndexMarker589"/> Agent, FluentBit via a plugin, and Telegraf via <span class="No-Break">a plugin.</span></p>
			<h3>Zipkin</h3>
			<p>Zipkin offers support for C#, Go, Java, JavaScript, Ruby, Scalar, and PHP<a id="_idIndexMarker590"/> via supported<a id="_idIndexMarker591"/> libraries, and C++, C, Clojure, Elixir, Lua, and Scala, via community-supported libraries. As with OTLP, there is also good support for Zipkin in popular development frameworks, so it is good practice to check the framework documentation when <span class="No-Break">instrumenting applications.</span></p>
			<p>Zipkin only natively supports the B3 propagation headers. However, as frameworks offer pluggable support for different trace protocols, support for alternative propagation headers is probably easy to implement in <span class="No-Break">an application.</span></p>
			<p>When it comes to data collection, Zipkin is supported by the OpenTelemetry Collector, Grafana Agent, and the native tools created <span class="No-Break">by Zipkin.</span></p>
			<h3>Jaeger</h3>
			<p>We have included Jaeger<a id="_idIndexMarker592"/> for historical reasons<a id="_idIndexMarker593"/> here, but it is not recommended for adoption. Jaeger was originally developed by <em class="italic">Uber</em>. Before January 2022, Jaeger offered SDKs for Java, Python, Node.js, Go, C#, and C++. These SDKs supported the OpenTracing APIs. OpenTelemetry was formed by the OpenTracing and OpenCensus projects merging. Jaeger now recommends the use of the OpenTelemetry SDKs for instrumenting applications. For applications already using the Jaeger client<a id="_idIndexMarker594"/> libraries, migration guides have been provided by <span class="No-Break">OpenTelemetry: </span><a href="https://opentelemetry.io/docs/migration/opentracing/"><span class="No-Break">https://opentelemetry.io/docs/migration/opentracing/</span></a><span class="No-Break">.</span></p>
			<p>Jaeger libraries supported the Jaeger, Zipkin, and W3C TraceContext headers, but they had no support for any other <span class="No-Break">propagation formats.</span></p>
			<p>There was not wide support in data collectors for Jaeger while it was actively supported; the intended way to use the protocol was to collect data in a Jaeger backend locally in an environment. The OpenTelemetry Collector and Grafana Agent do offer receivers for Jaeger traces and allow you to collect these traces as applications migrate to the <span class="No-Break">OpenTelemetry protocol.</span></p>
			<p>Now that you are familiar with the tracing<a id="_idIndexMarker595"/> protocols, let’s look at the headers that are used to propagate information between<a id="_idIndexMarker596"/> services that use <span class="No-Break">distributed tracing.</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor144"/>Context propagation</h2>
			<p><strong class="bold">Distributed tracing</strong> is relatively new in web<a id="_idIndexMarker597"/> technologies, with the <strong class="bold">World Wide Web Consortium</strong> (<strong class="bold">W3C</strong>) making <strong class="bold">Trace Context</strong> a recommended standard in November 2021, while the <strong class="bold">Baggage</strong> format is still currently in a working draft<a id="_idIndexMarker598"/> state. Tracing<a id="_idIndexMarker599"/> records information<a id="_idIndexMarker600"/> in two <span class="No-Break">distinct</span><span class="No-Break"><a id="_idIndexMarker601"/></span><span class="No-Break"> ways:</span></p>
			<ul>
				<li>Traces and spans are sent to a collection agent by <span class="No-Break">each application</span></li>
				<li>Applications also share data using HTTP or gRPC headers, which are picked up by the <span class="No-Break">receiving application</span></li>
			</ul>
			<p>As tracing is a new technology, a couple of unofficial standard formats were used before the official W3C Trace Context headers were decided on. To provide some historical context on tracing, we’ll explore the <span class="No-Break">following formats:</span></p>
			<ul>
				<li><span class="No-Break">Jaeger/Uber headers</span></li>
				<li>Zipkin <span class="No-Break">B3 headers</span></li>
				<li>W3C Trace <span class="No-Break">Context headers</span></li>
				<li>W3C <span class="No-Break">baggage headers</span></li>
			</ul>
			<h3>Jaeger/Uber headers</h3>
			<p>Jaeger libraries historically<a id="_idIndexMarker602"/> used the following header formats; we’ve included these for historical<a id="_idIndexMarker603"/> reference, as these should be considered deprecated in favor of W3C <span class="No-Break">Trace Context.</span></p>
			<p>The two HTTP headers used in Jaeger are <strong class="source-inline">uber-trace-id</strong> and <strong class="source-inline">uberctx</strong>, which look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
uber-trace-id: {trace-id}:{span-id}:{parent-span-id}:{flags}
uberctx-{baggage-key}: {baggage-value}</pre>			<p>An example of the <strong class="source-inline">uber-trace-id</strong> header is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
uber-trace-id: 269daf90c4589ce1:5c44cd976d8f8cd9:39e8e549de678267:0x01</pre>			<p>Let’s break this down the various fields in the <span class="No-Break"><strong class="source-inline">uber-trace-id</strong></span><span class="No-Break"> header:</span></p>
			<ul>
				<li><strong class="source-inline">trace-id</strong>: This field is a 64-bit or 128-bit random number and is hex-encoded. In the example this <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">269daf90c4589ce1</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">span-id</strong> and <strong class="source-inline">parent-span-id</strong>: These are 64-bit random numbers and are hex-encoded. These are <strong class="source-inline">5c44cd976d8f8cd9</strong> and <span class="No-Break"><strong class="source-inline">39e8e549de678267</strong></span><span class="No-Break">, respectively.</span></li>
				<li><strong class="source-inline">flags</strong>: This field is used to convey additional information, such as whether the trace is being sampled. In this example, its value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0x01</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>In the <strong class="source-inline">uberctx</strong> baggage header, the fields are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">baggage-key</strong>: This is a unique string that is used to name <span class="No-Break">the header.</span></li>
				<li><strong class="source-inline">baggage-value</strong>: This is a string that will be percent-encoded. Baggage as a concept will be explored further in the <em class="italic">W3C </em><span class="No-Break"><em class="italic">baggage</em></span><span class="No-Break"> section.</span></li>
			</ul>
			<h3>Zipkin B3 headers</h3>
			<p>Zipkin libraries use <strong class="source-inline">B3</strong> headers; unlike the Uber <a id="_idIndexMarker604"/>headers, Zipkin has historically separated each field into its own header, as shown in the <span class="No-Break">following snippet:</span></p>
			<pre class="source-code">
X-B3-TraceId: {TraceId}
X-B3-ParentSpanId: {ParentSpanId}
X-B3-SpanId: {SpanId}
X-B3-Sampled: {bool}
X-B3-Flags: 1 OR header absent
b3: {TraceId}-{SpanId}-{SamplingState}-{ParentSpanId}</pre>			<p>Let’s break these <span class="No-Break">headers down:</span></p>
			<ul>
				<li><strong class="source-inline">X-B3-TraceId</strong>: Similar to the Jaeger format, <strong class="source-inline">TraceId</strong> is 64-bit or 128-bit hex-encoded. Here is an example of this header as it would <span class="No-Break">be sent:</span><pre class="source-code">
X-B3-TraceId: 68720d6346a16000531430804ce28f9c</pre></li>				<li> <strong class="source-inline">X-B3-ParentSpanId</strong> and <strong class="source-inline">X-B3-SpanId</strong>: These are 64-bit <span class="No-Break">and hex-encoded.</span></li>
				<li><strong class="source-inline">X-B3-Sampled</strong>: This has a value of either <strong class="source-inline">1</strong> or <strong class="source-inline">0</strong>, although early implementations may use <strong class="source-inline">true</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">X-B3-Flags</strong>: This header is used to propagate <span class="No-Break">debug decisions.</span></li>
				<li><strong class="source-inline">b3</strong>: Zipkin predated the introduction of the W3C Trace Context standards. To aid in the transition to the newly agreed standard, Zipkin introduced the <strong class="source-inline">b3</strong> header. Later versions of Zipkin can propagate using both these headers and the W3C Trace Context headers for interoperability. The <strong class="source-inline">b3</strong> header exactly matches the <strong class="source-inline">tracestate</strong> header used in <em class="italic">W3C Trace Context</em> and represents the other headers combined<a id="_idIndexMarker605"/> into <span class="No-Break">one mapping.</span></li>
			</ul>
			<h3>W3C Trace Context</h3>
			<p>W3C specifies a standard<a id="_idIndexMarker606"/> pair of headers, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
traceparent: {version}-{trace-id}-{parent-id}-{trace-flags}
tracestate: vendor specific trace information</pre>			<p>Let’s break these headers down into <span class="No-Break">their constituents:</span></p>
			<ul>
				<li>The various fields in <strong class="source-inline">traceparent</strong> are <span class="No-Break">as follows:</span><ul><li>The <strong class="source-inline">trace-id</strong> is a hex-encoded 16-byte <span class="No-Break">array (128-bit).</span></li><li><strong class="source-inline">parent-id</strong> is a hex-encoded 8-byte array (64-bit); this field is equivalent to <strong class="source-inline">span-id</strong> or <strong class="source-inline">SpanId</strong> in Jaeger and B3, respectively, and represents the span ID used by the service that generated the header. It differs from the B3 <strong class="source-inline">ParentSpanId</strong>, as this can be used to represent a service further upstream that initiated a <span class="No-Break">traced process.</span></li><li>The <strong class="source-inline">version</strong> field is another hex-encoded 8-bit field; it represents the version of the standard being used. Currently, only version <span class="No-Break">00 exists.</span></li><li><strong class="source-inline">trace-flags</strong> is another hex-encoded 8-bit field. In version 00 of the W3C standard, the only available flag is one to denote whether sampling is occurring <span class="No-Break">or not.</span></li></ul></li>
				<li><strong class="source-inline">tracestate</strong> is used to encode vendor-specific information. While <strong class="source-inline">traceparent</strong> is a fixed format and required by any vendor adopting the standard, <strong class="source-inline">tracestate</strong> is available for vendors to ensure that trace data is propagated while giving space for them to use and encode that data as desired. The only requirement regarding this header field is that the contents will be a comma-separated<a id="_idIndexMarker607"/> list of <span class="No-Break">key-value pairs.</span></li>
			</ul>
			<h3>W3C baggage</h3>
			<p><strong class="bold">Baggage</strong> is a related but different concept to a trace. Baggage<a id="_idIndexMarker608"/> headers contain contextual<a id="_idIndexMarker609"/> data that is passed between applications. These headers can share specific fields from one application and a downstream application. For example, we might have a top-level concept of <strong class="source-inline">tenantId</strong>, but when an application makes a request to a downstream application, that application may not need to know about <strong class="source-inline">tenantId</strong> for it to process the request. A baggage header allows us to propagate this <strong class="source-inline">tenantId</strong> field to the downstream application. The downstream application can then use this field in its observability instrumentation, while not polluting its data model with an unrelated field. This effectively separates <em class="italic">observability</em> concerns from <em class="italic">application</em> concerns. It’s important to note that data contained in baggage headers can be exposed to anyone inspecting network traffic, so it should not be used to share <span class="No-Break">sensitive information.</span></p>
			<p>W3C <strong class="source-inline">baggage</strong> headers look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
baggage: key1=value1,key2=value2;property1;propertyKey=propertyValue,…</pre>			<p>All fields must be percent-encoded; the full header must have 64 members or fewer, and it has a maximum size of 8,192 bytes. Using baggage gives systems a standardized way to propagate <span class="No-Break">contextual information.</span></p>
			<p>We’ve now discussed how trace data<a id="_idIndexMarker610"/> is produced by applications and how it is shared, both with a collection agent and other applications. Let’s take some time to look at how data is processed and stored <span class="No-Break">by Tempo.</span></p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor145"/>Understanding the Tempo architecture</h1>
			<p>Like Loki and Mimir, Tempo leverages<a id="_idIndexMarker611"/> object stores such as Amazon S3, Google Cloud Storage, and Microsoft Azure Blob Storage. With the horizontal scalability of components in both the read and write pathways, Tempo has a fantastic ability to scale as data <span class="No-Break">volumes increase.</span></p>
			<p>The following diagram shows the architecture used <span class="No-Break">by Tempo:</span></p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B18277_Figure_6.7.jpg" alt="Figure 6.7 – The Tempo architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – The Tempo architecture</p>
			<p>The <em class="italic">write</em> pathway for Tempo consists<a id="_idIndexMarker612"/> of <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Distributor</strong>: The distributor is responsible for accepting spans and routing them to the correct instance of the ingester service, based on the trace ID of <span class="No-Break">the span.</span></li>
				<li><strong class="bold">Ingester</strong>: The ingester is responsible for grouping spans into traces, batching multiple traces into blocks, and writing bloom filters and indexes for querying. Once a block is complete, the ingester also flushes the data to <span class="No-Break">the backend.</span></li>
				<li><strong class="bold">Metrics generator</strong>: The metrics generator is an optional component; it receives spans from the distributor and uses them to produce service graphs and span metrics (such as the rate and the error duration). These are then written to a <span class="No-Break">metrics backend.</span></li>
			</ul>
			<p>The <em class="italic">read</em> pathway has <span class="No-Break">these components:</span></p>
			<ul>
				<li><strong class="bold">Query frontend</strong>: The frontend is responsible<a id="_idIndexMarker613"/> for receiving a query and splitting it into smaller shards, based on the blocks (created by the ingester) that will be read to return the requested data. These shards are then queued <span class="No-Break">with queriers.</span></li>
				<li><strong class="bold">Querier</strong>: This component is responsible for finding the requested data, either from the backend if the block has been flushed, or directly from the ingester if the block is still <span class="No-Break">being collected.</span></li>
			</ul>
			<p>The <strong class="bold">compactor</strong>, which is a standalone component, is responsible<a id="_idIndexMarker614"/> for optimizing the use of the <span class="No-Break">backend storage.</span></p>
			<p>Now that we’re done exploring the system architecture of Tempo, you have seen all the major components of the tool, and how distributed tracing using Tempo can help provide great visibility of the components of the systems <span class="No-Break">you run.</span></p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor146"/>Summary</h1>
			<p>In this chapter, you learned how to use TraceQL to query trace data stored in Tempo, which will help you build queries for dashboards using this rich data source. You have explored the Tempo user interface, so you will be confident in moving around the interface. Combined with the skills learned in <em class="italic">Chapters 4</em> and <em class="italic">5</em> you will be confident in moving between log, metric, and trace data in Grafana to be able to observe the systems you <span class="No-Break">work with.</span></p>
			<p>We took a detailed look at the different protocols and libraries you can use when instrumenting an application, and we saw the levels of support those tools have across different programming languages. We also explored the HTTP headers that are used to propagate trace data between applications. This will help you choose the best way to instrument an application and how to work with applications that are already instrumented <span class="No-Break">with tracing.</span></p>
			<p>Finally, we looked at the Tempo architecture and how it can horizontally scale to support your organization with however many traces you need to sample. With this knowledge, you will understand how to operate a Tempo installation and monitor the <span class="No-Break">various components.</span></p>
			<p>In the next chapter, we will conclude <em class="italic">Part 2</em> of the book by showing you how to collect data from your infrastructure layers, whether that is a cloud provider such as AWS, Azure, or GCP, or a <span class="No-Break">Kubernetes cluster.</span></p>
		</div>
	</body></html>