- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing MicroK8s
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Kubernetes** is the world''s most popular orchestration technology for container-based
    applications, automating their deployment and scalability while also making maintenance
    easier. Kubernetes, on the other hand, has its own set of complications. So, how
    can an organization use containerization to address complexity while avoiding
    adding to Kubernetes'' complexity?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Canonical''s MicroK8s** is a powerful Cloud-Native Computing Foundation-certified
    Kubernetes distribution. Here are some of the key reasons why it has become a
    powerful enterprise computing platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Delivered as snap packages**: These are application packages for desktop,
    cloud, and even **Internet of Things** (**IoT**) devices that are simple to install
    and secured with auto-updates, and they can be deployed on any of the Linux distributions
    that support snaps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strict confinement**: This ensures complete isolation from the underlying
    operating system as well as a highly secure Kubernetes environment fit for production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Production-grade add-ons**: Add-ons such as Istio, Knative, CoreDNS, Prometheus,
    Jaeger, Linkerd, Cilium, and Helm are available. They are straightforward to set
    up, requiring only a few lines of commands. For better **Artificial Intelligence**
    (**AI**) and **Machine Learning** (**ML**) capabilities, Kubeflow is also available
    as an add-on to MicroK8s.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroK8s will speed up Kubernetes deployments due to its ability to decrease
    complexity. Treating devices like distributed containerized programs allows developers
    to concentrate on applications rather than infrastructure, making operations teams'
    lives easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'MicroK8s enables you to combine Kubernetes installations into a single cluster
    and distribute workloads over one or more of these nodes. In this chapter, we
    are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing MicroK8s Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a sample application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling add-ons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting/stopping MicroK8s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring MicroK8s to use local images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring MicroK8s to use built-in registries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring MicroK8s to use private/public registries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring MicroK8s services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting application and cluster issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing MicroK8s Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroK8s is a production-ready Kubernetes distribution that is powerful, lightweight,
    and reliable. It's a Kubernetes distribution for enterprises with a reduced memory
    and disk footprint, as well as pre-installed add-ons such as Istio, Knative, Grafana,
    Cilium, and others. MicroK8s meets your needs, whether you're running a production
    setup or just getting started with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Anyone who has attempted to work with Kubernetes understands how difficult it
    is to get up and running with the deployment. There are other minimalist solutions
    on the market that minimize deployment time and complexity, but they come at the
    cost of key extensibility and missing add-ons.
  prefs: []
  type: TYPE_NORMAL
- en: MicroK8s gets you up and running in just 60 seconds, so you don't waste too
    much time jumping through hurdles to get Kubernetes up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the key features are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimal**: For laptop and workstation development, developers need the smallest
    Kubernetes solution possible. When running on Ubuntu, MicroK8s is a self-contained
    Kubernetes cluster that works with Azure AKS, Amazon EKS, and Google GKE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy**: Lower administration and operations costs by using a single-package
    installation. All add-ons and dependencies are included.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secured**: Updates are available for all security breaches and can be applied
    immediately or scheduled according to your maintenance cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Up to date**: MicroK8s keeps up with upstream Kubernetes, releasing beta,
    RC, and final elements on the same day as upstream Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complete**: A handpicked set of manifests for common Kubernetes capabilities
    and services is already included in MicroK8s:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a. Automatic updates to the latest Kubernetes version
  prefs: []
  type: TYPE_NORMAL
- en: 'b. Service mesh: Istio and Linkerd'
  prefs: []
  type: TYPE_NORMAL
- en: 'c. Serverless: Knative and OpenFaaS'
  prefs: []
  type: TYPE_NORMAL
- en: 'd. Monitoring: Fluentd, Prometheus, and Grafana, Metrics'
  prefs: []
  type: TYPE_NORMAL
- en: e. Ingress, DNS, Dashboard, and clustering
  prefs: []
  type: TYPE_NORMAL
- en: f. GPU bindings for AI/ML
  prefs: []
  type: TYPE_NORMAL
- en: g. Cilium, Helm, and Kubeflow
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what MicroK8s is, let's see how easy it is to get started in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Quick installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroK8s is deployed via **snaps**. Snaps are containerized (like Docker) software
    packages that are easy to create and install; they bundle their dependencies,
    and they work on all major Linux systems without modification. Snaps auto-update
    and are safe to run. Also, keep in mind that the MicroK8s snap will be updated
    frequently to keep up with Kubernetes releases.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will guide you through a minimal installation that'll
    work while we walk through the introduction.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the minimal installation, you require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You should have either a Linux distribution such as Ubuntu (20.04 LTS, 18.04
    LTS, or 16.04 LTS) environment to execute the commands or any other operating
    system that supports `snapd`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 GB of memory and 20 GB of disk space are recommended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 1 – Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following steps, we will be installing a MicroK8s cluster. We will install
    a limited set of components such as `api-server`, `controller-manager`, `scheduler`,
    `kubelet`, `cni`, and `kube-proxy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A MicroK8s snap can be installed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output confirms that MicroK8s has been installed
    successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – MicroK8s installation ](img/B18115_Fig_2.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – MicroK8s installation
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, I''m using an Ubuntu VM hosted on the cloud, but MicroK8s can also
    be installed on Windows, macOS, and Raspberry Pi on ARM hardware. For other platforms,
    please refer to the following link: [https//microk8s.io/docs/install-alternatives](http://https//microk8s.io/docs/install-alternatives).'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also specify a channel when installing MicroK8s. The specified channel
    consists of two parts – the *track* and the *risk* level. For example, to install
    MicroK8s v1.20 with the risk level set to `stable`, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sudo snap install microk8s --classic --channel=1.20/stable**'
  prefs: []
  type: TYPE_NORMAL
- en: When the MicroK8s team determines that a release (*edge* and *candidate*) is
    ready, your cluster is updated to the *stable* risk level, indicating that no
    bugs have been discovered by users running the same revision on riskier branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'For accessing Kubernetes, MicroK8s includes its own version of `kubectl`. It
    can be used to perform commands that will monitor and control your Kubernetes
    cluster. MicroK8s adds a `microk8s.kubectl` command to avoid conflicting with
    an existing *kubectl* and overwriting any existing Kubernetes configuration file.
    If you just use MicroK8s, consider creating an alias with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output confirms that an alias was added successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – kubectl – adding an alias ](img/B18115_Fig_2.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – kubectl – adding an alias
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have installed MicroK8s. In the next steps, we will be verifying
    whether the installation has succeeded or not.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Verify the installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, check whether the newly deployed node is in the `Ready` state using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the command execution output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Verify the installation ](img/B18115_Fig_2.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Verify the installation
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get the error shown in *Figure 2.3*, it means MicroK8s doesn''t have
    enough permissions. MicroK8s creates a group to make it easier to use commands
    that require administrative privileges. To acquire access to the `.kube` caching
    directory by adding the current user to the group, run the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Adding users to the group ](img/B18115_Fig_2.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Adding users to the group
  prefs: []
  type: TYPE_NORMAL
- en: 'If you receive still an error, it means that MicroK8s is still starting the
    nodes in the background. Wait for a few minutes and try again. If the installation
    is successful, then you should be seeing the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Verify the installation ](img/B18115_Fig_2.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Verify the installation
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `kubectl describe` command to get the details of the node
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – The describe command used on a node ](img/B18115_Fig_2.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – The describe command used on a node
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have a fully functional Kubernetes cluster. To summarize,
    we have installed MicroK8s and verified whether the installation was successful
    or not. In the next section, we are going to deploy a sample application on the
    MicroK8s cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to deploy the `nginx` web server sample application. It is software
    that responds to client requests via `nginx` web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output indicates that there is no error in
    the deployment, and in the next steps, we can verify whether the Pods have been
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Create the deployment ](img/B18115_Fig_2.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Create the deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the `pods` status to verify whether the application has been deployed
    and is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output indicates that Pods have been created
    and in the `Running` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Check the status of the deployment ](img/B18115_Fig_2.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Check the status of the deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'The `nginx` application has been deployed successfully, so it can be exposed
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output indicates that the `nginx` application
    is exposed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Expose the deployment ](img/B18115_Fig_2.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Expose the deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see a new service and the `ClusterIP` address assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – get svc and the ClusterIP address ](img/B18115_Fig_2.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – get svc and the ClusterIP address
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that services are exposed externally, we can launch the web browser and
    point it to the external IP from our local machine to access the `nginx` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – The nginx landing page ](img/B18115_Fig_2.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – The nginx landing page
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have now deployed the `nginx` application to a fully functional
    Kubernetes cluster by using MicroK8s. This will help you to understand how MicroK8s
    gets you up and running in under 60 seconds. In the next section, we are going
    to learn about add-ons and how to enable them.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling add-ons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To provide a pure, lightweight version of Kubernetes, MicroK8s uses the bare
    minimum of components. With only a few keystrokes, **add-ons**, which are pre-packaged
    components that provide additional capabilities for your Kubernetes cluster, from
    simple DNS control to ML with Kubeflow, are accessible.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, the DNS add-on should be enabled to promote communication between
    services. The storage add-on provides directory space on the host for programs
    that require storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are easy to set up with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The command execution output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Enable DNS and storage add-ons ](img/B18115_Fig_2.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Enable DNS and storage add-ons
  prefs: []
  type: TYPE_NORMAL
- en: For the full list of available MicroK8s add-ons, please refer to the *Full list
    of add-ons* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the add-on is enabled, check whether all the components for the additional
    services can be started using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output indicates (in the highlighted portions)
    that additional services have been started and are in `Running` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Verify that additional components have been started ](img/B18115_Fig_2.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – Verify that additional components have been started
  prefs: []
  type: TYPE_NORMAL
- en: 'Add-ons that have been enabled can be disabled at any time by utilizing the
    `disable` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To check the list of available and installed addons, use the `status` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Use the status command to check the list of available and installed
    add-ons ](img/B18115_Fig_2.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – Use the status command to check the list of available and installed
    add-ons
  prefs: []
  type: TYPE_NORMAL
- en: In case of errors, MicroK8s gives you troubleshooting tools to check out what
    has gone wrong. In the following sections, we can check how to use troubleshooting
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Full list of add-ons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table shows the current list of add-ons at the time of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1 – The complete list of MicroK8s add-ons ](img/B18115_02_Table_2.1a.jpg)![Table
    2.1 – The complete list of MicroK8s add-ons ](img/B18115_02_Table_2.1b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.1 – The complete list of MicroK8s add-ons
  prefs: []
  type: TYPE_NORMAL
- en: We have now understood what an add-on is, and we have enabled a few add-ons,
    such as `dns` and `storage`. We've also seen the entire list of add-ons. In the
    next section, we will look at how to start/stop a MicroK8s cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Starting/stopping MicroK8s
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroK8s will run indefinitely unless you instruct it to **stop**. With these
    simple commands, you can *stop and start* MicroK8s.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop a MicroK8s cluster, use the `microk8s stop` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Use the stop command to stop the MicroK8s cluster ](img/B18115_Fig_2.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – Use the stop command to stop the MicroK8s cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the MicroK8s cluster, use the `microk8s start` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Use the start command to start the MicroK8s cluster ](img/B18115_Fig_2.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – Use the start command to start the MicroK8s cluster
  prefs: []
  type: TYPE_NORMAL
- en: MicroK8s will automatically restart after a reboot if you keep it running. If
    you don't want this to happen, simply run `microk8s stop` before turning off the
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how to start and stop a MicroK8s cluster. In the following section,
    we'll look at how to configure MicroK8s to work with local images.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring MicroK8s to use local images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Kubernetes orchestration framework** uses container images to manage
    containerized applications. These images can be in a local filesystem or can be
    downloaded from a remote registry. The most popular container tool is **Docker**.
    The following diagram is an introduction to what Docker does:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – What Docker does ](img/B18115_Fig_2.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – What Docker does
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose we have a container image built and available in the local Docker
    image repository. For example, here, I have the `nginx1.21` image in the local
    Docker image repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Docker images from the local Docker repository ](img/B18115_Fig_2.18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – Docker images from the local Docker repository
  prefs: []
  type: TYPE_NORMAL
- en: 'The `nginx1.21` local image is only recognized by Docker, and MicroK8s Kubernetes
    will not be aware of the image. This is because the MicroK8s Kubernetes cluster
    does not include your local Docker *daemon*. We can push the Docker image into
    the MicroK8s image cache by exporting it from the local Docker daemon using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Push the Docker image ](img/B18115_Fig_2.19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 – Push the Docker image
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have imported the image to the MicroK8s image cache, we can confirm
    whether the image is in there by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command execution output shows that our `nginx1.21` image is
    available in the MicroK8s image cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20 – The list of containerd images ](img/B18115_Fig_2.20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.20 – The list of containerd images
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the image, we can use the `microk8s kubectl apply -f <file>`
    command to deploy it to the MicroK8s Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I have created the `nginx.local` file with the deployment instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.21 – The nginx.local file with the deployment instructions ](img/B18115_Fig_2.21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.21 – The nginx.local file with the deployment instructions
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we are ready to deploy using the `kubectl apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.22 – Create the deployment using the apply command ](img/B18115_Fig_2.22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.22 – Create the deployment using the apply command
  prefs: []
  type: TYPE_NORMAL
- en: 'When the deployment is created, use the `kubectl get deployment` command to
    check the status of the deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23 – Check the status of the deployment ](img/B18115_Fig_2.23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.23 – Check the status of the deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'The following fields are displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NAME` indicates the names of the deployments in the namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READY` indicates how many replicas of the application are available to the
    users of the applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UP-TO-DATE` indicates the number of replicas that have been updated to achieve
    the desired state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AVAILABLE` indicates the number of replicas that are available to the users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AGE` indicates the amount of time that the application has been operating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes will act as if there is an image in the Docker Hub registry at `docker.io`
    for which it already has a cached copy. This procedure can be repeated whenever
    the image is changed.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to work with locally built images without a registry. In
    the next section, we are going to look at how to use MicroK8s' built-in registry
    for the management of images.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring MicroK8s to use its built-in registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By minimizing the time spent on uploading and downloading Docker images, having
    a private Docker registry can help you to be more productive. The registry that
    comes with MicroK8s is hosted inside a Kubernetes cluster and is accessible as
    a `NodePort` service on the localhost's port `32000`.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: You should be aware that this registry is not secured and will need additional
    steps to limit access from outside (in the case of production scenarios).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to enable the built-in registry using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.24 – Enable the registry ](img/B18115_Fig_2.24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.24 – Enable the registry
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the registry add-on has been set up with a 40 Gi persistent
    volume claim for storing images. Please note that the storage add-on is also enabled
    along with the registry to enable storage claims.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the registry set up, our next step is to tag the image and
    push it into the built-in registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.25 – Tag the Docker image ](img/B18115_Fig_2.25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.25 – Tag the Docker image
  prefs: []
  type: TYPE_NORMAL
- en: 'Push the tagged image into the built-in image, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.26 – Push the tagged image ](img/B18115_Fig_2.26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.26 – Push the tagged image
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Pushing to this insecure registry may fail in some Docker versions unless the
    daemon is specifically set to trust it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`{`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"insecure-registries" : ["localhost:32000"]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check whether the images are tagged by using the `docker images` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.27 – Check whether the images are tagged ](img/B18115_Fig_2.27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.27 – Check whether the images are tagged
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the image, we can use the `kubectl apply -f <file>` command
    to deploy it to the MicroK8s Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I have created the `nginx.builtin` file with the deployment instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.28 – The nginx.builtin file with the deployment instructions ](img/B18115_Fig_2.28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.28 – The nginx.builtin file with the deployment instructions
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we are ready to deploy using the `kubectl apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.29 – Create the deployment using the apply command ](img/B18115_Fig_2.29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.29 – Create the deployment using the apply command
  prefs: []
  type: TYPE_NORMAL
- en: 'When the deployment is created, use the `kubectl get deployment` command to
    check the status of the deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.30 – Check the status of the deployments using the kubectl get deployment
    command ](img/B18115_Fig_2.30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.30 – Check the status of the deployments using the kubectl get deployment
    command
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes will pull the image from the built-in registry. If there is a change
    to the image, *building* and *pushing* the images to the built-in registry can
    be repeated so that updates are propagated. If you've dedicated machines that
    host registries in a cluster, you'll need to alter the configuration files to
    point to the node's IP address.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will go through the steps on how to configure MicroK8s
    to pull the images from any of the public or private registries.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring MicroK8s to use private/public registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroK8s can pull the images from *private* or *public* registries as well,
    but before being able to pull container images, MicroK8s Kubernetes must be made
    aware of the registry endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that a `10.131.231.155`. The images we build need to be tagged
    with the `IP address:Port/image:tag` registry endpoint syntax, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`{`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"insecure-registries" : ["10.131.231.155:32000"]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To push it to one of the `hub.docker.com`, use the `docker login` command to
    log in and push the image tagged with `docker-hub-username/image-name:tag`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the image is tagged, push the tagged image into a private or public registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the image, we can use the `kubectl apply -f <file>` command
    to deploy like earlier. Here, I have created a file with the deployment instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.31 – The deployment file with instructions ](img/B18115_Fig_2.31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.31 – The deployment file with instructions
  prefs: []
  type: TYPE_NORMAL
- en: Once the deployment is created, use the `kubectl get deployment` command to
    check the status of the deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: In the *production* scenarios, a **private secure registry** needs to be used,
    which is more secure and limits access to specific users/applications. The recommended
    way is to create a secret from the Docker login credentials and use this secret
    to access the secure registry.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, we looked at how to set up MicroK8s using either local images or ones
    fetched from public or private registries. In the next section, we will look at
    how to configure the various services or components of MicroK8s.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring MicroK8s services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroK8s is made up of various services or components that are managed by a
    number of system daemons. Configuration of these services is read from files stored
    in the `$SNAP_DATA` directory, which normally points to `/var/snap/microk8s/current`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reconfigure the services, we will need to edit the respective file and then
    restart the respective daemon. The following table shows *system daemon services*
    that will be run by MicroK8s:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.2 – A list of the MicroK8s system daemon services ](img/B18115_02_Table_2.2a.jpg)![Table
    2.2 – A list of the MicroK8s system daemon services ](img/B18115_02_Table_2.2b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.2 – A list of the MicroK8s system daemon services
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how to troubleshoot issues at the application
    and cluster levels.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting application and cluster issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's critical to know that things can go wrong; there might be issues with the
    Kubernetes components themselves, or a problem with the MicroK8s component. In
    this section, we will cover some of the common issues and tools to assist you
    in determining what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: The application level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section assists users in debugging Kubernetes-deployed applications that
    aren't functioning as intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examining a **Pod** is the first step in troubleshooting it. With the following
    command, you can check the current state of the Pod and a historical list of the
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following command execution output, you can see that the `kubectl describe
    pod` command fetches the details of the container(s) and the Pod''s configuration
    information (labels, resource needs, and so on), as well as the container(s) and
    Pod''s status information (state, readiness, restart count, events, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.32 – Troubleshooting with the kubectl describe pods command ](img/B18115_Fig_2.32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.32 – Troubleshooting with the kubectl describe pods command
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes all the possible issues and solutions based
    on the Pod state from the previously described command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.3 – Examining the Pod status for possible issues ](img/B18115_02_Table_2.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.3 – Examining the Pod status for possible issues
  prefs: []
  type: TYPE_NORMAL
- en: We've looked at how to infer application issues from the Pod status information;
    in the following part, we'll look at it at the cluster level.
  prefs: []
  type: TYPE_NORMAL
- en: The cluster level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get detailed information about the overall health of a MicroK8s cluster,
    you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: By default, this command dumps all the information about the cluster to the
    output for debugging and diagnosing cluster problems. It also dumps the logs of
    all the Pods in the cluster, which are split into directories by namespace and
    Pod name.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes also generates events whenever any of the resources it manages undergoes
    a change. The entity that initiated the event, the type of event (`Normal`, `Warning`,
    `Error`, and so on), and the cause are generally included in these events. This
    data is typically stored in `etcd` and made available when you run `kubectl events`
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'These events provide insight into what occurred behind the scenes when a specific
    entity entered a particular state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'MicroK8s also has a built-in inspection tool to generate a comprehensive report
    on the status of MicroK8s subsystems and the machine they run on. By running the
    tool, we can verify whether the system is working or not, and it also gathers
    all the important data for bug reporting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Administrator privileges are required to run this tool and gather the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.33 – The MicroK8s inspection tool ](img/B18115_Fig_2.33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.33 – The MicroK8s inspection tool
  prefs: []
  type: TYPE_NORMAL
- en: We recognized that things may go wrong; there can be issues with the application,
    Kubernetes components, or the MicroK8s component. We've looked at how to diagnose
    problems and picked up a few tools to help us with our debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are unable to resolve your problem and feel it is due to a bug in MicroK8s,
    please submit an issue to the project repository at the following link: [https://github.com/ubuntu/microk8s/issues/](https://github.com/ubuntu/microk8s/issues/).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To summarize, we learned how to install MicroK8s, check the progress of the
    installation, and monitor and control a Kubernetes cluster in this chapter. We
    learned how to install a sample application and use some of the add-ons as well.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to use MicroK8s with local container images as well as images
    retrieved from public and private registries. Furthermore, we investigated the
    inspection tool that creates a complete report on MicroK8s and the system it runs
    on, as well as walked through common issues to assist in fixing the most frequently
    encountered problems.
  prefs: []
  type: TYPE_NORMAL
- en: The key concepts of *edge computing* will be introduced in the next chapter.
    We'll also look at some of the things to keep in mind when you develop your edge
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Kubernetes as the Preferred Platform for IoT and Edge Computing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data volumes continue to grow, particularly in industries such as manufacturing,
    oil and gas, energy, and transportation that are undergoing rapid digital transformation.
    There is a need to manage this data explosion at the edge and the many associated
    challenges, including the complexity of systems, data privacy, latency issues,
    low bandwidth connectivity, and increasing costs for storing and processing data,
    either in the cloud or data centers. In this part, we will look at how Kubernetes,
    the edge, and the cloud can collaborate to drive intelligent business decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of the book comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B18115_03.xhtml#_idTextAnchor051), *Essentials of IoT and Edge
    Computing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18115_04.xhtml#_idTextAnchor060), *Handling the Kubernetes Platform
    for IoT and Edge Computing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
