- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Understanding Kubernetes Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 架构
- en: In one sentence, Kubernetes is a platform to orchestrate the deployment, scaling,
    and management of container-based applications. You have probably read about Kubernetes,
    and maybe even dipped your toes in and used it in a side project or maybe even
    at work. But to understand what Kubernetes is all about, how to use it effectively,
    and what the best practices are requires much more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 用一句话来说，Kubernetes 是一个平台，用于编排容器化应用程序的部署、扩展和管理。你可能已经读过 Kubernetes 的相关内容，甚至可能在某个副项目或工作中使用过它。但要真正理解
    Kubernetes 是什么，如何有效使用它，以及最佳实践是什么，远远不止这些。
- en: Kubernetes is a big open source project and ecosystem with a lot of code and
    a lot of functionality. Kubernetes came out of Google, but joined the **Cloud
    Native Computing Foundation** (**CNCF**) and is now the de facto standard in the
    space of container-based applications. According to the 2021 CNCF survey, 96%
    of organizations use or evaluate Kubernetes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个庞大的开源项目和生态系统，包含了大量的代码和功能。Kubernetes 起源于 Google，但加入了 **云原生计算基金会**
    (**CNCF**)，现在成为了基于容器的应用程序领域的事实标准。根据 2021 年 CNCF 调查，96% 的组织在使用或评估 Kubernetes。
- en: In this chapter, we will build the foundation necessary to utilize Kubernetes
    to its full potential. We will start by understanding what Kubernetes is, what
    Kubernetes isn’t, and what container orchestration means exactly. Then we will
    cover important Kubernetes concepts that will form the vocabulary we will use
    throughout the book. After that, we will dive into the architecture of Kubernetes
    properly and look at how it enables all the capabilities it provides for its users.
    Then, we will discuss how Kubernetes supports multiple container runtimes in a
    generic way.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将打下充分利用 Kubernetes 潜力所需的基础。我们将从理解什么是 Kubernetes，什么不是 Kubernetes，以及容器编排究竟意味着什么开始。然后，我们将介绍
    Kubernetes 的重要概念，这些概念将构成我们贯穿全书的词汇。接下来，我们将深入探讨 Kubernetes 的架构，看看它是如何为用户提供各种功能的。之后，我们将讨论
    Kubernetes 如何以通用的方式支持多种容器运行时。
- en: 'The topics we will discuss are:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的主题包括：
- en: What is Kubernetes?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Kubernetes？
- en: What Kubernetes is not
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 不是
- en: Understanding container orchestration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解容器编排
- en: Kubernetes concepts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 概念
- en: Diving into Kubernetes architecture in depth
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入研究 Kubernetes 架构
- en: Kubernetes container runtimes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 容器运行时
- en: At the end of this chapter, you will have a solid understanding of container
    orchestration, what problems Kubernetes addresses, the rationale of Kubernetes
    design and architecture, and the different runtime engines it supports.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将对容器编排、Kubernetes 解决的问题、Kubernetes 设计和架构的基本理念，以及它支持的不同运行时引擎有一个扎实的理解。
- en: What is Kubernetes?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Kubernetes？
- en: 'Kubernetes is a platform that encompasses a huge number of services and capabilities
    that keeps growing. The core functionality is scheduling workloads in containers
    across your infrastructure, but it doesn’t stop there. Here are some of the other
    capabilities Kubernetes brings to the table:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个涵盖了大量服务和功能的庞大平台，且这些服务和功能还在不断增长。其核心功能是调度容器中的工作负载到你的基础设施中，但它不仅仅停留在这一点。以下是
    Kubernetes 带来的其他一些功能：
- en: Providing authentication and authorization
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供身份验证和授权
- en: Debugging applications
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试应用程序
- en: Accessing and ingesting logs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问和获取日志
- en: Rolling updates
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动更新
- en: Using Cluster Autoscaling
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集群自动扩展
- en: Using the Horizontal Pod Autoscaler
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用水平 Pod 自动扩展器
- en: Replicating application instances
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制应用程序实例
- en: Checking application health and readiness
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查应用程序健康状况和就绪性
- en: Monitoring resources
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控资源
- en: Balancing loads
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Naming and service discovery
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名和服务发现
- en: Distributing secrets
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发秘密
- en: Mounting storage systems
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载存储系统
- en: We will cover all these capabilities in great detail throughout the book. At
    this point, just absorb and appreciate how much value Kubernetes can add to your
    system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中详细介绍所有这些功能。此时，只需吸收并欣赏 Kubernetes 为你的系统带来的巨大价值。
- en: Kubernetes has impressive scope, but it is also important to understand what
    Kubernetes explicitly doesn’t provide.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 拥有广泛的功能，但同样重要的是要理解 Kubernetes 明确不提供的内容。
- en: What Kubernetes is not
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 不是
- en: 'Kubernetes is not a **Platform as a Service** (**PaaS**). It doesn’t dictate
    many important aspects that are left to you or to other systems built on top of
    Kubernetes, such as OpenShift and Tanzu. For example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 不是 **平台即服务** (**PaaS**)。它不强制规定很多重要方面，这些方面由你或在 Kubernetes 之上构建的其他系统（例如
    OpenShift 和 Tanzu）来处理。例如：
- en: Kubernetes doesn’t require a specific application type or framework
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes不要求特定的应用类型或框架
- en: Kubernetes doesn’t require a specific programming language
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes不要求特定的编程语言
- en: Kubernetes doesn’t provide databases or message queues
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes不提供数据库或消息队列
- en: Kubernetes doesn’t distinguish apps from services
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes不区分应用和服务
- en: Kubernetes doesn’t have a click-to-deploy service marketplace
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes没有点击部署的服务市场
- en: Kubernetes doesn’t provide a built-in function as a service solution
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes不提供内建的函数即服务解决方案
- en: Kubernetes doesn’t mandate logging, monitoring, and alerting systems
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes不强制要求日志、监控和告警系统
- en: Kubernetes doesn’t provide a CI/CD pipeline
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes不提供CI/CD管道
- en: Understanding container orchestration
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解容器编排
- en: The primary responsibility of Kubernetes is container orchestration. That means
    making sure that all the containers that execute various workloads are scheduled
    to run on physical or virtual machines. The containers must be packed efficiently
    following the constraints of the deployment environment and the cluster configuration.
    In addition, Kubernetes must keep an eye on all running containers and replace
    dead, unresponsive, or otherwise unhealthy containers. Kubernetes provides many
    more capabilities that you will learn about in the following chapters. In this
    section, the focus is on containers and their orchestration.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的主要责任是容器编排。那意味着确保所有执行各种工作负载的容器都能在物理或虚拟机上被调度运行。容器必须根据部署环境和集群配置的约束进行高效打包。此外，Kubernetes还必须时刻监控所有运行的容器，并替换死掉的、无响应的或其他不健康的容器。Kubernetes提供了许多更多的功能，你将在接下来的章节中学习到。在这一节中，重点是容器及其编排。
- en: Physical machines, virtual machines, and containers
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理机器、虚拟机器和容器
- en: It all starts and ends with hardware. In order to run your workloads, you need
    some real hardware provisioned. That includes actual physical machines, with certain
    compute capabilities (CPUs or cores), memory, and some local persistent storage
    (spinning disks or SSDs). In addition, you will need some shared persistent storage
    and to hook up all these machines using networking, so they can find and talk
    to each other. At this point, you run multiple virtual machines on the physical
    machines or stay at the bare-metal level (no virtual machines). Kubernetes can
    be deployed on a bare-metal cluster (real hardware) or on a cluster of virtual
    machines. Kubernetes in turn can orchestrate the containers it manages directly
    on bare-metal or on virtual machines. In theory, a Kubernetes cluster can be composed
    of a mix of bare-metal and virtual machines, but this is not very common. There
    are many more esoteric configurations with different levels of encapsulation,
    such as virtual Kubernetes clusters running inside the namespaces of another Kubernetes
    cluster.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一切从硬件开始并以硬件结束。为了运行工作负载，你需要一些真实的硬件资源。这包括实际的物理机器，具备一定计算能力（CPU或核心）、内存以及一些本地持久存储（旋转磁盘或SSD）。此外，你还需要一些共享的持久存储，并通过网络将所有这些机器连接起来，使它们能够互相发现并通信。此时，你可以在物理机器上运行多个虚拟机，或者停留在裸金属层级（不使用虚拟机）。Kubernetes可以部署在裸金属集群（真实硬件）上，也可以部署在虚拟机集群上。Kubernetes反过来可以直接在裸金属或虚拟机上编排它所管理的容器。理论上，Kubernetes集群可以由裸金属和虚拟机的混合组成，但这并不常见。还有许多更为深奥的配置，具有不同级别的封装，例如运行在另一个Kubernetes集群的命名空间中的虚拟Kubernetes集群。
- en: The benefits of containers
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器的优势
- en: 'Containers represent a true paradigm shift in the development and operation
    of large, complicated software systems. Here are some of the benefits compared
    to more traditional models:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 容器代表了大型复杂软件系统开发和运维的真正范式转变。与传统模型相比，以下是容器的一些优点：
- en: Agile application creation and deployment
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏捷应用创建和部署
- en: Continuous development, integration, and deployment
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续开发、集成和部署
- en: Development and operations separation of concerns
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发与运维的职责分离
- en: Environmental consistency across development, testing, staging, and production
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发、测试、预生产和生产环境的一致性
- en: Cloud and OS distribution portability
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云和操作系统的分发可移植性
- en: Application-centric management
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以应用为中心的管理
- en: Resource isolation
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源隔离
- en: Resource utilization
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源利用率
- en: Containers in the cloud
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云中的容器
- en: Microservices are the dominant architecture for modern large-scale systems.
    The primary idea is to break down the system into small services with well-defined
    responsibilities that manage their own data and communicate with other microservices
    through well-defined APIs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是现代大规模系统的主流架构。其核心思想是将系统拆分成小的服务，每个服务有明确的责任，管理自己的数据，并通过明确的API与其他微服务进行通信。
- en: Containers are ideal to package microservices because, while providing isolation
    to the microservice, they are very lightweight and you don’t incur a lot of overhead
    when deploying many microservices, as you do with virtual machines. That makes
    containers ideal for cloud deployment, where allocating a whole virtual machine
    for each microservice would be cost-prohibitive.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是打包微服务的理想选择，因为它们不仅提供了微服务的隔离，而且非常轻量化，在部署多个微服务时，你不会像虚拟机那样增加过多的开销。这使得容器非常适合云部署，因为为每个微服务分配一台完整的虚拟机会导致成本过高。
- en: All major cloud providers, such as Amazon AWS, Google’s GCE, and Microsoft’s
    Azure, provide container hosting services these days. Many other companies jumped
    on the Kubernetes bandwagon and offer managed Kubernetes services, including IBM
    IKS, Alibaba Cloud, DigitalOcean DKS, Oracle OKS, OVH Managed Kubernetes, and
    Rackspace KaaS.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，所有主要的云服务提供商，如Amazon AWS、谷歌的GCE和微软的Azure，都提供容器托管服务。许多其他公司也加入了Kubernetes的阵营，提供托管的Kubernetes服务，包括IBM
    IKS、阿里云、DigitalOcean DKS、Oracle OKS、OVH托管Kubernetes和Rackspace KaaS。
- en: Google’s GKE was always based on Kubernetes. AWS **Elastic Kubernetes Service**
    (**EKS**) was added in addition to the proprietary AWS ECS orchestration solution.
    Microsoft Azure’s container service used to be based on Apache Mesos, but later
    switched to Kubernetes with **Azure Kubernetes Service** (**AKS**). You could
    always deploy Kubernetes on all the cloud platforms, but it wasn’t deeply integrated
    with other services. But, at the end of 2017 all cloud providers announced direct
    support for Kubernetes. Microsoft launched AKS, and AWS released EKS. Also, various
    other companies offer managed Kubernetes services such as IBM, Oracle, Digital
    Ocean, Alibaba, Tencent, and Huawei.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的GKE始终基于Kubernetes。AWS的**弹性Kubernetes服务**（**EKS**）是在原有的AWS ECS编排解决方案基础上增加的。微软Azure的容器服务曾经基于Apache
    Mesos，但后来转向Kubernetes，推出了**Azure Kubernetes服务**（**AKS**）。你始终可以在所有云平台上部署Kubernetes，但它并未与其他服务深度集成。然而，在2017年底，所有云服务提供商都宣布了对Kubernetes的直接支持。微软推出了AKS，AWS发布了EKS。此外，还有各种其他公司提供托管的Kubernetes服务，如IBM、Oracle、Digital
    Ocean、阿里巴巴、腾讯和华为。
- en: Cattle versus pets
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 牲畜与宠物
- en: In the olden days, when systems were small, each server had a name. Developers
    and users knew exactly what software was running on each machine. I remember that,
    in many of the companies I worked for, we had multi-day discussions to decide
    on a naming theme for our servers. For example, composers and Greek mythology
    characters were popular choices. Everything was very cozy. You treated your servers
    like beloved pets. When a server died it was a major crisis. Everybody scrambled
    to try to figure out where to get another server, what was even running on the
    dead server, and how to get it working on the new server. If the server stored
    some important data, then hopefully you had an up-to-date backup, and maybe you’d
    even be able to recover it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，当系统还很小的时候，每台服务器都有一个名字。开发人员和用户清楚地知道每台机器上运行的软件是什么。我记得，在我工作的许多公司中，我们曾经花费几天时间讨论如何为我们的服务器命名。例如，作曲家和希腊神话中的人物是常见的命名主题。那时一切都非常温馨。你像对待心爱的宠物一样对待你的服务器。当一台服务器“死掉”时，那可是个大危机。每个人都急忙去找另一台服务器，搞清楚死掉的服务器上运行了什么，如何让它在新服务器上重新工作。如果服务器存储了一些重要数据，那么希望你有最新的备份，也许你还能够恢复它。
- en: Obviously, that approach doesn’t scale. When you have tens or hundreds of servers,
    you must start treating them like cattle. You think about the collective and not
    individuals. You may still have some pets like your CI/CD machines (although managed
    CI/CD solutions are becoming more common), but your web servers and backend services
    are just cattle.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种方法是无法扩展的。当你拥有数十或数百台服务器时，你必须开始像对待牲畜一样对待它们。你考虑的是整体，而不是个体。你可能仍然有一些“宠物”，比如你的CI/CD机器（尽管托管的CI/CD解决方案变得越来越普遍），但你的Web服务器和后端服务就只是牲畜。
- en: Kubernetes takes the cattle approach to the extreme and takes full responsibility
    for allocating containers to specific machines. You don’t need to interact with
    individual machines (nodes) most of the time. This works best for stateless workloads.
    For stateful applications, the situation is a little different, but Kubernetes
    provides a solution called StatefulSet, which we’ll discuss soon.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 将“养牛”模式发挥到极致，并且完全负责将容器分配到特定的机器上。大多数时候，你无需与单独的机器（节点）交互。这种方式最适合无状态工作负载。对于有状态的应用，情况稍有不同，但
    Kubernetes 提供了一种名为 StatefulSet 的解决方案，我们稍后将讨论。
- en: In this section, we covered the idea of container orchestration and discussed
    the relationships between hosts (physical or virtual) and containers, as well
    as the benefits of running containers in the cloud. We then finished with a discussion
    about cattle versus pets. In the following section, we will get to know the world
    of Kubernetes and learn its concepts and terminology.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了容器编排的概念，并讨论了主机（物理或虚拟）与容器之间的关系，以及在云中运行容器的好处。最后，我们讨论了“养牛”与“宠物”的区别。在接下来的章节中，我们将进一步了解
    Kubernetes 的世界，并学习它的概念和术语。
- en: Kubernetes concepts
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 概念
- en: In this section, we’ll briefly introduce many important Kubernetes concepts
    and give you some context as to why they are needed and how they interact with
    each other. The goal is to get familiar with these terms and concepts. Later,
    we will see how these concepts are woven together and organized into API groups
    and resource categories to achieve awesomeness. You can consider many of these
    concepts as building blocks. Some concepts, such as nodes and the control plane,
    are implemented as a set of Kubernetes components. These components are at a different
    abstraction level, and we will discuss them in detail in a dedicated section,
    *Kubernetes components*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍许多重要的 Kubernetes 概念，并为你提供一些背景信息，解释它们为何需要以及它们如何相互作用。目标是让你熟悉这些术语和概念。稍后，我们将看到这些概念如何被组织到
    API 组和资源类别中，以实现卓越的功能。你可以将这些概念视为构建块。一些概念，例如节点和控制平面，作为一组 Kubernetes 组件来实现。这些组件处于不同的抽象层次，我们将在专门的章节
    *Kubernetes 组件* 中详细讨论它们。
- en: 'Here is the Kubernetes architecture diagram:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Kubernetes 架构图：
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B18998_01_01.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，Teams 说明自动生成](img/B18998_01_01.png)'
- en: 'Figure 1.1: Kubernetes architecture'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：Kubernetes 架构
- en: Node
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点
- en: A node is a single host. It may be a physical or virtual machine. Its job is
    to run pods. Each Kubernetes node runs several Kubernetes components, such as
    the kubelet, the container runtime, and the kube-proxy. Nodes are managed by the
    Kubernetes control plane. The nodes are the worker bees of Kubernetes and shoulder
    all the heavy lifting. In the past they were called **minions**. If you read some
    old documentation or articles, don’t get confused. Minions are just nodes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 节点是一个单独的主机。它可以是物理机或虚拟机。它的工作是运行 pods。每个 Kubernetes 节点都运行多个 Kubernetes 组件，如 kubelet、容器运行时和
    kube-proxy。节点由 Kubernetes 控制平面管理。节点是 Kubernetes 的“工蜂”，肩负着所有繁重的工作。过去它们被称为 **minions**。如果你阅读一些旧文档或文章，不要感到困惑，minions
    就是节点。
- en: Cluster
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集群
- en: A cluster is a collection of hosts (nodes) that provide compute, memory, storage,
    and networking resources. Kubernetes uses these resources to run the various workloads
    that comprise your system. Note that your entire system may consist of multiple
    clusters. We will discuss this advanced use case of multi-cluster systems in detail
    later.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 集群是由一组主机（节点）组成，它们提供计算、内存、存储和网络资源。Kubernetes 使用这些资源来运行构成系统的各种工作负载。请注意，整个系统可能由多个集群组成。稍后我们将详细讨论这一多集群系统的高级用例。
- en: Control plane
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制平面
- en: The control plane of Kubernetes consists of several components, such as an API
    server, a scheduler, a controller manager and, optionally, a cloud controller
    manager. The control plane is responsible for the global state of the cluster,
    cluster-level scheduling of pods, and handling of events. Usually, all the control
    plane components are set up on the same host although it’s not required. When
    considering high-availability scenarios or very large clusters, you will want
    to have control plane redundancy. We will discuss highly available clusters in
    detail in *Chapter 3*, *High Availability and Reliability*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的控制平面包括多个组件，如 API 服务器、调度器、控制器管理器和可选的云控制器管理器。控制平面负责集群的全局状态、Pod 的集群级调度和事件处理。通常，所有控制平面组件都设置在同一台主机上，尽管这并非必需。在考虑高可用性场景或非常大的集群时，您可能希望具备控制平面的冗余性。我们将在第三章“高可用性和可靠性”中详细讨论高可用性集群。
- en: Pod
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod
- en: A pod is the unit of work in Kubernetes. Each pod contains one or more containers
    (so you can think of it as a container container). A pod is scheduled as an atomic
    unit (all its containers run on the same machine). All the containers in a pod
    have the same IP address and port space; they can communicate with each other
    using localhost or standard inter-process communication. In addition, all the
    containers in a pod can have access to shared local storage on the node hosting
    the pod. Containers don’t get access to local storage or any other storage by
    default. Volumes of storage must be mounted into each container inside the pod
    explicitly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 是 Kubernetes 中的工作单位。每个 Pod 包含一个或多个容器（可以将其视为一个容器容器）。Pod 被调度为一个原子单位（所有容器运行在同一台机器上）。Pod
    中的所有容器共享相同的 IP 地址和端口空间；它们可以使用 localhost 或标准的进程间通信进行通信。此外，Pod 中的所有容器可以访问托管 Pod
    的节点上的共享本地存储。容器默认不会访问本地存储或任何其他存储，必须显式地将存储卷挂载到 Pod 内的每个容器中。
- en: 'Pods are an important feature of Kubernetes. It is possible to run multiple
    applications inside a single container by having something like supervisord as
    the main process that runs multiple processes, but this practice is often frowned
    upon for the following reasons:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 是 Kubernetes 的一个重要特性。通过像 supervisord 这样的主进程可以在单个容器内运行多个应用程序，但这种做法通常不被推荐，原因如下：
- en: '**Transparency**: Making the containers within the pod visible to the infrastructure
    enables the infrastructure to provide services to those containers, such as process
    management and resource monitoring. This facilitates a number of conveniences
    for users.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**透明性**：使得 Pod 内的容器对基础设施可见，使得基础设施能够为这些容器提供服务，如进程管理和资源监控。这为用户提供了许多便利。'
- en: '**Decoupling software dependencies**: The individual containers may be versioned,
    rebuilt, and redeployed independently. Kubernetes may even support live updates
    of individual containers someday.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦软件依赖关系**：各个容器可以独立进行版本控制、重建和重新部署。Kubernetes 可能将来甚至支持对单个容器的实时更新。'
- en: '**Ease of use**: Users don’t need to run their own process managers, worry
    about signal and exit-code propagation, and so on.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：用户无需运行自己的进程管理器，不必担心信号和退出码的传播等问题。'
- en: '**Efficiency**: Because the infrastructure takes on more responsibility, containers
    can be more lightweight.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：由于基础设施承担了更多责任，容器可以更加轻量化。'
- en: Pods provide a great solution for managing groups of closely related containers
    that depend on each other and need to co-operate on the same host to accomplish
    their purpose. It’s important to remember that pods are considered ephemeral,
    throwaway entities that can be discarded and replaced at will. Each pod gets a
    **unique ID** (**UID**), so you can still distinguish between them if necessary.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 提供了管理紧密相关的容器组的出色解决方案，这些容器相互依赖并需要在同一主机上协作以完成其目的。重要的是要记住，Pod 被视为临时的、可丢弃的实体，可以随意丢弃和替换。每个
    Pod 都有一个**唯一 ID**（**UID**），因此如果有必要，仍然可以区分它们。
- en: Label
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Label
- en: Labels are key-value pairs that are used to group together sets of objects,
    very often pods via selectors. This is important for several other concepts, such
    as replica sets, deployments, and services that operate on dynamic groups of objects
    and need to identify the members of the group. There is an NxN relationship between
    objects and labels. Each object may have multiple labels, and each label may be
    applied to different objects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是键值对，用于通过选择器将一组对象组合在一起，通常是 pods。这对于其他多个概念非常重要，例如副本集、部署和服务，这些概念处理动态对象组并需要识别组的成员。对象与标签之间存在一个
    NxN 的关系。每个对象可以有多个标签，每个标签也可以应用于不同的对象。
- en: There are certain restrictions by design on labels. Each label on an object
    must have a unique key. The label key must adhere to a strict syntax. Note that
    labels are dedicated to identifying objects and are not for attaching arbitrary
    metadata to objects. This is what annotations are for (see the *Annotation* section).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 标签在设计上有一定的限制。每个对象上的标签必须具有唯一的键。标签键必须符合严格的语法要求。请注意，标签专门用于标识对象，而不是用来附加任意的元数据到对象上。注解就是用于这个目的（见*注解*部分）。
- en: Label selector
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签选择器
- en: 'Label selectors are used to select objects based on their labels. Equality-based
    selectors specify a key name and a value. There are two operators, `=` (or `==`)
    and `!=`, for equality or inequality based on the value. For example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 标签选择器用于根据标签选择对象。基于相等性的选择器指定键名和值。对于值的相等或不等，有两个运算符：`=`（或`==`）和`!=`。例如：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will select all objects that have that label key and value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将选择所有具有该标签键和值的对象。
- en: 'Label selectors can have multiple requirements separated by a comma. For example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 标签选择器可以有多个用逗号分隔的要求。例如：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Set-based selectors extend the capabilities and allow selection based on multiple
    values:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基于集合的选择器扩展了功能，允许基于多个值进行选择：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Annotation
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注解
- en: Annotations let you associate arbitrary metadata with Kubernetes objects. Kubernetes
    just stores the annotations and makes their metadata available. Annotation key
    syntax has similar requirements as label keys.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注解允许你将任意的元数据与 Kubernetes 对象关联。Kubernetes 只会存储注解并使它们的元数据可用。注解键的语法与标签键有类似的要求。
- en: In my experience, you always need such metadata for complicated systems, and
    it is nice that Kubernetes recognizes this need and provides it out of the box,
    so you don’t have to come up with your own separate metadata store and mapping
    object to their metadata.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，对于复杂的系统，你总是需要这样的元数据，而 Kubernetes 能够识别这种需求并且开箱即用，提供这种元数据，这样你就不必自己创建单独的元数据存储和映射对象。
- en: Service
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: 'Services are used to expose some functionality to users or other services.
    They usually encompass a group of pods, usually identified by – you guessed it
    – a label. You can have services that provide access to external resources, or
    pods you control directly at the virtual IP level. Native Kubernetes services
    are exposed through convenient endpoints. Note that services operate at layer
    3 (TCP/UDP). Kubernetes 1.2 added the Ingress object, which provides access to
    HTTP objects – more on that later. Services are published or discovered via one
    of two mechanisms: DNS, or environment variables. Services can be load-balanced
    inside the cluster by Kubernetes. But, developers can choose to manage load balancing
    themselves in case of services that use external resources or require special
    treatment.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 服务用于将某些功能暴露给用户或其他服务。它们通常包含一组 pods，通常通过标签来标识。你可以拥有提供对外部资源访问的服务，或者直接在虚拟 IP 层控制的
    pods。原生的 Kubernetes 服务通过便捷的端点暴露。注意，服务在第 3 层（TCP/UDP）上运行。Kubernetes 1.2 添加了 Ingress
    对象，它提供对 HTTP 对象的访问——稍后我们会详细讲解。服务通过两种机制之一进行发布或发现：DNS 或环境变量。服务可以通过 Kubernetes 在集群内进行负载均衡。但开发人员可以选择自己管理负载均衡，尤其是对于使用外部资源或需要特别处理的服务。
- en: There are many gory details associated with IP addresses, virtual IP addresses,
    and port spaces. We will discuss them in depth in *Chapter 10*, *Exploring Kubernetes
    Networking*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址、虚拟 IP 地址和端口空间涉及许多复杂的细节。我们将在*第 10 章*《探索 Kubernetes 网络》中深入讨论它们。
- en: Volume
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卷
- en: Local storage used by the pod is ephemeral and goes away with the pod in most
    cases. Sometimes that’s all you need, if the goal is just to exchange data between
    containers of the node, but sometimes it’s important for the data to outlive the
    pod, or it’s necessary to share data between pods. The volume concept supports
    that need. The essence of a volume is a directory with some data that is mounted
    into a container.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: There are many volume types. Originally, Kubernetes directly supported many
    volume types, but the modern approach for extending Kubernetes with volume types
    is through the **Container Storage Interface** (**CSI**), which we’ll discuss
    in detail in *Chapter 6*, *Managing Storage*. Most of the originally built-in
    volume types will have been (or are in the process of being) phased out in favor
    of out-of-tree plugins available through the CSI.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Replication controller and replica set
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Replication controllers and replica sets both manage a group of pods identified
    by a label selector and ensure that a certain number is always up and running.
    The main difference between them is that replication controllers test for membership
    by name equality and replica sets can use set-based selection. Replica sets are
    the way to go as they are a superset of replication controllers. I expect replication
    controllers to be deprecated at some point. Kubernetes guarantees that you will
    always have the same number of pods running as you specified in a replication
    controller or a replica set. Whenever the number drops due to a problem with the
    hosting node or the pod itself, Kubernetes will fire up new instances. Note that,
    if you manually start pods and exceed the specified number, the replica set controller
    will kill some extra pods.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Replication controllers used to be central to many workflows, such as rolling
    updates and running one-off jobs. As Kubernetes evolved, it introduced direct
    support for many of these workflows, with dedicated objects such as **Deployment**,
    **Job**, **CronJob**, and **DaemonSet**. We will meet them all later.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: StatefulSet
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pods come and go, and if you care about their data then you can use persistent
    storage. That’s all good. But sometimes you want Kubernetes to manage a distributed
    data store such as **Cassandra** or **CockroachDB**. These clustered stores keep
    the data distributed across uniquely identified nodes. You can’t model that with
    regular pods and services. Enter **StatefulSet**. If you remember earlier, we
    discussed pets versus cattle and how cattle is the way to go. Well, StatefulSet
    sits somewhere in the middle. StatefulSet ensures (similar to a ReplicaSet) that
    a given number of instances with unique identities are running at any given time.
    StatefulSet members have the following properties:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: A stable hostname, available in DNS
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ordinal index
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stable storage linked to the ordinal and hostname
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Members are created and terminated gracefully in order
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: StatefulSet can help with peer discovery as well as adding or removing members
    safely.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSet 可以帮助进行节点发现，并且能够安全地添加或删除成员。
- en: Secret
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Secret
- en: Secrets are small objects that contain sensitive info such as credentials and
    tokens. They are stored by default as plaintext in etcd, accessible by the Kubernetes
    API server, and can be mounted as files into pods (using dedicated secret volumes
    that piggyback on regular data volumes) that need access to them. The same secret
    can be mounted into multiple pods. Kubernetes itself creates secrets for its components,
    and you can create your own secrets. Another approach is to use secrets as environment
    variables. Note that secrets in a pod are always stored in memory (tmpfs in the
    case of mounted secrets) for better security. The best practice is to enable encryption
    at rest as well as access control with RBAC. We will discuss it in detail later.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets 是包含敏感信息的小对象，例如凭证和令牌。默认情况下，它们以明文形式存储在 etcd 中，通过 Kubernetes API 服务器访问，并可以作为文件挂载到需要访问它们的
    Pod 中（使用专用的 secret 卷，这些卷依赖于常规数据卷）。同一个 secret 可以挂载到多个 Pod 中。Kubernetes 本身为其组件创建
    secrets，你也可以创建自己的 secrets。另一种方法是将 secrets 作为环境变量使用。请注意，Pod 中的 secrets 始终存储在内存中（挂载的
    secret 的情况下是 tmpfs），以提高安全性。最佳实践是启用静态加密以及使用 RBAC 进行访问控制。我们将在后续章节详细讨论这一点。
- en: Name
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称
- en: Each object in Kubernetes is identified by a UID and a name. The name is used
    to refer to the object in API calls. Names should be up to 253 characters long
    and use lowercase alphanumeric characters, dashes (-), and dots (.). If you delete
    an object, you can create another object with the same name as the deleted object,
    but the UIDs must be unique across the lifetime of the cluster. The UIDs are generated
    by Kubernetes, so you don’t have to worry about it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的每个对象都有一个 UID 和一个名称。名称用于在 API 调用中引用对象。名称应最多包含 253 个字符，并且只能使用小写字母数字字符、连字符
    (-) 和点 (.)。如果删除一个对象，可以使用相同的名称创建另一个对象，但 UID 必须在整个集群生命周期内唯一。UID 是由 Kubernetes 生成的，因此你无需担心它。
- en: Namespace
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: A namespace is a form of isolation that lets you group resources and apply policies.
    It is also a scope for names. Objects of the same kind must have unique names
    within a namespace. By default, pods in one namespace can access pods and services
    in other namespaces.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是一种隔离形式，允许你将资源进行分组并应用策略。它也是名称的作用域。相同类型的对象在一个命名空间内必须有唯一的名称。默认情况下，一个命名空间中的
    Pod 可以访问其他命名空间中的 Pod 和服务。
- en: Note that there are cluster-scope objects like node objects and persistent volumes
    that don’t live in a namespace. Kubernetes may schedule pods from different namespaces
    to run on the same node. Likewise, pods from different namespaces can use the
    same persistent storage.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，也有一些集群范围的对象，如节点对象和持久卷，它们不属于任何命名空间。Kubernetes 可以将来自不同命名空间的 Pod 调度到同一节点上运行。同样，来自不同命名空间的
    Pod 也可以使用相同的持久存储。
- en: In multi-tenancy scenarios, where it’s important to totally isolate namespaces,
    you can do a passable job with proper network policies and resource quotas to
    ensure proper access and distribution of the physical cluster resources. But,
    in general namespaces are considered a weak form of isolation and there are other
    solutions more appropriated for hard multi-tenancy like virtual clusters, which
    we will discuss in *Chapter 4*, *Securing Kubernetes*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在多租户场景中，当需要完全隔离命名空间时，通过适当的网络策略和资源配额可以在一定程度上实现这一目标，以确保正确的访问控制和物理集群资源的分配。然而，通常来说，命名空间被认为是一种较弱的隔离形式，针对严格的多租户场景，虚拟集群等解决方案更加适用，后者将在*第
    4 章*，*Kubernetes 安全性*中讨论。
- en: We’ve covered most of Kubernetes’ primary concepts; there are a few more I mentioned
    briefly. In the next section, we will continue our journey into Kubernetes architecture
    by looking into its design motivations, the internals, and implementation, and
    even pick at the source code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了 Kubernetes 的大多数主要概念，还有一些我简单提到过。在接下来的章节中，我们将继续深入探讨 Kubernetes 架构，了解其设计动机、内部机制和实现，甚至看看源代码。
- en: Diving into Kubernetes architecture in depth
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解 Kubernetes 架构
- en: Kubernetes has very ambitious goals. It aims to manage and simplify the orchestration,
    deployment, and management of distributed systems across a wide range of environments
    and cloud providers. It provides many capabilities and services that should work
    across all these diverse environments and use cases, while evolving and remaining
    simple enough for mere mortals to use. This is a tall order. Kubernetes achieves
    this by following a crystal-clear, high-level design and well-thought-out architecture
    that promotes extensibility and pluggability.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 有非常宏大的目标。它旨在管理和简化跨多个环境和云服务提供商的分布式系统的编排、部署和管理。它提供了许多功能和服务，这些功能和服务应该能够在所有这些多样化的环境和使用案例中工作，同时在发展中保持足够简单，让普通人也能使用。这是一个艰巨的任务。Kubernetes
    通过遵循清晰明确的高层设计和深思熟虑的架构来实现这一点，这种架构促进了可扩展性和插件化。
- en: Kubernetes originally had many hard-coded or environment-aware components, but
    the trend is to refactor them into plugins and keep the core small, generic, and
    abstract.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 最初有许多硬编码或环境感知的组件，但现在的趋势是将它们重构为插件，并保持核心小巧、通用和抽象。
- en: In this section, we will peel Kubernetes like an onion, starting with various
    distributed systems design patterns and how Kubernetes supports them, then go
    over the surface of Kubernetes, which is its set of APIs, and then take a look
    at the actual components that comprise Kubernetes. Finally, we will take a quick
    tour of the source-code tree to gain even better insight into the structure of
    Kubernetes itself.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将像剥洋葱一样逐步剖析 Kubernetes，从各种分布式系统设计模式及其如何得到 Kubernetes 支持开始，然后讲解 Kubernetes
    的表面部分，也就是它的 API 集，接着看看构成 Kubernetes 的实际组件。最后，我们将快速浏览源代码树，以便更好地了解 Kubernetes 本身的结构。
- en: At the end of this section, you will have a solid understanding of Kubernetes
    architecture and implementation, and why certain design decisions were made.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节结束时，你将对 Kubernetes 的架构和实现有一个扎实的理解，并明白为什么做出某些设计决策。
- en: Distributed systems design patterns
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式系统设计模式
- en: All happy (working) distributed systems are alike, to paraphrase Tolstoy in
    *Anna Karenina*. That means that, to function properly, all well-designed distributed
    systems must follow some best practices and principles. Kubernetes doesn’t want
    to be just a management system. It wants to support and enable these best practices
    and provide high-level services to developers and administrators. Let’s look at
    some of those described as design patterns. We will start with single-node patterns
    such as sidecar, ambassador, and adapter. Then, we will discuss multi-node patterns.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所有成功的（正常工作的）分布式系统都是相似的，借用托尔斯泰在《安娜·卡列尼娜》中的话说。也就是说，为了正常运作，所有设计良好的分布式系统必须遵循一些最佳实践和原则。Kubernetes
    不仅仅想成为一个管理系统，它还希望支持并促进这些最佳实践，并为开发者和管理员提供高层服务。让我们来看看一些被称为设计模式的内容。我们将从单节点模式开始，比如
    sidecar、ambassador 和 adapter，然后再讨论多节点模式。
- en: Sidecar pattern
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sidecar 模式
- en: The sidecar pattern is about co-locating another container in a pod in addition
    to the main application container. The application container is unaware of the
    sidecar container and just goes about its business. A great example is a central
    logging agent. Your main container can just log to stdout, but the sidecar container
    will send all logs to a central logging service where they will be aggregated
    with the logs from the entire system. The benefits of using a sidecar container
    versus adding central logging to the main application container are enormous.
    First, applications are not burdened anymore with central logging, which could
    be a nuisance. If you want to upgrade or change your central logging policy or
    switch to a totally new provider, you just need to update the sidecar container
    and deploy it. None of your application containers change, so you can’t break
    them by accident. The Istio service mesh uses the sidecar pattern to inject its
    proxies into each pod.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Sidecar 模式是指在 pod 中与主应用容器共同部署另一个容器。应用容器不会知道 sidecar 容器的存在，只会继续执行自己的工作。一个很好的例子是中央日志代理。主容器可以将日志输出到
    stdout，但 sidecar 容器会将所有日志发送到中央日志服务，在那里与整个系统的日志汇总在一起。使用 sidecar 容器而不是将中央日志功能添加到主应用容器中的好处是巨大的。首先，应用程序不再承担中央日志的负担，这可能是一件麻烦事。如果你想升级或更改中央日志策略，或者切换到全新的提供商，你只需更新
    sidecar 容器并重新部署即可。你的应用容器不会改变，因此你不会不小心破坏它们。Istio 服务网格使用 sidecar 模式将代理注入到每个 pod
    中。
- en: Ambassador pattern
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ambassador 模式
- en: The ambassador pattern is about representing a remote service as if it were
    local and possibly enforcing some policy. A good example of the ambassador pattern
    is if you have a Redis cluster with one master for writes and many replicas for
    reads. A local ambassador container can serve as a proxy and expose Redis to the
    main application container on the localhost. The main application container simply
    connects to Redis on `localhost:6379` (Redis’s default port), but it connects
    to the ambassador running in the same pod, which filters the requests, and sends
    write requests to the real Redis master and read requests randomly to one of the
    read replicas. Just like with the sidecar pattern, the main application has no
    idea what’s going on. That can help a lot when testing against a real local Redis
    cluster. Also, if the Redis cluster configuration changes, only the ambassador
    needs to be modified; the main application remains blissfully unaware.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使者模式是将远程服务表现得像本地服务，并可能执行一些策略的模式。使者模式的一个很好的例子是，如果你有一个 Redis 集群，其中一个主节点用于写入，多个副本用于读取。一个本地使者容器可以充当代理，将
    Redis 显示给主应用容器，通过 localhost 提供服务。主应用容器只需连接到 `localhost:6379`（Redis 的默认端口），但它连接到运行在同一
    pod 中的使者容器，后者过滤请求，并将写请求发送到真正的 Redis 主节点，将读取请求随机发送到一个读取副本。就像 sidecar 模式一样，主应用根本不知道发生了什么。这在与真实的本地
    Redis 集群进行测试时非常有帮助。此外，如果 Redis 集群的配置发生变化，只需要修改使者，主应用仍然保持不知情。
- en: Adapter pattern
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适配器模式
- en: 'The adapter pattern is about standardizing output from the main application
    container. Consider the case of a service that is being rolled out incrementally:
    it may generate reports in a format that doesn’t conform to the previous version.
    Other services and applications that consume that output haven’t been upgraded
    yet. An adapter container can be deployed in the same pod with the new application
    container and massage their output to match the old version until all consumers
    have been upgraded. The adapter container shares the filesystem with the main
    application container, so it can watch the local filesystem, and whenever the
    new application writes something, it immediately adapts it.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式的目的是将主应用容器的输出标准化。考虑一个逐步推出的服务：它可能会生成与先前版本不兼容的报告格式。其他使用该输出的服务和应用尚未升级。一个适配器容器可以与新的应用容器一起部署在同一个
    pod 中，并将它们的输出调整为符合旧版本，直到所有消费者都升级完成。适配器容器与主应用容器共享文件系统，因此它可以监视本地文件系统，每当新应用写入内容时，它会立即进行适配。
- en: Multi-node patterns
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多节点模式
- en: The single-node patterns described earlier are all supported directly by Kubernetes
    via pods scheduled on a single node. Multi-node patterns involve pods scheduled
    on multiple nodes. Multi-node patterns such as leader election, work queues, and
    scatter-gather are not supported directly, but composing pods with standard interfaces
    to accomplish them is a viable approach with Kubernetes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的单节点模式都是通过在单个节点上调度 pod 直接由 Kubernetes 支持的。多节点模式涉及在多个节点上调度 pod。像领导者选举、工作队列和散点收集这样的多节点模式不被
    Kubernetes 直接支持，但通过将 pod 组合成具有标准接口的方式来实现它们是 Kubernetes 中可行的方法。
- en: Level-triggered infrastructure and reconciliation
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电平触发的基础设施与协调
- en: Kubernetes is all about control loops. It keeps watching itself and correcting
    issues. Level-triggered infrastructure means that Kubernetes has a desired state,
    and it constantly strives toward it. For example, if a replica set has a desired
    state of 3 replicas and it drops to 2 replicas, Kubernetes (the **ReplicaSet**
    controller part of Kubernetes) will notice and work to get back to 3 replicas.
    The alternative approach of edge-triggering is event-based. If the number of replicas
    dropped from 2 to 3, create a new replica. This approach is very brittle and has
    many edge cases, especially in distributed systems where events like replicas
    coming and going can happen simultaneously.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的核心是控制循环。它不断监控自身并纠正问题。基于电平触发的基础设施意味着 Kubernetes 有一个期望状态，并不断朝着该状态努力。例如，如果一个副本集的期望状态是
    3 个副本，而它降到 2 个副本，Kubernetes（作为 Kubernetes 的 **ReplicaSet** 控制器部分）会注意到并努力恢复到 3
    个副本。与此不同的边缘触发方法是基于事件的。如果副本数量从 2 个减少到 3 个，则创建一个新的副本。这种方法非常脆弱，并且有许多边界情况，特别是在分布式系统中，像副本进出这样的事件可能同时发生。
- en: After covering the Kubernetes architecture in depth let’s study the Kubernetes
    APIs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解 Kubernetes 架构后，让我们研究 Kubernetes API。
- en: The Kubernetes APIs
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes API
- en: 'If you want to understand the capabilities of a system and what it provides,
    you must pay a lot of attention to its API. The API provides a comprehensive view
    of what you can do with the system as a user. Kubernetes exposes several sets
    of REST APIs for different purposes and audiences via API groups. Some APIs are
    used primarily by tools and some can be used directly by developers. An important
    aspect of the APIs is that they are under constant development. The Kubernetes
    developers keep it manageable by trying to extend (adding new objects, and new
    fields to existing objects) and avoid renaming or dropping existing objects and
    fields. In addition, all API endpoints are versioned, and often have an alpha
    or beta notation too. For example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解系统的功能以及它能提供什么，你必须非常关注其 API。API 提供了你作为用户可以使用系统的全面视图。Kubernetes 通过 API 组为不同的目的和受众暴露了多组
    REST API。一些 API 主要供工具使用，而一些则可以直接供开发者使用。API 的一个重要方面是它们在不断发展。Kubernetes 开发者通过尽量扩展（添加新对象和新字段到现有对象）来保持可管理性，同时避免重命名或删除现有对象和字段。此外，所有
    API 端点都有版本标识，并且通常还带有 alpha 或 beta 标注。例如：
- en: '[PRE3]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can access the API through the kubectl CLI, via client libraries, or directly
    through REST API calls. There are elaborate authentication and authorization mechanisms
    we will explore in *Chapter 4*, *Securing Kubernetes*. If you have the right permissions
    you can list, view, create, update, and delete various Kubernetes objects. At
    this point, let’s get a glimpse into the surface area of the APIs.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 kubectl CLI、客户端库或直接通过 REST API 调用访问 API。我们将在*第 4 章*，*保护 Kubernetes*中探讨详细的认证和授权机制。如果你拥有适当的权限，你可以列出、查看、创建、更新和删除各种
    Kubernetes 对象。现在，让我们简单浏览一下 API 的表面区域。
- en: 'The best way to explore the API is via API groups. Some API groups are enabled
    by default. Other groups can be enabled/disabled via flags. For example, to disable
    the `autoscaling/v1` group and enable the `autoscaling/v2beta2` group you can
    set the `--runtime-config` flag when running the API server as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 探索 API 的最佳方式是通过 API 组。一些 API 组默认启用，其他组可以通过标志启用/禁用。例如，要禁用`autoscaling/v1`组并启用`autoscaling/v2beta2`组，可以在运行
    API 服务器时设置`--runtime-config`标志，方法如下：
- en: '[PRE4]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that managed Kubernetes clusters in the cloud don’t let you specify flags
    for the API server (as they manage it).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，云中的托管 Kubernetes 集群不允许你为 API 服务器指定标志（因为它们由云服务提供商管理）。
- en: Resource categories
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源类别
- en: 'In addition to API groups, another useful classification of available APIs
    is by functionality. The Kubernetes API is huge and breaking it down into categories
    helps a lot when you’re trying to find your way around. Kubernetes defines the
    following resource categories:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 API 组，另一种有用的 API 分类方式是按功能划分。Kubernetes API 非常庞大，将其拆分成不同的类别可以帮助你在探索过程中更加得心应手。Kubernetes
    定义了以下资源类别：
- en: '**Workloads**: Objects you use to manage and run containers on the cluster.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Workloads**：用于在集群上管理和运行容器的对象。'
- en: '**Discovery and load balancing**: Objects you use to expose your workloads
    to the world as externally accessible, load-balanced services.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发现与负载均衡**：用于将工作负载暴露给外界，作为外部可访问的、负载均衡的服务的对象。'
- en: '**Config and storage**: Objects you use to initialize and configure your applications,
    and to persist data that is outside the container.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置和存储**：用于初始化和配置应用程序的对象，以及持久化容器外部数据的对象。'
- en: '**Cluster**: Objects that define how the cluster itself is configured; these
    are typically used only by cluster operators.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cluster**：定义集群自身配置的对象；这些对象通常仅由集群操作员使用。'
- en: '**Metadata**: Objects you use to configure the behavior of other resources
    within the cluster, such as **HorizontalPodAutoscaler** for scaling workloads.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元数据**：用于配置集群内其他资源行为的对象，例如用于扩展工作负载的**HorizontalPodAutoscaler**。'
- en: In the following subsections, we’ll list the resources that belong to each group
    with the API group they belong to. We will not specify the version here because
    APIs move rapidly from alpha to beta to **GA** (**general availability**) and
    from V1 to V2, and so on.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将列出属于每个组的资源及其对应的 API 组。这里不会指定版本，因为 API 会快速从 alpha 到 beta 到**GA**（**通用可用性**），从
    V1 到 V2 等等。
- en: Workloads resource category
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工作负载资源类别
- en: 'The workloads category contains the following resources with their corresponding
    API groups:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 工作负载类别包含以下资源及其对应的 API 组：
- en: '**Container**: core'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：核心'
- en: '**CronJob**: batch'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CronJob**：批处理'
- en: '**ControllerRevision**: apps'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ControllerRevision**：应用程序'
- en: '**DaemonSet**: apps'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DaemonSet**：应用程序'
- en: '**Deployment**: apps'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deployment**：应用程序'
- en: '**HorizontalPodAutoscaler**: autoscaling'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HorizontalPodAutoscaler**: autoscaling'
- en: '**Job**: batch'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Job**: batch'
- en: '**Pod**: core'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod**: core'
- en: '**PodTemplate**: core'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PodTemplate**: core'
- en: '**PriorityClass**: scheduling.k8s.io'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PriorityClass**: scheduling.k8s.io'
- en: '**ReplicaSet**: apps'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ReplicaSet**: apps'
- en: '**ReplicationController**: core'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ReplicationController**: core'
- en: '**StatefulSet**: apps'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StatefulSet**: apps'
- en: Controllers create containers within pods. Pods execute containers and offer
    necessary dependencies, such as shared or persistent storage volumes, as well
    as configuration or secret data injected into the containers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器在Pod内创建容器。Pod执行容器，并提供必要的依赖项，例如共享或持久化存储卷，以及注入到容器中的配置或秘密数据。
- en: 'Here is a detailed description of one of the most common operations, which
    gets a list of all the pods across all namespaces as a REST API:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是其中一个最常见操作的详细描述，获取所有命名空间中所有Pods的列表作为REST API：
- en: '[PRE5]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It accepts various query parameters (all optional):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受各种查询参数（均为可选）：
- en: '`fieldSelector`: Specifies a selector to narrow down the returned objects based
    on their fields. The default behavior includes all objects.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fieldSelector`: 指定一个选择器，通过其字段来缩小返回对象的范围。默认行为是包括所有对象。'
- en: '`labelSelector`: Defines a selector to filter the returned objects based on
    their labels. By default, all objects are included.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labelSelector`: 定义一个选择器，通过对象的标签来筛选返回的对象。默认情况下，所有对象都会被包含。'
- en: '`limit`/`continue`: The `limit` parameter specifies the maximum number of responses
    to be returned in a list call. If there are more items available, the server sets
    the `continue` field in the list metadata. This value can be used with the initial
    query to fetch the next set of results.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit`/`continue`: `limit`参数指定在列表调用中返回的最大响应数量。如果有更多的项目可用，服务器会在列表元数据中设置`continue`字段。这个值可以与初始查询一起使用来获取下一组结果。'
- en: '`pretty`: When set to `''true''`, the output is formatted in a human-readable
    manner.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pretty`: 设置为`''true''`时，输出格式为人类可读的方式。'
- en: '`resourceVersion`: Sets a constraint on the acceptable resource versions that
    can be served by the request. If not specified, it defaults to unset.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resourceVersion`: 设置请求可提供的资源版本的约束。如果未指定，默认值为未设置。'
- en: '`resourceVersionMatch`: Determines how the `resourceVersion` constraint is
    applied in list calls. If not specified, it defaults to unset.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resourceVersionMatch`: 确定在列表调用中如何应用`resourceVersion`约束。如果未指定，默认值为未设置。'
- en: '`timeoutSeconds`: Specifies a timeout duration for the list/watch call. This
    limits the duration of the call, regardless of any activity or inactivity.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeoutSeconds`: 为列表/监视调用指定超时持续时间。无论是否有活动或非活动，这都限制了调用的持续时间。'
- en: '`watch`: Enables the monitoring of changes to the described resources and returns
    a continuous stream of notifications for additions, updates, and removals. The
    `resourceVersion` parameter must be specified.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`watch`: 启用对描述资源的变化进行监控，并返回一个连续的通知流，通知内容包括新增、更新和删除。必须指定`resourceVersion`参数。'
- en: Discovery and load balancing
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发现与负载均衡
- en: 'Workloads in a cluster are only accessible within the cluster by default. To
    make them accessible externally, either a `LoadBalancer` or a `NodePort` Service
    needs to be used. However, for development purposes, internally accessible workloads
    can be accessed through the API server using the “kubectl proxy” command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 集群中的工作负载默认仅在集群内可访问。要使其可在外部访问，需要使用`LoadBalancer`或`NodePort`服务。然而，对于开发目的，内部可访问的工作负载可以通过API服务器使用“kubectl
    proxy”命令进行访问：
- en: '`Endpoints`: `core`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Endpoints`: `core`'
- en: '`EndpointSlice`: `discovery.k8s.io/v1`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EndpointSlice`: `discovery.k8s.io/v1`'
- en: '`Ingress`: `networking.k8s.io`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ingress`: `networking.k8s.io`'
- en: '`IngressClass`: `networking.k8s.io`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IngressClass`: `networking.k8s.io`'
- en: '`Service`: `core`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Service`: `core`'
- en: Config and storage
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置与存储
- en: 'Dynamic configuration without redeployment and secret management are cornerstones
    of Kubernetes and running complex distributed applications on your Kubernetes
    cluster. The secret and configuration are not baked into container images and
    are stored in the Kubernetes state store (usually etcd). Kubernetes also provides
    a lot of abstractions for managing arbitrary storage. Here are some of the primary
    resources:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 动态配置和无需重新部署的秘密管理是Kubernetes的基石，也是运行复杂分布式应用程序在Kubernetes集群上的关键。秘密和配置不会嵌入到容器镜像中，而是存储在Kubernetes的状态存储中（通常是etcd）。Kubernetes还提供了许多抽象层来管理任意存储。以下是一些主要资源：
- en: '`ConfigMap`: `core`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfigMap`: `core`'
- en: '`CSIDriver`: `storage.k8s.io`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSIDriver`: `storage.k8s.io`'
- en: '`CSINode`: `storage.k8s.io`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSINode`: `storage.k8s.io`'
- en: '`CSIStorageCapacity`: `storage.k8s.io`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSIStorageCapacity`: `storage.k8s.io`'
- en: '`Secret`: `core`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Secret`: `core`'
- en: '`PersistentVolumeClaim`: `core`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PersistentVolumeClaim`: `core`'
- en: '`StorageClass`: `storage.k8s.io`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StorageClass`：`storage.k8s.io`'
- en: '`Volume`: `core`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Volume`：`core`'
- en: '`VolumeAttachment`: `storage.k8s.io`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VolumeAttachment`：`storage.k8s.io`'
- en: Metadata
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 元数据
- en: 'The metadata resources typically show up as sub-resources of the resources
    they configure. For example, a limit range is defined at the namespace level and
    can specify:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据资源通常作为它们所配置资源的子资源出现。例如，限制范围是在命名空间级别定义的，并且可以指定：
- en: The range of compute resource usage (minimum and maximum) for pods or containers
    within a namespace.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间内 pod 或容器的计算资源使用范围（最小值和最大值）。
- en: The range of storage requests (minimum and maximum) per `PersistentVolumeClaim`
    within a namespace.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间内每个 `PersistentVolumeClaim` 的存储请求范围（最小值和最大值）。
- en: The ratio between the resource request and limit for a specific resource within
    a namespace.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间内特定资源的资源请求与限制之间的比例。
- en: The default request/limit for compute resources within a namespace, which are
    automatically injected into containers at runtime.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间内计算资源的默认请求/限制，这些会在运行时自动注入到容器中。
- en: 'You will not interact with these objects directly most of the time. There are
    many metadata resources. You can find the complete list here: [https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#-strong-metadata-apis-strong-](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#-strong-metadata-apis-strong-).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你不会直接与这些对象交互。元数据资源非常多。你可以在此处找到完整的列表：[https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#-strong-metadata-apis-strong-](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#-strong-metadata-apis-strong-)。
- en: Cluster
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集群
- en: 'The resources in the cluster category are designed for use by cluster operators
    as opposed to developers. There are many resources in this category as well. Here
    are some of the most important resources:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 集群类别中的资源是为集群操作员设计的，而非开发人员。这个类别也有很多资源。以下是一些最重要的资源：
- en: '`Namespace`: `core`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Namespace`：`core`'
- en: '`Node`: `core`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Node`：`core`'
- en: '`PersistentVolume`: `core`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PersistentVolume`：`core`'
- en: '`ResourceQuota`: `core`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResourceQuota`：`core`'
- en: '`Role`: `rbac.authorization.k8s.io`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Role`：`rbac.authorization.k8s.io`'
- en: '`RoleBinding`: `rbac.authorization.k8s.io`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RoleBinding`：`rbac.authorization.k8s.io`'
- en: '`ClusterRole`: `rbac.authorization.k8s.io`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClusterRole`：`rbac.authorization.k8s.io`'
- en: '`ClusterRoleBinding`: `rbac.authorization.k8s.io`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClusterRoleBinding`：`rbac.authorization.k8s.io`'
- en: '`NetworkPolicy`: `networking.k8s.io`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetworkPolicy`：`networking.k8s.io`'
- en: Now that we understand how Kubernetes organizes and exposes its capabilities
    via API groups and resource categories, let’s see how it manages the physical
    infrastructure and keeps it up with the state of the cluster.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了 Kubernetes 如何通过 API 组和资源类别组织并公开其能力，接下来我们来看它是如何管理物理基础设施并与集群状态保持同步的。
- en: Kubernetes components
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 组件
- en: A Kubernetes cluster has several control plane components used to control the
    cluster, as well as node components that run on each worker node. Let’s get to
    know all these components and how they work together.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Kubernetes 集群有多个控制平面组件用于控制集群，还有运行在每个工作节点上的节点组件。让我们了解这些组件及其如何协同工作。
- en: Control plane components
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制平面组件
- en: The control plane components can all run on one node, but in a highly available
    setup or a very large cluster, they may be spread across multiple nodes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 控制平面组件可以全部运行在一个节点上，但在高度可用的设置或非常大的集群中，它们可能会分布在多个节点上。
- en: API server
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: API 服务器
- en: The Kubernetes API server exposes the Kubernetes REST API. It can easily scale
    horizontally as it is stateless and stores all the data in the etcd cluster (or
    another data store in Kubernetes distributions like k3s). The API server is the
    embodiment of the Kubernetes control plane.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 服务器暴露了 Kubernetes 的 REST API。由于它是无状态的，并且将所有数据存储在 etcd 集群中（或者像
    k3s 这样的 Kubernetes 发行版中的其他数据存储），它可以轻松进行水平扩展。API 服务器是 Kubernetes 控制平面的体现。
- en: etcd
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: etcd
- en: etcd is a highly reliable distributed data store. Kubernetes uses it to store
    the entire cluster state. In small, transient clusters a single instance of etcd
    can run on the same node with all the other control plane components. But, for
    more substantial clusters, it is typical to have a 3-node or even 5-node etcd
    cluster for redundancy and high availability.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: etcd 是一个高度可靠的分布式数据存储。Kubernetes 使用它来存储整个集群的状态。在小型、短暂的集群中，etcd 的单个实例可以与所有其他控制平面组件一起运行在同一个节点上。但对于更大的集群，通常会有一个
    3 节点甚至 5 节点的 etcd 集群，以实现冗余和高可用性。
- en: Kube controller manager
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Kube 控制器管理器
- en: The Kube controller manager is a collection of various managers rolled up into
    one binary. It contains the replica set controller, the pod controller, the service
    controller, the endpoints controller, and others. All these managers watch over
    the state of the cluster via the API, and their job is to steer the cluster into
    the desired state.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Kube 控制器管理器是多个管理器集合的二进制文件。它包含副本集控制器、Pod 控制器、服务控制器、端点控制器等。所有这些管理器通过 API 监视集群状态，它们的工作是将集群引导到期望的状态。
- en: Cloud controller manager
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 云控制器管理器
- en: When running in the cloud, Kubernetes allows cloud providers to integrate their
    platform for the purpose of managing nodes, routes, services, and volumes. The
    cloud provider code interacts with Kubernetes code. It replaces some of the functionality
    of the Kube controller manager. When running Kubernetes with a cloud controller
    manager you must set the Kube controller manager flag `--cloud-provider` to `external`.
    This will disable the control loops that the cloud controller manager is taking
    over.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中运行时，Kubernetes 允许云服务提供商集成他们的平台，以便管理节点、路由、服务和存储卷。云提供商的代码与 Kubernetes 代码交互。它替代了部分
    Kube 控制器管理器的功能。使用云控制器管理器运行 Kubernetes 时，必须将 Kube 控制器管理器的标志 `--cloud-provider`
    设置为 `external`。这将禁用云控制器管理器接管的控制循环。
- en: 'The cloud controller manager was introduced in Kubernetes 1.6, and it’s being
    used by multiple cloud providers already such as:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 云控制器管理器是在 Kubernetes 1.6 中引入的，已经被多个云服务提供商使用，例如：
- en: GCP
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCP
- en: AWS
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS
- en: Azure
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure
- en: BaiduCloud
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 百度云
- en: Digital Ocean
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Digital Ocean
- en: Oracle
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle
- en: Linode
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linode
- en: 'OK. Let’s look at some code. The specific code is not that important. The goal
    is just to give you a taste of what Kubernetes code looks like. Kubernetes is
    implemented in Go. A quick note about Go to help you parse the code: the method
    name comes first, followed by the method’s parameters in parentheses. Each parameter
    is a pair, consisting of a name followed by its type. Finally, the return values
    are specified. Go allows multiple return types. It is very common to return an
    error object in addition to the actual result. If everything is OK, the error
    object will be nil.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们来看一些代码。具体的代码并不重要，目的是让你了解 Kubernetes 代码的样子。Kubernetes 是用 Go 实现的。为了帮助你理解代码，简要说明
    Go 的用法：方法名在前，后面跟着方法的参数（括号内）。每个参数是一个由名称和类型组成的对。最后，指定返回值。Go 允许多个返回类型。返回错误对象和实际结果是很常见的。如果一切正常，错误对象将为
    nil。
- en: 'Here is the main interface of the `cloudprovider` package:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `cloudprovider` 包的主要接口：
- en: '[PRE6]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Most of the methods return other interfaces with their own method. For example,
    here is the `LoadBalancer` interface:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数方法返回其他接口及其自己的方法。例如，这里是 `LoadBalancer` 接口：
- en: '[PRE7]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Kube scheduler
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Kube 调度器
- en: 'The `kube-scheduler` is responsible for scheduling pods into nodes. This is
    a very complicated task as it needs to consider multiple interacting factors,
    such as:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`kube-scheduler` 负责将 Pod 调度到节点上。这是一项非常复杂的任务，因为它需要考虑多个相互作用的因素，例如：'
- en: Resource requirements
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源需求
- en: Service requirements
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务需求
- en: Hardware/software policy constraints
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件/软件政策约束
- en: Node affinity and anti-affinity specifications
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点亲和性与反亲和性规范
- en: Pod affinity and anti-affinity specifications
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod 亲和性与反亲和性规范
- en: Taints and tolerations
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 污点与容忍
- en: Local storage requirements
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地存储需求
- en: Data locality
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据本地性
- en: Deadlines
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 截止时间
- en: If you need some special scheduling logic not covered by the default Kube scheduler,
    you can replace it with your own custom scheduler. You can also run your custom
    scheduler side by side with the default scheduler and have your custom scheduler
    schedule only a subset of the pods.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一些默认 Kube 调度器未覆盖的特殊调度逻辑，你可以用自己的自定义调度器替换它。你还可以让自定义调度器与默认调度器并行运行，只调度 Pod
    的子集。
- en: DNS
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DNS
- en: Starting with Kubernetes 1.3, a DNS service is part of the standard Kubernetes
    cluster. It is scheduled as a regular pod. Every service (except headless services)
    receives a DNS name. Pods can receive a DNS name too. This is very useful for
    automatic discovery.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Kubernetes 1.3 开始，DNS 服务成为标准 Kubernetes 集群的一部分。它作为常规 Pod 调度。每个服务（除去无头服务）都会分配一个
    DNS 名称。Pod 也可以分配 DNS 名称。这对于自动发现非常有用。
- en: We covered all the control plane components. Let’s look at the Kubernetes components
    running on each node.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了所有的控制平面组件。接下来，让我们看看每个节点上运行的 Kubernetes 组件。
- en: Node components
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 节点组件
- en: Nodes in the cluster need a couple of components to interact with the API server,
    receive workloads to execute, and update the API server regarding their status.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 集群中的节点需要一些组件与API服务器交互，接收要执行的工作负载，并向API服务器更新它们的状态。
- en: Proxy
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代理
- en: The kube-proxy does low-level network housekeeping on each node. It reflects
    the Kubernetes services locally and can do TCP and UDP forwarding. It finds cluster
    IPs via environment variables or DNS.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: kube-proxy在每个节点上进行低级的网络维护。它在本地反映Kubernetes服务，并可以进行TCP和UDP转发。它通过环境变量或DNS查找集群IP。
- en: kubelet
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: kubelet
- en: 'The kubelet is the Kubernetes representative on the node. It oversees communicating
    with the API server and manages the running pods. That includes the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: kubelet是节点上Kubernetes的代表。它负责与API服务器通信，并管理正在运行的Pod。它包括以下内容：
- en: Receive pod specs
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收Pod的规格
- en: Download pod secrets from the API server
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从API服务器下载Pod密钥
- en: Mount volumes
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载卷
- en: Run the pod’s containers (via the configured container runtime)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Pod的容器（通过配置的容器运行时）
- en: Report the status of the node and each pod
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告节点和每个Pod的状态
- en: Run container liveness, readiness, and startup probes
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行容器的存活、就绪和启动探针
- en: In this section, we dug into the guts of Kubernetes and explored its architecture
    from a very high level of vision and supported design patterns, through its APIs
    and the components used to control and manage the cluster. In the next section,
    we will take a quick look at the various runtimes that Kubernetes supports.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们深入探讨了Kubernetes的内部机制，从一个非常高层次的视角探索其架构，支持的设计模式，直到它的API以及用于控制和管理集群的组件。在下一节中，我们将快速浏览Kubernetes支持的各种运行时。
- en: Kubernetes container runtimes
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes容器运行时
- en: Kubernetes originally only supported Docker as a container runtime engine. But
    that is no longer the case. Kubernetes now supports any runtime that implements
    the CRI interface.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes最初只支持Docker作为容器运行时引擎，但现在已经不再是这种情况。Kubernetes现在支持任何实现了CRI接口的运行时。
- en: In this section, you’ll get a closer look at the CRI and get to know some runtime
    engines that implement it. At the end of this section, you’ll be able to make
    a well-informed decision about which container runtime is appropriate for your
    use case and under what circumstances you may switch or even combine multiple
    runtimes in the same system.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将更深入地了解CRI，并了解一些实现它的运行时引擎。在本节结束时，你将能够做出充分的信息决策，选择适合你用例的容器运行时，并了解在什么情况下你可能会切换或甚至在同一系统中结合多个运行时。
- en: The Container Runtime Interface (CRI)
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器运行时接口（CRI）
- en: 'The CRI is a gRPC API, containing specifications/requirements and libraries
    for container runtimes to integrate with the kubelet on a node. In Kubernetes
    1.7 the internal Docker integration in Kubernetes was replaced with a CRI-based
    integration. This was a big deal. It opened the door to multiple implementations
    that can take advantage of advances in the container world. The kubelet doesn’t
    need to interface directly with multiple runtimes. Instead, it can talk to any
    CRI-compliant container runtime. The following diagram illustrates the flow:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: CRI是一个gRPC API，包含容器运行时与节点上的kubelet集成所需的规范/要求和库。在Kubernetes 1.7中，Kubernetes内部的Docker集成被替换为基于CRI的集成。这是一个重大变化，开启了多个实现的可能性，可以利用容器领域的进展。kubelet不需要直接与多个运行时接口交互。相反，它可以与任何符合CRI标准的容器运行时进行交互。以下图示说明了流程：
- en: '![Diagram  Description automatically generated](img/B18998_01_02.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图示 描述自动生成](img/B18998_01_02.png)'
- en: 'Figure 1.2: kubelet and cri'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：kubelet和cri
- en: 'There are two gRPC service interfaces `ImageService` and `RuntimeService` that
    CRI container runtimes (or shims) must implement. The `ImageService` is responsible
    for managing images. Here is the gRPC/protobuf interface (this is not Go):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个gRPC服务接口`ImageService`和`RuntimeService`，CRI容器运行时（或shim）必须实现。`ImageService`负责管理镜像。以下是gRPC/protobuf接口（这不是Go语言）：
- en: '[PRE8]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `RuntimeService` is responsible for managing pods and containers. Here
    is the gRPC/protobuf interface:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`RuntimeService`负责管理Pod和容器。以下是gRPC/protobuf接口：'
- en: '[PRE9]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The data types used as arguments and return types are called messages and are
    also defined as part of the API. Here is one of them:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参数和返回类型使用的数据类型被称为消息，并作为API的一部分进行定义。以下是其中之一：
- en: '[PRE10]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see messages can be embedded inside each other. The `CreateContainerRequest`
    message has one string field and two other fields, which are themselves messages:
    `ContainerConfig` and `PodSandboxConfig`.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，消息可以嵌套在彼此内部。`CreateContainerRequest` 消息有一个字符串字段和另外两个字段，这两个字段本身也是消息：`ContainerConfig`
    和 `PodSandboxConfig`。
- en: 'To learn more about gRPC and CRI check out the following resources:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 gRPC 和 CRI 的信息，请查看以下资源：
- en: '[https://grpc.io](https://grpc.io)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://grpc.io](https://grpc.io)'
- en: '[https://kubernetes.io/docs/concepts/architecture/cri/](https://kubernetes.io/docs/concepts/architecture/cri/)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/concepts/architecture/cri/](https://kubernetes.io/docs/concepts/architecture/cri/)'
- en: Now that you are familiar at the code level with what Kubernetes considers a
    runtime engine, let’s look at the individual runtime engines briefly.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在代码层面上了解了 Kubernetes 所认为的运行时引擎，我们来简要看一下各个独立的运行时引擎。
- en: Docker
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker
- en: Docker used to be the 800-pound gorilla of containers. Kubernetes was originally
    designed to only manage Docker containers. The multi-runtime capability was first
    introduced in Kubernetes 1.3 and the CRI in Kubernetes 1.5\. Until then, Kubernetes
    could only manage Docker containers. Even after the CRI was introduced a Dockershim
    remained in the Kubernetes source code, and it was only removed in Kubernetes
    1.24\. Since then, Docker doesn’t get any special treatment anymore.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 曾是容器领域的“巨无霸”。Kubernetes 最初设计时仅用于管理 Docker 容器。多运行时功能首次在 Kubernetes 1.3
    中引入，CRI 则是在 Kubernetes 1.5 中引入。直到那时，Kubernetes 只能管理 Docker 容器。即使在 CRI 引入后，Kubernetes
    源代码中仍保留了 DockerShim，直到 Kubernetes 1.24 才被移除。从那时起，Docker 不再享有任何特别待遇。
- en: 'I assume you’re very familiar with Docker and what it brings to the table if
    you are reading this book. Docker enjoys tremendous popularity and growth, but
    there is also a lot of criticism towards it. Critics often mention the following
    concerns:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在读这本书，我假设你对 Docker 及其所提供的功能非常熟悉。Docker 在全球范围内享有极高的普及度和增长，但也受到许多批评。批评者通常提到以下几个问题：
- en: Security
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Difficulty setting up multi-container applications (in particular, networking)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置多容器应用（尤其是网络）的难度
- en: Development, monitoring, and logging
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发、监控和日志记录
- en: Limitations of Docker containers running one command
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 容器运行单个命令的限制
- en: Releasing half-baked features too fast
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过快发布未完成的功能
- en: Docker is aware of the criticisms and has addressed some of these concerns.
    In particular, Docker invested in its Docker Swarm product. Docker Swarm is a
    Docker-native orchestration solution that competes with Kubernetes. It is simpler
    to use than Kubernetes, but it’s not as powerful or mature.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 知道这些批评，并已解决其中的一些问题。特别是，Docker 投资于其 Docker Swarm 产品。Docker Swarm 是一个 Docker
    原生的编排解决方案，竞争对手是 Kubernetes。它比 Kubernetes 更易于使用，但功能和成熟度不如 Kubernetes 强大。
- en: 'Starting with Docker 1.11, released in April 2016, Docker has changed the way
    it runs containers. The runtime now uses containerd and runC to run **Open Container
    Initiative** (**OCI**) images in containers:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2016 年 4 月发布的 Docker 1.11 开始，Docker 改变了它运行容器的方式。现在的运行时使用 containerd 和 runC
    来运行 **开放容器倡议**（**OCI**）镜像：
- en: '![Diagram  Description automatically generated](img/B18998_01_03.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![Diagram  Description automatically generated](img/B18998_01_03.png)'
- en: 'Figure 1.3: Docker and OCI'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：Docker 和 OCI
- en: Starting with Docker 1.12, swarm mode is included in the Docker daemon natively,
    which upset some people due to bloat and scope creep. As a result, more people
    turned to other container runtimes.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Docker 1.12 开始，Swarm 模式原生包含在 Docker 守护进程中，这让一些人感到不满，因为它导致了膨胀和范围蔓延。因此，更多的人转向了其他容器运行时。
- en: In September 2021, Docker required a paid subscription to Docker Desktop for
    large organizations. This wasn’t popular, as you might expect, and lots of organizations
    scrambled to find an alternative. Docker Desktop is a client-side distribution
    and UI for Docker and doesn’t impact the container runtime. But it eroded Docker’s
    reputation and goodwill with the community even further.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 2021 年 9 月，Docker 对大型组织要求订阅 Docker Desktop。这一做法并不受欢迎，正如你所料，许多组织纷纷寻找替代方案。Docker
    Desktop 是 Docker 的客户端分发和 UI，它不影响容器运行时。但它进一步损害了 Docker 在社区中的声誉和善意。
- en: containerd
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: containerd
- en: containerd has been a graduated CNCF project since 2019\. It is now a mainstream
    option for Kubernetes containers. All major cloud providers support it and as
    of Kubernetes 1.24, it is the default container runtime.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: containerd 自 2019 年以来已成为 CNCF 毕业项目。现在它是 Kubernetes 容器的主流选择。所有主要云服务商都支持它，并且从
    Kubernetes 1.24 开始，它是默认的容器运行时。
- en: In addition, the Docker container runtime is built on top of containerd as well.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: CRI-O
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CRI-O is a CNCF incubator project. It is designed to provide an integration
    path between Kubernetes and OCI-compliant container runtimes like Docker. CRI-O
    provides the following capabilities:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Support for multiple image formats including the existing Docker image format
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for multiple means to download images including trust and image verification
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container image management (managing image layers, overlay filesystems, etc.)
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container process life cycle management
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring and logging required to satisfy the CRI
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource isolation as required by the CRI
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports runC and Kata containers right now, but any OCI-compliant container
    runtime can be plugged in and integrated with Kubernetes.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Lightweight VMs
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes runs containers from different applications on the same node, sharing
    the same OS. This allows for running a lot of containers in a very efficient manner.
    However, container isolation is a serious security concern and multiple cases
    of privilege escalation occurred, which drove a lot of interest in a different
    approach. Lightweight VMs provide strong VM-level isolation, but are not as heavyweight
    as standard VMs, which allow them to operate as container runtimes on Kubernetes.
    Some prominent projects are:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: AWS Firecracker
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google gVisor
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kata Containers
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singularity
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SmartOS
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we covered the various runtime engines that Kubernetes supports
    as well as the trend toward standardization, convergence, and externalizing the
    runtime support from core Kubernetes.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of ground. You learned about the organization,
    design, and architecture of Kubernetes. Kubernetes is an orchestration platform
    for microservice-based applications running as containers. Kubernetes clusters
    have a control plane and worker nodes. Containers run within pods. Each pod runs
    on a single physical or virtual machine. Kubernetes directly supports many concepts,
    such as services, labels, and persistent storage. You can implement various distributed
    systems design patterns on Kubernetes. Container runtimes just need to implement
    the CRI. Docker, containerd, CRI-O, and more are supported.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 2*, *Creating Kubernetes Clusters*, we will explore the various
    ways to create Kubernetes clusters, discuss when to use different options, and
    build a local multi-node cluster.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Join us on Discord!
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, cloud experts, authors, and like-minded
    professionals.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, provide solutions to other readers, chat with the authors via.
    Ask Me Anything sessions and much more.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Scan the QR code or visit the link to join the community now.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code844810820358034203.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
