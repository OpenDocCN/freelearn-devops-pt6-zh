- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Building Secure Container Images with Build Service
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Build Service 构建安全的容器镜像
- en: In the previous chapter, we discussed how Application Accelerator for VMware
    Tanzu helps organizations with a uniform and efficient way of building greenfield
    applications. This is a great start to building cloud-native applications that
    are based on predefined templates. These templates help developers purely focus
    on the business logic, which brings revenue to the organization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了 VMware Tanzu 的应用加速器如何帮助组织以统一、高效的方式构建绿地应用。这为构建基于预定义模板的云原生应用打下了良好的基础。这些模板帮助开发人员专注于业务逻辑，从而为组织带来收入。
- en: Greenfield and cloud-native applications
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 绿地和云原生应用
- en: 'Greenfield is a term from the construction industry that refers to undeveloped
    land. In the IT world, greenfield describes a software project that is developed
    from scratch rather than built from an existing program. It is often contrasted
    with *brownfield*, which describes software built from an existing program. Reference:
    [https://techterms.com/definition/greenfield](https://techterms.com/definition/greenfield).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 绿地（Greenfield）是建筑行业的术语，指的是未开发的土地。在 IT 领域，绿地指的是从零开始开发的软件项目，而不是基于现有程序构建的软件项目。它通常与*棕地（Brownfield）*相对，后者描述的是从现有程序构建的软件。参考：[https://techterms.com/definition/greenfield](https://techterms.com/definition/greenfield)。
- en: 'Cloud-native applications, as you might surmise, are written to take advantage
    of cloud computing. They are characterized by such technologies as containers,
    service meshes, microservices, immutable infrastructure, and declarative APIs.
    Reference: [https://github.com/cncf/toc/blob/main/DEFINITION.md](https://github.com/cncf/toc/blob/main/DEFINITION.md).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用，如你所料，是为了充分利用云计算而编写的。它们的特点是使用容器、服务网格、微服务、不变基础设施和声明式 API 等技术。参考：[https://github.com/cncf/toc/blob/main/DEFINITION.md](https://github.com/cncf/toc/blob/main/DEFINITION.md)。
- en: However, to get the true benefit out of a cloud-native application on a container
    platform such as Kubernetes, we need to run these applications as containers.
    And, to run them as containers, we need to build container images for those applications.
    While there are various ways we can build such container images for our applications,
    one of the most popular approaches in the industry is to build them using configuration
    files known as Dockerfiles. A **Dockerfile** contains the definition, requirements,
    and attributes of the container image that should be built for the application.
    Though using Dockerfile is one of the most popular approaches to building container
    images, it is not always the most optimal one.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要从容器平台（如 Kubernetes）中真正受益于云原生应用，我们需要将这些应用作为容器来运行。为了以容器形式运行它们，我们需要为这些应用构建容器镜像。虽然有多种方式可以为我们的应用构建容器镜像，但业界最流行的方法之一是使用称为
    Dockerfile 的配置文件来构建。**Dockerfile** 包含了应用程序所需构建的容器镜像的定义、要求和属性。尽管使用 Dockerfile 是构建容器镜像的流行方法之一，但它并不总是最优的选择。
- en: 'In this chapter, we will take a deep dive into this concept and cover the following
    topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入探讨这一概念，并涵盖以下主题：
- en: Why Tanzu Build Service?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择 Tanzu Build Service？
- en: Unboxing Tanzu Build Service
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁 Tanzu Build Service
- en: Getting started with Tanzu Build Service
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Tanzu Build Service
- en: Common day-2 activities for Tanzu Build Service
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tanzu Build Service 的常见日常活动
- en: So, let’s get started.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Some technical requirements need to be fulfilled before we start installing
    **Tanzu Build Service** (**TBS**). These requirements will be covered later in
    this chapter at the beginning of the *Getting started with Tanzu Build Service*
    section. However, you may not need them to understand the benefits TBS brings
    to the table. Let’s start looking into it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始安装**Tanzu Build Service**（**TBS**）之前，需要满足一些技术要求。这些要求将在本章*开始使用 Tanzu Build
    Service*部分的开头进行详细介绍。不过，你可能不需要它们来理解 TBS 带来的好处。让我们开始了解它吧。
- en: Why Tanzu Build Service?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 Tanzu Build Service？
- en: There are various business, technical, and security challenges in building container
    images for applications. This becomes even more complex when we do it at scale
    in a large enterprise. Let’s understand what those challenges are and how TBS
    addresses them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在为应用程序构建容器镜像时，存在各种业务、技术和安全挑战。在大规模企业中进行此操作时，挑战会变得更加复杂。让我们了解这些挑战是什么，以及 TBS 如何解决这些问题。
- en: Increasing developer productivity
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高开发者生产力
- en: As discussed, one of the most popular approaches to building container images
    today is using Dockerfiles. And, in most cases, the application teams are responsible
    for building and maintaining such Dockerfiles for their applications. These Dockerfiles
    contain details such as the base container operating system and its version, application
    bundles such as JAR files for a Java application, environment variables, and useful
    libraries and their versions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，构建容器镜像的最流行方法之一是使用Dockerfile。在大多数情况下，应用程序团队负责构建和维护这些Dockerfile。这些Dockerfile包含了如基础容器操作系统及其版本、应用程序包（如Java应用程序的JAR文件）、环境变量以及有用的库及其版本等详细信息。
- en: JAR files
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JAR文件
- en: A **Java ARchive** (**JAR**) file is a package of an application containing
    compiled source code files, configuration files, and external libraries required
    by the application. A JAR file can either be a supporting library or an application
    package that can be run in a **Java Runtime** **Environment** (**JRE**).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java ARchive**（**JAR**）文件是包含应用程序的一个打包文件，包含已编译的源代码文件、配置文件和应用程序所需的外部库。JAR文件可以是一个支持库，也可以是一个可以在**Java运行时环境**（**JRE**）中运行的应用程序包。'
- en: Developers know their applications more than anybody. So, it makes sense that
    they define what goes in their applications’ Dockerfiles. But at the same time,
    building and managing Dockerfiles are additional overheads for developers. Developers
    should spend all their time building more business-impacting functionalities in
    their applications. You might argue that building and changing such Dockerfiles
    is not a frequent task. Also, you may build some automation around building containers
    to reduce the amount of effort. However, such in-house automation brings other
    maintenance challenges. It would not eliminate the time required from the application
    teams. It’s not just about the time the developers need to spend to create or
    update the Dockerfiles. They also need the time required to research and decide
    on the content of it. And finally, these Dockerfiles have to be kept up to date
    to reflect the latest security patches of the libraries referenced in them. That
    ensures the best possible security posture for the running containers. Such endless
    ongoing maintenance consumes a lot of productive time of developers for unproductive
    activities.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员对自己的应用程序了解最深。因此，允许他们定义应用程序的Dockerfile内容是有道理的。但与此同时，构建和管理Dockerfile是开发人员的额外负担。开发人员应该将所有时间都用在为应用程序构建更多有商业影响的功能上。你可能会争辩说，构建和更改这些Dockerfile并不是一个频繁的任务。此外，你还可以围绕构建容器创建一些自动化流程来减少工作量。然而，这种内部自动化会带来其他维护上的挑战。它并不能消除应用程序团队所需要的时间。这不仅仅是开发人员花时间创建或更新Dockerfile的问题。他们还需要花时间去研究和决定其中的内容。最后，这些Dockerfile必须保持最新，以反映其中引用的库的最新安全补丁。这确保了运行中的容器拥有最佳的安全态势。这种持续不断的维护消耗了大量开发人员的生产时间，进行的却是无生产性的活动。
- en: Layers in container images
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像中的层
- en: A final container image of an application could be a combination of multiple
    smaller images that are stacked as layers on top of each other to provide reusability,
    separation, and ease of usage.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序的最终容器镜像可能是多个较小镜像的组合，这些镜像像层一样堆叠在一起，提供可重用性、分离性和易用性。
- en: To address these challenges, Pivotal Software Inc. (which was acquired by VMware
    Inc. in 2020) and Heroku collaborated. They incepted an open source project called
    **buildpacks.io** under the **Cloud Native Computing Foundation** (**CNCF**).
    We will discuss this project later in this chapter in detail. TBS is commercially-supported
    packaging containing buildpacks.io and a few other open source tools.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些挑战，Pivotal Software Inc.（于2020年被VMware Inc.收购）与Heroku合作，启动了一个名为**buildpacks.io**的开源项目，该项目隶属于**Cloud
    Native Computing Foundation**（**CNCF**）。我们将在本章稍后详细讨论这个项目。TBS是一个商业支持的打包方案，包含buildpacks.io以及其他一些开源工具。
- en: TBS addresses this challenge by providing a complete automation engine to build
    container images when you supply application code or built artifacts. As an output,
    TBS generates an OCI-compliant container image for the application. This image
    can be deployed on Kubernetes or any other OCI-compliant container orchestration
    platform. With TBS, developers are off the hook to build and maintain their container
    images. The reduced amount of responsibilities helps developers focus on what
    is more important for the business.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TBS通过提供一个完整的自动化引擎来应对这一挑战，当您提供应用程序代码或构建的工件时，它可以构建容器镜像。作为输出，TBS会为应用程序生成一个符合OCI标准的容器镜像。这个镜像可以部署到Kubernetes或任何其他符合OCI标准的容器编排平台。通过TBS，开发人员无需再负责构建和维护容器镜像，减少的责任帮助开发人员将注意力集中在对业务更为重要的部分。
- en: What is OCI?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是OCI？
- en: '**Open Container Initiative** (**OCI**) is a standard set by The Linux Foundation
    describing the characteristics of a container image that can be implemented by
    various container image-building tools and understood by different container scheduling
    platforms such as Kubernetes. All major container platforms, including Kubernetes,
    support OCI-compliant container images.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放容器倡议**（**OCI**）是由Linux基金会设立的标准，描述了容器镜像的特性，这些镜像可以由各种容器镜像构建工具实现，并被像Kubernetes这样的不同容器调度平台理解。所有主要的容器平台，包括Kubernetes，都支持符合OCI规范的容器镜像。'
- en: TBS supports different languages including Java, .Net, Python, Go, NodeJS, and
    many more.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: TBS支持包括Java、.Net、Python、Go、NodeJS等多种语言。
- en: Reduction of bespoke automation
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少定制自动化
- en: It is a commonly observed practice that organizations create **continuous integration**
    (**CI**) pipelines to build their applications’ container images. These pipelines
    are often developed using tools such as Jenkins and written mostly using languages
    such as Python or Shell script. Organizations may need to invest in resources
    to first develop such custom automation and then to maintain them ongoingly. Furthermore,
    the lack of good documentation around such custom automation makes such maintenance
    a nightmare. Hence, such people-dependent automation becomes a pain to maintain
    when their parents leave the organization. Additionally, the organizations could
    get better business outcomes if these people could rather be used for a better
    business-value-oriented assignment instead of such below-value-line engineering
    efforts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 组织通常会创建**持续集成**（**CI**）流水线来构建应用程序的容器镜像。这些流水线通常使用Jenkins等工具开发，并且大多数使用Python或Shell脚本等语言编写。组织可能需要先投入资源开发此类定制自动化流程，然后还需要持续维护。而且，缺乏关于这些定制自动化流程的良好文档，使得维护变得非常困难。因此，这种依赖人员的自动化在相关人员离开组织后，维护起来就成了一个大问题。此外，如果这些人员能够投入到更具业务价值的任务中，组织可能会获得更好的业务成果，而不是仅仅参与这种低价值的工程工作。
- en: TBS also helps address this challenge. It automates the container image-building
    process to a significant level. Although this will not replace the entire CI pipeline,
    it will reduce its complexity by covering the various steps required to build
    container images with full automation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: TBS也有助于解决这一挑战。它在容器镜像构建过程中实现了高度自动化。虽然这不会替代整个CI流水线，但它通过覆盖构建容器镜像所需的各个步骤并实现完全自动化，能够显著简化这一流程。
- en: Standardization of container build process
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器构建过程的标准化
- en: It is often seen that there are many departmental silos in enterprises with
    large development shops. Such silos have tools and practices to follow. This could
    be a huge waste of crucial resources for the organizations in terms of duplication
    at various levels. Such duplication could be people’s time spent for similar outcomes,
    the license cost of tools, and the infrastructure used by the automation. This
    could lead to a whole new issue of lack of standardization. Such non-standard
    practices result in decreased transparency, governance, and security posture.
    When it comes to building container images, such an absence of standardization
    could be proven to be a very costly mistake for security risk exposures. This
    is caused by using unapproved libraries or not patching them quickly. When different
    teams have different ways of building container images, they could follow different
    practices. They might use different container operating systems, open source tools,
    third-party libraries, and their versions. It would be very difficult to apply
    an enterprise-wide standard. Such enforced standards should not affect different
    teams’ productivity and freedom of choice.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型开发团队的企业中，往往可以看到许多部门之间的孤岛（silos）。这些孤岛有各自的工具和流程。这可能会导致组织在多个层面上浪费宝贵的资源，例如重复劳动。这种重复可能体现在人员为相似的结果所花费的时间、工具的许可证费用以及自动化使用的基础设施。这可能会引发一个全新的问题——缺乏标准化。非标准化的做法会导致透明度、治理和安全态势的下降。在构建容器镜像时，缺乏标准化可能会证明是一个非常昂贵的错误，导致安全风险暴露。这是由于使用未经批准的库，或者没有及时修补这些库。当不同的团队有不同的容器镜像构建方法时，他们可能会遵循不同的做法。他们可能使用不同的容器操作系统、开源工具、第三方库及其版本。这使得应用全公司范围的标准化变得非常困难。强制执行的标准不应影响不同团队的生产力和选择自由。
- en: TBS solves this problem in two ways. First, it includes a centralized software
    library provided by VMware in the form of buildpacks and Stacks. Here, **buildpacks**
    include all the required libraries for the application to work in the container,
    including application runtimes such as **Java Runtime Environment** (**JRE**)
    and middleware such as Tomcat Server. On the other side, **Stacks** include different
    flavors of container operating systems. Second, TBS provides a standardized container
    image-building automation engine. Hence, when an organization uses TBS to build
    containers, it automatically implements standardization in the container-building
    process. This standardization comes in the form of the required automation and
    the application supporting content in the images.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: TBS通过两种方式解决了这个问题。首先，它包括由VMware提供的集中式软件库，形式为构建包（buildpacks）和栈（Stacks）。在这里，**构建包（buildpacks）**包含了应用在容器中运行所需的所有库，包括应用程序运行时环境，如**Java运行环境（JRE）**以及中间件，如Tomcat服务器。另一方面，**栈（Stacks）**包括不同版本的容器操作系统。其次，TBS提供了一个标准化的容器镜像构建自动化引擎。因此，当组织使用TBS构建容器时，它会自动在容器构建过程中实现标准化。这种标准化体现在自动化要求和镜像中支持的应用程序内容上。
- en: TBS does not only help to standardize the container build process across the
    company but also improves the overall security posture around the same, as explained
    in the following section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: TBS不仅帮助公司标准化容器构建过程，还提升了整体的安全态势，正如以下部分所述。
- en: Stronger security posture
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更强的安全态势
- en: Security exposure is a major concern for the most established organizations
    in their journey to cloud transformation. Most cloud-native applications are deployed
    as containers in either public or private cloud platforms for several benefits.
    Containers are nothing but tiny virtual machines where the applications run. It
    is critical that such containers are built with secure ingredients that do not
    contain security vulnerabilities. But today’s secure library version could be
    found vulnerable tomorrow since it is very common to see new security vulnerabilities
    getting announced often for all operating systems and libraries that could be
    used in those container images. The corresponding organizations behind such operating
    systems and libraries would release newer versions to address those **Common Vulnerabilities
    and Exposures** (**CVE**). However, it is on the user organizations to take the
    newer versions of the software and use them to rebuild the impacted container
    images. Such container image rebuild exercises may introduce two big pain points.
    The first is when there are multiple development teams managing hundreds of containerized
    applications. In that case, it is very difficult to find the impacted applications.
    Such an identification and remediation process may take weeks, keeping those applications
    vulnerable to attacks. It would be very difficult to push all the application
    teams at the same time to rebuild their applications’ container images using the
    newer version of the software. The patching gets delayed as the application teams
    would have their product backlogs and priorities to manage. And history has proven
    time and again that most major software-related security breaches were driven
    by unpatched software components running for a long time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 安全暴露是大多数成熟组织在云转型过程中面临的主要问题。大多数云原生应用程序都作为容器部署在公共或私有云平台上，以获得多个好处。容器其实就是运行应用程序的小型虚拟机。至关重要的是，这些容器必须使用安全的组件来构建，确保不含有安全漏洞。然而，今天的安全库版本可能明天就会被发现存在漏洞，因为常常会看到新安全漏洞的发布，这些漏洞可能影响到所有操作系统和库，而这些操作系统和库可能会被用于容器镜像中。相应的组织会发布新版本，以解决这些**常见漏洞和暴露**（**CVE**）。然而，用户组织需要自行获取这些软件的新版本，并用它们来重新构建受影响的容器镜像。这类容器镜像重建工作可能会带来两个大痛点。第一个问题是，当有多个开发团队管理着数百个容器化应用程序时，寻找受影响的应用程序变得非常困难。这样的识别和修复过程可能需要数周时间，使得这些应用程序在此期间容易受到攻击。与此同时，要让所有应用团队在同一时间使用新版本软件重建其应用程序的容器镜像也是非常困难的。由于应用团队需要处理他们的产品待办事项和优先级，修补工作通常会延迟。而历史一再证明，大多数重大软件相关的安全漏洞都是由于长时间没有修补的软件组件导致的。
- en: TBS can greatly speed up the CVE patching of the impacted container images with
    its centralized resource library and container image rebuild automation using
    that library. As a new CVE patch is announced for the impacted component in the
    library, VMware releases a new version of the repository component (either a buildpack
    or a stack) containing the fix for the vulnerability. TBS identifies impacted
    application container images using an internal map of container images and their
    linked dependencies. So, when VMware releases a new component version in the centralized
    repository to fix any CVE, TBS immediately triggers the patching of the impacted
    application images using the patched version. Such an automatic rebuilding of
    images for hundreds of applications may be complete in a few hours rather than
    needing weeks in the absence of TBS. This could be one of the most important reasons
    to consider using a tool such as TBS. Such mappings of applications, their container
    images, and the associated software components used in them provide the required
    transparency and auditability to the security team. Using TBS, we can quickly
    generate a **Bill of Material** (**BOM**) for any application managed by TBS.
    A BOM is a detailed report listing all the components and their versions used
    in the respective container images. It greatly simplifies security audits of containerized
    environments.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: TBS 可以通过其集中资源库和基于该资源库的容器镜像重建自动化，极大地加速受影响容器镜像的CVE修补。当库中的受影响组件发布新的CVE补丁时，VMware
    会发布包含该漏洞修复的仓库组件的新版本（可以是构建包或栈）。TBS 使用内部容器镜像及其关联依赖项的映射来识别受影响的应用程序容器镜像。因此，当 VMware
    在集中仓库中发布新组件版本来修复任何CVE时，TBS 会立即触发使用已修补版本的受影响应用镜像的修补。这样的自动化镜像重建可以在几小时内完成数百个应用的修补，而无需
    TBS 的话可能需要数周时间。这可能是考虑使用 TBS 等工具的最重要原因之一。应用程序、其容器镜像和其中使用的相关软件组件的这种映射为安全团队提供了所需的透明度和可审计性。使用
    TBS，我们可以快速为任何由 TBS 管理的应用生成**物料清单**（**BOM**）。BOM 是一份详细报告，列出在相应容器镜像中使用的所有组件及其版本。它极大地简化了容器化环境的安全审计。
- en: Optimized network bandwidth and storage utilization
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化的网络带宽和存储利用率
- en: 'As described previously, an OCI-compliant container image is a collection of
    other smaller images containing different components required for the final resultant
    container image. These layers are made up of application code, configurations,
    third-party libraries, and operating systems. Container image repositories such
    as Docker Hub and Harbor store such layers separately. They also maintain maps
    of which image layer depends on which other image layers. So, when you pull a
    specific container image from the container image registry, the registry pushes
    all dependent container image layers as a result. Due to this, when an application
    goes through any change, only the corresponding impacted layer will get transferred
    over the network into the container registry. All other non-impacted image layers
    will not move over the network. This makes the image push and pull operations
    a lot more efficient. It also helps to reduce the storage requirements for the
    container image registry because of the reuse of the unchanged layers. However,
    to get the full benefit of these layers, you should follow some discipline in
    the image-building process. If the authors of Dockerfiles do not take enough care,
    they end up with fewer image layers than what is optimally possible. The following
    figures show the anatomy of the same application’s container images. They both
    have a different number of layers. They are built with two different Dockerfile
    approaches. These snapshots were taken using an open source tool named **Dive**
    ([https://github.com/wagoodman/dive](https://github.com/wagoodman/dive)), which
    gives a detailed view of layers and their content for a container image:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，符合 OCI 标准的容器镜像是由多个较小的镜像集合构成，这些小镜像包含了构成最终容器镜像所需的不同组件。这些层包括应用代码、配置、第三方库和操作系统。像
    Docker Hub 和 Harbor 这样的容器镜像仓库会将这些层分开存储，并维护哪些镜像层依赖于其他镜像层的映射关系。因此，当你从容器镜像仓库拉取特定的容器镜像时，仓库会将所有依赖的容器镜像层一起推送过来。由于这个原因，当应用发生变化时，只有受影响的层会通过网络传输到容器仓库，所有其他未受影响的镜像层将不会通过网络传输。这使得镜像的推送和拉取操作更加高效，同时也有助于减少容器镜像仓库的存储需求，因为未改变的层会被重复使用。然而，为了充分利用这些层，你应该在镜像构建过程中遵循一定的规范。如果
    Dockerfile 的作者不够谨慎，可能会导致镜像层的数量比最优情况要少。以下的图示展示了同一应用的容器镜像结构，它们的层数不同，且是通过两种不同的 Dockerfile
    构建的。这些快照是使用名为 **Dive** 的开源工具拍摄的 ([https://github.com/wagoodman/dive](https://github.com/wagoodman/dive))，该工具可以详细显示容器镜像的各个层及其内容：
- en: "![Figure 3.1 – A demo Java application’s container image built using \uFEFF\
    four layers](img/B18145_03_01.jpg)"
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 使用四层构建的演示 Java 应用的容器镜像](img/B18145_03_01.jpg)'
- en: Figure 3.1 – A demo Java application’s container image built using four layers
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 使用四层构建的演示 Java 应用的容器镜像
- en: 'As you can see, *Figure 3**.1* has only four layers, whereas *Figure 3**.2*
    has eight layers, even though the total resultant image size is almost the same.
    There are various ways to build a container image, which may result in different
    outputs for the same application code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，*图 3.1* 仅有四层，而 *图 3.2* 则有八层，尽管最终镜像的总大小几乎相同。构建容器镜像有多种方法，这些方法可能会导致相同应用代码产生不同的结果：
- en: "![Figure 3.2 – The same demo Java application’s container image but built using\
    \ \uFEFFeight layers](img/B18145_03_02.jpg)"
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 使用八层构建的相同演示 Java 应用的容器镜像](img/B18145_03_02.jpg)'
- en: Figure 3.2 – The same demo Java application’s container image but built using
    eight layers
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 使用八层构建的相同演示 Java 应用的容器镜像
- en: When the developers do not have the required awareness or there are no enterprise-level
    guidelines on how to build application container images, every team might end
    up with their own standards and practices. With such a lack of knowledge and controls
    in place, large organizations may end up with several suboptimal application container
    images, which may lead to a waste of network bandwidth and storage for every container
    image push and pull operation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员没有足够的意识，或者没有企业级的指南来指导如何构建应用容器镜像时，每个团队可能会最终形成自己的标准和实践。由于缺乏知识和控制，大型组织可能会拥有多个不理想的应用容器镜像，这可能导致每次容器镜像推送和拉取操作时，浪费网络带宽和存储空间。
- en: 'On the other side, TBS uses a highly acclaimed **Cloud Native Computing Foundation**
    (**CNCF**) ([https://cncf.io](https://cncf.io)) certified project named **Cloud
    Native Buildpacks** (**CNB**) ([https://buildpack.io](https://buildpack.io)) as
    a tool under the hood, which provides a way to build container images with several
    smaller layers when the application container images are built using this tool.
    It provides an organization-level standardized approach to building container
    images that are also very resource efficient, along with having other benefits,
    as discussed previously. Here is a high-level representation depicting how TBS
    performs this operation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，TBS 使用一个广受好评的 **Cloud Native Computing Foundation** (**CNCF**) （[https://cncf.io](https://cncf.io)）认证项目，名为
    **Cloud Native Buildpacks** (**CNB**) （[https://buildpack.io](https://buildpack.io)），作为其底层工具，当使用此工具构建应用容器镜像时，它通过多个较小的层来构建容器镜像。它提供了一种组织级标准化方法来构建容器镜像，同时具有非常高的资源效率，并带有前述的其他好处。以下是一个高层次表示，展示
    TBS 如何执行这一操作：
- en: '![Figure 3.3 – High-level representation of how TBS builds container images
    with layers](img/B18145_03_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – TBS 如何通过层级构建容器镜像的高层次表示](img/B18145_03_03.jpg)'
- en: Figure 3.3 – High-level representation of how TBS builds container images with
    layers
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – TBS 如何通过层级构建容器镜像的高层次表示
- en: The preceding figure shows how TBS takes some application code, performs various
    operations internally, and creates a final OCI-compliant application container
    image that has different smaller layers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示展示了 TBS 如何获取一些应用代码，执行内部各种操作，并创建一个最终符合 OCI 标准的应用容器镜像，该镜像包含多个较小的层。
- en: Overall, TBS is useful to enhance developer productivity, reduce the learning
    curve, reduce operational toil, and increase security posture, along with several
    other benefits listed here for building secure container images. With all that,
    it just helps you accelerate your cloud-native application journey. After learning
    about the different benefits of using a tool such as TBS, let’s unbox it to check
    its anatomy. We will take a deep dive into all the different components that are
    bundled together as TBS.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，TBS 有助于提升开发者生产力，减少学习曲线，降低运维负担，并增强安全性，同时提供其他若干构建安全容器镜像的好处。所有这些都将帮助你加速云原生应用的旅程。在了解了使用
    TBS 这类工具的不同好处之后，接下来让我们深入解锁它，了解它的架构。我们将深入探讨 TBS 所包含的所有不同组件。
- en: Unboxing Tanzu Build Service
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解锁 Tanzu Build Service
- en: 'As described previously, TBS is built on top of two main open source projects:
    CNB and kpack. The following figure depicts the whole packaging of TBS:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，TBS 建立在两个主要开源项目之上：CNB 和 kpack。下图展示了 TBS 的整体包装结构：
- en: '![Figure 3.4 – Building blocks of Tanzu Build Service](img/B18145_03_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – Tanzu Build Service 的构建模块](img/B18145_03_04.jpg)'
- en: Figure 3.4 – Building blocks of Tanzu Build Service
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Tanzu Build Service 的构建模块
- en: As shown in the preceding figure, kpack includes engine and CLIs, whereas CNB
    includes things such as Builder, buildpacks and their groups, the stack, build
    and run images, and the life cycle process. Additionally, there are some VMware-supplied
    components for additional functionalities that are bundled in TBS. Let’s understand
    them in detail.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，kpack 包含引擎和 CLI，而 CNB 包含诸如 Builder、buildpacks 及其组、堆栈、构建和运行镜像以及生命周期过程等内容。此外，还有一些
    VMware 提供的组件，提供额外的功能，这些组件已打包在 TBS 中。让我们详细了解这些组件。
- en: Cloud-native buildpacks
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云原生构建包
- en: 'The concept of CNB was derived from the concept of buildpacks in Cloud Foundry,
    which is another container orchestration platform for cloud-native applications.
    The buildpacks in Cloud Foundry have been proven a battle-tested tool for over
    a decade. Buildpacks in Cloud Foundry are used to scan application source code,
    determine application requirements based on the technology and language used,
    club all required dependencies with application packages, and create an offline
    container called a **droplet**. These droplets are large binary objects that contain
    everything required by the corresponding applications to run as containers on
    the Cloud Foundry platform. Though droplets have a solid track record, they have
    some limitations, listed as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CNB 的概念来源于 Cloud Foundry 中构建包的概念，Cloud Foundry 是另一个用于云原生应用的容器编排平台。Cloud Foundry
    中的构建包已经证明是经过多年考验的工具，已有十多年历史。Cloud Foundry 中的构建包用于扫描应用源代码，根据所使用的技术和语言确定应用需求，将所有所需的依赖项与应用程序包一起打包，并创建一个离线容器，称为**droplet**。这些
    droplet 是包含所有运行所需内容的大型二进制对象，用于在 Cloud Foundry 平台上作为容器运行对应的应用程序。尽管 droplet 拥有稳定的记录，但它们也存在一些局限性，具体如下：
- en: Cloud Foundry buildpacks generate droplets that are very large as they contain
    everything required by the application. They do not have a layer concept like
    modern OCI-compliant container images do. Hence, every small change in the application
    or its dependency creates a new version of the heavy droplet again. Such droplets
    require more storage as they do not contain just the delta but a full-blown application
    package. Because of this, deploying containers using droplets in Cloud Foundry
    is a relatively slower process than deploying containers using an OCI image for
    a newer version of the application on an OCI-compatible platform such as Kubernetes.
    This slowness of container scheduling impacts application deployment times while
    scaling or redeploying the applications.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloud Foundry 的构建包生成的 droplet 非常大，因为它们包含应用程序所需的所有内容。它们不像现代的 OCI 合规容器镜像那样有层的概念。因此，应用程序或其依赖项的每一个小变化都会重新创建一个新的重型
    droplet。这些 droplet 需要更多存储空间，因为它们不仅仅包含差异，还包含完整的应用程序包。由于这个原因，使用 droplet 在 Cloud
    Foundry 中部署容器的过程比在如 Kubernetes 等 OCI 兼容平台上使用 OCI 镜像部署更新版本的应用程序要慢。这种容器调度的慢速会影响应用程序在扩展或重新部署时的部署时间。
- en: The Buildpack project was designed to work only on Cloud Foundry. So, there
    was no way to use them on platforms such as Kubernetes that support only OCI-compliant
    container images.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buildpack 项目仅设计用于 Cloud Foundry，因此无法在只支持 OCI 合规容器镜像的 Kubernetes 等平台上使用。
- en: The extendibility or customization of Cloud Foundry buildpacks is very limited.
    Rather than adding newer changes as layers or plugins, they must be modified by
    opening them completely.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloud Foundry 的构建包在扩展性或定制化方面非常有限。它们不能像层或插件一样添加新的更改，而必须完全打开并修改。
- en: Cloud Foundry buildpacks are slow in building new droplets as they do not optimally
    use cached resources.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloud Foundry 的构建包在构建新 droplet 时较慢，因为它们未能最优化使用缓存资源。
- en: Keeping all these limitations in mind and using the power of the buildpack concept
    in more broader and popular platforms such as Kubernetes, two software companies,
    Heroku and Pivotal (acquired by VMware in 2019), joined hands and announced that
    they were to collaborate on a new open source project called CNB, which retains
    all the goodness of the original Buildpack project but addresses its weaknesses.
    With this background, let’s discuss the anatomy of CNB in detail.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于所有这些局限性，并且利用构建包概念在更广泛和流行的平台（如 Kubernetes）中的潜力，两个软件公司 Heroku 和 Pivotal（2019
    年被 VMware 收购）携手合作，宣布共同开发一个新的开源项目 CNB，该项目保留了原始 Buildpack 项目的优点，同时解决了它的弱点。基于这个背景，我们来详细讨论
    CNB 的结构。
- en: The following are some of the key concepts and terminologies of CNB that are
    important constructs of TBS.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 CNB 中一些重要的概念和术语，它们是 TBS 的关键构建模块。
- en: Build image
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建镜像
- en: This is a base container operating system layer that is used to create a builder’s
    container image. A build container is short-lived. It executes the life cycle
    process to build the application’s container image and gets terminated.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基础容器操作系统层，用于创建构建者的容器镜像。构建容器的生命周期较短。它执行构建应用容器镜像的生命周期过程，完成后会被终止。
- en: Run image
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行镜像
- en: This is a base container operating system layer that is used to create an application’s
    container image. This is the main outcome of TBS. All the application-specific
    container images built by TBS use this image as the base container operating system
    layer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基础容器操作系统层，用于创建应用程序的容器镜像。这是 TBS 的主要成果。所有由 TBS 构建的特定应用程序容器镜像都使用此镜像作为基础容器操作系统层。
- en: Stack
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆栈
- en: This is a configuration entity that contains details of the build image and
    runs image flavors to be used in the container image build process. As a part
    of the package, TBS provides four different flavors of stacks that contain different
    flavors of build-and-run operating systems. These operating systems layers could
    be either thin or thick, depending on the requirements of the applications that
    need to use them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个配置实体，包含有关构建镜像的详细信息，并运行将在容器镜像构建过程中使用的镜像风味。作为包的一部分，TBS 提供了四种不同的堆栈风味，包含不同风味的构建和运行操作系统。这些操作系统层可以是薄层或厚层，具体取决于需要使用它们的应用程序的要求。
- en: Buildpack
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建包
- en: This is a collection of executables that inspect your application code and determines
    whether the buildpack would apply to the application and hence should be a part
    of the resultant application’s container image. For example, there is a buildpack
    for Java applications, which detects the presence of Java-specific files in the
    application code or artifact, and then takes a call if the application needs required
    support to run as a Java application. In the TBS architecture, such buildpacks
    are stored in a container registry as container images.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可执行文件集合，检查你的应用程序代码并确定是否应用构建包（buildpack）到该应用程序，并因此应该成为结果应用程序容器镜像的一部分。例如，Java
    应用程序有一个构建包，它检测应用程序代码或工件中是否存在 Java 特定文件，然后决定应用程序是否需要支持以作为 Java 应用程序运行。在 TBS 架构中，这些构建包存储在容器注册表中，作为容器镜像。
- en: Buildpack group
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建包组
- en: This is a collection of buildpacks that are typically used together to build
    a container image of a specific type of application. The buildpacks that are members
    of a buildpack group could either be mandatory or optional, depending on their
    use case and the requirement of the application. For example, buildpacks for **Java
    Runtime Environment** (**JRE**), Maven, Gradle, Tomcat Server, and Jetty Server
    may all fall in the same group as they are all Java application-related dependencies.
    However, the buildpack for JRE would be a compulsory one for a Java application,
    but all others listed before would fall into the optional category as the application
    might or might not need them. There are various such buildpack groups for different
    types of applications, such as Python, .Net, NodeJS, and more.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个构建包集合，通常一起用于构建特定类型应用程序的容器镜像。构建包组中的构建包可以是强制性的，也可以是可选的，具体取决于其使用场景和应用程序的需求。例如，**Java
    运行时环境**（**JRE**）、Maven、Gradle、Tomcat 服务器和 Jetty 服务器的构建包可能都属于同一组，因为它们都是与 Java 应用程序相关的依赖项。然而，JRE
    的构建包对于 Java 应用程序来说是必须的，而前述的其他构建包则属于可选类别，因为应用程序可能需要也可能不需要它们。针对不同类型应用程序，还有其他多种构建包组，如
    Python、.Net、NodeJS 等。
- en: Life cycle
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生命周期
- en: 'This determines the application of buildpacks and orchestrates their execution.
    The life cycle process has various components that execute its stages. At the
    end of all the stages, we get the final OCI-compliant container image of an application.
    Let’s review these life cycle components:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这决定了构建包的应用，并协调它们的执行。生命周期过程包含多个组件，它们执行不同阶段。在所有阶段结束后，我们将得到一个符合 OCI 标准的最终容器镜像。让我们回顾一下这些生命周期组件：
- en: '**Analyzer**: This retrieves and examines all required files that would be
    required during the image build process and used by the buildpacks. It also checks
    whether all the required images for the build are accessible in the container
    registry used by TBS. With such quick checking of dependencies, the build process
    fails fast if something is missing rather than realizing that later in the build
    process.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析器**：该工具检索并检查在镜像构建过程中需要的所有文件，并由构建包使用。它还会检查构建所需的所有镜像是否在 TBS 使用的容器注册表中可以访问。通过快速检查依赖关系，如果某些内容丢失，构建过程会迅速失败，而不是在构建过程后期才发现问题。'
- en: '**Detector**: This checks which buildpack group is applicable for the application
    under the build process. It also gets a list of all available buildpack groups
    in a specific order. Then, it checks the applicability of each of these groups
    one by one until the first group passes the required criteria. The detector then
    creates a plan of execution to perform the container image build process as a
    resulting artifact.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检测器**：它检查在构建过程中，哪个构建包组适用于该应用程序。它还会按特定顺序获取所有可用构建包组的列表。然后，它依次检查每个组的适用性，直到第一个组满足所需的标准。检测器随后创建一个执行计划，以执行容器镜像构建过程，作为最终的产物。'
- en: '**Restorer**: This restores all the required dependency image layers based
    on the selected buildpack group from the cache put in by previous container build
    processes using the same image layers. This phase reduces the build time and the
    network traffic to transfer frequently used images.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恢复器**：它根据从之前的容器构建过程缓存中选择的构建包组，恢复所有所需的依赖镜像层，这些缓存是由相同的镜像层放入的。此阶段减少了构建时间和网络流量，以便传输频繁使用的镜像。'
- en: '**App Builder**: This transforms the application source code into a runnable
    artifact that can be packaged for execution inside a container. For example, this
    stage converts a Java application source code into a JAR file with compiled class
    files as an executable artifact. The application of this stage could be optional,
    depending on the supplied artifact of the application or even based on the technology
    requirements. For example, if the build process gets an already prepared JAR file
    for a Java application instead of the source code, then there is no need to prepare
    a build for the application and this stage may be skipped.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序构建器**：它将应用程序源代码转化为可执行的工件，以便可以在容器内打包执行。例如，这一阶段将 Java 应用程序的源代码转换为包含已编译类文件的
    JAR 文件，作为可执行的工件。该阶段的应用可能是可选的，具体取决于应用程序提供的工件，甚至可能根据技术需求来决定。例如，如果构建过程中已经提供了一个准备好的
    Java 应用程序 JAR 文件，而不是源代码，那么就不需要为该应用程序准备构建，这一阶段可能会被跳过。'
- en: '**Exporter**: This creates the final OCI-compliant container image file. It
    also prepares a report containing the BOM for the components and their versions
    used in the container image. Finally, it pushes the container image into the target
    registry.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导出器**：它创建最终的符合 OCI 标准的容器镜像文件。它还准备一份报告，包含容器镜像中所使用的组件及其版本的 BOM（物料清单）。最后，它将容器镜像推送到目标注册表。'
- en: Builder
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建器
- en: To build a container image of an application, TBS needs to deploy a temporary
    container on Kubernetes that executes the life cycle components, as previously
    described, to create the resultant container image. A builder is a container image
    that deploys this container, which contains the executables for the life cycle
    processes, along with a list of buildpack groups and a build image.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个应用程序的容器镜像，TBS 需要在 Kubernetes 上部署一个临时容器，执行之前描述的生命周期组件，以创建最终的容器镜像。构建器是一个容器镜像，它部署这个容器，其中包含生命周期进程的可执行文件，以及构建包组和构建镜像的列表。
- en: kpack
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kpack
- en: kpack ([https://github.com/pivotal/kpack](https://github.com/pivotal/kpack))
    is an open source project initiated by Pivotal and is now actively being maintained
    by VMware. kpack provides a way to use CNB on the Kubernetes platform. kpack uses
    some Kubernetes **Custom Resource Definitions** (**CRDs**) to deploy itself as
    a tool running on top of Kubernetes. Hence, kpack is a tool that runs on Kubernetes
    and uses CNB to build OCI-compliant container images.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: kpack ([https://github.com/pivotal/kpack](https://github.com/pivotal/kpack))
    是由 Pivotal 发起的开源项目，现在由 VMware 积极维护。kpack 提供了一种在 Kubernetes 平台上使用 CNB 的方式。kpack
    使用一些 Kubernetes **自定义资源定义**（**CRDs**）将自己部署为在 Kubernetes 上运行的工具。因此，kpack 是一个在 Kubernetes
    上运行的工具，利用 CNB 构建符合 OCI 标准的容器镜像。
- en: Custom Resource Definitions (CRDs)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源定义（CRDs）
- en: 'Kubernetes has several out-of-the-box APIs that are referred to as resources.
    Some examples of such resources are Pod, Node, Deployment, Service, ReplicaSet,
    and many others. Though Kubernetes comes with many such out-of-the-box resources,
    it is a very extensible platform that allows adding more resources that are custom.
    Such custom resources are called CRDs. You may learn more about CRDs here: [https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 有几个现成的 API，称为资源。此类资源的一些示例包括 Pod、Node、Deployment、Service、ReplicaSet
    等。尽管 Kubernetes 提供了许多现成的资源，但它是一个非常可扩展的平台，允许添加更多自定义资源。此类自定义资源被称为 CRD。你可以在这里了解更多关于
    CRD 的信息：[https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/)。
- en: 'kpack has two main components, as depicted in *Figure 3**.4*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: kpack 有两个主要组件，如 *图 3.4* 所示：
- en: kpack Kubernetes CRDs to help use CNB and define the container image specification.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kpack Kubernetes CRD 帮助使用 CNB 并定义容器镜像规范。
- en: The kpack **command-line interface** (**CLI**), which provides the required
    user interface to use kpack resources. The kpack CLI provides ways to create and
    manage container image build specifications using kpack.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kpack **命令行接口**（**CLI**）提供了所需的用户界面，以便使用 kpack 资源。kpack CLI 提供了通过 kpack 创建和管理容器镜像构建规范的方法。
- en: kpack CRD objects used by TBS
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TBS 使用的 kpack CRD 对象
- en: 'Though kpack is an internal component of TBS, the following are some of the
    key kpack CRD objects that are used by TBS:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 kpack 是 TBS 的内部组件，但以下是 TBS 使用的一些关键 kpack CRD 对象：
- en: '`Image` object references the application source code or package location,
    the runtime details for the build process, and the container registry details
    to store the built images.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image` 对象引用应用程序源代码或包的位置、构建过程的运行时详细信息，以及存储构建镜像的容器注册表详细信息。'
- en: '**ClusterStore**: This contains references to buildpacks in the form of their
    respective container image locations.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClusterStore**：它包含以容器镜像位置形式引用的 buildpacks。'
- en: '**ClusterStack**: This contains references to the OS layers in terms of the
    build image and run image, along with their container registry locations.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClusterStack**：它包含以构建镜像和运行镜像形式引用的操作系统层，以及它们的容器注册表位置。'
- en: '`ClusterStore` and `ClusterStack` combinations. A `ClusterBuilder` object also
    defines an order of buildpacks to be validated against any application.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClusterStore` 和 `ClusterStack` 的组合。`ClusterBuilder` 对象还定义了构建包的顺序，以便对任何应用程序进行验证。'
- en: VMware-provided components and features
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VMware 提供的组件和功能
- en: 'In addition to the two main open source build blocks of TBS – CNB and kpack
    – there are also a few additional components and functionalities provided by VMware
    that the enterprises can get as a part of TBS packaging. Let’s quickly visit them:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 TBS 的两个主要开源构建模块 — CNB 和 kpack — VMware 还提供了一些额外的组件和功能，企业可以作为 TBS 打包的一部分获取。我们快速浏览一下：
- en: TBS comes with a proprietary installation and upgrades the user experience using
    an open source toolkit named Carvel ([https://carvel.dev](https://carvel.dev)).
    It is a Kubernetes application packaging and deployment toolkit mainly maintained
    by VMware. We will use it to install TBS in the next section.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TBS 提供了一种专有的安装方式，并通过一个名为 Carvel 的开源工具包（[https://carvel.dev](https://carvel.dev)）提升用户体验。Carvel
    是一个 Kubernetes 应用程序打包和部署工具包，主要由 VMware 维护。我们将在下一节中使用它来安装 TBS。
- en: TBS has a dependency updater component that keeps all the container images built
    by TBS up to date with changes made in their corresponding buildpacks or stack.
    This feature helps to keep all the container images patched and secured with the
    latest updates in the operating system and application dependency changes.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TBS 具有一个依赖更新器组件，它保持所有由 TBS 构建的容器镜像与其相应的 buildpacks 或堆栈中的更改保持同步。此功能有助于确保所有容器镜像都通过操作系统和应用程序依赖项的最新更新进行修补和安全加固。
- en: TBS also comes with a bundle of VMware-supplied buildpacks. This includes the
    support for offline buildpacks, Windows containers, and quick and reliable release
    engineering of the new buildpack versions to include new features and fixes of
    CVEs.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TBS 还附带了一套 VMware 提供的 buildpacks。它支持离线 buildpacks、Windows 容器，以及新版本 buildpack
    的快速可靠发布工程，包括新功能和 CVE 修复。
- en: In this section, we saw the structure and components of TBS. We also learned
    the role that each of them plays to build the whole solution. Now, let’s get started
    with working with TBS. In the next section, you will learn how to install and
    configure TBS in your Kubernetes cluster and rip all the benefits we discussed
    previously.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了TBS的结构和组件。我们还学习了每个组件在构建整个解决方案中的作用。现在，让我们开始使用TBS。在下一节中，您将学习如何在Kubernetes集群中安装和配置TBS，并获得我们之前讨论的所有好处。
- en: Getting started with Tanzu Build Service
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Tanzu Build Service
- en: After learning about the challenges addressed by TBS and the details of what
    TBS contains, let’s learn how we can quickly get started with it running in a
    Kubernetes cluster.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了TBS解决的挑战和TBS所包含的内容后，让我们学习如何快速在Kubernetes集群中启动并运行它。
- en: Important note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: All these instructions are for **Tanzu Build Service** (**TBS**) v1.3.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些说明适用于**Tanzu Build Service**（**TBS**）v1.3版本。
- en: The following section details different prerequisites that you may need to get
    TBS fully up and running in your Kubernetes cluster.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分详细介绍了在Kubernetes集群中完全启用TBS所需的不同前提条件。
- en: Prerequisites
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前提条件
- en: 'You will need the following to configure TBS in your Kubernetes environment:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes环境中配置TBS时，您需要以下内容：
- en: Administrator-level `kubectl` CLI access to a Kubernetes cluster with version
    1.19 or later. If administrator-level access is not feasible, then the user must
    at least have permissions listed at [https://github.com/tandcruz/DevSecOps-in-Practice-with-VMware-Tanzu/blob/main/chapter-03/tbs-k8s-cluster-permissions.yml](https://github.com/tandcruz/DevSecOps-in-Practice-with-VMware-Tanzu/blob/main/chapter-03/tbs-k8s-cluster-permissions.yml)
    on the cluster to install and configure TBS.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员级别的`kubectl` CLI访问权限，要求Kubernetes集群版本为1.19或更高。如果无法获得管理员级别的访问权限，则用户至少需要具有[https://github.com/tandcruz/DevSecOps-in-Practice-with-VMware-Tanzu/blob/main/chapter-03/tbs-k8s-cluster-permissions.yml](https://github.com/tandcruz/DevSecOps-in-Practice-with-VMware-Tanzu/blob/main/chapter-03/tbs-k8s-cluster-permissions.yml)中列出的权限，才能安装和配置TBS。
- en: The worker nodes of the Kubernetes cluster should at least have 50 GB of ephemeral
    storage as TBS stores the historical versions of the built images for records.
    The number of historical versions stored by TBS can be configured. This will be
    covered later in this chapter under day-2 activities.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes集群的工作节点应至少具有50GB的临时存储，因为TBS会存储构建镜像的历史版本以供记录。TBS存储的历史版本数量是可以配置的。后续将在本章的第二天活动中讲解这一点。
- en: Access to any container registry with required permission that supports Docker
    HTTP API V2 with at least a 5 GB storage quota, which excludes the space required
    for application images built by TBS. To keep things simple, we will use Docker
    Hub ([https://hub.docker.com/](https://hub.docker.com/)), which provides a free
    account that is good enough for TBS integration.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问任何支持Docker HTTP API V2并具有至少5GB存储配额的容器注册表，排除由TBS构建的应用程序镜像所需的空间。为了简化操作，我们将使用Docker
    Hub（[https://hub.docker.com/](https://hub.docker.com/)），它提供一个免费的账户，足以支持TBS集成。
- en: There should be a default **StorageClass** configured in your Kubernetes cluster
    that TBS can use to create the required storage volumes. By default, TBS will
    need a **PersistentVolumeClaim** that it uses to cache already-built artifacts.
    Such caching helps the subsequent builds complete faster.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的Kubernetes集群中应配置一个默认的**StorageClass**，以供TBS创建所需的存储卷。默认情况下，TBS将需要一个**PersistentVolumeClaim**，用于缓存已经构建的工件。这样的缓存有助于加快后续构建的速度。
- en: 'The operator machine that will be used for this installation should have Carvel
    CLI tools installed. The following are those Carvel tools that TBS uses, along
    with their download locations and purposes:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于此安装的操作机应已安装Carvel CLI工具。以下是TBS使用的Carvel工具，以及它们的下载位置和用途：
- en: '`kapp` version 0.41.0 ([https://network.tanzu.vmware.com/products/kapp](https://network.tanzu.vmware.com/products/kapp)/)
    to deploy the bundle of Kubernetes resources required for TBS.'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kapp`版本0.41.0（[https://network.tanzu.vmware.com/products/kapp](https://network.tanzu.vmware.com/products/kapp)/）用于部署TBS所需的Kubernetes资源包。'
- en: '`ytt` version 0.37.0 ([https://network.tanzu.vmware.com/products/ytt/](https://network.tanzu.vmware.com/products/ytt/))
    to replace custom configuration values in the YAML template files used for TBS
    Kubernetes resource deployments.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ytt`版本0.37.0（[https://network.tanzu.vmware.com/products/ytt/](https://network.tanzu.vmware.com/products/ytt/)）用于替换TBS
    Kubernetes资源部署中使用的YAML模板文件中的自定义配置值。'
- en: '`kbld` version 0.31.0 ([https://network.tanzu.vmware.com/products/kbld/](https://network.tanzu.vmware.com/products/kbld/))
    to reference container images in Kubernetes configuration files that are relocated
    based on your choice of container registry.'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kbld` 版本 0.31.0 ([https://network.tanzu.vmware.com/products/kbld/](https://network.tanzu.vmware.com/products/kbld/))
    用于在基于您选择的容器注册表的 Kubernetes 配置文件中引用容器映像，这些映像已经根据您的选择进行了重定位。'
- en: '`imgpkg` version 0.23.1 ([https://network.tanzu.vmware.com/products/imgpkg/](https://network.tanzu.vmware.com/products/imgpkg/))
    to deploy the packaged application bundle for TBS that contains the required configuration
    and OCI images. For an air-gapped (an environment that has no outbound internet
    connectivity) installation, it helps to relocate all the required OCI images to
    the private container registry in use.'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imgpkg` 版本 0.23.1 ([https://network.tanzu.vmware.com/products/imgpkg/](https://network.tanzu.vmware.com/products/imgpkg/))
    用于部署包含所需配置和 OCI 映像的 TBS 打包应用程序包。对于无外出 Internet 连接的空气隔离环境，它有助于将所有必需的 OCI 映像重定位到正在使用的私有容器注册表。'
- en: The operator machine should have `kp` CLI v0.4.*, which can be downloaded from
    the Tanzu Network website at [https://network.tanzu.vmware.com/products/build-service/](https://network.tanzu.vmware.com/products/build-service/).
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员机器应该安装有 `kp` CLI v0.4.*，可以从 Tanzu Network 网站上的 [https://network.tanzu.vmware.com/products/build-service/](https://network.tanzu.vmware.com/products/build-service/)
    下载。
- en: 'The operator machine should have the `docker` CLI: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员机器应该安装 `docker` CLI：[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)。
- en: The operator machine should have the Dependency Descriptor file in the `descriptor-<version>.yaml`
    format downloaded from the TBS dependencies page on the Tanzu Network website
    at [https://network.tanzu.vmware.com/products/build-service/](https://network.tanzu.vmware.com/products/build-service/).
    This book has used the `descriptor-100.0.229.yaml` file. This file contains container
    image paths that TBS will need to execute image builds. You may find a different
    version, depending on when you download it, which is fine.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员机器应该从 Tanzu Network 网站的 TBS 依赖页面上下载 `descriptor-<version>.yaml` 格式的依赖描述符文件，该书使用了
    `descriptor-100.0.229.yaml` 文件。此文件包含 TBS 将需要执行图像构建的容器映像路径。根据您下载的时间，可能会找到不同的版本，这是可以接受的。
- en: Important note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The Kubernetes cluster running with Containerd v1.4.1 is not compatible with
    TBS. The following `kubectl` command will get the version of the underneath container
    runtime to check this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Containerd v1.4.1 的 Kubernetes 集群与 TBS 不兼容。以下 `kubectl` 命令将获取底层容器运行时的版本以检查此问题：
- en: '`kubectl get` `nodes -o=jsonpath=''{.items[0].status.nodeInfo.containerRuntimeVersion}''`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get` `nodes -o=jsonpath=''{.items[0].status.nodeInfo.containerRuntimeVersion}''`'
- en: Let’s start our journey working with TBS by first installing it and then performing
    some basic tests to confirm whether it is working as expected.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从首先安装 TBS 开始我们的旅程，并执行一些基本测试，以确认它是否按预期工作。
- en: Installation procedure
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装过程
- en: In this chapter, we will use Docker Hub as the container registry to be used
    with TBS. Also, the installation steps assume that the base Kubernetes cluster
    has full outbound internet connectivity. The procedure to install and configure
    TBS is different for an air-gapped environment and a custom container registry
    to be used instead of Docker Hub. You may follow the official product documentation
    ([https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-installing.html](https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-installing.html))
    for a different use case.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Docker Hub 作为与 TBS 配合使用的容器注册表。此外，安装步骤假定基本 Kubernetes 集群具有完全的外部 Internet
    连通性。对于空气隔离环境和要使用的自定义容器注册表，安装和配置 TBS 的过程有所不同。您可以根据不同的用例查看官方产品文档 ([https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-installing.html](https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-installing.html))。
- en: Additionally, the `p********t` value used in all the commands should be replaced
    with your respective username and `**********` with your respective password.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在所有命令中使用的 `p********t` 值应替换为您的相应用户名，并将 `**********` 替换为您的相应密码。
- en: 'With those expectations set, let’s install and configure TBS by performing
    the following steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些期望，让我们通过执行以下步骤来安装和配置 TBS：
- en: 'Make sure you are working in the right Kubernetes cluster and context where
    you want to install TBS:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您正在正确的 Kubernetes 集群和上下文中进行工作，以便安装 TBS：
- en: '[PRE0]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Relocate the required container images from the Tanzu Network registry to your
    Docker Hub account. For that, log in to your Docker Hub account, as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所需的容器镜像从Tanzu Network注册表迁移到您的Docker Hub帐户。为此，登录到您的Docker Hub帐户，操作如下：
- en: '[PRE1]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Log in to the Tanzu Network container registry to pull the required images
    for installation using your Tanzu Network credentials:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录Tanzu Network容器注册表，使用您的Tanzu Network凭据拉取所需的安装镜像：
- en: '[PRE4]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Relocate the images from Tanzu Network to your Docker Hub registry using the
    following `imgpkg` command:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`imgpkg`命令将镜像从Tanzu Network迁移到您的Docker Hub注册表：
- en: '[PRE8]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You may ignore the warning given before the success message because TBS excludes
    Windows components by default as they are licensed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以忽略成功消息之前的警告，因为TBS默认不包括Windows组件，因为它们有许可证限制。
- en: 'Pull the TBS bundle image locally using the `imgpkg` command:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`imgpkg`命令将TBS包镜像拉取到本地：
- en: '[PRE19]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Install TBS using the relevant Carvel tools – `ytt`, `kbld`, and `kapp` – with
    the following command. It is a very long command that injects the provided custom
    parameter values with the `-v` flag into the deployment configuration files using
    `ytt`. Then, the command replaces the container image locations based on your
    registry location using `kbld`. And finally, it deploys TBS using the configuration
    files with custom parameter values and the required container image files pulled
    from your repository using `kapp`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关的Carvel工具（`ytt`，`kbld`和`kapp`）安装TBS，执行以下命令。这是一个非常长的命令，它将通过`ytt`使用`-v`标志将提供的自定义参数值注入部署配置文件中。然后，命令使用`kbld`根据您的注册位置替换容器镜像位置。最后，它使用`kapp`通过带有自定义参数值和从您的存储库拉取的所需容器镜像文件的配置文件部署TBS：
- en: '[PRE25]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Important note
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: At the time of writing this book, all the binaries supplied under Carvel, including
    `ytt`, `kbld`, and `kapp,` are unsigned binaries. Because of this, your operating
    system, especially macOS, may raise a security concern against using them. However,
    you may explicitly allow the execution of these binaries in your operating system’s
    security settings. Additionally, as this command performs various long image pull
    operations to deploy TBS in your Kubernetes cluster, you may see the command complete
    unsuccessfully with an error – `use of closed network connection`. In that case,
    you may run the same command again and it may just work.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，所有Carvel下提供的二进制文件，包括`ytt`，`kbld`和`kapp`，都是未签名的二进制文件。因此，您的操作系统，尤其是macOS，可能会对使用它们提出安全警告。但是，您可以在操作系统的安全设置中明确允许执行这些二进制文件。此外，由于此命令执行多个长时间的镜像拉取操作以在Kubernetes集群中部署TBS，您可能会看到命令未成功完成并出现错误——`use
    of closed network connection`。在这种情况下，您可以再次运行相同的命令，可能就能成功。
- en: 'You may need to replace the highlighted values in the preceding command as
    per the following specification:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要根据以下规范替换前述命令中的突出显示值：
- en: Replace `p********t` in the `kp_default_repository` and `kp_default_repository_username`
    parameters with your Docker Hub username
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`kp_default_repository`和`kp_default_repository_username`参数中的`p********t`替换为您的Docker
    Hub用户名
- en: Replace `**********` in the `kp_default_repository_password` parameter with
    your Docker Hub account password
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`**********`替换为`kp_default_repository_password`参数中的Docker Hub帐户密码
- en: Replace `p********t@*******.io` in `tanzunet_username` with your Tanzu Network
    username
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`tanzunet_username`中的`p********t@*******.io`替换为您的Tanzu Network用户名
- en: Replace `**********` in `tanzunet_password` with your Tanzu Network password
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`tanzunet_password`中的`**********`替换为您的Tanzu Network密码
- en: With that last command completed successfully, TBS should be up and running
    in your Kubernetes cluster. Let’s verify the installation and ensure TBS is working
    fine.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个命令成功完成后，TBS应已在您的Kubernetes集群中启动并运行。让我们验证安装并确保TBS正常工作。
- en: Verifying the installation
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证安装
- en: 'To verify the TBS installation, execute the following `kp` command to list
    the cluster builders available in your TBS environment:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证TBS安装，执行以下`kp`命令以列出TBS环境中可用的集群构建器：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The result of the preceding command should look as follows, where you should
    see your Docker Hub username instead of `p********t`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的结果应如下所示，您应看到您的Docker Hub用户名，而不是`p********t`：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you see the preceding output, then congratulations to you as you have TBS
    running in your Kubernetes environment, waiting to build container images of your
    application!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到上述输出，恭喜您，TBS已在您的Kubernetes环境中运行，并准备构建您的应用程序的容器镜像！
- en: Now that we’ve got started with TBS, let’s investigate common day-2 operations
    that we can perform on TBS for various use cases.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经开始使用TBS，让我们探讨一些常见的第2天操作，这些操作可以根据不同的用例在TBS上执行。
- en: Common day-2 activities for Tanzu Build Service
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tanzu Build Service的常见第2天操作
- en: In this section, we will go through some useful operations we can perform on
    TBS.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些可以在TBS上执行的有用操作。
- en: Building application container images
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建应用程序容器镜像
- en: In this section, we will learn how to register our application with TBS for
    the first time, create the first container image, run that container image locally,
    retrigger the image build process again by modifying the application configuration,
    and, finally, verify the newly created container image to reflect the application
    change. This will be an exciting journey to use TBS for its main purpose.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何首次将应用程序注册到TBS，创建第一个容器镜像，在本地运行该容器镜像，通过修改应用配置重新触发镜像构建过程，最后验证新创建的容器镜像以反映应用程序的变化。这将是一次令人兴奋的旅程，展示如何使用TBS来实现其主要目的。
- en: Registering an application with TBS
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将应用程序注册到TBS
- en: The main reason to use TBS is to gain the ability to build application container
    images in a fully automatic and secure way. Let’s see how we can build container
    images of a cloud-native application using the TBS setup we have completed. We
    will use a sample Spring Framework-based application, Spring Pet Clinic, available
    at [https://github.com/tandcruz/DevSecOps-in-Practice-with-VMware-Tanzu/tree/main/spring-petclinic](https://github.com/tandcruz/DevSecOps-in-Practice-with-VMware-Tanzu/tree/main/spring-petclinic).
    To follow along, you need to fork this project in your Git repository.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TBS的主要原因是获得以完全自动化和安全的方式构建应用程序容器镜像的能力。让我们看看如何使用我们完成的TBS设置构建云原生应用程序的容器镜像。我们将使用一个基于Spring框架的示例应用程序——Spring
    Pet Clinic，地址为[https://github.com/tandcruz/DevSecOps-in-Practice-with-VMware-Tanzu/tree/main/spring-petclinic](https://github.com/tandcruz/DevSecOps-in-Practice-with-VMware-Tanzu/tree/main/spring-petclinic)。要跟随本教程，你需要在你的Git仓库中fork这个项目。
- en: 'We will use the `kp` CLI to register our application with TBS. To register
    an application, we must create an `image` resource, which is a kpack CRD object
    to create a record of the application in its list. Once an image resource has
    been created, TBS creates a `build`, which is also a kpack CRD object that creates
    a container image of a registered application. There can be one-to-many relationships
    between an `image` and its `build` objects, depending on the number of instances
    to create a new container image for an application. But before we register our
    application, let’s verify the current image objects:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`kp` CLI将应用程序注册到TBS。要注册一个应用程序，我们必须创建一个`image`资源，这是一个kpack CRD对象，用于在其列表中创建应用程序的记录。创建`image`资源后，TBS会创建一个`build`，它也是一个kpack
    CRD对象，用于创建已注册应用程序的容器镜像。根据创建新容器镜像的实例数量，`image`和`build`对象之间可以是多对一的关系。在注册我们的应用程序之前，让我们验证当前的镜像对象：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you might have guessed, we don’t have any existing `image` objects managed
    by our newly deployed TBS in our Kubernetes cluster.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的那样，我们在Kubernetes集群中通过新部署的TBS并没有管理任何现有的`image`对象。
- en: 'Additionally, we will also need to provide TBS with the credentials to our
    Docker Hub account so that it can push built images there. You may also use a
    different container registry or a Docker Hub account to push built application
    images. But, to keep things simple, we will use the same Docker Hub account that
    we used previously to install TBS. To supply the login credentials of our Docker
    Hub account, we need to create a Kubernetes `Secret` object, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要向TBS提供Docker Hub帐户的凭证，以便它能够将构建的镜像推送到那里。你也可以使用其他的容器注册表或Docker Hub帐户来推送构建的应用镜像。但为了简化操作，我们将使用之前用来安装TBS的相同Docker
    Hub帐户。为了提供Docker Hub帐户的登录凭证，我们需要创建一个Kubernetes `Secret`对象，如下所示：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, let’s work on creating an `image` object.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始创建一个`image`对象。
- en: 'There are three different ways in which we may configure an application to
    use TBS for building container images. Let’s take a look at them so that you can
    understand which one you should use when:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过三种不同的方式配置应用程序，以使用TBS构建容器镜像。让我们一起了解一下它们，帮助你理解在何时使用哪种方式：
- en: '**Using a Git repository URL**: In this approach, we register the Git repository
    URL and the branch of the repository that we want to monitor for changes and trigger
    TBS image builds based on the changes committed in this branch. This is the most
    automated approach to creating container images as soon as application changes
    are merged in the final code branch. We will use this approach in this book.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 Git 仓库 URL**：在此方法中，我们注册 Git 仓库 URL 和我们希望监视更改并根据该分支中提交的更改触发 TBS 镜像构建的仓库分支。这是创建容器镜像的最自动化方法，一旦应用程序更改合并到最终代码分支中，我们将采用此方法。我们将在本书中使用此方法。'
- en: '**Using a local path**: In this approach, we supply either the location of
    the application’s package such as a JAR file for a Java application that is precompiled
    and packaged on the local system, or provide the location of the application’s
    source code on the local system. This approach is not fully automated using TBS
    and assumes that you have an external CI process that will explicitly call TBS
    whenever there is a need to create a container image of the application, rather
    than creating new images automatically based on the new changes pushed into the
    Git repository branch.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用本地路径**：在此方法中，我们提供应用程序包的位置，例如 Java 应用程序的 JAR 文件，该文件在本地系统上预编译并打包，或提供应用程序源代码在本地系统上的位置。此方法不能完全通过
    TBS 自动化，并假定您有一个外部 CI 流程，该流程会在需要为应用程序创建容器镜像时显式调用 TBS，而不是基于推送到 Git 仓库分支的新更改自动创建新镜像。'
- en: '`zip`, `tar.gz`, `tar`, or `jar` file. This approach is also used for explicit
    build triggers like the previous one.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zip`、`tar.gz`、`tar` 或 `jar` 文件。此方法也用于像前面一样的显式构建触发器。'
- en: 'Now, let’s register the application, Spring Pet Clinic, to be used with TBS,
    along with its Git repository. See the following command and its results, which
    explain how to do this. The command uses the application’s Git repository and
    the branch that we want TBS to monitor for changes and build container images
    from:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们注册应用程序 Spring Pet Clinic 以与 TBS 一起使用，并注册其 Git 仓库。请参阅以下命令及其结果，了解如何执行此操作。该命令使用应用程序的
    Git 仓库和我们希望 TBS 监视更改并基于这些更改构建容器镜像的分支：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this command, replace the value of `--git` and `--git-revision` with the
    repository details that you would have forked.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中，将 `--git` 和 `--git-revision` 的值替换为您已分叉的仓库详细信息。
- en: Important note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: 'This command may take several minutes to run since it’s the first build and
    application registration. Also, it assumes that the Git repository is publicly
    accessible. But if the repository requires user credentials to pull the source
    code, you may need to create a TBS `secret` object for the Git repository credentials,
    as described here: [https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-secrets.html#create-a-git-ssh-secret](https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-secrets.html#create-a-git-ssh-secret).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令可能需要几分钟才能运行，因为这是第一次构建和应用程序注册。此外，它假定 Git 仓库是公开可访问的。但如果该仓库需要用户凭据来拉取源代码，您可能需要为
    Git 仓库凭据创建一个 TBS `secret` 对象，如下所述：[https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-secrets.html#create-a-git-ssh-secret](https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-secrets.html#create-a-git-ssh-secret)。
- en: As you can see, this command performs several operations, including accessing
    the application’s source code, downloading all required dependencies, performing
    all CNB life cycle stages, and finally, pushing the application image into your
    Docker Hub registry, as specified in the command.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此命令执行了多个操作，包括访问应用程序的源代码、下载所有必需的依赖项、执行所有 CNB 生命周期阶段，最后将应用程序镜像推送到您的 Docker
    Hub 注册表，如命令中所指定。
- en: 'Let’s check the presence of `image` objects for our application:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查应用程序的 `image` 对象的存在：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we can see that one `image` object has been created called `tbs-spring-petclinic`.
    Now, let’s check the number of `build` objects that have been created for our
    application:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到已创建一个名为 `tbs-spring-petclinic` 的 `image` 对象。现在，让我们检查为我们的应用程序创建的 `build`
    对象的数量：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, we can see one `build` object created for our application `image` object.
    We may see more `build` objects if there were a greater number of image builds
    triggered for application changes. The column named `REASON` indicates the reason
    to get this build triggered by TBS. There are the following possible reasons:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到为我们的应用`image`对象创建了一个`build`对象。如果为应用的更改触发了更多的镜像构建，我们可能会看到更多的`build`对象。名为`REASON`的列表示由TBS触发此构建的原因。可能的原因如下：
- en: '**CONFIG** to indicate when a change is made to commit, branch, Git repository,
    or build fields on the image’s configuration file'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置** 表示在镜像配置文件中对提交、分支、Git仓库或构建字段进行更改'
- en: '**COMMIT** to indicate a build as a result of a change pushed in an application’s
    code repository under TBS’s watch'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提交** 表示由应用代码仓库中推送的更改引发的构建，TBS监视此过程'
- en: '**STACK** to indicate a change in the run image OS layer'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆栈** 表示运行镜像操作系统层发生变化'
- en: '**BUILDPACK** to indicate a change in the buildpack versions that are made
    available through an updated builder'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建包** 表示通过更新的构建器提供的构建包版本的变化'
- en: '**TRIGGER** to indicate a build triggered manually'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发** 表示手动触发的构建'
- en: 'Now that the application has been registered with TBS, when you commit a small
    change in the monitored branch, you should see a new build getting created in
    a few seconds, as shown here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用已在TBS中注册，当您在受监控的分支中提交一个小的更改时，您应该会看到几秒钟内创建一个新的构建，如下所示：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You may now pull the old and the new images to deploy their containers within
    your local Docker environment to verify the changes that have been made to the
    application. Now that we’ve learned how to create new builds of the container
    images for the registered applications, let’s learn how to check the build logs
    to see the execution details of the life cycle stages.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以拉取旧的和新的镜像，在本地Docker环境中部署它们的容器，以验证应用所做的更改。现在我们已经学会了如何为已注册的应用创建新的容器镜像构建，让我们学习如何检查构建日志，以查看生命周期阶段的执行细节。
- en: Checking image build logs
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查镜像构建日志
- en: 'To check the TBS logs of the newly built image, use the following command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查新构建镜像的TBS日志，请使用以下命令：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The output has been truncated for brevity.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 输出已被截断以简洁为主。
- en: With that, we’ve learned how to create the first application configuration,
    trigger a new build, and check build logs on TBS. Now, let’s discuss another very
    important activity around TBS, which is to keep our container images always secured
    and patched with the latest versions of the software libraries and operating system
    layers used in the application container images.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们已经学会了如何创建第一个应用配置、触发新构建以及检查TBS上的构建日志。现在，让我们讨论另一个关于TBS的非常重要的活动，那就是保持我们的容器镜像始终保持安全，并及时更新应用容器镜像中使用的软件库和操作系统层的最新版本。
- en: Upgrading buildpacks and stacks
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级构建包和堆栈
- en: As we saw in the *Why Tanzu Build Service* section, one of the main benefits
    of using this tool is to enhance the security posture by staying up to date using
    the latest patched application dependencies and the OS layer used to build container
    images. As we know, buildpacks contain references to different software library
    versions and stacks contain the OS layers for the container image building. So,
    when there are new patch releases of the libraries that are referenced in the
    buildpacks or the OS in the stacks, VMware releases a new version of the impacted
    buildpacks and stacks to provide the latest patched version of the software that
    they reference.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*为什么选择 Tanzu Build Service* 部分中看到的，使用该工具的主要好处之一是通过保持最新的修补程序应用依赖和构建容器镜像时使用的操作系统层，从而提高安全性。正如我们所知，构建包包含对不同软件库版本的引用，堆栈包含构建容器镜像的操作系统层。因此，当构建包中引用的软件库或堆栈中的操作系统有新的补丁版本发布时，VMware会发布更新后的构建包和堆栈版本，以提供它们引用的软件的最新修补版本。
- en: 'The most recommended way to stay up to date with TBS component versions is
    to enable the automatic update ability that TBS is equipped with. When we deploy
    TBS with our Tanzu Network account credentials, TBS deploys a CRD object in our
    Kubernetes cluster named **TanzuNetDependencyUpdater**. This CRD object is responsible
    for keeping our TBS components up to date automatically. We used the same approach
    in our installation, which we performed earlier in this chapter. You can verify
    this setup by running the following command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 TBS 组件版本最新的最推荐方式是启用 TBS 自带的自动更新功能。当我们使用 Tanzu 网络账户凭据部署 TBS 时，TBS 会在我们的 Kubernetes
    集群中部署一个名为**TanzuNetDependencyUpdater**的 CRD 对象。这个 CRD 对象负责自动保持我们的 TBS 组件最新。我们在本章早些时候的安装中使用了相同的方法。你可以通过运行以下命令来验证这个设置：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, the value of `DESCRIPTIONVERSION` may be different, depending on the latest
    available release of the description file that you would have downloaded as a
    part of the prerequisites at the beginning of this chapter.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`DESCRIPTIONVERSION` 的值可能不同，这取决于你在本章开始时作为前提条件下载的描述文件的最新可用版本。
- en: 'If the automatic update was not enabled during the installation process, then
    the following link shows how to enable it post-installation or how to manually
    update various components to retain more control over time and the impact of the
    changes: [https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-updating-deps.html](https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-updating-deps.html).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在安装过程中未启用自动更新，则以下链接展示了如何在安装后启用它，或者如何手动更新各个组件，以便更好地控制更新的时间和变更的影响：[https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-updating-deps.html](https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-updating-deps.html)。
- en: Managing images and builds
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理图像和构建
- en: 'There are various day-to-day operations that we may need to perform to work
    with the application configuration, in the form of image objects, and their corresponding
    build processes, created in the form of build objects, that are triggered for
    different possible reasons we saw earlier, including STACK, BUILDPACK, CONFIG,
    COMMIT, and TRIGGER. You can learn more about such operations at [https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-images.html](https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-images.html).
    Additionally, TBS keeps the last 10 successful and failed pieces of build history
    information, including their completed pods and hence the logs for each `Image`
    resource. Such historical builds help you obtain historical logs and details but
    also occupy a lot of storage space on the cluster. In a large enterprise-scale
    environment, it could impact more because of several `Image` resources being created.
    You may refer to this documentation if you want to change the default configuration
    of 10 historical builds to a different number: [https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-faq.html#faq-18](https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-faq.html#faq-18).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要执行各种日常操作，以便处理应用程序配置，这些配置以图像对象的形式存在，并且对应的构建过程作为构建对象生成，这些过程会因之前提到的不同原因而触发，包括
    STACK、BUILDPACK、CONFIG、COMMIT 和 TRIGGER。你可以在[https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-images.html](https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-images.html)了解更多关于这些操作的信息。此外，TBS
    会保留最后 10 次成功和失败的构建历史记录，包括它们完成的 Pod 及其相应的 `Image` 资源的日志。这些历史构建有助于你获取历史日志和详细信息，但也会占用大量集群存储空间。在大规模企业环境中，随着多个
    `Image` 资源的创建，这可能会产生更大的影响。如果你想更改默认的 10 次历史构建的配置，可以参考以下文档，设置为其他数字：[https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-faq.html#faq-18](https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-faq.html#faq-18)。
- en: Configuring role-based access controls
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置基于角色的访问控制
- en: 'It is recommended to install TBS on a Kubernetes cluster that is dedicated
    to such platform services that are different from the cluster running actual business
    workloads. Such supporting services clusters are under the control of a specific
    user group of platform operators. Such cluster-level separation is one good way
    to selectively allow users to access TBS in the first place. An accidental change
    in a `ClusterBuilder` definition may cause a trigger to build possibly hundreds
    of container images for the applications that are linked with that `ClusterBuilder`.
    And if there is an automated deployment pipeline in place that deploys new versions
    of all the applications with the new container images, then such a mistake could
    be even more severe. That is why putting the required guardrail around TBS is
    very important. For that reason, TBS provides some level of access control using
    two Kubernetes ClusterRoles, as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐在专门用于平台服务的Kubernetes集群中安装TBS，而不是用于实际业务负载的集群。此类支持服务集群由平台运维特定用户组控制。集群级别的分离是选择性地允许用户访问TBS的一个好方法。如果`ClusterBuilder`定义发生意外更改，可能会触发构建与该`ClusterBuilder`相关联的应用程序的数百个容器镜像。而且，如果有自动化部署管道部署了所有应用程序的新版本并使用了新的容器镜像，那么这种错误可能会更加严重。因此，围绕TBS设置必要的保护措施非常重要。为此，TBS提供了使用两个Kubernetes
    ClusterRoles的某种级别的访问控制，具体如下：
- en: '`build-service-user-role`: To allow working with images and build resources'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build-service-user-role`：允许处理镜像和构建资源'
- en: '`build-service-admin-role`: To allow all other administrative activities on
    TBS'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build-service-admin-role`：允许在TBS上执行所有其他管理活动'
- en: 'The TBS users with access to images and builds should create these objects
    in their respective Kubernetes namespace to restrict access to these objects to
    the members of the same namespace. This way, we can combine the power of Kubernetes
    access control capabilities for greater control. You may find more details on
    how to configure these permissions here: [https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-tbs-with-projects.html#rbac-support-in-tanzu-build-service](https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-tbs-with-projects.html#rbac-support-in-tanzu-build-service).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 具有访问镜像和构建权限的TBS用户应在各自的Kubernetes命名空间中创建这些对象，以限制这些对象的访问权限仅限于同一命名空间的成员。通过这种方式，我们可以结合Kubernetes的访问控制功能，获得更强的控制力。你可以在这里找到如何配置这些权限的更多详细信息：[https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-tbs-with-projects.html#rbac-support-in-tanzu-build-service](https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-tbs-with-projects.html#rbac-support-in-tanzu-build-service)。
- en: Upgrading TBS to a newer version
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级TBS到新版本
- en: Upgrading TBS to a newer version is very simple. You just need to perform the
    same steps that we walked through for the installation process other than re-importing
    the dependencies if they’re not required.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 升级TBS到新版本非常简单。你只需执行与安装过程中相同的步骤，除了在不需要的情况下重新导入依赖项。
- en: Uninstalling TBS
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卸载TBS
- en: 'To uninstall TBS from your Kubernetes cluster, just run the following `kapp`
    command; it will delete all TBS objects from your cluster other than the container
    images created by TBS. This command is very destructive and should be used with
    extreme caution:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Kubernetes集群中卸载TBS，只需运行以下`kapp`命令；它将删除集群中所有TBS对象，除了TBS创建的容器镜像。此命令非常具有破坏性，使用时应极其小心：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Customizing buildpacks
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义buildpacks
- en: 'TBS is built with a very modular, customizable, and extendable architecture.
    It allows us to perform various custom changes, such as including new buildpacks,
    changing buildpack order, adding new OS layers, and many more. You may learn more
    about such customizations using the following references:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: TBS采用非常模块化、可定制和可扩展的架构。它允许我们进行各种自定义更改，例如添加新的buildpacks、改变buildpack顺序、添加新的操作系统层等。你可以通过以下参考资料了解更多关于此类自定义的信息：
- en: 'Managing `ClusterStores`: [https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-stores.html](https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-stores.html)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理`ClusterStores`：[https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-stores.html](https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-stores.html)
- en: 'Managing `ClusterStacks`: [https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-stacks.html](https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-stacks.html)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理`ClusterStacks`：[https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-stacks.html](https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-stacks.html)
- en: 'Creating and managing buildpacks: [https://buildpacks.io/docs/buildpack-author-guide/](https://buildpacks.io/docs/buildpack-author-guide/)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和管理buildpacks：[https://buildpacks.io/docs/buildpack-author-guide/](https://buildpacks.io/docs/buildpack-author-guide/)
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about different problems around building secured
    container images for our applications and how TBS targets them with different
    capabilities. Later, we took a deep dive into the full anatomy of TBS to understand
    all its building blocks. After that, we walked through the installation process
    of TBS to get started with it. And finally, we saw how to perform various key
    operations on TBS. Using a solution such as TBS that is based on CNB is one of
    the most recommended approaches suggested by CNCF, and now, we can appreciate
    why that is the case.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了围绕为应用程序构建安全容器镜像的不同问题，以及TBS如何通过不同的功能来应对这些问题。接着，我们深入了解了TBS的完整结构，以理解它的所有构建模块。之后，我们进行了TBS的安装过程演示，帮助我们开始使用它。最后，我们了解了如何在TBS上执行各种关键操作。使用像TBS这样的基于CNB的解决方案是CNCF推荐的最佳实践之一，现在我们可以理解为什么这是一个有效的做法。
- en: In any Kubernetes environment, we deploy two different types of container images
    – either they belong to our application or a third-party software. Now that we’ve
    learned how to build secured container images for our applications using an out-of-box
    automation tool, in the next chapter, we will learn how to consume secured container
    images of popular open source software to provide backing services to our applications.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何Kubernetes环境中，我们都会部署两种不同类型的容器镜像——它们要么属于我们的应用程序，要么属于第三方软件。现在我们已经学习了如何使用开箱即用的自动化工具为我们的应用程序构建安全容器镜像，在下一章中，我们将学习如何使用流行开源软件的安全容器镜像，为我们的应用程序提供后端服务。
