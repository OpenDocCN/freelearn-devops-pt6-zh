<html><head></head><body>
		<div id="_idContainer036">
			<h1 id="_idParaDest-153"><em class="italic"><a id="_idTextAnchor152"/>Chapter 9</em>: Diving into FAQs and Future Trends</h1>
			<p>The <strong class="bold">Operator Framework</strong> covers a lot of different topics, many of which have been discussed in this book. In this chapter, we will not discuss any new topics. Rather, we will revisit all of the main points that have been covered since the start of the book in short, digestible FAQ-style headings. It is the intent of these FAQs to provide a brief reference and refresher to everything that was covered during the course of this book. This should be a good, quick reminder of various topics in the event you are studying for an interview, certification exam, or just trying to remember an overview of a certain point that was made. The outline for these FAQs will fall under the following sections:</p>
			<ul>
				<li>FAQs about the Operator Framework</li>
				<li>FAQs about Operator design, <strong class="bold">CustomResourceDefinitions</strong> (<strong class="bold">CRDs</strong>), and APIs</li>
				<li>FAQs about the Operator SDK and coding controller logic</li>
				<li>FAQs about OperatorHub and the Operator Lifecycle Manager</li>
				<li>Future trends in the Operator Framework</li>
			</ul>
			<p>These sections are roughly in the order that they appeared in the book, so reading this chapter in order will jog your memory and solidify your understanding of the topics as they were originally presented.</p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor153"/>FAQs about the Operator Framework</h1>
			<p>These topics include <a id="_idIndexMarker571"/>an overview of the Operator Framework, its basic components, and the general vocabulary of Operator design. The topics from this section are from <a href="B18147_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introducing the Operator Framework</em>.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>What is an Operator?</h2>
			<p>An Operator is <a id="_idIndexMarker572"/>a type of Kubernetes controller. Operators are designed to automate the management of Kubernetes applications and cluster components. They do this by continuously working to reconcile the current state of the cluster with the desired state, as defined by a user or administrator.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/>What benefit do Operators provide to a Kubernetes cluster?</h2>
			<p>Operators <a id="_idIndexMarker573"/>provide an idiomatic <a id="_idIndexMarker574"/>way for developers to encode automated cluster and application management logic into a controller. Operators also offer ways to expose the settings for this automation to non-developer users (for example, cluster administrators or customers). This automation frees up engineering and DevOps resources for many tasks.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor156"/>How are Operators different from other Kubernetes controllers?</h2>
			<p>Operators <a id="_idIndexMarker575"/>are very similar to any other <strong class="bold">Kubernetes</strong> controller. Some <a id="_idIndexMarker576"/>examples of built-in controllers <a id="_idIndexMarker577"/>in Kubernetes include the <strong class="bold">scheduler</strong>, the API server, and the controller manager (which itself manages other controllers). These native controllers all handle the automated execution of core cluster functionality, such as placing Pods onto Nodes and maintaining Deployment replica counts. This is all part of the continuous state reconciliation pattern that Operators also exhibit.</p>
			<p>However, while they are functionally similar, Operators are defined by conceptual and semantic conventions that differentiate them from standard controllers. These include the development libraries, tools, deployment methods, and distribution channels that comprise the Operator Framework. </p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>What is the Operator Framework?</h2>
			<p>The Operator Framework is a set of development and deployment tools and patterns that define <a id="_idIndexMarker578"/>and support the standard processes for building an Operator. In broad terms, these include code libraries and scaffolding tools (the Operator SDK), a component <a id="_idIndexMarker579"/>for installing, running, and upgrading Operators (the <strong class="bold">Operator Lifecycle Manager</strong> (<strong class="bold">OLM</strong>)), and a centralized index for distributing Operators among the Kubernetes community (OperatorHub). </p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor158"/>What is an Operand?</h2>
			<p>An Operand is <a id="_idIndexMarker580"/>the component or resources that are managed by an Operator.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor159"/>What are the main components of the Operator Framework?</h2>
			<p>The main <a id="_idIndexMarker581"/>components of the Operator Framework are as follows:</p>
			<ul>
				<li><strong class="bold">The Operator SDK</strong> – A set <a id="_idIndexMarker582"/>of common libraries and command-line tools for building an Operator from scratch. This includes wrappers for <a id="_idIndexMarker583"/>tools such as <strong class="bold">Kubebuilder</strong>, which are designed for generating code used in Kubernetes controllers.</li>
				<li><strong class="bold">The OLM</strong> – A component designed to install, run, and upgrade (or downgrade) Operators in <a id="_idIndexMarker584"/>a Kubernetes cluster. Operator developers write (or generate) files that describe the Operator's relevant metadata in a way that the OLM can automate the Operator's deployment. The OLM also serves as an in-cluster catalog of installed Operators and can ensure that there are no conflicting APIs between installed Operators.</li>
				<li><strong class="bold">OperatorHub</strong> – A centralized <a id="_idIndexMarker585"/>index of freely available Operators backed by an open source GitHub repository. Developers can submit <a id="_idIndexMarker586"/>Operators to <a href="https://operatorhub.io/">https://operatorhub.io/</a> for them to be indexed and searchable by users.</li>
			</ul>
			<p>Now, let's talk about programming languages Operators can be written in.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor160"/>What programming languages can Operators be written in?</h2>
			<p>Technically, an Operator can be written in any language that supports the necessary clients <a id="_idIndexMarker587"/>and API calls needed in order to interact with a Kubernetes cluster. But, the Operator SDK supports writing Operators in <strong class="bold">Go</strong> or building <a id="_idIndexMarker588"/>with tools such as <strong class="bold">Helm</strong> or <strong class="bold">Ansible</strong>. Helm and Ansible <a id="_idIndexMarker589"/>Operators are fairly straightforward to generate with the <strong class="source-inline">operator-sdk</strong> command-line tool, but these Operators are ultimately limited in their capability. In this book, we covered the code needed to write an Operator in Go, which offers far more functionality as defined by the Operator Capability Model.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor161"/>What is the Operator Capability Model?</h2>
			<p>The Capability Model is <a id="_idIndexMarker590"/>a rubric for measuring the functionality an Operator provides and informing <a id="_idIndexMarker591"/>users of that functionality <a id="_idIndexMarker592"/>level. It defines five incremental levels of functionality:</p>
			<ol>
				<li><strong class="bold">Level I – Basic Install</strong>: Operators that are able to install an Operand, exposing configuration options for that installation if applicable</li>
				<li><strong class="bold">Level II – Seamless Upgrades</strong>: Operators that can upgrade themselves and their Operand without disrupting function</li>
				<li><strong class="bold">Level III – Full Lifecycle</strong>: Operators that can handle creation and/or restoration of Operand backups, failover scenarios for failure recovery, more complex configuration options, and scale Operands automatically</li>
				<li><strong class="bold">Level IV – Deep Insights</strong>: Operators that report metrics on themselves or their Operand</li>
				<li><strong class="bold">Level V – Auto Pilot</strong>: Operators that handle complex automated tasks including auto-scaling (creating more replicas of an Operand or deleting replicas, as needed), auto-healing (detecting and recovering from failure scenarios without intervention based on automated reporting such as metrics or alerts), auto-tuning (reallocating Operand Pods to better-suited Nodes), or abnormality detection (detecting when Operand performance does not align with usual application health)</li>
			</ol>
			<p>These were some of the most fundamental topics covered in the first chapter. The next sections in this book built upon these to dive deeper into Operator design concepts.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor162"/>FAQs about Operator design, CRDs, and APIs</h1>
			<p>These questions <a id="_idIndexMarker593"/>cover information about an Operator's <a id="_idIndexMarker594"/>design, including approaches <a id="_idIndexMarker595"/>to developing an Operator and how Operators can function within a Kubernetes cluster. The topics in this section were introduced in <a href="B18147_02_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding How Operators Interact with Kubernetes</em>, and <a href="B18147_03_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Designing an Operator – CRD, API, and Target Reconciliation</em>.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor163"/>How does an Operator interact with Kubernetes?</h2>
			<p>Operators <a id="_idIndexMarker596"/>interact with Kubernetes through <a id="_idIndexMarker597"/>event-triggered continuous monitoring of the cluster's state, wherein the Operator attempts to reconcile the current state with the desired state as specified by a user. From a technical standpoint, it does so through a standard set of Kubernetes client libraries that allow it to list, get, watch, create, and update Kubernetes resources.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor164"/>What cluster resources does an Operator act on?</h2>
			<p>An <a id="_idIndexMarker598"/>Operator can act on any resource that is accessible through the Kubernetes API (and that the Operator has cluster permissions to access). This includes native Kubernetes resources (such as Pods, ReplicaSets, Deployments, Volumes, and <a id="_idIndexMarker599"/>Services) and <strong class="bold">custom resources</strong> (<strong class="bold">CRs</strong>) provided by third-party APIs or CRDs.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor165"/>What is a CRD?</h2>
			<p>A CRD is a <a id="_idIndexMarker600"/>native Kubernetes API type that allows developers to extend the Kubernetes API with CR types that look and behave exactly like native Kubernetes API resources. Operator developers can create a CRD that defines their Operator's API type (for example, <strong class="source-inline">customresourcedefinitions/MyOperator</strong>) and this CRD then provides the template for creating CR objects that fit the definition of that type (for example, <strong class="source-inline">MyOperators/foo</strong>).</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>How is a CRD different from a CR object?</h2>
			<p>A CR object is <a id="_idIndexMarker601"/>the individual representation of an object that is based on <a id="_idIndexMarker602"/>the CRD template. In <a id="_idIndexMarker603"/>programming terms, it is the difference between an abstract type and an object instantiation of that type. CR objects are the API objects that users interact with to set Operator settings, for example with commands such as <strong class="source-inline">kubectl get MyOperators/foo</strong>.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/>What Kubernetes namespaces do Operators run within?</h2>
			<p>Operators can either be <strong class="source-inline">namespaced</strong> or <strong class="source-inline">cluster-scoped</strong>. Namespaced Operators run within <a id="_idIndexMarker604"/>an individual namespace, which allows multiple copies of the same Operator to be installed in a cluster. Cluster-scoped Operators run at the cluster-wide level, managing resources in multiple namespaces. The scope of an Operator is largely determined by the namespace scope defined in <a id="_idIndexMarker605"/>its CRD and the <strong class="bold">role-based access control</strong> (<strong class="bold">RBAC</strong>) policies assigned to the Operator's service.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor168"/>How do users interact with an Operator?</h2>
			<p>Users first interact with an Operator by installing it. This can be either from an index such as <a id="_idIndexMarker606"/>OperatorHub or by installing directly from <a id="_idIndexMarker607"/>your organization's website or GitHub page. Operators can usually be installed with a single <strong class="source-inline">kubectl create</strong> command, especially when installed via the OLM.</p>
			<p>Once installed, users will mainly interact with an Operator by creating a CR object that is a representation of its CRD. This CR object will expose API fields designed for tweaking the various settings associated with the Operator.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor169"/>How can you plan for changes early in an Operator's lifecycle?</h2>
			<p>As with many software projects, thoughtful design allows for much easier growth as the project <a id="_idIndexMarker608"/>evolves. In the context of Operators, this means thinking early on about how the Operator (and more importantly, its Operand) may change over time. Upstream APIs and third-party dependencies may have support cycles that differ from your organization's own, so minimizing exposure to these dependencies can be very beneficial in reducing the work required later on. To this end, it can be helpful to start small with an Operator's design and build on that functionality as needed. This is part of the idea behind the Capability Model, with each level effectively building on the previous.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor170"/>How does an Operator's API relate to its CRD?</h2>
			<p>The API <a id="_idIndexMarker609"/>that an Operator provides is the code definition <a id="_idIndexMarker610"/>of its CRD. When writing an API with the Operator SDK in Go, that API is generated into a CRD using the tools provided by the SDK.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor171"/>What are the conventions for an Operator API?</h2>
			<p>Operator API <a id="_idIndexMarker611"/>conventions generally follow the same upstream Kubernetes conventions as for native API objects. The most important of these is that the Operator object contains two fields, <strong class="source-inline">spec</strong> and <strong class="source-inline">status</strong>, which provide the backbone for the cluster-state-reconciliation loop that Operators run on. <strong class="source-inline">spec</strong> is the user input section of the Operator object, while <strong class="source-inline">status</strong> reports the current functioning conditions of the Operator. </p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor172"/>What is a structural CRD schema?</h2>
			<p>A structural CRD schema is an object definition that enforces known fields in cluster memory. Kubernetes <a id="_idIndexMarker612"/>requires CRDs to define a structural schema, which can be generated with tools provided by the Operator SDK. They provide security advantages and are often complex, owing to the recommendation that they are generated rather than hand-written.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor173"/>What is OpenAPI v3 validation?</h2>
			<p>OpenAPI v3 validation <a id="_idIndexMarker613"/>is a format for providing field type and format validation upon the creation or modification of an object. Field validation is defined in the Go code for the CRD's API types. This validation is in the form of comments (for example, <strong class="source-inline">//+kubebuilder:validation…</strong>). These comments are generated into a validation schema when the Operator CRD is generated.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor174"/>What is Kubebuilder?</h2>
			<p>Kubebuilder is an <a id="_idIndexMarker614"/>open source project that provides a tool for generating Kubernetes APIs and controllers. Many of the commands in the Operator SDK are wrappers for underlying Kubebuilder commands. This is good to know for debugging and support when troubleshooting Operator SDK issues.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor175"/>What is a reconciliation loop?</h2>
			<p>The <strong class="bold">reconciliation loop</strong>, or <strong class="bold">control loop</strong>, is the <a id="_idIndexMarker615"/>main logic function <a id="_idIndexMarker616"/>of an Operator. It is conceptually the continuous cycle of checks an Operator performs to ensure that the actual cluster state matches the desired state. In reality, this is usually not done as a continuous loop but rather as an event-triggered function call.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor176"/>What is the main function of an Operator's reconciliation loop?</h2>
			<p>The Operator's reconciliation loop is its core logic, during which the Operator evaluates the current <a id="_idIndexMarker617"/>state of the cluster, compares that to the desired state, and, if necessary, performs the required actions to reconcile the state of the cluster to match the desired state. This could mean updating a Deployment or tuning workload constraints to react to changing states.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor177"/>What are the two kinds of event triggering?</h2>
			<p>Event triggering <a id="_idIndexMarker618"/>generally falls into two categories: <strong class="bold">level-triggered</strong> and <strong class="bold">edge-triggered</strong>. Operators <a id="_idIndexMarker619"/>are designed following <a id="_idIndexMarker620"/>the level-based triggering approach, in which a triggering event does not contain all <a id="_idIndexMarker621"/>of the context of <a id="_idIndexMarker622"/>the cluster state. Rather, the Operator must receive only enough information from the event to understand the relevant cluster state itself. By rebuilding this information each time, the Operator ensures that no state information is lost due to delays or dropped events. This is in contrast to edge-triggered events (reconciliation activated only by the incoming action of an event), which can result in information loss and are not suitable for large distributed systems such as Kubernetes. These terms stem from electronic circuit design.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor178"/>What is a ClusterServiceVersion (CSV)?</h2>
			<p>A <strong class="source-inline">ClusterServiceVersion</strong> is a CRD provided by the Operator Framework that contains <a id="_idIndexMarker623"/>metadata describing a single version of an Operator. The <strong class="source-inline">ClusterServiceVersion</strong> CRD is provided by the OLM, which is the primary consumer of Operator CSVs. OperatorHub also uses the Operator CSV to present information to users about an Operator.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor179"/>How can Operators handle upgrades and downgrades?</h2>
			<p>Operator versions are defined by their release version, image tag, and CSV metadata. The CSV <a id="_idIndexMarker624"/>in particular provides the concept of upgrade <a id="_idIndexMarker625"/>channels, which allow a developer to define subscription pathways for upgrade and downgrade versions. The OLM then knows how to transition installed Operators between versions thanks to this metadata. Operator API versions are defined in the Operator's CRD, which can contain information about multiple versions. This allows developers to ship an Operator release that supports multiple API versions simultaneously, enabling users to transition between versions within a single release.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor180"/>How can Operators report failures?</h2>
			<p>Operators <a id="_idIndexMarker626"/>have several ways to report issues. These include standard runtime logs, metrics and telemetry, status conditions, and Kubernetes events.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor181"/>What are status conditions?</h2>
			<p>Status conditions <a id="_idIndexMarker627"/>are an Operator's ability to use an upstream Kubernetes API type (<strong class="source-inline">v1.Condition</strong>) that quickly informs a user about various failure (or success) states via an Operator's <strong class="source-inline">status</strong> field in its CRD.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor182"/>What are Kubernetes events?</h2>
			<p>Events are <a id="_idIndexMarker628"/>Kubernetes API objects that can be aggregated, monitored, and filtered by native Kubernetes tools such as <strong class="source-inline">kubectl</strong>. Their definition is richer than that of status conditions, allowing for more advanced information reporting to users.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor183"/>FAQs about the Operator SDK and coding controller logic</h1>
			<p>The topics in <a id="_idIndexMarker629"/>this section focus on the technical development <a id="_idIndexMarker630"/>of an Operator with the Operator SDK. This includes generating an Operator project's initial boilerplate code, filling out the code with custom reconciliation logic, and expanding that code with more advanced features. These <a id="_idIndexMarker631"/>topics <a id="_idIndexMarker632"/>were introduced in <a href="B18147_04_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 4</em></a>, <em class="italic">Developing an Operator with the Operator SDK</em>, and <a href="B18147_05_ePub.xhtml#_idTextAnchor078"><em class="italic">Chapter 5</em></a>, <em class="italic">Developing an Operator – Advanced Functionality</em>.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor184"/>What is the Operator SDK?</h2>
			<p>The Operator SDK is a software development kit that provides code libraries and tools to quickly scaffold <a id="_idIndexMarker633"/>and build an Operator. It is mainly used through the <strong class="source-inline">operator-sdk</strong> binary, which provides commands to initialize projects, create boilerplate APIs and controllers, generate code, and build and deploy Operators in a cluster.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor185"/>How can operator-sdk scaffold a boilerplate Operator project?</h2>
			<p>The <a id="_idIndexMarker634"/>first command to create an Operator SDK project is <strong class="source-inline">operator-sdk init</strong>. This command accepts <a id="_idIndexMarker635"/>additional flags to provide some project information (such as the code repository location of the project) that will later populate variables used when creating other aspects of the Operator (such as the API and controllers).</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor186"/>What does a boilerplate Operator project contain?</h2>
			<p>A <a id="_idIndexMarker636"/>boilerplate Operator project (that is, one that has just been created with <strong class="source-inline">operator-sdk init</strong> and no other changes) contains only a <strong class="source-inline">main.go</strong> file with some basic standard code, a <strong class="source-inline">Dockerfile</strong> file for building a container image, a <strong class="source-inline">Makefile</strong> file, which provides more commands to build and deploy an Operator, and some additional directories of config files and dependencies.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor187"/>How can you create an API with operator-sdk?</h2>
			<p>The <strong class="source-inline">operator-sdk create api</strong> command <a id="_idIndexMarker637"/>initializes a template API file structure to be filled in by the developer. It accepts additional flags to define the API version and the Operator's resource name, and can even create the boilerplate controller for the Operator to handle the API object.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor188"/>What does a basic Operator API created with operator-sdk look like?</h2>
			<p>The empty <a id="_idIndexMarker638"/>template API created by <strong class="source-inline">operator-sdk create api</strong> contains a basic definition for the Operator's <strong class="source-inline">config</strong> object. This object comprises upstream metadata types (containing fields such as <strong class="source-inline">namespace</strong> and <strong class="source-inline">name</strong>) as well as two sub-objects, representing the <strong class="source-inline">spec</strong> and <strong class="source-inline">status</strong> fields of the Operator's CRD.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor189"/>What other code is generated by operator-sdk?</h2>
			<p>Along with <a id="_idIndexMarker639"/>the boilerplate template <a id="_idIndexMarker640"/>code, which is meant to be modified by the developer, the <strong class="source-inline">operator-sdk</strong> command also generates <strong class="source-inline">deepcopy</strong> and other code that is used by Kubernetes clients but should not be modified. Therefore, it's important to regularly re-run the code generators provided by <strong class="source-inline">operator-sdk</strong> to ensure this auto-generated code stays up to date. </p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor190"/>What do Kubebuilder markers do?</h2>
			<p>Kubebuilder markers <a id="_idIndexMarker641"/>are specially formatted code comments placed on API object fields, types, and packages. They define field validation settings (such as type, length, and pattern) and other options that control the Operator's CRD generation. They allow such options to be configured in a location that makes them very clear, right next to the relevant code. </p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor191"/>How does the Operator SDK generate Operator resource manifests? </h2>
			<p>The <a id="_idIndexMarker642"/>Operator SDK generates <a id="_idIndexMarker643"/>the relevant resource manifests (including the Operator's CRD, as well as other required resources such as <strong class="bold">RoleBindings</strong>) with <a id="_idIndexMarker644"/>the <strong class="source-inline">make manifests</strong> command. This command is defined in the standard <strong class="source-inline">Makefile</strong> file in a basic Operator project, and it invokes the <strong class="source-inline">controller-gen</strong> binary (part of the Kubebuilder toolset) to do the generation.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor192"/>How else can you customize generated Operator manifests?</h2>
			<p>Generated <a id="_idIndexMarker645"/>Operator manifests can be customized beyond what is done by default with the <strong class="source-inline">controller-gen</strong> tool. This program is the underlying component responsible for much of the generated resource files, and running it manually offers access to additional commands and flags.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor193"/>What are go-bindata and go:embed?</h2>
			<p><strong class="source-inline">go-bindata</strong> and <strong class="source-inline">go:embed</strong> are two ways to compile raw files into Go code. The former is <a id="_idIndexMarker646"/>a package that can be imported into projects as a library, while the <a id="_idIndexMarker647"/>latter is a native Go compiler directive. Both are useful options for making Operator-related resources (such as an Operand Deployment YAML file) accessible in the code and readable for other users.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/>What is the basic structure of a control/reconciliation loop?</h2>
			<p>For most <a id="_idIndexMarker648"/>Operators, the basic structure of a control loop follows these steps:</p>
			<ol>
				<li value="1">Retrieve the desired configuration of the Operator/cluster.</li>
				<li>Assess the current state of the cluster, with the information available to the Operator, and compare this to the desired configuration.</li>
				<li>If needed, take action to transition the current cluster state toward the desired state.</li>
			</ol>
			<p>At each <a id="_idIndexMarker649"/>of these steps, Operators should also implement error checking and status reporting branches to report any failures to the user (for example, if the Operator is unable to find its own configuration, it should obviously not proceed).</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor195"/>How does a control loop function access Operator config settings?</h2>
			<p>The main <a id="_idIndexMarker650"/>control loop <a id="_idIndexMarker651"/>function (<strong class="source-inline">Reconcile()</strong> in Operator SDK projects) accesses the Operator's config settings through its CR object. This requires that the user has created an instance of the CR object in the cluster (as defined by the CRD). Since CR objects are accessible through the Kubernetes API, the Operator is able to use Kubernetes clients and functions such as <strong class="source-inline">Get()</strong> to retrieve its config. In the Operator SDK, these clients are automatically populated and passed to the <strong class="source-inline">Reconcile()</strong> function, ready to use.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/>What information does a status condition report?</h2>
			<p>A <strong class="source-inline">v1.Condition</strong> object contains fields describing the status: <strong class="source-inline">type</strong> (a short name for the status), <strong class="source-inline">status</strong> (a Boolean value indicating the status), and <strong class="source-inline">reason</strong> (a longer description <a id="_idIndexMarker652"/>providing more information to the user). It also contains timestamp information regarding the last transition timestamp of the status.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/>What are the two basic kinds of metrics?</h2>
			<p>Metrics fall <a id="_idIndexMarker653"/>into roughly two categories: <strong class="bold">service metrics</strong> and <strong class="bold">core metrics</strong>. Service <a id="_idIndexMarker654"/>metrics are metrics that have been <a id="_idIndexMarker655"/>defined as <a id="_idIndexMarker656"/>custom for a specific component (or service), while <a id="_idIndexMarker657"/>core metrics are common metrics published by all services (such as CPU and memory usage). </p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/>How can metrics be collected?</h2>
			<p>Core <a id="_idIndexMarker658"/>metrics can be collected <a id="_idIndexMarker659"/>using the <strong class="source-inline">metrics-server</strong> component (<a href="https://github.com/kubernetes-sigs/metrics-server">https://github.com/kubernetes-sigs/metrics-server</a>). Service <a id="_idIndexMarker660"/>metrics can be collected by any metrics aggregation tool, such as Prometheus.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/>What are RED metrics?</h2>
			<p><strong class="bold">Rate, errors, and duration</strong> (<strong class="bold">RED</strong>) is an acronym describing the best practices <a id="_idIndexMarker661"/>for defining new metrics. It is recommended that the three key kinds of metrics for a service should include rate, errors, and duration. This means reporting the number of requests per period, the number of failed attempts, and the latency for a request, respectively.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor200"/>What is leader election?</h2>
			<p>Leader election is <a id="_idIndexMarker662"/>the concept of running multiple copies of an application, with one copy (the leader) working at a time. This provides high availability for the application because if one replica fails, there are others ready to take its place. This concept applies to Operators, because it may be necessary to ensure Operator uptime in a distributed system.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor201"/>What are the two main strategies for leader election?</h2>
			<p>Leader election <a id="_idIndexMarker663"/>can be implemented as either leader-with-lease or leader-for-life. The leader-with-lease approach is the default strategy for Operator SDK projects, and in it, the current leader makes periodic attempts to renew its status. This allows leader transitions to happen quickly, should they need to occur. In leader-for-life approaches, the leader only relinquishes its status when it is deleted. This makes recovery slower, but more definitive. </p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor202"/>What are health and ready checks?</h2>
			<p>Health and ready checks <a id="_idIndexMarker664"/>are watchdog endpoints that allow an application to indicate when it is healthy (that is, running smoothly) and ready (that is, actively prepared to serve requests). The Operator SDK provides basic health and ready checks with a boilerplate project, but these can easily be extended to accommodate custom logic.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor203"/>FAQs about OperatorHub and the OLM</h1>
			<p>These questions <a id="_idIndexMarker665"/>relate to the building, shipping, and deployment <a id="_idIndexMarker666"/>of Operators. Topics covered include installing Operators with the OLM and submitting Operators to OperatorHub. These topics come from <a href="B18147_06_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 6</em></a>, <em class="italic">Building and Deploying Your Operator</em>, and <a href="B18147_07_ePub.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>, <em class="italic">Installing and Running Operators with the Operator Lifecycle Manager</em>.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor204"/>What are the different ways to compile an Operator?</h2>
			<p>Like many <a id="_idIndexMarker667"/>cloud-native applications, an Operator can be compiled either as a local binary or built into a container image suitable for deploying directly onto a Kubernetes cluster. The Operator SDK provides commands to do both.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor205"/>How does a basic Operator SDK project build a container image?</h2>
			<p>The Operator <a id="_idIndexMarker668"/>SDK provides <strong class="source-inline">Makefile</strong> targets to build a Docker image with <strong class="source-inline">make docker-build</strong>. By default, this copies the main Operator source code (specifically, the main controller and API) along with its <strong class="source-inline">assets</strong> directory to the Docker image.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor206"/>How can an Operator be deployed in a Kubernetes cluster?</h2>
			<p>Operators <a id="_idIndexMarker669"/>can be deployed manually once <a id="_idIndexMarker670"/>the Docker image has been built, similar to how any other application is deployed in a Kubernetes cluster. The Operator SDK simplifies this with the <strong class="source-inline">make deploy</strong> command. Operators can also be installed with the OLM.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor207"/>What is the OLM?</h2>
			<p>The OLM is <a id="_idIndexMarker671"/>a component provided by the Operator Framework to manage the installation, running, and upgrade/downgrade of Operators in a cluster.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor208"/>What benefit does running an Operator with the OLM provide?</h2>
			<p>The OLM provides a convenient tool to install Operators (as opposed to methods such as manually <a id="_idIndexMarker672"/>deploying the Operator image), as well as monitor the Operator status in a cluster. It can ensure that an Operator does not create any conflicts with other Operators. It can also handle upgrades and downgrades of Operators in the cluster. Finally, it makes the list of installed Operators in the cluster available to users.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor209"/>How do you install the OLM in a cluster?</h2>
			<p>The OLM <a id="_idIndexMarker673"/>can be installed with the <strong class="source-inline">operator-sdk</strong> binary by running <strong class="source-inline">operator-sdk olm install</strong>. </p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor210"/>What does the operator-sdk olm status command show?</h2>
			<p>Running <strong class="source-inline">operator-sdk olm status</strong> (after installing OLM in the cluster) shows the OLM's <a id="_idIndexMarker674"/>health by listing its required resources (including the CRDs it installs, its RoleBindings, Deployment, and namespaces).</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor211"/>What is an Operator bundle?</h2>
			<p>A bundle <a id="_idIndexMarker675"/>is a format <a id="_idIndexMarker676"/>for packaging an Operator's manifests <a id="_idIndexMarker677"/>and <strong class="bold">ClusterServiceVersion</strong> (<strong class="bold">CSV</strong>).</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor212"/>How do you generate a bundle?</h2>
			<p>With the Operator SDK, a bundle can be generated by running <strong class="source-inline">make bundle</strong>. This command is <a id="_idIndexMarker678"/>interactive and will ask for information about the Operator and your organization, which will then be compiled into the Operator's metadata in the bundle.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor213"/>What is a bundle image?</h2>
			<p>A bundle image is <a id="_idIndexMarker679"/>a container image that holds the information from the Operator's bundle. The image is used to deploy an Operator in a cluster, based on the underlying metadata.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor214"/>How do you build a bundle image?</h2>
			<p>A bundle image <a id="_idIndexMarker680"/>can be built with the Operator SDK by running <strong class="source-inline">make bundle-build</strong>. This builds the basic Docker image that holds the bundle information.</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor215"/>How do you deploy a bundle with the OLM?</h2>
			<p>The <strong class="source-inline">operator-sdk run bundle</strong> command deploys a bundle image into a cluster with <a id="_idIndexMarker681"/>the OLM. This command takes an additional <a id="_idIndexMarker682"/>argument, which is the location of the bundle image in a container registry, for example, <strong class="source-inline">operator-sdk run bundle docker.io/myreg/myoperator-bundle:v0.0.1</strong>.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor216"/>What is OperatorHub?</h2>
			<p>OperatorHub is <a id="_idIndexMarker683"/>a centralized index of published Operators from various developers and organizations. Its website is <a href="https://operatorhub.io">https://operatorhub.io</a>. For each Operator, it provides information about the Operator and developer as well as installation guides and links to support resources and source code. It does this by parsing information from the Operator's bundle (mainly from the Operator CSV). </p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor217"/>How do you install an Operator from OperatorHub?</h2>
			<p>Each Operator's <a id="_idIndexMarker684"/>page on OperatorHub includes <a id="_idIndexMarker685"/>a link to installation instructions. These instructions include a series of simple commands, usually using <strong class="source-inline">kubectl create</strong>:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_9.1_B18147.jpg" alt="Figure 9.1 – Screenshot of OperatorHub installation instructions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Screenshot of OperatorHub installation instructions</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor218"/>How do you submit an Operator to OperatorHub?</h2>
			<p>Listing an <a id="_idIndexMarker686"/>Operator on OperatorHub involves <a id="_idIndexMarker687"/>creating a <strong class="bold">pull request</strong> (<strong class="bold">PR</strong>) to the GitHub repository, which serves as the backend index powering OperatorHub. The requirements include submitting a valid CSV file in a directory structure that is easily copied from the output of the Operator SDK bundle generation commands. Automated tests check that all requirements for submission have been met and merge the submission PR, with the Operator being listed on <a href="https://operatorhub.io">https://operatorhub.io</a> soon after.</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor219"/>Future trends in the Operator Framework</h1>
			<p>This section <a id="_idIndexMarker688"/>refers to the future maintenance of your own Operator, as well as the alignment with ongoing work in the upstream Kubernetes community and how that relates to third-party Operator development. These topics are from <a href="B18147_08_ePub.xhtml#_idTextAnchor126"><em class="italic">Chapter 8</em></a>,<em class="italic"> Preparing for Ongoing Maintenance of Your Operator</em>.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor220"/>How do you release a new version of an Operator?</h2>
			<p>Releasing a new version of an Operator is mostly dependent on your organization's release <a id="_idIndexMarker689"/>methods regarding timing and delivery infrastructure. But, the Operator Framework provides ways to denote your Operator's version in the form of the version field in the Operator's CSV (which is shown on OperatorHub), new API versions, and release channels.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor221"/>When is it appropriate to add a new API version?</h2>
			<p>The most common time to add a new API version is when you are introducing a breaking change to <a id="_idIndexMarker690"/>the existing API. It can also be appropriate to increase the API's version as an indicator of its stability level (for example, promoting a <strong class="source-inline">v1alpha1</strong> API to <strong class="source-inline">v1beta1</strong> or <strong class="source-inline">v1</strong>). It is most important to follow the support timelines you have chosen to establish (or the Kubernetes timeline, if you have chosen to adopt those as a template) when replacing an old API version with a new one.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor222"/>How do you add a new API version?</h2>
			<p>A new API <a id="_idIndexMarker691"/>can be added with the <strong class="source-inline">operator-sdk create api</strong> command. This command scaffolds the empty Go files just as when creating the Operator's initial API in a project. Once these files are filled out with the new API types, the corresponding generated code, CRD, and other manifests can be updated with the <strong class="source-inline">make generate</strong> and <strong class="source-inline">make manifests</strong> commands.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor223"/>What is an API conversion?</h2>
			<p>An API conversion <a id="_idIndexMarker692"/>refers to an Operator's ability to transcribe API objects between incompatible versions of the same API. Conversion code in an Operator allows it to support multiple versions of its API within the same release. This is usually done by developers writing manual conversion logic to ensure that the incompatible fields between the two APIs can translate back and forth (round-trip) without losing any data. The biggest benefit of this is allowing users to transition from a deprecated API to a newer version seamlessly.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor224"/>How do you convert between two versions of an API?</h2>
			<p>When designing a new API, consider how the existing information in an older version can be <a id="_idIndexMarker693"/>accurately translated to the new version and back. Then, you can convert between two versions of an API by implementing a conversion webhook in your Operator's code.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor225"/>What is a conversion webhook?</h2>
			<p>A conversion <a id="_idIndexMarker694"/>webhook is an endpoint that is exposed in your Operator's Pod that accepts requests from the API server to encode and decode API objects between different versions.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor226"/>How do you add a conversion webhook to an Operator?</h2>
			<p>A conversion <a id="_idIndexMarker695"/>webhook consists of two Go interfaces <a id="_idIndexMarker696"/>that must be implemented for the API object types that are being converted. These are the <strong class="source-inline">Convertible</strong> and <strong class="source-inline">Hub</strong> interfaces from <strong class="source-inline">sigs.k8s.io/controller-runtime/pkg/conversion</strong>. Most importantly, the <strong class="source-inline">Convertible</strong> interface requires two functions, <strong class="source-inline">ConvertTo()</strong> and <strong class="source-inline">ConvertFrom()</strong>, which are where a developer manually writes the logic to translate fields between the two objects. Then, the webhook manifests that expose the relevant endpoint can be created with the <strong class="source-inline">operator-sdk create webhook</strong> command. These manifests are then enabled by uncommenting the webhook references within the project's <strong class="source-inline">Kustomization</strong> files.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor227"/>What is kube-storage-version-migrator?</h2>
			<p><strong class="bold">kube-storage-version-migrator</strong> is a tool that allows Kubernetes users to manually convert <a id="_idIndexMarker697"/>their existing stored API objects to a new API version. This can be useful to help progress updates between Operator versions where a new API changes the storage version of the Operator's CRD object.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor228"/>How do you update an Operator's CSV?</h2>
			<p>An Operator's CSV <a id="_idIndexMarker698"/>holds information about the Operator, including its current version. To increase the Operator's version, the CSV should first be updated to indicate the previous version of the Operator with the <strong class="source-inline">replaces</strong> field. In other words, this tells tools such as the OLM which version precedes the new version so that it can upgrade to the right version. Then, the <strong class="source-inline">VERSION</strong> variable in the Operator project's <strong class="source-inline">Makefile</strong> should be updated to the new version number (for example, <strong class="source-inline">0.0.2</strong>). The new CSV is generated with the <strong class="source-inline">make bundle</strong> and <strong class="source-inline">make bundle-build</strong> commands.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor229"/>What are upgrade channels?</h2>
			<p>Upgrade channels <a id="_idIndexMarker699"/>are a way to offer different distribution upgrade pathways. For example, an Operator's CSV can define <strong class="source-inline">alpha</strong> and <strong class="source-inline">stable</strong> channels. Users can then choose to subscribe to either channel to get updated versions at the cadence and stability level they desire.</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor230"/>How do you publish a new version on OperatorHub?</h2>
			<p>OperatorHub <a id="_idIndexMarker700"/>hosts Operator information in bundles on GitHub. Each Operator has its own unique directory, with every different version of that Operator as its own subdirectory. These subdirectories each hold the bundle information (such as its CSV) for that version.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor231"/>What is the Kubernetes deprecation policy?</h2>
			<p>The Kubernetes <a id="_idIndexMarker701"/>deprecation policy defines the API version support guidelines for core Kubernetes components. This provides downstream and third-party developers (as well as users) with a guaranteed timeline for support based on an API's stability. It is also a good template for other projects that are not strictly beholden to the policy but wish to align with the upstream Kubernetes policy for consistency.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor232"/>How can API elements be removed in the Kubernetes deprecation policy?</h2>
			<p>In the <a id="_idIndexMarker702"/>Kubernetes deprecation <a id="_idIndexMarker703"/>policy, API elements can only be removed by incrementing the API version. In other words, if an Operator is following the Kubernetes deprecation policy, then it cannot remove a CRD field from the current API. It must, instead, create a new API version that does not have the field.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor233"/>How long are API versions generally supported?</h2>
			<p>The support <a id="_idIndexMarker704"/>timeline for an API version in the Kubernetes deprecation policy depends on its stability level (alpha, beta, or GA). Alpha APIs have no guaranteed timeline and can be changed at any time. Beta APIs are supported for 9 months or three releases (whichever is longer). Graduated GA APIs cannot be removed, but they can be marked as deprecated.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor234"/>How long is the Kubernetes release cycle?</h2>
			<p>The Kubernetes <a id="_idIndexMarker705"/>release cycle for a minor version is about 15 weeks long and contains several milestone dates, including Enhancements Freeze, Code Freeze, and Retrospective.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor235"/>What is Enhancements Freeze?</h2>
			<p>Enhancements Freeze <a id="_idIndexMarker706"/>is the point during the release cycle at <a id="_idIndexMarker707"/>which <strong class="bold">Kubernetes Enhancements</strong> (<strong class="bold">KEPs</strong>) must be implementable and committed to the release or officially delayed to at least the next release.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor236"/>What is Code Freeze?</h2>
			<p>At Code Freeze, all significant <a id="_idIndexMarker708"/>code changes must be merged into the current release or otherwise obtain an exception for a reasonable extension.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor237"/>What is Retrospective?</h2>
			<p>Retrospective is <a id="_idIndexMarker709"/>a series of meetings leading up to and following the Kubernetes release in which community members reflect on the successful areas of the release and pinpoint processes that can use improvement.</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor238"/>How do Kubernetes community standards apply to Operator development?</h2>
			<p>Operator <a id="_idIndexMarker710"/>developers have no requirement to adhere to the Kubernetes community standards or participate <a id="_idIndexMarker711"/>in upstream development. However, an awareness of how the Kubernetes project functions is helpful to Operator developers because it offers guidelines for feature support, and Operators are very often dependent on certain Kubernetes features. These standards also provide a template for an Operator's own development processes that can be presented to the Operator's users.</p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor239"/>Summary</h1>
			<p>There are obviously too many topics to cover in a discussion about the Operator Framework to distill them all into a single chapter of bite-sized trivia. But, to serve as a refresher (or crash course), the goal of this chapter was to recap the most important points that were already discussed, in a way that briefly explains them all, start to finish. For a deeper dive into any of these topics, the chapters they originated from have been provided as a resource. There are also any one of the many fantastic references that have been listed throughout this book to give support and further reading on all of these topics.</p>
			<p>In the next chapters, we will examine real-world Operators that have been developed in the open source community. By doing so, we have the opportunity to relate each of the previous topics to a concrete example and compare the similarities and differences between what was done with the samples provided in this book and a real Operator.</p>
		</div>
	</body></html>