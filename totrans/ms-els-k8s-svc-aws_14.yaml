- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Setting Load Balancing for Applications on EKS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 EKS 上为应用设置负载均衡
- en: In [*Chapter 4*](B18129_04.xhtml#_idTextAnchor067), we looked at how you can
    use a NodePort, Ingress, and/or AWS **Load Balancer** (**LB**) to expose a simple
    application. In this chapter, we will dive into more detail on how to scale and
    provide greater resilience in your application using **AWS Elastic Load** **Balancers**
    (**ELBs**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B18129_04.xhtml#_idTextAnchor067) 中，我们探讨了如何使用 NodePort、Ingress 和/或
    AWS **负载均衡器** (**LB**) 来暴露一个简单的应用。在本章中，我们将更详细地讨论如何使用 **AWS 弹性负载均衡器** (**ELB**)
    扩展和提升应用的弹性。
- en: 'In most modern web or cloud-native applications, you want to ensure that the
    application is available to its client (resilient) and copes as the Kubernetes
    scheduler scales your application by replacing, removing, and adding Pods when
    necessary. Placing an LB in front of your application allows these Kubernetes
    actions to be hidden from the client, which has a consistent endpoint to access
    the application regardless of the location or number of Pods. Hence, specifically,
    we will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现代 Web 或云原生应用中，你需要确保应用对客户端可用（具备弹性），并且当 Kubernetes 调度器通过替换、移除和添加 Pods 来扩展应用时，应用能够应对这种变化。在应用前面放置负载均衡器可以将这些
    Kubernetes 操作隐藏起来，使客户端无论 Pods 的位置或数量如何，都能通过一个一致的端点访问应用。因此，在本章中，我们将专门讨论以下主题：
- en: What LBs are available in AWS, and how to choose the right one for your needs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 AWS 中有哪些负载均衡器（LB）可用，以及如何选择适合你需求的负载均衡器
- en: How EKS can create and use AWS LBs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 EKS 中创建和使用 AWS 负载均衡器
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You should be familiar with YAML, AWS **Identity and Access Management** (**IAM**),
    and **Elastic Kubernetes Service** (**EKS**) architecture. Before getting started
    with this chapter, please ensure that you have the following in place:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该熟悉 YAML、AWS **身份与访问管理** (**IAM**) 和 **弹性 Kubernetes 服务** (**EKS**) 架构。在开始本章之前，请确保你已经具备以下条件：
- en: Network connectivity to your EKS cluster API endpoint
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到 EKS 集群 API 端点的网络
- en: The AWS `kubectl` binary are installed on your workstation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS `kubectl` 二进制文件已安装在你的工作站上
- en: A basic understanding of AWS networking
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 AWS 网络的基本理解
- en: Choosing the right load balancer for your needs
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的需求选择合适的负载均衡器
- en: 'One of the key characteristics of a modern, cloud-based application is to be
    able to scale horizontally (adding more instances to meet demand or recover from
    failure). In [*Chapter 4*](B18129_04.xhtml#_idTextAnchor067), we looked at how
    you can use deployments to create and manage multiple Pods, but you also need
    to distribute user traffic over those Pods. This is what an LB does, and we will
    work with two main types in EKS: the **Application Load Balancer** (**ALB**) and
    the **Network Load Balancer** (**NLB**), which are both types of ELB. In the next
    two sections, we will consider two key concepts that can be applied to any LB.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现代云应用的一个关键特性是能够横向扩展（增加更多实例以满足需求或从故障中恢复）。在 [*第 4 章*](B18129_04.xhtml#_idTextAnchor067)
    中，我们探讨了如何使用部署来创建和管理多个 Pods，但你还需要将用户流量分配到这些 Pods 上。这正是负载均衡器（LB）所做的事情，我们将在 EKS 中处理两种主要类型：**应用程序负载均衡器**
    (**ALB**) 和 **网络负载均衡器** (**NLB**)，它们都是 ELB 类型。在接下来的两节中，我们将探讨适用于任何负载均衡器的两个关键概念。
- en: Concept 1 – understanding Layer 4 and Layer 7 load balancer networking
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概念 1 – 理解第四层和第七层负载均衡器的网络
- en: When we talk about layers in a networking context, we are talking about the
    **Open Systems Interconnection** (**OSI**) model, which was developed in the 1980s
    to simplify interconnection between different networks. The OSI model describes
    a seven-layer model in which the top layer, Layer 7 (application), describes the
    interface that applications use. Layer 4 (transport) describes how lower-level
    protocols, such as **User Datagram Protocol** (**UDP**)/**Transmission Control
    Protocol** (**TCP**), should behave. A complete description of the OSI model is
    out of the scope of this book, but it’s worth noting that Layer 3 (networks) can
    be used to describe the underlying networks, which in 99% of cases will be either
    IPv4 or IPv6 (unless you are describing a **wide area** **network** (**WAN**)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论网络中的层次时，我们指的是 **开放系统互联** (**OSI**) 模型，该模型是在 1980 年代开发的，用以简化不同网络之间的互联。OSI
    模型描述了一个七层模型，其中最上层，第七层（应用层），描述了应用程序使用的接口。第四层（传输层）描述了低层协议，如 **用户数据报协议** (**UDP**)/**传输控制协议**
    (**TCP**) 的行为。OSI 模型的完整描述超出了本书的范围，但值得注意的是，第三层（网络层）可用于描述底层网络，这在 99% 的情况下将是 IPv4
    或 IPv6（除非你描述的是 **广域网** (**WAN**)）。
- en: LBs that operate at Layer 7 have an understanding of the application protocols,
    such as HTTP/HTTPS, and will inspect and distribute traffic using HTTP paths/URLs
    and can perform actions such as redirection and health checks. It’s worth noting
    that as HTTPS is encrypted, the LB must act as a proxy (see *Concept 2 – understanding
    proxy and DSR modes*) and, in most cases, will terminate traffic from the client
    before forwarding it to a (backend) service.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: LBs that operate at Layer 3/4 have no understanding of higher-layer protocols,
    such as HTTP/HTTPS, and work at a lower level. That means they can support web
    applications and other traffic, such as **Secure Shell Protocol** (**SSH**) or
    **Simple Mail Transfer Protocol** (**SMTP**). As these LBs operate at a lower
    level, they can’t inspect HTTP headers, so how they inspect and distribute network
    traffic is much simpler, and they tend to be faster. It also means they can operate
    as both a **proxy** and in **Direct Server Return** (**DSR**) mode.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the two types of LBs. Both LBs see the client
    traffic (denoted by the `1.1.1.1` IP address in the diagram) and can do the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Serve web traffic to the Layer 7 LB and understand the HTTP verbs (`POST` in
    the diagram) and the path or URL (`/users/user` in the diagram)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distribute traffic on them, whereas the Layer 4 LB will simply see the type
    of traffic (in the case of HTTP/HTTPS TCP) and the port (`8080` in the diagram)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 14.1 – L7 versus L4 LB](img/B18129_14_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – L7 versus L4 LB
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the differences between the network layers, let’s review the
    differences between proxy and **DSR** modes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Concept 2 – understanding proxy and DSR modes
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To inspect the HTTPS traffic (which is encrypted), the LB needs to terminate
    it, so this normally means it holds the encryption certificate. This model is
    known as a **reverse proxy mode**, as the LB will proxy the request to the backend
    server(s) on behalf of the client. This can be seen in the following diagram,
    where the source IP address of the client is replaced by the LB, which means that
    the request and the response traffic go through the LB:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Comparison of proxy and DSR modes](img/B18129_14_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Comparison of proxy and DSR modes
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'In DSR, the return/response traffic goes directly to the client. This means
    that the LB handles fewer requests and can theatrically scale more with less latency
    being introduced into the request/response traffic. It also means that the backend
    (web service) needs to know the client’s IP address and be able to route back
    to it. The following table describes each of the steps in the previous diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Proxy Request–Response** | **DSR Request–Response** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: '| 1 | A **Domain Name System** (**DNS**) request for the service IP address
    resolves to the IP address of the LB, and traffic is sent to the LB IP address
    from the client’s IP. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| 2 | HTTP/HTTPS traffic is inspected, and based on the protocol type/URL/port,
    the traffic is sent to a set of registered backend servers (targets) typically
    based on their health/load or on a round-robin basis. The client IP address is
    normally added to the **X-Forwarded-For** header so that the backend server can
    identify where the request has come from, but this is optional. | UDP/TCP traffic
    is inspected, and based on the protocol type/port, the traffic is sent to a set
    of registered backend servers (targets) typically on a round-robin basis using
    a Layer 2 address such as a `X-header`, so the backend knows how to return the
    traffic, but the approach will vary depending on how the LB is implemented. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 2 | HTTP/HTTPS流量会被检查，并根据协议类型/URL/端口，流量会被发送到一组已注册的后端服务器（目标），通常基于其健康状况/负载或使用轮询方式。客户端IP地址通常会被添加到**X-Forwarded-For**头部，以便后端服务器可以识别请求来自何处，但这是可选的。
    | UDP/TCP流量会被检查，并根据协议类型/端口，流量会被发送到一组已注册的后端服务器（目标），通常使用轮询方式，通过Layer 2地址（如`X-header`）进行，因此后端知道如何返回流量，但该方法会根据负载均衡器的实现方式有所不同。
    |'
- en: '| 3 | The request is handled by the backend, and the `X-Forwarded-for` header
    may be used to validate the request. The response is sent back to the LB. | The
    request is handled by the backend. The response is sent back to the client using
    either the preserved source IP address of `X-header` or by mimicking the LB IP.
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 请求由后端处理，`X-Forwarded-for`头部可用于验证请求。响应被发送回LB。 | 请求由后端处理。响应通过保留的源IP地址的`X-header`或模仿LB
    IP返回给客户端。 |'
- en: '| 4 | The LB returns the response to the client. | This step is not needed
    for a DR router as the response is returned to the client in the previous step.
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 4 | LB将响应返回给客户端。 | 对于DR路由器，这一步不需要，因为响应已经在上一步返回给客户端。 |'
- en: Table 14.1 – Request/response steps
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.1 – 请求/响应步骤
- en: Now we have looked at how a generic balancer works, let’s look at the options
    available in AWS.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一个通用负载均衡器是如何工作的，让我们来看看AWS中可用的选项。
- en: Which load balancers are available in AWS?
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在AWS中有哪些负载均衡器可用？
- en: 'There are a number of different types of LBs available in AWS, but we will
    focus on the two types of ELBs commonly used with EKS: the ALB and the NLB. An
    ELB can be either external or internal, but not both. External means that it is
    accessible from the internet, and internal means it can only be accessed from
    the **virtual private cloud** (**VPC**) or internal addresses that have a route
    to the VPC hosting the ELB. The following diagram illustrates both ELB options
    available in AWS:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: AWS中有多种类型的负载均衡器，但我们将重点讨论EKS常用的两种ELB类型：ALB和NLB。ELB可以是外部的，也可以是内部的，但不能同时是两者。外部表示它可以从互联网访问，内部表示只能从**虚拟私有云**（**VPC**）或具有路由访问该ELB所在VPC的内部地址访问。下图展示了AWS中可用的两种ELB选项：
- en: '![Figure 14.3 – AWS ELB](img/B18129_14_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3 – AWS ELB](img/B18129_14_03.jpg)'
- en: Figure 14.3 – AWS ELB
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – AWS ELB
- en: 'Both LBs are configured using three key concepts:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种负载均衡器（LB）是通过三个关键概念来配置的：
- en: You create an instance of an NLB or ALB and connect it to a VPC.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你创建一个NLB或ALB的实例，并将其连接到一个VPC。
- en: You configure a listener, defining the protocol and either a port (NLB) or a
    URL path (ALB) that the LB will accept traffic on.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要配置监听器，定义负载均衡器将接受流量的协议以及端口（NLB）或URL路径（ALB）。
- en: You configure a target group, which defines the targets for the traffic sent
    to it from the LB listener. It also defines the health checks needed to ensure
    that the targets are healthy and can respond to traffic.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你配置一个目标组，定义从LB监听器发送到它的流量的目标。它还定义了需要的健康检查，以确保目标是健康的并且能够响应流量。
- en: The ALB works as an Layer 7 proxy, so it can handle HTTP/HTTPS and HTTPv2\.
    So if your application uses RESTful or gRPC-based APIs, an ALB will be able to
    support the traffic. The ALB can send traffic to targets based on *registered*
    IP addresses (both VPC addresses and on-premises, in the RFC 1918 address range,
    as long as there is a VPC route), EC2 instances, and Lambda functions. The ALB
    attaches to the VPC’s availability zones and scales to meet traffic demands. So
    AWS provides a DNS **Canonical Name** (**CNAME**) record as its reference, as
    it may have multiple network interfaces in a VPC, and the IP addresses associated
    with the ALB can change. An ALB has an associated security group, meaning you
    can control access to either its public or private interfaces.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Support for gRPC is limited, so while the ALB can forward gRPC traffic, it can’t
    make traffic distribution decisions in the same way it can with RESTful APIs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'The NLB lives in the AWS **software-defined networking** (**SDN**) fabric and
    so it works quite differently from the ALB. The NLB works as an Layer-4 LB, supporting
    both a proxy and DSR mode, depending on the type of backend servers and protocols
    configured. The following are examples of these:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: If the backend services are specified by the EC2 instance ID they reside on,
    the client IP is preserved and visible to your backend service.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the backend’s services are specified by IP address, then we see the following:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the target group protocol is TCP/**Transport Layer Security** (**TLS**),
    client IP preservation is disabled, and the backend service sees the LB as the
    source of the traffic (the client IP address can be accessed through the proxy
    protocol headers)
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the target group protocol is UDP/TCP_UDP, the client IP is preserved and
    is visible to your backend service
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if the backend sees the client IP address, as the NLB is an SDN construct,
    return traffic is sent back through the NLB without any additional configuration.
    This means that the client only sees the NLB addresses, and you don’t have asymmetrical
    routing where the response goes to one IP and the response comes back from another.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: This *return traffic magic* is not explained by AWS but ensures that any traffic
    that is in the VPC will be routed back to the NLB even if the client IP address
    is the source IP; outside the VPC, you may get different, asymmetrical routing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The NLB can send traffic to targets based on *registered* IP addresses (both
    VPC addresses and on-premises in the RFC 1918 address range, as long as there
    is a VPC route), EC2 instances, and ALBs. The NLB attaches to VPCs through fixed
    **Elastic Network Interfaces** (**ENIs**), so AWS provides these IP addresses
    (public or private), so once allocated, the IP addresses remain the same and don’t
    change. The NLB has *no* associated security group, so external NLBs are *open*
    to the internet. As you can see, while there are similarities between these two
    ELBs, there are also differences. In the next section, let’s look at how you can
    choose which one to use.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: NLB可以根据*注册*的IP地址（包括VPC地址和在RFC 1918地址范围内的本地地址，只要有VPC路由），EC2实例和ALB将流量发送到目标。NLB通过固定的**弹性网络接口**（**ENIs**）附加到VPC，因此AWS提供这些IP地址（公有或私有），一旦分配，IP地址将保持不变且不会更改。NLB没有*关联*的安全组，因此外部的NLB是*开放*的，能接入互联网。正如你所见，尽管这两种ELB有相似之处，但也存在差异。在接下来的部分，我们将看看如何选择适合的ELB。
- en: Choosing the right ELB
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择合适的ELB
- en: 'Imagine the scenario where you want to expose a simple microservice running
    on EKS to the outside world in a scalable and resilient manner. Which ELB would
    you choose? Of course, we would assume that both ELB types are available in your
    desired Region! Here are some questions you might want to ask to help you make
    your decision:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你想将运行在EKS上的简单微服务以可扩展和弹性的方式暴露给外部世界。你会选择哪个ELB？当然，我们假设你想要的区域中两种ELB类型都可用！以下是一些你可能需要问的问题，帮助你做出决定：
- en: What type of interface are you exposing? If it’s not based on HTTP/HTTPS or
    HTTPv2, you will need to use an NLB.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你要暴露的是哪种类型的接口？如果不是基于HTTP/HTTPS或HTTPv2，你将需要使用NLB。
- en: Do you want to offload encryption? If so, in most cases, you will want to use
    SSL/TLS, and in a lot of cases, you will offload the encryption/decryption process
    to the ELB. Both NLBs and ALBs support this, but if you want your Pod to do the
    encryption/decryption (end-to-end encryption), you will need an NLB, as it can
    pass the traffic through to the Pods.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否希望卸载加密？如果是，在大多数情况下，你会想使用SSL/TLS，而且在很多情况下，你会将加密/解密过程卸载到ELB上。NLB和ALB都支持这一点，但如果你希望Pod进行加密/解密（端到端加密），你将需要一个NLB，因为它可以将流量传递到Pod。
- en: Do you need advanced web security? Only an ALB integrates with AWS **Web Application
    Firewall** (**WAF**) and **AWS Shield**, which acts as a **distributed denial-of-service**
    (**DDoS**) protection service. NLB can be protected if you have Shield Advanced
    but doesn’t integrate with WAF and, as we mentioned, has no security group associated
    with it.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要高级的Web安全性吗？只有ALB与AWS的**Web应用防火墙**（**WAF**）和**AWS Shield**集成，后者作为**分布式拒绝服务**（**DDoS**）保护服务。NLB如果启用了Shield
    Advanced也可以进行保护，但它不与WAF集成，并且如前所述，没有关联的安全组。
- en: Do you need static IP addresses for whitelisting? NLBs provides static IP addresses,
    whereas an ALB uses a DNS name, which can return different IP addresses. It is
    possible to put an NLB *in front* of an ALB to provide static IP addresses, but
    you are adding another network hop and increasing latency.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要静态IP地址来进行白名单管理吗？NLB提供静态IP地址，而ALB使用DNS名称，可能会返回不同的IP地址。你可以将NLB*放在*ALB前面以提供静态IP地址，但这会增加一个网络跳跃，并增加延迟。
- en: Do you need low latency, or can you cope with large traffic bursts? As the NLB
    is an SDN construct, it is very low-latency and scales much faster than an ALB.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要低延迟，还是可以应对大流量突发？由于NLB是SDN构建的，它的延迟非常低，且扩展速度远快于ALB。
- en: Do I want to use a Kubernetes Ingress or Service in the deployment? Similar
    to an NLB, a Kubernetes service, for example, a **NodePort**, is a simple construct
    that distributes traffic over a set of Pods. An Ingress, on the other hand, allows
    much more control over routing, using different paths to distribute the load over
    your Pods and is analogous to an ALB. So if you want to have different Pods handling
    updates for users and groups, you can use path-based routing to point the user
    actions to one Pod and the group actions to another Pod. If you need a single
    Pod to handle all actions and expose a single port, you need an NLB/Service.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在部署时，我是否想使用Kubernetes的Ingress或Service？类似于NLB，Kubernetes服务（例如**NodePort**）是一个简单的构造，它将流量分配到一组Pods。而Ingress则提供更多的路由控制，通过不同的路径将负载分配到你的Pods上，它类似于ALB。所以，如果你希望不同的Pods处理用户和小组的更新，你可以使用基于路径的路由，将用户操作指向一个Pod，将小组操作指向另一个Pod。如果你需要一个Pod处理所有操作并暴露一个单一端口，那么你需要使用NLB/Service。
- en: There are, of course, other areas you might consider, but these are the main
    ones I found useful when considering which ELB to use. In the next section, let’s
    look at how we can use the **AWS Load Balancer Controller** (**ALBC**) to create
    and use ELBs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有其他一些方面你可能需要考虑，但在选择使用哪种ELB时，这些是我认为有用的主要因素。在下一部分，我们将看看如何使用**AWS负载均衡器控制器**（**ALBC**）来创建和使用ELB。
- en: Using EKS to create and use AWS LBs
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EKS创建并使用AWS负载均衡器
- en: We can use the ALBC, which is an open source project, to create either an ALB/NLB
    or use existing ones in our AWS account. Let’s start with installing the controller
    and configuring the right privileges to access the AWS APIs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用ALBC，这是一个开源项目，来创建ALB/NLB，或者使用我们AWS账户中已有的负载均衡器。让我们从安装控制器和配置正确的权限来访问AWS
    API开始。
- en: Installing the ALBC in your cluster
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你的集群中安装ALBC
- en: 'The following steps should be followed in order to successfully install the
    ALBC:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装ALBC所需的步骤如下：
- en: 'The first thing you need to do is make sure your VPC is set up correctly so
    that, if you want to create an internal or external ELB, it is deployed into the
    right subnets. You do this by tagging your public subnets with `kubernetes.io/role/elb`
    and your private subnets with `kubernetes.io/role/internal-elb` and setting `Value`
    to `1`. The following commands show you how you can tag and verify a public subnet:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要确保你的VPC正确设置，以便如果你想创建一个内部或外部ELB，它会部署到正确的子网中。你可以通过标记你的公共子网为`kubernetes.io/role/elb`，将私有子网标记为`kubernetes.io/role/internal-elb`并将`Value`设置为`1`来完成此操作。以下命令展示了如何标记并验证一个公共子网：
- en: '[PRE0]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now you have tagged all your subnets, we can deploy the controller to your
    cluster. We will use `eksctl` and Helm. The next thing we need to do is create
    a role and service account for the controller to use (we will use v2.4.5, but
    this may change):'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经标记了所有的子网，我们可以将控制器部署到你的集群中。我们将使用`eksctl`和Helm。接下来我们需要做的是为控制器创建一个角色和服务账号（我们将使用v2.4.5版本，但这个版本可能会有所变化）：
- en: '[PRE1]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we have the policy, we can create the service account using the `Arn` that
    was provided in the previous command:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了策略，我们可以使用前一个命令中提供的`Arn`来创建服务账号：
- en: '[PRE2]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we have the service account created, we can deploy the controller and use
    the Kubernetes service account we just created. To do this, we use the following
    Helm commands with the service account created in the previous steps:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了服务账号，我们可以部署控制器并使用刚刚创建的Kubernetes服务账号。为此，我们使用以下Helm命令，并且在之前的步骤中创建了服务账号：
- en: '[PRE3]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we verify the deployment and version using the following commands:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下命令验证部署和版本：
- en: '[PRE4]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we have the controller deployed, let’s look at how we can use it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经部署了控制器，让我们看看如何使用它。
- en: Using an ALB with your application
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ALB与应用程序
- en: 'In this section, we will work through the official sample located at [https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.4.7/docs/examples/2048/2048_full.yaml](https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.4.7/docs/examples/2048/2048_full.yaml).
    To use an ALB with your application, please follow these steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将使用官方示例，示例位于[https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.4.7/docs/examples/2048/2048_full.yaml](https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.4.7/docs/examples/2048/2048_full.yaml)。要将ALB与应用程序一起使用，请按照以下步骤操作：
- en: 'The first thing we will do is create the namespace for the application components
    using the following section of the YAML file:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们做的第一件事是使用以下部分的YAML文件为应用组件创建命名空间：
- en: '[PRE5]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we will create a deployment of three (Pods) replicas using the official
    Docker image (note that your worker nodes must have internet access to pull the
    image) and expose port `80` on each of the Pods in the deployment using the following
    code snippet:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用官方Docker镜像创建一个包含三个副本（Pod）的部署（请注意，你的工作节点必须能够访问互联网以拉取镜像），并使用以下代码片段在每个Pod的部署中暴露端口`80`：
- en: '[PRE6]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we create a `NodePort` service to expose the Pod outside of the EKS
    cluster with the following code snippet:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`NodePort`服务，将Pod暴露到EKS集群之外，使用以下代码片段：
- en: '[PRE7]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So far, we haven’t done anything different to many of the services we have
    deployed throughout the book. The key difference is in the following snippet,
    where the Ingress uses the `alb.ingress` annotations to define the type of ALB
    to create, in this case, an external ALB with a target group based on IP addresses.
    If you remember, the ALB is a Layer 7 proxy, so we also have to define what path
    and port to register. In this case, we are defining [http://loadbalancername:80/](http://loadbalancername:80/):'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们并没有做任何不同于书中其他已部署服务的事情。关键的区别在于以下代码段，其中 Ingress 使用 `alb.ingress` 注释来定义要创建的
    ALB 类型，在这种情况下，是一个基于 IP 地址的目标组的外部 ALB。如果你记得，ALB 是一个第七层代理，因此我们还需要定义要注册的路径和端口。在这种情况下，我们定义的是
    [http://loadbalancername:80/](http://loadbalancername:80/)：
- en: '[PRE8]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The controller (ALBC) will see the annotations in the manifest and make calls
    to the AWS API to create an external ALB listening on port `80` and a target group
    with the Pod’s IP addresses defined as targets, which are registered with the
    service we created as part of the manifest.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器（ALBC）将看到清单中的注释，并调用 AWS API 来创建一个监听端口 `80` 的外部 ALB，以及一个将 Pod 的 IP 地址定义为目标的目标组，这些目标将与我们在清单中创建的服务一起注册。
- en: 'If we look at the deployed Pods using the following `kubectl` command, we can
    see the VPC IP addresses that have been assigned (the output has been truncated):'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用以下 `kubectl` 命令查看已部署的 Pods，可以看到已分配的 VPC IP 地址（输出已被截断）：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, if we go to the **EC2** | **Load Balancers** section of the AWS Console,
    you will see the ALB created for the game application and the **DNS name** value
    associated with it (remember that IP addresses can change, so you need to always
    use the provided DNS name). An example is shown in the following screenshot:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们进入 AWS 控制台的 **EC2** | **负载均衡器** 部分，你将看到为游戏应用程序创建的 ALB 以及与之关联的 **DNS 名称**
    值（请记住，IP 地址可能会变化，因此你需要始终使用提供的 DNS 名称）。以下截图展示了一个例子：
- en: '![Figure 14.4 – Game app ALB](img/B18129_14_04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.4 – 游戏应用程序 ALB](img/B18129_14_04.jpg)'
- en: Figure 14.4 – Game app ALB
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – 游戏应用程序 ALB
- en: 'If we look at the associated `80`. An example is shown in the following screenshot:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看关联的 `80`，以下截图展示了一个例子：
- en: '![Figure 14.5 – Game app ALB target group](img/B18129_14_05.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.5 – 游戏应用程序 ALB 目标组](img/B18129_14_05.jpg)'
- en: Figure 14.5 – Game app ALB target group
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – 游戏应用程序 ALB 目标组
- en: 'If we open up the target group and look at `kubectl` command. An example is
    shown in the following screenshot:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们打开目标组并查看 `kubectl` 命令，以下截图展示了一个例子：
- en: "![Figure 14.6 – \uFEFFRegistered targets\uFEFF for the game app](img/B18129_14_06.jpg)"
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.6 – 游戏应用程序的已注册目标](img/B18129_14_06.jpg)'
- en: Figure 14.6 – Registered targets for the game app
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 – 游戏应用程序的已注册目标
- en: 'You can see that the targets are all shown with a `80` every **15 seconds**
    to make sure each Pod is able to receive traffic:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，所有的目标都在 **15 秒** 内显示 `80`，以确保每个 Pod 都能够接收流量：
- en: "![Figure 14.7 – \uFEFFHealth checks\uFEFF for the game app](img/B18129_14_07.jpg)"
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.7 – 游戏应用程序的健康检查](img/B18129_14_07.jpg)'
- en: Figure 14.7 – Health checks for the game app
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7 – 游戏应用程序的健康检查
- en: 'If you now browse to the ALB DNS name, you will be presented with the game
    screen and can play the game, which involves moving blocks around the screen:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在访问 ALB 的 DNS 名称，你将看到游戏界面并可以开始玩游戏，游戏内容包括在屏幕上移动方块：
- en: '![Figure 14.8 – The game app service](img/B18129_14_08.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.8 – 游戏应用程序服务](img/B18129_14_08.jpg)'
- en: Figure 14.8 – The game app service
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8 – 游戏应用程序服务
- en: Let’s now look at how we can modify the previous Kubernetes configuration to
    use an NLB instead.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下如何修改之前的 Kubernetes 配置，改用 NLB。
- en: Using an NLB with your application
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NLB 与应用程序配合
- en: 'We can reuse the `namespace` and `Deployment` specifications from the previous
    examples in the *Using an ALB with your* *application* section:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用之前示例中的 `namespace` 和 `Deployment` 配置，在 *使用 ALB 与你的* *应用程序* 部分：
- en: 'As the NLB is an L4 LB, we don’t need the Ingress object, but we do need to
    modify the `Service` definition. The first difference is that the annotations
    we use define the same thing as the ALB annotations, that is, the type of NLB
    and target group. As this is a service, we then define the ports rather than the
    paths. In the example shown in the following code block, an external NLB will
    be created with an IP target group and expose port `80`, which maps to the backend
    port `80`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 NLB 是一个 L4 负载均衡器，我们不需要 Ingress 对象，但我们需要修改 `Service` 的定义。第一个区别是，我们使用的注解定义了与
    ALB 注解相同的内容，即 NLB 类型和目标组。由于这是一个服务，我们定义的是端口而不是路径。在下面的代码块示例中，将创建一个外部 NLB，它将一个 IP
    目标组暴露到端口 `80`，并映射到后台端口 `80`：
- en: '[PRE10]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As before, the controller (ALBC) will see the annotations and make calls to
    the AWS API to create an external NLB listening on port `80` and a target group
    with the Pods' IP addresses defined by the `selector` statement.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，控制器（ALBC）将查看注解，并调用 AWS API 来创建一个监听端口 `80` 的外部 NLB，以及一个由 `selector` 语句定义的
    Pods IP 地址的目标组。
- en: 'If we look at **EC2** | **Load balancers** on the AWS Console, you will see
    another LB for the game application, but in this case, it’s an NLB. An example
    is shown in the following screenshot:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在 AWS 控制台上查看 **EC2** | **负载均衡器**，你将看到一个为游戏应用程序配置的 LB，但在这种情况下，它是一个 NLB。下面的截图展示了一个示例：
- en: '![Figure 14.9 – The game app NLB](img/B18129_14_09.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.9 – 游戏应用程序 NLB](img/B18129_14_09.jpg)'
- en: Figure 14.9 – The game app NLB
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9 – 游戏应用程序 NLB
- en: Important note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: While you can see the DNS name in the previous example, the NLB IP addresses
    are static, unlike the ALB, which can change if AWS scales the service.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在前面的示例中看到 DNS 名称，但 NLB 的 IP 地址是静态的，不像 ALB，后者在 AWS 扩展服务时 IP 地址可能会发生变化。
- en: 'If we review **Target groups** associated with the NLB and **Registered targets**,
    as shown in the following screenshot, we can see the same Pod IP addresses are
    associated with the NLB and in a **healthy** state:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看与 NLB 关联的 **目标组** 和 **已注册的目标**，如下面的截图所示，我们可以看到相同的 Pod IP 地址与 NLB 关联，并且处于
    **健康** 状态：
- en: '![Figure 14.10 – The game app NLB registered targets](img/B18129_14_10.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.10 – 游戏应用程序 NLB 注册的目标](img/B18129_14_10.jpg)'
- en: Figure 14.10 – The game app NLB registered targets
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10 – 游戏应用程序 NLB 注册的目标
- en: 'Again, a health check has been automatically created, but as this is a Layer
    4 LB, the health check is port-based. In the example shown in the following screenshot,
    a `80` check is used to make sure each Pod is able to receive traffic:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，一个健康检查已经自动创建，但由于这是一个第 4 层（L4）负载均衡器，健康检查是基于端口的。在下面的截图示例中，使用了 `80` 端口检查，确保每个
    Pod 都能接收流量：
- en: '![Figure 14.11 – The game app NLB health check](img/B18129_14_11.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.11 – 游戏应用程序 NLB 健康检查](img/B18129_14_11.jpg)'
- en: Figure 14.11 – The game app NLB health check
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11 – 游戏应用程序 NLB 健康检查
- en: If you browse to the DNS name of the NLB, you will see the same game screen
    as with the ALB (*Figure 14**.8*).
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你浏览 NLB 的 DNS 名称，你将看到与 ALB 相同的游戏屏幕（*图 14.8*）。
- en: Reusing an existing LB
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重用现有的 LB
- en: In some cases, you might want to reuse an existing ELB. This will save you costs
    and also simplify your configuration. You can do this by using the `TargetGroupBinding`
    custom resource. This resource allows you to associate a service with an existing
    **TargetGroup** and by NLB.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能希望重用现有的 ELB。这样可以节省成本，同时简化配置。你可以通过使用 `TargetGroupBinding` 自定义资源来实现。这项资源允许你将服务与现有的
    **TargetGroup** 和 NLB 关联。
- en: 'Let’s assume we have created an NLB and an associated IP-based target group
    but without registering any IP addresses. The following code snippet shows how
    we can use `TargetGroupBinding`, which allows the ALBC to register Pods associated
    with a Kubernetes Service with an existing NLB or ALB. The key is to specify the
    given `ARN` of `TargetGroup` in the definition:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经创建了一个 NLB 和一个关联的基于 IP 的目标组，但还没有注册任何 IP 地址。以下代码片段展示了我们如何使用 `TargetGroupBinding`，该资源允许
    ALBC 将与 Kubernetes 服务关联的 Pods 注册到现有的 NLB 或 ALB。关键是要在定义中指定给定的 `TargetGroup` 的 `ARN`：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Important note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The NLB is outside of the security group associated with the worker nodes where
    the Pods are running. So you will need to allow TCP:`80` from the NLB ENIs to
    the worker nodes’ security groups as the ALBC will not do this for you when you
    use `TargetGroupBinding`. The service referenced by `serviceRef` can be configured,
    as `type: ClusterIP` rather than `LoadBalancer` or `NodePort`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at how general LBs work, what options are available
    in AWS, and how to configure and use the ALBC on EKS. We’ll now revisit the key
    learning points from this chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how LBs help applications scale and provide resilience.
    They tend to fall into two categories, either Layer 7 or Layer 4 LBs. Layer 7
    LBs, which normally work on HTTP, understand protocol-specific attributes such
    as paths or headers, whereas L4 LBs work at the port level and are protocol-agnostic.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: We also reviewed the differences between the proxy and DSR modes; a proxy LB
    always sits between the client and the backend system, whereas in DSR mode, the
    backend can return traffic directly to the client (albeit by faking the source
    address to be that of the LB).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: We reviewed the different types of ELBs typically used with EKS, namely the
    ALB and NLB, and how they differ. We then learned how to install the ALBC on an
    EKS cluster and then how you can use annotations and custom configuration to create
    either an NLB or ALB and register Pods with them so you can access the service
    based on the path (ALB) or ports (NLB).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we quickly reviewed how you can use `TargetGroupBinding` to register
    Pods with an existing NLB (or ALB). You should now be able to talk about the different
    options available to you in AWS and configure deployments and services in EKS
    to take advantage of an ALB or NLB.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how you can use AWS Fargate to provide
    enhanced security, support small workloads, or simply not manage or pay for EC2
    instances.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Understanding the OSI network model: [https://www.imperva.com/learn/application-security/osi-model/](https://www.imperva.com/learn/application-security/osi-model/)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Understanding how HTTPS works: [https://www.cloudflare.com/learning/ssl/what-is-https/](https://www.cloudflare.com/learning/ssl/what-is-https/)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Understanding how `X-Forwarded-For` works: [https://en.wikipedia.org/wiki/X-Forwarded-For](https://en.wikipedia.org/wiki/X-Forwarded-For)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Understanding ALB support for gRPC: https://aws.amazon.com/blogs/aws/new-application-load-balancer-support-for-end-to-end-http-2-and-grpc/'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Understanding NLB client IP address preservation: https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-target-groups.html#client-ip-preservation'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Understanding NLB proxy protocol: [https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-target-groups.html#proxy-protocol](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-target-groups.html#proxy-protocol)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Understanding AWS advanced web security features: [https://docs.aws.amazon.com/waf/latest/developerguide/what-is-aws-waf.html](https://docs.aws.amazon.com/waf/latest/developerguide/what-is-aws-waf.html)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Downloading the ALBC: [https://github.com/kubernetes-sigs/aws-load-balancer-controller](https://github.com/kubernetes-sigs/aws-load-balancer-controller)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to create an NLB: [https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-network-load-balancer.html](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-network-load-balancer.html)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
