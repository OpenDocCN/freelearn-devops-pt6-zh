- en: '*Chapter 7*: Managing Storage and Stateful Applications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：管理存储和有状态应用程序'
- en: In the previous chapters, we learned how to provision and prepare our Kubernetes
    clusters for production workloads. It is part of the critical production readiness
    requirement to configure and fine-tune day zero tasks, including networking, security,
    monitoring, logging, observability, and scaling, before we bring our applications
    and data to Kubernetes. Kubernetes was originally designed for mainly stateless
    applications in order to keep containers portable. Therefore, data management
    and running stateful applications are still among the top challenges in the cloud
    native space. There are a number of ways and a variety of solutions to address
    storage needs. New solutions emerge in the Kubernetes and cloud-native ecosystem
    every day; therefore, we will start with popular in-production solutions and also
    learn the approach and criteria to look for when evaluating future solutions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们学习了如何配置和准备Kubernetes集群以处理生产工作负载。在将应用程序和数据引入Kubernetes之前，配置并调优包括网络、安全、监控、日志、可观测性和扩展等零日任务是生产就绪的关键要求之一。Kubernetes最初是为主要处理无状态应用程序而设计的，以确保容器的可移植性。因此，数据管理和运行有状态应用程序仍然是云原生领域中的主要挑战之一。有多种方法和不同的解决方案可以满足存储需求。新的解决方案每天都在Kubernetes和云原生生态系统中出现；因此，我们将从目前流行的生产解决方案开始，并学习评估未来解决方案时需要关注的方法和标准。
- en: In this chapter, we will learn the technical challenges associated with stateful
    applications on Kubernetes. We will follow the cloud-native approach completely
    to fine-tune Kubernetes clusters for persistent storage. We will learn the different
    storage solutions and their shortcomings, and how to use and configure them with
    our Kubernetes cluster.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习与Kubernetes上有状态应用程序相关的技术挑战。我们将完全遵循云原生的方法来调优Kubernetes集群，以实现持久存储。我们将了解不同的存储解决方案及其不足之处，以及如何使用和配置它们与我们的Kubernetes集群。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要主题：
- en: Understanding the challenges with stateful applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解有状态应用程序的挑战
- en: Tuning Kubernetes storage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调优Kubernetes存储
- en: Choosing a persistent storage solution
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择持久存储解决方案
- en: Deploying stateful applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署有状态应用程序
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You should have the following tools installed from the previous chapters:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经安装了以下来自前几章的工具：
- en: AWS CLI V2
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI V2
- en: AWS IAM Authenticator
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS IAM身份验证器
- en: '`kubectl`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl`'
- en: 'We will also need to install the following tools:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装以下工具：
- en: Helm
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm
- en: CSI driver
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSI驱动程序
- en: You need to have an up and running Kubernetes cluster as per the instructions
    in [*Chapter 3*](B16192_03_Final_PG_ePub.xhtml#_idTextAnchor073), *Provisioning
    Kubernetes Clusters Using AWS and Terraform*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要按照[*第3章*](B16192_03_Final_PG_ePub.xhtml#_idTextAnchor073)《使用AWS和Terraform配置Kubernetes集群》中的说明，确保您的Kubernetes集群已启动并运行。
- en: The code for this chapter is located at [https://github.com/PacktPublishing/Kubernetes-Infrastructure-Best-Practices/tree/master/Chapter07](https://github.com/PacktPublishing/Kubernetes-Infrastructure-Best-Practices/tree/master/Chapter07).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码位于[https://github.com/PacktPublishing/Kubernetes-Infrastructure-Best-Practices/tree/master/Chapter07](https://github.com/PacktPublishing/Kubernetes-Infrastructure-Best-Practices/tree/master/Chapter07)。
- en: 'Check out the following link to see the Code in Action video:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下链接观看《代码实战》视频：
- en: '[https://bit.ly/3jemcot](https://bit.ly/3jemcot)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/3jemcot](https://bit.ly/3jemcot)'
- en: Installing the required tools
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装所需的工具
- en: In this section, we will install the tools that we will use to provision applications
    using Helm charts and provide dynamically provisioned volumes to the stateful
    applications in your Kubernetes infrastructure during this chapter and the upcoming
    ones. As a cloud and Kubernetes learner, you may be familiar with these tools
    from before.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装在本章及接下来的章节中用于使用Helm charts部署应用程序并为Kubernetes基础设施中的有状态应用程序提供动态供应卷的工具。作为云计算和Kubernetes学习者，您可能已经熟悉这些工具。
- en: Installing Helm
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Helm
- en: Helm is a package manager for Kubernetes. Helm is also a great way to find and
    deploy vendor and community published applications on Kubernetes. We will use
    Helm to deploy applications on our Kubernetes cluster. If you do not have Helm
    installed in your cluster, you can follow these instructions to do that.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Helm是Kubernetes的包管理器。Helm也是在Kubernetes上查找和部署供应商及社区发布的应用程序的好方法。我们将使用Helm在我们的Kubernetes集群上部署应用程序。如果您的集群中没有安装Helm，可以按照这些说明进行安装。
- en: 'Execute the following commands to install Helm 3 in your Kubernetes cluster:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以在你的 Kubernetes 集群中安装 Helm 3：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we will install the CSI drivers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将安装 CSI 驱动程序。
- en: Installing CSI drivers
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 CSI 驱动程序
- en: '**Container Storage Interface** (**CSI**) is the standardized APIs to extend
    Kubernetes with third-party storage provider solutions. CSI drivers are vendor
    specific and, of course, you only need an AWS EBS CSI driver if you are running
    on AWS infrastructure, including EC2 or EKS-based clusters. To install the latest
    AWS EBS CSI drivers, refer to the Amazon EKS official documentation at [https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi.htm](https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi.htm).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器存储接口**（**CSI**）是扩展 Kubernetes 的标准化 API，用于支持第三方存储提供商解决方案。CSI 驱动程序是供应商特定的，当然，如果你在
    AWS 基础设施上运行（包括 EC2 或基于 EKS 的集群），你只需要 AWS EBS CSI 驱动程序。要安装最新的 AWS EBS CSI 驱动程序，请参考
    Amazon EKS 官方文档，网址为 [https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi.htm](https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi.htm)。'
- en: If you are running on a self-managed Kubernetes solution, bare metal/on-premises,
    or virtualized environment, you may need to use another vendor's CSI driver or
    **Container Attached Storage** (**CAS**) solutions. To install other CSI vendor
    drivers, you can refer the links to specific driver instructions on the official
    CSI documentation at [https://kubernetes-csi.github.io/docs/drivers.html](https://kubernetes-csi.github.io/docs/drivers.html).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用自管理的 Kubernetes 解决方案、裸金属/本地部署或虚拟化环境，你可能需要使用其他供应商的 CSI 驱动程序或 **容器附加存储**（**CAS**）解决方案。要安装其他
    CSI 供应商的驱动程序，你可以参考官方 CSI 文档中的具体驱动程序说明，网址为 [https://kubernetes-csi.github.io/docs/drivers.html](https://kubernetes-csi.github.io/docs/drivers.html)。
- en: Now that we have installed the prerequisites required in the chapter to deploy
    Helm Charts and consume AWS EBS volumes using the CSI driver, let's go over the
    implementation principles we will be following, making storage provider decisions
    with a view to solving our stateful application challenges.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了本章中部署 Helm Charts 和使用 CSI 驱动程序访问 AWS EBS 卷所需的前提条件，让我们来回顾一下我们将遵循的实施原则，在做出存储提供商决策时，要着眼于解决有状态应用程序的挑战。
- en: Implementation principles
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现原则
- en: 'In [*Chapter 1*](B16192_01_Final_PG_ePub.xhtml#_idTextAnchor014), *Introduction
    to Kubernetes Infrastructure and Production-Readiness*, we learned about the infrastructure
    design principles that we will follow during the book. I would like to start this
    chapter by highlighting the notable principles that influenced the cloud-native
    data management suggestions and the technical decisions in this chapter:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B16192_01_Final_PG_ePub.xhtml#_idTextAnchor014)，《Kubernetes 基础设施与生产就绪介绍》中，我们学习了在本书中我们将遵循的基础设施设计原则。我想从本章开始时，强调影响本章云原生数据管理建议和技术决策的重要原则：
- en: '**Simplication**: In this chapter, we will retain our commitment to the simplification
    principle. Unless you are operating in a multi-cloud environment, it is not necessary
    to introduce new tools and complicate operations. On public clouds, we will use
    the native storage data management technology stack provided, and which is supported
    by your managed service vendor. Many stateful applications today are designed
    to fail and provide built-in, high-availability functionality. We will identify
    different types of stateful applications and learn how to simply data paths and
    fine-tune for performance. We will also learn the additional design principles
    to achieve higher availability across availability zones, as well as unifying
    data management in on-premises and hybrid cloud environments.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化**：在本章中，我们将继续坚持简化原则。除非你在多云环境中操作，否则没有必要引入新工具来使操作复杂化。在公有云中，我们将使用提供的原生存储数据管理技术栈，这些技术栈由你的托管服务供应商支持。如今，许多有状态应用程序设计为能够容错并提供内建的高可用性功能。我们将识别不同类型的有状态应用程序，并学习如何简化数据路径并进行性能微调。我们还将学习额外的设计原则，以实现跨可用区的更高可用性，并统一本地和混合云环境中的数据管理。'
- en: '**Cloud agnostic**: Data has gravity. When running stateless applications,
    cloud vendor lock-in may not be as important since container images can be brought
    up almost instantly on any infrastructure, but when dealing with stateful workloads,
    it is easy to get into this situation. We will use cloud-native solutions to abstract
    storage layers and eliminate dependencies. The solutions we will implement will
    work exactly the same way on any cloud provider, managed Kubernetes service, and
    even on a self-managed on-premise environment.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云无关性**：数据具有引力。当运行无状态应用时，云厂商锁定可能不那么重要，因为容器镜像几乎可以在任何基础设施上即时启动，但当处理有状态工作负载时，就很容易进入这种情况。我们将使用云原生解决方案来抽象存储层并消除依赖。我们将实现的解决方案将在任何云提供商、托管
    Kubernetes 服务，甚至是自主管理的本地环境中以相同方式工作。'
- en: '**Design for availability**: CSI is great, but, at the same time, it is nothing
    more than standardized APIs. Your data still needs to be stored on a highly available
    media somewhere. It is important to consider the blast radius of your storage
    solution. It doesn''t make sense to store your loosely coupled applications in
    a single scale-out storage solution, or on a legacy storage appliance. Doing so
    would create scale bottlenecks and will slow you down along the way. We will learn
    the benefits of cloud-native storage solutions. We will also learn how to use
    snapshots, clones, and backups for increased service availability and quick service
    recovery.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为高可用性设计**：CSI 非常棒，但同时，它不过是标准化的 API。你的数据仍然需要存储在某个高可用的介质上。考虑存储解决方案的爆炸半径非常重要。将松散耦合的应用存储在单一的可扩展存储解决方案或传统存储设备上是没有意义的。这样做会造成规模瓶颈，最终会拖慢你的进程。我们将学习云原生存储解决方案的优势。我们还将学习如何使用快照、克隆和备份来提高服务可用性并快速恢复服务。'
- en: '**Automation**: You can''t automate your CI/CD pipelines unless everything
    can be dynamically provisioned. We will learn about Kubernetes storage primitives
    and the use of dynamic provisioners.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：除非所有内容都可以动态配置，否则你无法自动化你的 CI/CD 流水线。我们将学习 Kubernetes 存储原语以及动态配置器的使用。'
- en: In this section, we have covered the implementation principles we will be following
    when making storage provider decisions. Let's now take a look at some of the common
    stateful application challenges we will need to address.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经介绍了在做出存储提供商决策时将遵循的实施原则。现在让我们来看看一些常见的有状态应用挑战，我们需要解决这些问题。
- en: Understanding the challenges with stateful applications
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解有状态应用程序面临的挑战
- en: Kubernetes was initially built for stateless applications in order to keep containers
    portable. Even when we run stateful applications, the applications themselves
    are actually very often stateless containers where the state is stored separately
    and mounted from a resource called **Persistent Volume** (**PV**). We will learn
    the different resource types used to maintain state and also keep some form of
    flexibility later in the *Understanding storage primitives in Kubernetes* section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 最初是为无状态应用构建的，以保持容器的可移植性。即使我们运行有状态应用，应用本身实际上也经常是无状态容器，状态存储在一个叫做**持久卷**（**PV**）的资源中，并且是单独挂载的。我们将学习用于维护状态的不同资源类型，并且在稍后的*理解
    Kubernetes 中的存储原语*部分中保持一定的灵活性。
- en: 'I would like to highlight the six notable stateful application challenges that
    we will try to address in this chapter:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调在本章中我们将尝试解决的六个显著的有状态应用挑战：
- en: '**Deployment challenges**: Especially when running a mission-critical service
    in production, finding the ideal deployment method of a certain stateful application
    can be challenging to start with. Should we use a YAML file we found in a blog
    article, open source repository examples, Helm charts, or an operator? Your choice
    will have an impact on future scalability, manageability, upgrades, and service
    recoverability. We will learn the best practices to follow for deploying a stateful
    application later in this chapter in the *Deploying stateful applications* section.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署挑战**：尤其是在生产环境中运行关键任务服务时，找到理想的有状态应用部署方法从一开始就可能具有挑战性。我们应该使用在博客文章、开源库示例、Helm
    charts 或操作器中找到的 YAML 文件吗？你的选择将影响未来的可扩展性、可管理性、升级和服务可恢复性。我们将在本章稍后的*部署有状态应用程序*部分中学习部署有状态应用程序的最佳实践。'
- en: '**Persistency challenges**: Storing the actual persistent data that makes the
    application stateful needs to be carefully picked. You should never store the
    state inside the application container itself since the container images and pods
    can be restarted and updated, which would result in losing the data. Similarly,
    if you are running your cluster across multiple availability zones on top of EBS
    volumes when a node is restarted, your application may come up in a node located
    on a separate availability zone with no access to previous EBS volumes. In that
    case, you should consider a container-attached storage solution with across **availability
    zone** (**AZ**) replication functionality.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性挑战**：存储使应用程序具有状态的实际持久数据需要仔细选择。你永远不应将状态存储在应用程序容器内部，因为容器镜像和 Pod 可以被重启和更新，这会导致数据丢失。同样，如果你在
    EBS 卷上跨多个可用区运行集群，当某个节点重启时，应用程序可能会启动在一个位于不同可用区的节点上，而无法访问之前的 EBS 卷。在这种情况下，你应该考虑具有跨
    **可用区** (**AZ**) 复制功能的容器附加存储解决方案。'
- en: On the other hand, if your application is a distributed database with built-in
    high availability, adding an additional layer of high availability from a storage
    provider would have a negative impact on capacity, cost, and performance. Persistency
    decisions need to carefully consider an application's requirements.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一方面，如果你的应用程序是具有内建高可用性的分布式数据库，来自存储提供商的额外高可用性层将对容量、成本和性能产生负面影响。持久性决策需要仔细考虑应用程序的需求。
- en: '**Scalability challenges**: One of the main reasons behind the popularity of
    the Kubernetes orchestration platform is the flexibility of scaling up services.
    Kubernetes platforms allow you to start on a single worker node and dynamically
    scale up to thousands of nodes according to demand and increasing loads. Not every
    storage solution is designed for scale. We will learn the best practices to follow
    and the differences between the storage options to consider when deploying a scalable
    stateful application later in this chapter in the *Choosing a persistent storage
    solution* section.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性挑战**：Kubernetes 编排平台受欢迎的主要原因之一是它能够灵活扩展服务。Kubernetes 平台允许你从单个工作节点开始，根据需求和不断增加的负载动态扩展到数千个节点。并非每个存储解决方案都为扩展而设计。稍后在本章的
    *选择持久存储解决方案* 部分中，我们将学习应遵循的最佳实践以及部署可扩展有状态应用程序时需要考虑的存储选项之间的差异。'
- en: '**Mobility challenges**: Data mobility means being able to get data where and
    when you need it. Especially in an infrastructure where hybrid or multi-cloud
    are requirements, your choice of storage provider becomes a key factor. This requirement
    is also aligned with the cloud-agnostic design principles that we introduced in
    [*Chapter 1*](B16192_01_Final_PG_ePub.xhtml#_idTextAnchor014), *Introduction to
    Kubernetes Infrastructure and Production-Readiness*. If needed, your stateful
    applications should be able to migrate to different zones and even different storage
    and cloud vendors.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动性挑战**：数据移动性意味着能够在需要时获取数据，尤其是在要求使用混合云或多云架构的基础设施中，存储提供商的选择成为关键因素。这个需求也与我们在[*第一章*](B16192_01_Final_PG_ePub.xhtml#_idTextAnchor014)中介绍的与云无关的设计原则相一致，*Kubernetes
    基础设施与生产就绪性简介*。如果需要，你的有状态应用程序应该能够迁移到不同的区域，甚至不同的存储和云供应商。'
- en: '**Life cycle manageability challenges**: The real challenge starts after you
    deploy your stateful applications. Day two operations need to be planned in advance
    before you go to production with your services. This sometimes creates a dependency
    and requirement on your deployment method as well. You need to pick the deployment
    method that will support rollover upgrades, monitoring, observability, and troubleshooting.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期可管理性挑战**：真正的挑战开始于你部署有状态应用程序之后。第二天的操作需要在生产服务之前提前规划好。这有时会对你的部署方法产生依赖和要求。你需要选择支持滚动升级、监控、可观察性和故障排除的部署方法。'
- en: '**Disaster recovery (DR) and backup challenges**: You need to plan for service
    availability in case of application and or infrastructure failures. Your data
    needs to be backed up on a regular basis. Some applications may require application-consistent
    backups, and some might be good with just crash-consistent backups. CSI-operated
    snapshots and copying that data to object storage needs to be scheduled. Taking
    a backup is one side of the problem, but being able to recover from your backup
    in a timely fashion is another challenge. When there is a service outage, end
    user service impact is measured using mainly two data points; the **Recovery Time
    Objective** (**RTO**) and the **Recovery Point Objective** (**RPO**). RTO measures
    the time required to bring a service back, while RPO measures the backup frequency.
    Data created by your application may grow quickly when you go to production with
    your services. Recovering a large amount of data from S3-like object storage will
    take time. In that case, stream backup solutions need to be considered. This requirement
    is also aligned with the *design for availability* design principles that I introduced
    in [*Chapter 1*](B16192_01_Final_PG_ePub.xhtml#_idTextAnchor014), *Introduction
    to Kubernetes Infrastructure and Production-Readiness*. If needed, your application
    needs to be able to switch to its DR copy as quickly as possible with minimal
    downtime.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灾难恢复（DR）和备份挑战**：你需要为应用程序和/或基础设施故障的情况下规划服务可用性。你的数据需要定期备份。一些应用程序可能要求应用一致的备份，而一些可能仅仅要求崩溃一致的备份。CSI
    操作的快照和将数据复制到对象存储的操作需要进行调度。备份是问题的一方面，而能够及时从备份中恢复则是另一个挑战。当发生服务中断时，最终用户服务的影响通常通过两个数据点来衡量；**恢复时间目标**（**RTO**）和**恢复点目标**（**RPO**）。RTO
    衡量恢复服务所需的时间，而 RPO 衡量备份频率。随着你的应用程序投入生产，数据可能会迅速增长。从类似 S3 的对象存储中恢复大量数据将需要时间。在这种情况下，需要考虑流备份解决方案。这个需求也与我在[*第
    1 章*](B16192_01_Final_PG_ePub.xhtml#_idTextAnchor014)《Kubernetes 基础设施与生产就绪性简介》中介绍的*可用性设计*设计原则相一致。如果需要，你的应用程序应该能够在最短的停机时间内快速切换到灾难恢复副本。'
- en: These six core challenges contribute to the architectural design decisions we
    need to make in order to run stateful applications in production. We will consider
    these challenges later in this chapter when we evaluate our storage options and
    make a relevant technical decision based on it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这六个核心挑战促成了我们在运行有状态应用程序时需要做出的架构设计决策。稍后在本章中，当我们评估存储选项并基于此做出相关技术决策时，我们将考虑这些挑战。
- en: Tuning Kubernetes storage
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调优 Kubernetes 存储
- en: At some point, we have all experienced and been frustrated by storage performance
    and the technical limitations of it. In this chapter, we will learn the fundamentals
    of Kubernetes storage, including storage primitives, creating static **persistent
    volumes** (**PVs**), and using storage classes to provision dynamic PVs to simplify
    management.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些时候，我们都曾体验过存储性能的限制，并为此感到沮丧。在本章中，我们将学习 Kubernetes 存储的基础知识，包括存储原语、创建静态**持久卷**（**PVs**）以及使用存储类来动态配置
    PV，以简化管理。
- en: Understanding containerized stateful applications requires us to get into the
    cloud-native mindset. Although referred to as stateful, data used by pods is either
    accessed remotely or orchestrated and stored in Kubernetes as separate resources.
    Therefore, some flexibility is maintained to schedule applications across worker
    nodes and update when needed without losing the data. Before we get into the tuning,
    let's understand some of the basic storage primitives in Kubernetes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 理解容器化有状态应用程序要求我们进入云原生的思维方式。尽管被称为有状态，但 pods 使用的数据要么是远程访问的，要么是作为独立资源在 Kubernetes
    中编排和存储的。因此，保持一定的灵活性，使得应用程序能够跨工作节点调度，并在需要时更新而不丢失数据。在我们开始调优之前，让我们先理解一些 Kubernetes
    中的基本存储原语。
- en: Understanding storage primitives in Kubernetes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 中的存储原语
- en: 'The beauty of Kubernetes is that every part of it is abstracted as an object
    that can be managed and configured declaratively with YAML or JSON through the
    `kube-api` server. This makes Kubernetes configuration easier to manage as code.
    Storage is also handled as abstracted objects. To be able to understand the reasoning
    behind the best practices, I highly recommend that you learn the separation of
    the storage object. In this section, we will learn the following core storage
    primitives to request persistent storage from Kubernetes and orchestrate the provisioning
    through storage providers associated with it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Volume
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent Volume** (**PV**)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent Volume Claim** (**PVC**)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage Class** (**SC**)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss each of these in the following sections.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Volumes
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes volumes are basically just a directory accessible to the applications
    running in containers in a pod. How this directory is created and protected, and
    where it is stored really depends on the type of volume used, which makes this
    a critical decision when running stateful applications in production. Kubernetes
    supports many types of volumes. For a detailed list of support volume types, refer
    to the official Kubernetes documentation at [https://kubernetes.io/docs/concepts/storage/volumes/](https://kubernetes.io/docs/concepts/storage/volumes/).
    Some of the volume types are ephemeral, in other words, their lifespan is limited
    to its pod. Therefore, they should only be used for stateless applications where
    the persistency of data is not necessary across restarts. In the context of stateful
    applications, our focus is PV types, including remote PVs and local PVs. Let's
    now learn about the use of PV objects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: PVs
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PVs are volumes that can retain the data during pod restarts or other resource
    failures. PVs can be created either statically in advance or dynamically when
    requested by the user application. I will explain the use of static or dynamic
    PV objects with a practical example while we deploy a Percona server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/pv-percona.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/pv-percona.yaml).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a static volume to understand its limitations, in other words,
    the value and logic behind the dynamic provisioning:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an AWS Elastic Block Store volume with a size of 100 GB using the volume
    type `gp2`. Make sure that the EBS volume is in the same availability zone as
    your Kubernetes worker nodes:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Repeat the previous step to create one volume per worker node available in
    your cluster. If you have three nodes available, then create a total of three
    volumes. Execute the following command to get the list of `InstanceId` strings
    for the nodes:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Execute the following command to attach each volume you have created to one
    worker node in your cluster at a time using the AWS CLI. Replace `WORKER_NODE_ID`
    and `VOLUME_ID` from the output of step 1:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令，使用AWS CLI将您创建的每个卷依次附加到集群中的一个工作节点。将`WORKER_NODE_ID`和`VOLUME_ID`替换为第1步输出的内容：
- en: '[PRE3]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a Kubernetes PV named `percona-pv1` with a size of `5Gi` in the following
    path – `stateful/percona/pv-percona.yaml`. Make sure to replace `volumeID` with
    a valid volume ID of your EBS volume:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下路径`stateful/percona/pv-percona.yaml`中创建一个名为`percona-pv1`，大小为`5Gi`的Kubernetes
    PV。确保将`volumeID`替换为您的EBS卷的有效卷ID：
- en: '[PRE4]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Execute the following `kubectl` command to create a static PV in the cluster:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下`kubectl`命令以在集群中创建静态PV：
- en: '[PRE5]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now you have created a PV that can bind to your stateful application. As you
    can see, if you have a dynamically scaling environment, creating volumes manually
    in advance will not provide a scalable option.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了一个可以绑定到有状态应用程序的PV。如您所见，如果您有一个动态扩展的环境，提前手动创建卷将无法提供可扩展的选项。
- en: PV claims
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PV声明
- en: A **PV claim** (**PVC**) is a request for storage. PVC requests can be fulfilled
    either by static or dynamic PVs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**PV声明**（**PVC**）是对存储的请求。PVC请求可以通过静态或动态的PV来满足。'
- en: Important note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: You can find the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/pvc-percona.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/pvc-percona.yaml).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/pvc-percona.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/pvc-percona.yaml)找到完整的源代码。
- en: 'Here, we will create a PVC manifest to request the static PV we created earlier:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个PVC清单，以请求我们之前创建的静态PV：
- en: 'Create a PVC named `percona-pv1` with a size of `5Gi` in the following path
    – `stateful/percona/pvc-percona.yaml`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`percona-pv1`，大小为`5Gi`的PVC，路径为`stateful/percona/pvc-percona.yaml`：
- en: '[PRE6]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the following part of the template, we will set `storageClassName` to blank.
    Otherwise, the default storage class will be used and a PV is created dynamically
    using the default storage provisioner. This time, we are specifically requesting
    a PV with no storage class specified, so it can only be bound to our existing
    PV:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板的以下部分，我们将`storageClassName`设置为空白。否则，将使用默认的存储类，并且会使用默认的存储提供程序动态创建PV。这一次，我们特意请求一个没有指定存储类的PV，因此它只能绑定到我们现有的PV：
- en: '[PRE7]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Execute the following `kubectl` command to create a PVC object in the cluster:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下`kubectl`命令以在集群中创建PVC对象：
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Important note
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要说明
- en: You can find the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/deployment-percona.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/deployment-percona.yaml).
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/deployment-percona.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/deployment-percona.yaml)找到完整的源代码。
- en: 'In the following code snippet, you create the `percona` deployment that will
    use the PVC to request the PV we created earlier:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，您将创建`percona`部署，该部署将使用PVC请求我们之前创建的PV：
- en: 'Create a Kubernetes secret to keep the Percona root password by executing the
    following command. This will be used in the deployment later. You can read more
    about the detailed usage of Kubernetes secrets at [https://kubernetes.io/docs/concepts/configuration/secret/](https://kubernetes.io/docs/concepts/configuration/secret/):'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令创建一个Kubernetes密钥以保存Percona的root密码。这个密钥将在稍后的部署中使用。您可以在[https://kubernetes.io/docs/concepts/configuration/secret/](https://kubernetes.io/docs/concepts/configuration/secret/)中阅读有关Kubernetes密钥的详细用法：
- en: '[PRE9]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create the template for the `percona` deployment in the following path – `stateful/percona/deployment-percona.yaml`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下路径`stateful/percona/deployment-percona.yaml`中创建`percona`部署的模板：
- en: '[PRE10]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the following part of the template, we will define the `volumeMounts` using
    the name `percona-volume`, with the `mountPath` parameter configured as the path
    `/var/lib/mysql`, where your PV will be mounted inside the container:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板的以下部分，我们将使用名称`percona-volume`定义`volumeMounts`，并将`mountPath`参数配置为路径`/var/lib/mysql`，这是您的PV将在容器内挂载的路径：
- en: '[PRE11]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, in the following part of the template, we will define where your request
    will be directed. In our case, as defined before in the case of `claimName`, this
    should be `percona-pvc`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在模板的以下部分，我们将定义您的请求将被指向的位置。就我们而言，正如之前在`claimName`的案例中定义的，这应该是`percona-pvc`：
- en: '[PRE12]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Execute the following `kubectl` command to create `percona` deployment in the
    cluster:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下`kubectl`命令，以在集群中创建`percona`部署：
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now you have created a stateful application deployment with a binding to a static
    PV. Although it can be useful to know how to clone an existing volume and mount
    it to a new pod, this is not a scalable solution. Therefore, we will now learn
    about the dynamic provisioning of PVs using `StorageClass`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经创建了一个有状态应用程序部署，并绑定到一个静态PV。虽然了解如何克隆现有卷并将其挂载到新Pod可能会有用，但这并不是一个可扩展的解决方案。因此，我们现在将学习如何使用`StorageClass`进行PV的动态配置。
- en: Storage class
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储类
- en: The `StorageClass` object allows dynamic provisioning requests through a PVC.
    You can maintain multiple classes that map to different availability and QoS levels
    using internal or external third-party provisioners. The `StorageClass` concept
    is similar to tiers or profiles in traditional storage solutions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`StorageClass`对象允许通过PVC进行动态配置请求。您可以维护多个类，这些类映射到不同的可用性和QoS级别，使用内部或外部第三方供应者。`StorageClass`概念类似于传统存储解决方案中的层级或配置文件。'
- en: Important note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: You can find the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/deployment-percona.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/deployment-percona.yaml).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/deployment-percona.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/deployment-percona.yaml)找到完整的源代码。
- en: 'Let''s review a `StorageClass` template used for provisioning EBS volumes on
    AWS:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下用于在AWS上配置EBS卷的`StorageClass`模板：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the following part of the template, we set `StorageClass` as the default
    storage class. It is highly recommended good practice to set a default storage
    class, so PVCs missing the `storageClassName` field are automatically assigned
    to your default class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板的以下部分，我们将`StorageClass`设置为默认存储类。强烈推荐将默认存储类设置为最佳实践，这样如果PVC缺少`storageClassName`字段，它会自动分配到您的默认类：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the following part of the template, we set the EBS volume type to `gp2`,
    with AWS EBS volumes of `io1`, `gp2`, `sc1`, or `st1`. You can read about the
    differences in the official AWS documentation at [https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volume-types.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volume-types.html).
    We also set `fsType` to `ext4`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板的以下部分，我们将EBS卷类型设置为`gp2`，并使用AWS EBS卷类型`io1`、`gp2`、`sc1`或`st1`。您可以在官方AWS文档中阅读有关这些类型的差异，网址为[https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volume-types.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volume-types.html)。我们还将`fsType`设置为`ext4`：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the following part of the template, we set the `provisioner` type to `kubernetes.io/aws-ebs`.
    This field can be internal or an external provisioner. In our following template,
    it is set to Kubernetes'' internal `aws-ebs` provisioner, `kubernetes.io/aws-ebs`.
    We will review the available storage options later in this chapter in the *Choosing
    a persistent storage solution* section:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板的以下部分，我们将`provisioner`类型设置为`kubernetes.io/aws-ebs`。此字段可以是内部或外部供应者。在我们接下来的模板中，它设置为Kubernetes的内部`aws-ebs`供应者`kubernetes.io/aws-ebs`。我们将在本章稍后*选择持久存储解决方案*部分中回顾可用的存储选项：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`reclaimPolicy` can be set to `Delete`, `Recycle`, or `Retain` and it defines
    the action when a corresponding PVC is deleted. When `Retain` is selected, after
    the PVC is removed, the PV is moved to the `Released` state. Hence, `Retain` is
    the suggested option to avoid accidents.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`reclaimPolicy`可以设置为`Delete`、`Recycle`或`Retain`，它定义了当相应的PVC被删除时的操作。当选择`Retain`时，PVC被移除后，PV将转移到`Released`状态。因此，建议选择`Retain`以避免意外发生。'
- en: The `allowVolumeExpansion` field is used if you need to request a larger size
    PVC later and you want the same volume to be resized instead of getting a new
    volume. You can only expand a PVC if its storage class has the `allowVolumeExpansion`
    parameter set to `true`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`allowVolumeExpansion`字段用于在稍后需要请求更大大小的PVC时，并希望调整相同卷的大小，而不是获取新的卷。只有当存储类的`allowVolumeExpansion`参数设置为`true`时，才能扩展PVC。'
- en: Note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: AWS EBS volume expansions can take time and one modification is allowed every
    6 hours.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: AWS EBS卷扩展可能需要时间，并且每6小时允许进行一次修改。
- en: '`volumeBindingMode` can be set to `Immediate` or `WaitForFirstConsumer`. This
    parameter stipulates when the volume binding should occur.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`volumeBindingMode`可以设置为`Immediate`或`WaitForFirstConsumer`。此参数规定了何时进行卷绑定。'
- en: 'To learn about the remainder of the `StorageClass` parameters, please check
    the official Kubernetes documentation here: [https://kubernetes.io/docs/concepts/storage/storage-classes/](https://kubernetes.io/docs/concepts/storage/storage-classes/).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多`StorageClass`参数的信息，请查看Kubernetes官方文档：[https://kubernetes.io/docs/concepts/storage/storage-classes/](https://kubernetes.io/docs/concepts/storage/storage-classes/)。
- en: Important note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can find the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/deployment-percona-sc.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/deployment-percona-sc.yaml).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/deployment-percona-sc.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter07/stateful/percona/deployment-percona-sc.yaml)找到完整的源代码。
- en: 'Now, we will modify the `pvc-percona.yaml` and `deployment-percona.yaml` manifest
    files. We will adjust the `percona` deployment to use a storage class to dynamically
    request a PV through a PVC:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改`pvc-percona.yaml`和`deployment-percona.yaml`清单文件。我们将调整`percona`部署，使其通过PVC动态请求PV，并使用存储类：
- en: 'Edit the template for the `percona-pvc` PVC in this path, `stateful/percona/pvc-percona.yaml`,
    using your preferred text editor. Adjust the name and `storageClassName` fields
    as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器编辑此路径下的`percona-pvc` PVC模板：`stateful/percona/pvc-percona.yaml`，并根据以下内容调整`name`和`storageClassName`字段：
- en: '[PRE18]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Edit the template for the `percona` deployment in this path, `stateful/percona/deployment-percona.yaml`,
    using your preferred text editor. Adjust the last line, `claimName`, as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器编辑此路径下的`percona`部署模板：`stateful/percona/deployment-percona.yaml`，并根据以下内容调整最后一行的`claimName`字段：
- en: '[PRE19]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Execute the following `kubectl` commands to create a `percona` deployment in
    the cluster using a dynamically provisioned PV:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下`kubectl`命令，在集群中使用动态配置的PV创建`percona`部署：
- en: '[PRE20]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now you have created a stateful application deployment with a binding to a dynamically
    provisioned PV using `StorageClass`. This step completely eliminated the need
    for manual EBS volume creation. Therefore, we will use this method later in this
    chapter when creating new stateful applications.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经创建了一个与动态配置的PV绑定的有状态应用部署，使用了`StorageClass`。这个步骤完全消除了手动创建EBS卷的需求。因此，在本章稍后创建新的有状态应用时，我们将使用这种方法。
- en: Choosing a persistent storage solution
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个持久存储解决方案
- en: 'Two of the biggest stateful application challenges in Kubernetes are storage
    orchestration and data management. There are an infinite number of solutions out
    there. First, we will explain the main storage attributes and topologies we need
    to consider when evaluating storage alternatives. Let''s review the topologies
    used by the most common storage systems:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，最大的两个有状态应用挑战是存储编排和数据管理。市场上有无数解决方案。首先，我们将解释在评估存储替代方案时需要考虑的主要存储属性和拓扑结构。让我们回顾一下最常见存储系统所使用的拓扑结构：
- en: '**Centralized**: Traditional, or also referred to as monolithic, storage systems
    are most often tightly coupled with a proprietary hardware and internal communication
    protocols. They are usually associated with scale-up models since it is difficult
    to scale-out tightly coupled components of the storage nodes.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中式**：传统的，也称为单体存储系统，通常与专有硬件和内部通信协议紧密耦合。它们通常与向上扩展的模型相关，因为难以扩展紧密耦合的存储节点组件。'
- en: '**Distributed**: Distributed storage systems are more likely to be a software-defined
    solution and they may be architected to favor availability, consistency, durability,
    performance, or scalability. Usually, distributed systems scale out better than
    others to support many storage server nodes in parallel.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式**：分布式存储系统更可能是软件定义的解决方案，它们的架构可能会偏向可用性、一致性、耐久性、性能或可扩展性。通常，分布式系统比其他系统更能支持多个存储服务器节点并行扩展。'
- en: '**Hyperconverged**: Hyperconverged storage solutions are designed to take advantage
    of the same network and compute resources where the applications run. They are
    largely designed to run as software and are orchestrated by the same platform
    used to manage applications, VMs, or containers, such as a hypervisor or container
    orchestrators.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超融合**：超融合存储解决方案旨在利用应用程序运行所在的相同网络和计算资源。它们主要设计为软件运行，并由与应用程序、虚拟机或容器管理相同的平台进行编排，如虚拟化管理程序或容器编排器。'
- en: '**Sharded**: Sharded storage solutions partition the data into datasets and
    store them across multiple nodes. Sharded storage solutions can be complex to
    manage and rebalance and performance is limited to the performance of a single
    node where the dataset is located.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分片**：分片存储解决方案将数据分割成多个数据集，并将它们分布存储在多个节点上。分片存储解决方案可能管理起来比较复杂，需要重新平衡，而且性能受限于数据集所在单个节点的性能。'
- en: The category of storage solutions available for the cloud-native application
    is known as cloud-native storage by the **Cloud Native Computing Foundation**
    (**CNCF**). Currently, there are 17 open source and 32 proprietary solutions,
    hence a total of 49 solutions, listed in the category.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用可用的存储解决方案类别被**云原生计算基金会**（**CNCF**）定义为云原生存储。目前，列出了17个开源解决方案和32个专有解决方案，总共49个解决方案。
- en: 'For the most up-to-date list of solutions, you can refer to the official CNCF
    cloud-native interactive landscape documentation at [https://landscape.cncf.io/](https://landscape.cncf.io/):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如需查看最新的解决方案列表，请参考官方的CNCF云原生互动生态文档：[https://landscape.cncf.io/](https://landscape.cncf.io/)：
- en: '![Figure 7.1 – CNCF cloud-native landscape with cloud-native storage providers'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – CNCF 云原生生态图，包含云原生存储提供商'
- en: '](img/B16192_07_001.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16192_07_001.jpg)'
- en: Figure 7.1 – CNCF cloud-native landscape with cloud-native storage providers
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – CNCF 云原生生态图，包含云原生存储提供商
- en: When the challenges mentioned in the *Understanding the challenges with stateful
    applications* section are considered for the simplicity of the deployment and
    life cycle management of block storage, **Container Attached Storage** (**CAS**)
    and **Cloud Storage** are preferred over the centralized topology. To satisfy
    persistence across different infrastructure and data mobility requirements, **CAS**
    and **Distributed** solutions should be preferred over the solutions on the right.
    When we talk about Kubernetes-grade scalability, again **Cloud Storage** and **CAS**
    solutions offer significant advantages over the centralized topology. Overall,
    **CAS** and **Cloud Storage** providers satisfy all the architectural concerns.
    That said, on many occasions, we will have to utilize your company's existing
    investment. Cloud storage is only available on the cloud vendor provided infrastructure,
    and if you are running on-premises/private clouds, you may need to utilize your
    existing hardware solutions. In that case, you can still leverage **CAS** solutions
    to unify data management, add the advantages of cloud-native storage, including
    data mobility and scalability, and simplify the life cycle management of PVs on
    top of your investment.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到*理解有状态应用面临的挑战*部分提到的挑战，针对块存储的简化部署和生命周期管理，**容器附加存储**（**CAS**）和**云存储**优于集中式拓扑。为了满足跨不同基础设施和数据流动性的持久性要求，应该优先选择**CAS**和**分布式**解决方案，而非右侧的解决方案。在讨论Kubernetes级别的可扩展性时，**云存储**和**CAS**解决方案也显著优于集中式拓扑。总体而言，**CAS**和**云存储**提供商能够满足所有架构需求。尽管如此，在许多情况下，我们仍然需要利用公司现有的投资。云存储仅在云服务商提供的基础设施上可用，如果你是在本地/私有云环境中运行，可能需要利用现有的硬件解决方案。在这种情况下，你仍然可以利用**CAS**解决方案来统一数据管理，增加云原生存储的优势，包括数据流动性和可扩展性，并简化PV生命周期管理。
- en: Now that you have learned the storage topologies used by the most common storage
    solutions, let's focus on how we can use a CAS solution to deploy a stateful application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了最常见存储解决方案使用的存储拓扑结构，接下来我们来关注如何使用CAS解决方案来部署有状态应用。
- en: Deploying stateful applications
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署有状态应用
- en: Kubernetes provides a number of controller APIs to manage the deployment of
    pods within a Kubernetes cluster. Initially designed for stateless applications,
    these controllers are used to group pods based on need. In this section, we will
    briefly learn the differences between the following Kubernetes objects – pods,
    ReplicaSets, deployments, and StatefulSets. In the event of a node failure, individual
    Pods will not be rescheduled on other nodes. Therefore, they should be avoided
    when running stateful workloads.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了多个控制器 API 来管理 Kubernetes 集群中 Pod 的部署。这些控制器最初是为无状态应用程序设计的，旨在根据需求将
    Pod 分组。在本节中，我们将简要了解以下 Kubernetes 对象的区别——Pod、ReplicaSets、Deployments 和 StatefulSets。如果节点发生故障，个别
    Pod 不会被重新调度到其他节点。因此，在运行有状态工作负载时，应避免使用这些对象。
- en: '**Deployments** are used when managing pods, and **ReplicaSets** when we need
    to roll out changes to replica Pods. Both ReplicaSets and Deployments are used
    when provisioning stateless applications. To learn about Deployments, please check
    the official Kubernetes documentation here: [https://kubernetes.io/docs/concepts/workloads/controllers/deployment/](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**部署** 用于管理 Pod，而 **副本集** 用于在需要对副本 Pod 进行更新时。副本集和部署都用于配置无状态应用程序。要了解更多关于部署的信息，请查阅官方
    Kubernetes 文档：[https://kubernetes.io/docs/concepts/workloads/controllers/deployment/](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)。'
- en: '**StatefulSets** are another controller that reached a **General Availability**
    (**GA**) milestone with the release of Kubernetes 1.9\. The real adoption of stateful
    applications started following the introduction of the StatefulSets object. With
    StatefulSets, every pod replica has its own state, in other words, its own volume,
    and therefore retains its state and identity across restarts. When deploying stateful
    applications, and when we need storage to be stateful, we will use StatefulSets.
    The following diagram shows the components of an application deployed using StatefulSets:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**StatefulSets** 是另一种控制器，在 Kubernetes 1.9 发布时达到了 **正式发布**（**GA**）的里程碑。随着 StatefulSets
    对象的引入，有状态应用程序的真正采用开始了。通过 StatefulSets，每个 Pod 副本都有自己的状态，换句话说，就是它自己的卷，因此在重启后仍能保持其状态和身份。在部署有状态应用程序时，当我们需要存储保持状态时，我们将使用
    StatefulSets。以下图示显示了使用 StatefulSets 部署的应用程序组件：'
- en: '![Figure 7.2 – Kubernetes StatefulSet deployment diagram'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – Kubernetes StatefulSet 部署示意图](img/B16192_07_002.jpg)'
- en: '](img/B16192_07_002.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16192_07_002.jpg)'
- en: Figure 7.2 – Kubernetes StatefulSet deployment diagram
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – Kubernetes StatefulSet 部署示意图
- en: StatefulSets require a headless service for handling the network identity of
    the related pods. When a StatefulSet requests volumes to be created, it uses the
    StorageClass to call the PV provisioner. Earlier in this chapter, you learned
    to use StorageClass to dynamically provision PVs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSets 需要一个无头服务来处理相关 Pod 的网络身份。当 StatefulSet 请求创建卷时，它使用 StorageClass 来调用
    PV 配置器。在本章前面，你已经学习了如何使用 StorageClass 动态配置 PV。
- en: Before we deploy a stateful application, we will learn how to install one of
    the popular open source storage provisioner options, OpenEBS, which we mentioned
    in the *Choosing a persistent storage solution* section.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们部署有状态应用程序之前，我们将学习如何安装一个流行的开源存储配置器选项——OpenEBS，这也是我们在 *选择持久化存储解决方案* 部分提到过的。
- en: Installing OpenEBS
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 OpenEBS
- en: OpenEBS is an open source CNCF project for Kubernetes designed to enable stateful
    applications to easily access dynamic local PVs, or replicated and highly available
    PVs. OpenEBS is an example of the new category of cloud-native storage solutions
    known as CAS. CAS solutions are easy to maintain, are portable, can run on any
    platform, are scalable, and fulfil the infrastructure design principles that I
    introduced in [*Chapter 1*](B16192_01_Final_PG_ePub.xhtml#_idTextAnchor014), *Introduction
    to Kubernetes Infrastructure and Production-Readiness*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: OpenEBS 是一个开源的 CNCF 项目，旨在使 Kubernetes 中的有状态应用程序能够轻松访问动态本地 PV，或复制的高可用 PV。OpenEBS
    是一种新的云原生存储解决方案类别（称为 CAS）的例子。CAS 解决方案易于维护，具有可移植性，能在任何平台上运行，具备可扩展性，并且符合我在 [*第 1
    章*](B16192_01_Final_PG_ePub.xhtml#_idTextAnchor014) *Kubernetes 基础设施和生产就绪性介绍*
    中介绍的基础设施设计原则。
- en: 'To learn more about its prerequisites and the detailed usage of OpenEBS, please
    refer to the following link: [https://docs.openebs.io/](https://docs.openebs.io/).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关 OpenEBS 的更多先决条件和详细用法，请参考以下链接：[https://docs.openebs.io/](https://docs.openebs.io/)。
- en: 'Now, let''s install OpenEBS on your Kubernetes cluster and prepare your cluster
    to provide dynamically provisioned PVs:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 Kubernetes 集群上安装 OpenEBS，并为您的集群准备动态供应的 PV：
- en: 'Create a namespace called `openebs`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `openebs` 的命名空间：
- en: '[PRE21]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the OpenEBS Helm chart repository to your local repository list:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 OpenEBS Helm chart 仓库添加到本地仓库列表中：
- en: '[PRE22]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Update the Helm chart repositories:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 Helm chart 仓库：
- en: '[PRE23]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Install `openebs` from its Helm repository:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Helm 仓库安装 `openebs`：
- en: '[PRE24]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Verify successful installation by executing the following command:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令验证安装是否成功：
- en: '[PRE25]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of the preceding command should look as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述命令的输出应如下所示：
- en: '![Figure 7.3 – List of the OpenEBS pods running following successful installation'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3 – 安装成功后运行的 OpenEBS Pods 列表'
- en: '](img/B16192_07_003.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16192_07_003.jpg)'
- en: Figure 7.3 – List of the OpenEBS pods running following successful installation
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 安装成功后运行的 OpenEBS Pods 列表
- en: Now that you can use OpenEBS for dynamically creating PVs, you can either create
    a new SC or use one of the default storage classes provided by OpenEBS.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您可以使用 OpenEBS 动态创建 PV，您可以创建一个新的 SC 或使用 OpenEBS 提供的默认存储类之一。
- en: OpenEBS provides various types of block storage options, including storage engines
    called `Jiva`, `cStor`, and `Mayastor`, for persistent workloads that require
    highly available volumes during node failures and `Dynamic Local PV` (device,
    host path, ZFS) alternatives for distributed applications, such as Cassandra,
    Elastic, Kafka, or MinIO.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: OpenEBS 提供了各种类型的块存储选项，包括名为 `Jiva`、`cStor` 和 `Mayastor` 的存储引擎，适用于需要在节点故障期间保证高可用卷的持久化工作负载，以及适用于分布式应用程序（如
    Cassandra、Elastic、Kafka 或 MinIO）的 `Dynamic Local PV`（设备、主机路径、ZFS）替代方案。
- en: 'Execute the following command to get the list of default storage classes in
    your cluster:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以获取集群中默认存储类的列表：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You will notice the new storage classes, `openebs-device`, `openebs-hostpath`,
    `openebs-jiva-default`, and `openebs-snapshot-promoter`, added to your list.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您将注意到新添加到列表中的存储类：`openebs-device`、`openebs-hostpath`、`openebs-jiva-default`
    和 `openebs-snapshot-promoter`。
- en: 'Here is an example of a YAML manifest to create a PVC using the default `openebs-jiva-default`
    storage class:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 YAML 清单示例，用于使用默认的 `openebs-jiva-default` 存储类创建 PVC：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now you have learned who to create a PV for with your stateful applications
    using an open source CAS alternative – OpenEBS.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学习了如何使用开源 CAS 替代方案 OpenEBS 为有状态应用程序创建 PV。
- en: From now on, if running on an AWS infrastructure, you can continue to consume
    your existing EBS volumes using the `gp2` storage class or the `ebs-sc` storage
    class created earlier using `Amazon_EBS_CSI_Driver`, or take advantage of OpenEBS
    to abstract data management. OpenEBS, in the same way as CAS solutions, helps
    to reduce many of the challenges we described in the *Understanding the challenges
    with stateful applications* section earlier in this chapter.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，如果运行在 AWS 基础设施上，您可以继续使用现有的 EBS 卷，使用 `gp2` 存储类或先前通过 `Amazon_EBS_CSI_Driver`
    创建的 `ebs-sc` 存储类，或者利用 OpenEBS 来抽象化数据管理。与 CAS 解决方案相似，OpenEBS 帮助减少了我们在本章 *理解有状态应用程序的挑战*
    部分中描述的许多挑战。
- en: Now that we have learned how to use storage provisioners to dynamically provision
    a PV, let's use it, along with a stateful application, to simplify the life cycle
    of data management.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何使用存储提供者动态提供 PV，让我们将其与有状态应用程序一起使用，以简化数据管理的生命周期。
- en: Deploying a stateful application on OpenEBS volumes
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 OpenEBS 卷上部署有状态应用程序
- en: OpenEBS provides a flexible data plane with a few storage engines options that
    are optimized for different application and performance expectations. You can
    read about the differences between storage engines on the official OpenEBS documentation
    site at [https://docs.openebs.io/docs/next/casengines.html](https://docs.openebs.io/docs/next/casengines.html).
    Here, we will dive into one of the defaults, the low-footprint storage engine
    option, `Jiva`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: OpenEBS 提供了一个灵活的数据平面，拥有多个存储引擎选项，针对不同的应用和性能需求进行了优化。您可以在官方 OpenEBS 文档网站 [https://docs.openebs.io/docs/next/casengines.html](https://docs.openebs.io/docs/next/casengines.html)
    阅读有关存储引擎差异的详细信息。在这里，我们将深入了解其中一个默认选项，即低占用存储引擎选项 `Jiva`。
- en: 'Now, we will modify the `pvc-percona.yaml` and `deployment-percona.yaml` manifest
    files. We will adjust the `percona` deployment to use a StorageClass to dynamically
    request a PV through a PVC:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改 `pvc-percona.yaml` 和 `deployment-percona.yaml` 清单文件。我们将调整 `percona`
    部署，以便使用 StorageClass 动态请求通过 PVC 创建 PV：
- en: 'Create a `StorageClass` named `openebs-jiva-3r` with a `ReplicaCount` of `3`
    in the following path – `stateful/percona/sc-openebs-jiva.yaml`. This will create
    three copies of the volume and make it highly available in the event of node failure:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下路径 `stateful/percona/sc-openebs-jiva.yaml` 中创建一个名为 `openebs-jiva-3r` 的 `StorageClass`，并设置
    `ReplicaCount` 为 `3`。这将创建三个副本的卷，并在节点故障时提供高可用性：
- en: '[PRE28]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Execute the following `kubectl` command to create the StorageClass:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下 `kubectl` 命令创建 StorageClass：
- en: '[PRE29]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Edit the template for the `percona-pvc` PVC in this path, `stateful/percona/pvc-percona.yaml`,
    using your preferred text editor. Adjust the name and `storageClassName` fields
    as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器编辑此路径下的 `percona-pvc` PVC 模板，`stateful/percona/pvc-percona.yaml`。调整名称和
    `storageClassName` 字段，如下所示：
- en: '[PRE30]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Edit the template for the `percona` deployment in this path, `stateful/percona/deployment-percona.yaml`,
    using your preferred text editor. Adjust the last line, `claimName`, as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器编辑此路径下的 `percona` 部署模板，`stateful/percona/deployment-percona.yaml`。调整最后一行
    `claimName`，如下所示：
- en: '[PRE31]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Execute the following `kubectl` commands to create the `percona` deployment
    in the cluster using a dynamically provisioned PV:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下 `kubectl` 命令，在集群中使用动态供应的 PV 创建 `percona` 部署：
- en: '[PRE32]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now you have created a stateful application deployment backed by dynamically
    created OpenEBS PVs. This step helped us to abstract data management on cloud
    and bare-metal or VM-based Kubernetes clusters.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经创建了一个由动态创建的 OpenEBS PVs 支持的有状态应用程序部署。这一步帮助我们在云端、裸金属或基于虚拟机的 Kubernetes
    集群中抽象了数据管理。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned the stateful application challenges and best practices
    to consider when choosing the best storage management solutions, both open source
    and commercial, and finally, the stateful application considerations when deploying
    them in production using Kubernetes' StatefulSet and deployment objects.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了有状态应用程序的挑战，并讨论了在选择最佳存储管理解决方案时应考虑的最佳实践，包括开源和商业解决方案。最后，还介绍了在使用 Kubernetes
    的 StatefulSet 和部署对象将其部署到生产环境时需要考虑的有状态应用程序问题。
- en: We deployed the AWS EBS CSI driver and OpenEBS. We also created a highly available
    replicated storage using OpenEBS and deployed our application on OpenEBS volumes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们部署了 AWS EBS CSI 驱动程序和 OpenEBS，并使用 OpenEBS 创建了高度可用的复制存储，并将我们的应用程序部署在 OpenEBS
    卷上。
- en: We gained a solid understanding of Kubernetes storage in this chapter, but you
    should perform a detailed evaluation of your cluster storage requirements and
    take further action to deploy any extra tools and configurations that may be required,
    including your storage provider's CSI driver.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中深入了解了 Kubernetes 存储，但您应对您的集群存储需求进行详细评估，并采取进一步措施，部署任何可能需要的额外工具和配置，包括存储提供商的
    CSI 驱动程序。
- en: In the next chapter, we will learn in detail about seamless and reliable applications.
    We will also get to grips with containerization best practices to easily scale
    our applications.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细了解无缝且可靠的应用程序。我们还将掌握容器化的最佳实践，以便轻松地扩展我们的应用程序。
- en: Further reading
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'You can refer to the following links for more information on the topics covered
    in this chapter:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下链接，了解更多关于本章所涵盖主题的信息：
- en: '*Kubernetes – A Complete DevOps Cookbook* ([*Chapter 5*](B16192_05_Final_PG_ePub.xhtml#_idTextAnchor118),
    *Preparing for Stateful Workloads*): [https://www.packtpub.com/product/kubernetes-a-complete-devops-cookbook/9781838828042](https://www.packtpub.com/product/kubernetes-a-complete-devops-cookbook/9781838828042).'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kubernetes – 完整的 DevOps 手册*（[*第 5 章*](B16192_05_Final_PG_ePub.xhtml#_idTextAnchor118)，*为有状态工作负载做准备*）：[https://www.packtpub.com/product/kubernetes-a-complete-devops-cookbook/9781838828042](https://www.packtpub.com/product/kubernetes-a-complete-devops-cookbook/9781838828042)。'
- en: '*Kubernetes Container Storage Interface (CSI) Documentation*:[https://kubernetes-csi.github.io/docs/introduction.html](https://kubernetes-csi.github.io/docs/introduction.html)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kubernetes 容器存储接口（CSI）文档*：[https://kubernetes-csi.github.io/docs/introduction.html](https://kubernetes-csi.github.io/docs/introduction.html)'
- en: '*QuickStart Guide to OpenEBS*: [https://docs.openebs.io/docs/next/quickstart.html](https://docs.openebs.io/docs/next/quickstart.html)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OpenEBS 快速入门指南*：[https://docs.openebs.io/docs/next/quickstart.html](https://docs.openebs.io/docs/next/quickstart.html)'
