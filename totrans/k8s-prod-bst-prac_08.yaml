- en: '*Chapter 8*: Deploying Seamless and Reliable Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we learned how to prepare our platform and infrastructure
    components for production usage. We also learned Kubernetes data management considerations
    and storage best practices to deploy our first stateful application using the
    Operator Framework. One of the most underestimated topics in container orchestration
    is container image management. Although developing applications in Kubernetes
    is out of the scope of this book, we need to understand the critical components
    of our images. There are multiple sources, public container registries, and vendors
    where we can find ready-to-consume application images. Mishandling container images
    can not only cause overutilization of our cluster resources but, more importantly,
    can also impact the reliability and security of our services.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss topics such as containers and image management.
    We will learn about the technical challenges when selecting or creating our application
    images that affect the Kubernetes cluster's stability and security. We will focus
    on application rollout best practices when deploying and creating our production
    services before hosting on our cluster to avoid creating instability or misuse
    of the cluster. This will help us to get the full benefits of using Kubernetes
    to orchestrate our services securely.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the challenges with container images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning application deployment strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling applications and achieving higher availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should have the following tools installed from previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metrics-server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to have an up-and-running Kubernetes cluster as per the instructions
    in [*Chapter 3*](B16192_03_Final_PG_ePub.xhtml#_idTextAnchor073), *Provisioning
    Kubernetes Clusters Using AWS and Terraform*.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter is located at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter08](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3rpWeRN](https://bit.ly/3rpWeRN)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the challenges with container images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about the considerations and best practices followed
    by industry experts when building or selecting the right container images. Before
    we discuss the challenges and get into our options, let's learn what goes into
    a container image.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the components of container images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the behavior of a container image, we need to have basic knowledge
    of the **Operating System** (**OS**) and hierarchical protection domains. For
    security segregation purposes, the OS handles virtual memory in two layers called
    **kernel space** and **user space**. Basically, the kernel runs in the most privileged
    protection ring, called **Ring 0**, and interacts directly with critical resources
    such as CPU and memory. The kernel needs to be stable since any problem or instability
    would cause instability in the overall system and bring everything to a panic
    state. As we can see in *Figure 8.1*, drivers, low-level system components, and
    all user applications run in the least privileged protection rings and in user
    space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Privilege rings, also called hierarchical protection domains'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16192_08_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Privilege rings, also called hierarchical protection domains
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn about the user space, please check out the detailed explanation here:
    [https://debian-handbook.info/browse/stable/sect.user-space.html](https://debian-handbook.info/browse/stable/sect.user-space.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Linux containers take the segregation of security one step further and allow
    us to manage application and OS dependencies separately in what is called the
    **container host** and **container image**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The container host is where the OS runs along with the **container runtime**
    (some of the popular container runtimes include **containerd**, **CRI-O**, **Firecracker**,
    and **Kata**) and **container engine** (some of the popular container engines
    include Docker and the **Linux Container Daemon** (**LXD**)). In this book, we
    will not discuss the differences between container runtimes and engines, since
    most of the time they are part of the platform, which is outside of our scope.
    In traditional monolithic architectures, we run applications on top of the OS
    along with OS dependencies and other applications, whereas in cloud-native microservices
    architectures, we run applications and their dependencies inside a container image
    (see *Figure 8.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Comparison of monolithic and microservices architecture](img/B16192_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Comparison of monolithic and microservices architecture
  prefs: []
  type: TYPE_NORMAL
- en: When we run an application in Kubernetes, such as NGINX, Cassandra, Kafka, MongoDB,
    and so on, our container engine pulls the container image from its container registry
    to the local registry, then it wraps one or more containers into an object called
    a **pod** and **schedules** it on an available worker node.
  prefs: []
  type: TYPE_NORMAL
- en: The container image (most of the time, this term is misused instead of *base
    image*) used in this process is a layered image consisting of the user application
    and the container base image.
  prefs: []
  type: TYPE_NORMAL
- en: The container base image contains the interchangeable user space components
    of the OS. The container image is packaged following the Docker image or **Open
    Container Initiative** (**OCI**) industry standards. This is where our options
    and challenges come in. Most container base images contain a root filesystem with
    the minimal user space applications of an OS distribution, some other external
    libraries, utilities, and files. Container images are typically used for software
    development and provide a functional application written in common programming
    languages. Programming languages, including both compiled and interpreted ones,
    depend on external drivers and libraries. These dependencies make the container
    base image selection critically important.
  prefs: []
  type: TYPE_NORMAL
- en: Before we build our application or run an application based on an existing image
    in production, we need to understand the critical differences between the popular
    container base images. Now that you've learned what goes into container images,
    let's learn the differences between the common container base images and some
    of the best practices for choosing the right image type.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right container base image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Choosing a container base image is not much different than choosing your container
    hosts' Linux distribution. Similar criteria such as security, performance, dependencies,
    core utilities, package managers, the size of its community and ecosystem, and
    the security response and support must be considered.
  prefs: []
  type: TYPE_NORMAL
- en: 'I would like to highlight the five notable container image challenges that
    we will try to address in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Image size**: One of the important benefits of container images is portability.
    A smaller container image size reduces the build and rollout times since pulling
    the image itself will be faster. Smaller images are achieved by limiting extra
    binaries, which also bring a minimized attack surface and increased security benefits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stability**: Updating base images is not fun, but updating every container
    image is the worst. Container images that only include your application and its
    runtime dependencies, such as distroless images, may sound attractive. Still,
    when it comes to patching **Common Vulnerabilities and Exposures** (**CVEs**),
    you will need to update all your containers that can introduce stability issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Distroless images are container images that don''t contain package managers
    or any other application. You can read more about distroless Docker images and
    watch a presentation here: [https://github.com/GoogleContainerTools/distroless](https://github.com/GoogleContainerTools/distroless).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Security**: Every binary that is added to our container images adds unpredictable
    risks to the overall platform security. When choosing base images, their update
    frequency, ecosystem and community size, and vulnerability tracking methods such
    as a CVE database and **Open Vulnerability and Assessment Language** (**OVAL**)
    data are important factors to consider. Check the properties of executables such
    as the **Position Independent Executable** (**PIE**), **Relocation Read-Only**
    (**RELRO**), **Patches for the Linux Kernel** (**PaX**), canaries, **Address Space
    Layout Randomization** (**ASLR**), FORTIFY_SOURCE, and the RPATH and RUNPATH runtime
    search paths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can find the Bash script to check the properties of the binary hardening
    tools at [https://github.com/slimm609/checksec.sh](https://github.com/slimm609/checksec.sh).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Speed/performance**: Popular container base images may not always be the
    fastest. Although Alpine is famous for its size and is recommended in some cases,
    it may cause serious build performance issues. Alpine might be acceptable if you
    are using the Go language. If you are using Python instead, you will quickly notice
    that Alpine images will sometimes get two to three times larger, are more than
    10 times slower to build, and might even cause build problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can find the Kubernetes-related performance test tools here: [https://github.com/kubernetes/perf-tests](https://github.com/kubernetes/perf-tests).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`glibc`, Alpine includes `muslc` and can show implementation differences. Also,
    utilities included in the image for troubleshooting and support need to be considered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of the common container base image options compared
    by their size, security, and support options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`busybox` with a package manager. `glibc`/`musl` library differences are known
    to cause problems and performance issues that are hard to track down:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- **Size**: 2.6 MB.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Security**: Community-updated; Alpine Linux bug tracker available at [https://bugs.alpinelinux.org/projects/alpine/issues](https://bugs.alpinelinux.org/projects/alpine/issues).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Support**: Support via community. 386, AMD64, ARMv6, ARMv7, ARM64v8, ppc64le,
    and S390x architectures supported.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Amazon Linux 2 (amazonlinux:2)**: A Linux image maintained by **Amazon Web
    Services** (**AWS**) to be used on Amazon EC2 instances. It is binary-compatible
    with RHEL and CentOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- **Size**: 59.14 MB.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Security**: Vendor-updated; Amazon Linux Security Center available at [https://alas.aws.amazon.com/alas2.html](https://alas.aws.amazon.com/alas2.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Support**: LTS support included with AWS EC2; AMD64 and ARM64v8 architectures
    supported.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**CentOS (centos:8)**: Community-driven container base image of the popular
    Linux distribution. Due to the rollout of CentOS Stream, its future is unknown.
    At this point, it is better to wait for the replacement Rocky Linux base images
    or use Amazon Linux 2:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- **Size**: 71.7 MB.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Security**: Community-updated; CentOS security alerts can be found here:
    [https://lwn.net/Alerts/CentOS/](https://lwn.net/Alerts/CentOS/).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Support**: Support via community only. AMD64, ARM64v8, and ppc64le architectures
    supported.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`libc`) included in Debian images:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- **Size**: 26.47 MB'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Security**: Community-updated; Security Bug Tracker ([https://security-tracker.debian.org/tracker/](https://security-tracker.debian.org/tracker/))
    and OVAL at [https://www.debian.org/security/oval/](https://www.debian.org/security/oval/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Support**: Support via community only. 386, AMD64, and ARM64v5 architectures
    supported'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Ubuntu (ubuntu:21.04)**: A Debian-based larger community and enterprise-supported
    Linux distribution base image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- **Size**: 29.94 MB'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Security**: Ubuntu CVE Tracker at [https://people.canonical.com/~ubuntu-security/cve/](https://people.canonical.com/~ubuntu-security/cve/)
    and cloud image bug tracker at [https://bugs.launchpad.net/cloud-images](https://bugs.launchpad.net/cloud-images)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Support**: Community and commercial support. AMD64, ARMv7, and ARM64v8
    architectures supported'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`microdnf` as a package manager. It is preferred when running applications
    on the `ubi-minimal`), standard (`ubi`), and multi-service (`ubi-init`), for different
    use cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- **Size**: 37.6 MB.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Security**: The best container base image in terms of completeness of vulnerability
    checks. Errata provided at [https://access.redhat.com/errata](https://access.redhat.com/errata)
    and OVAL data provided at [https://www.redhat.com/security/data/oval/](https://www.redhat.com/security/data/oval/).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Support**: Community and commercial support. AMD64, ARM64v8, ppc64le, and
    S390x architectures supported.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Distroless (gcr.io/distroless/base-debian10)**: Builds on the Debian distribution
    by Google. They don''t contain package managers or shells. Preferred for security
    and size. Additional builds can be found at [https://console.cloud.google.com/gcr/images/distroless/GLOBAL](https://console.cloud.google.com/gcr/images/distroless/GLOBAL):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- **Size**: 75.1 MB'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Security**: Avoids image vulnerabilities, but introduces another challenge
    where dependent library updates need to be carefully tracked for every container
    image'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Support**: Support via community only. AMD64, ARM, ARM64, ppc64le, and
    S390x architectures supported'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now you have learned about the challenges we deal with when choosing the right
    container base image and how the most common popular base images compare. Let's
    find out some of the best practices for reducing your final image size and scanning
    your container images for vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing container image size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An excellent way to achieve smaller container images would be by starting with
    small base images such as Alpine, `ubi-minimal`, or distroless base images.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For reproducible builds and deployment, you can also use the Nix package manager
    and create slim builds. There is a lot of enthusiasm around Nix, but since there
    is a steep learning curve and custom expression language is involved, we will
    not discuss Nix in this book. You can learn about building container images using
    Nix here at the official NixOS documentation page: [https://nixos.org/guides/building-and-running-docker-images.html](https://nixos.org/guides/building-and-running-docker-images.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Excluding some of the unnecessary files, using a `.dockerignore` file can help
    us to reduce our image size. Here is an example of a `.dockerignore` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Size-optimized images can be achieved by utilizing multistage builds and avoiding
    extra layers. Multistage builds add a couple of new syntaxes and allow us to use
    a `FROM` section in our Dockerfile multiple times to start a new stage of the
    build and copy only the artifacts we want to take from previous stages. You can
    learn more about the multistage build on the official Docker documentation website
    at [https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a Dockerfile with two stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In our preceding example, the first stage, `base`, starts with the `node:14.15`
    Node.js base image. We copy our application code to the `/app` directory and execute
    the `npm install` command.
  prefs: []
  type: TYPE_NORMAL
- en: We move to the second stage, called `stage2`, this time using a `distroless/nodejs`
    base image. Then, we copy our application code and our `node_modules` from the
    first stage using the `COPY --from=base /app /app` syntax. This way, we are reducing
    our container image size as well as the attack surface since distroless images
    do not contain `bash` or other tools that can be maliciously executed.
  prefs: []
  type: TYPE_NORMAL
- en: You can read about the best practices for writing Dockerfiles at [https://docs.docker.com/develop/develop-images/dockerfile_best-practices/](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/).
  prefs: []
  type: TYPE_NORMAL
- en: Now we have learned a few techniques for reducing our container image size.
    Let's look at how we can proactively scan our images against security vulnerabilities
    and patch them in a timely manner before running them in production.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning container images for vulnerabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've built our container images or pulled some of the vendor-provided images
    to our local registry and now we are ready to run in our production environment.
    How do we know they are safe to run? How do we know they have the latest security
    vulnerabilities patched? Most **Continuous Integration and** **Continuous Delivery**
    (**CI/CD**) solutions today have additional security scanning tools. It is one
    of the golden rules not to roll out any service into production before going through
    a quick image validation during our pipeline. For this purpose, we will now learn
    about a popular open source solution called **Trivy**.
  prefs: []
  type: TYPE_NORMAL
- en: Trivy is a comprehensive vulnerability scanner for container images. Trivy is
    capable of detecting vulnerabilities in most images based on popular base images,
    including Alpine, CentOS, and Red Hat UBI, and application package dependencies
    such as `npm`, `yarn`, `bundler`, and `composer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will manually install the `trivy` binaries and run a vulnerability
    analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get the latest release version tag of `trivy` and keep it in a variable
    called `TRIVYVERSION`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, download the latest `trivy` binary and install it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Confirm that the installation is successfully completed by executing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run `trivy` checks with a target image location and its tag. In our example,
    we scanned the `alpine:3.12` base image from its official Docker Hub repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding command should look as follows since no issues
    are found in the particular container image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Trivy results of a container image with no known vulnerabilities'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16192_08_003.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.3 – Trivy results of a container image with no known vulnerabilities
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s scan a publicly available version of the popular MongoDB database
    container image. MongoDB is used by many modern cloud-native applications and
    services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will notice that Trivy returned `93` known vulnerabilities, including `2`
    high and `28` medium severity issues:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Trivy results showing vulnerabilities'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16192_08_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Trivy results showing vulnerabilities
  prefs: []
  type: TYPE_NORMAL
- en: In the long analysis returned by the Trivy scanner, you can find vulnerability
    IDs and severity URLs to learn more about the issues. You can also see that some
    issues come from the Ubuntu 18.04 base image used in the container image and can
    be resolved by just updating the base image of the container.
  prefs: []
  type: TYPE_NORMAL
- en: Trivy supports most CI tools, including Travis CI, CircleCI, Jenkins, and GitLab
    CI. To learn more about Trivy and integration details, you can read the official
    documentation at [https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy).
  prefs: []
  type: TYPE_NORMAL
- en: Now we have learned how to test container images against known vulnerabilities.
    It is highly recommended to have test conditions in your build pipelines. Let's
    look into how we can test the impact of container image downloads from public
    repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the download speed of a container image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CI is a key component of automation, and the reduction of every second spent
    in the pipeline execution will be important. Download time also impacts the speed
    of the new container image rollout to the production environment. Therefore, we
    need to consider the download speeds of the container images used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will use the `time` command in Linux to execute `docker run` in a
    specified container base image and compare the summary of the real-time user CPU
    time and system CPU time spent during the process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `curl` utility in the `debian:buster-slim` Debian base image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For comparison, let''s now run the same command in the `alpine:3.12` image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that both images were not available in the local registry and were pulled
    for the first time from the public Docker Hub location. As you can see, the Alpine
    image completed the task in close to 2 seconds, whereas the same request took
    more than 40 seconds longer to finish using the Debian image.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have learned about measuring the command execution speed in containers
    based on different base images. Let's summarize everything we have learned in
    this section into a short list of simple container image best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Applying container base images best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Technically, most applications will run in containers layered on top of all
    the common and popular container base images. This may be acceptable for development
    and test purposes, but before rolling out any container images into production,
    there are a few common-sense best practices we should consider:'
  prefs: []
  type: TYPE_NORMAL
- en: The size of the container image is important as long as the container base image
    does not introduce a performance tax and vulnerabilities. Using a stable, compatible,
    and supported base image is preferred over saving a few megabytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never use the `latest` tag to pull base images when building your container
    images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure to use container images with the exact tested and validated version
    of the image. You can also specify its digest by replacing `<image-name>:<tag>`
    with `<image-name>@<digest>` to generate stable reproducible builds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check `imagePullPolicy` in your application manifests. Unless required otherwise,
    it is suggested to use `IfNotPresent`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When possible, use the same base OS in your container host and container images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate image vulnerability scanners into your CI pipelines and make sure
    to clear at least high and critical severity vulnerabilities before rolling your
    images into production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor container image size changes over time and notify maintainers of sudden
    large size changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using public container registries, store your container images in multiple
    registries. Some public registries include Docker Hub, GitLab Container Registry,
    Red Hat Quay, Amazon ECR, Azure Container Registry, and Google Cloud Container
    Registry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For increased security, use a private container registry and monitor public
    container registry pulls into the production environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we have learned about the challenges of choosing container images and production
    best practices. Let's look at different deployment strategies and their use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Learning application deployment strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizations without the expertise to design an application deployment strategy
    before getting their services to production users can face great operational complexity
    when managing their application life cycle. Many users still face container and
    microservices adoption issues later in their digital transformation journey and
    end up going back to the more expensive **Database as a Service** (**DbaaS**)
    model or even using traditional deployment methods in VMs. To avoid common mistakes
    and production anti-patterns, we need to be aware of some of the common strategies
    that will ensure our success in deploying and managing applications on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the differences between different Kubernetes controllers such
    as Deployments, ReplicaSets, and StatefulSets in the *Deploying stateful applications*
    section in [*Chapter 7*](B16192_07_Final_PG_ePub.xhtml#_idTextAnchor157), *Managing
    Storage and Stateful Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will learn about the following containerized application
    deployment best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the deployment model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using readiness and liveness probes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss each of them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the deployment model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Kubernetes, applications can be rolled out following various deployment
    procedures. Choosing the right strategy is not always easy since it really depends
    on your services and how your applications are accessed by users. Now, we will
    review the most common models:'
  prefs: []
  type: TYPE_NORMAL
- en: A/B testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blue/green
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canary release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incremental deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's learn about the advantages of each of them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: A/B testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A/B testing deployments allow routing groups of users to a new deployment based
    on conditions such as HTTP headers, location, browser cookies, or other user metadata.
    A/B testing deployments are preferred when a specific feature of the application
    needs to be tested on a certain group of users and rollout needs to continue based
    on the conversation rate. Price and UX testing are also done using A/B testing.
    Other than the complexity of the parameters that need to be managed, it is the
    most flexible model with low cloud cost, minimum impact on users, and quick rollback
    times.
  prefs: []
  type: TYPE_NORMAL
- en: Blue/green
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the blue/green deployment model, an equal amount of instances of each application
    is deployed on your cluster. This model can be executed either by traffic switching
    or by traffic mirroring when a service mesh such as Istio is used. It is preferred
    when service changes need to be tested for load and compliance with no impact
    on actual users. When the metrics return successful data, a new deployment (green)
    gets promoted. This model cannot be used to target a specific group of users and
    can be expensive in terms of cloud resource consumption cost due to its full deployment
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Canary release
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Canary deployments gradually shift traffic from one deployment to another based
    on percentage, sometimes triggered by metrics such as success rate or health.
    Canary releases are preferred when confidence in the new releases is not high
    or when deploying releases on a completely new platform. Groups of users cannot
    be targeted. This method doesn't increase public cloud costs and rollback times
    can be rather quick.
  prefs: []
  type: TYPE_NORMAL
- en: Clean deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this method, one version of the application is destroyed and a new version
    is deployed. It is preferred in deployment since it is the simplest method, although
    this method should not be used in production unless the service is not in use.
    If the deployment fails compared to the other methods, the rollback time would
    be the highest, and the service downtime would be the longest.
  prefs: []
  type: TYPE_NORMAL
- en: Incremental deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this method, a new version of the application is deployed in a rolling update
    fashion and slowly migrated. The only advantage of this model compared to a clean
    deployment is that incremental deployment does not introduce downtime.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the methods can only be implemented with the help of **service mesh**
    solutions, such as Istio, Linkerd, or AWS App Mesh, and ingress controllers, including
    Contour, Gloo, NGINX, or Traefik.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestration of multiple deployment strategies can turn into a complex configuration
    puzzle. In this case, the usage of an application delivery operator can be very
    useful. **Flagger** is one of the most complete progressive delivery Kubernetes
    operators in the Kubernetes ecosystem. Flagger can automate complex rollover scenarios
    using Istio, Linkerd, App Mesh, NGINX, Skipper, Contour, Gloo, or Traefik based
    on the metrics analysis from the metrics collected by Prometheus. To learn more
    about Flagger operators and a tutorial covering the models discussed here, you
    can read the official documentation at [https://docs.flagger.app/](https://docs.flagger.app/).
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Smooth, production-ready application deployment and canary analysis cannot be
    achieved without monitoring the application usage metrics. We can monitor our
    applications using tools such as Prometheus, Datadog, or Splunk.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover monitoring, visualizations, logging, tracing solutions, and how
    to make visualization dashboards relevant to serve our production needs in [*Chapter
    9*](B16192_09_Final_PG_ePub.xhtml#_idTextAnchor200), *Monitoring, Logging, and
    Observability*.
  prefs: []
  type: TYPE_NORMAL
- en: Using readiness and liveness container probes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a new pod is scheduled in our Kubernetes cluster, its phase is represented
    by the `PodStatus` object. These phases reported as `Pending`, `Running`, `Succeeded`,
    `Failed`, or `Unknown` do not represent or guarantee our application's intended
    function. You can read more about the pod life cycle and its phases on the official
    Kubernetes documentation site at [https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To monitor our application''s real health status inside the container, a regular
    diagnostic task can be executed. These diagnostic tests performed periodically
    are called `kubelet` can perform three types of container probes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`livenessProbe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readinessProbe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startupProbe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is highly recommended to use at minimum the readiness and liveness probes
    to control your application's health when starting and periodically after it is
    scheduled in your Kubernetes cluster. When enabled, `kubelet` can call three different
    handlers, `ExecAction`, `TCPSocketAction`, and `HTTPGetAction`, inside or against
    the pod's IP and validate your application's health.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter08/probes/liveness/busybox.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter08/probes/liveness/busybox.yaml).
  prefs: []
  type: TYPE_NORMAL
- en: In the next code snippet, we will create a `busybox` pod example that will use
    `livenessProbe` to execute a command inside the container image to check our pod's
    liveness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the template for the `busybox` pod in this `probes/liveness/busybox.yaml`
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When the container starts, it executes the command specified under the `args`
    section. This command first creates a file under `/tmp/alive`, and then waits
    30 seconds and removes it. `livenessProbe`, as specified in the same file, first
    waits 10 seconds, as defined by the `initialDelaySeconds` parameter, and then
    periodically, every 10 seconds, as defined by the `periodSeconds` parameter, executes
    the `cat` `/tmp/alive` command. In the first 30 seconds, our command will be successful
    and once the file is removed, `livenessProbe` will fail, and our pod will be restarted
    for losing its liveness state. Make sure you allow enough time for the pod to
    start by setting a reasonable `initialDelaySeconds` value.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can add `readinessProbe` by replacing the `livenessProbe` field
    with `readinessProbe`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have learned about the production deployment best practices on Kubernetes.
    We have also learned about common deployment strategies for rolling production
    applications and using container probes for verifying the health of our application.
    Next, we will learn how to scale our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling applications and achieving higher availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes container orchestration platform provides a wide range of functionality
    to help us deploy our applications in a scalable and highly available way. When
    designing architecture that will support horizontally scalable services and applications,
    we need to be aware of some common strategies that will help to successfully scale
    our applications on Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, *Learning application deployment strategies*, we covered
    some strategies that would help us to scale our applications, including deployment
    strategies and implementing health checks using container probes. In this section,
    we will learn about scaling applications using the **Horizontal Pod Autoscaler**
    (**HPA**).
  prefs: []
  type: TYPE_NORMAL
- en: When we first deploy our application on Kubernetes clusters, applications will
    very likely not get accessed immediately and usage will gradually increase over
    time. In that case, rolling out a deployment with many replicas would result in
    wasting our infrastructure resources. HPA in Kubernetes helps us increase the
    necessary resources in different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter08/hpa/deployment-nginx.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter08/hpa/deployment-nginx.yaml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will learn about configuring a basic HPA based on CPU utilization metrics.
    You can read more about HPA on the official Kubernetes documentation site at [https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/):'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t installed it before, make sure to install **Metrics Server**
    by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a deployment named `nginx-hpa` with a `replicas` count of `1` in the
    `hpa/deployment-nginx.yaml` path. Make sure to have `resources.request.cpu` set,
    otherwise HPA cannot function. In our example, we used an NGINX deployment. You
    can instead use any deployment you would like to apply HPA to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the following command to create the deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Confirm that your deployment is successful by checking its state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create an HPA named `nginx-autoscale` with a `minReplicas` count of `1`,
    a `maxReplicas` count of `5`, and `targetCPUUtilizationPercentage` set to `50`
    in the `hpa/hpa-nginx.yaml` path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the following command to create the deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Confirm that our HPA is successfully created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding command should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – HPA monitoring for CPU metrics to scale the application](img/B16192_08_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – HPA monitoring for CPU metrics to scale the application
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we used CPU utilization as our metric. HPA can use
    multiple metrics, including CPU, memory, and other custom external metrics such
    as service latency and I/O load, using **custom metrics adapters**. In addition
    to HPA, we can use **Pod Disruption Budgets** (**PDBs**) to avoid voluntary and
    involuntary disruptions to provide higher availability. You can read more about
    specifying a PDB for your application at [https://kubernetes.io/docs/tasks/run-application/configure-pdb/](https://kubernetes.io/docs/tasks/run-application/configure-pdb/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the components of container images, best practices
    for creating container images, and choosing the right base image type. We reduced
    our container image size by removing unnecessary files and using multistage builds.
    We learned how to scan our container images for vulnerabilities proactively. We
    learned about application deployment strategies to test and roll out new features
    and releases of our applications. We created an HPA to scale our applications.
    All the recommendations and best practices mentioned in this chapter help us reduce
    the attack surface and increase stability to improve efficiency in our production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Kubernetes observability and key metrics
    to monitor in production. We will learn about the tools and stacks to use or build,
    compare the best tools in the ecosystem, and learn how to deal with observability
    from a site reliability perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for more information on the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A Practical Introduction to Container Terminology*: [https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction/](https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open Container Initiative: [https://opencontainers.org/](https://opencontainers.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hardening ELF binaries using Relocation Read-Only (RELRO)*: [https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro](https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A Comparison of Linux Container Images*:[http://crunchtools.com/comparison-linux-container-images/](http://crunchtools.com/comparison-linux-container-images/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Alpine makes Python Docker builds way too (50×) slower, and images double
    (2×) larger*: [https://lih-verma.medium.com/alpine-makes-python-docker-builds-way-too-50-slower-and-images-double-2-larger-61d1d43cbc79](https://lih-verma.medium.com/alpine-makes-python-docker-builds-way-too-50-slower-and-images-double-2-larger-61d1d43cbc79)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Why Elastic moved from Alpine to CentOS base images*: [https://www.elastic.co/blog/docker-base-centos7](https://www.elastic.co/blog/docker-base-centos7)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introducing multi-architecture container images for Amazon ECR*: [https://aws.amazon.com/blogs/containers/introducing-multi-architecture-container-images-for-amazon-ecr/](https://aws.amazon.com/blogs/containers/introducing-multi-architecture-container-images-for-amazon-ecr/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to use distroless Docker images: [https://github.com/GoogleContainerTools/distroless](https://github.com/GoogleContainerTools/distroless)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Best practices for building containers*: [https://cloud.google.com/solutions/best-practices-for-building-containers](https://cloud.google.com/solutions/best-practices-for-building-containers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Automated rollback of Helm releases based on logs or metrics*: [https://blog.container-solutions.com/automated-rollback-helm-releases-based-logs-metrics](https://blog.container-solutions.com/automated-rollback-helm-releases-based-logs-metrics)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kubernetes – A Complete DevOps Cookbook* ([*Chapter 7*](B16192_07_Final_PG_ePub.xhtml#_idTextAnchor157),
    *Scaling and Upgrading Applications*): [https://www.packtpub.com/product/kubernetes-a-complete-devops-cookbook/9781838828042](https://www.packtpub.com/product/kubernetes-a-complete-devops-cookbook/9781838828042)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
