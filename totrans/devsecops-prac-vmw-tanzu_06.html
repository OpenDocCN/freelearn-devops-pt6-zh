<html><head></head><body>
<div class="IMG---Figure" id="_idContainer112">
<h1 class="chapter-number" id="_idParaDest-112"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-113"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.2.1">Managing Container Images with Harbor</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapters, we covered the tools in the Tanzu portfolio that help us build cloud-native applications. </span><span class="koboSpan" id="kobo.3.2">We started our first segment with an overview of the evolution of building, running, and managing modern cloud-native applications and their platforms. </span><span class="koboSpan" id="kobo.3.3">Then, we saw how we can start application development using templates, how to build secure container images, how to quickly provision backing services for the applications, and how to manage APIs using various Tanzu products. </span><span class="koboSpan" id="kobo.3.4">After learning about building cloud-native applications, in this chapter, we will take a deep dive into various aspects of </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">running them.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">As the title of this chapter indicates, we will learn how to manage our container images and securely make them accessible using Harbor to deploy our applications on Kubernetes. </span><span class="koboSpan" id="kobo.5.2">Harbor is an open source container</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.6.1"> registry project under the </span><strong class="bold"><span class="koboSpan" id="kobo.7.1">Cloud Native Computing Foundation</span></strong><span class="koboSpan" id="kobo.8.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.9.1">CNCF</span></strong><span class="koboSpan" id="kobo.10.1">) umbrella. </span><span class="koboSpan" id="kobo.10.2">Despite Harbor being a fully open source tool, we have included it in this book for three main reasons. </span><span class="koboSpan" id="kobo.10.3">Firstly, Harbor was incubated by VMware and donated to CNCF in mid-2018. </span><span class="koboSpan" id="kobo.10.4">VMware is also one of the major contributors to the project and has actively invested in Harbor since then. </span><span class="koboSpan" id="kobo.10.5">Secondly, Harbor has also been recognized as a graduate project under the CNCF umbrella, which is a state that is tagged as a very popular, mature, and stable project within the CNCF ecosystem. </span><span class="koboSpan" id="kobo.10.6">Finally, the main reason to include Harbor in this book is that VMware, being a significant stakeholder in this project, also provides commercial enterprise support for Harbor as a part of its </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Tanzu portfolio.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.12.1">Sidenote</span></p>
<p class="callout"><span class="koboSpan" id="kobo.13.1">Henceforth, in this chapter, we will refer to a </span><em class="italic"><span class="koboSpan" id="kobo.14.1">container image</span></em><span class="koboSpan" id="kobo.15.1"> as an </span><em class="italic"><span class="koboSpan" id="kobo.16.1">image</span></em><span class="koboSpan" id="kobo.17.1"> only </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">for brevity.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">In this chapter, we will cover Harbor in detail by covering the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">following topics:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.21.1">Why Harbor?</span></strong><span class="koboSpan" id="kobo.22.1">: A walkthrough of the features and capabilities </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">of Harbor</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.24.1">Unboxing Harbor</span></strong><span class="koboSpan" id="kobo.25.1">: A detailed overview of the anatomy </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">of Harbor</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.27.1">Getting started with Harbor</span></strong><span class="koboSpan" id="kobo.28.1">: Learn how to install and </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">configure Harbor</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.30.1">Common day-2 operations with Harbor</span></strong><span class="koboSpan" id="kobo.31.1">: Learn how to perform various configuration and usage-related activities </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">on Harbor</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.33.1">Let’s start by learning about the background </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">of Harbor.</span></span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.35.1">Why Harbor?</span></h1>
<p><span class="koboSpan" id="kobo.36.1">In this section, we will</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.37.1"> review the various features, capabilities, and reasons to consider using Harbor as a container registry. </span><span class="koboSpan" id="kobo.37.2">These reasons will be explained using the security, control, and extensibility features of Harbor as </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">described henceforth.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.39.1">Using Harbor for security</span></h2>
<p><span class="koboSpan" id="kobo.40.1">There </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.41.1">are some strong security reasons and features that make Harbor a good choice for a container registry, which shifts security to a proactive measure rather than reactive in the applications’ journey toward production. </span><span class="koboSpan" id="kobo.41.2">Let’s review these</span><a id="_idIndexMarker244"/> <span class="No-Break"><span class="koboSpan" id="kobo.42.1">security benefits:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.43.1">Harbor comes with the capability to scan each image for the presence of </span><strong class="bold"><span class="koboSpan" id="kobo.44.1">critical vulnerability exposures</span></strong><span class="koboSpan" id="kobo.45.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.46.1">CVEs</span></strong><span class="koboSpan" id="kobo.47.1">) as a </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.48.1">result of certain software libraries and operating system versions used in the image. </span><span class="koboSpan" id="kobo.48.2">Such scanning provides a detailed report of the CVEs found in the corresponding image, along with their severity level, details of the exposure, and the version of the software in which that CVE is remediated. </span><span class="koboSpan" id="kobo.48.3">We can get such scanning results using either the web portal or using the REST APIs provided by Harbor. </span><span class="koboSpan" id="kobo.48.4">Harbor also allows you to use an external image scanning tool in place of or in addition to the default one. </span><span class="koboSpan" id="kobo.48.5">Such visibility of the possible security loopholes in the images could provide a preventative security posture well in advance in the application </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">deployment process.</span></span></li>
<li><span class="koboSpan" id="kobo.50.1">Depending on the application environment and the preferred tolerance level, Harbor also provides a way to prevent its clients from pulling such images that are scanned for CVEs and contain CVEs higher than the allowed severity level. </span><span class="koboSpan" id="kobo.50.2">For example, we can configure a policy in Harbor that any image that has CVEs found with categories more than medium severity in a project named </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">Production Repo</span></strong><span class="koboSpan" id="kobo.52.1"> may not be pulled to deploy containers. </span><span class="koboSpan" id="kobo.52.2">This capability provides required guardrails to prevent damage at the front gate itself. </span><span class="koboSpan" id="kobo.52.3">It ensures that the</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.53.1"> flagged images are never allowed to be pulled to run workloads and allow bad actors to exploit </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">them later.</span></span></li>
<li><span class="koboSpan" id="kobo.55.1">Harbor also supports integrations with Notary (</span><a href="https://github.com/notaryproject/notary"><span class="koboSpan" id="kobo.56.1">https://github.com/notaryproject/notary</span></a><span class="koboSpan" id="kobo.57.1">), which is an open source project that can digitally sign the images for authenticity. </span><span class="koboSpan" id="kobo.57.2">You can create a container deployment pipeline using such an image signing utility to allow only signed and hence authorized images to be deployed in your production environment. </span><span class="koboSpan" id="kobo.57.3">Such an arrangement can greatly enhance your security posture as no unverified, unscanned, or potentially dangerous images can be deployed in </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">your environment.</span></span></li>
<li><span class="koboSpan" id="kobo.59.1">Harbor has </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.60.1">robust </span><strong class="bold"><span class="koboSpan" id="kobo.61.1">role-based access control</span></strong><span class="koboSpan" id="kobo.62.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.63.1">RBAC</span></strong><span class="koboSpan" id="kobo.64.1">) capabilities. </span><span class="koboSpan" id="kobo.64.2">It allows you to configure users with two levels, mainly at the project level and at the system level, to provide the required control and flexibility for a </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">multi-tenant environment.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.66.1">Moreover, Harbor also </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.67.1">allows you to separate user accounts from system accounts (known as </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">r</span></strong><strong class="bold"><span class="koboSpan" id="kobo.69.1">obot accounts</span></strong><span class="koboSpan" id="kobo.70.1"> in Harbor) that can be used for </span><strong class="bold"><span class="koboSpan" id="kobo.71.1">continuous integration</span></strong><span class="koboSpan" id="kobo.72.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.73.1">CI</span></strong><span class="koboSpan" id="kobo.74.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.75.1">continuous deployment</span></strong><span class="koboSpan" id="kobo.76.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.77.1">CD</span></strong><span class="koboSpan" id="kobo.78.1">) automation</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.79.1"> processes. </span><span class="koboSpan" id="kobo.79.2">We may specify required</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.80.1"> permissions to such robot accounts to perform only allowed operations using the </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">automation processes.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.82.1">We may create a hub-and-spoke architecture while using Harbor as the hub that replicates images to and from either external or other internal Harbor container registries. </span><span class="koboSpan" id="kobo.82.2">An example of such a deployment is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.83.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.84.1">.1</span></em><span class="koboSpan" id="kobo.85.1">. </span><span class="koboSpan" id="kobo.85.2">Such an arrangement may allow organizations to prevent their internal users from pulling arbitrary and insecure images from unauthorized sources. </span><span class="koboSpan" id="kobo.85.3">But at the same time, it allows them to pull those images from only the internally deployed Harbor, which</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.86.1"> would have replicated authorized images from an external image repository. </span><span class="koboSpan" id="kobo.86.2">This feature provides the required control to ensure security without affecting developers’ freedom </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">and productivity.</span></span></li>
<li><span class="koboSpan" id="kobo.88.1">As we will see later in this chapter, Harbor has several components and supports many external integrations for various capabilities. </span><span class="koboSpan" id="kobo.88.2">To ensure the safety of such data transfers, all these</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.89.1"> inter-component communication channels use </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">Transport Layer Security</span></strong><span class="koboSpan" id="kobo.91.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.92.1">TLS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">) encryption.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.94.1">After </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.95.1">reviewing the key features of Harbor around security, let’s check what its benefits are from an operational control point </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">of view.</span></span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.97.1">Using Harbor for operational control</span></h2>
<p><span class="koboSpan" id="kobo.98.1">There are</span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.99.1"> several popular container registries available in the market as</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.100.1"> online </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">Software-as-a-Service</span></strong><span class="koboSpan" id="kobo.102.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.103.1">SaaS</span></strong><span class="koboSpan" id="kobo.104.1">) offerings, including Docker Hub, </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">Google Container Registry</span></strong><span class="koboSpan" id="kobo.106.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.107.1">GCR</span></strong><span class="koboSpan" id="kobo.108.1">), and </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.109.1">offerings from many other cloud providers. </span><span class="koboSpan" id="kobo.109.2">The point where Harbor differs from these online options is the fact that it can be deployed in an air-gapped environment. </span><span class="koboSpan" id="kobo.109.3">When there is a need to keep the application images private and on-premise, we need an offering like Harbor. </span><span class="koboSpan" id="kobo.109.4">With such on-premises deployments, as discussed in the previous section about security-specific reasons, Harbor provides a control mechanism to expose only authorized images that are replicated in Harbor from external sources for internal consumption. </span><span class="koboSpan" id="kobo.109.5">This way, the operators can prevent internal image users from downloading potentially vulnerable images from </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">unauthorized sources.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">Additionally, Harbor is also an open source community-driven project that is at the </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">Graduated</span></strong><span class="koboSpan" id="kobo.113.1"> maturity level in CNCF, like Kubernetes. </span><span class="koboSpan" id="kobo.113.2">CNCF only graduates an open source project when there is a significant community contribution and adoption. </span><span class="koboSpan" id="kobo.113.3">Since VMware is one of the major contributors to the project, it also provides commercial support </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">for Harbor.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">Along with the point of being a CNCF-mature and commercially supported open source project, Harbor has an array of multi-tenancy features. </span><span class="koboSpan" id="kobo.115.2">We will visit some of these features later in this chapter. </span><span class="koboSpan" id="kobo.115.3">But at a high level, Harbor admins can configure team-wise storage quotas for images and choose from different image vulnerability scanners, image retention periods, team-wise webhook configurations to trigger a CD pipeline, CVE whitelisting, and a few others. </span><span class="koboSpan" id="kobo.115.4">Having these configurations separate for different teams using the same deployment of Harbor provides the required operational control to Harbor admins, along with the required flexibility to the </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">user groups.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">Lastly, under </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.118.1">the operational control area, Harbor provides various general administrative configurations that are common for the deployment and all user groups. </span><span class="koboSpan" id="kobo.118.2">Such configurations include the following </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">administrative controls:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.120.1">Cleaning up all untagged artifacts using a garbage collection routine that can be triggered on-demand </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">or scheduled</span></span></li>
<li><span class="koboSpan" id="kobo.122.1">Managing user groups and </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">their permissions</span></span></li>
<li><span class="koboSpan" id="kobo.124.1">Configuring external or internal </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.125.1">authentication </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.126.1">providers, including </span><strong class="bold"><span class="koboSpan" id="kobo.127.1">Light-weight Directory Access Protocol</span></strong><span class="koboSpan" id="kobo.128.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.129.1">LDAP</span></strong><span class="koboSpan" id="kobo.130.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.131.1">Open ID Connect</span></strong><span class="koboSpan" id="kobo.132.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.133.1">OIDC</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">) systems</span></span></li>
<li><span class="koboSpan" id="kobo.135.1">Configuring </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.136.1">custom </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">Open Container Initiative</span></strong><span class="koboSpan" id="kobo.138.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.139.1">OCI</span></strong><span class="koboSpan" id="kobo.140.1">) artifacts to store binary objects other than images </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">in Harbor</span></span></li>
<li><span class="koboSpan" id="kobo.142.1">Configuring image proxy caching to allow externally hosted images to be stored in an </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">offline mode</span></span></li>
<li><span class="koboSpan" id="kobo.144.1">Accessing key performance metrics to check on </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">Harbor’s health</span></span></li>
<li><span class="koboSpan" id="kobo.146.1">Enabling the distributed tracing telemetry data for enhanced troubleshooting capabilities </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">for Harbor</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.148.1">Tip</span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.149.1">Open Container Initiative</span></strong><span class="koboSpan" id="kobo.150.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.151.1">OCI</span></strong><span class="koboSpan" id="kobo.152.1">) is an </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.153.1">open governance structure for creating open industry standards around container formats and </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.154.1">runtimes. </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">Source: </span></span><a href="https://opencontainers.org/"><span class="No-Break"><span class="koboSpan" id="kobo.156.1">https://opencontainers.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.157.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">After seeing how Harbor can help to obtain control over various types of configurations, let’s see one more category of reasons to use Harbor – </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">its extensibility.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.160.1">Using Harbor for its extensibility</span></h2>
<p><span class="koboSpan" id="kobo.161.1">Harbor is</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.162.1"> a solution that is comprised of a few different microservices that work together to serve the purpose of being a purpose-built container registry. </span><span class="koboSpan" id="kobo.162.2">It </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.163.1">has several components that can be replaced with other available options providing similar functionalities. </span><span class="koboSpan" id="kobo.163.2">Moreover, we can extend some functionalities to provide more choices for the end users to pick from. </span><span class="koboSpan" id="kobo.163.3">Such areas of extensibility include integration with an external container registry, CVE scanners, authentication providers, and OCI-compliant objects that can be hosted on Harbor. </span><span class="koboSpan" id="kobo.163.4">The following sections describe them </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">in detail.</span></span></p>
<h3><span class="koboSpan" id="kobo.165.1">Extending image sources and destinations through replication</span></h3>
<p><span class="koboSpan" id="kobo.166.1">Harbor </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.167.1">allows you to create image replication rules to extend the image library using an external image repository. </span><span class="koboSpan" id="kobo.167.2">That way, the clients of Harbor can the pull required images from an external repository such as Docker Hub without accessing Docker Hub. </span><span class="koboSpan" id="kobo.167.3">Such extensions are helpful for an air-gapped deployment where open internet access and open image downloading from a public repository are not desirable from a security point of view. </span><span class="koboSpan" id="kobo.167.4">Additionally, Harbor allows you to create replication rules for push and pull operations for a bidirectional flow of artifacts. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.168.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.169.1">.1</span></em><span class="koboSpan" id="kobo.170.1"> shows how </span><em class="italic"><span class="koboSpan" id="kobo.171.1">the central Harbor repository</span></em><span class="koboSpan" id="kobo.172.1"> pulls (replicates) images from </span><em class="italic"><span class="koboSpan" id="kobo.173.1">Docker Hub</span></em><span class="koboSpan" id="kobo.174.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.175.1">GCR</span></em><span class="koboSpan" id="kobo.176.1"> and then pushes those images to the </span><em class="italic"><span class="koboSpan" id="kobo.177.1">remote Harbor repositories</span></em><span class="koboSpan" id="kobo.178.1"> for a better network co-location for the nearby Kubernetes clusters. </span><span class="koboSpan" id="kobo.178.2">The arrows in the figure indicate the flow </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">of images:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.180.1"><img alt="Figure 6.1 – Harbor deployment topology to take advantage of the replication feature" src="image/B18145_06_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.181.1">Figure 6.1 – Harbor deployment topology to take advantage of the replication feature</span></p>
<p><span class="koboSpan" id="kobo.182.1">Such </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.183.1">extensions of image repository locations for different sources and destinations can be very useful to provide controlled access to the replicated images from security and governance. </span><span class="koboSpan" id="kobo.183.2">Additionally, it can also help reduce network latency and </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">bandwidth requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">In addition to using Harbor for replication, we can also configure Harbor as a proxy to cache externally located images. </span><span class="koboSpan" id="kobo.185.2">This caching arrangement can help save network latency in transferring frequently used images and save the network bandwidth required for internet traffic. </span><span class="koboSpan" id="kobo.185.3">Additionally, using Harbor for caching may cache only used images for a given timeframe. </span><span class="koboSpan" id="kobo.185.4">And if the image is not actively pulled, then it is removed. </span><span class="koboSpan" id="kobo.185.5">However, such a proxy configuration allows more freedom to access any available images versus only replicated ones. </span><span class="koboSpan" id="kobo.185.6">Both replication and caching have their use cases, pros, </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">and cons.</span></span></p>
<h3><span class="koboSpan" id="kobo.187.1">Adding or replacing vulnerability scanners</span></h3>
<p><span class="koboSpan" id="kobo.188.1">By default, Harbor</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.189.1"> comes with Trivy (</span><a href="https://github.com/aquasecurity/trivy"><span class="koboSpan" id="kobo.190.1">https://github.com/aquasecurity/trivy</span></a><span class="koboSpan" id="kobo.191.1">) for CVE scanning of </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.192.1">images. </span><span class="koboSpan" id="kobo.192.2">However, you can</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.193.1"> incorporate your own instance of a Trivy implementation if you have one. </span><span class="koboSpan" id="kobo.193.2">You may also integrate a different CVE scanner with Harbor in place of or in addition to Trivy. </span><span class="koboSpan" id="kobo.193.3">This extension allows different teams to use their preferred scanner from the list of supported ones by Harbor. </span><span class="koboSpan" id="kobo.193.4">In the present scenario, Harbor supports Clair, Anchore, Aqua, DoSec, Sysdig Secure, and Tensor Security in addition </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">to Trivy.</span></span></p>
<h3><span class="koboSpan" id="kobo.195.1">Extending authentication providers</span></h3>
<p><span class="koboSpan" id="kobo.196.1">Harbor provides</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.197.1"> database-level authentication where user accounts can be directly configured in Harbor as the default and primitive approach. </span><span class="koboSpan" id="kobo.197.2">However, the administrator may configure Harbor to use either an LDAP/Active Directory service or an OIDC provider. </span><span class="koboSpan" id="kobo.197.3">In that case, such external authentication providers will be used to create and manage user accounts. </span><span class="koboSpan" id="kobo.197.4">Harbor will redirect authentication requests to these external authentication providers and based on the identity provided by the authentication provider, Harbor grants the required access to </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">the user.</span></span></p>
<h3><span class="koboSpan" id="kobo.199.1">Extending user-defined OCI artifacts hosting</span></h3>
<p><span class="koboSpan" id="kobo.200.1">Along with</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.201.1"> images, Harbor can also store Helm charts and other user-defined OCI artifacts. </span><span class="koboSpan" id="kobo.201.2">Such artifacts can be </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">Kubeflow</span></strong><span class="koboSpan" id="kobo.203.1"> data</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.204.1"> models, which are used for machine learning on Kubernetes. </span><span class="koboSpan" id="kobo.204.2">For such extensions, the objects must follow Harbor-specific configuration using a manifest file. </span><span class="koboSpan" id="kobo.204.3">The use cases of such user-defined extensions are rare </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">but possible.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">So far in this chapter, we have seen different security, operational, and extensibility reasons explaining the </span><em class="italic"><span class="koboSpan" id="kobo.207.1">Why</span></em><span class="koboSpan" id="kobo.208.1"> behind using Harbor as a container repository. </span><span class="koboSpan" id="kobo.208.2">It is open source but supported by VMware and a lightweight, flexible, and purpose-built container registry that also helps enhance the overall container security posture via image scanning, replication, and signing features. </span><span class="koboSpan" id="kobo.208.3">In the next section of this chapter, we will discuss the </span><em class="italic"><span class="koboSpan" id="kobo.209.1">What</span></em><span class="koboSpan" id="kobo.210.1"> part of Harbor to see what is under </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">the hood.</span></span></p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.212.1">Unboxing Harbor</span></h1>
<p><span class="koboSpan" id="kobo.213.1">After</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.214.1"> seeing some good reasons to consider using Harbor as a container artifact repository around business, security, operational control, and extensibility, let’s learn what Harbor is made up of. </span><span class="koboSpan" id="kobo.214.2">In this section, we will learn about the internal components and functions of Harbor. </span><span class="koboSpan" id="kobo.214.3">Being a container registry to serve the cloud-native community, Harbor itself is a cloud-native application comprised of multiple smaller </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.215.1">microservices performing different activities. </span><span class="koboSpan" id="kobo.215.2">Let’s understand how they work together by providing an architectural overview </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">of Harbor.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.217.1">Architecture overview</span></h2>
<p><span class="koboSpan" id="kobo.218.1">Harbor</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.219.1"> has several internal and external components. </span><span class="koboSpan" id="kobo.219.2">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.220.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.221.1">.2</span></em><span class="koboSpan" id="kobo.222.1">, we can distribute these components into the </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">following</span></span><span class="No-Break"><a id="_idIndexMarker276"/></span><span class="No-Break"><span class="koboSpan" id="kobo.224.1"> categories:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.225.1">Consumers</span></strong><span class="koboSpan" id="kobo.226.1">: Consist of all clients and </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">client interfaces</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.228.1">Fundamental Services</span></strong><span class="koboSpan" id="kobo.229.1">: Consist of all core functionalities that are part of the Harbor project and other key third-party projects that are essential components of the </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">overall package</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.231.1">Data Access Layer</span></strong><span class="koboSpan" id="kobo.232.1">: Consists of all the different </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">data stores</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.234.1">Identity Providers</span></strong><span class="koboSpan" id="kobo.235.1">: Consist of all external authentication </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">provider extensions</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.237.1">Scan Providers</span></strong><span class="koboSpan" id="kobo.238.1">: Consist of all external image CVE </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">scanner extensions</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.240.1">Replicated Registry Providers</span></strong><span class="koboSpan" id="kobo.241.1">: Consist of all external image </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">replication extensions:</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.243.1"><img alt="Figure 6.2 – Harbor 2.0 architecture (https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor)" src="image/B18145_06_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.244.1">Figure 6.2 – Harbor 2.0 architecture (</span><a href="https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor"><span class="koboSpan" id="kobo.245.1">https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor</span></a><span class="koboSpan" id="kobo.246.1">)</span></p>
<p><span class="koboSpan" id="kobo.247.1">Let’s review some of the key components covered in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.248.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.249.1">.2</span></em><span class="koboSpan" id="kobo.250.1">. </span><span class="koboSpan" id="kobo.250.2">You will see these components deployed in your Kubernetes environment when we install and configure Harbor later in </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">this chapter.</span></span></p>
<h3><span class="koboSpan" id="kobo.252.1">Harbor Chart Museum</span></h3>
<p><span class="koboSpan" id="kobo.253.1">As we </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.254.1">discussed previously, along with images, Harbor also supports storing Helm charts. </span><span class="koboSpan" id="kobo.254.2">To support this feature, Harbor internally uses </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">Chart Museum</span></strong><span class="koboSpan" id="kobo.256.1">, an</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.257.1"> open source project for the Helm chart repository. </span><span class="koboSpan" id="kobo.257.2">Visit </span><a href="https://chartmuseum.com/"><span class="koboSpan" id="kobo.258.1">https://chartmuseum.com/</span></a><span class="koboSpan" id="kobo.259.1"> for</span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.260.1"> more details. </span><span class="koboSpan" id="kobo.260.2">You can see this project deployed as a Kubernetes deployment resource named </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">my-harbor-chartmuseum</span></strong><span class="koboSpan" id="kobo.262.1"> with a Kubernetes service running with the same name once you have a running instance of Harbor in your </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">Kubernetes cluster.</span></span></p>
<h3><span class="koboSpan" id="kobo.264.1">Harbor Core</span></h3>
<p><span class="koboSpan" id="kobo.265.1">As described in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.266.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.267.1">.2</span></em><span class="koboSpan" id="kobo.268.1">, Harbor Core is</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.269.1"> a collection of</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.270.1"> several modules that include key capabilities of Harbor being a container registry. </span><span class="koboSpan" id="kobo.270.2">These capabilities include concerns such as API management, authentication and authorization, interfacing glues, including pluggable image replication providers, image scanners, and image signature providers, and other foundational functionalities such as multitenancy capabilities, configuration management, artifact manager, and others. </span><span class="koboSpan" id="kobo.270.3">In</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.271.1"> our Kubernetes-based </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.272.1">Harbor deployment, all the modules displayed in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.273.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.274.1">.2</span></em><span class="koboSpan" id="kobo.275.1"> under </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">Core</span></strong><span class="koboSpan" id="kobo.277.1"> are deployed as a Kubernetes deployment resource named </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">my-harbor-core</span></strong><span class="koboSpan" id="kobo.279.1">, and this is exposed as a Kubernetes service resource with the </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">same name.</span></span></p>
<h3><span class="koboSpan" id="kobo.281.1">Harbor job service</span></h3>
<p><span class="koboSpan" id="kobo.282.1">This is Harbor’s </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.283.1">asynchronous task execution engine that exposes the required REST APIs for other components to submit their job requests. </span><span class="koboSpan" id="kobo.283.2">One such example is a job to scan an image. </span><span class="koboSpan" id="kobo.283.3">You will see this microservice also getting deployed as its own Kubernetes deployment and a service </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">my-harbor-jobservice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.287.1">Harbor Notary</span></h3>
<p><span class="koboSpan" id="kobo.288.1">Notary (</span><a href="https://github.com/notaryproject/notary"><span class="koboSpan" id="kobo.289.1">https://github.com/notaryproject/notary</span></a><span class="koboSpan" id="kobo.290.1">) is a </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.291.1">third-party</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.292.1"> open source project under the </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.293.1">CNCF umbrella. </span><span class="koboSpan" id="kobo.293.2">It is used to provide content trust establishment capabilities, which are achieved through an image signing procedure. </span><span class="koboSpan" id="kobo.293.3">As reviewed under the security-related reasons to use Harbor, such an image signing capability could be a great way to ensure that only verified images are deployed in a Kubernetes environment. </span><span class="koboSpan" id="kobo.293.4">It allows the image publisher to digitally sign an image using a private key authenticating the signer. </span><span class="koboSpan" id="kobo.293.5">Then, the consumers of that image can verify the publisher/signer of the image and take an informed decision to either trust or distrust the image based on the digital signature and the associated metadata. </span><span class="koboSpan" id="kobo.293.6">In secured and fully automated Kubernetes platforms, such operations of image signing and their verification are the steps of a CI/CD pipeline. </span><span class="koboSpan" id="kobo.293.7">Notary provides this functionality using its two main components – the server and the signer. </span><span class="koboSpan" id="kobo.293.8">The Notary server is responsible to store content metadata, ensuring the validity of the uploaded content, attaching the timestamps, and serving this content to the clients when requested. </span><span class="koboSpan" id="kobo.293.9">On the other side, the Notary signer is responsible for storing the private signing keys in a separate database from the Notary server database and performing the signing operations using these keys as and when requested by the Notary server. </span><span class="koboSpan" id="kobo.293.10">You will see these two components deployed as Kubernetes deployment resources named </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">my-harbor-notary-server</span></strong><span class="koboSpan" id="kobo.295.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">my-harbor-notary-signer</span></strong><span class="koboSpan" id="kobo.297.1">, along with their corresponding service resources, in a Kubernetes-based Harbor deployment that we will cover later in </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">this chapter.</span></span></p>
<h3><span class="koboSpan" id="kobo.299.1">Harbor portal</span></h3>
<p><span class="koboSpan" id="kobo.300.1">As the</span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.301.1"> name suggests, it is the </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">graphical user interface</span></strong><span class="koboSpan" id="kobo.303.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.304.1">GUI</span></strong><span class="koboSpan" id="kobo.305.1">) for Harbor. </span><span class="koboSpan" id="kobo.305.2">It</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.306.1"> provides sophisticated screens to perform all image registry and administrative configuration activities. </span><span class="koboSpan" id="kobo.306.2">In </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.307.1">addition to this portal, Harbor also supports all operations using a REST API interface for automation requirements. </span><span class="koboSpan" id="kobo.307.2">You will see this component deployed as a Kubernetes deployment resource named </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">my-harbor-portal</span></strong><span class="koboSpan" id="kobo.309.1">, along with its corresponding service with the same name, later in </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">this chapter.</span></span></p>
<h3><span class="koboSpan" id="kobo.311.1">Harbor registry</span></h3>
<p><span class="koboSpan" id="kobo.312.1">This is based on</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.313.1"> the open source project named </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.314.1">Distribution (</span><a href="https://github.com/distribution/distribution"><span class="koboSpan" id="kobo.315.1">https://github.com/distribution/distribution</span></a><span class="koboSpan" id="kobo.316.1">), which wraps functionalities to pack, ship, store, and deliver content. </span><span class="koboSpan" id="kobo.316.2">It implements the standards defined by the OCI Distribution Specification. </span><span class="koboSpan" id="kobo.316.3">It is the core library used for image registry operations and used by many open source and commercial registries, including Docker Hub, GitLab Container Registry, and DigitalOcean Container Registry, including Harbor. </span><span class="koboSpan" id="kobo.316.4">You will see this component deployed as a Kubernetes deployment resource named </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">my-harbor-registry</span></strong><span class="koboSpan" id="kobo.318.1">, along with its exposed service with the same name, later in </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">this chapter.</span></span></p>
<h3><span class="koboSpan" id="kobo.320.1">PostgreSQL database</span></h3>
<p><span class="koboSpan" id="kobo.321.1">This </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.322.1">is the main database of Harbor and is </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.323.1">used to store all required configurations and metadata used in Harbor. </span><span class="koboSpan" id="kobo.323.2">It stores all Harbor constructs, including but not limited to the data related to projects, users, policies, scanners, charts, and images. </span><span class="koboSpan" id="kobo.323.3">It is deployed as a stateful set on a Kubernetes cluster called </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">my-harbor-postgresql</span></strong><span class="koboSpan" id="kobo.325.1">, along with its service resource exposed with the </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">same name.</span></span></p>
<h3><span class="koboSpan" id="kobo.327.1">Redis cache</span></h3>
<p><span class="koboSpan" id="kobo.328.1">This is also deployed </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.329.1">as a stateful set on Kubernetes</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.330.1"> and it is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">my-harbor-redis-master</span></strong><span class="koboSpan" id="kobo.332.1">. </span><span class="koboSpan" id="kobo.332.2">It is used as a key-value store to cache the required metadata used by the </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">job service.</span></span></p>
<h3><span class="koboSpan" id="kobo.334.1">Trivy Scanner</span></h3>
<p><span class="koboSpan" id="kobo.335.1">This is an</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.336.1"> open source project by Aqua Security (</span><a href="https://github.com/aquasecurity/trivy"><span class="koboSpan" id="kobo.337.1">https://github.com/aquasecurity/trivy</span></a><span class="koboSpan" id="kobo.338.1">) and the</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.339.1"> default image</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.340.1"> CVE scanner that is deployed with Harbor 2.x. </span><span class="koboSpan" id="kobo.340.2">It can scan operating system layers and language-specific packages that are used in the image to find known vulnerability exposures present in those artifacts. </span><span class="koboSpan" id="kobo.340.3">Harbor uses such scanners to provide a comprehensive scanning capability. </span><span class="koboSpan" id="kobo.340.4">Such scanners can scan images and produce detailed reports, including CVE metadata. </span><span class="koboSpan" id="kobo.340.5">Such metadata includes a list of CVE numbers, vulnerability areas, severity levels, fixed versions if available, and other details. </span><span class="koboSpan" id="kobo.340.6">You will see this component getting deployed as </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">my-harbor-trivy</span></strong><span class="koboSpan" id="kobo.342.1"> as a Kubernetes deployment post </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">our installation.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.344.1">What is my-harbor?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.345.1">The prefix, </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">my-harbor</span></strong><span class="koboSpan" id="kobo.347.1">, that you have seen in the names of different components that will be deployed in your Kubernetes cluster is an arbitrary name given to the Helm chart instance of Harbor at the time of deployment. </span><span class="koboSpan" id="kobo.347.2">It can be replaced with any </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">other name.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">There are several other internal and external components described in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.350.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.351.1">.2</span></em><span class="koboSpan" id="kobo.352.1"> other than what we have covered here. </span><span class="koboSpan" id="kobo.352.2">The components we have covered are based on what is deployed on our Kubernetes cluster under Harbor’s namespace. </span><span class="koboSpan" id="kobo.352.3">To learn more details about Harbor’s architecture, visit this </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">link: </span></span><a href="https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor"><span class="No-Break"><span class="koboSpan" id="kobo.354.1">https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.355.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">Now that we’ve learned about the different modules of Harbor, let’s learn how to install and configure it on a </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">Kubernetes cluster.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.358.1">Getting started with Harbor</span></h1>
<p><span class="koboSpan" id="kobo.359.1">In this section, we</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.360.1"> will learn how to install and configure a Harbor registry instance on an existing Kubernetes cluster. </span><span class="koboSpan" id="kobo.360.2">But before we do that, we need to ensure that the following prerequisites </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">are met.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.362.1">Prerequisites</span></h2>
<p><span class="koboSpan" id="kobo.363.1">The</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.364.1"> following are the prerequisites for the Harbor installation instructions given in </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">this section:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.366.1">Kubernetes cluster with </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">version 1.10+</span></span></li>
<li><span class="koboSpan" id="kobo.368.1">Open internet connectivity from the </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">Kubernetes cluster</span></span></li>
<li><span class="koboSpan" id="kobo.370.1">The operator machine should have the </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">following tools:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">docker</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.373.1">CLI: </span></span><a href="https://docs.docker.com/get-docker/"><span class="No-Break"><span class="koboSpan" id="kobo.374.1">https://docs.docker.com/get-docker/</span></span></a></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">helm</span></strong><span class="koboSpan" id="kobo.376.1"> CLI version </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">2.8.0+: </span></span><a href="https://helm.sh/docs/intro/install/"><span class="No-Break"><span class="koboSpan" id="kobo.378.1">https://helm.sh/docs/intro/install/</span></span></a></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">kubectl</span></strong><span class="koboSpan" id="kobo.380.1"> CLI version </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">1.10+: </span></span><a href="https://kubernetes.io/docs/tasks/tools/"><span class="No-Break"><span class="koboSpan" id="kobo.382.1">https://kubernetes.io/docs/tasks/tools/</span></span></a></li></ul></li>
<li><span class="koboSpan" id="kobo.383.1">There should be a</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.384.1"> default </span><strong class="bold"><span class="koboSpan" id="kobo.385.1">StorageClass</span></strong><span class="koboSpan" id="kobo.386.1"> configured in your Kubernetes cluster that Harbor can use to create required storage volumes. </span><span class="koboSpan" id="kobo.386.2">By default, Harbor will need several </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">PersistentVolumeClaim</span></strong><span class="koboSpan" id="kobo.388.1"> resources</span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.389.1"> that are used by Redis cache, a PostgreSQL database, the registry storage, </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">and more.</span></span></li>
<li><span class="koboSpan" id="kobo.391.1">The infrastructure running the Kubernetes cluster should be able to expose an externally accessible IP address </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.392.1">upon the creation of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">LoadBalancer</span></strong><span class="koboSpan" id="kobo.394.1"> type Kubernetes service, making it accessible outside the Kubernetes cluster. </span><span class="koboSpan" id="kobo.394.2">We have used </span><strong class="bold"><span class="koboSpan" id="kobo.395.1">Google Kubernetes Engine</span></strong><span class="koboSpan" id="kobo.396.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.397.1">GKE</span></strong><span class="koboSpan" id="kobo.398.1">) in this chapter, which automatically creates a load balancer instance on GCP to front the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">LoadBalancer</span></strong><span class="koboSpan" id="kobo.400.1"> type service deployed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">GKE cluster.</span></span></li>
<li><span class="koboSpan" id="kobo.402.1">The operator machine should have a browser to access the </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">Harbor GUI.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.404.1">Additional learning</span></p>
<p class="callout"><span class="koboSpan" id="kobo.405.1">To keep the deployment of Harbor on Kubernetes simpler, we could also deploy it as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">NodePort</span></strong><span class="koboSpan" id="kobo.407.1"> service and access it externally using the Kubernetes node IP address and the port associated with the Harbor service. </span><span class="koboSpan" id="kobo.407.2">However, we cannot access this deployment of Harbor from a Docker client to push and pull images using the node port. </span><span class="koboSpan" id="kobo.407.3">This is because the Docker client can only connect to a registry using port </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">443</span></strong><span class="koboSpan" id="kobo.409.1"> (HTTPS) or port </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">80</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.411.1"> (HTTP).</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.412.1">Deploying a load balancer machine or a service instance for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">LoadBalancer</span></strong><span class="koboSpan" id="kobo.414.1"> type service running on a Kubernetes cluster is not an efficient approach when several </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">LoadBalancer</span></strong><span class="koboSpan" id="kobo.416.1"> type services are running on a Kubernetes cluster. </span><span class="koboSpan" id="kobo.416.2">Because, in this way, we may need several external load balancer instances for each externally facing service in the Kubernetes cluster. </span><span class="koboSpan" id="kobo.416.3">It is especially inefficient in a public cloud environment such as GKE, where such load balancer instances are charged separately. </span><span class="koboSpan" id="kobo.416.4">In a more sophisticated way, we can expose such externally facing services outside of a Kubernetes cluster using</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.417.1"> an </span><strong class="bold"><span class="koboSpan" id="kobo.418.1">Ingress Controller</span></strong><span class="koboSpan" id="kobo.419.1"> service running in the Kubernetes cluster. </span><strong class="bold"><span class="koboSpan" id="kobo.420.1">Contour</span></strong><span class="koboSpan" id="kobo.421.1"> (</span><a href="https://projectcontour.io/"><span class="koboSpan" id="kobo.422.1">https://projectcontour.io/</span></a><span class="koboSpan" id="kobo.423.1">) is one such </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.424.1">open source project under CNCF to be an Ingress Controller used for this reason that is supported by VMware and supplied with </span><strong class="bold"><span class="koboSpan" id="kobo.425.1">Tanzu Kubernetes Grid</span></strong><span class="koboSpan" id="kobo.426.1">, which</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.427.1"> we will cover in the </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">next chapter.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.429.1">To keep things simple for learning, we have used GKE to expose Harbor externally for this chapter. </span><span class="koboSpan" id="kobo.429.2">However, AWS Elastic Kubernetes Service and Azure Kubernetes Service can also provision the load balancers, similar to GKE. </span><span class="koboSpan" id="kobo.429.3">If your Kubernetes cluster is running on an infrastructure that cannot automatically expose a </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">LoadBalancer</span></strong><span class="koboSpan" id="kobo.431.1"> service using an external endpoint, you can also do that manually. </span><span class="koboSpan" id="kobo.431.2">For that, you need to create a reverse-proxy server such as Nginx and deploy Harbor as a NodePort service rather than a </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">LoadBalancer</span></strong><span class="koboSpan" id="kobo.433.1"> service using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">--set service.type=NodePort</span></strong><span class="koboSpan" id="kobo.435.1"> option for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">helm install</span></strong><span class="koboSpan" id="kobo.437.1"> command for Harbor deployment, which will be covered later in the </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">installation steps.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">Now, let’s start</span><a id="_idIndexMarker308"/> <span class="No-Break"><span class="koboSpan" id="kobo.440.1">installing Harbor.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.441.1">Installing Harbor</span></h2>
<p><span class="koboSpan" id="kobo.442.1">While </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.443.1">there are various ways to install and configure the Harbor repository, we will use a simple and easy-to-follow Bitnami-provided Helm chart approach to get a Harbor instance up and running in a Kubernetes cluster. </span><span class="koboSpan" id="kobo.443.2">It is required that all the steps in this section are performed using the same workstation. </span><span class="koboSpan" id="kobo.443.3">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">get started:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.445.1">Add Bitnami’s Helm repository to </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">your workstation:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.447.1">
$ helm repo add bitnami https://charts.bitnami.com/bitnami</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.448.1">
"bitnami" has been added to your repositories</span></pre></li>
<li><span class="koboSpan" id="kobo.449.1">Create a namespace on the cluster to deploy all Harbor components </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">within it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.451.1">
$ kubectl create namespace harbor</span></pre></li>
<li><span class="koboSpan" id="kobo.452.1">Install the Helm chart to get Harbor components deployed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">harbor</span></strong><span class="koboSpan" id="kobo.454.1"> namespace. </span><span class="koboSpan" id="kobo.454.2">It should deploy all Harbor components to expose a </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">LoadBalancer</span></strong><span class="koboSpan" id="kobo.456.1"> type Kubernetes service to expose </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">the portal:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.458.1">
$ helm install my-harbor bitnami/harbor -n harbor</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.459.1">Within just a few seconds, you will see the following output if the command was successfully executed. </span><span class="koboSpan" id="kobo.459.2">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">my-harbor</span></strong><span class="koboSpan" id="kobo.461.1"> is just a name given to this Helm deployment </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.462.1">that can be used to upgrade or delete the installation with that </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">name reference:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.464.1">
NAME: my-harbor
LAST DEPLOYED: Mon Mar 28 22:36:23 2022
NAMESPACE: harbor
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
CHART NAME: harbor
CHART VERSION: 12.2.4
APP VERSION: 2.4.2
** Please be patient while the chart is being deployed **
1. </span><span class="koboSpan" id="kobo.464.2">Get the Harbor URL:
    echo "Harbor URL: https://127.0.0.1:8443/"
    kubectl port-forward --namespace harbor svc/my-harbor 8443:443
2. </span><span class="koboSpan" id="kobo.464.3">Login with the following credentials to see your Harbor application
  echo Username: "admin"
  echo Password: $(kubectl get secret --namespace harbor my-harbor-core-envvars -o jsonpath="{.data.HARBOR_ADMIN_PASSWORD}" | base64 --decode)</span></pre>
<p><span class="koboSpan" id="kobo.465.1">The preceding code snippet shows the output of the successful execution of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">helm </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">install</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.468.1"> command.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.469.1">Check the</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.470.1"> status of all the pods deployed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">harbor</span></strong><span class="koboSpan" id="kobo.472.1"> namespace to ensure everything is </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">running fine:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.474.1">
$ kubectl get pods -n harbor</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.475.1">You should see all the pods running and all the containers in a ready state, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.477.1">
NAME                                       READY   STATUS    RESTARTS        AGE
my-harbor-chartmuseum-64bdb5df6f-jsflz     1/1     Running   0               5m38s
my-harbor-core-54fb5d55c9-jjw8p            1/1     Running   1 (3m23s ago)   5m38s
my-harbor-jobservice-66894459d4-rtv4n      1/1     Running   2 (3m28s ago)   5m38s
my-harbor-nginx-54f6b75d9b-9dtxt           1/1     Running   0               5m38s
my-harbor-notary-server-5fc48d989c-b5s96   1/1     Running   0           5m38s
my-harbor-notary-signer-5bffc645b-26r4c    1/1     Running   1 (3m38s ago)   5m38s
my-harbor-portal-697d84949-k7hrv           1/1     Running   0               5m38s
my-harbor-postgresql-0                 1/1     Running   0        5m38s
my-harbor-redis-master-0                1/1     Running   0            5m38s
my-harbor-regtry-6f55746685-rr4ts        2/2     Running   0        5m38s
my-harbor-trivy-0           1/1     Running   0           5m38s</span></pre>
<ol>
<li value="5"><span class="koboSpan" id="kobo.478.1">Retrieve</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.479.1"> the admin user password generated by the installation. </span><span class="koboSpan" id="kobo.479.2">Note down this password as we will use it later to access the </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">Harbor GUI:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.481.1">
$ echo "admin password: $(kubectl get secret --namespace harbor my-harbor-core-envvars -o jsonpath="{.data.HARBOR_ADMIN_PASSWORD}" | base64 --decode)"</span></pre></li>
<li><span class="koboSpan" id="kobo.482.1">Retrieve the external IP address on which Harbor service is exposed by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">following command:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.484.1">
$ echo "Harbor Service IP: $(kubectl get service my-harbor -n harbor -o jsonpath='{.status.loadBalancer.ingress[0].ip}')"</span></pre></li>
<li><span class="koboSpan" id="kobo.485.1">Access the Harbor portal from a browser using </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">https://&lt;external-ip&gt;/</span></strong><span class="koboSpan" id="kobo.487.1">. </span><span class="koboSpan" id="kobo.487.2">You may need to ignore the browser security prompts as we are not using a certificate signed by a valid certificate authority for the portal. </span><span class="koboSpan" id="kobo.487.3">You should see the </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">following screen:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer079">
<span class="koboSpan" id="kobo.489.1"><img alt="Figure 6.3 – Harbor login page" src="image/B18145_06_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.490.1">Figure 6.3 – Harbor login page</span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.491.1">Enter the</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.492.1"> username as </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">admin</span></strong><span class="koboSpan" id="kobo.494.1"> and the password that you retrieved in </span><em class="italic"><span class="koboSpan" id="kobo.495.1">step 5</span></em><span class="koboSpan" id="kobo.496.1"> previously. </span><span class="koboSpan" id="kobo.496.2">You should be able to log in successfully and see the following home page of the </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">Harbor GUI:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer080">
<span class="koboSpan" id="kobo.498.1"><img alt="Figure 6.4 – Harbor landing page" src="image/B18145_06_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.499.1">Figure 6.4 – Harbor landing page</span></p>
<p><span class="koboSpan" id="kobo.500.1">If you can log in using the aforementioned credentials and see the previous screen, you are done with the </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.501.1">required setup to have a Harbor instance on your Kubernetes cluster running. </span><span class="koboSpan" id="kobo.501.2">As the next step, we will perform a small smoke test by pushing an image to this registry to validate </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">our setup.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.503.1">Validating the setup</span></h2>
<p><span class="koboSpan" id="kobo.504.1">Perform </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.505.1">the following steps to validate </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">the installation:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.507.1">Retrieve the CA certificate used by Harbor by following these steps. </span><span class="koboSpan" id="kobo.507.2">We need to add this certificate in the trust store used by the Docker client to connect to the </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">Harbor deployment:</span></span><ol><li><span class="koboSpan" id="kobo.509.1">Go into the </span><strong class="bold"><span class="koboSpan" id="kobo.510.1">library</span></strong><span class="koboSpan" id="kobo.511.1"> project by clicking on the </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">highlighted link:</span></span></li></ol></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer081">
<span class="koboSpan" id="kobo.513.1"><img alt="Figure 6.5 – Clicking the library project" src="image/B18145_06_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.514.1">Figure 6.5 – Clicking the library project</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.515.1">Download the certificate into your workstation using the </span><strong class="bold"><span class="koboSpan" id="kobo.516.1">REGISTRY CERTIFICATE</span></strong><span class="koboSpan" id="kobo.517.1"> link shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">following screenshot:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer082">
<span class="koboSpan" id="kobo.519.1"><img alt="Figure 6.6 – Downloading the registry certificate" src="image/B18145_06_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.520.1">Figure 6.6 – Downloading the registry certificate</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.521.1">Import</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.522.1"> the Harbor portal certificate in the trust store used by the Docker client running in your workstation as explained here, depending on your operating </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">system: </span></span><a href="https://docs.docker.com/registry/insecure/#use-self-signed-certificates"><span class="No-Break"><span class="koboSpan" id="kobo.524.1">https://docs.docker.com/registry/insecure/#use-self-signed-certificates</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.525.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.526.1">For macOS, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.528.1">
$ sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain &lt;downloaded-harbor-certificate&gt;</span></pre>
<p><span class="koboSpan" id="kobo.529.1">Here, replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">&lt;downloaded-harbor-certificate&gt;</span></strong><span class="koboSpan" id="kobo.531.1"> with the certificate path that was downloaded in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.532.1">step 1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.534.1">Restart the Docker daemon in your workstation if it is running; otherwise, start it to make the certificate visible to the </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">Docker client.</span></span></li>
<li><span class="koboSpan" id="kobo.536.1">Create a local DNS entry in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">/etc/hosts</span></strong><span class="koboSpan" id="kobo.538.1"> file to link the default domain name, </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">core.harbor.domain</span></strong><span class="koboSpan" id="kobo.540.1">, with the external load balancer IP address that was used to access the portal in the </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">previous steps.</span></span></li>
<li><span class="koboSpan" id="kobo.542.1">Log in to the Harbor registry using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">docker</span></strong><span class="koboSpan" id="kobo.544.1"> CLI to enable </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">push/pull operations:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.546.1">
$ docker login -u admin https://core.harbor.domain</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.547.1">
Password: &lt;as retrieved from the step #5 of installation&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.548.1">
Login Succeeded</span></pre></li>
<li><span class="koboSpan" id="kobo.549.1">Push an image into your newly setup Harbor registry using the </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">Docker client:</span></span><ol><li><span class="koboSpan" id="kobo.551.1">Download the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">busybox:latest</span></strong><span class="koboSpan" id="kobo.553.1"> image using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">docker</span></strong><span class="koboSpan" id="kobo.555.1"> CLI. </span><span class="koboSpan" id="kobo.555.2">The following command will download the image from the Docker Hub repository into your </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">local workstation:</span></span></li></ol><pre class="source-code"><span class="koboSpan" id="kobo.557.1">
$ docker pull busybox:latest</span></pre><ol><li value="2"><span class="koboSpan" id="kobo.558.1">Verify</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.559.1"> the presence of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">busybox:latest</span></strong><span class="koboSpan" id="kobo.561.1"> image in your local image repository by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">following command:</span></span></li></ol><pre class="source-code"><span class="koboSpan" id="kobo.563.1">
$ docker images | grep busybox</span></pre><ol><li value="3"><span class="koboSpan" id="kobo.564.1">You should see a record indicating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">busybox</span></strong><span class="koboSpan" id="kobo.566.1"> image with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">latest</span></strong><span class="koboSpan" id="kobo.568.1"> tag as a result of the </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">previous command.</span></span></li><li><span class="koboSpan" id="kobo.570.1">Tag the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">busybox:latest</span></strong><span class="koboSpan" id="kobo.572.1"> image to prepare it to push to our Harbor </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">registry instance:</span></span></li></ol><pre class="source-code"><span class="koboSpan" id="kobo.574.1">
$ docker tag busybox:latest core.harbor.domain/library/busybox:latest</span></pre><ol><li value="5"><span class="koboSpan" id="kobo.575.1">Push the newly tagged image to your </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">Harbor instance:</span></span></li></ol><pre class="source-code"><span class="koboSpan" id="kobo.577.1">
$ docker push core.harbor.domain/library/busybox:latest</span></pre></li>
<li><span class="koboSpan" id="kobo.578.1">Upon this successful push operation, you should be able to see the image listed in your </span><strong class="bold"><span class="koboSpan" id="kobo.579.1">library</span></strong><span class="koboSpan" id="kobo.580.1"> project in the portal, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">following screenshot:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer083">
<span class="koboSpan" id="kobo.582.1"><img alt="Figure 6.7 – Verifying the new image presence" src="image/B18145_06_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.583.1">Figure 6.7 – Verifying the new image presence</span></p>
<p><span class="koboSpan" id="kobo.584.1">If you see</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.585.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">busybox</span></strong><span class="koboSpan" id="kobo.587.1"> image in the previous screen, your Harbor installation is complete. </span><span class="koboSpan" id="kobo.587.2">You may also choose to perform a pull test either from the same workstation by removing the existing image from the local repository, or a different workstation that has a Docker client. </span><span class="koboSpan" id="kobo.587.3">If you prefer to use a different workstation, you may need to configure the Harbor certificate there and authenticate against the Harbor repository using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">docker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.589.1"> CLI.</span></span></p>
<p><span class="koboSpan" id="kobo.590.1">In the next section, we will cover some of the crucial day-2 operations for Harbor using </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">this installation.</span></span></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.592.1">Common day-2 operations with Harbor</span></h1>
<p><span class="koboSpan" id="kobo.593.1">Now that </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.594.1">we have a working setup of Harbor, let’s look into some important day-2 operations that we may need to perform on it. </span><span class="koboSpan" id="kobo.594.2">We will cover the</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.595.1"> following activities in </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">this section:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.597.1">Creating and configuring a project in Harbor, which is the multi-tenancy enabling construct on Harbor that allows different teams to have </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">separate configurations</span></span></li>
<li><span class="koboSpan" id="kobo.599.1">Configuring automated image scanning and working with the </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">scan results</span></span></li>
<li><span class="koboSpan" id="kobo.601.1">Preventing insecure images from being used to deploy containers </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">using them</span></span></li>
<li><span class="koboSpan" id="kobo.603.1">Configuring image replication to allow selective access to the </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">external images</span></span></li>
<li><span class="koboSpan" id="kobo.605.1">Performing a cleanup of unused image tags to free up the storage quota of </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">a project</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.607.1">As you can see here, we have lots of ground to cover. </span><span class="koboSpan" id="kobo.607.2">So, let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">get started.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.609.1">Configuring a project in Harbor</span></h2>
<p><span class="koboSpan" id="kobo.610.1">Let’s </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.611.1">create a new project called </span><strong class="bold"><span class="koboSpan" id="kobo.612.1">project-1</span></strong><span class="koboSpan" id="kobo.613.1"> and configure it using the admin user we used previously to verify </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">the installation:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.615.1">Click on the </span><strong class="bold"><span class="koboSpan" id="kobo.616.1">NEW PROJECT</span></strong><span class="koboSpan" id="kobo.617.1"> button on the home screen of the Harbor portal after logging in </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">as </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.619.1">admin</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer084">
<span class="koboSpan" id="kobo.621.1"><img alt="Figure 6.8 – Creating a new project" src="image/B18145_06_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.622.1">Figure 6.8 – Creating a new project</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.623.1">Configure </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.624.1">the project’s name and quota, as shown in the following screenshot, and click </span><strong class="bold"><span class="koboSpan" id="kobo.625.1">OK</span></strong><span class="koboSpan" id="kobo.626.1">. </span><span class="koboSpan" id="kobo.626.2">We will keep this project private, which means that you need to get authenticated to pull images. </span><span class="koboSpan" id="kobo.626.3">We will also not configure this project to be used as a pull-through cache for an external registry such as </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">Docker Hub:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.628.1"><img alt="Figure 6.9 – Entering New Project details" src="image/B18145_06_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.629.1">Figure 6.9 – Entering New Project details</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.630.1">You </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.631.1">should be able to see a new project listed on the screen, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">following screenshot:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer086">
<span class="koboSpan" id="kobo.633.1"><img alt="Figure 6.10 – Verifying the new project’s presence" src="image/B18145_06_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.634.1">Figure 6.10 – Verifying the new project’s presence</span></p>
<p><span class="koboSpan" id="kobo.635.1">Now that we have this project created, the users of this project may push their images with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">core.harbor.domain/project-1/</span></strong><span class="koboSpan" id="kobo.637.1"> prefix for the images. </span><span class="koboSpan" id="kobo.637.2">The project will not </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.638.1">accept new images after it reaches its 2 GB storage quota, which we configured while creating it in </span><em class="italic"><span class="koboSpan" id="kobo.639.1">step 2</span></em><span class="koboSpan" id="kobo.640.1">. </span><span class="koboSpan" id="kobo.640.2">Now, let’s learn about some of the important </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">project-level configurations.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.642.1">Configuring image scanning for a project in Harbor</span></h2>
<p><span class="koboSpan" id="kobo.643.1">Scanning images</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.644.1"> for the presence of CVEs is an important security feature of Harbor. </span><span class="koboSpan" id="kobo.644.2">Now, let’s configure </span><strong class="bold"><span class="koboSpan" id="kobo.645.1">project-1</span></strong><span class="koboSpan" id="kobo.646.1"> to enable automated CVE scanning as soon as an image is pushed in this project using the default </span><a id="_idIndexMarker326"/><span class="No-Break"><span class="koboSpan" id="kobo.647.1">scanner, </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.648.1">Trivy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.650.1">Go to the </span><strong class="bold"><span class="koboSpan" id="kobo.651.1">project-1</span></strong><span class="koboSpan" id="kobo.652.1"> detail page by clicking on the </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">highlighted link:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.654.1"><img alt="Figure 6.11 – Selecting the newly created project" src="image/B18145_06_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.655.1">Figure 6.11 – Selecting the newly created project</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.656.1">Open the </span><strong class="bold"><span class="koboSpan" id="kobo.657.1">Configuration</span></strong><span class="koboSpan" id="kobo.658.1"> tab and select the highlighted option to scan every image upon push. </span><span class="koboSpan" id="kobo.658.2">Finally, </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.660.1">SAVE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer088">
<span class="koboSpan" id="kobo.662.1"><img alt="Figure 6.12 – Enabling image auto-scanning for the project" src="image/B18145_06_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.663.1">Figure 6.12 – Enabling image auto-scanning for the project</span></p>
<p><span class="koboSpan" id="kobo.664.1">Now, let’s verify whether this configuration works by pushing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">busybox:latest</span></strong><span class="koboSpan" id="kobo.666.1"> image that we pulled from Docker Hub previously. </span><span class="koboSpan" id="kobo.666.2">This should be present in your local workstation’s </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">Docker repository.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.668.1">Prepare </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.669.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">busybox:latest</span></strong><span class="koboSpan" id="kobo.671.1"> image to be pushed into the </span><strong class="bold"><span class="koboSpan" id="kobo.672.1">project-1</span></strong><span class="koboSpan" id="kobo.673.1"> repository of Harbor by applying the </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">appropriate tag:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.675.1">
$ docker tag busybox:latest core.harbor.domain/project-1/busybox:latest</span></pre></li>
<li><span class="koboSpan" id="kobo.676.1">Push the newly tagged </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">busybox:latest</span></strong><span class="koboSpan" id="kobo.678.1"> image to the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.679.1">project-1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.680.1"> repository:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.681.1">
$ docker push core.harbor.domain/project-1/busybox:latest</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.682.1">
The push refers to repository [core.harbor.domain/project-1/busybox]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.683.1">
797ac4999b67: Layer already exists</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.684.1">
latest: digest: sha256:14d4f50961544fdb669075c442509f194bdc4c0e344bde06e35dbd55af842a38 size: 527</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.685.1">As you can see in the result of the previous command, Harbor used the same layer of the image that we had pushed under the </span><strong class="bold"><span class="koboSpan" id="kobo.686.1">library</span></strong><span class="koboSpan" id="kobo.687.1"> project during the verification process we </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">performed earlier.</span></span></p>
<p><span class="koboSpan" id="kobo.689.1">erify </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.690.1">the image presence under </span><strong class="bold"><span class="koboSpan" id="kobo.691.1">project-1</span></strong><span class="koboSpan" id="kobo.692.1"> and click on the </span><strong class="bold"><span class="koboSpan" id="kobo.693.1">project/busybox</span></strong><span class="koboSpan" id="kobo.694.1"> link that is highlighted in the following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<span class="koboSpan" id="kobo.695.1"><img alt="Figure 6.13 – Clicking the image repository" src="image/B18145_06_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.696.1">Figure 6.13 – Clicking the image repository</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.697.1">As shown in the following screenshot, the scanning of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">busybox:latest</span></strong><span class="koboSpan" id="kobo.699.1"> image has already been completed with no vulnerabilities found in it. </span><span class="koboSpan" id="kobo.699.2">This scanning was triggered automatically upon pushing the new image into </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">the repository:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer090">
<span class="koboSpan" id="kobo.701.1"><img alt="Figure 6.14 – Verifying the scanning results" src="image/B18145_06_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.702.1">Figure 6.14 – Verifying the scanning results</span></p>
<p><span class="koboSpan" id="kobo.703.1">Now, let’s </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.704.1">create a policy based on such scan results to prevent pulling an image that has CVEs of more than medium severity to prevent running a container with </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">such vulnerabilities.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.706.1">Preventing insecure images from being used in Harbor</span></h2>
<p><span class="koboSpan" id="kobo.707.1">To stop</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.708.1"> insecure images from being pulled, navigate to the project landing page of </span><strong class="bold"><span class="koboSpan" id="kobo.709.1">project-1</span></strong><span class="koboSpan" id="kobo.710.1">. </span><span class="koboSpan" id="kobo.710.2">You may see an option named </span><strong class="bold"><span class="koboSpan" id="kobo.711.1">Prevent vulnerable images from running</span></strong><span class="koboSpan" id="kobo.712.1"> under the </span><strong class="bold"><span class="koboSpan" id="kobo.713.1">Configuration</span></strong><span class="koboSpan" id="kobo.714.1"> tab, as shown in the following screenshot. </span><span class="koboSpan" id="kobo.714.2">Check this option, select </span><strong class="bold"><span class="koboSpan" id="kobo.715.1">High</span></strong><span class="koboSpan" id="kobo.716.1"> from the dropdown menu, and save the </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">configuration changes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<span class="koboSpan" id="kobo.718.1"><img alt="Figure 6.15 – Preventing image pulling with high and critical CVEs" src="image/B18145_06_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.719.1">Figure 6.15 – Preventing image pulling with high and critical CVEs</span></p>
<p><span class="koboSpan" id="kobo.720.1">Now, let’s test </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.721.1">this configuration change. </span><span class="koboSpan" id="kobo.721.2">For that, we need to push an insecure image into </span><strong class="bold"><span class="koboSpan" id="kobo.722.1">project-1</span></strong><span class="koboSpan" id="kobo.723.1">. </span><span class="koboSpan" id="kobo.723.2">You may follow these steps to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">this test:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.725.1">Pull the </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">nginx:1.9.5</span></strong><span class="koboSpan" id="kobo.727.1"> image from Docker Hub, which is very old and full </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">of CVEs:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.729.1">
$ docker pull nginx:1.9.5</span></pre></li>
<li><span class="koboSpan" id="kobo.730.1">Tag </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">nginx:1.9.5</span></strong><span class="koboSpan" id="kobo.732.1"> for the Harbor </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.733.1">project-1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.734.1"> repository:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.735.1">
$ docker tag nginx:1.9.5 core.harbor.domain/project-1/nginx:1.9.5</span></pre></li>
<li><span class="koboSpan" id="kobo.736.1">Push </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">nginx:1.9.5</span></strong><span class="koboSpan" id="kobo.738.1"> to the Harbor </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.739.1">project-1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.740.1"> repository:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.741.1">
$ docker push core.harbor.domain/project-1/nginx:1.9.5</span></pre></li>
<li><span class="koboSpan" id="kobo.742.1">Verify that the image on Harbor under </span><strong class="bold"><span class="koboSpan" id="kobo.743.1">project-1</span></strong><span class="koboSpan" id="kobo.744.1"> has been scanned and showing CVEs, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">following screenshot:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.746.1"><img alt="Figure 6.16 – Verifying the CVE scan results" src="image/B18145_06_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.747.1">Figure 6.16 – Verifying the CVE scan results</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.748.1">Delete</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.749.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">nginx:1.9.5</span></strong><span class="koboSpan" id="kobo.751.1"> image from the local Docker repository so that we can attempt to pull it from our Harbor </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.752.1">project-1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.753.1"> repository:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.754.1">
$ docker image rm core.harbor.domain/project-1/nginx:1.9.5 nginx:1.9.5</span></pre></li>
<li><span class="koboSpan" id="kobo.755.1">Try to pull </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">nginx:1.9.5</span></strong><span class="koboSpan" id="kobo.757.1"> from the Harbor </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.758.1">project-1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.759.1"> repository:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.760.1">
$ docker pull core.harbor.domain/project-1/nginx:1.9.5</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.761.1">
Error response from daemon: unknown: </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">current image with 721 vulnerabilities cannot be pulled due to configured policy</span></strong><span class="koboSpan" id="kobo.763.1"> in 'Prevent images with vulnerability severity of "High" or higher from running.' </span><span class="koboSpan" id="kobo.763.2">To continue with pull, please contact your project administrator to exempt matched vulnerabilities through configuring the CVE allowlist.</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.764.1">As you can see, Harbor denied sending the image because of the CVEs present in the image above the configured </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">tolerance threshold.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.766.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.767.1">We took this testing approach to keep it simple. </span><span class="koboSpan" id="kobo.767.2">But alternatively, you may also attempt to create a pod using this image on a Kubernetes cluster to mimic a practical scenario. </span><span class="koboSpan" id="kobo.767.3">The result would be the same and you may not create a pod using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">core.harbor.domain/project-1/nginx:1.9.5</span></strong><span class="koboSpan" id="kobo.769.1"> image. </span><span class="koboSpan" id="kobo.769.2">However, to test creating a pod using this Harbor setup, you may need to add the DNS entries to all your Kubernetes cluster nodes’ </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">/etc/hosts</span></strong><span class="koboSpan" id="kobo.771.1"> file. </span><span class="koboSpan" id="kobo.771.2">Alternatively, you might need to create a more production-like Harbor setup with a proper domain name that can be resolved using an external DNS record from within the </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.773.1">This </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.774.1">concludes our configuration and its test to prevent insecure container images from being pulled from a Harbor repository. </span><span class="koboSpan" id="kobo.774.2">In the next section, we will learn how to configure a remote repository sync to allow internal developers to pull the required externally available allowed images </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">via Harbor.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.776.1">Replicating images in Harbor</span></h2>
<p><span class="koboSpan" id="kobo.777.1">In this </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.778.1">section, we will learn how to configure image replication in Harbor. </span><span class="koboSpan" id="kobo.778.2">There are two types of replications in Harbor, as described here, along with their </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">practical applications:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.780.1">Push-based</span></strong><span class="koboSpan" id="kobo.781.1">: To</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.782.1"> configure a rule to push certain images from Harbor to another repository, which could be another remote Harbor deployment or even a public repository. </span><span class="koboSpan" id="kobo.782.2">This type of replication is very useful to implement a hub-and-spoke type of deployment where we need to make certain images available in the Kubernetes clusters running at edge locations. </span><span class="koboSpan" id="kobo.782.3">Having the required images on the same Kubernetes clusters available at the edge location could be a great help to reduce network latency and dependency (hence application availability) when the image pulls are required to deploy containers on the edge Kubernetes clusters. </span><span class="koboSpan" id="kobo.782.4">This scenario is depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.783.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.784.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.786.1">Pull-based</span></strong><span class="koboSpan" id="kobo.787.1">: To </span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.788.1">configure a rule to pull certain images from a remote public or private repository. </span><span class="koboSpan" id="kobo.788.2">Such a replication policy allows access to developers of certain allowed container images from an external repository such as Docker Hub or GCR. </span><span class="koboSpan" id="kobo.788.3">This feature of Harbor not only allows freedom for developers to use approved externally hosted images but also allows operators to prevent the wild-wild-west situation where anyone may pull any image from an external repository. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.789.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.790.1">.1</span></em><span class="koboSpan" id="kobo.791.1"> shows how the central Harbor repository pulls required images from Docker Hub and GCR using </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">this feature.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.793.1">Now</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.794.1"> that we understand the types and their uses, let’s see how we can configure these replication rules in Harbor. </span><span class="koboSpan" id="kobo.794.2">Here, we will configure a pull-based policy to allow developers to access MySQL images from Docker Hub. </span><span class="koboSpan" id="kobo.794.3">We will configure a remote repository location and the replication rule in Harbor, followed by quickly verifying that these configurations are working </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">as expected:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.796.1">Add Docker Hub as an external </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">registry endpoint:</span></span><ol><li><span class="koboSpan" id="kobo.798.1">Click on the </span><strong class="bold"><span class="koboSpan" id="kobo.799.1">Registries</span></strong><span class="koboSpan" id="kobo.800.1"> option under the </span><strong class="bold"><span class="koboSpan" id="kobo.801.1">Administration</span></strong><span class="koboSpan" id="kobo.802.1"> menu and click on the </span><strong class="bold"><span class="koboSpan" id="kobo.803.1">NEW ENDPOINT</span></strong><span class="koboSpan" id="kobo.804.1"> button, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">following screenshot:</span></span></li></ol></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.806.1"><img alt="Figure 6.17 – Adding a new external registry endpoint" src="image/B18145_06_17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.807.1">Figure 6.17 – Adding a new external registry endpoint</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.808.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.809.1">Docker Hub</span></strong><span class="koboSpan" id="kobo.810.1"> from the dropdown, enter a name and description, and click on the </span><strong class="bold"><span class="koboSpan" id="kobo.811.1">TEST CONNECTION</span></strong><span class="koboSpan" id="kobo.812.1"> button. </span><span class="koboSpan" id="kobo.812.2">You may leave the authentication details empty for this test. </span><span class="koboSpan" id="kobo.812.3">However, for a production-grade deployment, you should supply these credentials to prevent Docker Hub from </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.813.1">applying an image pull rate limit. </span><span class="koboSpan" id="kobo.813.2">Docker Hub throttles unauthenticated pull requests with lower </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">rate limits:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer094">
<span class="koboSpan" id="kobo.815.1"><img alt="Figure 6.18 – Adding Docker Hub details and testing the connection" src="image/B18145_06_18.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.816.1">Figure 6.18 – Adding Docker Hub details and testing the connection</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.817.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.818.1">OK</span></strong><span class="koboSpan" id="kobo.819.1"> button to save </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">and exit.</span></span></li>
<li><span class="koboSpan" id="kobo.821.1">Verify the newly created entry under the </span><strong class="bold"><span class="koboSpan" id="kobo.822.1">Registries</span></strong><span class="koboSpan" id="kobo.823.1"> page, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">following screenshot:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer095">
<span class="koboSpan" id="kobo.825.1"><img alt="Figure 6.19 – Verifying the presence of the Docker Hub endpoint" src="image/B18145_06_19.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.826.1">Figure 6.19 – Verifying the presence of the Docker Hub endpoint</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.827.1">Create a </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.828.1">replication rule that allows us to pull MySQL images from Docker Hub using the registry endpoint we </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">just created:</span></span><ol><li><span class="koboSpan" id="kobo.830.1">Click on the </span><strong class="bold"><span class="koboSpan" id="kobo.831.1">Replications</span></strong><span class="koboSpan" id="kobo.832.1"> option under the </span><strong class="bold"><span class="koboSpan" id="kobo.833.1">Administration</span></strong><span class="koboSpan" id="kobo.834.1"> menu and click on the </span><strong class="bold"><span class="koboSpan" id="kobo.835.1">NEW REPLICATION RULE</span></strong><span class="koboSpan" id="kobo.836.1"> button, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">following screenshot:</span></span></li></ol></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer096">
<span class="koboSpan" id="kobo.838.1"><img alt="Figure 6.20 – Creating a new replication rule" src="image/B18145_06_20.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.839.1">Figure 6.20 – Creating a new replication rule</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.840.1">Enter the name and the description of the replication rule, select the </span><strong class="bold"><span class="koboSpan" id="kobo.841.1">Pull-based</span></strong><span class="koboSpan" id="kobo.842.1"> replication option, select the Docker Hub registry endpoint from the dropdown</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.843.1"> that we created in </span><em class="italic"><span class="koboSpan" id="kobo.844.1">step 1</span></em><span class="koboSpan" id="kobo.845.1">, provide image filter criteria, as shown in the following screenshot, and click the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.846.1">SAVE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.847.1"> button:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer097">
<span class="koboSpan" id="kobo.848.1"><img alt="Figure 6.21 – Submitting the replication rule’s details" src="image/B18145_06_21.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.849.1">Figure 6.21 – Submitting the replication rule’s details</span></p>
<p><span class="koboSpan" id="kobo.850.1">We will </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.851.1">leave the other options as-is. </span><span class="koboSpan" id="kobo.851.2">These other options include the image destination details to specify if we want a different image folder name and the directory structure, which is different from the source. </span><span class="koboSpan" id="kobo.851.3">It also has the option to select when we want to trigger pulling the images matching the filter criteria. </span><span class="koboSpan" id="kobo.851.4">The default value of the same is to pull manually when required but we can also create a schedule-based pull. </span><span class="koboSpan" id="kobo.851.5">Then, we have the option to restrict the bandwidth requirements to prevent the network from being overwhelmed with a flood of pull requests being executed for large filter criteria. </span><span class="koboSpan" id="kobo.851.6">And finally, there is the</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.852.1"> option to enable/disable the images from being overwritten when there is an image with a different SHA but the same name and tag available on the source </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">registry endpoint.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.854.1">Customized filter patterns</span></p>
<p class="callout"><span class="koboSpan" id="kobo.855.1">In the previous configuration, we used very basic filter criteria to pick all MySQL images that have tags starting with </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">8.</span></strong><span class="koboSpan" id="kobo.857.1"> characters. </span><span class="koboSpan" id="kobo.857.2">However, you may apply complex patterns here to allow/disallow images based on your requirements. </span><span class="koboSpan" id="kobo.857.3">You may learn more about such patterns </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">here: </span></span><a href="https://goharbor.io/docs/2.4.0/administration/configuring-replication/create-replication-rules/"><span class="No-Break"><span class="koboSpan" id="kobo.859.1">https://goharbor.io/docs/2.4.0/administration/configuring-replication/create-replication-rules/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.860.1">.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.861.1">Trigger the replication manually by selecting the newly created rule and clicking on the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.862.1">REPLICATE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.863.1"> button:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer098">
<span class="koboSpan" id="kobo.864.1"><img alt="Figure 6.22 – Triggering image replication" src="image/B18145_06_22.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.865.1">Figure 6.22 – Triggering image replication</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.866.1">Confirm the replication by pressing the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.867.1">REPLICATE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.868.1"> button:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer099">
<span class="koboSpan" id="kobo.869.1"><img alt="Figure 6.23 – Confirming image replication" src="image/B18145_06_23.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.870.1">Figure 6.23 – Confirming image replication</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.871.1">Verify </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.872.1">whether the replication execution was successful from the </span><strong class="bold"><span class="koboSpan" id="kobo.873.1">Executions</span></strong><span class="koboSpan" id="kobo.874.1"> section on the </span><strong class="bold"><span class="koboSpan" id="kobo.875.1">Replications</span></strong><span class="koboSpan" id="kobo.876.1"> page, as shown in the following screenshot. </span><span class="koboSpan" id="kobo.876.2">Depending on the network connection, it may take a few minutes before all the images are </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">successfully replicated:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer100">
<span class="koboSpan" id="kobo.878.1"><img alt="Figure 6.24 – Verifying image replication execution" src="image/B18145_06_24.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.879.1">Figure 6.24 – Verifying image replication execution</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.880.1">Upon successful completion of this replication, go to the </span><strong class="bold"><span class="koboSpan" id="kobo.881.1">Projects</span></strong><span class="koboSpan" id="kobo.882.1"> screen and click on the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.883.1">library</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.884.1"> project:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer101">
<span class="koboSpan" id="kobo.885.1"><img alt="Figure 6.25 – Opening the library project" src="image/B18145_06_25.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.886.1">Figure 6.25 – Opening the library project</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.887.1">You</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.888.1"> will see a new namespace under the </span><strong class="bold"><span class="koboSpan" id="kobo.889.1">Repositories</span></strong><span class="koboSpan" id="kobo.890.1"> tab named </span><strong class="bold"><span class="koboSpan" id="kobo.891.1">library/mysql</span></strong><span class="koboSpan" id="kobo.892.1">. </span><span class="koboSpan" id="kobo.892.2">Click on </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">that link:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer102">
<span class="koboSpan" id="kobo.894.1"><img alt="Figure 6.26 – Verifying the newly replicated repository" src="image/B18145_06_26.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.895.1">Figure 6.26 – Verifying the newly replicated repository</span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.896.1">You </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.897.1">may see several images listed under </span><strong class="bold"><span class="koboSpan" id="kobo.898.1">library/mysql</span></strong><span class="koboSpan" id="kobo.899.1"> as a result of the </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">replication operation:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer103">
<span class="koboSpan" id="kobo.901.1"><img alt="Figure 6.27 – Verifying the newly replicated repository’s content" src="image/B18145_06_27.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.902.1">Figure 6.27 – Verifying the newly replicated repository’s content</span></p>
<ol>
<li value="9"><span class="koboSpan" id="kobo.903.1">Pull one of these images into the local workstation’s Docker repository to verify it is working </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">as expected:</span></span></li>
</ol>
<pre class="source-code"><span class="koboSpan" id="kobo.905.1">
$ docker pull core.harbor.domain/library/mysql:8.0.27</span></pre>
<p><span class="koboSpan" id="kobo.906.1">This command should be able to pull the image successfully from our </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">Harbor repository.</span></span></p>
<p><span class="koboSpan" id="kobo.908.1">This concludes</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.909.1"> our replication configuration step. </span><span class="koboSpan" id="kobo.909.2">Now, the developers may pull a required MySQL image directly from the Harbor repository rather than getting them from </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">Docker Hub.</span></span></p>
<p><span class="koboSpan" id="kobo.911.1">As the next day-2 activity in this list, we will learn how to configure a rule-based tag retention policy to clean up stale images and free up </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">the storage.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.913.1">Configuring rule-based tag retention policies in Harbor</span></h2>
<p><span class="koboSpan" id="kobo.914.1">As you </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.915.1">saw in the previous configuration, we replicated over 25 different images for MySQL. </span><span class="koboSpan" id="kobo.915.2">In production-grade implementations, we often encounter situations where there are several stale images not being used but occupying the project’s allocated space quota. </span><span class="koboSpan" id="kobo.915.3">In our previous MySQL replication, we may see only a few image tags that are used, and we can remove the rest. </span><span class="koboSpan" id="kobo.915.4">For that, we will learn how to configure such automated tag-based retention policies to clean up old and useless content. </span><span class="koboSpan" id="kobo.915.5">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">get started:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.917.1">Go to the </span><strong class="bold"><span class="koboSpan" id="kobo.918.1">Projects</span></strong><span class="koboSpan" id="kobo.919.1"> screen and click on the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.920.1">library</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.921.1"> project:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer104">
<span class="koboSpan" id="kobo.922.1"><img alt="Figure 6.28 – Opening the library project" src="image/B18145_06_28.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.923.1">Figure 6.28 – Opening the library project</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.924.1">Under the </span><strong class="bold"><span class="koboSpan" id="kobo.925.1">library</span></strong><span class="koboSpan" id="kobo.926.1"> project, go to the </span><strong class="bold"><span class="koboSpan" id="kobo.927.1">Policy</span></strong><span class="koboSpan" id="kobo.928.1"> tab and click on the </span><strong class="bold"><span class="koboSpan" id="kobo.929.1">ADD </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.930.1">RULE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.931.1"> button:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer105">
<span class="koboSpan" id="kobo.932.1"><img alt="Figure 6.29 – Adding a new image retention rule" src="image/B18145_06_29.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.933.1">Figure 6.29 – Adding a new image retention rule</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.934.1">Enter </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">mysql</span></strong><span class="koboSpan" id="kobo.936.1"> as the</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.937.1"> matching repository, select </span><strong class="bold"><span class="koboSpan" id="kobo.938.1">retain the most recently pulled # artifact</span></strong><span class="koboSpan" id="kobo.939.1"> from the dropdown, as shown in the following screenshot, enter </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">1</span></strong><span class="koboSpan" id="kobo.941.1"> as the count to retain, and press the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.942.1">ADD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.943.1"> button:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer106">
<span class="koboSpan" id="kobo.944.1"><img alt="Figure 6.30 – Entering details about the image retention rule" src="image/B18145_06_30.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.945.1">Figure 6.30 – Entering details about the image retention rule</span></p>
<p><span class="koboSpan" id="kobo.946.1">This policy will remove all MySQL images except for </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">mysql:8.0.27</span></strong><span class="koboSpan" id="kobo.948.1"> because we pulled that one in the verification </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">step earlier.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.950.1">As you</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.951.1"> can see, the new tag retention policy is in place. </span><span class="koboSpan" id="kobo.951.2">While we can also schedule this activity at a regular frequency, for now, we will run it manually using the </span><strong class="bold"><span class="koboSpan" id="kobo.952.1">RUN </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.953.1">NOW</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.954.1"> button:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer107">
<span class="koboSpan" id="kobo.955.1"><img alt="Figure 6.31 – Verifying the creation of the image retention rule" src="image/B18145_06_31.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.956.1">Figure 6.31 – Verifying the creation of the image retention rule</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.957.1">Move on by pressing the </span><strong class="bold"><span class="koboSpan" id="kobo.958.1">RUN</span></strong><span class="koboSpan" id="kobo.959.1"> button by accepting the warning of a mass </span><span class="No-Break"><span class="koboSpan" id="kobo.960.1">deletion operation:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer108">
<span class="koboSpan" id="kobo.961.1"><img alt="Figure 6.32 – Executing the image retention rule" src="image/B18145_06_32.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.962.1">Figure 6.32 – Executing the image retention rule</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.963.1">Verify</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.964.1"> whether the clean-up activity was completed successfully by inspecting the activity log record, which indicates there was only 1 tag retained out of 24 total. </span><span class="koboSpan" id="kobo.964.2">This was the </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">expected outcome:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer109">
<span class="koboSpan" id="kobo.966.1"><img alt="Figure 6.33 – Verifying the image retention rule’s execution" src="image/B18145_06_33.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.967.1">Figure 6.33 – Verifying the image retention rule’s execution</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.968.1">Click on the </span><strong class="bold"><span class="koboSpan" id="kobo.969.1">Repositories</span></strong><span class="koboSpan" id="kobo.970.1"> tab to list the existing repositories. </span><span class="koboSpan" id="kobo.970.2">On that screen, you should be able to see only 1 tag available for </span><strong class="bold"><span class="koboSpan" id="kobo.971.1">mysql</span></strong><span class="koboSpan" id="kobo.972.1"> instead of the 24 </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">from earlier:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer110">
<span class="koboSpan" id="kobo.974.1"><img alt="Figure 6.34 – Verifying the remaining image count post-retention rule’s execution" src="image/B18145_06_34.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.975.1">Figure 6.34 – Verifying the remaining image count post-retention rule’s execution</span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.976.1">Navigate </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.977.1">to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">mysql</span></strong><span class="koboSpan" id="kobo.979.1"> repository to verify that the tags other than </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">8.0.27</span></strong><span class="koboSpan" id="kobo.981.1"> have </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">been deleted:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer111">
<span class="koboSpan" id="kobo.983.1"><img alt="Figure 6.35 – Verifying the remaining image’s post-retention rule’s execution" src="image/B18145_06_35.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.984.1">Figure 6.35 – Verifying the remaining image’s post-retention rule’s execution</span></p>
<p><span class="koboSpan" id="kobo.985.1">This </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.986.1">concludes our tag retention policy configuration. </span><span class="koboSpan" id="kobo.986.2">Like tag retention, we may also configure tag immutability policies to configure certain critical image tags from being overwritten with a new version of the image. </span><span class="koboSpan" id="kobo.986.3">Without such a policy in place, you may push new images with changes but with the same tag value. </span><span class="koboSpan" id="kobo.986.4">Hence, an application that is tested against one tagged version of an image may not be able to fully ensure that the content of the same tag would be the same in the next pull of the image. </span><span class="koboSpan" id="kobo.986.5">This could potentially break applications from working in case of any unexpected changes in the newer version of the same tagged images are pushed. </span><span class="koboSpan" id="kobo.986.6">Ideally, this should not be the case as it is a poor development practice. </span><span class="koboSpan" id="kobo.986.7">But there should be some controls in place to prevent it from happening. </span><span class="koboSpan" id="kobo.986.8">Hence, Harbor helps in this case by allowing you to create policies where the Harbor users may not push images with the same tag with different content determined by the </span><span class="No-Break"><span class="koboSpan" id="kobo.987.1">SHA-256 algorithm.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.988.1">Important information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.989.1">To safeguard our containerized applications from failing because of changed image content for the same tag value, it is always a good practice to pull images using their SHA values rather than their tags. </span><span class="koboSpan" id="kobo.989.2">Pulling an image using its SHA value (also known as the digest) ensures you always get the same image with the same content and there is no fear of it getting accidentally overwritten with the same tag value. </span><span class="koboSpan" id="kobo.989.3">For example, the image content pulled with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">docker pull ubuntu:20.04</span></strong><span class="koboSpan" id="kobo.991.1"> command can be theoretically different for multiple executions, but the image content will always be the same when it is pulled with its digest using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">docker pull </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">ubuntu@sha256:82becede498899ec668628e7cb0ad87b6e1c371cb8a1e597d83a47fac21d6af3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.994.1"> command.</span></span></p>
<p><span class="koboSpan" id="kobo.995.1">There </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.996.1">are several more administrative and user day-2 activities we may need to perform on Harbor, including user account management, robot accounts for automation, image signing, webhook-based automation triggers, and many more. </span><span class="koboSpan" id="kobo.996.2">In this chapter, we covered some of the most common activities that we usually perform on a container registry such as Harbor. </span><span class="koboSpan" id="kobo.996.3">While we can add more details for other operations, the goal of this book is not to be a </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.997.1">Harbor guide alone. </span><span class="koboSpan" id="kobo.997.2">But if you want, you may find more details in the official documentation for Harbor </span><span class="No-Break"><span class="koboSpan" id="kobo.998.1">at </span></span><a href="https://goharbor.io/docs/2.4.0/"><span class="No-Break"><span class="koboSpan" id="kobo.999.1">https://goharbor.io/docs/2.4.0/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1000.1">.</span></span></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.1001.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1002.1">Let’s review what we have covered in this chapter. </span><span class="koboSpan" id="kobo.1002.2">First, we discussed several benefits and the use cases of Harbor while explaining the </span><em class="italic"><span class="koboSpan" id="kobo.1003.1">Why</span></em><span class="koboSpan" id="kobo.1004.1"> behind using it. </span><span class="koboSpan" id="kobo.1004.2">We looked at the different security-related benefits of Harbor, including image scanning, robust RBAC capabilities, and the ability to restrict public repository access requirements using image replications. </span><span class="koboSpan" id="kobo.1004.3">For the operational control aspect, we discussed the benefits, such as on-premises and air-gapped deployment, a popular open source project under CNCF, comprehensive multi-tenancy, and administrative configurations. </span><span class="koboSpan" id="kobo.1004.4">For the extensibility aspect, we saw how Harbor can be used with its replication feature of extending image library contents. </span><span class="koboSpan" id="kobo.1004.5">Harbor’s pluggable model for vulnerability scanners and authentication providers was also discussed in </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">this category.</span></span></p>
<p><span class="koboSpan" id="kobo.1006.1">After that, we covered details of Harbor’s architecture and learned about the different components that make up Harbor in detail. </span><span class="koboSpan" id="kobo.1006.2">Following this, we learned how to quickly get started with Harbor using the Bitnami Helm chart and verified the installation. </span><span class="koboSpan" id="kobo.1006.3">Finally, we walked through some of the important day-2 operations around Harbor, including creating a project, performing image scanning, preventing risky images from being pulled, image replication from Docker Hub, and cleaning stale images to free up the storage quota for </span><span class="No-Break"><span class="koboSpan" id="kobo.1007.1">a project.</span></span></p>
<p><span class="koboSpan" id="kobo.1008.1">In the next chapter, we will learn how to run these images using Tanzu Kubernetes Grid, a multi-cloud Kubernetes offering </span><span class="No-Break"><span class="koboSpan" id="kobo.1009.1">from VMware.</span></span></p>
</div>
</body></html>