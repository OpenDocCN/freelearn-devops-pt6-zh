- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking at Logs with Grafana Loki
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will get hands-on experience with **Grafana Loki**. We will
    learn how to use **LogQL**, which is the language used for querying Loki, how
    to select and filter log streams, and how to use the operators and aggregations
    available. This will give you the tools to extract the data in appropriate ways
    for your dashboard visualizations and alerts. We will review the benefits and
    drawbacks of the log format and how it impacts your use of Loki. To fully explore
    the benefits of Loki, we will explore the architecture and where it can be scaled
    for performance. To finish, we will look at advanced areas of LogQL, such as labels
    and transformations, and other tips and tricks to expand your use of Loki.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Loki
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding LogQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Loki’s architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips, tricks, and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will work with LogQL using the Grafana Cloud instance and
    demo you set up in [*Chapter 3*](B18277_03.xhtml#_idTextAnchor063). The full LogQL
    language documentation can be found on the Grafana website at [https://grafana.com/docs/loki/latest/logql/](https://grafana.com/docs/loki/latest/logql/).
    Loki is in active development, so it’s worth checking for new features frequently.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find the code for this chapter in the GitHub repository at [https://github.com/PacktPublishing/Observability-with-Grafana/tree/main/chapter4](https://github.com/PacktPublishing/Observability-with-Grafana/tree/main/chapter4).
    You'll find the *Code in Action* videos for this chapter at [https://packt.link/aB4mP](https://packt.link/aB4mP).
  prefs: []
  type: TYPE_NORMAL
- en: Updating the OpenTelemetry demo application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let’s improve the logging for our demo application. For this chapter,
    we have provided an updated `OTEL-Collector.yaml` file with additional Loki log
    labels in the `chapter4` folder in the GitHub repository. These instructions assume
    you have already completed the demo project setup in [*Chapter 3*](B18277_03.xhtml#_idTextAnchor063).
    Full details on this process are available in the GitHub repository in the [*Chapter
    4*](B18277_04.xhtml#_idTextAnchor092) section of the `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To upgrade the OpenTelemetry Collector, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upgrade the collector with Helm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can validate that the upgrade was successful with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will now have a lot more labels available for your Loki log data. Let’s
    explore what that means in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Loki
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Grafana Loki** was designed from the ground up to be a highly scalable multi-tenant
    logging solution. Its design was heavily influenced by Prometheus with a few main
    objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: It was built with developers and operators in mind (such as *Diego* and *Ophelia*,
    who were introduced in [*Chapter 1*](B18277_01.xhtml#_idTextAnchor018))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has simple ingestion; no pre-parsing is required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It only indexes metadata about logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It stores everything in an object store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at how Loki ingests data and uses labels as this will provide valuable
    insight into the way your queries source and then process the data for presentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Log ingest**: Loki accepts logs from all sources with a wide choice of agents
    available to make that easy. You can even send log data directly to the Loki API.
    This makes it the perfect choice for complex environments featuring a multitude
    of systems and hardware components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Loki stores its logs as log streams, where each entry has the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Timestamp**: It has nanosecond precision for accuracy.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Labels**: These are key-value pairs used for the identification and retrieval
    of your data; they form the Loki index.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content**: This refers to the raw log line. It is not indexed and is stored
    in compressed chunks.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows a log stream with a log line and its associated
    metadata:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Loki log structure](img/B18277_Figure_4.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Loki log structure
  prefs: []
  type: TYPE_NORMAL
- en: '**Log labels**: Loki log labels provide the metadata for the log line and not
    only help identify the data but also are used to create the index for the log
    streams and structure the log storage. They have the following features:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each unique set of labels and values creates a log stream
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Logs in a stream are batched, compressed, and stored as chunks
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Labels are the index to Loki’s log streams
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Labels are used to search for logs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates two log streams. As you can see, in a stream
    of logs, each log has the same unique set of labels. In this instance, `k8s_node_name`
    has two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Loki log streams](img/B18277_Figure_4.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Loki log streams
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at the structure of a Loki log, let’s introduce **LogQL**,
    the query language used to extract value from your logs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding LogQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Grafana developed LogQL as the query language for Loki using the **Prometheus
    Query Language** (**PromQL**) for inspiration. It was designed with developers
    (*Diego*) and operators (*Ophelia*) in mind (you can refer to [*Chapter 1*](B18277_01.xhtml#_idTextAnchor018)
    for an introduction to these personas), providing familiar filtering and aggregation
    mechanisms. Loki does not index the log content. Log events are grouped into log
    streams and indexed with labels (the log metadata). Executing a LogQL query in
    Loki invokes a type of distributed filtering against log streams to aggregate
    the log data.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the **Grafana explorer UI** for LogQL, where you will be executing
    most of your LogQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: LogQL query builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We took a brief look at the Grafana explorer UI in *Figure 3**.16* in [*Chapter
    3*](B18277_03.xhtml#_idTextAnchor063). For our examples, we will mostly work with
    raw LogQL in the **Code** editor. The following screenshot shows LogQL typed directly
    into the query builder code editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – LogQL query builder Code editor](img/B18277_Figure_4.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – LogQL query builder Code editor
  prefs: []
  type: TYPE_NORMAL
- en: If you ever get stuck with your LogQL, you can lean on the **Log query starters**
    and **Explain query** tools to help you get started with your queries and understand
    what each step of your pipeline is doing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Log query starters** provides some quick examples to work with your data
    and get you filtering and formatting it with ease:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Log query starters](img/B18277_Figure_4.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Log query starters
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, **Metric query starters** provides some quick examples to work with
    your data and generate metrics ready for use in dashboards and alerts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Metric query starters](img/B18277_Figure_4.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Metric query starters
  prefs: []
  type: TYPE_NORMAL
- en: 'Available in the LogQL query builder and the dashboard panel editor, **Explain
    query**, when toggled on, provides a breakdown of each stage of your LogQL pipeline.
    This tool is invaluable when analyzing an existing query or debugging your own
    during design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Explain query](img/B18277_Figure_4.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Explain query
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now explore the features of LogQL available for selecting, filtering,
    and parsing your log data.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of LogQL features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A basic LogQL query consists of one or more log stream selectors to retrieve
    the raw log chunks for processing and an optional log pipeline to filter and parse
    the log data. The following figure shows a basic LogQL query with the `component="cartservice"`
    selector and a pipeline filter, `` |= `GetCartAsync` ``, which would return two
    lines from the log stream example in *Figure 4**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – A basic LogQL query](img/B18277_Figure_4.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – A basic LogQL query
  prefs: []
  type: TYPE_NORMAL
- en: 'The following reference table shows the different features available to you
    when building your LogQL query, which will help while you get familiar with querying
    your logs with Loki:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **LogQL Sections** | **Syntax** | **Operators** | **Scope** |'
  prefs: []
  type: TYPE_TB
- en: '| **Stream selector** | `{``label="value", foo!="bar"}` | `=`,`!=`,`=~`,`!~`
    | Select log streams to retrieve; there must always be at least one selector |'
  prefs: []
  type: TYPE_TB
- en: '| **Line filter** | `` &#124;= ` [PRE2] emailservice` `` |'
  prefs: []
  type: TYPE_TB
- en: '| `!=` | Log line does not contain a string | `` != ` [PRE3] email\w+` `` |'
  prefs: []
  type: TYPE_TB
- en: '| `!~` | Log line does not contain a match to the regex | `` !~ ` [PRE4] 2023-04-25T12:15:03.00Z+01:00"
    }}` ``'
  prefs: []
  type: TYPE_NORMAL
- en: 'Template functions can be broken down into the following distinct areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Regex patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Math functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date and time functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, there are other functions that do not necessarily fit into a grouping
    but are nevertheless very useful. These include encode and decode functions, byte
    and duration conversions, counts, and default values.
  prefs: []
  type: TYPE_NORMAL
- en: Line and label format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two features are available for transforming logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`| line_format "{{ .label }}"`, is used to rewrite log line content. This expression
    is used to modify your log line using the template functions referenced earlier.
    LogQL injects all labels as variables into the template, making them available
    for use, for example, `| line_format "{{.label_one}} {{.label_two}}"`. The format
    takes double quotes or backticks, where backticks allow you to avoid escaping
    characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if we have the following labels, `method=sent`, `status=200`,
    and `duration=15ms`, the following LogQL query would return `sent` `200 15ms`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Only one instance of a label name can be used per expression; for example,
    `| label_format foo=bar,foo="new"` would fail. The desired result could be implemented
    with two expressions, one following the other, like this: `| label_format foo=bar
    |` `label_format foo="new"`.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve looked at how the label format gives you options to create, modify, and
    rename labels. Additionally, we have the `drop labels` command to remove labels
    completely. Let’s explore that expression now.
  prefs: []
  type: TYPE_NORMAL
- en: Dropping labels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `drop labels` expression is used to remove labels from the pipeline. For
    example, if we have the `user=diego`, `status=200`, and `duration=1000(ms)` labels,
    the `|drop user` pipeline would drop the `user` label, leaving only `status` and
    `duration`.
  prefs: []
  type: TYPE_NORMAL
- en: We will now take a look at more of the LogQL features, exploring formatters,
    metric queries, and the UI for executing LogQL the **Grafana Explorer** where
    queries for all data sources are built.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring LogQL metric queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most powerful features of Loki and LogQL is the ability to create
    metrics from logs. With **metric queries**, you can, for example, calculate the
    rate of errors or the top 10 log sources with the highest volume of logs over
    the last hour. This makes it perfect for creating visualizations or triggering
    alerts.
  prefs: []
  type: TYPE_NORMAL
- en: If we combine metric queries with the parsers and formatters we looked at earlier
    in this section, they can be used to calculate metrics from sample data within
    a log line. For example, latency or request size can be extracted from log data
    and used as a metric. These will then be available for aggregations and the generation
    of new series.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now take a look at the aggregations available, namely, **range vector
    aggregations** and **built-in** **aggregation operators**.
  prefs: []
  type: TYPE_NORMAL
- en: Range vector aggregations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Prometheus concept of a **range vector** is shared by LogQL, where the
    range of samples is a range of log or label values. We will discuss the range
    vector concept in greater detail in [*Chapter 5*](B18277_05.xhtml#_idTextAnchor106).
    The selected aggregation is applied to a time interval specified as a number followed
    by a unit. The following time interval units can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ms`: Milliseconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`: Seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`: Minutes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`h`: Hours'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`: Days'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`: Weeks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y`: Years'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples are `6h`, `1h30m`, `10m`, and `20s`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of range vector aggregations supported by Loki and LogQL:
    **log range aggregations** and **unwrapped range aggregations**. Let’s explore
    these in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Log range aggregation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `[10ms]`, with a function applied to it to aggregate the query over the duration.
    The duration can be placed after the log stream selector or at the end of the
    log pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the aggregation functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Aggregation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `rate(range)` | Will calculate the number of entries per second. |'
  prefs: []
  type: TYPE_TB
- en: '| `count_over_time(range)` | Will count the entries for each log stream within
    the given range. |'
  prefs: []
  type: TYPE_TB
- en: '| `bytes_rate(range)` | Useful to detect changes in log data volume. It will
    calculate the number of bytes per second for each log stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `bytes_over_time(range)` | Useful to calculate the volume of log data. It
    will count the amount of bytes used by each log stream for the given range. |'
  prefs: []
  type: TYPE_TB
- en: '| `absent_over_time(range)` | Useful for alerting when there are no time series
    and logs streams for label combinations for a duration of time. It returns an
    empty vector if the range passed to it has elements and a single element vector
    with the value `1` if the range passed to it has no elements. |'
  prefs: []
  type: TYPE_TB
- en: Table 4.6 – Log range aggregation functions
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few log range aggregation examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To count all the log lines within the last 10 minutes for the `currencyservice`
    component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To sum the rate per second of errors by component within the last minute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unwrapped range aggregations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`unwrap` function to extract a value to be used in the aggregation. They support
    grouping using the `by` or `without` clause to aggregate over distinct labels.
    The `without` aggregation removes the labels identified from the result vector
    while preserving all other labels. The `by` aggregation drops labels that are
    not identified in the `by` clause.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the aggregation functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Aggregation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `rate(unwrapped-range)` | Will calculate the per-second rate of the sum of
    all of the values within the interval. |'
  prefs: []
  type: TYPE_TB
- en: '| `rate_counter( unwrapped-range)` | Will calculate the per-second rate of
    all the values within the interval, treating them as counter metrics. |'
  prefs: []
  type: TYPE_TB
- en: '| `sum_over_time( unwrapped-range)` | Will sum of all the values within the
    interval. |'
  prefs: []
  type: TYPE_TB
- en: '| `avg_over_time( unwrapped-range)` | Will return the average of all the points
    within the interval. |'
  prefs: []
  type: TYPE_TB
- en: '| `max_over_time(range)` | Will return the maximum of all the points within
    the interval. |'
  prefs: []
  type: TYPE_TB
- en: '| `min_over_time( unwrapped-range)` | Will return the minimum of all the points
    within the interval. |'
  prefs: []
  type: TYPE_TB
- en: '| `first_over_time( unwrapped-range):` | Will return the first value of all
    the points within the interval. |'
  prefs: []
  type: TYPE_TB
- en: '| `last_over_time( unwrapped-range)` | Will return the last value of all the
    points within the interval. |'
  prefs: []
  type: TYPE_TB
- en: '| `stdvar_over_time( unwrapped-range)` | Will return the population standard
    variance of the values within the interval. |'
  prefs: []
  type: TYPE_TB
- en: '| `stddev_over_time( unwrapped-range)` | Will return the population standard
    deviation of the values within the interval. |'
  prefs: []
  type: TYPE_TB
- en: '| `quantile_over_time(scalar, unwrapped-range)` | Will return the specified
    quantile of the values within the interval. |'
  prefs: []
  type: TYPE_TB
- en: '| `absent_over_time( unwrapped-range)` | Useful for alerting when there are
    no time series and logs streams for label combinations for a duration of time.
    It returns an empty vector if the range passed to it has elements and a single
    element vector with the value `1` if the range passed to it has no elements. |'
  prefs: []
  type: TYPE_TB
- en: Table 4.7 – Unwrapped range aggregation functions
  prefs: []
  type: TYPE_NORMAL
- en: The `sum_over_time`, `absent_over_time`, `rate`, and `rate_counter` functions
    are excluded from grouping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few unwrapped range aggregation examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the 99th percentile of the `webserver` container `request_time`
    excluding any JSON formatting errors by `path` within the last minute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To calculate the number of bytes processed by `org_id` within the last minute,
    filtering where the log contains the `metrics` string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Built-in aggregation operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LogQL supports a subset of the **built-in aggregation operators** that PromQL
    supports. These can be used to aggregate the element of a single vector, resulting
    in a new vector of fewer elements but with aggregated values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows some built-in range aggregation operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Aggregation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `sum` | Will calculate the sum by the labels specified |'
  prefs: []
  type: TYPE_TB
- en: '| `avg` | Will calculate the average by the labels specified |'
  prefs: []
  type: TYPE_TB
- en: '| `min` | Will select the minimum by the labels specified |'
  prefs: []
  type: TYPE_TB
- en: '| `max` | Will select the maximum by the labels specified |'
  prefs: []
  type: TYPE_TB
- en: '| `stddev` | Will calculate the population standard deviation by the labels
    specified |'
  prefs: []
  type: TYPE_TB
- en: '| `stdvar` | Will calculate the population standard variance by the labels
    specified |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | Will count the number of elements in a vector |'
  prefs: []
  type: TYPE_TB
- en: '| `topk` | Will select the largest `k` elements by sample value |'
  prefs: []
  type: TYPE_TB
- en: '| `bottomk` | Will select the smallest `k` elements by sample value |'
  prefs: []
  type: TYPE_TB
- en: '| `sort` | Will return the vector elements sorted by their sample values, in
    ascending order |'
  prefs: []
  type: TYPE_TB
- en: '| `sort_desc` | Will return the vector elements sorted by their sample values,
    in descending order |'
  prefs: []
  type: TYPE_TB
- en: Table 4.8 – Built-in range aggregation functions
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few built-in range aggregation operator examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To return the top 10 applications by the highest log throughput for the last
    10 minutes by `name`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To return the average rate of `GET` requests to the `/hello` endpoint for web
    server logs by region for the last 10 seconds:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have looked at how LogQL can parse different log formats. Let’s now take
    a look at the Loki architecture and how Loki stores and queries the log data you
    send.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Loki’s architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Grafana Loki has a full **microservices architecture** that can be run as a
    single binary and a simple scalable deployment to a full microservices deployment
    running all the components as distinct processes. At a high level, it is made
    up of features that implement write, read, and store functionality, as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – High-level overview of Loki architecture](img/B18277_Figure_4.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – High-level overview of Loki architecture
  prefs: []
  type: TYPE_NORMAL
- en: Both *write* and *read* functionality can be scaled independently to suit your
    particular needs and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood, Loki has the following core components:'
  prefs: []
  type: TYPE_NORMAL
- en: Distributor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ingester
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Backend services:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruler
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Compactor
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Query scheduler
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s now look at the functionality and core components in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Writes**: Writes for the incoming log data hit the distributor, which is
    responsible for data sharding and partitioning, and sending them to the ingesters.
    The distributor validates each set of streams, checking labels, timestamps, and
    log line sizes, then batches log stream chunks to multiple ingesters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ingester writes to the **write-ahead logs** (**WALs**) for resiliency and
    finally into the object storage backend.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Both the querier and ruler read the ingester to access the most recent data.
    The querier can additionally access the object storage data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Reads**: The query frontend is responsible for accelerating query execution,
    distributing large queries across multiple queriers and ensuring retries in the
    event of failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Queriers parse the LogQL and query the underlying systems: the ingester for
    the most recent data and object storage for older data. The querier de-duplicates
    data with the same nanosecond timestamp, labels, and log content.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Storage**: The object storage is where the batched logs are stored. The compactor
    is responsible for maintaining the data. It monitors the object storage, de-duplicating
    data and removing old logs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backend services**: The ruler evaluates queries and performs actions based
    on the result. The actions can be recording rules (generating new metrics for
    LogQL queries) or alerts for system events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The alert manager is responsible for notifications and alerts triggering and
    being sent from the system, but this is not included with Loki.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Loki index**: In this chapter, so far, we have covered Loki log labels and
    LogQL log stream selectors. The underlying architecture completes the picture,
    explaining how the distributor shards the data. It is that sharding and subsequent
    storage using the label-based Loki index that makes Loki fast and inexpensive.
    It also validates the importance of a good labeling strategy to improving storage
    and retrieval, and essentially querying performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have built up a good understanding of Loki, let’s look at a few
    best practices and some tips for working with Loki log data.
  prefs: []
  type: TYPE_NORMAL
- en: Tips, tricks, and best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at a few best practices for filtering and cardinality.
    We will then look at the LogQL Analyzer and LogCLI, which are tools that can help
    you when you are working with Grafana Loki log data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some best practices to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filter first**: Loki stores the raw log in object storage as compressed chunks.
    Because of this, it is important, from a speed point of view, to filter early.
    Processing complex parsing on smaller datasets will increase the response time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`namespace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cluster`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`job`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`instance`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filename`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some examples of poor labels (often vague with unlimited values) are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`userid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`traceid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status code`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s take a closer look at the advantages offered by using the LogQL
    Analyzer and LogCLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LogQL Analyzer**: The LogQL Analyzer provides an interface on the Grafana
    website for you to practice your LogQL queries. You can view detailed explanations
    of the actions implemented by your query on a sample log entry. Head over to [https://grafana.com/docs/loki/latest/query/analyzer/](https://grafana.com/docs/loki/latest/query/analyzer/)
    to try it out. Let’s take a look at the Loki LogQL Analyzer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Loki LogQL Analyzer](img/B18277_Figure_4.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Loki LogQL Analyzer
  prefs: []
  type: TYPE_NORMAL
- en: The explanations provided by the LogQL Analyzer are far more detailed than the
    **Explain query** feature in the query builder, so it’s worth checking out while
    you are learning LogQL.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using LogCLI**: For command-line lovers everywhere, Grafana Loki comes with
    a command-line interface called LogCLI that allows you to do the following at
    your terminal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query your logs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate metric queries for a single point in time
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify Loki labels and obtain stats about their values
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Return log streams for a time window with a label matcher
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is great if you need access to the power of LogQL without leaving the comfort
    of your own console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Full setup documentation and command references can be found here: [https://grafana.com/docs/loki/latest/query/](https://grafana.com/docs/loki/latest/query/).
    You can download the binary from the Loki releases page on GitHub.'
  prefs: []
  type: TYPE_NORMAL
- en: We will now wrap up this chapter with a reminder of what you have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have taken a look at Loki, exploring the log ingest format
    and the importance of log labels. We then started looking at the comprehensive
    features of LogQL, the query language of Loki, and how we can select log streams
    and then filter, parse, format, and transform log lines. These techniques will
    be invaluable when working with Loki to build dashboards in [*Chapter 8*](B18277_08.xhtml#_idTextAnchor172).
    Then, we looked at the Loki architecture to get an understanding of what’s going
    on behind the scenes. We also explained how our data is stored and how Loki can
    be scaled to increase performance. Lastly, we reviewed some tips and best practices
    that can help you improve your experience with Loki.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll move on from logs to explore **metrics** and **Prometheus**,
    where Loki took its original inspiration from.
  prefs: []
  type: TYPE_NORMAL
