<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer043">
<h1 class="chapterNumber">1</h1>
<h1 class="chapterTitle" id="_idParaDest-17">Docker and Container Essentials</h1>
<p class="normal"><strong class="keyWord">Containers</strong> have become an incredibly popular<a id="_idIndexMarker000"/> and influential technology that brings significant changes from legacy applications. Everyone, from tech companies to big corporations and end users, not has widely embraced containers to handle their day-to-day tasks. It’s worth noting that the conventional method of installing ready-made commercial applications is gradually transforming into fully containerized setups. Considering the sheer magnitude of this technological shift, it becomes essential for people working in the field of information technology to gain knowledge and understand the concept of containers.</p>
<p class="normal">This chapter will provide an overview of the issues that containers aim to solve. We will begin by highlighting the significance of containers. Then, we will introduce <strong class="keyWord">Docker</strong>, the runtime that played a pivotal role in the rise of containerization, and discuss its relationship with <strong class="keyWord">Kubernetes</strong>.</p>
<p class="normal">This chapter intends to provide you with an understanding of running containers in Docker. One common question you may have heard is: “What is the relationship of Docker to Kubernetes?” Well, in today’s world, Docker is not tied to Kubernetes at all – you do not need Docker to run Kubernetes and you don’t need it to create containers. We are discussing Docker in this chapter to provide you with the skills to run containers locally and test your images before you deploy them to a Kubernetes cluster.</p>
<p class="normal">By the end of this chapter, you will have a clear understanding of how to install Docker and how to effectively utilize the commonly used <strong class="keyWord">Docker command-line interface</strong> (<strong class="screenText">CLI</strong>) commands.</p>
<p class="normal">In this chapter, we will cover the following main topics:</p>
<ul>
<li class="bulletList">Understanding the need for containerization</li>
<li class="bulletList">Understanding why Kubernetes removed Docker</li>
<li class="bulletList">Understanding Docker</li>
<li class="bulletList">Installing Docker</li>
<li class="bulletList">Using the Docker CLI</li>
</ul>
<h1 class="heading-1" id="_idParaDest-18">Technical requirements</h1>
<p class="normal">This chapter has the following technical requirements:</p>
<ul>
<li class="bulletList">An Ubuntu 22.04+ server running Docker with a minimum of 4 GB of RAM, though 8 GB is suggested.</li>
<li class="bulletList">Scripts from the <code class="inlineCode">chapter1</code> folder from the repository, which you can access by using this link: <a href="https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition"><span class="url">https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition</span></a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-19">Understanding the need for containerization</h1>
<p class="normal">You may have experienced<a id="_idIndexMarker001"/> a conversation like this at your office or school:</p>
<p class="normal"><strong class="keyWord">Developer</strong>: “<em class="italic">Here’s the new application. It went through weeks of testing and you are the first to get the new release.</em>”</p>
<p class="normal">….. A little while later …..</p>
<p class="normal"><strong class="keyWord">User</strong>: “<em class="italic">It’s not working. When I click the submit button, it shows an error about a missing dependency</em>.”</p>
<p class="normal"><strong class="keyWord">Developer</strong>: “<em class="italic">That’s weird; it’s working fine on my machine.</em>”</p>
<p class="normal">Encountering such issues can be incredibly frustrating for developers when they’re deploying an application. Oftentimes, these problems occur due to a missing library in the final package that the developer had on their own machine. One might think that a simple solution would be to include all the libraries in the release, but what if this release includes a newer version of a library that replaces an older version, which another application may still rely on?</p>
<p class="normal">Developers have to carefully consider their new releases and the potential conflicts they may cause with existing software on users’ workstations. It becomes a delicate balancing act that often requires larger deployment teams to thoroughly test the application on various system configurations. This situation can result in additional work for the developer or, in extreme cases, render the application completely incompatible with an existing one.</p>
<p class="normal">Over the years, there have been several attempts to simplify application delivery. One solution is VMware’s <strong class="keyWord">ThinApp</strong>, which aims to virtualize<a id="_idIndexMarker002"/> an application (not to be confused with virtualizing the entire operating system (OS)). It allows you to bundle the application and its dependencies into a single executable package. By doing so, all the application’s dependencies are contained within the package, eliminating conflicts with other application dependencies. This not only ensures application isolation but also enhances security and reduces the complexities of OS migrations.</p>
<p class="normal">You might not have come across terms like application packaging or application-on-a-stick until now, but it seems like a great solution to the infamous “it worked on my machine” problem. However, there are reasons why it hasn’t gained widespread adoption as anticipated. Firstly, most solutions in this space are paid offerings that require a significant investment. Additionally, they require a “clean PC,” meaning that for each application you want to virtualize, you need to start with a fresh system. The package you create captures the differences between the base installation and any changes made afterward. These differences are then packaged into a distribution file, which can be executed on any workstation.</p>
<p class="normal">We’ve mentioned application<a id="_idIndexMarker003"/> virtualization to highlight that application issues such as “it works on my machine” have had different solutions over the years. Products such as <strong class="keyWord">ThinApp</strong> are just one attempt at solving the problem. Other attempts include running the application on a server using <strong class="keyWord">Citrix</strong>, <strong class="keyWord">Remote Desktop</strong>, <strong class="keyWord">Linux containers</strong>, <strong class="keyWord">chroot jails</strong>, and even <strong class="keyWord">virtual machines</strong>.</p>
<h1 class="heading-1" id="_idParaDest-20">Understanding why Kubernetes removed Docker</h1>
<p class="normal">Kubernetes removed<a id="_idIndexMarker004"/> all support for Docker in version 1.24 as a supported container runtime. While it has been removed as a runtime engine option, you can create new containers using Docker and they will run<a id="_idIndexMarker005"/> on any runtime that supports the <strong class="keyWord">Open Container Initiative</strong> (<strong class="keyWord">OCI</strong>) specification. OCI is a set of standards for containers and their runtimes. These standards ensure that containers remain portable, regardless of the container platform or the runtime used to execute them.</p>
<p class="normal">When you create a container using Docker, you are creating a container that is fully OCI compliant, so it will still run on Kubernetes clusters that are running any Kubernetes-compatible container runtime.</p>
<p class="normal">To fully explain the impact and the supported alternatives, we need to understand what a container runtime is. A high-level definition would be that a container runtime is the software layer that runs and manages containers. Like many components that make up a Kubernetes cluster, the runtime is not included as part of Kubernetes – it is a pluggable module that needs to be supplied by a vendor, or by you, to create a functioning cluster.</p>
<p class="normal">There are many technical reasons that led to the decision to deprecate and remove Docker, but at a high level, the main concerns were as follows:</p>
<ul>
<li class="bulletList">Docker contains multiple pieces inside of the Docker runtime<a id="_idIndexMarker006"/> to support its own remote API and <strong class="keyWord">user experience</strong> (<strong class="keyWord">UX</strong>). Kubernetes only requires one component in the executable, dockerd, which is the runtime process that manages containers. All other pieces of the executable contribute nothing to using Docker in a Kubernetes cluster. These extra components make the binary bloated and can lead to additional bugs, security, or performance issues.</li>
<li class="bulletList">Docker does not conform to the <strong class="keyWord">Container Runtime Interface</strong> (<strong class="keyWord">CRI</strong>) standard, which was introduced<a id="_idIndexMarker007"/> to create a set of standards to easily integrate container runtimes in Kubernetes. Since it doesn’t comply, the Kubernetes team has had extra work that only caters to supporting Docker.</li>
</ul>
<p class="normal">When it comes to local container testing and development, you can still use Docker on your workstation or server. Considering the previous statement, if you build a container on Docker and the container successfully runs on your Docker runtime system, it will run on a Kubernetes cluster that does not use Docker as the runtime.</p>
<p class="normal">Removing Docker will have very little impact on most users of Kubernetes in new clusters. Containers will still run using any standard method, as they would with Docker as the container runtime. If you happen to manage a cluster, you may need to learn new commands when you troubleshoot a Kubernetes node – you will not have a Docker command on the node to look at running containers, clean up volumes, and so on.</p>
<p class="normal">Kubernetes supports a number of runtimes in place of Docker. Two of the most commonly used runtimes are as follows:</p>
<ul>
<li class="bulletList">containerd</li>
<li class="bulletList">CRI-O</li>
</ul>
<p class="normal">While these are the two commonly<a id="_idIndexMarker008"/> used runtimes, there are a number of other compatible runtimes available. You can always view the latest supported runtimes on the Kubernetes GitHub page at <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md"><span class="url">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md</span></a>.</p>
<div class="packt_tip">
<p class="normal">For more details on the impact of deprecating and removing Docker, refer to the article called <em class="italic">Don’t Panic: Kubernetes and Docker</em> on the Kubernetes.io site at <a href="https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/"><span class="url">https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/</span></a>.</p>
</div>
<h2 class="heading-2" id="_idParaDest-21">Introducing Docker</h2>
<p class="normal">Both the industry and end users<a id="_idIndexMarker009"/> were seeking a solution that was both convenient and affordable, and this is where <strong class="keyWord">Docker</strong> containers came in. While containers have been utilized in different ways over time, Docker has brought about a transformation by providing a runtime and tools for everyday users and developers.</p>
<p class="normal">Docker brought an abstraction layer to the masses. It was easy to use and didn’t require a clean PC for every application before creating a package, thus offering a solution for dependency issues, but most attractive of all, it was free. Docker became a standard for many projects on GitHub, where teams would often create a Docker container and distribute the Docker image or Dockerfile to team members, providing a standard testing or development environment. This adoption by end users is what eventually brought Docker to the enterprise and, ultimately, what made it the standard it has become today.</p>
<p class="normal">Within the scope of this book, we will be focusing on what you will need to know when trying to use a local Kubernetes environment. Docker has a long and interesting history of how it evolved into the standard container image format that we use today. We encourage you to read about the company and how they ushered in the container world we know today.</p>
<p class="normal">While our focus is not to teach Docker inside out, we feel that those of you who are new to Docker would benefit from a quick primer on general container concepts.</p>
<p class="normal">If you have some Docker experience and understand terminology such as ephemeral and stateless, you can jump to the <em class="chapterRef">Installing Docker</em> section.</p>
<h2 class="heading-2" id="_idParaDest-22">Docker versus Moby</h2>
<p class="normal">When the Docker runtime<a id="_idIndexMarker010"/> was developed, it was<a id="_idIndexMarker011"/> a single code base. The single code base contained every function that Docker offered, whether you have used them or not. This led to inefficiencies, and it started to hinder the progression of Docker and containers in general.</p>
<p class="normal">The following table shows the differences between the Docker and Moby projects.</p>
<table class="table-container" id="table001-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Feature</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Docker</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Moby</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Development</p>
</td>
<td class="table-cell">
<p class="normal">The primary contributor is Docker, with some community support</p>
</td>
<td class="table-cell">
<p class="normal">It is open-source software with heavy community development and support</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Project scope</p>
</td>
<td class="table-cell">
<p class="normal">The complete platform that includes all components to build and run containers</p>
</td>
<td class="table-cell">
<p class="normal">It is a modular platform for building container-based components and solutions</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Ownership</p>
</td>
<td class="table-cell">
<p class="normal">It is a branded product, offered by Docker, Inc.</p>
</td>
<td class="table-cell">
<p class="normal">It is an open-source project that is used to build various container solutions</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Configuration</p>
</td>
<td class="table-cell">
<p class="normal">A full default configuration is included to make it easy for users to use it quickly</p>
</td>
<td class="table-cell">
<p class="normal">It has more available customizations, providing users with the ability to address their specific requirements</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Commercial support</p>
</td>
<td class="table-cell">
<p class="normal">It offers full support, including enterprise support</p>
</td>
<td class="table-cell">
<p class="normal">It is offered as open-source software; there is no support direct from the Moby project</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 1.1: Docker versus Moby features</p>
<p class="normal">To recap – <strong class="keyWord">Moby</strong> is a project that was started by Docker, but it is not the complete Docker runtime. The Docker runtime uses the components from Moby to create the Docker runtime, which includes the Moby open-source components<a id="_idIndexMarker012"/> and Docker’s own open-sourced<a id="_idIndexMarker013"/> components.</p>
<p class="normal">Now, let’s move on to understanding Docker a little more and how you can use it to create and manage containers.</p>
<h1 class="heading-1" id="_idParaDest-23">Understanding Docker</h1>
<p class="normal">This book assumes that you have a foundational<a id="_idIndexMarker014"/> understanding of Docker and container concepts. However, we know that not everyone will have prior experience with Docker or containers. Therefore, we have included this crash course to introduce you to container concepts and guide you through the usage of Docker.</p>
<p class="normal">If you are new to containers, we suggest reading the documentation that can be found on Docker’s website for additional information: <a href="https://docs.docker.com/"><span class="url">https://docs.docker.com/</span></a>.</p>
<h2 class="heading-2" id="_idParaDest-24">Containers are ephemeral</h2>
<p class="normal">The first thing to understand<a id="_idIndexMarker015"/> is that containers are ephemeral.</p>
<p class="normal">The term “ephemeral” means something that exists for a short period. <strong class="keyWord">Containers</strong> can be intentionally terminated, or automatically restarted without any user involvement or consequences. To better understand this concept, let’s look at an example – imagine someone interactively adds files to a web server running within a container. The uploaded files are temporary because they were not originally part of the base image.</p>
<p class="normal">This means that once a container is built and running, any changes that are made to the container will not be saved once it is removed, or destroyed, from the Docker host. Let’s look at a full example:</p>
<ol>
<li class="numberedList" value="1">You start a container running a web server using <strong class="keyWord">NGINX</strong> on your host without any base <strong class="keyWord">HTML</strong> pages.</li>
<li class="numberedList">Using a Docker command, you execute a <code class="inlineCode">copy</code> command to copy some web files into the container’s filesystem.</li>
<li class="numberedList">To test that the copy was successful, you go to the website and confirm that it is serving the correct web pages.</li>
<li class="numberedList">Happy with the results, you stop the container and remove it from the host. Later that day, you want to show a coworker the website and you start your <strong class="keyWord">NGINX</strong> container. You go to the website again, but when the site opens, you receive a <code class="inlineCode">404</code> error (page not found error).</li>
</ol>
<p class="normal">What happened to the files you uploaded before you stopped and removed the container from the host?</p>
<p class="normal">The reason your web pages cannot be found after the container was restarted is that all containers are ephemeral. Whatever is in the base container image is all that will be included each time the container is initially started. Any changes that you make inside a container are short-lived.</p>
<p class="normal">If you need to add permanent files to an existing image, you need to rebuild the image with the files included or, as we will explain in the <em class="chapterRef">Persistent data</em> section later in this chapter, you could mount a Docker volume in your container.</p>
<p class="normal">At this point, the main concept to understand is that containers are <strong class="keyWord">ephemeral</strong>.</p>
<p class="normal">But wait! You may be wondering, “If containers are ephemeral, how did I add web pages to the server?” <strong class="keyWord">Ephemeral</strong> just means that changes will not be saved; it doesn’t stop you from making changes to a running container.</p>
<p class="normal">Any changes made to a running container will be written to a temporary layer, called the <strong class="keyWord">container layer</strong>, which is a directory<a id="_idIndexMarker016"/> on the localhost filesystem. Docker uses a <strong class="keyWord">storage driver</strong>, which is in charge of handling<a id="_idIndexMarker017"/> requests that use the container layer. The storage driver is responsible for managing and storing images and containers on your Docker host. It controls the mechanisms and processes involved in their storage and management.</p>
<p class="normal">This location will store all changes in the container’s filesystem so that when you add the HTML pages to the container, they will be stored on the local host. The container layer is tied to the <strong class="keyWord">container ID</strong> of the running image and it will remain<a id="_idIndexMarker018"/> on the host system until the container is removed from Docker, either by using the CLI or by running a Docker <strong class="keyWord">prune job</strong> (see <em class="italic">Figure 1.1</em> on the next page).</p>
<p class="normal">Considering that containers<a id="_idIndexMarker019"/> are temporary and are read only, you might wonder how it’s possible to modify data within a container. Docker addresses<a id="_idIndexMarker020"/> this by utilizing <strong class="keyWord">image layering</strong>, which involves creating interconnected layers that collectively function as a single filesystem. Through this, changes can be made to the container’s data, even though the underlying image remains <strong class="keyWord">immutable</strong>.</p>
<h2 class="heading-2" id="_idParaDest-25">Docker images</h2>
<p class="normal">A Docker image is composed of multiple<a id="_idIndexMarker021"/> image layers, each<a id="_idIndexMarker022"/> accompanied by a <strong class="keyWord">JavaScript Object Notation</strong> (<strong class="keyWord">JSON</strong>) file that stores metadata specific to the layer. When a container image is launched, these layers are combined to form the application that users interact with.</p>
<p class="normal">You can read more about the contents of an image on Docker’s GitHub at <a href="https://github.com/moby/moby/blob/master/image/spec/v1.1.md"><span class="url">https://github.com/moby/moby/blob/master/image/spec/v1.1.md</span></a>.</p>
<h2 class="heading-2" id="_idParaDest-26">Image layers</h2>
<p class="normal">As we mentioned in the previous<a id="_idIndexMarker023"/> section, a running <a id="_idIndexMarker024"/>container uses a <strong class="keyWord">container layer</strong> that is “on top” of the base <strong class="keyWord">image layer</strong>, as shown in the following diagram:</p>
<figure class="mediaobject"><img alt="Figure 1.1 – Docker image layers " height="339" src="../Images/B21165_01_01.png" width="746"/></figure>
<p class="packt_figref">Figure 1.1: Docker image layers</p>
<p class="normal">The image layers cannot be written<a id="_idIndexMarker025"/> to since they are in a read-only state, but the temporary container layer is in a writeable state. Any data that you add to the container is stored in this layer and will be retained as long as the container is running.</p>
<p class="normal">To deal with multiple layers<a id="_idIndexMarker026"/> efficiently, Docker implements <strong class="keyWord">copy-on-write</strong>, which means that if a file already exists, it will not be created. However, if a file is required that does not exist in the current image, it will be written. In the container world, if a file exists in a lower layer, the layers above it do not need to include it. For example, if layer 1 had a file called <code class="inlineCode">/opt/nginx/index.xhtml</code> in it, layer 2 does not need the same file in its layer.</p>
<p class="normal">This explains how the system handles files that either exist or do not exist, but what about a file that has been modified? There will be times when you’ll need to replace a file that is in a lower layer. You may need to do this when you are building an image or as a temporary fix to a running container issue. The copy-on-write system knows how to deal with these issues. Since images read from the top down, the container uses only the highest layer file. If your system had a <code class="inlineCode">/opt/nginx/index.xhtml</code> file in layer 1 and you modified and saved the file, the running container would store the new file in the container layer. Since the container layer is the topmost layer, the new copy of <code class="inlineCode">index.xhtml</code> would always be read before the older version in the image layer.</p>
<h2 class="heading-2" id="_idParaDest-27">Persistent data</h2>
<p class="normal">Being limited to ephemeral-only <a id="_idIndexMarker027"/>containers would severely limit the use cases for Docker. You will probably encounter use cases where persistent storage is needed or data must be retained even if a container is stopped.</p>
<p class="normal">Remember, when you store data in the container image layer, the base image does not change. When the container is removed from the host, the container layer is also removed. If the same image is used to start a new container, a new container image layer is created. While containers themselves are ephemeral, you can achieve data persistence by incorporating a Docker volume. By utilizing a <strong class="keyWord">Docker volume</strong>, data can be stored externally in the container, enabling it to persist beyond the container’s lifespan.</p>
<h2 class="heading-2" id="_idParaDest-28">Accessing services running in containers</h2>
<p class="normal">Unlike a physical machine<a id="_idIndexMarker028"/> or a virtual machine, containers<a id="_idIndexMarker029"/> do not connect to a network directly. When a container needs to send or receive traffic, it goes through the Docker<a id="_idIndexMarker030"/> host system using a bridged <strong class="keyWord">network address translation</strong> (<strong class="keyWord">NAT</strong>) connection. This means that when you run a container and you want to receive incoming traffic requests, you need to expose the ports for each of the containers that you wish to receive traffic on. On a Linux-based system, <code class="inlineCode">iptables</code> has rules to forward traffic to the Docker daemon, which will service the assigned ports for each container. There is no need to worry about how the <code class="inlineCode">iptables</code> rules are created, as Docker will handle that for you by using the port information provided when you start the container. If you are new to Linux, <code class="inlineCode">iptables</code> may be new to you.</p>
<div class="note">
<p class="normal">At a high level, <code class="inlineCode">iptables</code> is used to manage network traffic and keep it secure within a cluster. It controls the flow of network connections between components in the cluster, deciding which connections are allowed and which ones are blocked.</p>
</div>
<p class="normal">That concludes the introduction to container fundamentals and Docker concepts. In the next section, we will guide you through the process of installing Docker on your host.</p>
<h1 class="heading-1" id="_idParaDest-29">Installing Docker</h1>
<p class="normal">The hands-on exercises in this book will require<a id="_idIndexMarker031"/> that you have a working Docker host. To install Docker, we have included a script located in this book’s GitHub repository, in the <code class="inlineCode">chapter1</code> directory, called <code class="inlineCode">install-docker.sh</code>.</p>
<p class="normal">Today, you can install Docker on just about every hardware platform out there. Each version of Docker acts and looks the same on each platform, making development and using Docker easy for people who need to develop cross-platform applications. By making the functions and commands the same between different platforms, developers do not need to learn a different container runtime to run images.</p>
<p class="normal">The following is a table of Docker’s available platforms. As you can see, there are installations for multiple OSs, as well as multiple architectures:</p>
<table class="table-container" id="table002">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Desktop Platform</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">x86_64/amd64</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">arm64 (Apple Silicon)</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Docker Desktop (Linux)</p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Docker Desktop (macOS)</p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Docker Desktop (Windows)</p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell"/>
</tr>
</tbody>
</table>
<table class="table-container" id="table003">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Server Platform</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">x86_64/amd64</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">arm64/aarch64</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">arm (32-bit)</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">ppcc64le</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">s390x</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">CentOS</p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell"/>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Debian</p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Fedora</p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell"/>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Raspberry Pi OS</p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal">RHEL (s390)</p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">SLES</p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Ubuntu</p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell">
<p class="normal"><img alt="Checkmark" height="17" src="../Images/Icon.png" width="23"/></p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 1.2: Available Docker platforms</p>
<p class="normal">Images that are created using one architecture cannot run on a different architecture. This means that you cannot create an image based on x86 hardware and expect that same image to run on your Raspberry Pi running an ARM processor. It’s also important to note that while you can run a Linux container on a Windows machine, you cannot run a Windows container on a Linux machine.</p>
<p class="normal">While images, by default, are not cross-architecture compatible, there are new tools to create what’s known as a multi-platform image. Multi-platform images<a id="_idIndexMarker032"/> are images that can be used across different architectures or processors in a single container, rather than having multiple images, such as one for <strong class="keyWord">NGINX</strong> on x86, another one for <strong class="keyWord">ARM</strong>, and another one for <strong class="keyWord">PowerPC</strong>. This will help you simplify your management and deployment of containerized applications. Since multi-platform images contain various versions, one for each architecture you include, you need to specify the architecture when deploying the image. Luckily, the container runtime will help out and automatically select the correct architecture from the image manifest.</p>
<p class="normal">The use of multi-platform images provides portability, flexibility, and scalability for your containers across cloud platforms, edge deployments, and hybrid infrastructure. With the use of ARM-based servers growing in the industry and the heavy use of Raspberry Pi by people learning Kubernetes, cross-platform images will help make consuming containers quicker and easier. </p>
<p class="normal">For example, in 2020, Apple released the M1 chip, ending the era of Apple running Intel processors in favor of the ARM processor. We’re not going to get into the details of the difference, only that they are different and this leads to important challenges for container developers and users. Docker does have <strong class="keyWord">Docker Desktop</strong>, a macOS tool for running containers that lets you use the same workflows that you used if you had a Docker installation on Linux, Windows, or x86 macOS. Docker will try to match the architecture of the underlying host when pulling or building images. On ARM-based systems, if you are attempting to pull an image that does not have an ARM version, Docker will throw an error due to the architecture incompatibilities. If you are attempting to build an image, it will build an ARM version on macOS, which cannot run on x86 machines.</p>
<p class="normal">Multi-platform images can be complex to create. If you want additional details on creating multi-platform images, visit the <em class="italic">Multi-platform</em><em class="italic"><a id="_idIndexMarker033"/></em><em class="italic"> images</em> page on Docker’s website: <a href="https://docs.docker.com/build/building/multi-platform/"><span class="url">https://docs.docker.com/build/building/multi-platform/</span></a>.</p>
<p class="normal">The installation procedures that are used to install Docker vary between platforms. Luckily, Docker has documented<a id="_idIndexMarker034"/> many of them on their website: <a href="https://docs.docker.com/install/"><span class="url">https://docs.docker.com/install/</span></a>.</p>
<p class="normal">In this chapter, we will<a id="_idIndexMarker035"/> install Docker on an <strong class="keyWord">Ubuntu 22.04</strong> system. If you do not have an Ubuntu machine to install on, you can still read about the installation steps, as each step will be explained and does not require that you have a running system to understand the process. If you have a different Linux installation, you can use the installation procedures<a id="_idIndexMarker036"/> outlined on Docker’s site at <a href="https://docs.docker.com/"><span class="url">https://docs.docker.com/</span></a>. Steps are provided for CentOS, Debian, Fedora, and Ubuntu, and there are generic<a id="_idIndexMarker037"/> steps for other Linux distributions.</p>
<h2 class="heading-2" id="_idParaDest-30">Preparing to install Docker</h2>
<p class="normal">Now that we have introduced<a id="_idIndexMarker038"/> Docker, the next step is to select an installation method. Docker’s installation changes between not only different Linux distributions but also versions of the same Linux distribution. Our script is based on using an Ubuntu 22.04 server, so it may not work on other versions of Ubuntu. You can install Docker using one of two methods:</p>
<ul>
<li class="bulletList">Add the Docker repositories to your host system</li>
<li class="bulletList">Install using Docker scripts</li>
</ul>
<p class="normal">The first option is considered the best option since it allows for easy installation and updates to the Docker engine. The second option is designed for installing Docker on testing/development environments and is not recommended for deployment in production environments.</p>
<p class="normal">Since the preferred method is to add Docker’s repository to our host, we will use that option.</p>
<h2 class="heading-2" id="_idParaDest-31">Installing Docker on Ubuntu</h2>
<p class="normal">Now that we have added<a id="_idIndexMarker039"/> the required <a id="_idIndexMarker040"/>repositories, the next step is to install Docker.</p>
<p class="normal">We have provided a script in the <code class="inlineCode">chapter1</code> folder of the Git repository called <code class="inlineCode">install</code>-<code class="inlineCode">docker.sh</code>. When you execute the script, it will automatically install all of the necessary binaries required for Docker to run.</p>
<p class="normal">To provide a brief summary of the script, it begins by modifying a specific value in the <code class="inlineCode">/etc/needrestart/needrestart.conf</code> file. In Ubuntu 22.04, there was a change in how daemons are restarted, where users might be required to manually select which system daemons to restart. To simplify the exercises described in the book, we alter the <code class="inlineCode">restart</code> value in the <code class="inlineCode">needsrestart.conf</code> file to “automatic” instead of prompting for each changed service.</p>
<p class="normal">Next, we install a few utilities like <code class="inlineCode">vim</code>, <code class="inlineCode">ca-certificates</code>, <code class="inlineCode">curl</code>, and <code class="inlineCode">GnuPG</code>. The first three utilities are fairly common, but the last one, <code class="inlineCode">GnuPG</code>, may be newer to some readers and might<a id="_idIndexMarker041"/> need some explaining. <code class="inlineCode">GnuPG</code>, an acronym for <strong class="keyWord">GNU Privacy Guard</strong>, enhances Ubuntu with a range of cryptographic capabilities such as <strong class="keyWord">encryption</strong>, <strong class="keyWord">decryption</strong>, <strong class="keyWord">digital signatures</strong>, and <strong class="keyWord">key management</strong>.</p>
<p class="normal">In our Docker deployment, we need<a id="_idIndexMarker042"/> to add Docker’s <strong class="keyWord">GPG public key</strong>. which is a cryptographic key pair that secures communication and maintains data integrity. GPG keys use asymmetrical encryption, which involves<a id="_idIndexMarker043"/> the use of two different, but<a id="_idIndexMarker044"/> related, keys, known as a <strong class="keyWord">public</strong> key and a <strong class="keyWord">private</strong> key. These keys are generated together as a pair, but they provide different functions. The private key, which remains confidential, is used to generate the digital signatures on the downloaded files. The public key is publicly available and is used to verify digital signatures created by the private key.</p>
<p class="normal">Next, we need to add Docker’s repository to our local repository list. When we add the repository to the list, we need to include the Docker certificate. The <code class="inlineCode">docker.gpg</code> certificate was downloaded by the script from Docker’s site and stored on the local server under <code class="inlineCode">/etc/apt/keyings/docker.gpg</code>. When we add the repository to the repository list, we add the key by using the signed-by option in the <code class="inlineCode">/etc/apt/sources.list.d/docker.list</code> file. The full command is shown here:</p>
<pre class="programlisting con"><code class="hljs-con">deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu   jammy stable
</code></pre>
<p class="normal">By including the Docker repository in our local <code class="inlineCode">apt</code> repository list, we gain the ability to install the Docker binaries effortlessly. This process entails using a straightforward <code class="inlineCode">apt-get install</code> command, which will install the five essential binaries for Docker: <code class="inlineCode">docker-ce</code>, <code class="inlineCode">docker-ce-cli</code>, <code class="inlineCode">containerd.io</code>, <code class="inlineCode">docker-buildx-plugin</code>, and <code class="inlineCode">docker-compose-plugin</code>. As previously stated, all these files are signed with Docker’s GPG key. Thanks to the inclusion of Docker’s key on our server, we can be confident that the files are safe and originate from a reliable source.</p>
<p class="normal">Once Docker is successfully installed, the next step involves enabling and configuring the Docker daemon to start automatically during system boot using the <code class="inlineCode">systemctl</code> command. This process follows the standard procedure applied to most system daemons installed on Linux servers.</p>
<div class="note">
<p class="normal">Rather than go over each line of code in each script, we have included comments in the scripts to help you understand how what each command and step is executing. Where it may help with some topics, we will include some section of code in the chapters for reference.</p>
</div>
<p class="normal">After installing <a id="_idIndexMarker045"/>Docker, let’s get some configuration<a id="_idIndexMarker046"/> out of the way. First, you will rarely execute commands as root in the real world, so we need to grant permissions to use Docker to your user.</p>
<h2 class="heading-2" id="_idParaDest-32">Granting Docker permissions</h2>
<p class="normal">In a default installation, Docker<a id="_idIndexMarker047"/> requires root access, so you will need to run all Docker commands as <strong class="keyWord">root</strong>. Rather than using <code class="inlineCode">sudo</code> with every Docker command, you can add your user account to a new group on the server that provides Docker access without requiring <code class="inlineCode">sudo</code> for every command.</p>
<p class="normal">If you are logged on as a standard user and try to run a Docker command, you will receive an error:</p>
<pre class="programlisting con"><code class="hljs-con">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.40/images/json: dial unix /var/run/docker.sock: connect: permission denied
</code></pre>
<p class="normal">To allow your user, or any other user you may want to add, to execute Docker commands, you need to add the users to a new group called <code class="inlineCode">docker</code> that was created during the installation of Docker. The following is an example command you can use to add the currently logged-on user to the group:</p>
<pre class="programlisting con"><code class="hljs-con">sudo usermod -aG docker $USER
</code></pre>
<p class="normal">To add the new members<a id="_idIndexMarker048"/> to your account, you can either log off and log back into the Docker host, or activate the group changes using the <code class="inlineCode">newgrp</code> command:</p>
<pre class="programlisting con"><code class="hljs-con">newgrp docker
</code></pre>
<p class="normal">Now, let’s test that Docker is working by running the standard <code class="inlineCode">hello-world</code> image (note that we do not require <code class="inlineCode">sudo</code> to run the Docker command):</p>
<pre class="programlisting con"><code class="hljs-con">docker run hello-world
</code></pre>
<p class="normal">You should see the following output, which verifies that your user has access to Docker:</p>
<pre class="programlisting con"><code class="hljs-con">Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
2db29710123e: Pull complete
Digest: sha256:37a0b92b08d4919615c3ee023f7ddb068d12b8387475d64c622ac30f45c29c51
Status: Downloaded newer image for hello-world:latest
Hello from Docker!
</code></pre>
<p class="normal">This message shows that your installation is working correctly – congratulations!</p>
<p class="normal">To generate this message, Docker took the following steps:</p>
<ol>
<li class="numberedList" value="1">The Docker client contacted the Docker daemon.</li>
<li class="numberedList">The Docker daemon pulled the <code class="inlineCode">hello-world</code> image from Docker Hub (amd64).</li>
<li class="numberedList">The Docker daemon created a new container from the image that runs the executable that produces the output you are currently reading.</li>
<li class="numberedList">The Docker daemon streamed that output to the Docker client, which sent it to your terminal.</li>
</ol>
<p class="normal">To try something more ambitious – you can run an Ubuntu container with the following:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">docker run -it ubuntu bash</span>
</code></pre>
<p class="normal">For more examples<a id="_idIndexMarker049"/> and ideas, visit <a href="https://docs.docker.com/get-started/"><span class="url">https://docs.docker.com/get-started/</span></a>.</p>
<p class="normal">Now that we’ve granted<a id="_idIndexMarker050"/> Docker permission, we can start unlocking the most common Docker commands by learning how to use the Docker CLI.</p>
<h1 class="heading-1" id="_idParaDest-33">Using the Docker CLI</h1>
<p class="normal">You used the Docker CLI <a id="_idIndexMarker051"/>when you ran the <code class="inlineCode">hello-world</code> container to test your installation. The Docker command is what you will use to interact with the Docker daemon. Using this single executable, you can do the following, and more:</p>
<ul>
<li class="bulletList">Start and stop containers</li>
<li class="bulletList">Pull and push images</li>
<li class="bulletList">Run a shell in an active container</li>
<li class="bulletList">Look at container logs</li>
<li class="bulletList">Create Docker volumes</li>
<li class="bulletList">Create Docker networks</li>
<li class="bulletList">Prune old images and volumes</li>
</ul>
<p class="normal">This chapter is not meant to include an exhaustive explanation of every Docker command; instead, we will explain some of the common commands that you will need to use to interact with the Docker daemon and containers.</p>
<p class="normal">You can break down Docker commands into two categories: general Docker commands and Docker management commands. The standard Docker commands allow you to manage containers, while management commands allow you to manage Docker options such as managing volumes and networking.</p>
<h2 class="heading-2" id="_idParaDest-34">docker help</h2>
<p class="normal">It is quite common to forget<a id="_idIndexMarker052"/> the syntax or options of a command, and Docker acknowledges this. If you ever find yourself in a situation where you can’t recall a command, you can always depend on the <code class="inlineCode">docker help</code> command. It will help<a id="_idIndexMarker053"/> you by providing what the command can do and how to use it.</p>
<h2 class="heading-2" id="_idParaDest-35">docker run</h2>
<p class="normal">To run a container, use<a id="_idIndexMarker054"/> the <code class="inlineCode">docker run</code> command with the provided image name. But, before executing a <code class="inlineCode">docker run</code> command, you should understand the options you can supply when starting a container.</p>
<p class="normal">In its simplest form, an example command you can use to run an NGINX web server would be <code class="inlineCode">docker run bitnami/nginx:latest</code>. This will start a container running NGINX, and it will run in the foreground, showing logs of the application running in the container. Pressing <em class="keystroke">Ctrl</em> + <em class="keystroke">C</em> will stop the running container and terminate the NGINX server:</p>
<pre class="programlisting con"><code class="hljs-con">nginx 22:52:27.42
nginx 22:52:27.42 Welcome to the Bitnami nginx container
nginx 22:52:27.43 Subscribe to project updates by watching https://github.com/bitnami/bitnami-docker-nginx
nginx 22:52:27.43 Submit issues and feature requests at https://github.com/bitnami/bitnami-docker-nginx/issues
nginx 22:52:27.44
nginx 22:52:27.44 INFO  ==&gt; ** Starting NGINX setup **
nginx 22:52:27.49 INFO  ==&gt; Validating settings in NGINX_* env vars
nginx 22:52:27.50 INFO  ==&gt; Initializing NGINX
nginx 22:52:27.53 INFO  ==&gt; ** NGINX setup finished! **
nginx 22:52:27.57 INFO  ==&gt; ** Starting NGINX **
</code></pre>
<p class="normal">As you saw, when you used <em class="keystroke">Ctrl</em> + <em class="keystroke">C</em> to stop the container, NGINX also stopped. In most cases, you want a container to start and continue to run without being in the foreground, allowing the system to run other tasks while the container also continues to run. To run a container as a background process, you need to add the <code class="inlineCode">-d</code>, or <code class="inlineCode">--detach</code> option to your Docker command, which will run your container in detached mode. Now, when you run a detached container, you will only see the container ID, instead of the interactive or attached screen:</p>
<pre class="programlisting con"><code class="hljs-con">[root@localhost ~]# docker run -d bitnami/nginx:latest
13bdde13d0027e366a81d9a19a56c736c28feb6d8354b363ee738d2399023f80
[root@localhost ~]#
</code></pre>
<p class="normal">By default, containers will be given a random name once they are started. In our previous detached example, if we list the running containers, we will see that the container has been given the name <code class="inlineCode">silly_keldysh</code>, as shown in the following output:</p>
<pre class="programlisting con"><code class="hljs-con">CONTAINER ID      IMAGE                      NAMES
13bdde13d002      bitnami/nginx:l
</code></pre>
<p class="normal">If you do not assign a name to your container, it can quickly get confusing as you start to run multiple containers on a single host. To make management easier, you should always start your container with a name that will make it easier to manage. Docker provides another option with the <code class="inlineCode">run</code> command: the <code class="inlineCode">--name</code> option. Building on our previous example, we will name our container <code class="inlineCode">nginx-test</code>. Our new <code class="inlineCode">docker run</code> command will be as follows:</p>
<pre class="programlisting con"><code class="hljs-con">docker run --name nginx-test -d bitnami/nginx:latest
</code></pre>
<p class="normal">Just like running any detached<a id="_idIndexMarker055"/> image, this will return the container ID, but not the name you provided. In order to verify that the container ran with the name <code class="inlineCode">nginx-test</code>, we can list the containers using the <code class="inlineCode">docker ps</code> command, which we will explain next.</p>
<h2 class="heading-2" id="_idParaDest-36">docker ps</h2>
<p class="normal">Often, you will need<a id="_idIndexMarker056"/> to retrieve a list of running containers or a list of containers that have been stopped. The Docker CLI has a flag called <code class="inlineCode">ps</code> that will list all running and stopped containers, by adding the extra flag to the <code class="inlineCode">ps</code> command. The output will list the containers, including their container ID, image tag, <code class="inlineCode">entry</code> command, creation date, status, ports, and container name. The following is an example of containers that are currently running:</p>
<pre class="programlisting con"><code class="hljs-con">CONTAINER ID   IMAGE                  COMMAND                 CREATED
13bdde13d002   bitnami/nginx:latest   "/opt/bitnami/script…"  Up 4 hours
3302f2728133   registry:2             "/entrypoint.sh /etc…"  Up 3 hours
</code></pre>
<p class="normal">This is helpful if the container you are looking for is currently running, but what if the container has stopped, or even worse, what if the container failed to start and then stopped? You can view the status of all containers, including previously run containers, by adding the <code class="inlineCode">-a</code> flag to the <code class="inlineCode">docker ps</code> command. When you execute <code class="inlineCode">docker ps -a</code>, you will see the same output from a standard <code class="inlineCode">ps</code> command, but you will notice that the list may include additional containers.</p>
<p class="normal">How can you tell which containers are running versus which ones have stopped? If you look at the <code class="inlineCode">STATUS</code> field of the list, the running containers will show a running time; for example, <code class="inlineCode">Up xx hours</code>, or <code class="inlineCode">Up xx days</code>. However, if the container has been stopped for any reason, the status will show when it stopped; for example, <code class="inlineCode">Exited (0) 10 minutes ago</code>.</p>
<pre class="programlisting con"><code class="hljs-con">IMAGE                  COMMAND                  CREATED         STATUS
bitnami/nginx:latest   "/opt/bitnami/script…"   10 minutes ago  Up 10 minutes
bitnami/nginx:latest   "/opt/bitnami/script…"   12 minutes ago  Exited (0) 10 minutes ago
</code></pre>
<p class="normal">A stopped container does not mean there was an issue with running the image. There are containers that may execute a single task and, once completed, the container may stop gracefully. One way to determine whether an exit was graceful or whether it was due to a failed startup is to look at the exited status code. There are a number of exit codes that you can use<a id="_idIndexMarker057"/> to find out why a container has exited.</p>
<table class="table-container" id="table004">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Exit Code</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">0</code></p>
</td>
<td class="table-cell">
<p class="normal">The command was executed successfully without any issues.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">1</code></p>
</td>
<td class="table-cell">
<p class="normal">The command failed due to an unexpected error.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">2</code></p>
</td>
<td class="table-cell">
<p class="normal">The command was unable to find the specified resource or encountered a similar issue.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">125</code></p>
</td>
<td class="table-cell">
<p class="normal">The command failed due to a Docker-related error.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">126</code></p>
</td>
<td class="table-cell">
<p class="normal">The command failed because the Docker binary or script could not be executed.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">127</code></p>
</td>
<td class="table-cell">
<p class="normal">The command failed because the Docker binary or script could not be found.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">128+</code></p>
</td>
<td class="table-cell">
<p class="normal">The command failed due to a specific Docker-related error or exception.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 1.3: Docker exit codes</p>
<h2 class="heading-2" id="_idParaDest-37">docker start and stop</h2>
<p class="normal">You may need to stop a container<a id="_idIndexMarker058"/> due to limited system resources, limiting you to running a few containers simultaneously. To stop a running container and free up resources, use the <code class="inlineCode">docker stop</code> command with the name of the container, or the container ID, you want to stop.</p>
<p class="normal">If you need to start that container at a future time for additional testing or development, execute <code class="inlineCode">docker start &lt;name&gt;</code>, which will start the container with all of the options that it was originally started<a id="_idIndexMarker059"/> with, including any networks or volumes that were assigned.</p>
<h2 class="heading-2" id="_idParaDest-38">docker attach</h2>
<p class="normal">In order to troubleshoot<a id="_idIndexMarker060"/> an issue or inspect a log file, it may be necessary to interact with a container. One way to connect to a container that is currently running is by using the <code class="inlineCode">docker attach &lt;container ID/name&gt;</code> command. When you perform this action, you establish a connection with the active process of the running container. If you attach to a container that is executing a process, it is unlikely that you will see any prompt. In fact, it’s likely that you will see a blank screen for a period of time until the container starts producing output that is displayed on the screen.</p>
<p class="normal">You should always be cautious when attaching to a container. It’s easy to accidentally stop the running process and, in turn, stop the container. Let’s use an example of attaching to a web server running NGINX. First, we need to verify that the container is running using <code class="inlineCode">docker ps</code>:</p>
<pre class="programlisting con"><code class="hljs-con">CONTAINER ID   IMAGE                 COMMAND                   STATUS
4a77c14a236a   nginx                 "/docker-entrypoint.…"    Up 33 seconds
</code></pre>
<p class="normal">Using the <code class="inlineCode">attach</code> command, we execute <code class="inlineCode">docker attach 4a77c14a236a</code>.</p>
<p class="normal">When you attach to a process, you will only be able to interact with the running process, and the only output you will see is data being sent to standard output. In the case of the NGINX container, the <code class="inlineCode">attach</code> command has been attached to the NGINX process. To show this, we will leave the attachment and <code class="inlineCode">curl</code> to the web server from another session. Once we <code class="inlineCode">curl</code> to the container, we will see logs outputted to the attached console:</p>
<pre class="programlisting con"><code class="hljs-con">[root@astra-master manifests]# docker attach 4a77c14a236a
172.17.0.1 - - [15/Oct/2021:23:28:31 +0000] "GET / HTTP/1.1" 200 615 "-" "curl/7.61.1" "-"
172.17.0.1 - - [15/Oct/2021:23:28:33 +0000] "GET / HTTP/1.1" 200 615 "-" "curl/7.61.1" "-"
172.17.0.1 - - [15/Oct/2021:23:28:34 +0000] "GET / HTTP/1.1" 200 615 "-" "curl/7.61.1" "-"
172.17.0.1 - - [15/Oct/2021:23:28:35 +0000] "GET / HTTP/1.1" 200 615 "-" "curl/7.61.1" "-"
172.17.0.1 - - [15/Oct/2021:23:28:36 +0000] "GET / HTTP/1.1" 200 615 "-" "curl/7.61.1" "-"
</code></pre>
<p class="normal">We mentioned that you need to be careful once you attach to the container. Those who are new to Docker may attach to the NGINX image and assume that nothing is happening on the server or a process appears to be hung so they may decide to break out of the container using the standard <em class="keystroke">Ctrl</em> + <em class="keystroke">C</em> keyboard command. This will stop the container and send them back to a Bash prompt, where they may run <code class="inlineCode">docker ps</code> to look at the running containers:</p>
<pre class="programlisting con"><code class="hljs-con">root@localhost:~# docker ps
CONTAINER ID      IMAGE  COMMAND    CREATED    STATUS
root@localhost:~#
</code></pre>
<p class="normal">What happened to the NGINX container? We didn’t execute a <code class="inlineCode">docker stop</code> command, and the container was running until we attached to the container. Why did the container stop after we attached to it?</p>
<p class="normal">As we mentioned, when an attachment is made to a container, you are attached to the running process. All keyboard commands will act in the same way as if you were at a physical server that was running NGINX in a regular shell. This means that when the user used <em class="keystroke">Ctrl</em> + <em class="keystroke">C</em> to return to a prompt, they stopped the running NGINX process.</p>
<p class="normal">If we press <em class="keystroke">Ctrl</em> + <em class="keystroke">C</em> to exit the container, we will receive<a id="_idIndexMarker061"/> an output that shows that the process has been terminated. The following output shows an example of what happens in our NGINX example:</p>
<pre class="programlisting con"><code class="hljs-con">2023/06/27 19:38:02 [notice] 1#1: signal 2 (SIGINT) received, exiting2023/06/27 19:38:02 [notice] 31#31: exiting2023/06/27 19:38:02 [notice] 30#30: exiting2023/06/27 19:38:02 [notice] 29#29: exiting2023/06/27 19:38:02 [notice] 31#31: exit2023/06/27 19:38:02 [notice] 30#30: exit2023/06/27 19:38:02 [notice] 29#29: exit2023/06/27 19:38:02 [notice] 32#32: exiting2023/06/27 19:38:02 [notice] 32#32: exit2023/06/27 19:38:03 [notice] 1#1: signal 17 (SIGCHLD) received from 312023/06/27 19:38:03 [notice] 1#1: worker process 29 exited with code 02023/06/27 19:38:03 [notice] 1#1: worker process 31 exited with code 02023/06/27 19:38:03 [notice] 1#1: worker process 32 exited with code 02023/06/27 19:38:03 [notice] 1#1: signal 29 (SIGIO) received2023/06/27 19:38:03 [notice] 1#1: signal 17 (SIGCHLD) received from 292023/06/27 19:38:03 [notice] 1#1: signal 17 (SIGCHLD) received from 302023/06/27 19:38:03 [notice] 1#1: worker process 30 exited with code 02023/06/27 19:38:03 [notice] 1#1: exit
</code></pre>
<p class="normal">If a container’s running process stops, the container will also stop, and that’s why the <code class="inlineCode">docker ps</code> command does not show a running NGINX container.</p>
<p class="normal">To exit an attachment, rather than use <em class="keystroke">Ctrl</em> + <em class="keystroke">C</em> to return to a prompt, you should have used <em class="keystroke">Ctrl</em> + <em class="keystroke">P</em>, followed by <em class="keystroke">Ctrl</em> + <em class="keystroke">Q</em>, which will exit the container without stopping the running process.</p>
<p class="normal">There is an alternative<a id="_idIndexMarker062"/> to the <code class="inlineCode">attach</code> command: the <code class="inlineCode">docker exec</code> command. The <code class="inlineCode">exec</code> command differs from the <code class="inlineCode">attach</code> command since you supply the process to execute on the container.</p>
<h2 class="heading-2" id="_idParaDest-39">docker exec</h2>
<p class="normal">A better option when it comes<a id="_idIndexMarker063"/> to interacting with a running container is the <code class="inlineCode">exec</code> command. Rather than attach to the container, you can use the <code class="inlineCode">docker exec</code> command to execute a process in the container. You need to supply the container name and the process you want to execute in the image. Of course, the process must be included in the running image – if you do not have the Bash executable in the image, you will receive an error when trying to execute Bash in the container.</p>
<p class="normal">We will use an NGINX container as an example again. We will verify that NGINX is running using <code class="inlineCode">docker ps</code> and then, using the container ID or the name, we execute into the container. The command syntax is <code class="inlineCode">docker exec &lt;options&gt; &lt;container name&gt; &lt;command&gt;</code>:</p>
<pre class="programlisting con"><code class="hljs-con">root@localhost:~# docker exec -it nginx-test bash
I have no name!@a7c916e7411:/app$
</code></pre>
<p class="normal">The option we included is <code class="inlineCode">-it</code>, which tells the <code class="inlineCode">exec</code> to run in an interactive TTY session. Here, the process we want to execute is Bash.</p>
<p class="normal">Notice how the prompt name changed from the original user and hostname. The hostname is <code class="inlineCode">localhost</code>, while the container name is <code class="inlineCode">a7c916e7411</code>. You may also have noticed that the current working directory changed from <code class="inlineCode">~</code> to <code class="inlineCode">/app</code> and that the prompt is not running as a root user, as shown by the <code class="inlineCode">$</code> prompt.</p>
<p class="normal">You can use this session the same way you would a standard <strong class="keyWord">SSH</strong> connection; you are running Bash in the container and since we are not attached to the running process in the container, <em class="keystroke">Ctrl</em> + <em class="keystroke">C</em> will not stop any process from running.</p>
<p class="normal">To exit an interactive session, you only need to type in <code class="inlineCode">exit</code>, followed by <em class="keystroke">Enter</em>, which will exit the container. If you then run <code class="inlineCode">docker ps</code>, you will notice that the container is still in a running state.</p>
<p class="normal">Next, let’s see what we can learn about Docker log files.</p>
<h2 class="heading-2" id="_idParaDest-40">docker logs</h2>
<p class="normal">The <code class="inlineCode">docker logs</code> command<a id="_idIndexMarker064"/> allows you to retrieve logs from a container using the container name or container ID. You can view the logs from any container that is listed in your <code class="inlineCode">ps</code> command; it doesn’t matter if it’s currently running or stopped.</p>
<p class="normal">Log files are often the only way to troubleshoot why a container may not be starting up, or why a container is in an exited state. For example, if you attempt to run an image and the image starts and suddenly stops, you may find the answer by looking at the logs for that container.</p>
<p class="normal">To look at the logs for a container, you can use the <code class="inlineCode">docker logs &lt;container ID or name&gt;</code> command.</p>
<p class="normal">To view the logs for a container with a container ID of <code class="inlineCode">7967c50b260f</code>, you would use the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker logs 7967c50b260f
</code></pre>
<p class="normal">This will output the logs from the container to your screen, which may be very long and verbose. Since many logs may contain a lot of information, you can limit the output by supplying the <code class="inlineCode">logs</code> command with additional options. The following table lists the options available for viewing logs:</p>
<table class="table-container" id="table005">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Log Options</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">-f</code></p>
</td>
<td class="table-cell">
<p class="normal">Follow the log output (can also use <code class="inlineCode">--follow</code>).</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">--tail xx</code></p>
</td>
<td class="table-cell">
<p class="normal">Show the log output starting from the end of the file and retrieve <code class="inlineCode">xx</code> lines.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">--until xxx</code></p>
</td>
<td class="table-cell">
<p class="normal">Show the log output before the <code class="inlineCode">xxx</code> timestamp.</p>
<p class="normal"><code class="inlineCode">xxx</code> can be a timestamp; for example, <code class="inlineCode">2020-02-23T18:35:13</code>.</p>
<p class="normal"><code class="inlineCode">xxx</code> can be a relative time; for example, <code class="inlineCode">60m</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">--since xxx</code></p>
</td>
<td class="table-cell">
<p class="normal">Show the log output after the <code class="inlineCode">xxx</code> timestamp.</p>
<p class="normal"><code class="inlineCode">xxx</code> can be a timestamp; for example, <code class="inlineCode">2020-02-23T18:35:13</code>.</p>
<p class="normal"><code class="inlineCode">xxx</code> can be a relative time; for example, <code class="inlineCode">60m</code>.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 1.4: Log options</p>
<p class="normal">Checking log files is a process you will find yourself doing often, and since they can be very lengthy, knowing options like <code class="inlineCode">tail</code>, <code class="inlineCode">until</code>, and <code class="inlineCode">since</code> will help you to find the information in a log quicker.</p>
<h2 class="heading-2" id="_idParaDest-41">docker rm</h2>
<p class="normal">Once you assign a name<a id="_idIndexMarker065"/> to a container, the assigned name cannot be used on a different container unless you remove it using the <code class="inlineCode">docker rm</code> command. If you had a container running called <code class="inlineCode">nginx-test</code> that was stopped and you attempted to start another container with the name <code class="inlineCode">nginx-test</code>, the Docker daemon would return an error, stating that the name is in use:</p>
<pre class="programlisting con"><code class="hljs-con">Conflict.  The container name "/nginx-test" is already in use
</code></pre>
<p class="normal">The original <code class="inlineCode">nginx-test</code> container is not running, but the daemon knows that the container name was used previously and that it’s still in the list of previously run containers.</p>
<p class="normal">When you want to reuse a specific name, you must first remove the existing container before launching a new one with the same name. This scenario commonly occurs during container image testing. You may initially start a container but encounter issues with the application or image. In such instances, you would stop the container, resolve the problems with the image or application, and wish to redeploy it using the same name. However, since the previous container with that name still exists in the Docker history, it becomes necessary to remove it before reutilizing the name.</p>
<div class="note">
<p class="normal">You can also add the <code class="inlineCode">--rm</code> option to your Docker command to automatically remove the image after it is stopped.</p>
</div>
<p class="normal">To remove the <code class="inlineCode">nginx-test</code> container, simply execute <code class="inlineCode">docker rm nginx-test</code>:</p>
<pre class="programlisting con"><code class="hljs-con">root@localhost ~:# docker rm nginx-test
nginx-test
root@localhost ~:#
</code></pre>
<p class="normal">Assuming the container name is correct and it’s not running, the only output you will see is the name of the image that you have removed.</p>
<p class="normal">We haven’t discussed Docker volumes, but when removing a container that has a volume, or volumes, attached, it’s a good practice to add the <code class="inlineCode">-v</code> option to your remove command. Adding the <code class="inlineCode">-v</code> option to the <code class="inlineCode">docker rm</code> command will remove any volumes that were attached to the container.</p>
<h2 class="heading-2" id="_idParaDest-42">docker pull/run</h2>
<p class="normal">When running a <code class="inlineCode">pull</code>, make<a id="_idIndexMarker066"/> sure to specify the architecture. <code class="inlineCode">docker</code> <code class="inlineCode">pull</code> and <code class="inlineCode">run</code> are used to either pull an image or run an image. If you try to run a container that doesn’t exist on the Docker host already, it will initiate a <code class="inlineCode">pull</code> request to get the container and then run it.</p>
<p class="normal">When you attempt to <code class="inlineCode">pull</code> or <code class="inlineCode">run</code> a container, Docker will download a container that is compatible with the host’s architecture. If you want to download a different image that is based on a different architecture, you can add the <code class="inlineCode">--platform</code> tag to the <code class="inlineCode">build</code> command. For example, if you are on a system that is running on arm64 architecture and you want to pull an x86 image, you would add <code class="inlineCode">linux/arm64</code> as your platform. When running a pull, make sure to specify the architecture:</p>
<pre class="programlisting con"><code class="hljs-con">root@localhost ~:# docker pull --platform=linux/amd64 ubuntu:22.04
22.04: Pulling from library/ubuntu6b851dcae6ca: Pull completeDigest: sha256:6120be6a2b7ce665d0cbddc3ce6eae60fe94637c6a66985312d1f02f63cc0bcdStatus: Downloaded newer image for ubuntu:22.04WARNING: image with reference ubuntu was found but does not match the specified platform: wanted linux/amd64, actual: linux/arm64/v8docker.io/library/ubuntu:22.04
</code></pre>
<p class="normal">Adding <code class="inlineCode">--platform=linux/amd64</code> is what told Docker to get the right platform. You can use the same parameter<a id="_idIndexMarker067"/> for <code class="inlineCode">docker run</code> to make sure that the right container image platform is used.</p>
<h2 class="heading-2" id="_idParaDest-43">docker build</h2>
<p class="normal">Similar to <code class="inlineCode">pull</code> and <code class="inlineCode">run</code>, Docker<a id="_idIndexMarker068"/> will attempt to build the image based on the host’s architecture: <code class="inlineCode">arm64</code>. Assuming you are building on an arm64-based image system, you can tell Docker to create an x86 image by using the <code class="inlineCode">buildx</code> sub-command:</p>
<pre class="programlisting con"><code class="hljs-con">root@localhost ~:# docker buildx build --platform linux/amd64 --tag docker.io/mlbiam/openunison-kubernetes-operator --no-cache -f ./src/main/docker/Dockerfile .
</code></pre>
<p class="normal">This addition tells Docker to generate the <code class="inlineCode">x86</code> version, which will run on any x86-based hardware. </p>
<h1 class="heading-1" id="_idParaDest-44">Summary</h1>
<p class="normal">In this chapter, you learned how Docker can be used to solve common development issues, including the dreaded “it works on my machine” problem. We also presented an introduction to the most commonly used Docker CLI commands that you will use on a daily basis.</p>
<p class="normal">In the next chapter, we will start our Kubernetes journey with an introduction to <strong class="keyWord">KinD</strong>, a utility that provides an easy way to run multi-node Kubernetes test servers on a single workstation.</p>
<h1 class="heading-1" id="_idParaDest-45">Questions</h1>
<ol>
<li class="numberedList" value="1">A <strong class="keyWord">single</strong> Docker image can be used on any Docker host, regardless of the architecture used.<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">True</li>
<li class="alphabeticList level-2">False</li>
</ol>
</li>
</ol>
<p class="normal-one">Answer: b</p>
<div class="note-one">
<p class="normal">We added the topic of cross-platform images </p>
</div>
<ol>
<li class="numberedList" value="2">What does Docker use to merge multiple image layers into a single filesystem?<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">Merged filesystem</li>
<li class="alphabeticList level-2">NTFS filesystem</li>
<li class="alphabeticList level-2">EXT4 filesystem</li>
<li class="alphabeticList level-2">Union filesystem</li>
</ol>
</li>
</ol>
<p class="normal-one">Answer: d</p>
<ol>
<li class="numberedList" value="3">Kubernetes is only compatible with the Docker runtime engine.<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">True</li>
<li class="alphabeticList level-2">False</li>
</ol>
</li>
</ol>
<p class="normal-one">Answer: b</p>
<ol>
<li class="numberedList" value="4">When you edit a container’s filesystem interactively, what layer are the changes written to?<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">OS layer</li>
<li class="alphabeticList level-2">Bottom-most layer</li>
<li class="alphabeticList level-2">Container layer</li>
<li class="alphabeticList level-2">Ephemeral layer</li>
</ol>
</li>
</ol>
<p class="normal-one">Answer: c</p>
<ol>
<li class="numberedList" value="5">Assuming the image contains the required binaries, what Docker command allows you to gain access to a running container’s bash prompt?<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1"><code class="inlineCode">docker shell -it &lt;container&gt; /bin/bash</code></li>
<li class="alphabeticList level-2"><code class="inlineCode">docker run -it &lt;container&gt; /bin/bash</code></li>
<li class="alphabeticList level-2"><code class="inlineCode">docker exec -it &lt;container&gt; /bin/bash</code></li>
<li class="alphabeticList level-2"><code class="inlineCode">docker spawn -it &lt;container&gt; /bin/bash</code></li>
</ol>
</li>
</ol>
<p class="normal-one">Answer: c</p>
<ol>
<li class="numberedList" value="6">If you start a container with a simple <code class="inlineCode">run</code> command, without any flags, and the container is stopped, the Docker daemon will delete all traces of the container.<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">True</li>
<li class="alphabeticList level-2">False</li>
</ol>
</li>
</ol>
<p class="normal-one">Answer: b</p>
<ol>
<li class="numberedList" value="7">What command will show you a list of all containers, including any stopped containers?<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1"><code class="inlineCode">docker ps -all</code></li>
<li class="alphabeticList level-2"><code class="inlineCode">docker ps -a</code></li>
<li class="alphabeticList level-2"><code class="inlineCode">docker ps -list</code></li>
<li class="alphabeticList level-2"><code class="inlineCode">docker list all</code></li>
</ol>
</li>
</ol>
<p class="normal-one">Answer: b</p>
<h1 class="heading-1" id="_idParaDest-46">Join our book’s Discord space</h1>
<p class="normal">Join the book’s Discord workspace for a monthly <em class="italic">Ask Me Anything</em> session with the authors:</p>
<p class="normal"><a href="https://packt.link/K8EntGuide"><span class="url">https://packt.link/K8EntGuide</span></a></p>
<p class="normal"><img alt="" height="176" src="../Images/QR_Code965214276169525265.png" width="176"/></p>
</div>
</div></body></html>