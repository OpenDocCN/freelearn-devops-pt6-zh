<html><head></head><body>
		<div id="_idContainer104">
			<h1 id="_idParaDest-190" class="chapter-number"><a id="_idTextAnchor193"/>13</h1>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor194"/>Using IAM for Granting  Access to Applications</h1>
			<p>AWS has over 200 services available, from SQL/NoSQL databases to machine learning and quantum computing. It’s likely that at some point you will want to use one of these services from within your application deployed <span class="No-Break">on EKS.</span></p>
			<p>This chapter looks at how you can grant IAM permissions to Pods, how you use the associated credentials in your application to connect to an AWS service, and how to troubleshoot issues with the overall process. Specifically, we will cover <span class="No-Break">the following:</span></p>
			<ul>
				<li>Understanding what <strong class="bold">IAM Roles for Service Accounts</strong> (<strong class="bold">IRSA</strong>) is and what problems <span class="No-Break">it solves</span></li>
				<li>Using IRSA in <span class="No-Break">your application</span></li>
				<li>How to troubleshoot IAM issues <span class="No-Break">on EKS</span></li>
			</ul>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor195"/>Technical requirements</h1>
			<p>The reader should be familiar with YAML, AWS IAM, and EKS architecture. Before getting started with this chapter, please ensure <span class="No-Break">the following:</span></p>
			<ul>
				<li>You have network connectivity to your EKS cluster <span class="No-Break">API endpoint</span></li>
				<li>The AWS CLI, Docker, and the <strong class="source-inline">kubectl</strong> binaries are installed on <span class="No-Break">your workstation</span></li>
				<li>You have a basic understanding of <span class="No-Break">AWS IAM</span></li>
			</ul>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor196"/>Understanding IRSA</h1>
			<p>Firstly, let’s look at how IAM role<a id="_idIndexMarker633"/> assignment works for standard EC2 instances. In AWS IAM, roles are used to allocate permissions (using one or more policies). A role can be assigned to an EC2 instance using an instance profile, which is simply a container for the IAM role that’s attached to a specific <span class="No-Break">EC2 instance.</span></p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B18129_13_01.jpg" alt="Figure 13.1 – EC2 role assignment"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – EC2 role assignment</p>
			<p>When an EC2 instance<a id="_idIndexMarker634"/> is created and assigned a role, the AWS platform will automatically create an instance profile. When that instance<a id="_idIndexMarker635"/> boots up, it will make a network call to the <strong class="bold">instance metadata service</strong> (<strong class="bold">IMDS</strong>), which runs in the VPC at the well-known address, <strong class="source-inline">169.254.169.254</strong>, and query what (if any) instance profile (or role) is assigned to that instance. If one has been assigned, it can retrieve the access credentials, an example of which is shown next. These credentials consist of the access and secret keys, which are used for all AWS API calls and identify the role and therefore the permissions granted to <span class="No-Break">the role:</span></p>
			<pre class="source-code">
{ "Code" : "Success",
  "LastUpdated" : "2022-04-26T16:39:16Z",
  "Type" : "AWS-HMAC",
  <strong class="bold">"AccessKeyId"</strong> : "ASIAIOSFODNN7EXAMPLE",
  <strong class="bold">"SecretAccessKey"</strong> : "bPxRfiCYEXAMPLEKEY",
  "Token" : "token",
  "Expiration" : "2022-05-17T15:09:54Z"}</pre>
			<p>If you log in to an EC2 instance, you can review the instance profile attached to a running instance using the <strong class="source-inline">aws sts</strong> command, which is <span class="No-Break">shown next:</span></p>
			<pre class="console">
$ aws sts get-caller-identity
{
 "UserId": "hdghd78898:i-014",
 "Account": "11223344,
 "Arn": "arn:aws:sts::11223344:assumed-role/&lt;IPROFILE&gt;/i-014"
}</pre>
			<p>AWS introduced IMDSv2 to provide<a id="_idIndexMarker636"/> some security controls on container platforms, so let’s review the <span class="No-Break">main changes.</span></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor197"/>Introducing IMDSv2</h2>
			<p>As we have discussed, the instance profile<a id="_idIndexMarker637"/> information is retrieved through the EC2 IMDS, which runs at address <strong class="source-inline">169.254.169.254</strong> in every VPC. This service is critical to the operation of EC2 instances and should not be blocked for the worker nodes, but it should be restricted for Pods. The original IMDS version, version 1, doesn’t allow any restrictions to be placed on who can <span class="No-Break">use it.</span></p>
			<p>IMDSv2 is an enhancement to IMDSv1 that uses session-oriented requests to add security controls to the service. IMDSv2 returns a token, which is used to make requests for metadata and credentials. As the token is never stored in IMDSv2, when the process or application using the token ends, the token is lost. The metadata service uses the TTL hop count in the IPv4/IPv6 packet to allow requests. By default, it is set to 1, which means requests can only come directly from the EC2. Any Pods running on the host will increment the hop count to 2 (as they use the bridge network inside the hots), which prevents them from using the IMDSv2 service directly and retrieving host instance <span class="No-Break">profile credentials.</span></p>
			<p>To force the use of IMDSv2 and restrict the hop count, you can run the following command<a id="_idIndexMarker638"/> on all the worker nodes or add the configuration into your <strong class="bold">infrastructure-as-code</strong> (<strong class="bold">IaC</strong>) definition for the launch template used for the <span class="No-Break">worker nodes:</span></p>
			<pre class="console">
$ aws ec2 modify-instance-metadata-options --instance-id i-1122233 --http-tokens required --http-put-response-hop-limit 1
{
    "InstanceId": "i-112233",
    "InstanceMetadataOptions": {
        "State": "pending",
        "HttpEndpoint": "enabled",
        "HttpTokens": "required",
        "HttpPutResponseHopLimit": 1
    }
}</pre>
			<p>This only works, however, if the Pod uses IMDSv2. In most cases, the Pod uses the AWS SDK to make AWS API calls, which defaults to IMDSv2 to retrieve the credentials. These will have the hop limit applied. However, if the Pod uses IMDSv1, it can still retrieve the host credentials. In this case, the best practice is only to give the worker nodes minimal permissions (to pull ECR containers, for example) or limit access to IMDSv1 using Calico network policies or <span class="No-Break"><strong class="source-inline">iptables</strong></span><span class="No-Break"> rules.</span></p>
			<p>Now, we’ve looked<a id="_idIndexMarker639"/> at the underlying mechanism of how instances and Pods can use IMDS to retrieve credentials assigned to a host (and how we can restrict them from doing so). Let’s look at how we can assign specific roles directly to Pods <span class="No-Break">using IRSA.</span></p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor198"/>How IRSA works</h2>
			<p>IRSA allows you to assign<a id="_idIndexMarker640"/> specific privileges <a id="_idIndexMarker641"/>to a specific Pod by associating a Kubernetes <strong class="bold">service account</strong> (<strong class="bold">SA</strong>) with an IAM role, shown in <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.2</em> as step <strong class="bold">1</strong>. When the Pod makes an API call, it will try to use the SA credentials, which have an annotation mapping to an IAM role (step <strong class="bold">2</strong>). This call is translated into an <strong class="source-inline">AssumeRoleWithWebIdentity</strong> API call to the AWS <strong class="bold">Security Token Service</strong> (<strong class="bold">STS</strong>), which will exchange the Kubernetes-generated<a id="_idIndexMarker642"/> credentials for AWS IAM-generated credentials. It does this by using the OIDC provider for a specific EKS cluster as the principal and assuming the role that is defined in the SA annotation (<span class="No-Break">step </span><span class="No-Break"><strong class="bold">3</strong></span><span class="No-Break">).</span></p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B18129_13_02.jpg" alt="Figure 13.2 – How IRSA works"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – How IRSA works</p>
			<p>Now we understand<a id="_idIndexMarker643"/> at a high level how IRSA will work, let’s look at what we need to configure so that a Pod can <span class="No-Break">use IRSA.</span></p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor199"/>Using IRSA in your application</h1>
			<p>Now that you understand<a id="_idIndexMarker644"/> the basic concepts<a id="_idIndexMarker645"/> behind IRSA, let’s look at how you can configure and use it in your applications. We will look at how to deploy a Pod manually and configure it to use IRSA and then we will look at how you can really simplify the process <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">eksctl</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor200"/>How to deploy a Pod and use IRSA credentials</h2>
			<p>The first step is to make<a id="_idIndexMarker646"/> sure you have<a id="_idIndexMarker647"/> an OIDC provider configured for your cluster. If you used <strong class="source-inline">eksctl</strong>, this will be <span class="No-Break">configured already:</span></p>
			<pre class="console">
$ aws eks describe-cluster --name myipv4cluster --query "cluster.identity.oidc.issuer" --output text
https://oidc.eks.eu-central-1.amazonaws.com/id/763683678</pre>
			<p>If you haven’t enabled it, you can use the following <span class="No-Break"><strong class="source-inline">eksctl</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
$ eksctl utils associate-iam-oidc-provider --cluster cluster_name –approve</pre>
			<p>Now that we have an identity for our cluster that we can use, in IAM, we can create the relevant policies and roles. Let’s assume we want to give our Pod access to all S3 buckets and objects in the account. So, we will use the following policy to provide <span class="No-Break">S3 access:</span></p>
			<pre class="source-code">
{ "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "s3:GetAccountPublicAccessBlock",
                "s3:GetBucketAcl",
                "s3:GetBucketLocation",
                "s3:GetBucketPolicyStatus",
                "s3:GetBucketPublicAccessBlock",
                "s3:ListAccessPoints",
                "s3:ListAllMyBuckets"
            ],
            "Resource": "*"
        }
    ]
}</pre>
			<p>We will then create the policy<a id="_idIndexMarker648"/> in our AWS account using the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker649"/></span><span class="No-Break"> command:</span></p>
			<pre class="console">
$ aws iam create-policy --policy-name bespoke-pod-policy --policy-document file://s3-policy.json
{
    "Policy": {
        "PolicyName": "bespoke-pod-policy",
        "PermissionsBoundaryUsageCount": 0,
        "CreateDate": "2022-11-09T15:03:58Z",
        "AttachmentCount": 0,
        "IsAttachable": true,
        "PolicyId": "ANPARDV7UN626ZCPMFH4X",
        "DefaultVersionId": "v1",
        "Path": "/",
        "Arn": "arn:aws:iam::112233444:policy/bespoke-pod-policy",
        "UpdateDate": "2022-11-09T15:03:58Z"
    }
}</pre>
			<p>Now, we have the policy we need to create the role and allow the EKS cluster OIDC provider and Kubernetes SA combination to assume that role. The following commands will allow you to do this. Let’s initially set up some environment variables for the AWS account, the EKS OIDC provider, the Kubernetes namespace, <span class="No-Break">and SA:</span></p>
			<pre class="console">
$ export account_id=$(aws sts get-caller-identity --query "Account" --output text)
$ export oidc_provider=$(aws eks describe-cluster --name myipv4cluster --region eu-central-1 --query "cluster.identity.oidc.issuer" --output text | sed -e "s/^https:\/\///")
$ export namespace=default
$ export service_account=s3-access</pre>
			<p>We can now create<a id="_idIndexMarker650"/> the trust relationship<a id="_idIndexMarker651"/> for the role that the Pod will assume using the <span class="No-Break">following command:</span></p>
			<pre class="console">
cat &gt;trust-relationship.json &lt;&lt;EOF
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Federated": "arn:aws:iam::$account_id:oidc-provider/$oidc_provider"
      },
      "Action": "sts:AssumeRoleWithWebIdentity",
      "Condition": {
        "StringEquals": {
          "$oidc_provider:aud": "sts.amazonaws.com",
          "$oidc_provider:sub": "system:serviceaccount:$namespace:$service_account"
        }
      }
    }
  ]
}
EOF</pre>
			<p>All this is doing is defining<a id="_idIndexMarker652"/> the mapping for the EKS OIDC provider and Kubernetes namespace<a id="_idIndexMarker653"/> and SA, so we need to create the role with this trust relationship and attach the policy we created previously to allow S3 access using the <span class="No-Break">following commands:</span></p>
			<pre class="console">
$ aws iam create-role --role-name s3-access-default --assume-role-policy-document file://trust-relationship.json --description "s3 access role for pod SA s3-access/default"
{
    "Role": {
        ………
        "Arn": "arn:aws:iam::11223344:role/s3-access-default"
    }
}
$ aws iam attach-role-policy --role-name s3-access-default --policy-arn=arn:aws:iam::$account_id:policy/bespoke-pod-policy</pre>
			<p>We have now set up everything that’s needed in the AWS IAM, so now we just need to configure a Pod to use the SA in the namespace defined here. Let’s start by configuring the SA in the <span class="No-Break"><strong class="source-inline">default</strong></span><span class="No-Break"> namespace:</span></p>
			<pre class="console">
$ cat &gt;my-service-account.yaml &lt;&lt;EOF
apiVersion: v1
kind: ServiceAccount
metadata:
  name: s3-access
  namespace: default
EOF
$ kubectl apply -f my-service-account.yaml
$ kubectl annotate serviceaccount -n $namespace $service_account eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/s3-access-default
serviceaccount/s3-access annotated
$ kubectl describe sa $service_account
Name:                s3-access
Namespace:           default
Labels:              &lt;none&gt;
Annotations:         eks.amazonaws.com/role-arn: arn:aws:iam::11223344:role/s3-access-default
Image pull secrets:  &lt;none&gt;
Mountable secrets:   s3-access-token-9z6
Tokens:              s3-access-token-9z6
Events:              &lt;none&gt;</pre>
			<p>We can now run a Pod<a id="_idIndexMarker654"/> using the SA with the following commands. This will use the <strong class="source-inline">aws-cli</strong> image<a id="_idIndexMarker655"/> and run the <strong class="source-inline">aws s3 ls</strong> command, which should be able to list the buckets, as the assigned SA has the necessary permissions exposed through <span class="No-Break">the role:</span></p>
			<pre class="console">
$ kubectl run –rm -ti cli  --image=amazon/aws-cli –overrides="{ 'spec': { 'serviceAccount': 's3-access' }  }" s3 ls
2022-09-29 09:26:05 ingress-123-bb
2022-03-29 17:49:50 servicecatalog456643
……..</pre>
			<p>If you change the <strong class="source-inline">serviceAccount</strong> value to <strong class="source-inline">default</strong>, you will see the command fail, as the default SA<a id="_idIndexMarker656"/> has no annotation and therefore no mapping to a valid IAM<a id="_idIndexMarker657"/> role. Now, let’s look at how we can make this process easier <span class="No-Break">using IaC.</span></p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor201"/>How to create an IRSA role programmatically</h2>
			<p>We have<a id="_idIndexMarker658"/> used the <strong class="source-inline">eksctl create iamserviceaccount</strong> command from the previous chapter to allow the Pods hosting the storage controllers to communicate with the AWS <span class="No-Break">storage APIs.</span></p>
			<p>If we look at the generic command, we can see we have associated a Kubernetes SA in a specific namespace with a specific IAM policy. The policy defines what API action can be performed and the association of an SA to a Pod allows that Pod to perform <span class="No-Break">that action:</span></p>
			<pre class="console">
$ eksctl create iamserviceaccount --cluster=&lt;clusterName&gt; --name=&lt;serviceAccountName&gt; --namespace=&lt;serviceAccountNamespace&gt; --attach-policy-arn=&lt;policyARN&gt;</pre>
			<p>So, in comparison to the previous section, the only thing we need to pre-provision is the policy with the relevant permissions, so we can provide <strong class="source-inline">policyARN</strong>. The <strong class="source-inline">eksctl</strong> tool will do <span class="No-Break">the following:</span></p>
			<ol>
				<li>Determine the EKS cluster <span class="No-Break">OIDC provider.</span></li>
				<li>Create the role with a trust policy using the derived OIDC details and the Kubernetes SA name and <span class="No-Break">namespace provided.</span></li>
				<li>Attach the pre-created policy to the <span class="No-Break">IAM role.</span></li>
				<li>Create the Kubernetes SA with the right annotations in the <span class="No-Break">right namespace.</span></li>
			</ol>
			<p>You can now run the <strong class="source-inline">kubectl run</strong> command we used previously in the namespace and then use the SA specified in the <strong class="source-inline">eksctl</strong> command, and it should all work. Let’s look at how we can troubleshoot IRSA if there are <span class="No-Break">any issues.</span></p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor202"/>How to troubleshoot IAM issues on EKS</h1>
			<p>The first thing you need<a id="_idIndexMarker659"/> to do is determine whether this is an IAM<a id="_idIndexMarker660"/> permissions issue. If we look at the error message in the following example, we can see a very clear <strong class="source-inline">AccessDenied</strong> error message for an AWS API operation – in this case, the <strong class="source-inline">ListBuckets</strong> operations. This is a clear indicator that it’s an <span class="No-Break">IAM error:</span></p>
			<pre class="console">
$ kubectl run -ti cli  --image=amazon/aws-cli --overrides='{ "spec": { "serviceAccount": "default" }  }' s3 ls
If you don't see a command prompt, try pressing enter.
An error occurred (AccessDenied) when calling the ListBuckets operation: Access Denied</pre>
			<p>The first step is to determine which SA is being used and work backward from there. In the example, it’s pretty clear, as we have the <strong class="source-inline">run</strong> command. However, assuming we don’t have it, we can use the next command to figure <span class="No-Break">it out:</span></p>
			<pre class="console">
$ kubectl get po cli -o yaml | grep serviceAccountName
  serviceAccountName: default</pre>
			<p>We can then run the following command to make sure the annotation is in place and identify what role will <span class="No-Break">be assumed:</span></p>
			<pre class="console">
$ kubectl describe sa default
Name:                default
Namespace:           default
Labels:              &lt;none&gt;
Annotations:         &lt;none&gt;
Image pull secrets:  &lt;none&gt;
Mountable secrets:   default-token-wjpnc
Tokens:              default-token-wjpnc
Events:              &lt;none&gt;</pre>
			<p>In this case, there is no annotation, so it’s clear this SA has no permissions. If there was a role assigned, we could use the following commands to determine whether it was a policy or <span class="No-Break">permissions issue:</span></p>
			<pre class="console">
$ kubectl describe sa default
…..
Annotations:         eks.amazonaws.com/role-arn: arn:aws:iam::11223344:role/s3-access-default
…..
$ aws iam list-attached-role-policies --role-name s3-access-default
{
    "AttachedPolicies": [
        {
            "PolicyName": "bespoke-pod-policy",
            "PolicyArn": "arn:aws:iam::11223344:policy/bespoke-pod-policy"
        }
    ]
}</pre>
			<p>Once we can see<a id="_idIndexMarker661"/> the attached policy, in this case, just one, we<a id="_idIndexMarker662"/> can then iterate over it, but first, you must get the version of the policy using the <span class="No-Break"><strong class="source-inline">get-policy</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
$ aws iam get-policy --policy-arn arn:aws:iam::076637564853:policy/bespoke-pod-policy{
    "Policy": {
        "PolicyName": "bespoke-pod-policy",
        "Tags": [],
        "PermissionsBoundaryUsageCount": 0,
        "CreateDate": "2022-11-09T15:03:58Z",
        "AttachmentCount": 1,
        "IsAttachable": true,
        "PolicyId": "ANPARDV7UN626ZCPMFH4X",
        "DefaultVersionId": "<strong class="bold">v1</strong>",
        "Path": "/",
        "Arn": "arn:aws:iam::076637564853:policy/bespoke-pod-policy",
        "UpdateDate": "2022-11-09T15:03:58Z"
    }
}</pre>
			<p>We can now extract<a id="_idIndexMarker663"/> the permissions using the <strong class="source-inline">get-policy-version</strong> command. In the following<a id="_idIndexMarker664"/> example, the <strong class="source-inline">s3:ListAllMyBuckets</strong> operation is missing, which is causing <span class="No-Break">the problem:</span></p>
			<pre class="console">
$ aws iam get-policy-version    --policy-arn arn:aws:iam::076637564853:policy/bespoke-pod-policy   --version-id v1
{
    "PolicyVersion": {
        "CreateDate": "2022-11-09T15:03:58Z",
        "VersionId": "v1",
        "Document": {
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Action": [
                        "s3:GetAccountPublicAccessBlock",
                        "s3:GetBucketAcl",
                        "s3:GetBucketLocation",
                        "s3:GetBucketPolicyStatus",
                        "s3:GetBucketPublicAccessBlock",
                        "s3:ListAccessPoints"
                    ],
                    "Resource": "*",
                    "Effect": "Allow"
                }
            ]
        },
        "IsDefaultVersion": true
    }
}</pre>
			<p>There are a couple of other areas you <span class="No-Break">can consider:</span></p>
			<ul>
				<li>You can find out whether the assigned role trusts the right EKS OIDC provider using the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ aws iam get-role --role-name</strong></pre></li>
				<li>IRSA leverages a mutating webhook for Pod identity. You can validate that this has been deployed using the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ kubectl get mutatingwebhookconfiguration pod-identity-webhook  -o yaml</strong></pre></li>
			</ul>
			<p>Some other errors are covered in the <em class="italic">Further reading</em> section. In this section, we have looked at what IRSA is, how it works<a id="_idIndexMarker665"/> and is configured, and how you can do<a id="_idIndexMarker666"/> some basic IRSA troubleshooting. We’ll now revisit the key learning points from <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor203"/>Summary</h1>
			<p>In this chapter, we explored how AWS API permissions can be assigned to EC2 instances (worker nodes) and Pods using instance profiles and IMDS. We also noted that by default, EKS Pods inherit the permissions assigned to the worker nodes they run on, and how this may not be a good thing, as we are not observing a <em class="italic">least-privilege</em> model since many Pods may not need any AWS <span class="No-Break">API access.</span></p>
			<p>We discussed how IMDSv2 can be used to reduce the use of worker permission and should be used with IRSA to limit the worker node permission inheritance. We then worked through how to configure and use IRSA from the command line and how IaC tools such as <strong class="source-inline">eksctl</strong> can simplify the process significantly. Finally, we looked at how to do some basic troubleshooting of AWS IAM permission issues, working backward from the <span class="No-Break">Kubernetes SA.</span></p>
			<p>In the next chapter, we will look at how we can use AWS load balancers to make our Kubernetes services more resilient <span class="No-Break">and scalable.</span></p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor204"/>Further reading</h1>
			<ul>
				<li>Understanding the EC2 metadata <span class="No-Break">service: </span><a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html&#13;"><span class="No-Break">https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html</span></a></li>
				<li>EKS updates to support <span class="No-Break">IMDSv2: </span><a href="https://aws.amazon.com/about-aws/whats-new/2020/08/amazon-eks-supports-ec2-instance-metadata-service-v2/&#13;"><span class="No-Break">https://aws.amazon.com/about-aws/whats-new/2020/08/amazon-eks-supports-ec2-instance-metadata-service-v2/</span></a></li>
				<li>Troubleshooting IRSA <span class="No-Break">errors: </span><a href="https://aws.amazon.com/premiumsupport/knowledge-center/eks-troubleshoot-IRSA-errors/"><span class="No-Break">https://aws.amazon.com/premiumsupport/knowledge-center/eks-troubleshoot-IRSA-errors/</span></a></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer105" class="IMG---Figure">
			</div>
		</div>
	</body></html>