- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Utilizing Service Meshes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at monitoring and observability. One of the
    obstacles to a comprehensive monitoring story is that it requires a lot of changes
    to the code that are orthogonal to the business logic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how service meshes allow you to externalize
    many of those cross-cutting concerns from the application code. The service mesh
    is a true paradigm shift in the way you design, evolve, and operate distributed
    systems on Kubernetes. I like to think of it as aspect-oriented programming for
    cloud-native distributed systems. We will also take a deeper look into the Istio
    service mesh. The topics we will cover are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: What is a service mesh?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a service mesh
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Istio architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporating Istio into your Kubernetes cluster
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Istio
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s jump right in.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: What is a service mesh?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service mesh is an architectural pattern for large-scale cloud-native applications
    that are composed of many microservices. When your application is structured as
    a collection of microservices, there is a lot going on in the boundary between
    microservices inside your Kubernetes cluster. This is different from traditional
    monolithic applications where most of the work is done by a single OS process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some concerns that are relevant to each microservice or interaction
    between microservices:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Advanced load balancing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for canary deployments
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracing a request across multiple microservices
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication between services
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throttling the number of requests a service handles at a given time
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically retrying failed requests
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failing over to an alternative component when a component fails consistently
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting metrics
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these concerns are completely orthogonal to the domain logic of the service,
    but they are all very important. A naive approach is to simply code all these
    concerns directly in each microservice. This obviously doesn’t scale. So, a typical
    approach is to package all this functionality in a big library or set of libraries
    and use these libraries in each service.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_14_01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: A typical library-based architecture'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several problems with the big library approach:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: You need to implement the library in all the programming languages you use and
    make sure they are compatible
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to update your library, you must bump the version of all your services
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s difficult to upgrade services incrementally if a new version of the library
    is not backward-compatible
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In comparison, the service mesh doesn’t touch your application. It injects a
    sidecar proxy container into each pod and uses a service mesh controller. The
    proxies intercept all communication between the pods and, in collaboration with
    the mesh controller, can take care of all the cross-cutting concerns.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_14_02.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: Sidecar service mesh architecture'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some attributes of the proxy injection approach:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The application is unaware of the service mesh
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can turn the mesh on or off per pod and update the mesh independently
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need to deploy an agent on each node
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different pods on the same node can have different sidecars (or versions)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each pod has its own copy of the proxy
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On Kubernetes, it looks like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_14_03.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: Service mesh architecture in Kubernetes'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: There is another way to implement the service mesh proxy as a node agent, where
    it is not injected into each pod. This approach is less common, but in some cases
    (especially in non-Kubernetes environments), it is useful. It can save resources
    on nodes that run a lot of small pods where the overhead of all the sidecar containers
    adds up.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_14_04.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: Node agent service mesh architecture'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: In the service mesh world, there is a control plane, which is typically a set
    of controllers on Kubernetes, and there is a data plane, which is made up of the
    proxies that connect all the services in the mesh. The data plane consists of
    all the sidecar containers (or node agents) that intercept the communication between
    services in the mesh. The control plane is responsible for managing the proxies
    and configuring what actually happens when any traffic between services or a service
    and the outside world is intercepted.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Now, that we have a good idea of what a service mesh is, how it works, and why
    it is so useful, let’s review some of the service meshes out there.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a service mesh
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The service mesh concept is relatively new, but there are already many choices
    out there. We will be using Istio later in the chapter. However, you may prefer
    a different service mesh for your use case. Here is a concise review of the current
    cohort of service meshes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Envoy
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Envoy ([https://www.envoyproxy.io](https://www.envoyproxy.io)) is yet another
    CNCF graduated project. It is a very versatile and high-performance L7 proxy.
    It provides many service mesh capabilities; however, it is considered pretty low-level
    and difficult to configure. It is also not Kubernetes-specific. Some of the Kubernetes
    service meshes use Envoy as the underlying data plane and provide a Kubernetes-native
    control plane to configure and interact with it. If you want to use Envoy directly
    on Kubernetes, then the recommendation is to use other open source projects like
    Ambassador and Gloo as an ingress controller and/or API gateway.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd 2
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linkerd 2 ([https://linkerd.io](https://linkerd.io)) is a Kubernetes-specific
    service as well as a CNCF incubating project. It is developed by Buoyant ([https://buoyant.io](https://buoyant.io)).
    Buoyant coined the term service mesh and introduced it to the world a few years
    ago. They started with a Scala-based service mesh for multiple platforms including
    Kubernetes called Linkerd. But they decided to develop a better and more performant
    service mesh targeting Kubernetes only. That’s where Linkerd 2 comes in, which
    is Kubernetes-specific. They implemented the data plane (proxy layer) in Rust
    and the control plane in Go.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Kuma
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kuma ([https://kuma.io/](https://kuma.io/)) is an open source service mesh powered
    by Envoy. It was originally developed by Kong, which offers an enterprise product
    called Kong Mesh on top of Kuma. It works on Kubernetes as well as other environments.
    Its claims to fame is that it is super easy to configure and that it allows mixing
    Kubernetes and VM-based systems in a single mesh.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: AWS App Mesh
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AWS, of course, has its own proprietary service mesh – AWS App Mesh ([https://aws.amazon.com/app-mesh](https://aws.amazon.com/app-mesh)).
    App Mesh also uses Envoy as its data plane. It can run on EC2, Fargate, ECS and
    EKS, and plain Kubernetes. App Mesh is a bit late to the service mesh scene, so
    it’s not as mature as some other service meshes, but it is catching up. It is
    based on solid Envoy, and may be the best choice due to its tight integration
    with AWS services.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Mæsh
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mæsh ([https://mae.sh](https://mae.sh)) is developed by the makers of Træfik
    ([https://containo.us/traefik](https://containo.us/traefik)). It is interesting
    because it uses the node agent approach as opposed to sidecar containers. It is
    based heavily on Traefik middleware to implement the service mesh functionality.
    You can configure it by using annotations on your services. It may be an interesting
    and lightweight approach to try service meshes if you utilize Traefik at the edge
    of your cluster.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Istio
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Istio ([https://istio.io/](https://istio.io/)) is the most well-known service
    mesh on Kubernetes. It is built on top of Envoy and allows you to configure it
    in a Kubernetes-native way via YAML manifests. Istio was started by Google, IBM,
    and Lyft (the Envoy developers). It’s a one-click install on Google GKE, but it
    is widely used in the Kubernetes community in any environment. It is also the
    default ingress/API gateway solution for Knative, which promotes its adoption
    even further.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: OSM (Open Service Mesh)
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OSM ([https://openservicemesh.io](https://openservicemesh.io)) is yet another
    service mesh based on Envoy. It is configurable via **SMI** (**Service Mesh Interface**),
    which is a spec that attempts to provide a provider-agnostic set of APIs to configure
    service meshes. See [https://smi-spec.io](https://smi-spec.io) for more details.
    Both OSM and SMI are CNCF sandbox projects.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: OSM was developed by Microsoft and contributed to CNCF.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Cilium Service Mesh
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cilium Service Mesh ([https://isovalent.com/blog/post/cilium-service-mesh](https://isovalent.com/blog/post/cilium-service-mesh))
    is a newcomer to the service mesh arena. It is developed by Isovalent ([https://isovalent.com](https://isovalent.com)).
    It is notable for attempting to bring the benefits of eBPF to the service mesh
    and utilize a sidecar-free approach. It is still early days, and Cilium Service
    Mesh is not as mature as other service meshes. However, it has the interesting
    concept of allowing you to bring your own control plane. It can integrate with
    Istio and interoperate with sidecars as well. It’s worth keeping an eye on.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: After discussing the various service mesh choices, let’s take Istio for a ride.
    The reason we picked Istio is that it is one of the most mature service meshes,
    with a large community, a lot of users, and the backing of industry leaders.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Istio architecture
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will get to know Istio a little better.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s meet the main components of Istio and understand what they do and
    how they relate.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Istio is a large framework that provides a lot of capabilities, and it has multiple
    parts that interact with each other and with Kubernetes components (mostly indirectly
    and unobtrusively). It is divided into a control plane and a data plane. The data
    plane is a set of proxies (one per pod). Their control plane is a set of components
    that are responsible for configuring the proxies and collecting telemetry data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram illustrates the different parts of Istio, how they are
    related to each other, and what information is exchanged between them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_14_05.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: Istio architecture'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there are two primary components: the Envoy proxy, which is
    the sidecar container attached to every service instance (every pod), and istiod,
    which is responsible for discovery, configuration, and certificates. Istiod is
    a single binary that actually contains multiple components: Pilot, Citadel, and
    Galley. These components used to run as separate binaries. They were combined
    into a single binary in Istio 1.5 to simplify the experience of installing, running,
    and upgrading Istio.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go a little deeper into each component, starting with the Envoy proxy.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Envoy
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We discussed Envoy briefly when we reviewed service meshes for Kubernetes. Here,
    it serves as the data plane of Istio. Envoy is implemented in C++ and is a high-performance
    proxy. For each pod in the service mesh, Istio injects (either automatically or
    through the istioctl CLI) an Envoy side container that does the heavy lifting.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the tasks Envoy performs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Proxy HTTP, HTTP/2, and gRPC traffic between pods
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sophisticated load balancing
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mTLS termination
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP/2 and gRPC proxies
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing service health
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaking for unhealthy services
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Percentage-based traffic shaping
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting faults for testing
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailed metrics
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Envoy proxy controls all the incoming and outgoing communication to its
    pod. It is, by far, the most important component of Istio. The configuration of
    Envoy is not trivial, and this is a large part of what the Istio control plane
    deals with.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The next component is Pilot.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Pilot
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pilot is responsible for platform-agnostic service discovery, dynamic load balancing,
    and routing. It translates high-level routing rules into an Envoy configuration.
    This abstraction layer allows Istio to run on multiple orchestration platforms.
    Pilot takes all the platform-specific information, converts it into the Envoy
    data plane configuration format, and propagates it to each Envoy proxy with the
    Envoy data plane API. Pilot is stateless; in Kubernetes, all the configuration
    is stored as **custom resource definitions** (**CRDs**) in etcd.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The next component is Citadel.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Citadel
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Citadel is responsible for certificate and key management. It is a key part
    of Istio security. Citadel integrates with various platforms and aligns with their
    identity mechanisms. For example, in Kubernetes, it uses service accounts; on
    AWS, it uses AWS IAM; on Azure, it uses AAD, and on GCP/GKE, it can use GCP IAM.
    The Istio PKI is based on Citadel. It uses X.509 certificates in SPIFEE format
    as a vehicle for service identity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the workflow for a strong identity to envoy proxies in Kubernetes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Citadel creates certificates and key pairs for existing service accounts.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Citadel watches the Kubernetes API server for new service accounts to provision
    with a certificate and a key pair.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Citadel stores the certificates and keys as Kubernetes secrets.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes mounts the secrets into each new pod that is associated with the
    service account (this is standard Kubernetes practice).
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Citadel automatically rotates the Kubernetes secrets when the certificates expire.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pilot generates secure naming information that associates a service account
    with an Istio service. Pilot then passes the secure naming information to the
    Envoy proxy.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final major component that we will cover is Galley.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Galley
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Galley is responsible for abstracting the user configuration on different platforms.
    It provides the ingested configuration to Pilot. It is a pretty simple component.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have broken down Istio into its major components, let’s get hands-on
    with Istio and incorporate it into a Kubernetes cluster.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating Istio into your Kubernetes cluster
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will install Istio in a fresh cluster and explore all the
    service goodness it provides.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a minikube cluster for Istio
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use a minikube cluster for checking out Istio. Before installing Istio,
    we should make sure our cluster has enough capacity to handle Istio as well as
    its demo application, BookInfo. We will start minikube with 16 GB of memory and
    four CPUs, which should be adequate. Make sure the Docker VM you’re using (e.g.,
    Rancher Desktop) has sufficient CPU and memory:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Minikube can provide a load balancer for Istio. Let’s run this command in a
    separate terminal as it will block (do not stop the tunnel until you are done):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube可以为Istio提供负载均衡器。让我们在一个单独的终端中运行这个命令，因为它会阻塞（在完成之前不要停止隧道）：
- en: '[PRE1]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Minikube sometimes doesn’t clean up the tunnel network, so it’s recommended
    to run the following command after you stop the cluster:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时Minikube没有清理隧道网络，所以在停止集群后，建议运行以下命令：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing Istio
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Istio
- en: 'With minikube up and running, we can install Istio itself. There are multiple
    ways to install Istio:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Minikube启动并运行后，我们可以安装Istio本身。有多种方式可以安装Istio：
- en: Customized installation with istioctl (the Istio CLI)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用istioctl（Istio CLI）进行自定义安装
- en: Customized installation with Helm using the Istio operator (supported, but discouraged)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Istio运维器通过Helm进行自定义安装（支持，但不推荐）
- en: Multi-cluster installation
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多集群安装
- en: External control plane
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部控制平面
- en: Virtual machine installation
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机安装
- en: 'We will go with the recommended istioctl option. The Istio version may be higher
    than 1.15:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择推荐的istioctl选项。Istio版本可能高于1.15：
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The istioctl tool is located in `istio-1.15.2/bin` (the version may be different
    when you download it). Make sure it’s in your path. The Kubernetes installation
    manifests are in `istio-1.15.2/install/kubernetes` and the examples are in `istio-1.15.2/samples`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: istioctl工具位于`istio-1.15.2/bin`（下载时版本可能不同）。确保它在你的路径中。Kubernetes安装清单位于`istio-1.15.2/install/kubernetes`，示例位于`istio-1.15.2/samples`。
- en: 'Let’s run some preinstall checks:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先运行一些安装前的检查：
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will install the built-in demo profile, which is great for evaluating Istio:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装内置的demo配置文件，这对于评估Istio非常有用：
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s also install some observability add-ons such as `prometheus`, `grafana`,
    `jaeger`, and `kiali`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还安装一些可观察性插件，如`prometheus`、`grafana`、`jaeger`和`kiali`：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s review our cluster and see what is actually installed. Istio installs
    itself in the `istio-system` namespace, which is very convenient since it installs
    a lot of stuff. Let’s check out what services Istio installed:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下集群，看看实际安装了哪些内容。Istio将自己安装在`istio-system`命名空间中，这非常方便，因为它安装了很多内容。让我们看看Istio安装了哪些服务：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are quite a few services with an `istio-` prefix and then a bunch of
    other services:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多以`istio-`为前缀的服务，后面跟着其他一些服务：
- en: Prometheus
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus
- en: Grafana
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grafana
- en: Jaeger
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jaeger
- en: Zipkin
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zipkin
- en: Tracing
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪
- en: Kiali
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kiali
- en: OK. We installed Istio and a variety of integrations successfully. Let’s install
    the BookInfo application, which is Istio’s sample application, in our cluster.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经成功安装了Istio和各种集成。接下来，让我们在集群中安装BookInfo应用程序，这是Istio的示例应用程序。
- en: Installing BookInfo
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装BookInfo
- en: 'BookInfo is a simple microservice-based application that displays, as the name
    suggests, information on a single book such as name, description, ISBN, and even
    reviews. The BookInfo developers really embraced the polyglot lifestyle and each
    microservice is implemented in a different programming language:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: BookInfo是一个简单的基于微服务的应用程序，正如其名字所示，它展示了一本书的基本信息，如名称、描述、ISBN，甚至是评论。BookInfo的开发者真正拥抱了多语言编程的理念，每个微服务都是用不同的编程语言实现的：
- en: ProductPage service in Python
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Python编写的ProductPage服务
- en: Reviews service in Java
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Java编写的Reviews服务
- en: Details service in Ruby
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Ruby编写的Details服务
- en: Ratings service in JavaScript (Node.js)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用JavaScript（Node.js）编写的Ratings服务
- en: 'The following diagram describes the relationships and flow of information between
    the BookInfo services:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了BookInfo服务之间的关系和信息流动：
- en: '![](img/B18998_14_06.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_14_06.png)'
- en: 'Figure 14.6: The flow of information between BookInfo services'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6：BookInfo服务之间信息流动的示意图
- en: 'We’re going to install it in its own `bookinfo` namespace. Let’s create the
    namespace and then enable the Istio auto-injection of the sidecar proxies by adding
    a label to the namespace:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把它安装在自己的`bookinfo`命名空间中。让我们先创建该命名空间，然后通过向命名空间添加标签来启用Istio自动注入边车代理：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Installing the application itself is a simple one-liner:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 安装应用程序本身是一个简单的一行命令：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Alright, the application was deployed successfully, including separate service
    accounts for each service. As you can see, three versions of the reviews service
    were deployed. This will come in handy later when we play with upgrades and advanced
    routing and deployment patterns.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，应用已经成功部署，包括为每个服务创建了单独的服务账户。正如你所看到的，已经部署了三个版本的reviews服务。稍后在我们进行升级、高级路由和部署模式时，这将非常有用。
- en: 'Before going on, we still need to wait for all the pods to initialize and then
    Istio will inject its sidecar proxy container. When the dust settles, you should
    see something like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that under the `READY` column, each pod shows 2/2, which means 2 containers
    per pod. One is the application container and the other is the injected proxy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’re going to operate in the `bookinfo` namespace, let’s define a little
    alias that will make our life simpler:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, armed with our little `kb` alias, we can verify that we can get the product
    page from the ratings service:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But the application is not accessible to the outside world yet. This is where
    the Istio gateway comes in. Let’s deploy it:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s get the URLs to access the application from the outside:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we can try it from the outside:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can also open the URL in your browser and see some information about Shakespeare’s
    “The Comedy of Errors”:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_14_07.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.7: A sample BookInfo review'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Alright. We’re all set to start exploring the capabilities that Istio brings
    to the table.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Working with Istio
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will work with Istio resources and policies and utilize
    them to improve the operation of the BookInfo application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with traffic management.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Traffic management
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Istio traffic management is about routing traffic to your services according
    to the destination rules you define. Istio keeps a service registry for all your
    services and their endpoints. Basic traffic management allows traffic between
    each pair of services and does simple round-robin load balancing between each
    service instance. But Istio can do much more. The traffic management API of Istio
    consists of five resources:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Virtual services
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destination rules
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gateways
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service entries
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sidecars
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start by applying the default destination rules for BookInfo:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, let’s create the Istio virtual services that represent the services in
    the mesh:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We need to wait a little for the virtual service configuration to propagate.
    Let’s then check out the product page virtual service using the neat kubectl plugin.
    If you don’t have it installed already follow the instructions at [https://github.com/itaysk/kubectl-neat](https://github.com/itaysk/kubectl-neat).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is pretty straightforward, specifying the HTTP route and the version. The
    v1 subset is important for the reviews service, which has multiple versions. The
    product page service will hit its v1 version because that is the subset that’s
    configured.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make it a little more interesting and do routing based on the logged-in
    user. Istio itself doesn’t have a concept of user identity, but it routes traffic
    based on headers. The BookInfo application adds an end-user header to all requests.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will update the routing rules:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s check the new rules:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, if the HTTP header `end-user` matches `jason`, then the request
    will be routed to subset 2 of the reviews service, otherwise to subset 1\. Version
    2 of the reviews service adds a star rating to the reviews part of the page. To
    test it, we can sign in as user `jason` (any password will do), refresh the browser,
    and see that the reviews have stars next to them:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_14_08.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: A sample BookInfo review with star ratings'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'There is much more Istio can do in the arena of traffic management:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Fault injection for test purposes
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP and TCP traffic shifting (gradually shifting traffic from one version to
    the next)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request timeouts
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaking
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mirroring
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to internal traffic management, Istio supports configuring ingress
    into the cluster and egress from the cluster including secure options with TLS
    and mutual TLS.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Security
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security is a core fixture of Istio. It provides identity management, authentication
    and authorization, security policies, and encryption. The security support is
    spread across many layers using multiple industry-standard protocols and best-practice
    security principles like defense in depth, security by default, and zero trust.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the big picture of the Istio security architecture:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_14_09.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.9: Istio security architecture'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Istio enables a strong security posture via the following capabilities:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Sidecar and perimeter proxies implement authenticated and authorized communication
    between clients and servers
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control plane manages keys and certificates
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control plane distributes security policies and secure naming information to
    the proxies
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control plane manages auditing
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s break it down piece by piece.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Istio identity
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Istio utilizes secure naming where service names as defined by the service discovery
    mechanism (e.g., DNS) are mapped to server identities based on certificates. The
    clients verify the server identities. The server may be configured to verify the
    client’s identity. All the security policies apply to given identities. The servers
    decide what access a client has based on their identity.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The Istio identity model can utilize existing identity infrastructure on the
    platform it is running on. On Kubernetes, it utilizes Kubernetes service accounts,
    of course.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Istio securely assigns an x.509 certificate to each workload via an agent running
    together with the Envoy proxy. The agent works with istiod to automatically provision
    and rotate certificates and private keys.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Istio certificate management
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is the workflow for provisioning certificates and keys:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: istiod exposes a gRPC service that listens to **certificate signing requests**
    (**CSRs**).
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process begins with the Istio agent which, upon startup, generates a private
    key and a CSR. It then transmits the CSR, along with its own credentials, to the
    CSR service of istiod.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, the istiod **Certificate Authority** (**CA**) examines the agent
    credentials contained within the CSR. If they are deemed valid, the istiod CA
    proceeds to sign the CSR, resulting in the creation of a certificate.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a workload is launched, the Envoy proxy, residing within the same container,
    utilizes the Envoy **SDS** (**Secret Discovery Service**) API to request the certificate
    and corresponding key from the Istio agent.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Istio agent actively monitors the expiration of the workload certificate,
    initiating a periodic process to refresh the certificate and key to ensure they
    remain up to date.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Istio authentication
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The secure identity model underlies the authentication framework of Istio.
    Istio supports two modes of authentication: peer authentication and request authentication.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Peer authentication
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Peer authentication is used for service-to-service authentication. The cool
    thing about it is that Istio provides it with no code changes. It ensures that
    service-to-service communication will take place only between services you configure
    with authentication policies.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an authentication policy for the reviews service, which requires mutual
    TLS:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Request authentication
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Request authentication is used for end-user authentication. Istio will verify
    that the end user making the request is allowed to make that request. This request-level
    authentication utilizes **JWT** (**JSON Web Token**) and supports many OpenID
    Connect backends.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Once the identity of the caller has been established, the authentication framework
    passes it along with other claims to the next link in the chain – the authorization
    framework.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Istio authorization
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Istio can authorize requests at many levels:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Entire mesh
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entire namespace
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workload-level
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the authorization architecture of Istio:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_14_10.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.10: Istio authorization architecture'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Authorization is based on authorization policies. Each policy has a selector
    (what workloads it applies to) and rules (who is allowed to access a resource
    and under what conditions).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: If no policy is defined on a workload, all requests are allowed. However, if
    a policy is defined for a workload, only requests that are allowed by a rule in
    the policy are allowed. You can also define exclusion rules.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an authorization policy that allows two sources (service account `cluster.local/ns/default/sa/sleep`
    and namespace `dev`) to access the workloads with the labels `app: httpbin` and
    `version: v1` in namespace and `foo` when the request is sent with a valid JWT
    token.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The granularity doesn’t have to be at the workload level. We can limit access
    to specific endpoints and methods too. We can specify the operation using prefix
    match, suffix match, or presence match, in addition to exact match. For example,
    the following policy allows access to all paths that start with `/test/` and all
    paths that end in `/info`. The allowed methods are `GET` and `HEAD` only:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we want to get even more fancy, we can specify conditions. For example,
    we can allow only requests with a specific header. Here is a policy that requires
    a version header with a value of v1 or v2:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For TCP services, the `paths` and `methods` fields of the operation don’t apply.
    Istio will simply ignore them. But, we can specify policies for specific ports:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let’s look at one of the areas where Istio provides tremendous value – telemetry.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and observability
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instrumenting your applications for telemetry is a thankless job. The surface
    area is huge. You need to log, collect metrics, and create spans for tracing.
    Comprehensive observability is crucial for troubleshooting and mitigating incidents,
    but it’s far from trivial:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: It takes time and effort to do it in the first place
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes more time and effort to ensure it is consistent across all the services
    in your cluster
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can easily miss an important instrumentation point or configure it incorrectly
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to change your log provider or distributed tracing solution, you
    might need to modify all your services
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It litters your code with lots of stuff that obscures the business logic
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might need to explicitly turn it off for testing
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if all of it was taken care of automatically and never required any code
    changes? That’s the promise of service mesh telemetry. Of course, you may need
    to do some work at the application/service level, especially if you want to capture
    custom metrics or do some specific logging. If your system is divided into coherent
    microservices along boundaries that really represent your domain and workflows,
    then Istio can help you get decent instrumentation right out of the box. The idea
    is that Istio can keep track of what’s going on in the seams between your services.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Istio access logs
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can capture the access logs of Envoy proxies to give a picture of the network
    traffic from the perspective of each workload.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use two new workloads in this section: `sleep` and `httpbin`. Let’s
    deploy them:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In addition, let’s deploy an `OpenTelemetry` collector to the `istio-system`
    namespace:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Istio configures providers and much more in the Istio ConfigMap, which already
    contains a provider entry for the `opentelemetry-collector` service. Let’s use
    `yq` ([https://github.com/mikefarah/yq](https://github.com/mikefarah/yq)) to review
    just the data field of the config map:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To enable logging from the `sleep` workload to the `otel` collector, we need
    to configure a `Telemetry` resource:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The default access log format is:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That’s pretty verbose, but when debugging or troubleshooting, you want as much
    information as possible. The log format is configurable if you want to change
    it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright. Let’s try it out. The `sleep` workload is really just a pod from which
    we can make network requests to the httpbin application. The httpbin service is
    running on port `8000` and is known as simply `httpbin` inside the cluster. We
    will query `httpbin` from the `sleep` pod about the infamous 418 HTTP status ([https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/418](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/418)):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Yay, we got our expected teapot response. Now, let’s check the access logs:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we got a lot of information according to the default access
    log format, including the timestamp, request URL, the response status, the user
    agent, and the IP addresses of the source and destination.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: In a production system, you may want to forward the collector’s logs to a centralized
    logging system. Let’s see what Istio offers for metrics.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Metrics
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Istio collects three types of metrics:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Proxy metrics
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control plane metrics
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service metrics
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collected metrics cover all traffic into, from, and inside the service mesh.
    As operators, we need to configure Istio for metric collection. We installed Prometheus
    and Grafana earlier for metric collection and the visualization backend. Istio
    follows the four golden signals doctrine and records the latency, traffic, errors,
    and saturation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of proxy-level (Envoy) metrics:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And here is an example of service-level metrics:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can also collect metrics for TCP services. Let’s install v2 of the ratings
    service, which uses MongoDB (a TCP service):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we install MongoDB itself:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we need to create virtual services for the reviews and ratings services:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let’s hit our product page to generate traffic:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'At this point, we can expose Prometheus directly:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Or, alternatively, using `istioctl dashboard prometheus`, which will do the
    port-forwarding as well as launching the browser for you at the forwarded URL
    of `http://localhost:9090/`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'We can view the slew of new metrics available from both Istio services, Istio
    control plane and especially Envoy. Here is a very small subset of the available
    metrics:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_14_11.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.11: Available Istio metrics'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: The last pillar of observability is distributed tracing.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Distributed tracing
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Istio configures the Envoy proxies to generate trace spans for their associated
    services. The services themselves are responsible for forwarding the request context.
    Istio can work with multiple tracing backends, such as:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Jaeger
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zipkin
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LightStep
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DataDog
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the request headers that services should propagate (only some may
    be present for each request depending on the tracing backend):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The sampling rate for tracing is controlled by the mesh config. The default
    is 1%. Let’s change it to 100% for demonstration purposes:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s verify the sampling rate was updated to `100`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let’s hit the product page a couple of times:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we can start the Jaeger UI and explore the traces:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Your browser will automatically open and you should see the familiar Jaeger
    dashboard where you can select a service and search for traces:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_14_12.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.12: Jaeger dashboard'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'You can click on a trace to see a detailed view of the flow of the request
    through the system:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_14_13.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.13: Flow of a request through the system'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a dedicated service mesh visualization tool.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing your service mesh with Kiali
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Kiali is an open source project that ties together Prometheus, Grafana, and
    Jaeger to provide an observability console to your Istio service mesh. It can
    answer questions like:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: What microservices participate in the Istio service mesh?
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are these microservices connected?
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are these microservices performing?
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has various views, and it really allows you to slice and dice your service
    mesh by zooming in and out, filtering, and selecting various properties to display.
    It’s got several views that you can switch between.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start it like so:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here is the **Overview** page:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '![Title: Inserting image...](img/B18998_14_14.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.14: Kiali overview page'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: But, the most interesting view is the graph view, which can show your services
    and how they relate to each other and is fully aware of versions and requests
    flowing between different workloads, including the percentage of requests and
    latency. It can show both HTTP and TCP services and really provides a great picture
    of how your service mesh behaves.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_14_15.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.15: Kiali graph view'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: We have covered the monitoring and observability of Istio, including logs, metrics,
    and distributed tracing, and have shown how to use Kiali to visualize your service
    mesh.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we did a very comprehensive study of service meshes on Kubernetes.
    Service meshes are here to stay. They are simply the right way to operate a complex
    distributed system. Separating all operational concerns from the proxies and having
    the service mesh control them is a paradigm shift. Kubernetes, of course, is designed
    primarily for complex distributed systems, so the value of the service mesh becomes
    clear right away. It is also great to see that there are many options for service
    meshes on Kubernetes. While most service meshes are not specific to Kubernetes,
    it is one of the most important deployment platforms. In addition, we did a thorough
    review of Istio – arguably the service mesh with the most momentum – and took
    it through its paces. We demonstrated many of the benefits of service meshes and
    how they integrate with various other systems. You should be able to evaluate
    how useful a service mesh could be for your system and whether you should deploy
    one and start enjoying the benefits.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we look at the myriad ways that we can extend Kubernetes
    and take advantage of its modular and flexible design. This is one of the hallmarks
    of Kubernetes and why it was adopted so quickly by so many communities.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
