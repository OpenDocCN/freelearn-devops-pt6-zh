- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Helm Charts and Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Kubernetes ecosystem, it is very important to manage application redistribution
    and dependency management in cases when you want your applications to be easily
    downloadable and installable for customers, or when you want to share them between
    teams. One of the big differences between Linux package managers like APT or YUM
    and Kubernetes tools, such as Helm, is that they work universally and don’t depend
    on a particular Kubernetes distribution. Helm enables the easily distributive
    creation of applications by means of packaging multiple resources into charts,
    supporting easy reuse and customization of applications across diverse environments.
    This relieves the struggle of managing a large number of YAML manifests in application
    deployments and therefore lightens the load on a developer or an operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes Operators further complement Helm by adding the ability to manage
    an application’s life cycle in automated ways such as upgrades, failovers, and
    backups, and by maintaining consistent configurations. Together, Helm and the
    Operators help with some of the challenges of scaling and managing applications
    within Kubernetes. This chapter explores these tools in depth: Helm chart development,
    how to install popular components, and successful redistribution of Kubernetes
    applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Releasing software to Kubernetes using Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Kubernetes Dashboard using Helm Charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Kubernetes Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling Kubernetes monitoring using Prometheus and Grafana
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes cluster deployed. We recommend using a *multi-node, or* cloud-based,
    Kubernetes cluster if possible. You need to ensure CPU, memory, and storage resources
    are allocated for the Kubernetes cluster to ensure multiple Pods can be scheduled
    (e.g., you can create a larger minikube cluster using the command `minikube start
    --kubernetes-version=1.31.0 --cpus=4 --memory=8g`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kubernetes **command-line interface** (**CLI**) (`kubectl`) installed on
    your local machine and configured to manage your Kubernetes cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Basic Kubernetes cluster deployment (local and cloud-based) and `kubectl` installation
    have been covered in *Chapter 3*, *Installing Your First Kubernetes Cluster*.
    The upcoming chapters, *15*, *16*, and *17*, can give you an overview of how to
    deploy a fully functional Kubernetes cluster on different cloud platforms. You
    can download the latest code samples for this chapter from the official GitHub
    repository: [https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter14'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This approach is often used as a basic showcase of how you can run a given
    application as a container on Kubernetes. However, sharing raw YAML manifests
    has quite a few disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: All values in YAML templates are *hardcoded*. This means that if you want to
    change the number of replicas of a Service object target or a value stored in
    the ConfigMap object, you need to go through the manifest files, find the values
    you want to configure, and then edit them. Similarly, if you want to deploy the
    manifests to a different namespace in the cluster than the creators intended,
    you need to edit all YAML files. On top of that, you do not really know which
    values in the YAML templates are intended to be configurable by the creator unless
    they document this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployment process can vary for each application. There is no standardized
    approach regarding which YAML manifests the creator provides and which components
    you are required to deploy manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no *dependency management*. For example, if your application requires
    a **MySQL** server running as a StatefulSet in the cluster, you either need to
    deploy it yourself or rely on the creator of the application to provide YAML manifests
    for the MySQL server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a bit similar to what you see with the other applications if you do
    not use **Application Store** or a package manager such as **Chocolatey**, **APT**,
    **YUM**, **DNF**, and so on. Some applications that you download will come with
    an installer as a `setup.sh` script file, some with a `.exe` file, some as a `.msi`,
    and others will just be`.zip` files that you need to extract and configure yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kubernetes, you can use **Helm** ([https://helm.sh](https://helm.sh)), which
    is one of the most popular package managers for Kubernetes applications and services.
    If you are familiar with popular package managers such as APT, yum, npm, or Chocolatey,
    you will find many concepts in Helm similar and easy to understand. The following
    are the three most important concepts in Helm:'
  prefs: []
  type: TYPE_NORMAL
- en: A **chart** is a Helm *package*. This is what you *install* when you use the
    Helm **CLI**. A Helm chart contains all Kubernetes YAML manifests required to
    deploy the particular application on the cluster. Please note that these YAML
    manifests may be *parameterized*, so that you can easily inject configuration
    values provided by the user who installs the chart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **repository** is a storage location for Helm charts, used to collect and
    share charts. They can be public or private – there are multiple public repositories
    that are available, which you can browse on Artifact Hub ([https://artifacthub.io](https://artifacthub.io)).
    Private repositories are usually used for distributing components running on Kubernetes
    between teams working on the same product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **release** is an *instance* of a Helm chart that was installed and is running
    in a Kubernetes cluster. This is what you manage with the Helm CLI, for example,
    by upgrading or uninstalling it. You can install one chart many times on the same
    cluster and have multiple releases of it that are identified uniquely by release
    names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, Helm charts contain parameterizable YAML manifests that you store
    in a Helm repository for distribution. When you install a Helm chart, a Helm release
    is created in your cluster that you can further manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly summarize some of the common use cases for Helm:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying popular software to your Kubernetes cluster. This makes *development*
    on Kubernetes much easier – you can deploy third-party components to the cluster
    in a matter of seconds. The same approach may be used in *production* clusters.
    You do not need to rely on writing your own YAML manifest for such third-party
    components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm charts provide *dependency management* capabilities. If chart A requires
    chart B to be installed first with specific parameters, Helm supports syntax for
    this out of the box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing your own applications as Helm charts. This can include packaging a product
    for consumption by the end users or using Helm as an internal package and dependency
    manager for microservices in your product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that the applications receive proper upgrades. Helm has its own process
    for upgrading Helm releases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring software deployments for your needs. Helm charts are basically generic
    YAML templates for Kubernetes object manifests that can be *parameterized*. Helm
    uses **Go** templates ([https://godoc.org/text/template](https://godoc.org/text/template))
    for parameterization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently, Helm is distributed as a binary client (library) that has a CLI similar
    to `kubectl`. All operations that you perform using Helm do not require any additional
    components to be installed on the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that the Helm architecture was changed with the release of version
    3.0.0 of Helm. Previously, the architecture of Helm was different, and it required
    a special, dedicated service running on Kubernetes named Tiller. This was causing
    various problems, such as with security around **Role-Based Access Control** (**RBAC**)
    and elevated-privilege Pods running inside the cluster. You can read more about
    the differences between the latest major version of Helm and previous ones in
    the official FAQ:'
  prefs: []
  type: TYPE_NORMAL
- en: https://helm.sh/docs/faq/#changes-since-helm-2
  prefs: []
  type: TYPE_NORMAL
- en: This is useful to know if you find any online guides that still mention Tiller
    – they are most likely intended for older versions of Helm.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about Helm and its important concepts, we are going
    to install Helm and deploy a simple Helm chart from Artifact Hub to verify that
    it works correctly on your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Releasing software to Kubernetes using Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to install Helm and how to test the installation
    by deploying an example Helm chart. Helm is provided as binary releases ([https://github.com/helm/helm/releases](https://github.com/helm/helm/releases))
    available for multiple platforms. You can use them or refer to the following guides
    for installation using a package manager on your desired operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Helm on Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install Helm on Fedora, you need to ensure that the default Fedora repository
    is configured and working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then install Helm as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you can verify the version of the installed Helm package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to install Helm using the script (https://helm.sh/docs/intro/install/#from-script),
    which will automatically detect the platform, download the latest Helm, and install
    it on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, you can move on to *Deploying an example chart – WordPress*
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Helm on Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install Helm on Windows, the easiest way is to use the Chocolatey package
    manager. If you have not used Chocolatey before, you can find more details and
    the installation guide in the official documentation at [https://chocolatey.org/install](https://chocolatey.org/install).
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command in PowerShell or Command shell to install Helm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, you can move on to *Deploying an example chart – WordPress*,
    which is later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Helm on macOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install Helm on macOS, you can use the standard **Homebrew** package manager.
    Use the following command to install the Helm formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the installation was successful by trying to get the Helm version
    from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, we can deploy an example chart to verify that Helm works properly
    on your Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing from the binary releases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also possible to install the latest Helm package from the binary itself.
    You need to find the latest or desired version of the binary from the release
    page ([https://github.com/helm/helm/releases](https://github.com/helm/helm/releases))
    and download it for your operating system. In the following example, we will see
    how to install the latest Helm from the binary on the Fedora workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and install Helm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will test the Helm package by *Deploying an example chart - WordPress*
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an example chart – WordPress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, Helm comes with no repositories configured. One possibility, which
    is no longer recommended, is to add the `stable` repository so that you can browse
    the most popular Helm charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Adding random Helm chart repositories for deployment can pose serious security
    risks. Security audits are a must to ensure that only trusted and secure payloads
    are deployed within your Kubernetes environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that most charts are now in the process of deprecation as they
    are moved to different Helm repositories where they will be maintained by the
    original creators. You can see this if you try to search for available Helm charts
    using the `helm search repo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, the new recommended way is to use the `helm search hub` command, which
    allows you to browse the Artifact Hub directly from the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s try searching for some of the most popular Helm charts that we can
    use to test our installation. We would like to deploy **WordPress** on our Kubernetes
    cluster. We chose WordPress to demonstrate here because it is a typical three-tier
    application with a public access tier (The Service), a web tier (WordPress), and
    a database tier (MariaDB). First, let’s check what the available charts are for
    WordPress on Artifact Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can directly use the Artifact Hub web UI and search for WordPress
    Helm charts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Artifact Hub search results for WordPress Helm charts'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the Helm chart provided and maintained by **Bitnami**, a company
    specializing in distributing open-source software on various platforms, such as
    Kubernetes. If you navigate to the search result for WordPress charts by Bitnami,
    you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: Bitnami WordPress Helm chart on Artifact Hub with install instructions'
  prefs: []
  type: TYPE_NORMAL
- en: The page gives you detailed information about how you can add the `bitnami`
    repository and install the Helm chart for WordPress. Additionally, you will find
    a lot of details about available configurations, known limitations, and troubleshooting.
    You can also navigate to the home page of each of the charts in order to see the
    YAML templates that make up the chart ([https://github.com/bitnami/charts/tree/master/bitnami/wordpress](https://github.com/bitnami/charts/tree/master/bitnami/wordpress)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now do the installation by following the instructions on the web page.
    First, add the `bitnami` repository to your Helm installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As a best practice, let us install WordPress inside a dedicated namespace called
    `wordpress`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With the repository present, we can install the `bitnami/wordpress` Helm chart,
    but before that, we need to prepare some details for the deployment. Check the
    chart page in Artifact Hub ([https://artifacthub.io/packages/helm/bitnami/wordpress](https://artifacthub.io/packages/helm/bitnami/wordpress)).
    You will find a lot of parameters given here for you to configure and customize
    your WordPress deployment. If you do not provide any parameters, default values
    will be used for the Helm release deployment. For this demonstration, let us configure
    some of the parameters instead of using the default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pass the individual parameters using the `--set` argument as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When you have multiple parameters to configure, you can pass multiple `--set`
    arguments but it is recommended to use variables in files; you can use one or
    more files to pass the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us create a `wp-values.yaml` file to store the variables and values as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are passing some of the WordPress configurations to the Helm
    chart. Please note that we are changing the default WordPress type to `NodePort`
    as we are using a minikube cluster here. If you are using a different Kubernetes
    cluster – for example, cloud-based Kubernetes – then you may leave it as the default,
    which is `LoadBalancer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the Helm repo configured, a dedicated namespace created, and
    parameters configured in a variable file, let us deploy WordPress using Helm;
    we will use the name `wp-demo` for this release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Helm will show the basic release information, as shown here. After a while,
    you will also see the deployment details, including the service name, how to access
    the WordPress website, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is the beauty of Helm – you have executed a single `helm install` command
    and you are presented with a detailed guide on how to use the deployed component
    on *your* cluster. Meanwhile, the WordPress instance deploys without any intervention
    from you!
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a good practice to first inspect what Kubernetes objects’ YAML manifests
    were produced by Helm. You can do that by running the `helm install` command with
    additional flags: `helm install wp-demo bitnami/wordpress --dry-run --debug`.
    The output will contain the joint output of YAML manifests, and they will not
    be applied to the cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also mention the specific version of the Helm chart using the `--version`
    argument as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now follow the instructions from the Helm chart installation output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait for a while as the database needs to initialize and deploy the Pods. Check
    the Pod status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice the database is deployed as a StatefulSet as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wait for the `wp-demo` Service object (of the NodePort type) to acquire port
    details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our case, the port will be `80:31979/TCP`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are using minikube in this case, let us find the IP address and port
    details (if you are using the `LoadBalancer` type, then you can directly access
    the IP address to see the WordPress site):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now open your web browser and navigate to the WordPress URL, `http://192.168.59.150:30509`
    (the other port is for the HTTPS URL):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22019_14_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: WordPress chart deployed on Kubernetes – main page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can log in to the WordPress dashboard at `http://192.168.59.150:30509/wp-admin`.
    Please note that if you missed setting the WordPress parameters, including the
    password, you need to find the default values Helm has used. For example, to retrieve
    the WordPress login password, check the secret as follows. Use the following commands
    to obtain the credentials that are stored in a dedicated `wp-demo-wordpress` Secret
    object deployed as part of the chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the credentials to log in as the WordPress admin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22019_14_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: WordPress chart deployed on Kubernetes – admin dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: You can enjoy your WordPress now, congratulations! If you are interested, you
    can inspect the Pods, Services, Deployments, and StatefulSets that were deployed
    as part of this Helm chart. This will give you a lot of insight into what the
    components of the chart are and how they interact.
  prefs: []
  type: TYPE_NORMAL
- en: The Helm CLI offers *autocompletion* for various shells. You can run the `helm
    completion` command to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to get information about all Helm releases that are deployed in
    your Kubernetes cluster, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will learn how to delete a deployed release using Helm.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a Helm release
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we learned in the previous sections, the Helm chart has deployed several
    resources, including Deployment, PVC, Services, Secrets, and so on. It is not
    practical to find and delete these items one by one. But Helm provides an easy
    method to remove the deployment using the `helm uninstall` command. When you are
    ready, you can clean up the release by uninstalling the Helm release using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will delete all Kubernetes objects that the release has created. Please
    note though that PersistentVolumes and PersistentVolumeClaims, created by the
    Helm chart, will not be cleaned up – you need to clean them up manually. We will
    now take a closer look at how Helm charts are structured internally.
  prefs: []
  type: TYPE_NORMAL
- en: Helm chart anatomy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example, we will take the WordPress Helm chart by Bitnami ([https://github.com/bitnami/charts/tree/master/bitnami/wordpress](https://github.com/bitnami/charts/tree/master/bitnami/wordpress))
    that we have just used to perform a test Deployment in the cluster. Helm charts
    are simply directories with a specific structure (convention) that can live either
    in your local filesystem or in a Git repository. The directory name is at the
    same time the name of the chart – in this case, `wordpress`. The structure of
    files in the chart directory is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Chart.yaml`: YAML file that contains metadata about the chart such as version,
    keywords, and references to dependent charts that must be installed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LICENSE`: Optional, plain-text file with license information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`README.md`: End user README file that will be visible on Artifact Hub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values.yaml`: The default configuration values for the chart that will be
    used as YAML template parameters. These values can be overridden by the Helm user,
    either one by one in the CLI or as a separate YAML file with values. You have
    already used this method by passing the **-**`-values wp-values.yaml` argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values.schema.json`: Optionally, you can provide a JSON schema that `values.yaml`
    must follow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`charts/`: Optional directory with additional, dependent charts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crds/`: Optional Kubernetes custom resource definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templates/`: The most important directory that contains all YAML *templates*
    for generating Kubernetes YAML manifest files. The YAML templates will be combined
    with the provided *values*. The resulting YAML manifest files will be applied
    to the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templates/NOTES.txt`: Optional file with short usage notes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if you inspect `Chart.yaml` in the WordPress Helm chart, you can
    see that it depends on the **MariaDB** chart by Bitnami, if an appropriate value
    of `mariadb.enabled` is set to `true` in the provided values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you take a look at the `values.yaml` file with the default values,
    which is quite verbose, you can see that by default MariaDB is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, let’s check what one of the YAML templates looks like – open the
    `deployment.yaml` file ([https://github.com/bitnami/charts/blob/master/bitnami/wordpress/templates/deployment.yaml](https://github.com/bitnami/charts/blob/master/bitnami/wordpress/templates/deployment.yaml)),
    which is a template for the Kubernetes Deployment object for Pods with WordPress
    containers. For example, you can see how the number of `replicas` is referenced
    from the provided values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will be replaced by the `replicaCount` value (for which the default value
    of `1` is found in the `values.yaml` file). The details about how to use Go templates
    can be found at [https://pkg.go.dev/text/template](https://pkg.go.dev/text/template).
    You can also learn by example by analyzing the existing Helm charts – most of
    them use similar patterns for processing provided values.
  prefs: []
  type: TYPE_NORMAL
- en: The detailed documentation on Helm chart structure can be found at https://helm.sh/docs/topics/charts/.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you will need to override some of the default values from the
    `values.yaml` file during the installation of a chart, as we learned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that you know the most important details about the Helm chart structure,
    in the next section, we can deploy Kubernetes Dashboard using Helm charts.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kubernetes Dashboard using Helm Charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes Dashboard is the official web UI for providing an overview of your
    cluster. The Helm chart for this component is officially maintained by the Kubernetes
    community ([https://artifacthub.io/packages/helm/k8s-dashboard/kubernetes-dashboard](https://artifacthub.io/packages/helm/k8s-dashboard/kubernetes-dashboard)).
    We are going to install it with the default parameters, as there is no need for
    any customizations at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'For minikube clusters, you can enable the dashboard and access it using a single
    command: `minikube dashboard`. But our intention here is to learn how to deploy
    a dashboard for any type of Kubernetes cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the `kubernetes-dashboard` repository to Helm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can install the Helm chart as a `kubernetes-dashboard` release in the
    cluster as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the installation to finish and check the output messages. Notice the
    following message as we will use it later to access the dashboard WEBUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, ensure Pods have a `Running` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You may ignore other Pods deployed by the Helm chart for now. We will learn
    how to access the dashboard UI in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Secure access to the Kubernetes Dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the Kubernetes Dashboard prioritizes security by using a minimal
    RBAC configuration. This helps safeguard your cluster data. Currently, logging
    in to the dashboard requires a Bearer Token.
  prefs: []
  type: TYPE_NORMAL
- en: This sample user creation guide will likely grant administrative privileges.
    Be sure to use it only for educational purposes and implement proper RBAC controls
    for production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create a token to access the Kubernetes Dashboard WEBUI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a ServiceAccount; prepare the YAML as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the ServiceAccount as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `ClusterRoleBinding` to allow the access. Prepare the YAML as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `ClusterRoleBinding` by applying the YAML definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Copy the long token string generated, and we will use it in the next section
    to log in to the cluster dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Dashboard WEBUI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Kubernetes Dashboard offers various access methods. Here, we’ll focus on
    the default approach. This method assumes you haven’t altered the standard configuration
    during installation. If you’ve made modifications, the steps might differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command (which you copied from the `helm install` output
    earlier) to get Dashboard access. The command will stay there with the status
    of `port-forward`; do not exit from the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, access the URL `https://localhost:8443/` in a web browser. You can ignore
    the SSL certificate warning as the dashboard is using the self-signed SSL certificates.
    Enter the token you generated in *Step* *3*, of *Secure Access to the Kubernetes
    Dashboard*, and log in to Dashboard as shown in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: Kubernetes Dashboard chart – login page'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you have access to the dashboard, and you can browse its functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.6: Kubernetes Dashboard chart – Deployments page'
  prefs: []
  type: TYPE_NORMAL
- en: The bearer token is for a user with the `cluster-admin` role, so be careful,
    as you can perform any operations, including deleting resources.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations; you have successfully deployed the Kubernetes Dashboard using
    Helm charts, and verified the access using the token. You can explore more deployments
    using Helm charts as we explain in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing other popular solutions using Helm charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To practice more with Helm charts, you can quickly install some of the other
    software for your Kubernetes cluster. It can be useful in your development scenarios
    or as building blocks of your cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch with Kibana
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Elasticsearch is a popular full-text search engine that is commonly used for
    log indexing and log analytics. Kibana, which is part of the Elasticsearch ecosystem,
    is a visualization UI for the Elasticsearch database. To install this stack, we
    will need to use two charts, both of which are maintained by Elasticsearch creators:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Elasticsearch chart** ([https://artifacthub.io/packages/helm/elastic/elasticsearch](https://artifacthub.io/packages/helm/elastic/elasticsearch))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kibana chart** ([https://artifacthub.io/packages/helm/elastic/kibana](https://artifacthub.io/packages/helm/elastic/kibana))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prometheus with Grafana
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prometheus is a popular monitoring system with a time series database and Grafana
    is used as a visualization UI. Similar to the Elastic Stack, to install this Prometheus
    and Grafana stack, we will need to use two charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prometheus** ([https://artifacthub.io/packages/helm/prometheus-community/prometheus](https://artifacthub.io/packages/helm/prometheus-community/prometheus))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grafana** ([https://artifacthub.io/packages/helm/grafana/grafana](https://artifacthub.io/packages/helm/grafana/grafana))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we have already explained how to deploy Helm charts in the Kubernetes
    cluster, we will skip the step-by-step instructions for these. You may continue
    deploying the charts and exploring the functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore some of the key security considerations for
    Helm Charts.
  prefs: []
  type: TYPE_NORMAL
- en: Security considerations for Helm Charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Helm charts ease the deployment of applications into Kubernetes, but they can
    introduce several security vulnerabilities that need to be managed. Some of the
    most important things to bear in mind include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source Verification:** Always check the source for Helm charts before deploying
    and never install charts originating from non-trusted or less reputed repositories.
    Malicious/insecure applications may be contained. Verify the origin of a chart,
    and try using official ones or well-maintained community repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regular Audits**: Periodically run security audits of Helm charts and their
    dependencies. This process helps in identifying known vulnerabilities that, in
    turn, ensure applications deployed are secure enough to meet standards set by
    your organization. Perform vulnerability scanning within Helm charts using tools
    like Trivy or Anchore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chart Configuration**: Beware of the defaults that come in Helm charts. Most
    are shipped with configuration settings that are not appropriate to your production
    environment. Consider reviewing and adjusting the default settings as necessary,
    using your organizational security policy and best practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Role-Based Access Control (RBAC)**: Implement this to restrict the deployment
    and management of Helm charts in your Kubernetes cluster. This will reduce unauthorized
    changes and also ensure that only trusted persons can deploy sensitive applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Management:** Monitor and manage the list of dependencies shown
    within your Helm charts. Regularly update these to avoid security gaps in applications
    and make sure they receive the latest security patches and improvements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Namespace Isolation:** Consider using Helm charts, each in their own separate
    namespace, as this will increase security. If something bad happens, the blast
    radius will be limited, thus giving better isolation for applications and their
    resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By being proactive in these areas, you can go a long way toward improving the
    security posture of your Kubernetes deployments and ensuring that potential vulnerabilities
    do not bring down your applications and data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have explored and practiced the Helm charts in the first half of this
    chapter. We also learned that the Helm chart is a great way to deploy and manage
    complex applications in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: As Kubernetes adoption increases, so does the complexity of the production environment
    for managing applications. While Helm and similar tools improve the process of
    deploying applications, they cannot independently address stateful applications’
    operational needs such as scaling, configuration management, and failure recovery
    at runtime. We need solutions that package application knowledge and best practices
    for operation to automate operational tasks at every stage of the applications’
    lives with health and high performance in mind. With these solutions, teams minimize
    human interaction as well as reducing human error, and focus on delivering value
    through the application and not managing the infrastructure. Kubernetes Operators
    were introduced to help with such requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will learn what Kubernetes Operators are and how
    to install complex deployments with Kubernetes Operators.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kubernetes Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve explored the differences between Deployments and StatefulSets, with StatefulSets
    managing stateful applications that require persistent data storage. We also learned
    about the manual (and automated) operations needed for StatefulSets to function,
    such as data synchronization between Pod replicas and initialization tasks.
  prefs: []
  type: TYPE_NORMAL
- en: However, manual intervention goes against the core principles of Kubernetes,
    where automation and self-healing are paramount. This is where Kubernetes Operators
    step in.
  prefs: []
  type: TYPE_NORMAL
- en: From humans to software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine replacing human Operators with software Operators. Kubernetes Operators
    are essentially software extensions that automate complex application management
    tasks, especially for stateful applications. Instead of relying on manual intervention
    to maintain application stacks, Operators leverage their built-in software components
    and intelligence to execute and manage these tasks effectively.
  prefs: []
  type: TYPE_NORMAL
- en: The following image shows the high-level relationship between the components
    in a Kubernetes cluster with Operators.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.7: How Operators manage resources in Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will discuss the advantages and benefits of Kubernetes
    Operators.
  prefs: []
  type: TYPE_NORMAL
- en: Helm Charts versus Kubernetes Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Helm charts are associated components related to Operators in application
    management on Kubernetes, they are different. With Helm, users can install applications
    much faster than with Operators because Helm is an effective package manager,
    using pre-designed charts that make the process easier.
  prefs: []
  type: TYPE_NORMAL
- en: It finds its best application in situations that demand speed and, therefore,
    it is ideal for a one-time installation or even for smaller applications. Yet
    Helm still focuses way more on the deployment phase rather than on the continued
    operational needs across an application’s runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Operators are software programs that intend to assume responsibility for the
    entire life cycle of complex and stateful applications. Using **Custom Resource
    Definitions** (**CRDs**), they encode knowledge about how an application operates
    and allow scaling, configuration management, automation of upgrades, and self-healing
    mechanisms. Operators are constantly observing the health of an application and
    taking corrective action to head it back toward the desired state. That’s why
    they become so valuable for applications that are very management- and observation-intensive.
    To put it succinctly, Helm charts make the deployment easy, but Operators extend
    Kubernetes into production operability, letting teams automate and simplify how
    they manage their apps in production.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let us explore some of the major features of Kubernetes
    Operators compared to Helm charts.
  prefs: []
  type: TYPE_NORMAL
- en: How can the Operators help in the application deployment?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Operators are created with the capabilities to manage and maintain the application
    with all possible operations, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Life Cycle Management**: Operators manage the life cycle of your application
    or application stack beyond mere initial deployment. They automate key operational
    tasks like upgrades, scaling, and recovery from failures to keep the application
    healthy and performing over time. Other approaches, like Helm charts, generally
    stop at deployment, whereas Operators constantly monitor the current application
    state and automatically reconcile it to the desired configuration in case changes
    or issues arise. This allows for automated upgrades, configuration changes, and
    status monitoring – all with no intervention required or even desired. For complex
    stateful applications with demanding life cycle management, Operators offer significant
    advantages over Helm and must be preferred for such applications that require
    continuous care and automated management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Orchestration**: Operators create essential resources like **ConfigMaps**,
    **Secrets**, and **PVCs** required by your application to function properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated Deployment**: Operators can deploy your application stack based
    on either user-provided configurations or default values, streamlining the deployment
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database Management**: Take PostgreSQL clusters, for example. Operators can
    leverage StatefulSets to deploy them and ensure data synchronization across replicas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-Healing Capabilities**: Operators can detect and react to application
    failures, triggering recovery or failover mechanisms to maintain service continuity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusability of the automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operators promote reusability. The same Operator can be utilized across different
    projects or in multiple Kubernetes clusters, ensuring consistent and efficient
    application management throughout your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: How Operators ensure the application state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes Operators function similarly to Kubernetes itself, utilizing a control
    loop to manage applications. This loop continuously monitors the desired state
    of your application, defined by a CRD, and compares it to the application’s actual
    state within the cluster. Any discrepancies trigger corrective actions from the
    Operator. These actions can involve scaling the application, updating configurations,
    or restarting Pods. The control loop’s continuous operation ensures your application
    remains aligned with the desired state, promoting self-healing and automated management.
  prefs: []
  type: TYPE_NORMAL
- en: Custom resource definitions – building blocks for Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes Operators rely on CRDs. These are essentially extensions of the Kubernetes
    API that allow you to define custom resources specific to your application or
    its needs. Think of them as blueprints for your application’s desired configuration
    within the Kubernetes ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'CRDs essentially extend the Kubernetes API, allowing you to define custom resources
    specific to your application. These resources represent the building blocks of
    your application within the Kubernetes cluster. They can specify details like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The desired number of application replicas (Pods).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource requests and limits for memory and CPU.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage configurations for persistent data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables and configuration settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits of CRDs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are multiple benefits of using CRDs to deploy applications, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative Management:** Instead of manually configuring individual resources
    like Deployments or Services, CRDs let you define the desired state of your application
    in a declarative manner. The Operator then takes care of translating that desired
    state into actual running resources within the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application-Specific Configuration**: CRDs cater to the unique needs of your
    application. You can define custom fields specific to your application logic or
    configuration requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified Management:** CRDs provide a central point for managing your application’s
    configuration. This streamlines the process compared to scattered configurations
    across different resource types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator distribution mechanism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operators are primarily created and distributed by application vendors who possess
    the expertise in deploying those specific application stacks. However, a vibrant
    community actively develops, distributes, and maintains a vast array of Operators.
  prefs: []
  type: TYPE_NORMAL
- en: OperatorHub ([https://operatorhub.io/](https://operatorhub.io/)) serves as a
    central repository where you can discover and install Operators for a wide range
    of applications and functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: OperatorHub main page'
  prefs: []
  type: TYPE_NORMAL
- en: Building your own Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Operator Framework** provides a powerful toolkit known as the **Operator
    SDK**. This open-source gem empowers you to develop and build custom Operators,
    taking control of your application management within Kubernetes. The Operator
    SDK streamlines the often-complex process of crafting Operators. It offers pre-built
    components and functionalities that handle common tasks like interacting with
    the Kubernetes API, managing custom resources, and implementing the control loop.
    This allows you to focus on the unique logic and configuration needs of your specific
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Building your own Operators unlocks several advantages. Firstly, you gain fine-grained
    control over application management. The Operator can be tailored to your application’s
    specific needs, handling configuration, deployment strategies, and scaling requirements
    perfectly. Secondly, Operators automate repetitive tasks associated with the application
    life cycle, leading to significant efficiency gains. Finally, custom Operators
    are reusable. Once built for a particular application, they can be applied across
    different deployments of the same application, saving you time and effort in managing
    your Kubernetes infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about the Operator SDK at [https://sdk.operatorframework.io/](https://sdk.operatorframework.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Before we do some hands-on with the Operator, let us learn a few details about
    **Operator Lifecycle Manager** (**OLM**) in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Operator Lifecycle Manager (OLM)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operator Lifecycle Manager in Kubernetes simplifies the process of deploying
    and managing applications packaged as Operators. OLM uses a declarative way of
    specifying the resources using YAML files. In this, there is no need for complex
    multi-file deployments that rely on specific ordering. Installation and automatic
    upgrades also keep your Operators up to date with OLM. It also exposes a package
    discovery capability called Catalog Sources, which enables the use of Operators
    from, for example, OperatorHub, or from sources of your choosing. With OLM, you
    will gain several advantages. First, it reduces deployment complexity by managing
    dependencies and order. OLM can manage thousands of Operators over large clusters.
    What’s more, OLM enforces the desired configuration. This will ease rollouts and
    updates. Not to mention that OLM promotes standardization by providing a consistent
    way to package and deploy applications as Operators.
  prefs: []
  type: TYPE_NORMAL
- en: This is a question of your environment and personal preference. OLM is much
    more integrated and native to Kubernetes, while Helm, being familiar for other
    deployments, comes with a richer package ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: When we learn about Operators and OLM, it is also important to know about the
    **ClusterServiceVersion** (**CSV**). The ClusterServiceVersion will be the central
    point of an important part of Kubernetes’ Operator Lifecycle Manager, the core
    metadata processing and deploying information of the Operator. It goes on to define
    the name of the Operator and the version it holds, and gives a brief description.
    It also outlines the permissions or roles required by the Operator to operate
    correctly. It defines the CRDs that the Operator governs, installation strategy,
    and upgrade flows. Refer to the documentation ([https://olm.operatorframework.io/docs/concepts/crds/clusterserviceversion/](https://olm.operatorframework.io/docs/concepts/crds/clusterserviceversion/))
    to learn more about the CSV.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we’ll explore how to deploy Prometheus monitoring
    on Kubernetes using both OLM and the Prometheus Operator, showcasing the power
    of both approaches in application management.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Kubernetes monitoring using Prometheus and Grafana
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Success in keeping your Kubernetes applications healthy and performant depends
    on different factors; one of those is having a robust, reliable environment. Here,
    monitoring tools like **Prometheus** and **Grafana** can help. Prometheus works
    behind the scenes; it gathers and stores valuable metrics about your Kubernetes
    cluster. Grafana visualizes this treasure trove of data, presenting it in an understandable
    format for you to gain deep insight into the health and behavior of your applications
    and infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows the high-level architecture of Prometheus components.
    (It’s an official reference.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.9: Architecture of Prometheus and some of its ecosystem components
    (Source: https://prometheus.io/docs/introduction/overview/)'
  prefs: []
  type: TYPE_NORMAL
- en: Traditional deployments, say, of monitoring stacks comprising Prometheus and
    Grafana, are pretty cumbersome. Writing several YAML manifests by hand, with all
    the dependencies and the proper ordering of deployment, is rather laborious and
    prone to errors. The Prometheus and Grafana Operators offer an even more efficient
    and maintainable solution.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to utilize Helm charts to deploy this entire monitoring stack
    – including Operators and instances – using projects such as `kube-prometheus-stack`
    (https://artifacthub.io/packages/helm/prometheus-community/kube-prometheus-stack).
    But in the next section, our intention is to set up the same monitoring stack
    using OLM.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we’ll explore the process of deploying Prometheus
    and Grafana within your Kubernetes cluster, equipping you to effectively monitor
    your applications and ensure their smooth operation.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Operator Lifecycle Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To utilize the OLM-based operator installation, we need to install OLM in the
    cluster. You can install OLM in the cluster using the `operator-sdk` utility,
    Helm charts, or even by applying the Kubernetes YAML manifests for OLM. For this
    exercise, let us use the `install.sh` script-based installation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the script to complete and configure the Kubernetes cluster with OLM.
    Once finished, verify the Pods are running in the `olm` namespace as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, check the ClusterServiceVersion details using the `kubectl get csv` command
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: That has a success status – we can see the OLM is deployed and ready to manage
    the Operators. In the next section, we will deploy Prometheus and Grafana Operators
    using OLM.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Prometheus and Grafana Operators using OLM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you configure OLM, deploying Operators is pretty straightforward. Most
    of the time, you will find the operator installation command and instructions
    on the Operators page at `operatorhub.io`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the Prometheus operator ([https://operatorhub.io/operator/prometheus](https://operatorhub.io/operator/prometheus))
    using OLM, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Search for the Prometheus Operator in OperatorHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the Prometheus operator using OLM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: https://operatorhub.io/install/prometheus.yaml provides a basic YAML definition
    to create a subscription. You can create local YAML files with all the customization
    required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Wait for a few minutes and ensure the Prometheus operator is deployed properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify the Prometheus operator Pods are running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same way, find and install the Grafana operator using OLM (follow the
    previous steps for references):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, also verify the CRDs created in the backend as these entries are created
    as part of the Operator installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will find multiple CRDs created in the Kubernetes cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have deployed the Operators, it is time to create the Prometheus
    and Grafana instances and configure the stack to monitor the Kubernetes cluster.
    We will learn about these operations in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Prometheus and Grafana instances using Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To configure new instances, let us utilize standard YAML definitions with the
    CRD configuration. The instructions and the YAML definition files for this exercise
    are stored in the `Chapter 14` directory of the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the steps to configure a monitoring stack in Kubernetes with Prometheus
    and Grafana:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a best practice, let us create a namespace to deploy the monitoring solution
    (refer to `monitoring-ns.yaml`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure a ServiceAccount with the appropriate role and RBAC (refer to `monitoring-sa.yaml`
    in the repo):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Prepare YAML for the new Prometheus instance (refer to `promethues-instance.yaml`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice the `kind: Prometheus` in the preceding YAML definition, as we are using
    a CRD here; the Prometheus operator will understand this CRD and take necessary
    actions to create the deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Prometheus instance by applying the configuration to the cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a similar way, deploy the Grafana instance using the operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are using the configuration and passwords here in plain text directly inside
    the YAML definition. In a production environment, you should be using Kubernetes
    Secrets to store such sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the YAML definition to create a Grafana instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify the objects created by Prometheus and Grafana Operators in the `monitoring`
    namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can see, in the preceding output, that the Operators have created appropriate
    Kubernetes resources based on the CRD. You can even see the Prometheus and Grafana
    Service created and will be able to access it. We will demonstrate it at a later
    stage of this exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For demonstration purposes, let us enable Node Exporter in the cluster and visualize
    it using Grafana. Node Exporter is one of the Prometheus exporters, which exposes
    detailed metrics of a host machine, including hardware and OS details, such as
    CPU usage, memory usage, and other system-level metrics. It runs on each node
    in a Kubernetes cluster – or physical or virtual servers – as a separate service
    and exposes these metrics through an HTTP endpoint. By scraping this data, Prometheus
    can know the health and performance of a node, thereby enabling an administrator
    to understand resource utilization and point out problems in the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running Node Exporter as a DaemonSet would imply that each node in the Kubernetes
    cluster is running an instance of the exporter. In that way, Prometheus would
    be able to consistently scrape the system metrics across all nodes for effective
    observation of the overall health and performance of the cluster. Create the Node
    Exporter using `node-exporter-daemonset.yaml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'A Node Exporter Service (`svc`) should be created to expose the metrics that
    the Node Exporter is collecting to Prometheus. The service provides a way for
    Prometheus to discover and scrape metrics from the Node Exporter pods running
    on each node, thus providing a capability of centralized monitoring of node performance
    across the Kubernetes cluster. Create a Service for Node Exporter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'A Node Exporter serviceMonitor conventionally enables Prometheus to discover
    and scrape the Node Exporter service for metrics. This described configuration
    simplifies the whole process of monitoring by defining how and where Prometheus
    should scrape for metrics, like specifying the target service, interval, labels,
    and others serving to ensure consistency in the collection without an administrator’s
    intervention. Create a serviceMonitor CRD as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us verify the Prometheus portal to ensure the details are collected there.
    In one of your consoles, start a `kubectl port-forward` command to expose the
    Prometheus service as follows (you can end the `port-forward` using *Ctrl+C* later
    once you finish testing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Open a browser and access `http://localhost:9091/targets` to ensure `node-exporter`
    is visible to Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.10: Prometheus portal with node-exporter visible for Kubernetes node'
  prefs: []
  type: TYPE_NORMAL
- en: You can confirm from the preceding screenshot that Prometheus is getting the
    node metrics successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us visualize the metrics and monitoring data using our visualization
    tool, Grafana. Open a console and use the `kubectl port-foward` command to expose
    the Grafana service as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Open a browser and access the URL http://localhost:3000 to see the Grafana dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.11: Grafana portal'
  prefs: []
  type: TYPE_NORMAL
- en: Use the login credential you have configured in the `grafana-instance.yaml`
    (or the secret if you used one) and log in to the Grafana dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: You will only find a default dashboard there as we need to configure a new dashboard
    for our own purpose.
  prefs: []
  type: TYPE_NORMAL
- en: From the left-side menu, go to **Connections | Data sources** as shown in the
    following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.12: Adding a data source in Grafana'
  prefs: []
  type: TYPE_NORMAL
- en: In the next window, select **Prometheus** as the data source and enter the Prometheus
    URL as shown in the following figure. Remember to enter the FQDN (e.g., `http://prometheus-operated.monitoring.svc.cluster.local:9090`
    – r to *Chapter 8*, *Exposing Your Pods with Services*, to learn more about Services
    and FQDNs).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.13: Configure Grafana data source'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Save & test** button at the bottom of the page and you will receive
    a success message as shown in the following figure. (If you get any error messages,
    then please check the Prometheus URL you have used, including the FQDN and the
    port number.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.14: Grafana data source configured successfully'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the data source, we need to create a dashboard to visualize
    the data. You can either create a dashboard from scratch or import the dashboard
    with predefined configurations. For that, visit `https://grafana.com/grafana/dashboards/`
    and find the **Node Exporter Full** dashboard. Click on the **Copy ID to clipboard**
    button as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.15: Copy the Grafana dashboard ID to import'
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the Grafana **WEBUI | Dashboards | New | Import**, as shown in the
    following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.16: Importing a new dashboard to Grafana'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the **Node** **Exporter Full** dashboard ID that you already copied in
    the previous step, as shown here, and click on the **Load** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.17: Provide the dashboard ID to import in Grafana'
  prefs: []
  type: TYPE_NORMAL
- en: On the next screen, select **Prometheus** as the data source (which you configured
    earlier) and click the **Import** button as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.18: Complete dashboard import in Grafana'
  prefs: []
  type: TYPE_NORMAL
- en: That’s it; you will see the nice dashboard with preconfigured widgets and graphs,
    as shown in the following figure. You can explore the dashboard and find the details
    about your cluster, such as CPU, memory, network traffic, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_14_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.19: Node Exporter: full dashboard imported in Grafana'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have successfully deployed the Prometheus and Grafana stack
    on your Kubernetes cluster with Node Exporter enabled!
  prefs: []
  type: TYPE_NORMAL
- en: That is all for this chapter. As you can see, working with Helm charts and Operators,
    even for complex, multi-component solutions, is easy and can provide a lot of
    benefits for your development and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the details of working with Helm, Helm charts, and Kubernetes
    Operators. First, you learned what the purpose of package management is and how
    Helm works as a package manager for Kubernetes. We demonstrated how you can install
    Helm on your local machine, and how you can deploy a WordPress chart to test the
    installation. Then, we went through the structure of Helm charts, and we showed
    how the YAML templates in charts can be configured using user-provided values.
    Next, we showed the installation of popular solutions on a Kubernetes cluster
    using Helm. We installed Kubernetes Dashboard and explored the components. After
    that, we learned about Kubernetes Operators and other components, including customer
    resource definitions. We also deployed the Prometheus stack, including Grafana
    using Helm and Operators.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part, you will get all the details required to effectively deploy
    Kubernetes clusters in different cloud environments. We will first take a look
    at working with clusters deployed on Google Kubernetes Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Helm website**: [https://helm.sh/](https://helm.sh/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes Dashboard**: [https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/](https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing Dashboard**: [https://github.com/kubernetes/dashboard/blob/master/docs/user/accessing-dashboard/README.md](https://github.com/kubernetes/dashboard/blob/master/docs/user/accessing-dashboard/README.md'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploy and Access the Kubernetes Dashboard**: [https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/](https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a sample user for dashboard access**: [https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md](https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '**Build a Kubernetes Operator in six steps**: [https://developers.redhat.com/articles/2021/09/07/build-kubernetes-operator-six-steps](https://developers.redhat.com/articles/2021/09/07/build-kubernetes-operator-six-steps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom resources**: [https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information regarding Helm and Helm charts, please refer to the following
    *Packt Publishing* book:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Learn Helm*, by *Andrew Block*, *Austin Dewey* ([https://www.packtpub.com/product/learn-helm/9781839214295](https://www.packtpub.com/product/learn-helm/9781839214295))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can learn more about Elasticsearch and Prometheus in the following *Packt
    Publishing* books:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Learning Elasticsearch*, by *Abhishek Andhavarapu* ([https://www.packtpub.com/product/learning-elasticsearch/9781787128453](https://www.packtpub.com/product/learning-elasticsearch/9781787128453))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Infrastructure Monitoring with Prometheus*, by *Joel Bastos*, *Pedro
    Araujo* ([https://www.packtpub.com/product/hands-on-infrastructure-monitoring-with-prometheus/9781789612349](https://www.packtpub.com/product/hands-on-infrastructure-monitoring-with-prometheus/9781789612349))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code119001106479081656.png)'
  prefs: []
  type: TYPE_IMG
