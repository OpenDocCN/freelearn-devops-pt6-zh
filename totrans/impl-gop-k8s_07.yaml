- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cultural Transformation in IT for Embracing GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the rapidly evolving landscape of information technology, the adoption of
    **GitOps** marks a significant paradigm shift, heralding not just a technological
    transformation but also a profound **cultural** metamorphosis within IT departments.
    This chapter delves into the multifaceted layers of this change, highlighting
    how GitOps fundamentally redefines operational processes and methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, GitOps represents a fusion of software development and IT operations,
    driven by the principles of version control and collaboration, which are intrinsic
    to Git. It’s a methodology where infrastructure and application deployment are
    treated as code, enabling a high degree of **automation** and precision in IT
    operations. This approach ensures that the same rigor that’s applied to application
    development is now extended to the management of infrastructure, particularly
    within Kubernetes environments.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most transformative aspects of GitOps is the establishment of an
    **immutable infrastructure**. Using reconciling and synchronization loops, GitOps
    automates the process of aligning the actual state of the infrastructure with
    the desired state defined in a Git repository. This alignment minimizes the need
    for manual interventions, reducing the potential for human error and improving
    the overall reliability and security of the IT systems.
  prefs: []
  type: TYPE_NORMAL
- en: A significant part of this chapter is dedicated to understanding the impact
    of GitOps on IT performance. We’ll explore this through the lens of the **DevOps
    Research and Assessment** (**DORA**) metrics, a widely recognized set of indicators
    used to measure the effectiveness of DevOps practices. By applying these metrics
    to GitOps, organizations can quantitatively assess improvements in areas such
    as deployment frequency, change lead time, change failure rate, and mean time
    to recovery.
  prefs: []
  type: TYPE_NORMAL
- en: However, the journey of adopting GitOps extends beyond the implementation of
    tools such as Argo CD. It necessitates a continuous engagement with evolving GitOps
    trends and practices. As with any emerging technology, GitOps comes with its own
    set of challenges. These include the need for upskilling teams, adapting existing
    workflows, and **continuously optimizing** processes to align with best practices
    in GitOps.
  prefs: []
  type: TYPE_NORMAL
- en: The final section of this chapter addresses the broader organizational impact
    of implementing GitOps. Adopting GitOps is not just a technical upgrade; it’s
    a catalyst for a cultural shift that permeates various departments within an organization.
    We’ll share insights and experiences from multiple projects across diverse companies,
    illustrating how GitOps can drive a more collaborative, transparent, and efficient
    IT culture. These real-world examples provide valuable lessons on the challenges,
    strategies, and successes of integrating GitOps into the fabric of an organization.
  prefs: []
  type: TYPE_NORMAL
- en: This comprehensive examination of GitOps, from its technical foundations to
    its cultural implications, aims to provide you with a clear understanding of the
    transformative power of this methodology. It’s a journey that transcends mere
    technology adoption, charting a path toward a more agile, responsive, and innovative
    IT culture.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following main topics in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Treating infrastructure as an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The principles of immutable infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to DORA metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the need for continual improvement in GitOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overcoming cultural barriers to adopt GitOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Treating infrastructure as an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the evolving landscape of **DevOps**, the concept of treating infrastructure
    as applications – commonly known as **infra-as-apps** – is gaining momentum, especially
    in the context of GitOps. To understand this, we need to get a quick overview
    of **Infrastructure as Code** (**IaC**). IaC will be covered in detail in [*Chapter
    10*](B22100_10.xhtml#_idTextAnchor190). This is a crucial component that’s laid
    out, for example, by Terraform with its declarative approach, allowing infrastructure
    to be treated like an application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding IaC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IaC is a modern approach for managing and provisioning IT infrastructure using
    code instead of traditional manual processes. This method allows you to automate
    the setup, management, and configuration of computing resources such as servers,
    storage, networks, and applications. Treating your infrastructure as if it were
    software, IaC applies software development practices such as version control and
    testing to infrastructure management.
  prefs: []
  type: TYPE_NORMAL
- en: The main aim of IaC is to enhance efficiency, reliability, and consistency in
    infrastructure deployment and management. By using code to define infrastructure,
    manual intervention is reduced, decreasing human error, and speeding up deployment.
    IaC enables a more consistent and repeatable process for provisioning and configuring
    resources, simplifying the scaling and management of infrastructure over time.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**Imperative**: Directly use kubectl commands to create, update, or delete
    Kubernetes resources, offering quick, on-the-fly adjustments suitable for development
    and experimentation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative**: Define the desired state in YAML manifests and apply them,
    letting Kubernetes ensure the actual state aligns with the declared one. This
    is ideal for production with benefits such as version control and reproducibility.'
  prefs: []
  type: TYPE_NORMAL
- en: IaC typically employs a **declarative** or **imperative** approach to define
    the infrastructure’s desired state. This specification allows the IaC tool to
    make necessary changes automatically, leading to a more agile, efficient, and
    reliable IT environment that better supports modern business demands.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of IaC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rise of cloud computing has been a significant driver behind IaC’s growing
    adoption. Organizations face the challenge of managing and deploying resources
    across multiple environments, such as public, private, and hybrid clouds. IaC
    automates the deployment and management of these resources, easing the management
    of complex environments.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the need for businesses to deliver applications and services swiftly
    and efficiently has made IaC increasingly important. In today’s fast-paced digital
    world, organizations must rapidly adapt to market and customer demands. IaC streamlines
    IT operations, enabling quicker and more adaptable scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, IaC supports **DevOps principles**, bridging the gap between software
    development and IT operations. Treating infrastructure as code allows organizations
    to apply software development methodologies to infrastructure, enhancing collaboration
    and communication between development and operations teams.
  prefs: []
  type: TYPE_NORMAL
- en: How IaC works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fundamental concept of IaC is treating infrastructure like software. This
    includes employing rigorous software development practices such as version control,
    infrastructure code testing, and continuous integration and deployment. This approach
    ensures infrastructure consistency, reducing downtime and maintenance time.
  prefs: []
  type: TYPE_NORMAL
- en: The IaC process starts with writing scripts that describe the infrastructure’s
    desired state using declarative language. These scripts, stored in a version control
    system like any software, allow for versioning, auditing, and rollbacks. An IaC
    tool then applies these scripts to the actual infrastructure, ensuring it matches
    the desired state. This repeatability ensures consistency and reduces manual errors.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding infrastructure as applications in Argo CD’s GitOps framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the realm of Argo CD, the concept of an application extends beyond its traditional
    definition [*1*]. Here, an application encompasses not just the software but also
    its desired state configuration, the targeted deployment environment, and the
    policies governing how these resources are synced and managed. This approach marks
    a significant shift from the conventional understanding of applications.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, engineering teams have viewed applications as software layers that
    run on a separate infrastructure. The standard process involves setting up the
    infrastructure first, often manually or using tools such as **Terraform** or **Cloud
    Formation** templates. Once this groundwork is laid, another team deploys their
    applications onto this prepared infrastructure. However, Argo CD introduces a
    more integrated perspective. In this GitOps-driven environment, an application’s
    deployment is continuously monitored. Argo CD vigilantly compares the real-time
    state of the application against its predefined desired state. This constant comparison
    is crucial for maintaining consistency and reliability. The divergence between
    the actual state and the desired state can occur due to two primary reasons. First,
    there could be a drift in the actual state, which refers to unanticipated changes
    or modifications in the environment. Secondly, the desired state itself might
    be updated, necessitating a change in the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever such divergences occur, Argo CD steps in to reconcile these differences.
    This act of reconciliation is at the heart of the GitOps style of deployment,
    which Argo CD upholds. This method aligns with the principles set by the **OpenGitOps
    standards**, ensuring a systematic and standardized approach to deployment and
    infrastructure management.
  prefs: []
  type: TYPE_NORMAL
- en: This paradigm shift, where infrastructure is treated akin to applications, brings
    about a more seamless and integrated workflow. It emphasizes the importance of
    treating infrastructure management with the same level of detail and care as application
    development, underscoring a holistic approach to system deployment and management.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing infra-as-apps – bridging GitOps and infrastructure management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Traditionally, creating and managing infrastructure through declarative configurations
    has been a challenge, despite the popularity of tools such as **Terraform**, **Cloud
    Formation** templates, **Pulumi**, **Cloud Development Kit for Terraform** (**CDKTF**),
    and others. These tools offer a one-time or change-triggered application of the
    desired state, typically via **CI/CD pipelines**. However, this method falls short
    in one critical aspect of GitOps: ongoing state monitoring.'
  prefs: []
  type: TYPE_NORMAL
- en: The gap lies in the fact that CI/CD pipelines, while efficient in deploying
    new plans or updates, do not continuously monitor for state drift. For instance,
    if a Terraform plan is executed and the actual state is altered externally later,
    the CI/CD system remains oblivious to these changes. This is where a GitOps operator
    such as Argo CD becomes indispensable. Argo CD’s role is to relentlessly monitor
    the actual state of the infrastructure and ensure it aligns with the desired state,
    thereby preventing drift.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting this *no-drift-allowed approach* has proven beneficial for teams, not
    only in managing their applications more efficiently but also in enhancing their
    ability to recover from failures rapidly. In this model, rolling back to a previous
    state is as simple as performing `git revert`.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits that teams have experienced in managing applications can now be
    extended to infrastructure management, thanks to this paradigm shift. Our focus,
    however, will be on Crossplane. As an open source CNCF project, Crossplane enables
    users to provision and manage diverse cloud resources through the Kubernetes API.
    When integrated with a GitOps operator such as Argo CD, Crossplane allows for
    the deployment of applications representing a variety of cloud resources such
    as **Azure Key Vault**, **databases**, **Kubernetes clusters**, and load balancers
    across **Azure**, **AWS**, and other cloud platforms. This integration heralds
    a new era in infrastructure management, blending the robustness of GitOps with
    the versatility of modern cloud resources.
  prefs: []
  type: TYPE_NORMAL
- en: How IaC can be used to deploy infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have all the necessary background information and hopefully a sufficient
    understanding of the difference between the GitOps approach and using Terraform
    in terms of treating your infrastructure as an application, let’s clarify this
    in practice by examining three use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin, let’s briefly explain the selected tools for this setup and
    why they were chosen. Starting with Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Kubernetes Service (AKS)**: This service offers a managed Kubernetes
    environment that simplifies how containerized applications are deployed, managed,
    and scaled with the robustness of Azure’s infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container Registries**: This service provides a secure, scalable, and private
    registry for Docker container images, enhancing the management and deployment
    of containerized applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PostgreSQL Server on Azure**: This service offers a reliable and scalable
    cloud database service, ensuring efficient management and storage of application
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Key Vault**: This is a tool for securely storing and accessing secrets,
    keys, and certificates. It’s crucial for managing sensitive information and enhancing
    overall security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Kubernetes, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Argo CD**: A declarative, GitOps continuous delivery tool for Kubernetes,
    enabling automated deployment and management of applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External-DNS**: This tool automates the management of DNS records, streamlining
    the process of connecting Kubernetes services with external DNS names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cert-Manager**: This tool manages SSL/TLS certificates for Kubernetes, automating
    certificate issuance and renewal processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External-Secrets Operator**: This tool integrates with systems such as Azure
    Key Vault to securely inject secrets into Kubernetes, enhancing secure access
    to sensitive data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For deployments for the IaC part, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Terraform modules**: These are components within Terraform, an IaC tool,
    that are designed to enable modular and reusable infrastructure definitions. They
    facilitate a declarative approach by allowing users to define the desired state
    of their infrastructure in code, which Terraform then executes to create and manage
    the actual infrastructure, ensuring it matches the specified state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Crossplane**: This is an IaC tool that integrates with the Kubernetes ecosystem,
    allowing for external resources, such as cloud services, to be managed through
    Kubernetes **custom resource definitions** (**CRDs**). It adopts a declarative
    model where users define their infrastructure requirements in a Kubernetes-native
    way, enabling consistent and unified management of both Kubernetes internal resources
    and external cloud infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In combination, these tools form a comprehensive ecosystem. Azure’s services
    provide a secure and scalable cloud platform, while Kubernetes tools such as Argo
    CD and Cert-Manager ensure efficient and secure application deployment and management.
    The integration between Azure Key Vault and the External-Secrets Operator in Kubernetes
    exemplifies how cloud infrastructure and Kubernetes can work seamlessly together
    for enhanced security and operational efficiency. Now, let’s look at the use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Use case 1 – deploy everything over Terraform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the first use case, as illustrated in *Figure 7**.1*, everything is deployed
    via Terraform. This means that initially, the required cloud infrastructure is
    deployed using Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Use case 1 – deploy everything over Terraform](img/B22100_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Use case 1 – deploy everything over Terraform
  prefs: []
  type: TYPE_NORMAL
- en: To simplify this example, we’ve removed any unnecessary complexity, such as
    CI/CD pipelines. In a production setup, you would hopefully not execute this manually
    as a user, unless it’s for initial bootstrapping or solving the chicken-and-egg
    problem. Once the infrastructure is deployed, additional Terraform modules are
    used to deploy further infrastructure in a Kubernetes context.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that there are native approaches available for integrating
    Terraform with GitOps, such as the **Terraform Controller**. This tool enables
    a variety of GitOps models tailored for Terraform resources, including full automation,
    hybrid automation for partial infrastructure management, state enforcement, and
    drift detection, all within a native framework. However, this chapter focuses
    more on the native use of tools.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is sound and was even standard a few years ago. Here, the infrastructure
    is treated and deployed as an application through the declarative module approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are some drawbacks to this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lack of continuous monitoring**: This approach does not continuously monitor
    the infrastructure state for any drift, which is a key component in GitOps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity in scalability**: As the infrastructure grows, managing it through
    Terraform alone can become increasingly complex, especially in terms of state
    management, multiple stages, and module dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited dynamic response**: The approach lacks the dynamic response to changes
    that a GitOps workflow offers, where real-time adjustments to the infrastructure
    can be managed more seamlessly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overhead in managing modules**: Relying heavily on Terraform modules for
    every aspect of deployment can lead to overhead in module management and version
    control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Potential for configuration drift**: Without continuous reconciliation, there’s
    a higher risk of configuration drift over time as manual updates may not be tracked
    or recorded consistently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case 2 – integrating Terraform and Argo CD for deployment processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next approach, illustrated in *Figure 7**.2,* combines the first method
    and then delegates the task to Argo CD. This approach is common in practice and
    often encountered in various projects with different clients. In this method,
    the Azure infrastructure is initially rolled out using Terraform modules. Subsequently,
    Argo CD is deployed as the initial instance using Terraform modules. Afterward,
    Argo CD takes over the GitOps part and deploys the Kubernetes context-related
    infrastructure. In this approach, a declarative method is best. Terraform modules
    are laid out declaratively, and the infrastructure, such as **Cert-Manager**,
    is also presented declaratively as *Applications* or *ApplicationSets*, as described
    in previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Use case 2 – integrating Terraform and Argo CD for deployment
    processes](img/B22100_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Use case 2 – integrating Terraform and Argo CD for deployment processes
  prefs: []
  type: TYPE_NORMAL
- en: 'While this approach has its advantages, there are potential drawbacks to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity of integration**: Combining Terraform with Argo CD can add complexity,
    requiring a solid understanding of both tools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Initial learning curve**: For teams new to either Terraform or Argo CD, the
    learning curve might be steep due to the integration of these two different paradigms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overhead in maintenance**: The combined approach might require more maintenance
    effort as it involves managing two systems rather than one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risk of misconfiguration**: With two powerful tools at play, there’s an increased
    risk of misconfiguration, which can lead to deployment issues or security vulnerabilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update coordination**: Coordinating updates between the infrastructure managed
    by Terraform and applications managed by Argo CD requires careful planning to
    avoid conflicts and ensure smooth operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case 3 – unified management on Kubernetes – full-scale orchestration with
    CRs and Crossplane
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next approach, depicted in *Figure 7**.3*, fully utilizes the Kubernetes
    API while focusing on **CRDs** and **custom resources** (**CRs**), which allows
    users to define their resource types and instantiate these types for custom configurations
    and functionality. This approach uses Crossplane for provisioning cloud infrastructure
    and deploying third-party tools necessary for Kubernetes infrastructure, such
    as Cert-Manager. It treats infrastructure as applications through the declarative
    nature of CRs, providing a fully trackable solution that leverages the Kubernetes
    ecosystem as an orchestration platform to keep resources in sync. This concept
    can be expanded so that virtually all cloud infrastructure is provisioned through
    Argo CD in combination with Crossplane. Everything is maintained within the cluster,
    requiring only an understanding of Kubernetes manifests – in this case, CRDs and
    CRs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Use case 3 – unified management on Kubernetes – full-scale orchestration
    with CRs and Crossplane](img/B22100_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Use case 3 – unified management on Kubernetes – full-scale orchestration
    with CRs and Crossplane
  prefs: []
  type: TYPE_NORMAL
- en: For a better understanding of how to create a resource in Azure with Crosslplane,
    CR, and Argo CD, here is a small example using the CR `VirtualNetwork` type. The
    requirement for this is that Kubernetes is installed and that the Azure provider
    is installed and configured [*3*].
  prefs: []
  type: TYPE_NORMAL
- en: Once the preparation is complete and the network provider is installed, we can
    create a managed resource of the `VirtualNetwork` type that can be used for AKS,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a CR, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then, push the CR to your Git repository that will be managed by Argo CD. The
    CD part should now happen over GitOps with Argo CD and you should see the created
    managed Azure network resource in the portal.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this setup assumes the existence of a managed cluster where the necessary
    tools are deployed and configured. It comes with the following potential weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The complexity of a Kubernetes ecosystem**: It requires a thorough understanding
    of Kubernetes, including CRDs and CRs, which might be challenging for teams less
    familiar with these concepts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency on a managed cluster**: The approach is contingent on a managed
    Kubernetes cluster, limiting its applicability in environments where such a setup
    is not available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource intensiveness**: The approach might be resource-intensive, requiring
    more compute power and memory within the cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration and maintenance**: Managing and maintaining the configurations
    of CRDs and CRs can be cumbersome and error-prone, especially in large-scale deployments
    and version upgrades'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there is no one-size-fits-all approach that meets all requirements.
    The right approach for a team depends greatly on the company’s specific needs,
    the size of the teams, the team’s skill set in various areas, and more. However,
    we should still take a moment to revisit why treating infra-as-apps is a game-changer.
  prefs: []
  type: TYPE_NORMAL
- en: Why infra-as-apps is a game-changer?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To summarize, here’s a list of the benefits of infra-as-apps that makes it
    a game-changer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**: By centralizing key management and shifting from direct cloud
    access to change management via Git, infra-as-apps enhances security. This approach
    minimizes risks associated with direct cloud access and improves audit trails
    by tracking changes through version control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficient resource management**: This model streamlines the provisioning
    of new resources and the upgrading of existing ones. It allows for more agile
    and responsive infrastructure management, reducing the time and effort required
    for resource allocation and updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved CI/CD for pull requests**: Infra-as-apps focuses on enhancing pull
    requests within CI/CD pipelines, offering automated rollbacks and more thorough
    testing. This leads to more robust and reliable deployment processes, ensuring
    higher quality and stability in production environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier multi-cloud provisioning**: With tools such as Crossplane, infra-as-apps
    facilitates provisioning across various cloud environments. This capability simplifies
    the implementation of multi-cloud strategies, making it easier to manage and deploy
    resources across different cloud platforms efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified infrastructure management**: This approach significantly streamlines
    the process of managing infrastructure, making it more efficient and less prone
    to human error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of onboarding and resource provisioning for developers**: It simplifies
    the process for developers to get started and manage resources, reducing the time
    and complexity involved in setting up and deploying applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Faster mean time to recover (MTTR)**: It improves the speed of recovery from
    failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solid auditability**: It provides comprehensive audit trails and clear accountability,
    making it easier to track changes and maintain compliance with regulatory standards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are numerous companies, such as CERN, Splash, Grafana Labs, IBM, and SAP,
    that have already adopted Crossplane for a variety of use cases. A prime example
    of infra-as-apps in action can be seen at CERN, as presented by Ricardo Rocha
    at GitOpsCon US 2021, *A Multi-Cluster, Multi-Cloud Infrastructure with GitOps
    at CERN* [*2*]. CERN, renowned for operating the Large Hadron Collider, leverages
    infra-as-apps to manage an extensive infrastructure, including over 600 clusters,
    3,000 nodes, 13,000 cores, 30 TBs of RAM, and 160 TBs of raw storage, to process
    vast amounts of data from experiments. They manage a massive array of clusters
    and computing resources using Kubernetes. CERN’s implementation involves Helm
    charts with Crossplane configurations for cluster and resource management, allowing
    rapid scaling and multi-cloud resource allocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a second example, IBM’s use of Crossplane and GitOps to manage the infrastructure
    life cycle and application deployments is noteworthy. In *GitOpsify Everything:
    When Crossplane Meets Argo CD* [*4*], presented by Ken Murray, a CI/CD engineer
    at IBM, and Ying Mo, a software engineer, they explore the integration of Crossplane
    with Argo CD in various IT environments. IBM’s approach involves using Crossplane
    as an abstraction layer for infrastructure provisioning and cluster management,
    enabling them to maintain a pool of Kubernetes clusters efficiently. This method
    leverages Helm templates for defining resource configurations and simplifies cluster
    management by allowing users to interact with simple resource types while Crossplane
    handles communication with cloud providers.'
  prefs: []
  type: TYPE_NORMAL
- en: Infra-as-apps distinguishes itself from traditional **infra-as-code** by fully
    embracing GitOps at all levels. This approach treats manual changes to infrastructure
    as deviations from the Git-defined desired state, enhancing security and predictability
    in infrastructure management. It represents a significant shift in how infrastructure
    is managed, aligning it more closely with the dynamic and automated nature of
    application development and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps has changed a lot, creating an immutable infrastructure that also has
    an impact on a company’s culture. In the next section, we will look at immutable
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the principles of immutable infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **principles of immutable infrastructure**, combined with the GitOps approach,
    offer a transformative way of managing infrastructure and deployments in modern
    software development environments. Immutable infrastructure refers to a model
    where servers, once deployed, are never directly modified. Instead, changes require
    the server to be replaced with a new instance. This model drastically reduces
    issues caused by configuration drift and enhances the reliability of systems by
    treating servers as disposable units that can be replaced quickly, offering greater
    scalability and efficiency in deployment processes.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating GitOps into this model amplifies these benefits. GitOps leverages
    Git as the central source of truth for managing both software applications and
    infrastructure. It applies cloud-native patterns to deployments, often associated
    with Kubernetes but also applicable to various platforms. The core principles
    of GitOps include treating infrastructure as code, ensuring versioned and immutable
    deployments, automatic pulling of the desired state, and continuous reconciliation
    between the desired and actual states.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of immutable infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Immutable infrastructure is a concept where servers, once deployed, are never
    modified; if a change is needed, a new instance is created and replaced. This
    approach is fundamentally different from traditional mutable infrastructure, where
    servers are continually updated and modified. The immutable model brings several
    key advantages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of immutable infrastructure are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistency and reliability**: Immutable servers remain in a known, stable
    state, significantly reducing the risk of unexpected issues due to environmental
    drift or inconsistencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced security**: With servers not being modified post-deployment, the
    attack surface remains constant, simplifying security management and anomaly detection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified management and debugging**: Troubleshooting becomes more straightforward
    as the infrastructure stays in a predictable state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability and performance**: New instances can be spun up and down efficiently
    to meet demand, maintaining a consistent performance level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, this approach isn’t without its challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased storage and resource needs**: Immutable infrastructure can require
    more storage since each change involves creating a new instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Potential deployment overhead**: Setting up an entirely new instance for
    every change can be more resource-intensive than updating an existing one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity in configuration management**: Managing numerous server instances
    can become complex, particularly in large-scale environments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating immutable infrastructure with GitOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Incorporating GitOps into immutable infrastructure leverages Git’s core principles
    – version control, collaboration, and automation – to operational management,
    enabling a system where infrastructure is treated as code, with all configurations
    and states meticulously maintained in Git repositories for enhanced consistency
    and traceability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of GitOps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single source of truth**: Having a single repository for both application
    and infrastructure code ensures consistency and traceability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated, reliable deployments**: Continuous deployment via GitOps operators
    automates and simplifies the deployment process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced collaboration and transparency**: Pull request workflows enhance
    collaboration, providing clear audit trails and ensuring accountability in changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved security and compliance**: Git’s inherent features facilitate robust
    access control, encryption, and compliance adherence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Despite these benefits, GitOps is not without its drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity in scaling**: Managing multiple repositories and dealing with
    the complexity of large-scale deployments can be challenging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git limitations for operational tasks**: Git, primarily designed for code
    version control, may not be the best fit for operational updates, leading to potential
    conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learning curve and adoption resistance**: Teams may face a steep learning
    curve or resistance to adopting new workflows, tools, and mindsets. I will cover
    this part later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synergy and challenges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When immutable infrastructure and GitOps are combined, they create a powerful
    synergy:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infrastructure as a dynamic, version-controlled entity**: Infrastructure
    is treated similarly to application code, with changes tracked, reviewed, and
    deployed using GitOps methodologies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rapid recovery and rollback capabilities**: The combination allows for quick
    recovery from failures and easy rollbacks to previous stable states'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Streamlined operations**: This approach reduces the need for manual intervention,
    minimizing human error and streamlining operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, this integration also presents unique challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complex workflow management**: Balancing the immutable aspects of infrastructure
    with the dynamic nature of GitOps workflows requires careful planning and execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency on tooling and processes**: The effectiveness of this approach
    is heavily reliant on the right tooling and well-defined processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Balancing security and agility**: Ensuring security in a rapidly changing
    environment necessitates a fine balance between rigid controls and operational
    flexibility'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Achieving an effective production environment using immutable infrastructure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The optimal immutable infrastructure for production environments can be conceptualized
    by integrating several key practices, refined through experience. Here’s how an
    effective production environment might look and why:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read-only access to a Kubernetes prod cluster**: In a productive environment,
    a Kubernetes cluster should be treated like a managed service or a *black box*
    from a developer’s perspective. This means that access to the cluster should be
    primarily read-only. Developers should not be permitted to make manual changes
    to the cluster, ensuring a controlled and stable environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Only create and delete resources through GitOps**: This principle dictates
    that all resources entering the cluster should be managed exclusively through
    GitOps. This includes the entire creation process, covering elements such as namespaces,
    deployments, services, ingress, service accounts, and more. This approach ensures
    that changes are **traceable**, **reversible**, and **consistent** with the source
    of truth in the Git repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not create namespaces over applications**: In the context of Argo CD and
    its concept of application, an application mustn’t be able to create namespaces.
    This is because Argo CD does not support the deletion of namespaces created by
    an application *[5]*. This restriction is in place to prevent uncontrolled namespace
    creation, which could lead to conflicts and management issues in shared environments.
    In the following example, I will clarify the situation for you by illustrating
    the practical implications and potential risks associated with managing namespaces
    in a shared environment using Argo CD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider a scenario where five teams share a single Kubernetes namespace. Each
    team creates its own Argo CD application to deploy its service components, contributing
    to the overall microservices architecture. Suppose Team A decides to decommission
    its service. They proceed to delete their application and the associated deployed
    service, and they also attempt to delete the shared namespace through their application.
    However, Argo CD applications do not inherently have knowledge of or connections
    to other applications or unlinked resources within the same namespace. Consequently,
    if such a deletion were permitted, it would inadvertently result in the removal
    of the namespace and all other services deployed by the different teams within
    it. Fortunately, this scenario is not feasible in practice, as the Argo project
    team does not implement such a feature to avoid these kinds of disruptive and
    unintended consequences.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Use the right tools, such as PR-Generator**: Integrating tools such as PR-Generator
    in a GitOps workflow with Argo CD can greatly enhance the testing and deployment
    processes. PR-Generator can create resources with a specific prefix as soon as
    a PR is initiated, ensuring that resources are correctly created and cleaned up,
    respecting the *do not create namespaces over* *application* principle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By adhering to these practices, several benefits can be realized:'
  prefs: []
  type: TYPE_NORMAL
- en: Every change is made through Git, ensuring a centralized and version-controlled
    change management process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes are recorded in the Git history, providing a transparent and traceable
    record of all modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources are cleanly managed, with no residual “orphaned” resources left in
    the cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean and efficient workflow management using PRs and Git, facilitated by tools
    such as PR-Generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It establishes a standard and commitment within the organization, allowing these
    practices to be replicated across different projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing these principles in a production environment creates a robust,
    secure, and manageable infrastructure that leverages the benefits of both immutable
    infrastructure and GitOps methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'A potential folder structure for an application that utilizes both **Kustomize**
    and Argo CD might be structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This structure ensures that all resources can be deployed and cleaned up through
    Argo CD and the GitOps approach, eliminating the need to set the `AUTO-CREATE
    NAMESPACE` option in the Application Sync Options for namespace creation.
  prefs: []
  type: TYPE_NORMAL
- en: Application configuration for immutable infrastructure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will examine a potential application configuration that contributes
    to an immutable infrastructure setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Example of an application sync policy configuration](img/B22100_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Example of an application sync policy configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'The following flags should be set if you want to get the most immutable infrastructure
    setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PRUNE RESOURCES**: Enable this option to allow Argo CD to automatically delete
    resources that are present in the cluster but no longer defined in the Git repository.
    This ensures that all resources in the cluster are managed through the GitOps
    approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SELF HEAL**: Enable this option. It ensures that any changes made directly
    in the cluster that deviate from the Git repository are automatically corrected
    by Argo CD, maintaining the desired state as defined in Git.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SET DELETION FINALIZER**: Enable this option to ensure that resources are
    only deleted from the cluster when they are removed from the Git repository. This
    prevents premature deletion and ensures resources are cleaned up only after their
    removal from Git.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RESPECT IGNORE DIFFERENCES**: Enable this to instruct Argo CD to ignore specific
    differences it doesn’t recognize. You can define in the Argo CD configuration
    what specific differences to ignore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AUTO-CREATE NAMESPACE**: Ensure this option is disabled to prevent Argo CD
    from automatically creating namespaces. Namespaces should be explicitly defined
    as resources in your Git repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By setting these policies, you ensure that resource creation, deletion, and
    synchronization are all managed through changes in your Git repository while adhering
    to the principles of GitOps. This approach ensures a tight coupling between the
    declared state in Git and the actual state in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The combination of immutable infrastructure and GitOps represents a modern approach
    to IT operations and development. It brings together the best of stability, security,
    and dynamic, automated workflows. While it offers significant advantages in terms
    of reliability, security, and efficiency, it also poses challenges in terms of
    complexity, resource demands, and dependency on specific tools and practices.
    As with any IT methodology, success in implementing these concepts depends on
    a clear understanding of their benefits and limitations, careful planning, and
    an adaptive approach to evolving IT landscapes.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve looked at various aspects of transformation that come with GitOps.
    But what’s the point of all this if you can’t get or measure any added value from
    it? That’s why, in the next section, we’ll look at specific metrics that make
    product quality measurable.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing DORA metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we’ll introduce you to DORA metrics and delve into a set of
    key performance indicators developed by the DORA team. These metrics are pivotal
    in evaluating and improving software delivery and operational performance within
    IT teams. The four principal DORA metrics are **Deployment Frequency**, **Lead
    Time for Changes**, **Change Failure Rate**, and **MTTR**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployment Frequency**: This assesses how often a team successfully deploys
    code to production. Frequent deployments are indicative of an efficient and responsive
    development process, allowing for quicker feedback and **continuous improvement**.
    To increase the frequency of deployments, adopt CI/CD practices. Automate your
    build and deployment pipelines using tools such as **Jenkins**, **GitHub Actions**,
    or **GitLab CI**. Regular, smaller deployments reduce risks and facilitate quicker
    feedback. Additionally, feature flags can be used to manage deployments and gradually
    roll out new features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lead Time for Changes**: This measures the duration from code commit to code
    deployment in production. This metric indicates the speed and agility of the development
    process. Shorter lead times often result in faster feedback from users and the
    ability to adapt and improve the software swiftly. Improve lead time by optimizing
    your development processes. This includes adopting Agile methodologies, increasing
    collaboration between teams, and integrating code review and testing into the
    development process. Utilize automated testing and **continuous integration**
    tools to ensure that code changes are tested and integrated quickly. Tracking
    tools can be used to monitor the time from code commit to deployment, helping
    identify bottlenecks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change Failure Rate**: This focuses on the percentage of deployments that
    result in a production failure. This metric is essential for understanding the
    reliability and stability of the software development process. A lower change
    failure rate signifies higher quality and reliability in software deployments.
    To reduce the change failure rate, focus on enhancing the **quality of code**
    and the reliability of deployments. Implement automated testing, including unit
    tests, integration tests, and end-to-end tests, to catch issues early. Employ
    static code analysis tools and conduct thorough code reviews. Practice continuous
    deployment with automated rollbacks, and use **canary releases** or **blue-green
    deployments** to minimize the impact of failed deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MTTR**: This is the average time taken to recover from a failure in the production
    environment. This metric is crucial as it reflects the team’s ability to quickly
    rectify issues, thereby minimizing downtime and maintaining service quality. Reducing
    MTTR involves improving incident response and recovery processes. Implement monitoring
    and alerting tools such as Prometheus, Grafana, or New Relic to quickly detect
    issues. Establish clear incident management protocols and on-call rotations. Use
    IaC tools such as Terraform to enable fast and consistent environment recovery.
    Regularly practice incident response drills to ensure the team is prepared for
    quick recovery.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These metrics align well with the GitOps approach, which emphasizes automation,
    monitoring, and quick feedback. GitOps can enhance Deployment Frequency and Lead
    Time for Changes through automated pipelines. It also helps in reducing the Change
    Failure Rate and MTTR by enabling quicker rollbacks and promoting more reliable
    deployments through practices like continuous integration and delivery.
  prefs: []
  type: TYPE_NORMAL
- en: However, while DORA metrics provide valuable insights, they come with challenges.
    Implementing these metrics requires a mature DevOps team and established CI/CD
    processes. Data collection and tagging need to be precise and actionable. The
    metrics must be adapted to the unique cadences and processes of different teams
    and products.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of measuring these metrics independently from specific Git **Source
    Version Controls** (**SVCs**) such as DevOps, GitHub, or GitLab, organizations
    can look toward integrating various tools that provide necessary data visualizations
    and dashboards. Teams can leverage APIs from different tools to gather relevant
    data points for calculating these metrics. For example, Deployment Frequency can
    be monitored using tools that track code deployments, while Lead Time for Changes
    can be calculated by extracting timestamps for code commits and deployments from
    version control systems.
  prefs: []
  type: TYPE_NORMAL
- en: Organizations can choose to implement DORA metrics either by developing logic
    tailored to their environments or by utilizing established tools such as **GitLab’s
    Value Stream Analytics Dashboard**. GitLab’s dashboard [*6*] effectively visualizes
    the software development life cycle and computes DORA metrics. It provides an
    interactive interface for tracing essential phases of the software delivery process
    and enables teams to customize the dashboard to align with their specific workflow,
    enhancing the understanding of lead time, cycle time, and other vital metrics.
    This feature aids in identifying bottlenecks and areas needing improvement, thus
    boosting deployment frequency and overall DevOps performance.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, **SquaredUp** specializes in Azure DevOps integration [*7*] and offers
    a DORA metrics dashboard designed specifically for DevOps teams. This dashboard
    presents a comprehensive view of crucial performance indicators, including Deployment
    Frequency, Lead Time for Changes, Change Failure Rate, and MTTR. It supports teams
    in monitoring and analyzing their software delivery process, facilitating the
    identification of areas for enhancement. SquaredUp’s solution emphasizes data-driven
    decision-making in software development, showcasing the importance of metrics
    in optimizing DevOps workflows.
  prefs: []
  type: TYPE_NORMAL
- en: The key to successfully utilizing DORA metrics lies in understanding the context
    of these measurements, interpreting them collectively rather than in isolation,
    and adapting them to suit the unique requirements of individual teams and projects.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, DORA metrics provide a structured and quantifiable approach to
    assessing and improving DevOps performance. They offer a comprehensive view of
    the software delivery process, highlighting areas for improvement and fostering
    a **culture of continuous development** and operational efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need for continual improvement in GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the ever-evolving landscape of software development, the adoption of GitOps
    marks a significant transition in collaborative approaches and operational efficiencies.
    GitOps, a methodology that combines Git with Kubernetes’ operational workflows,
    is more than just a set of practices – it represents a continuous journey of improvement
    and adaptation. This section explores how GitOps necessitates and facilitates
    **continual improvement** across various domains such as security, development,
    platform engineering, and financial operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Evolving security practices with GitOps**: Security in the GitOps realm is
    dynamic and **continuously evolving**. Teams deploy policies using tools such
    as **Kyverno**, adjusting to the rapidly changing landscape of security threats.
    The emergence of new vulnerabilities and attack vectors demands a proactive and
    adaptive approach. GitOps supports this by allowing for quick iteration and deployment
    of **security policies**. However, the approach to managing secrets has seen shifts
    – from using tools such as Sealed Secrets to adopting External-Secrets Operators.
    This transition underscores the need for teams to constantly evolve their tools
    and practices, staying ahead in a domain where stagnation equates to vulnerability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Developers’ continuous innovation through GitOps**: For developers, GitOps
    is not just a method of deployment but a catalyst for **continuous innovation**.
    Techniques such as **blue-green** and **canary deployments** become more streamlined,
    while new tools such as PR-Generators enhance the deployment processes. These
    innovations are vital in a landscape where deployment strategies and tools are
    in a constant state of change. GitOps empowers developers to rapidly deploy, experiment,
    and iterate, thereby fostering a culture of continual improvement and agile responsiveness
    to market and technological changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform engineering and scalable infrastructure**: Platform engineering
    teams find GitOps an ally for managing infrastructure with efficiency and scalability.
    Patterns such as *App of Apps* and *ApplicationSets with Cluster Generator* in
    Argo CD demonstrate the evolving nature of infrastructure management. Tools such
    as Crossplane and Cluster API extend the capabilities of GitOps from mere application
    deployment to managing and provisioning diverse cloud resources. This evolution
    highlights the necessity for teams to continually adapt and enhance their skills
    and tools to manage increasingly complex and distributed systems effectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FinOps – financial optimization in the age of GitOps**: In the FinOps domain,
    GitOps introduces tools such as **OpenCost**, enabling detailed cost tracking
    and allocation down to the namespace level. Such granularity in cost allocation
    and the ability to adjust resource availability based on usage patterns represent
    a significant shift in managing cloud costs. It also illustrates the ongoing need
    for financial operations teams to integrate new tools and strategies to optimize
    costs continually. The use of tools such as **Kubegreen**, which adjusts resources
    based on demand, is a testament to the evolving nature of financial operations
    in cloud environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The journey with GitOps is ongoing and multifaceted. Teams across different
    domains – from security to development and platform engineering to FinOps – must
    not only adopt GitOps but also embrace its ethos of continual improvement. This
    involves regular evaluations, a willingness to adopt new tools and practices,
    and a commitment to learning and adaptation.
  prefs: []
  type: TYPE_NORMAL
- en: In the final section of this chapter, we will explore overcoming **cultural
    barriers**, adopting GitOps, and how different teams are currently working with
    varying approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Overcoming cultural barriers to adopt GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adopting GitOps goes beyond just tool implementation; it involves a cultural
    shift within organizations. This transition involves breaking down traditional
    departmental barriers, nurturing collaboration, and uniting teams toward shared
    goals. GitOps acts as a unifying force, streamlining operations and development
    toward a more efficient IT environment. Continual improvement in GitOps is essential
    in the dynamic world of software development. This journey focuses on learning,
    adapting, and evolving practices.
  prefs: []
  type: TYPE_NORMAL
- en: When examining different definitions or contrasting GitOps with DevOps, the
    technical aspects can be summarized via the Weaveworks blog on GitOps culture,
    which elaborates on how GitOps extends beyond a set of tools or practices to encompass
    a broader cultural shift within organizations. This approach integrates Git at
    the heart of both operational and developmental processes, emphasizing transparency,
    accountability, and collaboration. GitOps culture is characterized by the centralization
    of Git in managing infrastructure, applications, and CI/CD processes, enhancing
    automation, stability, and consistency. It fosters an environment where team members
    are engaged in a continuous cycle of improvement, enabled by the visibility and
    control offered by Git-based workflows.
  prefs: []
  type: TYPE_NORMAL
- en: It might be right about the GitOps approach and the associated technical challenges,
    as well as the responsibility, collaboration, and more. I’m not saying it’s wrong,
    because it isn’t. However, I want to shift the focus to a perspective that also
    considers the daily work in various industries. Not every company is a software
    company like Weaveworks.
  prefs: []
  type: TYPE_NORMAL
- en: A project’s story – exchange, experiences, and learnings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From my experience and discussions with **DevOps professionals**, **CTOs**,
    and **platform engineers**, it’s clear that tool and approach changes are more
    straightforward than altering a team or company mindset, which requires time for
    transformation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some companies handle this like so:'
  prefs: []
  type: TYPE_NORMAL
- en: In our use of GitOps with Argo CD for infrastructure and application services,
    we’ve noticed significant improvements. For instance, we can easily identify drifts
    in our staging and production environments, which are monitored closely. For development
    and ephemeral environments, we use Helm and CD pipelines without tracking changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weaveworks on GitOps culture highlights how GitOps, particularly through Weave
    GitOps, fosters a strong team culture characterized by **excellent communication**,
    **coordination**, and **collaboration**. The clarity in **roles** and **responsibilities**
    provided by GitOps allows teams to **maintain autonomy**, supported by Kubernetes
    namespaces for organizing and isolating workloads. Additionally, Weave’s acquisition
    of Magalix emphasizes security policies in GitOps, enabling admins to set and
    enforce policies throughout the GitOps process. This approach underscores the
    operational nature of GitOps culture, distinct from the aspirational culture of
    DevOps, focusing on precision and accountability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And I believe Weaveworks hits the nail on the head when you look beyond the
    technical aspects and read closely. The dialog suggests that the GitOps approach
    fosters a new culture among different teams, who should master the same tool but
    for different use cases. The teams can work autonomously, but this requires excellent
    communication, coordination, and collaboration. Additionally, it involves defining
    roles and responsibilities. Every change or initiative should be clearly and transparently
    communicated to the other teams. This all sounds great, but how does it look in
    real projects with different teams? I will try to illustrate this with an example
    from one of my projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the project, there’s a platform team, several developer teams, and a security
    team. The security team’s role is to ensure not only that security guidelines
    are adhered to within the organization, but also IT governance and compliance.
    Therefore, it feels responsible for using all possible means to protect the company
    and enforce policies throughout the GitOps process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The platform team provides the necessary Kubernetes clusters and context for
    the developers, so they only need to focus on their applications and, at most,
    third-party tools. They see their role as enablers for the developers, who purchase
    and use the platform as customers, with maximum emphasis on **self-service**,
    **availability**, and **performance**. The developer teams consume Kubernetes
    as a product and develop their applications. Let’s see how one team’s reasonable
    decision can unintentionally harm another team:'
  prefs: []
  type: TYPE_NORMAL
- en: The security team enforces a policy that no application can run with elevated
    privileges, and some applications, both in the platform context and those self-developed,
    stop working. This results in application downtime and software failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *rationale* for this action is to ensure that the company is protected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The platform team carried out a Kubernetes upgrade from 1.24 to 1.25 as support
    for the previous version ended. As a result, the third-party tools used by the
    security team no longer work. Some of the developers’applications also stop functioning.
    The change did not consider that the upgrade replaced *PodSecurityPolicies* with
    *PodSecurityStandards*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *rationale* for this action is to ensure that a supported version is available
    and that the platform remains up to date as required by the security team. This
    responsibility includes ensuring that performance is optimized and reliable while
    maintaining adherence to the latest security protocols and compliance standards
    associated with the Kubernetes ecosystem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The developers use their autonomy and open a *NodePort* on a node with an external
    IP address for testing purposes. The application becomes externally accessible.
    The debugging works, but testing takes longer. Fortunately, the application uses
    **Log4j** version 2.10 for logging, simplifying the debugging process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *rationale* for this action is to increase the performance of testing and
    debugging. The developers were under pressure to meet deadlines and chose a quick
    solution to test their applications, prioritizing immediate functionality over
    long-term security and compliance considerations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Possible causes that arise from the different actions are that customers are
    frustrated, the company loses money per minute, and the reputation of the company
    declines. These are modified use cases and fortunately, my projects were not affected
    by the Log4J incident. But the point here is not what happened but that these
    cases occur and are justifiable from the team’s point of view.
  prefs: []
  type: TYPE_NORMAL
- en: Reflecting on the causes of recent challenges, it seems that the varying explanations
    provided by the different teams are all valid. For example, when examining the
    changes made by the security and platform teams, they took accountability from
    their perspective, ensuring that the company was adequately protected and represented.
    However, they did not consider themselves responsible for application outages
    or customer loss, believing their actions were justified. This situation could
    have been potentially avoided with simple communication and transparency about
    the impending changes between teams.
  prefs: []
  type: TYPE_NORMAL
- en: From the developers’ viewpoint, they were under pressure to meet a deadline
    to prevent further delays for a feature, which is already behind schedule, causing
    frustration among customers. Debugging was activated only in the development environment,
    and they assumed it was unnecessary to inform the security or platform teams,
    believing that these teams wouldn’t understand the change and would impede it
    without reason. The developers felt they were acting in the company’s best interest
    and aiming to satisfy their customers.
  prefs: []
  type: TYPE_NORMAL
- en: From the developers’ viewpoint, they felt a strong sense of accountability to
    meet a deadline. However, they overlooked the importance of simple communication
    and transparency with the security or platform teams, assuming these teams wouldn’t
    comprehend the change and might unnecessarily impede it. In their pursuit to act
    in the company’s best interest and satisfy customers, they missed an opportunity
    for collaboration that could have harmonized their efforts with the broader organizational
    goals.
  prefs: []
  type: TYPE_NORMAL
- en: The learnings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The learnings from these incidents led to the creation of a guild, with representatives
    from each team attending meetings. This allowed for changes and their impacts
    to be discussed and made visible, fostering clear communication and collaboration
    between teams. Additionally, it helped different teams understand each other’s
    perspectives, needs, and reasons, enhancing transparency. While not all decisions
    were discussed, and changes were sometimes made rapidly due to time constraints
    or urgency, such as in the case of critical security vulnerabilities, the overall
    situation improved. The increased transparency helped in better understanding
    the impact of changes, reducing the blast radius of these changes. Empathy among
    team members increased, and the culture of blaming significantly decreased.
  prefs: []
  type: TYPE_NORMAL
- en: Did things overall improve? *Yes*!
  prefs: []
  type: TYPE_NORMAL
- en: Were all decisions discussed and changes made only after consultation? *No*,
    as time constraints and urgency often lead to decisions being made quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Essential Q&A from another recent project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we’ll focus on specific questions and answers from a company,
    and various projects, that are still in the process of transformation, having
    started with the DevOps approach and now shifted to platform engineering, including
    their honest reasoning for this change:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Q1: How did GitOps restructure your team organization?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A1: Initially, we had separate DevOps teams per project. GitOps led to the
    creation of a central platform team to manage Kubernetes clusters efficiently.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Q2: What were the challenges in transitioning to GitOps?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A2: Our main challenge was adapting to the **immutable infrastructure** GitOps
    offers, especially understanding that all changes need to flow through Git commits.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Q3: What benefits have you realized with GitOps?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A3: GitOps has brought us a clear, traceable workflow. Every change, big or
    small, is now meticulously tracked via Git.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Q4: How has GitOps affected team communication?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A4: Communication has significantly improved. Our platform team has developed
    a **deeper understanding** of the developers’ needs, leading to more **empathetic
    collaboration**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Q5: Can you share any successful cultural transformations?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A5: Definitely. We’ve developed a **proactive error culture**, focusing on
    automation and **continuous learning**, which has fundamentally changed our problem-solving
    approach.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Q6: How has daily work evolved for your teams with GitOps?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A6: There’s a noticeable increase in **motivation** and **responsibility**
    among team members, with a greater sense of **autonomy** in their roles.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Q7: How did your team adapt to GitOps?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A7: Surprisingly, there was a little resistance. The team understood the necessity
    of this transformation and was quite receptive to it.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Q8: How do you measure the success of this transition?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A8: While we don’t have precise metrics yet, the reduction in **manual interventions**
    and the increase in **Git activities** are strong indicators of success.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Q9: What is your team size?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A9: Our team consists of around 20 developers and three platform engineers.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This conversation format allows for a clear understanding of how GitOps has
    transformed team dynamics, challenges, and workflow efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting GitOps is more than implementing a set of tools; it involves cultural
    shifts within organizations. Overcoming traditional silos between departments,
    fostering a culture of collaboration and continuous learning, and aligning diverse
    teams toward common operational goals are essential steps in this journey. Thus,
    the adoption of GitOps becomes a unifying force, aligning varied operational and
    developmental efforts toward a more efficient, transparent, and responsive IT
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, the necessity for continual improvement in GitOps is not just
    a recommendation; it is a requirement in the fast-paced and ever-changing world
    of software development and IT operations. As teams navigate this journey, the
    focus should remain on learning, adapting, and evolving practices to stay ahead
    in an environment where change is the only constant. So, GitOps is less of a destination
    and more of a path toward operational excellence and continual improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided a compelling view of the cultural revolution in IT, brought
    about by the adoption of GitOps. It started by establishing GitOps as not just
    a technological shift but a profound cultural metamorphosis within IT departments.
    This approach, merging software development with IT operations through Git, transforms
    operational processes and methodologies, treating infrastructure as an application.
    It enables automation and precision and extends rigorous development practices
    to infrastructure management.
  prefs: []
  type: TYPE_NORMAL
- en: A key transformation brought about by GitOps is the establishment of immutable
    infrastructure, automating the alignment of the infrastructure’s actual state
    with its desired state, and reducing manual interventions and errors. This chapter
    also explored the impact of GitOps on IT performance through DORA metrics, offering
    a quantitative assessment of improvements in deployment frequency, change lead
    time, failure rate, and recovery time. This chapter also addressed the broader
    organizational implications of GitOps adoption. This goes beyond mere tool implementation;
    it’s a catalyst for a far-reaching cultural shift, fostering a collaborative,
    transparent, and efficient IT culture. Real-world examples from various organizations
    illustrated how GitOps drives these changes.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, this chapter revealed the transformative power of GitOps, transcending
    technology to chart a path toward a more agile and innovative IT culture.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll explore the application of GitOps in conjunction
    with OpenShift, a Kubernetes downstream distribution from Red Hat, and examine
    how its management differs.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*1*] [https://codefresh.io/blog/infrastructure-as-apps-the-gitops-future-of-infra-as-code/](https://codefresh.io/blog/infrastructure-as-apps-the-gitops-future-of-infra-as-code/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*2*] [https://www.youtube.com/watch?v=h6xDWc6fXao](https://www.youtube.com/watch?v=h6xDWc6fXao)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*3*] [https://docs.crossplane.io/latest/getting-started/provider-azure/](https://docs.crossplane.io/latest/getting-started/provider-azure/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*4*] [https://www.youtube.com/watch?v=9odjdVqJkws](https://www.youtube.com/watch?v=9odjdVqJkws)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*5*] [https://github.com/argoproj/argo-cd/issues/7875](https://github.com/argoproj/argo-cd/issues/7875)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*6*] [https://docs.gitlab.com/ee/user/analytics/value_streams_dashboard.html](https://docs.gitlab.com/ee/user/analytics/value_streams_dashboard.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*7*] [https://squaredup.com/dashboard-gallery/dora-metrics-dashboard-devops-team/](https://squaredup.com/dashboard-gallery/dora-metrics-dashboard-devops-team/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Hands-on Automating Infrastructure and CI/CD with GitOps'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will get hands-on experience with automating infrastructure
    and CI/CD processes using GitOps. You will explore specific implementations on
    platforms such as OpenShift, Azure, and AWS, and integrate tools such as Terraform
    and Flux CD for enhanced automation. This practical section is designed to equip
    you with the necessary skills to apply GitOps in diverse environments, ensuring
    you can manage infrastructure and CI/CD pipelines effectively and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B22100_08.xhtml#_idTextAnchor165), GitOps for OpenShift'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B22100_09.xhtml#_idTextAnchor176), GitOps for Azure and AWS Deployments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B22100_10.xhtml#_idTextAnchor190), GitOps for Infrastructure
    Automation – Terraform and Flux CD'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B22100_11.xhtml#_idTextAnchor209), Deploying Real-World Projects
    with GitOps on Kubernetes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
