- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging and Troubleshooting Kubernetes Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have identified the attack vectors for Kubernetes Secrets. Two of
    them are encryption at rest and encryption in transit. Previously, in [*Chapter
    3*](B20970_03.xhtml#_idTextAnchor064), *Encrypting Secrets the Kubernetes-Native
    Way*, encryption at rest helped us increase our security at rest and in transit.
    In this chapter, we will focus on debugging issues that we might have with Secrets.
    Secrets play a critical role in storing and providing sensitive information used
    by applications and services running in a Kubernetes environment. They are crucial
    to our applications, and understanding how to effectively troubleshoot Secret-related
    issues can save lots of time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will expand on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion of common issues with Kubernetes Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging and troubleshooting Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for debugging and troubleshooting Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, we will have acquired the knowledge needed to tackle
    secret-related challenges effectively. Also, we should be able to follow certain
    workarounds and avoid common pitfalls when troubleshooting Secret-related issues.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To link concepts with practice, we will use a series of tools and platforms
    commonly used to interact with containers, Kubernetes, and Secrets management.
    For this chapter, we need the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker** ([https://docker.com](https://docker.com)) or Podman ([https://podman.io](https://podman.io))
    as a container engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Golang** ([https://go.dev](https://go.dev)), or Go, which is a programming
    language used within our examples. Note that Kubernetes and most of its third-party
    components are written in Go.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**minikube** ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
    allows us to run a single-node Kubernetes cluster on our personal computers, making
    it perfect for learning and development purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git** ([https://git-scm.com](https://git-scm.com)) is a version control system
    that we will be using to recover the book examples but also leverage our discovery
    of Secrets management solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Helm** ([https://helm.sh](https://helm.sh)) is a package manager for Kubernetes
    that we will be using to simplify the deployment and management of Kubernetes
    resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GnuPG** ([https://gnupg.org/download/](https://gnupg.org/download/)) is a
    free open source implementation of OpenPGP. OpenPGP provides cryptographic privacy
    and authentication for data communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following link gives you access to the digital materials used in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The GitHub repository: [https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that reference to Kubernetes distributions such as Azure Kubernetes Engine,
    Rancher Kubernetes Engine, and Red Hat OpenShift will be made but you donâ€™t need
    working instances of these to perform the hands-on exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion of common issues with Kubernetes Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the previous chapters, we interacted with Kubernetes either through
    direct commands or by using YAML files. While applying those YAML specifications
    and applying the commands, some mistakes are very likely to occur along the way.
    An incorrect Secret name or YAML definition can introduce hours of troubleshooting
    to identify what caused the issue in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'For these reasons, certain principles need to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: YAML files are structured and can create a source of truth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusability of Secrets minimizes errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation removes human intervention, which is prone to error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a Secret eagerly every time we want to use it through the command line
    makes it easy to introduce an error in the specification. By having the Secret
    defined through a YAML file, it is easy to check the structure through an editor
    and to ensure that we have the desired outcome. Also, a YAML file gives the flexibility
    to apply the same Secret multiple times. In case of an error, the same file can
    be fixed and applied.
  prefs: []
  type: TYPE_NORMAL
- en: The other principal is a Secret's reusability. The reusability can happen in
    multiple ways. The more you apply the creation of the same Secret each time, the
    more likely you will encounter an error. A Secret that can reside in a namespace
    can be used by various components.
  prefs: []
  type: TYPE_NORMAL
- en: Helm and Helm Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to providing encryption and decryption capabilities for Secrets
    on Helm charts, we have the option of the Helm Secrets plugin. With Helm Secrets,
    we can encrypt sensitive data and the confidential information that resides on
    Kubernetes Secrets such as passwords, certificates, keys, and so on. There are
    various encryption options available when it comes to Helm Secrets. There are
    cloud KMS options such as AWS KMS and GCP KMS. There is also a non-vendor-based
    option, which is encryption through the `gpg` command-line tool, an implementation
    of the OpenPGP standard.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a PGP key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the options to encrypt a file with Helm Secrets is to use a PGP key.
    PGP uses public key encryption; a public and private key pair are used. The public
    key is used to encrypt the data and the private key to decrypt the data. The public
    key can be distributed, whereas the private key should be kept secret. Information
    can be encrypted by anyone who has access to the public key; however, the decryption
    can happen only through the actor holding the encryption key.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a PGP key is not available, we can generate one as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command will generate the key with some default options, for example, expiration
    after one year and a default key size. By using the `--full-generate-key` function,
    there are more options during key creation.
  prefs: []
  type: TYPE_NORMAL
- en: A prompt will ask for a passphrase; ignore this prompt and leave it empty. If
    the passphrase is not left empty, it will be required at every step of decryption
    making operations difficult to automate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can list the keys and retrieve the key we already created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a key generated, we can proceed with encrypting Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting Secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Supposing we have this file with Helm values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Provided we already have a GPG key, Helm Secrets will use it in order to encrypt
    the sensitive values. We need to create a `.sops.yaml` file specifying the GPG
    key to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can just encrypt the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Eventually, our file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Helm and Helm Secrets are two of the many tools that can help us organize our
    Secrets in a structured format and keep them secured and encrypted on disk. Helm
    and Helm Secrets are examples of keeping Secrets in a YAML format and reusing
    them through templating.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, automation and proper Secret organization can not only give us
    productivity gains but also help a lot in removing the need for human intervention.
    Most of the time, when an error is introduced, it is highly likely to be caused
    by human intervention.
  prefs: []
  type: TYPE_NORMAL
- en: Secret application pitfalls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the creation of Kubernetes Secrets, we might encounter errors, which
    can occur due to several reasons. An error may come from an invalid YAML syntax,
    invalid Secret type, missing data, or bad encoding. On the bright side, failing
    to apply a Secret properly gives us immediate feedback. A dry run can help us
    to validate our operations before executing them.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Take note that all the Kubernetes commands executed take effect on the default
    namespace unless specified otherwise or configured through the Kubernetes context.
    The following commands will take effect on the default namespace or the namespace
    that has been configured.
  prefs: []
  type: TYPE_NORMAL
- en: Dry run
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before applying a Kubernetes Secret, we can simulate the creation or update
    of the Secret by using the `--dry-run` option. By using `--dry-run` along with
    the `kubectl` commands, we do not actually perform any operation. It is a helpful
    feature for testing and validating our Secret configurations before applying them,
    thus saving time from troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we want to create a Secret from literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This output can confirm that our action will be successful. We can go one step
    further and produce a response in YAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The dry run can help us validate the operation without applying it, and we can
    validate the outcome of the operations without the operation taking any effect.
    Though the `--dry-run` option is extremely useful, it cannot be of help with Secrets
    that are successfully applied containing invalid data content. A common issue
    is the Base64 formatting of a Secret.
  prefs: []
  type: TYPE_NORMAL
- en: Base64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Base64 format is used for representing Secret values. By default, when applying
    a Secret, if the value is in plain text, it will be encoded and stored in the
    Base64 format. Also, instead of supplying the value in plain text, we can submit
    a value already encoded in the Base64 format. This might cause an issue if the
    value that we want to submit is by its nature Base64-encoded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, an AES-256 key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The AES key printed is already encoded using Base64\. Through Base64 encoding,
    binary data is represented in a format of printable ASCII characters. This makes
    it easier to pass in our codebase, for example, through environment variables.
    Also, we printed the MD5 hash of the Secret, and we will use the hash for troubleshooting
    purposes later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us try now to create a Secret using the AES-256 key we created previously
    using the `openssl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the Secret has been encoded. If we try to mount the Secret in
    a Pod, it will contain the right value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We applied it, so letâ€™s check the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The checksums match. As you see, we preferred to use an MD5 hash over just printing
    the variable. Printing variables in a live environment might lead to a data leak.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will try the same through a YAML file, but we shall not encode the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we try to use the key through an environment variable on a Pod, we face
    an issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The MD5 hash is different. This is because the key was passed to the Pod in
    binary format. Kubernetes identified that the Secret is in the Base64 format;
    therefore, by creating the Pod, it decoded the AES key and placed the binary as
    an environment variable. This can create confusion and hours of debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Specific Secret types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes provides us with specific Secret types. This might give us the impression
    that before applying a Secret, certain checks take place concerning the format
    of the Secrets. This behavior might vary based on the type of Secret.
  prefs: []
  type: TYPE_NORMAL
- en: TLS Secret
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we apply TLS Secrets, Kubernetes will not perform any checks with regard
    to the content of the Secrets. For example, we will try to create a TLS Secret
    using invalid certificates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We might think that there would be a check when applying the Secret; however,
    this will not happen. The Secret will be created and eventually, it will cause
    issues once a resource tries to mount and use it.
  prefs: []
  type: TYPE_NORMAL
- en: Basic auth Secrets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Basic auth Secrets fall in the same category as TLS Secrets. There are no validation
    checks when basic auth Secrets are being applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The Secret is applied, although it is obviously wrong. A `basic-auth` Secret
    should have a username and a password; however, we added variables of different
    names.
  prefs: []
  type: TYPE_NORMAL
- en: docker config Secret
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the case of docker config Secrets, Kubernetes will perform validation and
    issue an error in the case of an invalid Kubernetes configuration. We will try
    to apply a Secret containing an invalid Docker configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the following command, the file will not be applied. The docker
    config we provided is the wrong one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The errors we get when applying a Secret can vary. Sometimes, we might even
    create an erroneous Secret without receiving any feedback.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have identified issues we could face during the application of the
    Secrets and how we could use dry runs to our advantage. We have also identified
    cases where the Secret application is correct but the content of the actual Secret
    is incorrect. Last, but not least, we have had an overview of the types of Secrets
    that Kubernetes may or may not apply any validations to. This brings us to the
    next section on troubleshooting Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging and troubleshooting Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging Kubernetes Secrets is hard. This is largely because issues with Secrets
    materialize mainly when another component dependent on them is failing. For example,
    imagine an ingress deployment with bad certificates. Identifying the actual issue
    will be a process of inspecting multiple components until you find the root cause.
    In this section, we will learn tools and approaches for troubleshooting common
    Secret issues such as non-existent Secrets, badly configured Secrets, and more.
  prefs: []
  type: TYPE_NORMAL
- en: The describe command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, `kubectl get` has been our main command to retrieve information about
    Kubernetes resources. As a command, it can provide a quick way to retrieve information
    on the resources of interest and their status. The `kubectl get` function can
    serve us only to a certain level, however. Once more information is needed, we
    should utilize the `kubectl describe` command. By using the `kubectl describe`
    command, we can retrieve detailed information for Kubernetes resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supposing we have an Nginx deployment Pod in our Kubernetes cluster, we will
    describe the deployment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `kubectl describe` command provides us with all the information needed for
    the resource of interest. As we can see, it can list events, labels, annotations,
    and even properties that apply only to the resource examined.
  prefs: []
  type: TYPE_NORMAL
- en: Non-existing Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will utilize the `describe` command for a deployment that tries to use a
    Secret that does not exist. Our example will try to mount a Secret volume that
    is non-existent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since we specified a deployment, we will not be confronted with an error immediately.
    Our deployment will get into a continuous `ContainerCreating` state until the
    Secret is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, by using the `describe` command, we shall get the information
    that would assist us in identifying the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the `describe` command, we can see that the Secret is not available.
  prefs: []
  type: TYPE_NORMAL
- en: The feedback from badly mounted volumes is not immediately visible. This is
    not the case when Secrets are mapped to environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, an Nginx Pod acquiring its environment variables through
    a Secret that does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us apply the configuration. After some seconds, we will see that the Pod
    is not able to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We shall use the `describe` command to dig deeper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the Pod is not able to start since the Secret is missing. This
    is something that we detected because of the `describe` command.
  prefs: []
  type: TYPE_NORMAL
- en: Badly configured Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Badly configured Secrets are the reason you could spend hours on debugging.
    They can expand to multiple components in an application being affected and lead
    to extensive troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: A complex scenario can be an ingress with invalid SSL certificates. We previously
    created an SSL certificate Secret containing invalid certificates. We will create
    an ingress that will use those SSL certificates and try to identify the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Secrets we shall apply are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The ingress is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'At some point, the ingress will be operational. We can check this using the
    `kubectl get` `ing` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Eventually, by reaching the ingress through the browser, we will see a certificate
    that has been generated by Kubernetes. If we donâ€™t provide a certificate by ourselves
    or we provide a bad certificate configuration, Kubernetes will generate a certificate
    on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step would be to check the Kubernetes events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, based on our previous work, we can see the events just for the ingress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Eventually, we will have to identify the problem by checking the controller
    logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The logs will lead us to the badly configured certificate. This is where our
    focus will be.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting and observability solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our troubleshooting has so far involved the usage of `kubectl`, which is not
    always feasible. Depending on the organization, there can be various observability
    solutions integrated with a Kubernetes installation. For example, Datadog is a
    popular observability solution. In the case of a cloud-based Kubernetes offering,
    the observability tools offered by a cloud provider are integrated with the Kubernetes
    offering. That means tools such as CloudWatch and Google Cloud Monitoring can
    help us to identify the incidents without the usage of `kubectl`. We will see
    more on this topic in [*Chapter 8*](B20970_08.xhtml#_idTextAnchor157), *Exploring
    Cloud Secret Store on AWS*, [*Chapter 9*](B20970_09.xhtml#_idTextAnchor176), *Exploring
    Cloud Secret Store on Azure*, and [*Chapter 10*](B20970_10.xhtml#_idTextAnchor193),
    *Exploring Cloud Secret Store* *on GCP*.
  prefs: []
  type: TYPE_NORMAL
- en: We saw certain scenarios of badly configured Secrets. In order to identify the
    cause, we followed a process and used tools such as `describe`, and we checked
    the logs of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for debugging and troubleshooting Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a Secret is wrong, it can affect us in ways that are not immediately visible.
    A top-down approach can be used where we start by checking the actual application
    that is affected. Eventually, we will reach a point where the logs will point
    to the misconfigured Secret. Once we reach the Secret, we should identify whether
    the Secret has been applied correctly or whether it is a wrong Secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could make a checklist when evaluating the Secret:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the existence of the Secret.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the value of the Secret.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decode the Secret and see whether it is the desired one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use MD5 hashing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Avoid downloading Secrets locally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next thing to check is whether the application of the Secret is wrong. Imagine
    a scenario where a Secret is mounted on a Pod of a deployment incorrectly. There
    is the option to continuously try to change the deployment and eventually figure
    out along the way what is wrong. However, this might not give the best results.
    It is very easy to continuously apply trial and error until you figure out what
    is not working, but this will consume time and also make it difficult to distinguish
    what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: There are many things that can go wrong in an application. This translates to
    noise that makes it difficult to identify the problem. Ruling out that the Secrets
    are not the problem brings us closer to a resolution. Secrets are already a complex
    concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'A way to rule out that the Secret usage is wrong can be by using a simple Docker
    container and mounting the Secrets there. A simpler container is less complex
    and minimizes what can go wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: Mount the Secrets as environment variables to a Pod.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount the Secrets as a file to a Pod.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the hash algorithm of your choice to make sure they are the expected Secret.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By following this approach, the possibility of any Kubernetes issues being caused
    by the Secrets are minimized.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding leaking Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is essential to avoid leaking any Secrets when troubleshooting. When you
    have an issue with a Secret, it is very tempting to open a terminal session to
    a Kubernetes Pod and run troubleshooting commands. The logs generated in a container
    are written to the standard output (`stdout`) and standard error (`stderr`) streams.
    Kubernetes is integrated with many popular logging solutions such as AWS CloudWatch,
    Datadog, and Google Cloud Monitoring. By printing Secrets on a Pod, those Secrets
    are written to those streams and will end up in one of the integrated logging
    solutions. A logging solution can be widely accessible in an organization â€“ more
    accessible than direct Secret access on a Kubernetes cluster. The outcome of this
    action is a data leak, and as soon as this happens, the Secrets have to be revoked
    causing extra overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Another best practice is to avoid downloading the Secrets locally when troubleshooting.
    Downloading the Secrets locally could lead to a violation of the information security
    policies that an organization has established.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went further into the details of debugging Kubernetes Secrets
    and focused on troubleshooting and debugging common issues faced with Secrets
    within our Kubernetes clusters. We learned how essential it is to keep Secrets
    organized and follow best practices, and how human error can introduce hours of
    troubleshooting. We also went through the process of identifying issues with Secrets
    and tools that we could use to get to the root of the problem. In the next chapter,
    we will focus on security and compliance when it comes to Kubernetes Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Advanced Topics â€“ Kubernetes Secrets in a Production Environment'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will explore more advanced topics related to Kubernetes Secrets,
    including security and compliance considerations, risk mitigation strategies,
    and disaster recovery and backup plans. Toward the end, you will learn more about
    mitigating security risks and how to establish a disaster recovery plan and backup
    strategies for Kubernetes Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B20970_05.xhtml#_idTextAnchor092), *Security, Auditing, and Compliance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B20970_06.xhtml#_idTextAnchor117), *Disaster Recovery and Backups*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B20970_07.xhtml#_idTextAnchor142), *Challenges and Risks in Managing
    Secrets*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
