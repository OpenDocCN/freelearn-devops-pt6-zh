- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Debugging and Troubleshooting Kubernetes Secrets
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和故障排除 Kubernetes Secrets
- en: So far, we have identified the attack vectors for Kubernetes Secrets. Two of
    them are encryption at rest and encryption in transit. Previously, in [*Chapter
    3*](B20970_03.xhtml#_idTextAnchor064), *Encrypting Secrets the Kubernetes-Native
    Way*, encryption at rest helped us increase our security at rest and in transit.
    In this chapter, we will focus on debugging issues that we might have with Secrets.
    Secrets play a critical role in storing and providing sensitive information used
    by applications and services running in a Kubernetes environment. They are crucial
    to our applications, and understanding how to effectively troubleshoot Secret-related
    issues can save lots of time and effort.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确定了 Kubernetes Secrets 的攻击面。其中两个是静态加密和传输加密。之前，在 [*第 3 章*](B20970_03.xhtml#_idTextAnchor064)，*Kubernetes
    本地方式加密 Secrets* 中，静态加密帮助我们增强了静态和传输中的安全性。在本章中，我们将重点讨论可能与 Secrets 相关的调试问题。Secrets
    在存储和提供 Kubernetes 环境中运行的应用程序和服务所需的敏感信息方面起着至关重要的作用。它们对我们的应用程序至关重要，了解如何有效地调试与 Secrets
    相关的问题可以节省大量的时间和精力。
- en: 'In this chapter, we will expand on the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展以下主题：
- en: Discussion of common issues with Kubernetes Secrets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论 Kubernetes Secrets 的常见问题
- en: Debugging and troubleshooting Secrets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试和故障排除 Secrets
- en: Best practices for debugging and troubleshooting Secrets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试和故障排除 Secrets 的最佳实践
- en: By the end of the chapter, we will have acquired the knowledge needed to tackle
    secret-related challenges effectively. Also, we should be able to follow certain
    workarounds and avoid common pitfalls when troubleshooting Secret-related issues.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将掌握处理与密钥相关挑战的知识。同时，我们应该能够遵循一些解决方法，避免在调试与 Secret 相关问题时常见的陷阱。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To link concepts with practice, we will use a series of tools and platforms
    commonly used to interact with containers, Kubernetes, and Secrets management.
    For this chapter, we need the following tools:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将概念与实践相结合，我们将使用一系列常用的工具和平台来与容器、Kubernetes 和密钥管理进行交互。对于本章，我们需要以下工具：
- en: '**Docker** ([https://docker.com](https://docker.com)) or Podman ([https://podman.io](https://podman.io))
    as a container engine.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker** ([https://docker.com](https://docker.com)) 或 Podman ([https://podman.io](https://podman.io))
    作为容器引擎。'
- en: '**Golang** ([https://go.dev](https://go.dev)), or Go, which is a programming
    language used within our examples. Note that Kubernetes and most of its third-party
    components are written in Go.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Golang** ([https://go.dev](https://go.dev))，或 Go，是我们示例中使用的编程语言。请注意，Kubernetes
    及其大多数第三方组件都是用 Go 编写的。'
- en: '**minikube** ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
    allows us to run a single-node Kubernetes cluster on our personal computers, making
    it perfect for learning and development purposes.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**minikube** ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
    允许我们在个人电脑上运行单节点的 Kubernetes 集群，非常适合用于学习和开发目的。'
- en: '**Git** ([https://git-scm.com](https://git-scm.com)) is a version control system
    that we will be using to recover the book examples but also leverage our discovery
    of Secrets management solutions.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git** ([https://git-scm.com](https://git-scm.com)) 是一个版本控制系统，我们将使用它来恢复书中的示例，同时利用我们对
    Secrets 管理解决方案的发现。'
- en: '**Helm** ([https://helm.sh](https://helm.sh)) is a package manager for Kubernetes
    that we will be using to simplify the deployment and management of Kubernetes
    resources.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Helm** ([https://helm.sh](https://helm.sh)) 是一个用于 Kubernetes 的包管理工具，我们将使用它来简化
    Kubernetes 资源的部署和管理。'
- en: '**GnuPG** ([https://gnupg.org/download/](https://gnupg.org/download/)) is a
    free open source implementation of OpenPGP. OpenPGP provides cryptographic privacy
    and authentication for data communication.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GnuPG** ([https://gnupg.org/download/](https://gnupg.org/download/)) 是 OpenPGP
    的免费开源实现。OpenPGP 为数据通信提供加密隐私和身份验证。'
- en: 'The following link gives you access to the digital materials used in this book:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接提供了本书中使用的数字材料：
- en: 'The GitHub repository: [https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 仓库：[https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook)
- en: Note that reference to Kubernetes distributions such as Azure Kubernetes Engine,
    Rancher Kubernetes Engine, and Red Hat OpenShift will be made but you don’t need
    working instances of these to perform the hands-on exercises.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将提到 Kubernetes 发行版，如 Azure Kubernetes Engine、Rancher Kubernetes Engine 和
    Red Hat OpenShift，但你不需要这些工作实例来执行动手练习。
- en: Discussion of common issues with Kubernetes Secrets
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论 Kubernetes Secrets 中常见的问题。
- en: Throughout the previous chapters, we interacted with Kubernetes either through
    direct commands or by using YAML files. While applying those YAML specifications
    and applying the commands, some mistakes are very likely to occur along the way.
    An incorrect Secret name or YAML definition can introduce hours of troubleshooting
    to identify what caused the issue in the first place.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们通过直接命令或使用 YAML 文件与 Kubernetes 进行交互。在应用这些 YAML 规范并执行命令时，沿途很容易出现一些错误。错误的
    Secret 名称或 YAML 定义可能会导致大量的故障排除工作，以确定最初导致问题的原因。
- en: 'For these reasons, certain principles need to be followed:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些原因，需要遵循某些原则：
- en: YAML files are structured and can create a source of truth
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML 文件是结构化的，可以作为可信数据源。
- en: Reusability of Secrets minimizes errors
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Secret 的可重用性最小化了错误。
- en: Automation removes human intervention, which is prone to error
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化消除了容易出错的人为干预。
- en: Applying a Secret eagerly every time we want to use it through the command line
    makes it easy to introduce an error in the specification. By having the Secret
    defined through a YAML file, it is easy to check the structure through an editor
    and to ensure that we have the desired outcome. Also, a YAML file gives the flexibility
    to apply the same Secret multiple times. In case of an error, the same file can
    be fixed and applied.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们通过命令行想要使用 Secret 时都迫切地应用它，容易在规范中引入错误。通过 YAML 文件定义 Secret，使得通过编辑器检查结构变得容易，并确保我们得到了期望的结果。此外，YAML
    文件提供了多次应用相同 Secret 的灵活性。如果发生错误，可以修复相同的文件并重新应用。
- en: The other principal is a Secret's reusability. The reusability can happen in
    multiple ways. The more you apply the creation of the same Secret each time, the
    more likely you will encounter an error. A Secret that can reside in a namespace
    can be used by various components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原则是 Secret 的可重用性。可重用性可以通过多种方式实现。每次应用相同的 Secret 创建时，你遇到错误的可能性就越大。可以驻留在命名空间中的
    Secret 可以被不同的组件使用。
- en: Helm and Helm Secrets
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm 和 Helm Secrets
- en: When it comes to providing encryption and decryption capabilities for Secrets
    on Helm charts, we have the option of the Helm Secrets plugin. With Helm Secrets,
    we can encrypt sensitive data and the confidential information that resides on
    Kubernetes Secrets such as passwords, certificates, keys, and so on. There are
    various encryption options available when it comes to Helm Secrets. There are
    cloud KMS options such as AWS KMS and GCP KMS. There is also a non-vendor-based
    option, which is encryption through the `gpg` command-line tool, an implementation
    of the OpenPGP standard.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到为 Helm 图表上的 Secrets 提供加密和解密功能时，我们可以选择 Helm Secrets 插件。使用 Helm Secrets，我们可以加密敏感数据以及驻留在
    Kubernetes Secrets 中的机密信息，如密码、证书、密钥等。在 Helm Secrets 中有多种加密选项。包括 AWS KMS 和 GCP
    KMS 等云 KMS 选项。还有一种非供应商依赖的选项，即通过 `gpg` 命令行工具进行加密，它是 OpenPGP 标准的一个实现。
- en: Creating a PGP key
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 PGP 密钥
- en: One of the options to encrypt a file with Helm Secrets is to use a PGP key.
    PGP uses public key encryption; a public and private key pair are used. The public
    key is used to encrypt the data and the private key to decrypt the data. The public
    key can be distributed, whereas the private key should be kept secret. Information
    can be encrypted by anyone who has access to the public key; however, the decryption
    can happen only through the actor holding the encryption key.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Helm Secrets 加密文件的一种选择是使用 PGP 密钥。PGP 使用公钥加密；使用公钥和私钥对。公钥用于加密数据，私钥用于解密数据。公钥可以分发，而私钥应保持机密。任何拥有公钥的人都可以加密信息；然而，解密只能通过持有加密密钥的参与者进行。
- en: 'If a PGP key is not available, we can generate one as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 PGP 密钥，我们可以按照以下步骤生成一个：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command will generate the key with some default options, for example, expiration
    after one year and a default key size. By using the `--full-generate-key` function,
    there are more options during key creation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将生成带有一些默认选项的密钥，例如一年后过期和默认密钥大小。通过使用 `--full-generate-key` 功能，密钥创建时有更多选项。
- en: A prompt will ask for a passphrase; ignore this prompt and leave it empty. If
    the passphrase is not left empty, it will be required at every step of decryption
    making operations difficult to automate.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 会出现一个提示要求输入密码短语；忽略此提示并留空。如果未留空密码短语，则在每次解密时都需要输入，这使得操作难以自动化。
- en: 'We can list the keys and retrieve the key we already created:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以列出密钥并检索我们已经创建的密钥：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have a key generated, we can proceed with encrypting Secrets.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经生成了密钥，可以继续加密 Secrets。
- en: Encrypting Secrets
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密 Secrets
- en: 'Supposing we have this file with Helm values:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有这个包含 Helm 值的文件：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Provided we already have a GPG key, Helm Secrets will use it in order to encrypt
    the sensitive values. We need to create a `.sops.yaml` file specifying the GPG
    key to be used:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经拥有 GPG 密钥，Helm Secrets 将使用它来加密敏感值。我们需要创建一个 `.sops.yaml` 文件，指定要使用的 GPG
    密钥：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we can just encrypt the values:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以加密这些值：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Eventually, our file should look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们的文件应该看起来像这样：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Helm and Helm Secrets are two of the many tools that can help us organize our
    Secrets in a structured format and keep them secured and encrypted on disk. Helm
    and Helm Secrets are examples of keeping Secrets in a YAML format and reusing
    them through templating.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 和 Helm Secrets 是许多工具中的两个，它们可以帮助我们以结构化格式组织我们的 Secrets，并将其保存在磁盘上加密和安全。Helm
    和 Helm Secrets 是将 Secrets 保存在 YAML 格式中并通过模板化重用的例子。
- en: To summarize, automation and proper Secret organization can not only give us
    productivity gains but also help a lot in removing the need for human intervention.
    Most of the time, when an error is introduced, it is highly likely to be caused
    by human intervention.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，自动化和适当的 Secret 组织不仅能提高我们的生产力，还能大大减少对人工干预的需求。大多数时候，当出现错误时，很可能是人为干预引起的。
- en: Secret application pitfalls
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Secret 应用陷阱
- en: During the creation of Kubernetes Secrets, we might encounter errors, which
    can occur due to several reasons. An error may come from an invalid YAML syntax,
    invalid Secret type, missing data, or bad encoding. On the bright side, failing
    to apply a Secret properly gives us immediate feedback. A dry run can help us
    to validate our operations before executing them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Kubernetes Secrets 时，我们可能会遇到错误，这些错误可能由多种原因引起。错误可能来自无效的 YAML 语法、无效的 Secret
    类型、缺失数据或编码错误。幸运的是，未能正确应用 Secret 会立即给我们反馈。干运行可以帮助我们在执行操作之前验证我们的操作。
- en: Important note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Take note that all the Kubernetes commands executed take effect on the default
    namespace unless specified otherwise or configured through the Kubernetes context.
    The following commands will take effect on the default namespace or the namespace
    that has been configured.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有执行的 Kubernetes 命令都会对默认命名空间生效，除非另行指定或通过 Kubernetes 上下文进行配置。以下命令将对默认命名空间或已配置的命名空间生效。
- en: Dry run
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 干运行
- en: Before applying a Kubernetes Secret, we can simulate the creation or update
    of the Secret by using the `--dry-run` option. By using `--dry-run` along with
    the `kubectl` commands, we do not actually perform any operation. It is a helpful
    feature for testing and validating our Secret configurations before applying them,
    thus saving time from troubleshooting.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用 Kubernetes Secret 之前，我们可以使用 `--dry-run` 选项来模拟创建或更新 Secret。通过将 `--dry-run`
    与 `kubectl` 命令一起使用，我们实际上并不会执行任何操作。这是一个有用的功能，可以帮助我们在应用之前测试和验证我们的 Secret 配置，从而节省排查问题的时间。
- en: 'For example, we want to create a Secret from literals:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们想从字面值创建一个 Secret：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This output can confirm that our action will be successful. We can go one step
    further and produce a response in YAML:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出可以确认我们的操作将会成功。我们可以更进一步，生成一个 YAML 格式的响应：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The dry run can help us validate the operation without applying it, and we can
    validate the outcome of the operations without the operation taking any effect.
    Though the `--dry-run` option is extremely useful, it cannot be of help with Secrets
    that are successfully applied containing invalid data content. A common issue
    is the Base64 formatting of a Secret.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 干运行可以帮助我们验证操作而不实际应用它，并且我们可以验证操作的结果，而操作不会产生任何效果。尽管 `--dry-run` 选项非常有用，但它无法帮助我们解决已成功应用但包含无效数据内容的
    Secrets。一个常见的问题是 Secret 的 Base64 格式问题。
- en: Base64
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Base64
- en: The Base64 format is used for representing Secret values. By default, when applying
    a Secret, if the value is in plain text, it will be encoded and stored in the
    Base64 format. Also, instead of supplying the value in plain text, we can submit
    a value already encoded in the Base64 format. This might cause an issue if the
    value that we want to submit is by its nature Base64-encoded.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Base64 格式用于表示 Secret 值。默认情况下，在应用 Secret 时，如果值是纯文本，它将被编码并以 Base64 格式存储。另外，除了提供纯文本的值外，我们也可以提交已经编码为
    Base64 格式的值。如果我们要提交的值本身是 Base64 编码的，这可能会导致问题。
- en: 'Take, for example, an AES-256 key:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，一个 AES-256 密钥：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The AES key printed is already encoded using Base64\. Through Base64 encoding,
    binary data is represented in a format of printable ASCII characters. This makes
    it easier to pass in our codebase, for example, through environment variables.
    Also, we printed the MD5 hash of the Secret, and we will use the hash for troubleshooting
    purposes later.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出来的AES密钥已经使用Base64编码。通过Base64编码，二进制数据被表示为可打印的ASCII字符格式。这使得我们可以更轻松地在代码库中传递，例如通过环境变量。另外，我们打印了Secret的MD5哈希，稍后我们将使用该哈希进行故障排除。
- en: 'Let us try now to create a Secret using the AES-256 key we created previously
    using the `openssl` command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试使用之前通过`openssl`命令创建的AES-256密钥来创建一个Secret：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we can see, the Secret has been encoded. If we try to mount the Secret in
    a Pod, it will contain the right value:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Secret已经被编码。如果我们尝试将Secret挂载到Pod中，它将包含正确的值：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We applied it, so let’s check the logs:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经应用了它，现在来查看日志：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The checksums match. As you see, we preferred to use an MD5 hash over just printing
    the variable. Printing variables in a live environment might lead to a data leak.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和匹配。如你所见，我们更喜欢使用MD5哈希，而不是直接打印变量。在生产环境中打印变量可能导致数据泄漏。
- en: 'We will try the same through a YAML file, but we shall not encode the key:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过YAML文件尝试相同的操作，但我们不会对密钥进行编码：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once we try to use the key through an environment variable on a Pod, we face
    an issue:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过Pod中的环境变量尝试使用该密钥，我们就会遇到一个问题：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The MD5 hash is different. This is because the key was passed to the Pod in
    binary format. Kubernetes identified that the Secret is in the Base64 format;
    therefore, by creating the Pod, it decoded the AES key and placed the binary as
    an environment variable. This can create confusion and hours of debugging.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: MD5哈希不同。这是因为密钥是以二进制格式传递给Pod的。Kubernetes识别到该Secret是Base64格式的；因此，在创建Pod时，它解码了AES密钥并将二进制数据作为环境变量放置。这可能会导致混淆并耗费数小时进行调试。
- en: Specific Secret types
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特定类型的Secret
- en: Kubernetes provides us with specific Secret types. This might give us the impression
    that before applying a Secret, certain checks take place concerning the format
    of the Secrets. This behavior might vary based on the type of Secret.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes为我们提供了特定类型的Secret。这可能会让我们产生一种印象，即在应用Secret之前，会进行某些检查，检查Secret的格式。此行为可能会根据Secret的类型而有所不同。
- en: TLS Secret
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TLS Secret
- en: 'When we apply TLS Secrets, Kubernetes will not perform any checks with regard
    to the content of the Secrets. For example, we will try to create a TLS Secret
    using invalid certificates:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们应用TLS Secrets时，Kubernetes不会对Secrets的内容执行任何检查。例如，我们将尝试使用无效的证书创建TLS Secret：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We might think that there would be a check when applying the Secret; however,
    this will not happen. The Secret will be created and eventually, it will cause
    issues once a resource tries to mount and use it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为应用Secret时会进行检查；然而，这种情况不会发生。Secret会被创建，最终，当资源尝试挂载并使用它时，可能会导致问题。
- en: Basic auth Secrets
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基本认证Secrets
- en: 'Basic auth Secrets fall in the same category as TLS Secrets. There are no validation
    checks when basic auth Secrets are being applied:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 基本认证Secrets与TLS Secrets属于同一类别。当应用基本认证Secrets时，不会进行验证检查：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Secret is applied, although it is obviously wrong. A `basic-auth` Secret
    should have a username and a password; however, we added variables of different
    names.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Secret已被应用，尽管它显然是错误的。`basic-auth` Secret 应该包含用户名和密码；然而，我们添加了不同名称的变量。
- en: docker config Secret
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: docker配置Secret
- en: 'In the case of docker config Secrets, Kubernetes will perform validation and
    issue an error in the case of an invalid Kubernetes configuration. We will try
    to apply a Secret containing an invalid Docker configuration:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于docker配置Secrets，Kubernetes会进行验证，并在Kubernetes配置无效时发出错误。如果我们尝试应用一个包含无效Docker配置的Secret：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we run the following command, the file will not be applied. The docker
    config we provided is the wrong one:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行以下命令时，文件将不会被应用。我们提供的docker配置是错误的：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The errors we get when applying a Secret can vary. Sometimes, we might even
    create an erroneous Secret without receiving any feedback.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 应用Secret时我们可能会遇到不同的错误。有时，我们甚至会创建一个错误的Secret，而没有收到任何反馈。
- en: So far, we have identified issues we could face during the application of the
    Secrets and how we could use dry runs to our advantage. We have also identified
    cases where the Secret application is correct but the content of the actual Secret
    is incorrect. Last, but not least, we have had an overview of the types of Secrets
    that Kubernetes may or may not apply any validations to. This brings us to the
    next section on troubleshooting Secrets.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经识别了应用Secrets时可能遇到的问题，以及如何通过dry run（模拟运行）来帮助我们。我们还识别了那些Secret应用正确但实际Secret内容错误的情况。最后但同样重要的是，我们对Kubernetes可能不对其进行任何验证的Secrets类型进行了概览。这引出了下一个关于故障排除Secrets的章节。
- en: Debugging and troubleshooting Secrets
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和故障排除Secrets
- en: Debugging Kubernetes Secrets is hard. This is largely because issues with Secrets
    materialize mainly when another component dependent on them is failing. For example,
    imagine an ingress deployment with bad certificates. Identifying the actual issue
    will be a process of inspecting multiple components until you find the root cause.
    In this section, we will learn tools and approaches for troubleshooting common
    Secret issues such as non-existent Secrets, badly configured Secrets, and more.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 调试Kubernetes Secrets是困难的。这主要是因为Secrets的问题通常是在其他依赖它们的组件失败时才会显现。例如，假设有一个Ingress部署使用了错误的证书。识别实际问题将是一个检查多个组件的过程，直到找到根本原因。在本节中，我们将学习调试常见Secret问题的工具和方法，例如不存在的Secrets、配置错误的Secrets等。
- en: The describe command
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`describe`命令'
- en: So far, `kubectl get` has been our main command to retrieve information about
    Kubernetes resources. As a command, it can provide a quick way to retrieve information
    on the resources of interest and their status. The `kubectl get` function can
    serve us only to a certain level, however. Once more information is needed, we
    should utilize the `kubectl describe` command. By using the `kubectl describe`
    command, we can retrieve detailed information for Kubernetes resources.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`kubectl get`一直是我们用来检索Kubernetes资源信息的主要命令。作为一个命令，它提供了一种快速获取感兴趣资源及其状态信息的方式。然而，`kubectl
    get`功能只能满足我们的某些需求。一旦需要更多信息，我们应该使用`kubectl describe`命令。通过使用`kubectl describe`命令，我们可以获取Kubernetes资源的详细信息。
- en: 'Supposing we have an Nginx deployment Pod in our Kubernetes cluster, we will
    describe the deployment as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在Kubernetes集群中有一个Nginx部署Pod，我们将按如下方式描述该部署：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `kubectl describe` command provides us with all the information needed for
    the resource of interest. As we can see, it can list events, labels, annotations,
    and even properties that apply only to the resource examined.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl describe`命令为我们提供了所有关于资源的必要信息。如我们所见，它可以列出事件、标签、注解，甚至是仅适用于被检查资源的属性。'
- en: Non-existing Secrets
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不存在的Secrets
- en: 'We will utilize the `describe` command for a deployment that tries to use a
    Secret that does not exist. Our example will try to mount a Secret volume that
    is non-existent:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`describe`命令来检查一个尝试使用不存在的Secret的部署。我们的示例将尝试挂载一个不存在的Secret卷：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since we specified a deployment, we will not be confronted with an error immediately.
    Our deployment will get into a continuous `ContainerCreating` state until the
    Secret is available.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们指定了一个部署，错误不会立即出现。我们的部署将进入持续的`ContainerCreating`状态，直到Secret可用。
- en: 'In this case, by using the `describe` command, we shall get the information
    that would assist us in identifying the problem:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，通过使用`describe`命令，我们将获取有助于识别问题的信息：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Thanks to the `describe` command, we can see that the Secret is not available.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`describe`命令，我们可以看到Secret不可用。
- en: The feedback from badly mounted volumes is not immediately visible. This is
    not the case when Secrets are mapped to environment variables.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 错误挂载的卷反馈不会立即显现。将Secrets映射到环境变量时，情况则不同。
- en: 'Take, for example, an Nginx Pod acquiring its environment variables through
    a Secret that does not exist:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设一个Nginx Pod通过一个不存在的Secret获取其环境变量：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let us apply the configuration. After some seconds, we will see that the Pod
    is not able to start:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用配置。几秒钟后，我们将看到Pod无法启动：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We shall use the `describe` command to dig deeper:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`describe`命令深入探讨：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As expected, the Pod is not able to start since the Secret is missing. This
    is something that we detected because of the `describe` command.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，由于Secret缺失，Pod无法启动。这是我们通过`describe`命令检测到的问题。
- en: Badly configured Secrets
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置错误的Secrets
- en: Badly configured Secrets are the reason you could spend hours on debugging.
    They can expand to multiple components in an application being affected and lead
    to extensive troubleshooting.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 配置错误的 Secrets 可能是导致你花费数小时调试的原因。它们可能会影响应用程序的多个组件，导致广泛的故障排除。
- en: A complex scenario can be an ingress with invalid SSL certificates. We previously
    created an SSL certificate Secret containing invalid certificates. We will create
    an ingress that will use those SSL certificates and try to identify the issue.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个复杂的场景可能是带有无效 SSL 证书的 ingress。我们之前创建了一个包含无效证书的 SSL 证书 Secret。我们将创建一个 ingress，使用这些
    SSL 证书并尝试识别问题。
- en: 'The Secrets we shall apply are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用的 Secrets 如下：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The ingress is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ingress 如下所示：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At some point, the ingress will be operational. We can check this using the
    `kubectl get` `ing` command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，ingress 将开始工作。我们可以使用 `kubectl get` `ing` 命令来检查：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Eventually, by reaching the ingress through the browser, we will see a certificate
    that has been generated by Kubernetes. If we don’t provide a certificate by ourselves
    or we provide a bad certificate configuration, Kubernetes will generate a certificate
    on its own.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，通过浏览器访问 ingress，我们将看到一个由 Kubernetes 生成的证书。如果我们没有提供自己的证书或提供了错误的证书配置，Kubernetes
    将自动生成一个证书。
- en: 'The first step would be to check the Kubernetes events:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段是检查 Kubernetes 事件：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Also, based on our previous work, we can see the events just for the ingress:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，根据我们之前的工作，我们可以仅查看 ingress 的事件：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Eventually, we will have to identify the problem by checking the controller
    logs:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将通过查看控制器日志来识别问题：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The logs will lead us to the badly configured certificate. This is where our
    focus will be.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 日志将引导我们找到配置错误的证书。我们的重点将在此。
- en: Troubleshooting and observability solutions
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除和可观察性解决方案
- en: Our troubleshooting has so far involved the usage of `kubectl`, which is not
    always feasible. Depending on the organization, there can be various observability
    solutions integrated with a Kubernetes installation. For example, Datadog is a
    popular observability solution. In the case of a cloud-based Kubernetes offering,
    the observability tools offered by a cloud provider are integrated with the Kubernetes
    offering. That means tools such as CloudWatch and Google Cloud Monitoring can
    help us to identify the incidents without the usage of `kubectl`. We will see
    more on this topic in [*Chapter 8*](B20970_08.xhtml#_idTextAnchor157), *Exploring
    Cloud Secret Store on AWS*, [*Chapter 9*](B20970_09.xhtml#_idTextAnchor176), *Exploring
    Cloud Secret Store on Azure*, and [*Chapter 10*](B20970_10.xhtml#_idTextAnchor193),
    *Exploring Cloud Secret Store* *on GCP*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的故障排除过程涉及了 `kubectl` 的使用，但这并非总是可行的。根据组织的不同，Kubernetes 安装中可能集成了各种可观察性解决方案。例如，Datadog
    是一个流行的可观察性解决方案。在基于云的 Kubernetes 服务中，云服务提供商提供的可观察性工具与 Kubernetes 服务集成。这意味着，像 CloudWatch
    和 Google Cloud Monitoring 这样的工具可以帮助我们在不使用 `kubectl` 的情况下识别问题。我们将在 [*第8章*](B20970_08.xhtml#_idTextAnchor157)、《探索
    AWS 上的云秘密存储》、[*第9章*](B20970_09.xhtml#_idTextAnchor176)、《探索 Azure 上的云秘密存储》以及 [*第10章*](B20970_10.xhtml#_idTextAnchor193)、《探索
    GCP 上的云秘密存储》中看到更多相关内容。
- en: We saw certain scenarios of badly configured Secrets. In order to identify the
    cause, we followed a process and used tools such as `describe`, and we checked
    the logs of Kubernetes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了一些配置错误的 Secrets 场景。为了识别原因，我们遵循了一个流程，并使用了如`describe`等工具，同时查看了 Kubernetes
    的日志。
- en: Best practices for debugging and troubleshooting Secrets
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和故障排除 Secrets 的最佳实践
- en: When a Secret is wrong, it can affect us in ways that are not immediately visible.
    A top-down approach can be used where we start by checking the actual application
    that is affected. Eventually, we will reach a point where the logs will point
    to the misconfigured Secret. Once we reach the Secret, we should identify whether
    the Secret has been applied correctly or whether it is a wrong Secret.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 Secret 错误时，它可能会以不易察觉的方式影响我们。我们可以采取自上而下的方法，从检查实际受影响的应用程序开始。最终，我们将找到日志指向配置错误的
    Secret。一旦找到该 Secret，我们应该确认它是否已正确应用，或者它是否是错误的 Secret。
- en: 'We could make a checklist when evaluating the Secret:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估 Secret 时，我们可以制作一个检查清单：
- en: Ensure the existence of the Secret.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 Secret 存在。
- en: Check the value of the Secret.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 Secret 的值。
- en: Decode the Secret and see whether it is the desired one.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码 Secret，查看它是否为期望的那个。
- en: Use MD5 hashing.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 MD5 哈希。
- en: Avoid downloading Secrets locally.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避免将 Secrets 下载到本地。
- en: The next thing to check is whether the application of the Secret is wrong. Imagine
    a scenario where a Secret is mounted on a Pod of a deployment incorrectly. There
    is the option to continuously try to change the deployment and eventually figure
    out along the way what is wrong. However, this might not give the best results.
    It is very easy to continuously apply trial and error until you figure out what
    is not working, but this will consume time and also make it difficult to distinguish
    what is happening.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要检查的是 Secret 是否应用错误。假设某个 Secret 错误地挂载到某个部署的 Pod 上。虽然可以不断尝试修改部署，最终找出问题所在，但这可能不会带来最佳结果。通过不断尝试直到发现不工作之处虽然简单，但会浪费时间，并且很难辨别实际发生了什么。
- en: There are many things that can go wrong in an application. This translates to
    noise that makes it difficult to identify the problem. Ruling out that the Secrets
    are not the problem brings us closer to a resolution. Secrets are already a complex
    concept.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 应用中可能出现的错误有很多，这会带来噪音，难以辨别问题所在。排除 Secrets 不是问题的可能性，让我们更接近问题的解决。Secrets 本身就是一个复杂的概念。
- en: 'A way to rule out that the Secret usage is wrong can be by using a simple Docker
    container and mounting the Secrets there. A simpler container is less complex
    and minimizes what can go wrong:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一种排除 Secret 使用错误的方法是使用一个简单的 Docker 容器并将 Secrets 挂载到该容器上。一个更简单的容器复杂度较低，可以最小化出错的可能性：
- en: Mount the Secrets as environment variables to a Pod.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Secrets 挂载为环境变量到 Pod。
- en: Mount the Secrets as a file to a Pod.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Secrets 挂载为文件到 Pod。
- en: Use the hash algorithm of your choice to make sure they are the expected Secret.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你选择的哈希算法确保它们是预期的 Secret。
- en: By following this approach, the possibility of any Kubernetes issues being caused
    by the Secrets are minimized.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这种方法，可以最大限度地减少由 Secrets 引起的任何 Kubernetes 问题的可能性。
- en: Avoiding leaking Secrets
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免泄露 Secrets
- en: It is essential to avoid leaking any Secrets when troubleshooting. When you
    have an issue with a Secret, it is very tempting to open a terminal session to
    a Kubernetes Pod and run troubleshooting commands. The logs generated in a container
    are written to the standard output (`stdout`) and standard error (`stderr`) streams.
    Kubernetes is integrated with many popular logging solutions such as AWS CloudWatch,
    Datadog, and Google Cloud Monitoring. By printing Secrets on a Pod, those Secrets
    are written to those streams and will end up in one of the integrated logging
    solutions. A logging solution can be widely accessible in an organization – more
    accessible than direct Secret access on a Kubernetes cluster. The outcome of this
    action is a data leak, and as soon as this happens, the Secrets have to be revoked
    causing extra overhead.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在故障排除时避免泄露任何 Secrets 是至关重要的。当你遇到 Secret 问题时，通常很容易打开终端会话，连接到 Kubernetes Pod 并运行排查命令。容器中生成的日志会被写入标准输出（`stdout`）和标准错误（`stderr`）流中。Kubernetes
    与许多流行的日志解决方案（如 AWS CloudWatch、Datadog 和 Google Cloud Monitoring）集成。通过在 Pod 上打印
    Secrets，这些 Secrets 会被写入这些流中，并最终出现在集成的日志解决方案中。日志解决方案可能在一个组织内非常容易访问——甚至比直接访问 Kubernetes
    集群中的 Secrets 还要容易。这种行为的结果是数据泄露，一旦发生，Secrets 必须被撤销，带来额外的工作量。
- en: Another best practice is to avoid downloading the Secrets locally when troubleshooting.
    Downloading the Secrets locally could lead to a violation of the information security
    policies that an organization has established.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个最佳实践是在故障排除时避免将 Secrets 下载到本地。将 Secrets 下载到本地可能会导致违反组织已制定的信息安全政策。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小结
- en: In this chapter, we went further into the details of debugging Kubernetes Secrets
    and focused on troubleshooting and debugging common issues faced with Secrets
    within our Kubernetes clusters. We learned how essential it is to keep Secrets
    organized and follow best practices, and how human error can introduce hours of
    troubleshooting. We also went through the process of identifying issues with Secrets
    and tools that we could use to get to the root of the problem. In the next chapter,
    we will focus on security and compliance when it comes to Kubernetes Secrets.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了调试 Kubernetes Secrets 的细节，并重点介绍了在 Kubernetes 集群中解决和调试与 Secrets 相关的常见问题。我们了解到保持
    Secrets 有序和遵循最佳实践的重要性，以及人为错误可能带来的数小时排查工作。我们还介绍了如何识别 Secrets 问题的过程以及可以使用的工具来找出问题的根源。在下一章中，我们将重点讨论
    Kubernetes Secrets 的安全性和合规性。
- en: 'Part 2: Advanced Topics – Kubernetes Secrets in a Production Environment'
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：高级主题 – 在生产环境中的 Kubernetes Secrets
- en: In this part, you will explore more advanced topics related to Kubernetes Secrets,
    including security and compliance considerations, risk mitigation strategies,
    and disaster recovery and backup plans. Toward the end, you will learn more about
    mitigating security risks and how to establish a disaster recovery plan and backup
    strategies for Kubernetes Secrets.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将探索与Kubernetes Secrets相关的更高级话题，包括安全性和合规性考虑、风险缓解策略以及灾难恢复和备份计划。最后，你将学习如何缓解安全风险，以及如何为Kubernetes
    Secrets建立灾难恢复计划和备份策略。
- en: 'This part has the following chapters:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 5*](B20970_05.xhtml#_idTextAnchor092), *Security, Auditing, and Compliance*'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B20970_05.xhtml#_idTextAnchor092)，*安全性、审计与合规性*'
- en: '[*Chapter 6*](B20970_06.xhtml#_idTextAnchor117), *Disaster Recovery and Backups*'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B20970_06.xhtml#_idTextAnchor117)，*灾难恢复与备份*'
- en: '[*Chapter 7*](B20970_07.xhtml#_idTextAnchor142), *Challenges and Risks in Managing
    Secrets*'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B20970_07.xhtml#_idTextAnchor142)，*管理Secrets中的挑战与风险*'
