- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes Bootcamp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter introduced you to deploying Kubernetes clusters using KinD
    (Kubernetes in Docker), which is useful for creating a development cluster on
    a single machine using containers instead of virtual machines. This approach reduces
    the system resource requirements and simplifies the entire setup process. We covered
    the installation and configuration of KinD, creating clusters, including add-ons
    like Ingress controllers, Calico as the CNI, and using persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: We understand that many of you have experience with Kubernetes, whether it’s
    running clusters in production or experimenting with tools like `kubeadm`, minikube,
    or Docker Desktop. Our intention with this book is to go beyond the fundamentals
    of Kubernetes, which is why we didn’t want to reiterate all the basics. Instead,
    we’ve included this chapter as a bootcamp for those who are new to Kubernetes
    or have only had limited exposure to it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the essential components of a Kubernetes cluster,
    including the control plane and worker nodes. We will provide detailed explanations
    of each Kubernetes resource and its respective use cases. If you have previous
    experience with Kubernetes and feel comfortable using `kubectl`, as well as an
    understanding of Kubernetes resources like **DaemonSets**, **StatefulSets**, and
    **ReplicaSets**, this chapter can serve as a helpful review before moving on to
    *Chapter 4*, where we will dive into **Services**, **Load Balancing**, **ExternalDNS**,
    **Global Balancing**, and **K8GB**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a bootcamp chapter, we won’t get into every topic in detail.
    However, by the end of this chapter, you should have a solid understanding of
    the foundational concepts of Kubernetes, which will be crucial for comprehending
    the remaining chapters. Even if you already possess a strong background in Kubernetes,
    you may find this chapter valuable as a refresher before we get into more advanced
    topics. In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Kubernetes components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the control plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the worker node components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the API server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Kubernetes resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of the most
    commonly used cluster resources. Understanding Kubernetes resources is important
    for both cluster operators and cluster administrators.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has no technical requirements.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to execute commands while learning about the resources, you can
    use the KinD cluster that was deployed in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Kubernetes components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the components of systems in an infrastructure is essential for
    delivering services effectively. In today’s wide landscape of installation options,
    many Kubernetes users may not have felt the need to fully comprehend the integration
    of different Kubernetes components.
  prefs: []
  type: TYPE_NORMAL
- en: Just a few years ago, establishing a Kubernetes cluster involved the manual
    installation and configuration of each component. This process presented a steep
    learning curve and often resulted in frustration. As a result, many individuals
    and organizations concluded that “Kubernetes is overly complex.” However, the
    benefit of manual installation was the in-depth understanding it provided regarding
    the interaction between each component. If any issues arose within the cluster
    after installation, you would have a clear understanding of where to investigate.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how Kubernetes components work together, you must first understand
    the different components of a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is from the [http://Kubernetes.io](http://Kubernetes.io)
    site and shows a high-level overview of a Kubernetes cluster component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Kubernetes cluster components ](img/B21165_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Kubernetes cluster components'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the Kubernetes cluster is made up of several components. As
    we progress through the chapter, we’ll discuss these components and the role they
    play in a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the control plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The control plane, as its name suggests, has authority over every aspect of
    a cluster. In the absence of a functioning control plane, the cluster loses its
    ability to schedule workloads, create new deployments, and manage Kubernetes objects.
    Recognizing the criticality of the control plane, it is highly advisable to deploy
    with **high availability** (**HA**) support, deploying a minimum of three control
    plane nodes. Many production environments even utilize more than three control
    plane nodes, but the key principle is to have an odd number of nodes, which is
    required so we can maintain a highly available control plane if we lose a single
    `etcd` node.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s delve into the importance of the control plane and its components,
    providing a comprehensive understanding of their pivotal role in a functioning
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes API server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first component to understand in a cluster is the `kube-apiserver` component.
    Since Kubernetes is **application programming interface** (**API**)-driven, every
    request that comes into a cluster goes through the API server. Let’s look at a
    simple `get nodes` request using an API endpoint, using the IP address for the
    control plane, which, in an enterprise, is usually fronted by a load balancer.
    In our example, our load balancer has an entry for the three control plane nodes
    on `10.240.100.100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://10.240.100.100:6443/api/v1/nodes?limit=500](https://10.240.100.100:6443/api/v1/nodes?limit=500)'
  prefs: []
  type: TYPE_NORMAL
- en: If you attempt to make an API call without any credentials, you will receive
    a permission denied request. Using a pure API request directly is something that
    is very common when creating a pipeline for application deployment or even a Kubernetes
    add-on component. However, the most common method for users to interact with Kubernetes
    is the `kubectl` utility.
  prefs: []
  type: TYPE_NORMAL
- en: Every command that is issued using `kubectl` calls an API endpoint behind the
    scenes. In the preceding example, if we executed a `kubectl get nodes` command,
    an API request would be sent to the `kube-apiserver` process using the address
    `10.240.100.100` on port `6443`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API call requested the `/api/vi/nodes` endpoint, which returned a list
    of the nodes in the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the absence of a functioning API server, all requests directed to your cluster
    will fail. Therefore, it becomes crucial to ensure the continuous operation and
    health of the `kube-apiserver`.
  prefs: []
  type: TYPE_NORMAL
- en: By running three or more control plane nodes, we minimize any potential impact
    that could be caused by the loss of a control plane node.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, from the last chapter, that when running more than one control plane
    node, you need to have a load balancer in front of the cluster’s API server. The
    Kubernetes API server can be fronted by most standard solutions, including F5,
    HAProxy, and Seesaw.
  prefs: []
  type: TYPE_NORMAL
- en: The etcd database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Describing `etcd` as the foundation of your Kubernetes cluster would not be
    an overstatement. `etcd` functions as a robust and highly efficient distributed
    key-value database that Kubernetes relies on to store all cluster data. Every
    resource present within the cluster is associated with a specific key in the `etcd`
    database. If you can access the node or pod that hosts `etcd`, you `will` be able
    to use the `etcdctl` executable to explore all the keys stored within the database.
    The code snippet provided below offers an example extracted from a cluster based
    on KinD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The output from the preceding command contains too much data to list it all
    in this chapter. A base KinD cluster will return approximately 314 entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'All keys start with `/registry/<resource>`. For example, one of the keys that
    was returned is the `ClusterRole` for the `cluster-admin` key, as follows: `/registry/clusterrolebindings/cluster-admin`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the key name to retrieve the value using the `etcdctl` utility by
    slightly modifying our previous command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will contain characters that cannot be interpreted by your shell,
    but you will get an idea of the data stored in `etcd`. For the `cluster-admin`
    key, the output shows us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We describe the entries in `etcd` to offer an understanding of how Kubernetes
    stores and utilizes data to manage cluster objects. While you’ve already observed
    the direct database output for the `cluster-admin` key, in typical scenarios,
    you would utilize the command `kubectl get clusterrolebinding cluster-admin -o
    yaml` to query the API server for the same data. Using `kubectl`, the command
    would yield the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: kubectl ClusterRoleBinding output'
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the output from the `kubectl` command and compare it with the
    output from the `etcdctl` query, you will see matching information. You will rarely
    have to interact with `etcd` directly; instead, you will execute `kubectl` commands,
    and the request will go to the API server, which then queries the `etcd` database
    for the resource’s information.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that while `etcd` is by far the most used backend database
    for Kubernetes, it isn’t the only one. The **k3s** project, which was originally
    built to strip down Kubernetes for edge use cases, replaced `etcd` with relational
    databases. When we dive into `vclusters`, which use k3s, we’ll see that it uses
    **SQLite** instead of `etcd`.
  prefs: []
  type: TYPE_NORMAL
- en: kube-scheduler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As its name suggests, the `kube-scheduler` component oversees the allocation
    of pods to nodes. Its primary task is to consistently monitor pods that have yet
    to be assigned to any specific node. The scheduler then assesses the resource
    requirements of each pod to determine the most suitable placement. This assessment
    takes multiple factors into account, including the availability of node resources,
    constraints, selectors, and affinity/anti-affinity rules. Nodes that satisfy these
    requirements are considered feasible nodes. Finally, from the resulting list of
    compatible nodes, the scheduler chooses the most appropriate one for scheduling
    the pod.
  prefs: []
  type: TYPE_NORMAL
- en: kube-controller-manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Kubernetes Controller Manager** is a central control system in the Kubernetes
    control plane; it’s responsible for managing and coordinating other controllers
    that handle specific tasks for the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The Controller Manager contains multiple controllers, each dedicated to a specific
    function within the cluster. These controllers continuously monitor the cluster’s
    current state and adapt dynamically to maintain the desired configuration.
  prefs: []
  type: TYPE_NORMAL
- en: All of the controllers are contained in a single executable, reducing complexity
    and management. Some of the controllers included are shown in *Table 3.1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each controller provides a unique function to a cluster, and each controller
    and its function is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Controller** | **Responsibilities** |'
  prefs: []
  type: TYPE_TB
- en: '| Endpoints | Monitors new services and creates endpoints to the pods with
    matching labels |'
  prefs: []
  type: TYPE_TB
- en: '| Namespace | Monitors actions for namespaces |'
  prefs: []
  type: TYPE_TB
- en: '| Node | Monitors the status of nodes in the cluster, detecting node failures
    or additions, and taking appropriate actions to maintain the desired number of
    nodes |'
  prefs: []
  type: TYPE_TB
- en: '| Replication | Monitors the replicas for pods, taking action to either remove
    a pod or add a pod to get to the desired state |'
  prefs: []
  type: TYPE_TB
- en: '| Service Accounts | Monitors Service accounts |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.1: Controllers and their functions'
  prefs: []
  type: TYPE_NORMAL
- en: Each controller runs a non-terminating (never-ending) control loop. These control
    loops monitor the state of each resource, making any changes required to normalize
    the state of the resource. For example, if you needed to scale a deployment from
    one to three nodes, the replication controller would notice that the current state
    has one pod running, and the desired state is to have three pods running. To move
    the current state to the desired state, two additional pods would be requested
    by the replication controller.
  prefs: []
  type: TYPE_NORMAL
- en: cloud-controller-manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is one component that you may not have run into, depending on how your
    clusters are configured. Similar to the `kube-controller-manager` component, this
    controller contains four controllers in a single binary.
  prefs: []
  type: TYPE_NORMAL
- en: The cloud controller provides integrations specific to a particular cloud provider’s
    Kubernetes service, enabling the utilization of cloud-specific functionalities
    such as load balancers, persistent storage, auto-scaling groups, and other features.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the worker node components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Worker nodes, as implied by their name, have the duty of carrying out tasks
    within a Kubernetes cluster. In our previous conversation about the `kube-scheduler`
    element in the control plane, we emphasized that when a new pod requires scheduling,
    the kube-scheduler selects the suitable node for its execution. The kube-scheduler
    relies on data provided by the worker nodes to make this determination. This data
    is regularly updated to ensure a distribution of pods throughout the cluster,
    making the most of the cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: Each worker node has two main components, `kubelet` and `kube-proxy`.
  prefs: []
  type: TYPE_NORMAL
- en: kubelet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may hear a worker node referred to as a `kubelet`. The `kubelet` is an agent
    that runs on all worker nodes, and it is responsible for ensuring that containers
    are running and healthy on the node.
  prefs: []
  type: TYPE_NORMAL
- en: kube-proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Contrary to the name, `kube-proxy` is not a proxy server at all (though it was
    in the original version of Kubernetes).
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the CNI deployed in your cluster, you may or may not have a `kube-proxy`
    component on your nodes. CNIs like **Cilium** can be run with `kube-proxy` or
    in a `kube-proxyless` mode. In our KinD clusters, we have deployed Calico, which
    relies on the presence of `kube-proxy`.
  prefs: []
  type: TYPE_NORMAL
- en: When `kube-proxy` is deployed, its main purpose is to oversee network connectivity
    for pods and services in the cluster, providing network traffic routing to the
    destination pod(s).
  prefs: []
  type: TYPE_NORMAL
- en: Container runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each node also needs a container runtime. A container runtime is responsible
    for running the containers. The first thing you might think of is Docker, and
    while Docker is a container runtime, it is not the only runtime option available.
    Over the last several years, other options have replaced Docker as the preferred
    container runtime for clusters.
  prefs: []
  type: TYPE_NORMAL
- en: The two most prominent Docker replacements are **CRI-O** and **containerd**.
    At the time of writing this chapter, KinD only offers official support for Docker
    and Red Hat’s **Podman**.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the API server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, you interact with the API server using either direct
    API requests or the `kubectl` utility. We will focus on using `kubectl` for the
    majority of our interaction in this book, but we will call out using direct API
    calls wherever applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Kubernetes kubectl utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`kubectl` is a single executable file that allows you to interact with the
    Kubernetes API using a **command-line interface** (**CLI**). It is available for
    most major operating systems and architectures, including Linux, Windows, and
    macOS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: We have already installed `kubectl` using the KinD script that created
    our cluster in *Chapter 2*. Installation instructions for most operating systems
    are located on the Kubernetes site at [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/).
    Since we are using Linux as our operating system for the exercises in the book,
    we will cover installing `kubectl` on a Linux machine. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To download the latest version of `kubectl`, you can run a `curl` command that
    will download it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After downloading, you need to make the file executable by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will move the executable to our path, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You now have the latest `kubectl` utility on your system and can execute `kubectl`
    commands from any working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes is updated about every 4 months. This includes upgrades to the base
    Kubernetes cluster components and the `kubectl` utility. You may run into a version
    mismatch between a cluster and your `kubectl` command, requiring you to either
    upgrade or download your `kubectl` executable. You can always check the version
    of both by running a `kubectl` `version` command, which will output the version
    of both the API server and the `kubectl` client. The output from a version check
    is shown in the following code snippet – please note, your output may differ from
    our example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, the `kubectl` client is running version `1.30.0`
    and the cluster is running `1.30.0`. A minor version difference in the two will
    not cause any issues. In fact, the official supported version difference is within
    one major version release. So, if your client is running version 1.29 and the
    cluster is running 1.30.0, you would be within the supported version difference.
    While this may be supported, it doesn’t mean that you won’t run into issues if
    you are trying to use any new commands or resources included in the higher version.
    In general, you should try to keep your cluster and client version in sync to
    avoid any issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Through the remainder of this chapter, we will discuss Kubernetes resources
    and how you interact with the API server to manage each one. But before diving
    into the different resources, we wanted to mention one commonly overlooked option
    of the `kubectl` utility: the `verbose` option.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the verbose option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you execute a `kubectl` command, the only outputs you will see by default
    are any direct responses to your command. If you were to look at all pods in the
    `kube-system` namespace, you would receive a list of all pods. In most cases,
    this is the desired output, but what if you issued a `get` `Pods` request and
    received an error from the API server? How could you get more information about
    what might be causing the error?
  prefs: []
  type: TYPE_NORMAL
- en: By adding the `verbose` option to your `kubectl` command, you can get additional
    details about the API call itself and any replies from the API server. Often,
    the replies from the API server will contain additional information that may be
    useful to find the root cause of the issue.
  prefs: []
  type: TYPE_NORMAL
- en: The `verbose` option has multiple levels ranging from 0 to 9; the higher the
    number, the more output you will receive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot has been taken from the Kubernetes site, detailing
    each level and what the output will include:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Verbosity description ](img/B21165_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Verbosity description'
  prefs: []
  type: TYPE_NORMAL
- en: You can experiment with the levels by adding the `-v` or `--v` option to any
    `kubectl` command.
  prefs: []
  type: TYPE_NORMAL
- en: General kubectl commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CLI allows you to interact with Kubernetes in an imperative and declarative
    manner. Using an imperative command involves you telling Kubernetes what to do—for
    example, `kubectl run nginx --image nginx`. This tells the API server to create
    a new pod called `nginx` that runs an image called `nginx`. While imperative commands
    are useful for development and quick fixes or testing, you will use declarative
    commands more often in a production environment. In a declarative command, you
    tell Kubernetes what you want. To use declarative commands, you send a manifest
    to the API server, written in either **JavaScript Object Notation** (**JSON**)
    or **YAML Ain’t Markup Language** (**YAML**), which declares what you want Kubernetes
    to create.
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl` includes commands and options that can provide general cluster information
    or information about a resource. The table below contains a cheat sheet of commands
    and what they are used for. We will use many of these commands in future chapters,
    so you will see them in action throughout the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Cluster Commands** |'
  prefs: []
  type: TYPE_TB
- en: '| `api-resources` | Lists supported API resources |'
  prefs: []
  type: TYPE_TB
- en: '| `api-versions` | Lists supported API versions |'
  prefs: []
  type: TYPE_TB
- en: '| `cluster-info` | Lists cluster information, including the API server and
    other cluster endpoints |'
  prefs: []
  type: TYPE_TB
- en: '| **Object Commands** |'
  prefs: []
  type: TYPE_TB
- en: '| `get <object>` | Retrieves a list of all objects (i.e., pods, ingress, etc.)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `describe <object>` | Provides details for the object |'
  prefs: []
  type: TYPE_TB
- en: '| `logs <pod name>` | Retrieve the logs for a pod |'
  prefs: []
  type: TYPE_TB
- en: '| `edit <object>` | Edits an object interactively |'
  prefs: []
  type: TYPE_TB
- en: '| `delete <object>` | Deletes an object |'
  prefs: []
  type: TYPE_TB
- en: '| `label <object>` | Labels an object |'
  prefs: []
  type: TYPE_TB
- en: '| `annotate <object>` | Annotates an object |'
  prefs: []
  type: TYPE_TB
- en: '| `run` | Creates a pod |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.2: Cluster and object commands'
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of each Kubernetes component and how to interact with
    the API server using imperative commands, we can now move on to Kubernetes resources
    and how we use `kubectl` to manage them.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kubernetes resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will provide a substantial amount of information. However,
    as this is a bootcamp, we won’t go into exhaustive details about each resource.
    It’s worth noting that each resource could easily warrant its own dedicated chapter
    or even multiple chapters in a book. Since numerous books on basic Kubernetes
    already cover these resources extensively, we will focus on the essential aspects
    necessary for a basic understanding of each resource. As we progress through the
    subsequent chapters, we will supplement additional details about the resources
    as we expand our cluster using the exercises provided in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to delving into a comprehensive understanding of Kubernetes resources,
    let’s begin by introducing the concept of Kubernetes manifests.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes manifests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The files that we will use to create Kubernetes resources are referred to as
    manifests. A manifest can be created using YAML or JSON—most manifests use YAML,
    and that is the format we will use throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that while we are working with YAML files, `kubectl`
    will convert all YAML into JSON when interacting with your API server. All API
    calls are made with JSON, even if the manifests are written in YAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of a manifest will vary depending on the resource, or resources,
    that will be created. At a minimum, all manifests require a base configuration
    that includes `apiVersion`, the `kind` of resource, and `metadata` fields, as
    can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding manifest alone is not complete; we are only showing the beginning
    of a full `Deployment` manifest. As you can see in the file, we start with the
    three required fields that all manifests are required to have: the `apiVersion`,
    `kind`, and `metadata` fields.'
  prefs: []
  type: TYPE_NORMAL
- en: You may also notice that there is a format for fields in the file. YAML is very
    format-specific, and if the format of any line is off by even a single space,
    you will receive an error when you try to deploy the manifest. This takes time
    to get used to, and even after creating manifests for a long time, formatting
    issues will still pop up from time to time.
  prefs: []
  type: TYPE_NORMAL
- en: What are Kubernetes resources?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you want to add or delete something from a cluster, you are interacting
    with Kubernetes resources. This interaction is how you declare your desired state
    for the resource, which may be to create, delete, or scale a resource. Based on
    the desired state, the API server will make sure that the current state equals
    the desired state. For example, if you have a deployment that starts with a single
    replica, you can change the deployment resource from 1 to 3 replicas. When the
    API server sees that the current state is 1, it will scale the deployment out
    to 3 replicas by creating the additional 2 pods.
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve a list of resources a cluster supports, you can use the `kubectl
    api-resources` command. The API server will reply with a list of all resources,
    including any valid short name, namespace support, and supported API group.
  prefs: []
  type: TYPE_NORMAL
- en: There are approximately 58 base resources included with a Kubernetes cluster,
    but it’s very common to have many more than 58 in a production cluster. Many add-on
    components, like Calico, will extend the Kubernetes API with new objects. As a
    cluster has different add-ons deployed in the cluster, don’t be surprised at 100+
    resources in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'An abbreviated list of the most common resources is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **NAME** | **SHORT NAMES** | **API VERSION** | **NAMESPACED** |'
  prefs: []
  type: TYPE_TB
- en: '| apiservices | apiregistration.k8s.io/v1 | FALSE |  |'
  prefs: []
  type: TYPE_TB
- en: '| certificatesigningrequests | Csr | certificates.k8s.io/v1 | FALSE |'
  prefs: []
  type: TYPE_TB
- en: '| clusterrolebindings | rbac.authorization.k8s.io/v1 | FALSE |  |'
  prefs: []
  type: TYPE_TB
- en: '| clusterroles | rbac.authorization.k8s.io/v1 | FALSE |  |'
  prefs: []
  type: TYPE_TB
- en: '| componentstatuses | Cs | v1 | FALSE |'
  prefs: []
  type: TYPE_TB
- en: '| configmaps | Cm | v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| controllerrevisions | apps/v1 | TRUE |  |'
  prefs: []
  type: TYPE_TB
- en: '| cronjobs | Cj | batch/v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| csidrivers | storage.k8s.io/v1 | FALSE |  |'
  prefs: []
  type: TYPE_TB
- en: '| csinodes | storage.k8s.io/v1 | FALSE |  |'
  prefs: []
  type: TYPE_TB
- en: '| csistoragecapacities | storage.k8s.io/v1 | TRUE |  |'
  prefs: []
  type: TYPE_TB
- en: '| customresourcedefinitions | crd,crds | apiextensions.k8s.io/v1 | FALSE |'
  prefs: []
  type: TYPE_TB
- en: '| daemonsets | Ds | apps/v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| deployments | Deploy | apps/v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| endpoints | Ep | v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| endpointslices | discovery.k8s.io/v1 | TRUE |  |'
  prefs: []
  type: TYPE_TB
- en: '| events | Ev | v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| events | Ev | events.k8s.io/v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| flowschemas | flowcontrol.apiserver.k8s.io/v1beta3 | FALSE |  |'
  prefs: []
  type: TYPE_TB
- en: '| horizontalpodautoscalers | Hpa | autoscaling/v2 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| ingressclasses | networking.k8s.io/v1 | FALSE |  |'
  prefs: []
  type: TYPE_TB
- en: '| ingresses | Ing | networking.k8s.io/v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| jobs | batch/v1 | TRUE |  |'
  prefs: []
  type: TYPE_TB
- en: '| limitranges | Limits | v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| localsubjectaccessreviews | authorization.k8s.io/v1 | TRUE |  |'
  prefs: []
  type: TYPE_TB
- en: '| mutatingwebhookconfigurations | admissionregistration.k8s.io/v1 | FALSE |  |'
  prefs: []
  type: TYPE_TB
- en: '| namespaces | Ns | v1 | FALSE |'
  prefs: []
  type: TYPE_TB
- en: '| networkpolicies | Netpol | networking.k8s.io/v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| nodes | No | v1 | FALSE |'
  prefs: []
  type: TYPE_TB
- en: '| persistentvolumeclaims | Pvc | v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| persistentvolumes | pv | v1 | FALSE |'
  prefs: []
  type: TYPE_TB
- en: '| poddisruptionbudgets | pdb | policy/v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| pods | po | v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| podtemplates | v1 | TRUE |  |'
  prefs: []
  type: TYPE_TB
- en: '| priorityclasses | pc | scheduling.k8s.io/v1 | FALSE |'
  prefs: []
  type: TYPE_TB
- en: '| prioritylevelconfigurations | flowcontrol.apiserver.k8s.io/v1beta3 | FALSE
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| profiles | projectcalico.org/v3 | FALSE |  |'
  prefs: []
  type: TYPE_TB
- en: '| replicasets | rs | apps/v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| replicationcontrollers | rc | v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| resourcequotas | quota | v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| rolebindings | rbac.authorization.k8s.io/v1 | TRUE |  |'
  prefs: []
  type: TYPE_TB
- en: '| roles | rbac.authorization.k8s.io/v1 | TRUE |  |'
  prefs: []
  type: TYPE_TB
- en: '| runtimeclasses | node.k8s.io/v1 | FALSE |  |'
  prefs: []
  type: TYPE_TB
- en: '| secrets | v1 | TRUE |  |'
  prefs: []
  type: TYPE_TB
- en: '| selfsubjectaccessreviews | authorization.k8s.io/v1 | FALSE |  |'
  prefs: []
  type: TYPE_TB
- en: '| selfsubjectrulesreviews | authorization.k8s.io/v1 | FALSE |  |'
  prefs: []
  type: TYPE_TB
- en: '| serviceaccounts | sa | v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| services | svc | v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| statefulsets | sts | apps/v1 | TRUE |'
  prefs: []
  type: TYPE_TB
- en: '| storageclasses | sc | storage.k8s.io/v1 | FALSE |'
  prefs: []
  type: TYPE_TB
- en: '| subjectaccessreviews | authorization.k8s.io/v1 | FALSE |  |'
  prefs: []
  type: TYPE_TB
- en: '| tokenreviews | authentication.k8s.io/v1 | FALSE |  |'
  prefs: []
  type: TYPE_TB
- en: '| validatingwebhookconfigurations | admissionregistration.k8s.io/v1 | FALSE
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| volumeattachments | storage.k8s.io/v1 | FALSE |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.3: Kubernetes API resources'
  prefs: []
  type: TYPE_NORMAL
- en: As this chapter functions as a bootcamp, we will provide a short overview of
    the resources found in *Table 3.3*. To effectively comprehend the following chapters,
    it is important for you to possess a strong understanding of the objects and their
    respective functions.
  prefs: []
  type: TYPE_NORMAL
- en: Some resources will also be explained in greater detail in future chapters,
    including `Ingress`, `RoleBindings`, `ClusterRoles`, `StorageClasses`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing Kubernetes resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most resources in a cluster are run in a namespace, and to create/edit/read
    them, you should supply the `-n <namespace>` option to any `kubectl` command.
    To find a list of resources that accept a namespace option, you can reference
    the output from *Table 3.3*. If a resource can be referenced by a namespace, the
    `NAMESPACED` column will show `TRUE`. If the resource is only referenced by the
    cluster level, the `NAMESPACED` column will show `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: Apiservices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apiservices provide the primary entry point for communication and interaction
    between Kubernetes components and all external resources, such as users, applications,
    and other services. They provide a set of endpoints that allow users and applications
    to perform various operations, such as creating, updating, and deleting Kubernetes
    resources (i.e., pods, deployments, services, and namespaces).
  prefs: []
  type: TYPE_NORMAL
- en: Apiservices handle the authentication, authorization, and validation of requests,
    allowing only authorized users and applications to access or modify resources.
    They also handle resource versioning and other critical aspects of a Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: They can also extend Kubernetes functionality by developing custom controllers,
    operators, or other components that interact with the API Services to manage and
    automate various aspects of the cluster’s behavior. One example of this is our
    CNI, Calico, which adds 31 extra `api-resources` to a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: CertificateSigningRequests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **CertificateSigningRequest** (**CSR**) allows you to request a certificate
    from a certificate authority. These are typically used to obtain trusted certificates
    for securing communication within a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: ClusterRoles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `ClusterRole` is a collection of permissions that enable interaction with
    the API of the cluster. It pairs an action, or verb, with an API group to define
    a specific permission. For example, if you intended to restrict a **continuous
    integration/continuous delivery** (**CI/CD**) pipeline’s ability to only patch
    Deployments for updating image tags, you could utilize a `ClusterRole` similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A `ClusterRole` can apply to APIs at both the cluster and namespace levels.
  prefs: []
  type: TYPE_NORMAL
- en: ClusterRoleBindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have specified a `ClusterRole`, the next step is to create an association
    between the `ClusterRole` and a subject using a `ClusterRoleBinding`. This binding
    links the `ClusterRole` to a user, group, or service account, granting them the
    permissions defined within the `ClusterRole`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore `ClusterRoleBinding` in more detail in *Chapter 7*, *RBAC Policies
    and Auditing*.
  prefs: []
  type: TYPE_NORMAL
- en: ComponentStatus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Kubernetes control plane is a crucial component for a cluster; it is essential
    for the operation of the cluster. `ComponentStatus` is an object that shows the
    health and status of different Kubernetes control plane components. It provides
    an indicator of the overall health of a component, providing information on whether
    it is operating correctly or has errors.
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMaps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A ConfigMap is a resource that stores data in key-value pairs, enabling the
    separation of configuration from your application. `ConfigMaps` can hold various
    types of data, including literal values, files, or directories, allowing flexibility
    in managing your application’s configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an imperative example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<data>` option will vary based on the source of the `ConfigMap`. To use
    a file or a directory, you supply the `--from-file` option and either the path
    to a file or an entire directory, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This would create a new `ConfigMap` named `config-test`, with the `nginx.conf`
    key containing the content of the `nginx.conf` file as the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to have more than one key added in a single `ConfigMap`, you put
    each file into a directory and create the `ConfigMap` using all of the files in
    the directory. For example, you have three files in a directory located at `~/config/myapp`.
    The files each contain data and are called `config1`, `config2`, and `config3`.
    To create a `ConfigMap` that would add each file into a key, you need to supply
    the `--from-file` option and point to the directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This would create a new `ConfigMap` with three key values called `config1`,
    `config2`, and `config3`. Each key will contain a value equal to the content of
    each file in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To quickly show a `ConfigMap`, using the example mentioned above, we can retrieve
    `it` using the `get` command, `kubectl get configmaps config-test`, resulting
    in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ConfigMap` is comprised of three keys, indicated by the presence of the
    number `3` under the `DATA` column. For a more detailed examination, we can utilize
    the `kubectl get` command with the additional “`-o yaml`" option appended to the
    `kubectl get configmaps config-test` command. This will show the output of each
    key’s value represented in YAML format, as demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By examining the output, it shows that each key within the `ConfigMap` corresponds
    to the filenames found in the directory—`config1`, `config2`, and `config3`. Each
    key retains the value obtained from the data within its respective file.
  prefs: []
  type: TYPE_NORMAL
- en: One limitation of `ConfigMaps` that you should keep in mind is that the data
    is easily accessible to anyone with permission to the resource. As you can see
    from the preceding output, a simple `get` command shows the data in cleartext.
  prefs: []
  type: TYPE_NORMAL
- en: Due to this design, you should never store sensitive information such as a password
    in a `ConfigMap`. Later in this section, we will cover a resource that was designed
    to store secret data information, called a `Secret`.
  prefs: []
  type: TYPE_NORMAL
- en: ControllerRevisions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `ControllerRevision` is like a snapshot of a particular version or update
    to a controller’s settings. It’s mainly used by specific controllers, such as
    the `StatefulSet` controller, to keep track of and manage changes made to their
    configurations as time goes on.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever there are modifications or updates to the configuration of a resource
    managed by a controller, a new `ControllerRevision` is created. Each revision
    includes the desired setup of the controller and a revision number. These revisions
    are stored in the Kubernetes API server, allowing you to refer to or revert to
    them whenever necessary.
  prefs: []
  type: TYPE_NORMAL
- en: CronJobs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have used Linux cronjobs in the past, then you already know what a Kubernetes
    `CronJob` resource is. If you don’t have a Linux background, a cronjob is used
    to create a scheduled task. As another example, if you are a Windows person, it’s
    similar to Windows scheduled tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example manifest that creates a `CronJob` is shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `schedule` format follows the standard `cron` format. From left to right,
    each `*` represents the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Minute (0–59)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hour (0–23)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day (1–31)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Month (1–12)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day of the week (0–6) (Sunday = 0, Saturday = 6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CronJob` accept step values, which allow you to create a schedule that can
    execute every minute, every 2 minutes, or every hour.'
  prefs: []
  type: TYPE_NORMAL
- en: Our example manifest will create a `CronJob` that runs an image called `hello-world`
    every minute and outputs `Hello World!` in the Pod log.
  prefs: []
  type: TYPE_NORMAL
- en: CSI drivers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes uses the `CsiDriver` resource to connect nodes to a storage system.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can list all CSI drivers that are available on a cluster by executing the
    `kubectl get csidriver` command. In one of our lab clusters, we are using NetApp’s
    SolidFire for storage, so our cluster has the Trident CSI driver installed, as
    can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: CSI nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid storing storage information in the node’s API resource, the `CSINode`
    resource was added to the API server to store information generated by the CSI
    drivers. The information that is stored includes mapping Kubernetes node names
    to CSI node names, CSI driver availability, and the volume topology.
  prefs: []
  type: TYPE_NORMAL
- en: CSIStorageCapacities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`CSIStorageCapacity` is a component that stores information about the storage
    capacity for a given CSI, representing the available storage capacity for a given
    `StorageClass`. This information is used when K8s decides where to create new
    `PersistentVolumes`.'
  prefs: []
  type: TYPE_NORMAL
- en: CustomResourceDefinitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **CustomResourceDefinition** (**CRD**) is a way for users to make their own
    custom resources in a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: It outlines the structure, format, and behavior of the custom resource, including
    its API endpoints and supported operations. Once a CRD is made and added to the
    cluster, it becomes a built-in resource type that can be managed using regular
    Kubernetes tools and APIs.
  prefs: []
  type: TYPE_NORMAL
- en: DaemonSets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `DaemonSet` enables the deployment of a pod on each node in a cluster or on
    a specific set of nodes. It is commonly utilized to deploy essential components
    like logging, which are required on every node in the cluster. Once a `DaemonSet`
    is set up, it automatically creates a pod on each existing node.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, as new nodes are added to the cluster, the `DaemonSet` ensures that
    a pod is deployed on the newly joined nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Deployments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We mentioned earlier that you should never deploy a pod directly. One reason
    for this is that you cannot scale a pod or perform a rolling upgrade when a pod
    is created in this way. `Deployments` offer you many advantages, including a way
    to manage your upgrades declaratively and the ability to roll back to previous
    revisions. Creating a `Deployment` is actually a three-step process that is executed
    by the API server: a `Deployment` is created, which creates a `ReplicaSet`, which
    then creates the pod(s) for the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Even if you don’t plan to scale or perform rolling upgrades to the application,
    you should still use `Deployments` by default so that you can leverage the features
    at a future date.
  prefs: []
  type: TYPE_NORMAL
- en: Endpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An `Endpoint` maps a service to a pod or pods. This will make more sense when
    we explain the `Service` resource. For now, you only need to know that you can
    use the CLI to retrieve endpoints by using the `kubectl get endpoints` command.
    In a new KinD cluster, you will see a value for the Kubernetes API server in the
    default namespace, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that the cluster has a service called `kubernetes` that has
    an endpoint at the **Internet Protocol** (**IP**) address `172.17.0.2` on port
    `6443`. The IP that is returned in our example is the address to which our Docker
    control plane container has been assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Later, you will see how looking at endpoints can be used to troubleshoot service
    and ingress issues.
  prefs: []
  type: TYPE_NORMAL
- en: EndPointSlices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Endpoints` do not scale well—they store all endpoints in a single resource.
    When dealing with a smaller deployment that may have a handful of pods, this isn’t
    an issue. As clusters grow and applications scale, endpoint sizes also grow, and
    this will impact the performance of your control plane and cause additional network
    traffic as endpoints change.'
  prefs: []
  type: TYPE_NORMAL
- en: '`EndPointSlices` are designed to take on more significant and larger scenarios
    that require scalability and precise control over network endpoints. By default,
    each `EndPointSlice` can hold up to 100 endpoints, which can be increased by adding
    the `--max-endpoints-per-slice` option to the `kube-controller-manager`.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have a deployment of a Service in Kubernetes with a large number
    of pods. If one of those pods is deleted, Kubernetes will only update the specific
    slice that contains the information about that pod. When the updated slice is
    distributed across the cluster, it will only include details for a smaller subset
    of pods. By doing so, the cluster network remains efficient and avoids becoming
    overwhelmed with excessive data.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Events` resource will display any events for a namespace. To get a list
    of events for the `kube-system` namespace, you would use the `kubectl get events
    -n kube-system` command.
  prefs: []
  type: TYPE_NORMAL
- en: FlowSchemas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes clusters have predefined settings that manage the handling of concurrent
    requests to the API server, ensuring that the traffic does not overload the server.
    However, you have the flexibility to customize and configure your own flow schema
    and priority levels for requests directed at the API server in your clusters.
    This allows you to define specific rules and preferences for how requests are
    handled and prioritized, tailoring the behavior of the API server to suit your
    specific requirements and workload.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you have a namespace that has an important application deployed.
    You could create a `FlowSchema` with a high priority so the API server would handle
    requests for the namespace before other requests.
  prefs: []
  type: TYPE_NORMAL
- en: HorizontalPodAutoscalers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the biggest advantages of running a workload on a Kubernetes cluster
    is the ability to automatically scale your pods. While you can scale using the
    `kubectl` command or by editing a manifest’s replica count, these are not automated
    and require manual intervention.
  prefs: []
  type: TYPE_NORMAL
- en: '**Horizontal Pod Autoscalers** (**HPAs**) provide the ability to scale an application
    based on a set of criteria. Using metrics such as CPU and memory usage, or your
    own custom metrics, you can set a rule to scale your pods out when you need more
    pods to maintain your service level.'
  prefs: []
  type: TYPE_NORMAL
- en: After a cooldown period, Kubernetes will scale the application back to the minimum
    number of pods defined in the policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To quickly create an HPA for an NGINX Deployment, we can execute a `kubectl`
    command using the `autoscale` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create a Kubernetes manifest to create your HPAs. Using the same
    options as those we did in the CLI, our manifest would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Both options will create an HPA that will scale `nginx-deployment` up to 5 replicas
    when the `Deployment` hits a CPU utilization of 50%. Once the `Deployment` usage
    falls below 50% and the cooldown period is reached (by default, 5 minutes), the
    replica count will be reduced to 1.
  prefs: []
  type: TYPE_NORMAL
- en: IngressClasses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`IngressClasses` allow you to define and oversee various types of Ingress controllers.
    They offer the ability to personalize and adjust the behavior of these controllers
    according to specific needs, providing customizable routing of incoming traffic
    to services. `IngressClasses` allow you to manage and fine-tune Ingress controllers,
    ensuring that traffic is handled in a manner that aligns with your requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: The most important role an `IngressClass` has is to let you define multiple
    Ingress controllers in a single cluster. For instance, the Kubernetes Dashboard
    version 3 uses a specific `IngressClass` to make sure its `Ingress` objects are
    bound to an NGINX instance that doesn’t have a `LoadBalancer`, so it can’t be
    accessed from outside the cluster. You can also use this feature to connect Ingress
    controllers to different networks.
  prefs: []
  type: TYPE_NORMAL
- en: Ingress
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An `Ingress` resource is a tool that lets you create rules for incoming HTTP
    and HTTPS traffic to services using options like hostnames, paths, or request
    headers. It acts as a middleman between the external traffic and the services
    running in the cluster. By using `Ingress`, you can define how different types
    of traffic should be routed to specific services, giving you granular control
    over the flow of incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss `Ingress` in depth in the next chapter, but a quick description
    of what `Ingress` provides is that it allows you to expose your application to
    the outside world using an assigned URL.
  prefs: []
  type: TYPE_NORMAL
- en: Jobs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Jobs` allow you to execute a specific number of executions of a pod or pods.
    Unlike a `CronJob` resource, these pods are not run on a set schedule, but rather
    they will execute once when they are created.'
  prefs: []
  type: TYPE_NORMAL
- en: LimitRanges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will discuss the `Quota` resource later in this chapter, but a `LimitRange`
    is a configuration that allows you to establish and enforce specific boundaries
    and restrictions on resource allocations for pods and containers within a given
    namespace. By utilizing `LimitRanges`, you can define limits on resources, such
    as CPU, memory, and storage, ensuring that pods and containers operate efficiently
    and prevent any negative impact on the overall cluster environment.
  prefs: []
  type: TYPE_NORMAL
- en: LocalSubjectAccessReview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`LocalSubjectAccessReview` is a feature that helps you check if a user or group
    in the cluster has the required permissions to perform a specific action on a
    local resource. It enables you to review access permissions directly within the
    cluster without relying on external API requests.'
  prefs: []
  type: TYPE_NORMAL
- en: Using `LocalSubjectAccessReview`, you can specify the user or group identity
    along with the action and resource you want to evaluate. The Kubernetes API server
    will then verify the permissions against the local access control policies. It
    will respond with whether the requested action is allowed or denied.
  prefs: []
  type: TYPE_NORMAL
- en: MutatingWebhookConfiguration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`MutatingWebhookConfiguration` is used to create webhooks that can intercept
    and modify requests sent to the API server, providing a way to automatically modify
    the requested resources.'
  prefs: []
  type: TYPE_NORMAL
- en: A `MutatingWebhookConfiguration` contains a set of rules that determine which
    requests should be intercepted and processed by a webhook. When a request matches
    the defined rules, the `MutatingWebhookConfiguration` triggers the corresponding
    webhooks, which can then modify the payload. Modifications can include adding,
    removing, or modifying fields and annotations in the resource being created or
    updated.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Namespace` is a resource to divide a cluster into logical units. Each `Namespace`
    allows granular management of resources, including permissions, quotas, and reporting.
  prefs: []
  type: TYPE_NORMAL
- en: The `Namespace` resource is used for namespace tasks, which are cluster-level
    operations. Using the `namespace` resource, you can execute commands including
    `create`, `delete`, `edit`, and `get`.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for the command is `kubectl <verb> ns <namespace name>`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to describe the `kube-system` namespace, we would execute a `kubectl
    describe namespaces kube-system` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will return information for the namespace, including any labels, annotations,
    and assigned quotas, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, you can see that this namespace does not have any labels,
    annotations, or resource quotas assigned.
  prefs: []
  type: TYPE_NORMAL
- en: This section is only meant to introduce the concept of namespaces as a management
    unit in multi-tenant clusters. If you plan to run clusters with multiple tenants,
    you need to understand how namespaces can be used to secure a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: NetworkPolicies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`NetworkPolicy` resources let you define how network traffic, both ingress
    (incoming) and egress (outgoing), can flow through your cluster. They allow you
    to use Kubernetes native constructs to define which pods can talk to other Pods.
    If you’ve ever used security groups in **Amazon Web Services** (**AWS**) to lock
    down access between two groups of systems, it’s a similar concept. As an example,
    the following policy will allow traffic on port `443` to pods in the `myns` namespace
    from any namespace with the `app.kubernetes.io/name: ingress-nginx` label on it
    (which is the default label for the `nginx-ingress` namespace):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A `NetworkPolicy` is another resource that you can use to secure a cluster.
    They should be used in all production clusters, but in a multi-tenant cluster,
    they should be considered a **must-have** to secure each namespace in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `nodes` resource is a cluster-level resource that is used to interact with
    the cluster’s nodes. This resource can be used with various actions including
    `get`, `describe`, `label`, and `annotate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve a list of all of the nodes in a cluster using `kubectl`, you need
    to execute a `kubectl get nodes` command. On a new KinD cluster running a simple
    one-node cluster, this would display as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the nodes resource to get details of a single node using the
    `describe` command. To get a description of the KinD node listed previously, we
    can execute `kubectl describe node kind-control-plane`, which would return details
    on the node, including consumed resources, running pods, IP **classless inter-domain
    routing** (**CIDR**) ranges, and more.
  prefs: []
  type: TYPE_NORMAL
- en: PersistentVolumeClaims
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A PVC is a namespaced resource that is used by a pod to consume persistent storage.
    A PVC uses a **persistent volume** (**PV**) to map the actual storage resource,
    which can be on any support storage system, including **NFS** and **iSCSI**.
  prefs: []
  type: TYPE_NORMAL
- en: As with most resources we have discussed, you can issue `get`, `describe`, and
    `delete` commands on a PVC resource. Since these are used by pods in the namespace,
    PVCs must be created in the same namespace as the pod(s) that will use the PVC.
  prefs: []
  type: TYPE_NORMAL
- en: PersistentVolumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PVs are used by PVCs to create a link between the PVC and the underlying storage
    system. Manually maintaining PVs is a messy, manual task, and it should be avoided.
    Instead, Kubernetes includes the ability to manage most common storage systems
    using the **Container Storage Interface** (**CSI**).
  prefs: []
  type: TYPE_NORMAL
- en: Most CSI solutions that are used in an Enterprise cluster provide auto-provisioning
    support, as we discussed in *Chapter 2* when we introduced Rancher’s local provisioner.
    Solutions that support auto-provisioning remove the administrative overhead that
    is required to create PVs manually, taking care of the creation and mapping of
    the PVs to PVCs automatically.
  prefs: []
  type: TYPE_NORMAL
- en: PodDisruptionBudgets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `PodDisruptionBudget` (PDB) is a resource that creates boundaries on the maximum
    number of unavailable pods at any given time. Its purpose is to prevent situations
    where multiple pods are terminated simultaneously, which could result in service
    disruptions or failures. By defining the minimum number of available pods, referred
    to as the `"minAvailable"` parameter, you can guarantee that a specific quantity
    of pods remains functional during maintenance or other disruptive occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: The `kube-scheduler` in a cloud will use this information to figure out how
    to replace nodes during an upgrade. You need to be careful when using a `PodDisruptionBudget`
    because you could find a situation where an upgrade is halted.
  prefs: []
  type: TYPE_NORMAL
- en: Pods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The pod resource is used to interact with the pods that are running your container(s).
    Using the `kubectl` utility, you can use commands such as `get`, `delete`, and
    `describe`. For example, if you wanted to get a list of all pods in the `kube-system`
    namespace, you would execute a `kubectl get Pods -n kube-system` command that
    would return all pods in the namespace, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: While you can create a pod directly, you should avoid doing so unless you are
    using a pod for quick troubleshooting. pods that are created directly cannot use
    many of the features provided by Kubernetes, including scaling, automatic restarts,
    or rolling upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of creating a pod directly, you should use a `Deployment`, `StatefulSet`,
    or, in some rare cases, `ReplicaSet` resource or replication controller.
  prefs: []
  type: TYPE_NORMAL
- en: PodTemplates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PodTemplates` provide a way to create templates or blueprints for creating
    pods. They function as reusable configurations that include the desired specifications
    and settings for pods. They include the metadata and specifications of a pod,
    including the name, labels, containers, volumes, and other attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`PodTemplates` are commonly used in other Kubernetes objects such as `ReplicaSets`,
    `Deployments`, and `StatefulSets`. These resources rely on a `PodTemplate` to
    generate and manage a collection of pods with consistent configurations and behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: PriorityClasses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PriorityClasses` provide a way to prioritize pods based on their importance.
    This allows the Kubernetes scheduler to make better decisions regarding resource
    allocation and pod scheduling in a cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: To define `PriorityClasses`, you create a new `PriorityClass` resource associated
    with numeric values that indicate the priority level. pods with higher priority
    values are given priority over lower values when it comes to resource allocation
    and scheduling.
  prefs: []
  type: TYPE_NORMAL
- en: Using `PriorityClasses`, you can guarantee that crucial workloads are given
    higher priority in terms of resource allocation and scheduling, providing the
    necessary resources to run smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: PriorityLevelConfigurations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PriorityLevelConfigurations` are objects that help define priority levels
    for requests sent to the API server. They provide control over how API requests
    are processed and prioritized within a cluster. Using `PriorityLevelConfigurations`,
    you can establish multiple priority levels, assigned to specific attributes. These
    attributes include setting limits on the maximum number of queries per second
    (QPS) and concurrent requests for a particular priority level. This allows for
    more efficient resource management and allocation based on the importance of different
    API requests.'
  prefs: []
  type: TYPE_NORMAL
- en: '`PriorityLevelConfigurations` allow you to enforce policies that ensure critical
    requests always receive enough resources, providing flexibility in managing the
    processing and allocation of resources for API requests.'
  prefs: []
  type: TYPE_NORMAL
- en: ReplicaSets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ReplicaSets` can be used to create a pod or a set of pods (replicas). Similar
    to the `ReplicationController` resource, a `ReplicaSet` will maintain the set
    number of pods defined in the replica count. If there are too few pods, Kubernetes
    will make up the difference and create the missing pods. If there are too many
    pods for a `ReplicaSet`, Kubernetes will delete pods until the number is equal
    to the replica count set.'
  prefs: []
  type: TYPE_NORMAL
- en: In general, you should avoid creating `ReplicaSets` directly. Instead, you should
    create a `Deployment`, which will create and manage a `ReplicaSet`.
  prefs: []
  type: TYPE_NORMAL
- en: Replication controllers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Replication controllers will manage the number of running pods, keeping the
    desired replicas specified running at all times. If you create a replication controller
    and set the replica count to `5`, the controller will always keep five pods of
    the application running.
  prefs: []
  type: TYPE_NORMAL
- en: Replication controllers have been replaced by the `ReplicaSet` resource, which
    we just discussed in its own section. While you can still use replication controllers,
    you should consider using a `Deployment` or a `ReplicaSet`.
  prefs: []
  type: TYPE_NORMAL
- en: ResourceQuotas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is becoming very common to share a Kubernetes cluster between multiple teams,
    referred to as a **multi-tenant cluster**. Since you will have multiple teams
    working in a single cluster, you should create quotas to limit the potential of
    a single tenant consuming all the resources in a cluster or on a node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Limits can be set on most cluster resources, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Central processing unit (CPU)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PVCs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConfigMaps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pods, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a limit will stop any additional resources from being created once the
    limit is hit. If you set a limit of 10 pods for a namespace and a user creates
    a new `Deployment` that attempts to start 11 Pods, the eleventh pod will fail
    to start up and the user will receive an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic manifest file to create a quota for memory and CPU would look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will set a limit on the total amount of resources the namespace can use
    for CPU and memory requests and limits.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the options you can set in a quota are self-explanatory, like pods,
    PVCs, services, etc. When you set a limit, it means that the set limit is the
    maximum allowed for that resource in the namespace. For example, if you set a
    limit on a pod to 5, when an attempt is made to create a sixth pod in that namespace,
    it will be denied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some quotas have more than one option that can be set: specifically, CPU and
    memory. In our example, both resources have set a request and a limit. Both values
    are very important to understand to ensure efficient use of your resources and
    to limit the potential availability of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: A request is essentially a reservation of that specific resource. When a pod
    is deployed, you should always set a request on your CPU and memory, and the value
    should be the minimum required to start your application. This value will be used
    by the scheduler to find a node that meets the request that has been set. If there
    are no nodes with the requested resource available, the pod will fail to be scheduled.
  prefs: []
  type: TYPE_NORMAL
- en: Now, since a request will reserve the resource, that means once all nodes in
    the cluster have 100% of requests assigned, any additional pod creations will
    be denied since the requests are at 100%. Even if your actual cluster CPU or memory
    utilization is at 10%, pods will fail to be scheduled since the request, or **reservation**,
    is at 100%. If requests are not carefully thought out, it will lead to wasted
    resources, and that will lead to an increased cost to run the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Limits on CPU and memory set the maximum value that the pod will be able to
    utilize. This is different from a request since limits are not a reservation of
    the resource. However, limits still need to be carefully planned out from an application
    side. If you set the CPU limit too low, the application may experience performance
    issues, and if you set the memory limit too low, the pod will be terminated, impacting
    availability while it is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: Once a quota has been created, you can view the usage using the `kubectl describe`
    command. In our example, we named the `ResourceQuota` as `base-memory-cpu`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the usage, we will execute the `kubectl get resourcequotas base-memory-cpu`
    command, resulting in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`ResourceQuotas` serve as a means to manage and control the allocation of resources
    within a cluster. They allow you to assign specific CPU and memory resources to
    individual namespaces, ensuring that each tenant has sufficient resources to run
    their applications effectively. Additionally, `ResourceQuotas` act as a safeguard,
    preventing a poorly optimized or resource-intensive application from adversely
    affecting the performance of other applications in the cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: RoleBindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `RoleBinding` resource is how you associate a `Role` or `ClusterRole` with
    a subject and namespace. For instance, the following `RoleBinding` will allow
    the `aws-codebuild` user to apply the `patch-openunison ClusterRole` to the `openunison`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Even though this references a `ClusterRole`, it will only apply to the `openunison`
    namespace. If the `aws-codebuild` user tries to patch a Deployment in another
    namespace, the API server will stop it.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with a `ClusterRole`, Roles combine API groups and actions to define a set
    of permissions that can be assigned to a subject. The difference between a `ClusterRole`
    and a `Role` is that a `Role` can only have resources defined at the namespace
    level and they apply only within a specific namespace.
  prefs: []
  type: TYPE_NORMAL
- en: RuntimeClasses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`RuntimeClasses` are used to set up and customize different runtime environments
    for running containers. They provide the flexibility to choose and configure the
    container runtime that best suits your workloads. By using `RuntimeClasses`, you
    can fine-tune the container runtime according to your specific requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: Each `RuntimeClass` is linked to a specific container runtime, like Docker or
    Containerd. They include configurable parameters that define how the chosen container
    runtime behaves. These parameters include resource limits, security configurations,
    and environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier, we described how to use a `ConfigMap` resource to store configuration
    information. We mentioned that `ConfigMap` should never be used to store any type
    of sensitive data. This is the job of a `Secret`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Secrets` are stored as Base64-encoded strings, which aren’t a form of encryption.
    So, why separate `Secrets` from `ConfigMap`? Providing a separate resource type
    offers an easier way to maintain access controls and the ability to inject sensitive
    information using an external secret management system.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Secrets` can be created using a file, directory, or from a literal string.
    As an example, we have a MySQL image we want to execute, and we would like to
    pass the password to the pod using a Secret. On our workstation, we have a file
    called `dbpwd` in our current working directory that has our password in it. Using
    the `kubectl` command, we can create a `Secret` by executing `kubectl create secret
    generic mysql-admin --from-file=./dbpwd`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This would create a new `Secret` called `mysql-admin` in the current namespace,
    with the content of the `dbpwd` file. Using `kubectl`, we can get the output of
    the `Secret` by running the `kubectl get secret mysql-admin -o yaml` command,
    which would output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the preceding output, you can see that the `data` section contains
    the name of our file and then a Base64-encoded value, which was created from the
    content of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we copy the Base64 value from the `Secret` and pipe it out to the `base64`
    utility, we can easily decode the password, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When using the `echo` command to Base64-encode strings, add the `-n` flag to
    avoid adding an additional `\n`. Instead of `echo 'test' | base64`, use `echo
    -n 'test' | base64`.
  prefs: []
  type: TYPE_NORMAL
- en: Everything is stored in `etcd` but we are concerned that someone may be able
    to hack into the `etcd` node and steal a copy of the etcd database. Once someone
    has a copy of the database, they could easily use the `etcdctl` utility to look
    through the content to retrieve all of our Base64-encoded Secrets. Luckily, Kubernetes
    added a feature to encrypt `Secrets` when they are written to a database.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling this feature can be fairly complex for many users, and while it sounds
    like a good idea, it does present some potential issues that you should consider
    before implementing it. If you would like to read the steps on encrypting your
    Secrets at rest, you can view these on the Kubernetes site at [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).
  prefs: []
  type: TYPE_NORMAL
- en: Another option to secure Secrets is to use a third-party secrets management
    tool such as HashiCorp’s Vault or CyberArk’s Conjur. We’ll cover integration with
    secret management tools in *Chapter 9*, *Managing Secrets in Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: SelfSubjectAccessReviews
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`SelfSubjectAccessReviews` objects enable users or entities to check their
    own permissions for performing specific actions on resources in their namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: To use `SelfSubjectAccessReviews`, users provide their username along with the
    desired action and resource to check. The cluster evaluates the permissions of
    the provided user against the access control policies in the namespace, and the
    API server responds with whether the requested action is allowed or denied.
  prefs: []
  type: TYPE_NORMAL
- en: '`SelfSubjectAccessReviews` and the next resource, `SelfSubjectRulesReviews`,
    may look very similar, but they serve different functions. The main point to keep
    in mind for `SelfSubjectAccessReviews` is that they assess individual access permissions
    for specific actions on resources.'
  prefs: []
  type: TYPE_NORMAL
- en: SelfSubjectRulesReviews
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`SelfSubjectRulesReviews` objects are used to determine the set of rules that
    a user or entity has permissions for within a namespace, providing the ability
    to investigate the access control rules for their own actions and resources.'
  prefs: []
  type: TYPE_NORMAL
- en: To use a `SelfSubjectRulesReview`, you provide your identity, and the API server
    assesses the permissions associated with the identity in a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '`SelfSubjectRulesReviews` offer a more comprehensive view over `SelfSubjectAccessReviews`,
    providing a deeper understanding of the entire set of rules that govern a user’s
    permissions within a namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: Service accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes uses `ServiceAccounts` to enable access controls for workloads. When
    you create a `Deployment`, you may need to access other services or Kubernetes
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Since Kubernetes is a secure system, each resource or service your application
    tries to access will evaluate **role-based access control** (**RBAC**) rules to
    accept or deny the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a service account using a manifest is a straightforward process, requiring
    only a few lines in the manifest. The following code snippet shows a service account
    manifest to create a service account for a Grafana Deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You combine the service account with role bindings and `Roles` to allow access
    to the required services or objects.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover how to use `ServiceAccounts` in depth in *Chapter 6*, *Integrating
    Enterprise Authentication into Your Cluster*.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you create a pod, it will receive an IP address from the CIDR range that
    was assigned when the cluster was created. In most clusters, the assigned IPs
    are only addressable within the cluster itself, referred to as “**island mode**.”
    Since pods are ephemeral, the assigned IP address will likely change during an
    application’s life cycle, which becomes problematic when any service or application
    needs to connect to the pod. To address this, we can create a Kubernetes service,
    which will also receive an IP address, but since services aren’t deleted during
    an application’s life cycle, the address will remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: A service will dynamically maintain a list of pods to target based on labels
    that match the service selector, creating a list of endpoints for the service.
  prefs: []
  type: TYPE_NORMAL
- en: A service stores information about how to expose the application, including
    which pods are running the application and the network ports to reach them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each service has a network type that is assigned when they are created, and
    they include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ClusterIP`: A network type that is only accessible inside the cluster itself.
    This type can still be used for external requests using an Ingress controller,
    which will be discussed in a later chapter. The ClusterIP type is the default
    type that will be used if no type is specified when you create a service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NodePort`: A network type that exposes the service to a random port between
    ports `30000` and `32767`. This port becomes accessible by targeting any worker
    node in a cluster on the assigned `NodePort`. Once created, each node in the cluster
    will receive the port information, and incoming requests will be routed via `kube-proxy`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadBalancer`: This type requires an add-on to use inside a cluster. If you
    are running Kubernetes on a public cloud provider, this type will create an external
    load balancer that will assign an IP address to your service. Most on-premises
    Kubernetes installations do not include support for the `LoadBalancer` type, but
    some offerings such as Google’s Anthos do offer support for it. In a later chapter,
    we will explain how to add an open-source project called `MetalLB` to a Kubernetes
    cluster to provide support for the `LoadBalancer` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExternalName`: This type is different from the other three. Unlike the other
    three options, this type will not assign an IP address to the service. Instead,
    this is used to map the internal Kubernetes **Domain Name System** (**DNS**) name
    to an external service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, we have deployed a pod running Nginx on port `80`. We want to
    create a service that will allow this pod to receive incoming requests on port
    `80` from within the cluster. The code for this can be seen in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In our manifest, we create a label with a value of `app` and assign a value
    of `nginx-web-frontend`. We have called the service itself `nginx-web` and we
    exposed the service on port `80`, targeting the pod port of `80`. The last two
    lines of the manifest are used to assign the pods that the service will forward
    to, also known as Endpoints. In this manifest, any pod that has the label of `app`
    with a value of `nginx-web` in the namespace will be added as an endpoint to the
    service. Finally, you may have noticed that we didn’t specify a service type in
    our manifest. Since we didn’t specify the type, it will be created as the default
    service type of `ClusterIP`.
  prefs: []
  type: TYPE_NORMAL
- en: StatefulSets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`StatefulSets` offer some unique features when creating pods. They provide
    features that none of the other pod creation methods offer, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Known pod names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordered Deployment and scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordered updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent storage creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best way to understand the advantages of a `StatefulSet` is to review an
    example manifest from the Kubernetes site, shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – StatefulSet manifest example ](img/B21165_03_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: StatefulSet manifest example'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can look at the resources that the `StatefulSet` created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The manifest specifies that there should be three replicas of a pod named `nginx`.
    When we get a list of pods, you will see that three pods were created using the
    `nginx` name, with an additional dash and an incrementing number. This is what
    we meant in the overview when we mentioned that Pods will be created with known
    names, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The pods are also created in order—`web-0` must be fully deployed before `web-1`
    is created, and then, finally, `web-2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for this example, we also added a PVC to each pod using the `VolumeClaimTemplate`
    in the manifest. If you look at the output of the `kubectl get pvc` command, you
    will see that three PVCs were created with the names we expected (note that we
    removed the `VOLUME` column due to space), as illustrated in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the `VolumeClaimTemplate` section of the manifest, you will see that we assigned
    the name `www` to the PVC claim. When you assign a volume in a `StatefulSet`,
    the PVC name will combine the name used in the claim template, combined with the
    name of the pod. Using this naming, you can see why Kubernetes assigned the PVC
    names `www-web-0`, `www-web-1`, and `www-web-2`.
  prefs: []
  type: TYPE_NORMAL
- en: Storage classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Storage classes are used to define a storage endpoint. Each storage class can
    be assigned labels and policies, allowing a developer to select the best storage
    location for their persistent data. You may create a storage class for a backend
    system that has all **Non-Volatile Memory Express** (**NVMe**) drives, assigning
    it the name `fast`, while assigning a different class to a NetApp **Network File
    System** (**NFS**) volume running standard drives, using the name `standard`.
  prefs: []
  type: TYPE_NORMAL
- en: When a PVC is requested, the user can assign a `StorageClass` that they wish
    to use. When the API server receives the request, it finds the matching name and
    uses the `StorageClass` configuration to create the volume on the storage system
    using a provisioner.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a very high level, a `StorageClass` manifest does not require a lot of information.
    Here is an example of a storage class using a provisioner from the Kubernetes
    incubator project to provide NFS auto-provisioned volumes, named `nfs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Storage classes allow you to offer multiple storage solutions to your users.
    You may create a class for cheaper, slower storage while offering a second class
    that supports high throughput for high data requirements. By providing a different
    class to each offering, you allow developers to select the best choice for their
    application.
  prefs: []
  type: TYPE_NORMAL
- en: SubjectAccessReviews
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`SubjectAccessReviews` are used to check if an entity has permission to perform
    a specific action on a resource. They allow users to request access reviews and
    get information about their privileges. By providing an identity, desired action,
    and resource, the API server determines if the action is allowed or denied. This
    helps users verify their permissions to a resource, which can help to identify
    access issues to a Kubernetes resource.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, Scott wants to verify his ability to create pods in a namespace
    called `sales`. To do this, Scott creates a `SubjectAccessReview` in the `sales`
    namespace, including his username, the create action, and the target resource,
    pods.
  prefs: []
  type: TYPE_NORMAL
- en: The API server verifies whether he has permission to create pods in the `sales`
    namespace and sends a response back. The response from the API server includes
    whether the requested action is permitted or denied.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing if an entity has permission to execute an action on a resource helps
    to minimize frustrations when a deployment fails due to permissions.
  prefs: []
  type: TYPE_NORMAL
- en: TokenReviews
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TokenReviews` are API objects used to authenticate and verify the legitimacy
    of an authentication token linked to a user or entity in the cluster. If the token
    is valid, the API server retrieves the details about the associated user or entity.'
  prefs: []
  type: TYPE_NORMAL
- en: When users submit an authentication token to the Kubernetes API server, it validates
    the token against the internal authentication system. It verifies that the token
    is legitimate and determines the user or entity associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: The API server provides information about the token’s validity and the user
    or entity, including the username, **user identifier** (**UID**), and group membership.
  prefs: []
  type: TYPE_NORMAL
- en: ValidatingWebhookConfigurations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ValidatingWebhookConfiguration` is a collection of rules that determine what
    admission requests are intercepted and handled by a webhook. Each rule contains
    the specific resources and operations that the webhook should handle.'
  prefs: []
  type: TYPE_NORMAL
- en: It provides a way to enforce specific policies or rules by applying validation
    logic to admission requests. Many add-ons to Kubernetes provide a `ValidatingWebhookConfiguration`
    – one of the most common is the NGINX ingress controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view all of the `ValidatingWebhookConfigurations` in your cluster by
    executing `kubectl get validatingwebhookconfigurations`. For the KinD clusters
    we have deployed, you will have a single entry for NGINX ingress admissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: VolumeAttachments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`VolumeAttachments` create connections between external storage volumes and
    nodes in a cluster. They control the association of persistent volumes with specific
    nodes, enabling the nodes to access and utilize the storage resources.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were provided with a fast-paced Kubernetes bootcamp, where
    you were exposed to a wealth of technical information. Remember that as you get
    deeper into the world of Kubernetes, everything will become more manageable and
    easier to grasp. It’s important to note that many of the resources discussed in
    this chapter will be further explored and explained in subsequent chapters, providing
    you with a deeper understanding.
  prefs: []
  type: TYPE_NORMAL
- en: You gained insights into each Kubernetes component and their interdependencies,
    which form the cluster. Armed with this knowledge, you now possess the necessary
    skills to investigate and identify the root causes of errors or issues within
    a cluster. We explored the control plane, which encompasses `api-server`, `kube-scheduler`,
    `etcd`, and controller managers. Additionally, you familiarized yourself with
    Kubernetes nodes that run the `kubelet` and `kube-proxy` components, along with
    a container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: We also delved into the practical use of the `kubectl` utility, which will be
    your primary tool for interacting with a cluster. You learned about several essential
    commands, such as commands for accessing logs and providing descriptive information,
    which you will utilize on a daily basis.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create a development Kubernetes cluster that we
    will use as the base cluster for the remaining chapters. Throughout the remainder
    of the book, we will reference many of the resources that were presented in this
    chapter, helping to explain them by using them in real-world examples.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Kubernetes control plane does not include which of the following components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: api-server
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: kube-scheduler
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: etcd
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ingress controller
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: d'
  prefs: []
  type: TYPE_NORMAL
- en: What is the name of the component that keeps all of the cluster information?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: api-server
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Master controller
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: kubelet
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: etcd
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: d'
  prefs: []
  type: TYPE_NORMAL
- en: Which component is responsible for selecting the node that will run a workload?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: kubelet
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: api-server
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: kube-scheduler
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Pod-scheduler
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: c'
  prefs: []
  type: TYPE_NORMAL
- en: Which option would you add to a `kubectl` command to see additional output from
    a command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verbose
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: -v
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: –verbose
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: -log
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: b'
  prefs: []
  type: TYPE_NORMAL
- en: Which service type creates a randomly generated port, allowing incoming traffic
    to any worker node on the assigned port to access the service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: LoadBalancer
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ClusterIP
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None—it’s the default for all services
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: NodePort
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: d'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to deploy an application on a Kubernetes cluster that requires known
    pod names and a controlled startup of each pod, which object would you create?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: StatefulSet
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ReplicaSet
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ReplicationController
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: a'
  prefs: []
  type: TYPE_NORMAL
- en: Join our book’s Discord space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join the book’s Discord workspace for a monthly *Ask Me Anything* session with
    the authors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/K8EntGuide](https://packt.link/K8EntGuide)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code965214276169525265.png)'
  prefs: []
  type: TYPE_IMG
