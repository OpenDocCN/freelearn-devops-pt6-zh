- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Kubernetes Bootcamp
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes训练营
- en: The previous chapter introduced you to deploying Kubernetes clusters using KinD
    (Kubernetes in Docker), which is useful for creating a development cluster on
    a single machine using containers instead of virtual machines. This approach reduces
    the system resource requirements and simplifies the entire setup process. We covered
    the installation and configuration of KinD, creating clusters, including add-ons
    like Ingress controllers, Calico as the CNI, and using persistent storage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了如何使用KinD（Kubernetes in Docker）部署Kubernetes集群，这对于在单台机器上使用容器而非虚拟机创建开发集群非常有用。此方法减少了系统资源的需求，并简化了整个设置过程。我们介绍了KinD的安装和配置，如何创建集群，包括Ingress控制器、Calico作为CNI以及如何使用持久存储。
- en: We understand that many of you have experience with Kubernetes, whether it’s
    running clusters in production or experimenting with tools like `kubeadm`, minikube,
    or Docker Desktop. Our intention with this book is to go beyond the fundamentals
    of Kubernetes, which is why we didn’t want to reiterate all the basics. Instead,
    we’ve included this chapter as a bootcamp for those who are new to Kubernetes
    or have only had limited exposure to it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解，很多人已经具备Kubernetes的使用经验，无论是运行生产环境中的集群，还是尝试使用`kubeadm`、minikube或Docker Desktop等工具。本书的目的是超越Kubernetes的基础知识，因此我们不打算重复介绍所有的基础内容。相反，我们在本章中提供了一个针对新手或接触Kubernetes较少的人的训练营。
- en: In this chapter, we will explore the essential components of a Kubernetes cluster,
    including the control plane and worker nodes. We will provide detailed explanations
    of each Kubernetes resource and its respective use cases. If you have previous
    experience with Kubernetes and feel comfortable using `kubectl`, as well as an
    understanding of Kubernetes resources like **DaemonSets**, **StatefulSets**, and
    **ReplicaSets**, this chapter can serve as a helpful review before moving on to
    *Chapter 4*, where we will dive into **Services**, **Load Balancing**, **ExternalDNS**,
    **Global Balancing**, and **K8GB**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Kubernetes集群的基本组件，包括控制平面和工作节点。我们将详细解释每个Kubernetes资源及其相应的使用场景。如果你以前有Kubernetes经验，并且能够熟练使用`kubectl`，同时了解像**DaemonSets**、**StatefulSets**和**ReplicaSets**这样的Kubernetes资源，那么本章将作为一个有益的复习，帮助你为进入*第4章*做准备，在该章节中我们将深入讨论**服务**、**负载均衡**、**外部DNS**、**全局负载均衡**以及**K8GB**。
- en: 'Since this is a bootcamp chapter, we won’t get into every topic in detail.
    However, by the end of this chapter, you should have a solid understanding of
    the foundational concepts of Kubernetes, which will be crucial for comprehending
    the remaining chapters. Even if you already possess a strong background in Kubernetes,
    you may find this chapter valuable as a refresher before we get into more advanced
    topics. In this chapter, you will learn the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个训练营章节，我们不会对每个话题进行详细探讨。然而，在本章结束时，你应该能够扎实地理解Kubernetes的基础概念，这对于理解接下来的章节至关重要。即使你已经有了Kubernetes的扎实基础，本章也能作为一次复习，为接下来深入讨论更高级的主题做好准备。本章将涉及以下内容：
- en: An overview of Kubernetes components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes组件概述
- en: Exploring the control plane
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索控制平面
- en: Understanding the worker node components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解工作节点组件
- en: Interacting with the API server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与API服务器交互
- en: Introducing Kubernetes resources
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Kubernetes资源
- en: By the end of this chapter, you will have a solid understanding of the most
    commonly used cluster resources. Understanding Kubernetes resources is important
    for both cluster operators and cluster administrators.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对最常用的集群资源有扎实的理解。了解Kubernetes资源对集群操作员和集群管理员都非常重要。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter has no technical requirements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有技术要求。
- en: If you want to execute commands while learning about the resources, you can
    use the KinD cluster that was deployed in the previous chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在学习资源时想执行命令，可以使用上一章中部署的KinD集群。
- en: An overview of Kubernetes components
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes组件概述
- en: Understanding the components of systems in an infrastructure is essential for
    delivering services effectively. In today’s wide landscape of installation options,
    many Kubernetes users may not have felt the need to fully comprehend the integration
    of different Kubernetes components.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 理解基础设施中系统组件的构成对于高效提供服务至关重要。在当今众多安装选项中，许多Kubernetes用户可能没有意识到完全理解不同Kubernetes组件的集成是必要的。
- en: Just a few years ago, establishing a Kubernetes cluster involved the manual
    installation and configuration of each component. This process presented a steep
    learning curve and often resulted in frustration. As a result, many individuals
    and organizations concluded that “Kubernetes is overly complex.” However, the
    benefit of manual installation was the in-depth understanding it provided regarding
    the interaction between each component. If any issues arose within the cluster
    after installation, you would have a clear understanding of where to investigate.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，建立Kubernetes集群需要手动安装和配置每个组件。这个过程具有陡峭的学习曲线，并且常常会导致挫败感。因此，许多人和组织得出结论：“Kubernetes过于复杂。”然而，手动安装的好处在于它能提供关于各个组件之间交互的深入理解。如果在安装后集群出现问题，你会清楚知道该从哪里开始调查。
- en: To understand how Kubernetes components work together, you must first understand
    the different components of a Kubernetes cluster.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Kubernetes组件如何协同工作，首先必须了解Kubernetes集群的不同组件。
- en: 'The following diagram is from the [http://Kubernetes.io](http://Kubernetes.io)
    site and shows a high-level overview of a Kubernetes cluster component:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下图来自[http://Kubernetes.io](http://Kubernetes.io)网站，展示了Kubernetes集群组件的高级概览：
- en: '![Figure 5.1 – Kubernetes cluster components ](img/B21165_03_01.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – Kubernetes集群组件](img/B21165_03_01.png)'
- en: 'Figure 3.1: Kubernetes cluster components'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：Kubernetes集群组件
- en: As you can see, the Kubernetes cluster is made up of several components. As
    we progress through the chapter, we’ll discuss these components and the role they
    play in a Kubernetes cluster.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Kubernetes集群由多个组件组成。在本章接下来的内容中，我们将讨论这些组件以及它们在Kubernetes集群中的作用。
- en: Exploring the control plane
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索控制平面
- en: The control plane, as its name suggests, has authority over every aspect of
    a cluster. In the absence of a functioning control plane, the cluster loses its
    ability to schedule workloads, create new deployments, and manage Kubernetes objects.
    Recognizing the criticality of the control plane, it is highly advisable to deploy
    with **high availability** (**HA**) support, deploying a minimum of three control
    plane nodes. Many production environments even utilize more than three control
    plane nodes, but the key principle is to have an odd number of nodes, which is
    required so we can maintain a highly available control plane if we lose a single
    `etcd` node.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，控制平面对集群的各个方面具有控制权。如果控制平面无法正常工作，集群将失去调度工作负载、创建新部署和管理Kubernetes对象的能力。鉴于控制平面的重要性，强烈建议在部署时支持**高可用性**（**HA**），并至少部署三个控制平面节点。许多生产环境甚至使用三个以上的控制平面节点，但关键原则是保持奇数个节点，这样即使丢失一个`etcd`节点，我们也能保持高可用的控制平面。
- en: Now, let’s delve into the importance of the control plane and its components,
    providing a comprehensive understanding of their pivotal role in a functioning
    cluster.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨控制平面的重要性及其组件，全面理解它们在集群中至关重要的作用。
- en: The Kubernetes API server
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes API服务器
- en: 'The first component to understand in a cluster is the `kube-apiserver` component.
    Since Kubernetes is **application programming interface** (**API**)-driven, every
    request that comes into a cluster goes through the API server. Let’s look at a
    simple `get nodes` request using an API endpoint, using the IP address for the
    control plane, which, in an enterprise, is usually fronted by a load balancer.
    In our example, our load balancer has an entry for the three control plane nodes
    on `10.240.100.100`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群中要理解的第一个组件是`kube-apiserver`组件。由于Kubernetes是**应用程序编程接口**（**API**）驱动的，所有进入集群的请求都会通过API服务器。让我们来看一个简单的`get
    nodes`请求，使用控制平面的IP地址，通过API端点发送请求。在企业环境中，控制平面通常会通过负载均衡器来前置。在我们的示例中，负载均衡器有一个指向三个控制平面节点的条目，IP为`10.240.100.100`：
- en: '[https://10.240.100.100:6443/api/v1/nodes?limit=500](https://10.240.100.100:6443/api/v1/nodes?limit=500)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://10.240.100.100:6443/api/v1/nodes?limit=500](https://10.240.100.100:6443/api/v1/nodes?limit=500)'
- en: If you attempt to make an API call without any credentials, you will receive
    a permission denied request. Using a pure API request directly is something that
    is very common when creating a pipeline for application deployment or even a Kubernetes
    add-on component. However, the most common method for users to interact with Kubernetes
    is the `kubectl` utility.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在没有任何凭证的情况下进行API调用，你将收到权限拒绝的请求。直接使用纯API请求是非常常见的做法，尤其是在创建应用程序部署管道或Kubernetes附加组件时。然而，用户与Kubernetes交互的最常见方式是使用`kubectl`工具。
- en: Every command that is issued using `kubectl` calls an API endpoint behind the
    scenes. In the preceding example, if we executed a `kubectl get nodes` command,
    an API request would be sent to the `kube-apiserver` process using the address
    `10.240.100.100` on port `6443`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个使用`kubectl`发出的命令在幕后调用一个API端点。在前面的示例中，如果我们执行了`kubectl get nodes`命令，将向`kube-apiserver`进程发送一个API请求，使用地址`10.240.100.100`和端口`6443`。
- en: 'The API call requested the `/api/vi/nodes` endpoint, which returned a list
    of the nodes in the cluster:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: API调用请求了`/api/vi/nodes`端点，返回了集群中节点的列表：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the absence of a functioning API server, all requests directed to your cluster
    will fail. Therefore, it becomes crucial to ensure the continuous operation and
    health of the `kube-apiserver`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有正常运行的API服务器的情况下，所有发送到集群的请求都将失败。因此，确保`kube-apiserver`的持续运行和健康状态至关重要。
- en: By running three or more control plane nodes, we minimize any potential impact
    that could be caused by the loss of a control plane node.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行三个或更多的控制平面节点，可以最小化由于控制平面节点丢失可能造成的任何潜在影响。
- en: Remember, from the last chapter, that when running more than one control plane
    node, you need to have a load balancer in front of the cluster’s API server. The
    Kubernetes API server can be fronted by most standard solutions, including F5,
    HAProxy, and Seesaw.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，从上一章可以得知，当运行多个控制平面节点时，需要在集群的API服务器前面使用负载均衡器。Kubernetes API服务器可以由大多数标准解决方案（包括F5、HAProxy和Seesaw）提供支持。
- en: The etcd database
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: etcd数据库
- en: 'Describing `etcd` as the foundation of your Kubernetes cluster would not be
    an overstatement. `etcd` functions as a robust and highly efficient distributed
    key-value database that Kubernetes relies on to store all cluster data. Every
    resource present within the cluster is associated with a specific key in the `etcd`
    database. If you can access the node or pod that hosts `etcd`, you `will` be able
    to use the `etcdctl` executable to explore all the keys stored within the database.
    The code snippet provided below offers an example extracted from a cluster based
    on KinD:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 把`etcd`描述为你的Kubernetes集群的基础并不为过。`etcd`作为一个强大而高效的分布式键值数据库，Kubernetes依赖它来存储所有集群数据。集群中的每个资源都与`etcd`数据库中的特定键关联。如果你可以访问托管`etcd`的节点或Pod，你可以使用`etcdctl`可执行文件来探索数据库中存储的所有键。下面提供的代码片段展示了从基于KinD的集群中提取的示例：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The output from the preceding command contains too much data to list it all
    in this chapter. A base KinD cluster will return approximately 314 entries.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出包含太多数据，无法在本章节中全部列出。一个基本的KinD集群将返回大约314个条目。
- en: 'All keys start with `/registry/<resource>`. For example, one of the keys that
    was returned is the `ClusterRole` for the `cluster-admin` key, as follows: `/registry/clusterrolebindings/cluster-admin`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有键都以`/registry/<resource>`开头。例如，返回的键之一是`ClusterRole`为`cluster-admin`的键，如下所示：`/registry/clusterrolebindings/cluster-admin`。
- en: 'We can use the key name to retrieve the value using the `etcdctl` utility by
    slightly modifying our previous command, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用键名通过略微修改之前的命令来使用`etcdctl`实用程序检索值，如下所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output will contain characters that cannot be interpreted by your shell,
    but you will get an idea of the data stored in `etcd`. For the `cluster-admin`
    key, the output shows us the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将包含无法由你的Shell解释的字符，但你将了解到存储在`etcd`中的数据。对于`cluster-admin`键，输出向我们展示了以下内容：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We describe the entries in `etcd` to offer an understanding of how Kubernetes
    stores and utilizes data to manage cluster objects. While you’ve already observed
    the direct database output for the `cluster-admin` key, in typical scenarios,
    you would utilize the command `kubectl get clusterrolebinding cluster-admin -o
    yaml` to query the API server for the same data. Using `kubectl`, the command
    would yield the following information:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了`etcd`中的条目，以便理解Kubernetes如何存储和利用数据来管理集群对象。虽然你已经观察到了`cluster-admin`键的直接数据库输出，但在典型情况下，你会使用`kubectl
    get clusterrolebinding cluster-admin -o yaml`命令来查询API服务器获取相同的数据。使用`kubectl`，该命令将返回以下信息：
- en: '![](img/B21165_03_02.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_03_02.png)'
- en: 'Figure 3.2: kubectl ClusterRoleBinding output'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：kubectl ClusterRoleBinding输出
- en: If you look at the output from the `kubectl` command and compare it with the
    output from the `etcdctl` query, you will see matching information. You will rarely
    have to interact with `etcd` directly; instead, you will execute `kubectl` commands,
    and the request will go to the API server, which then queries the `etcd` database
    for the resource’s information.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `kubectl` 命令的输出，并与 `etcdctl` 查询的输出进行比较，你会发现两者信息一致。你很少需要直接与 `etcd` 进行交互；你只需要执行
    `kubectl` 命令，请求会发送到 API 服务器，后者再查询 `etcd` 数据库以获取资源信息。
- en: It’s worth noting that while `etcd` is by far the most used backend database
    for Kubernetes, it isn’t the only one. The **k3s** project, which was originally
    built to strip down Kubernetes for edge use cases, replaced `etcd` with relational
    databases. When we dive into `vclusters`, which use k3s, we’ll see that it uses
    **SQLite** instead of `etcd`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，虽然 `etcd` 是 Kubernetes 中最常用的后端数据库，但它并不是唯一的。最初为边缘使用场景简化 Kubernetes 的 **k3s**
    项目将 `etcd` 替换为关系型数据库。当我们深入了解使用 k3s 的 `vclusters` 时，我们会看到它使用的是 **SQLite** 而非 `etcd`。
- en: kube-scheduler
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kube-scheduler
- en: As its name suggests, the `kube-scheduler` component oversees the allocation
    of pods to nodes. Its primary task is to consistently monitor pods that have yet
    to be assigned to any specific node. The scheduler then assesses the resource
    requirements of each pod to determine the most suitable placement. This assessment
    takes multiple factors into account, including the availability of node resources,
    constraints, selectors, and affinity/anti-affinity rules. Nodes that satisfy these
    requirements are considered feasible nodes. Finally, from the resulting list of
    compatible nodes, the scheduler chooses the most appropriate one for scheduling
    the pod.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`kube-scheduler` 组件负责监督将 Pod 分配到节点的过程。它的主要任务是持续监控那些尚未分配到任何特定节点的 Pod。调度器随后评估每个
    Pod 的资源需求，以确定最合适的放置位置。这个评估考虑了多个因素，包括节点资源的可用性、约束条件、选择器以及亲和性/反亲和性规则。满足这些要求的节点被视为可行节点。最终，调度器从符合条件的节点列表中选择最合适的节点来调度
    Pod。
- en: kube-controller-manager
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kube-controller-manager
- en: The **Kubernetes Controller Manager** is a central control system in the Kubernetes
    control plane; it’s responsible for managing and coordinating other controllers
    that handle specific tasks for the cluster.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes 控制器管理器** 是 Kubernetes 控制平面的核心控制系统；它负责管理和协调其他控制器，这些控制器处理集群中的特定任务。'
- en: The Controller Manager contains multiple controllers, each dedicated to a specific
    function within the cluster. These controllers continuously monitor the cluster’s
    current state and adapt dynamically to maintain the desired configuration.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器管理器包含多个控制器，每个控制器负责集群中某个特定功能。这些控制器持续监控集群的当前状态，并动态调整以维持所需的配置。
- en: All of the controllers are contained in a single executable, reducing complexity
    and management. Some of the controllers included are shown in *Table 3.1*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有控制器都包含在一个可执行文件中，减少了复杂性和管理工作。部分包含的控制器如 *表 3.1* 所示。
- en: 'Each controller provides a unique function to a cluster, and each controller
    and its function is listed here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控制器为集群提供独特的功能，以下是各个控制器及其功能：
- en: '| **Controller** | **Responsibilities** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **控制器** | **职责** |'
- en: '| Endpoints | Monitors new services and creates endpoints to the pods with
    matching labels |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| Endpoints | 监控新服务并为具有匹配标签的 Pod 创建端点 |'
- en: '| Namespace | Monitors actions for namespaces |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| Namespace | 监控命名空间的操作 |'
- en: '| Node | Monitors the status of nodes in the cluster, detecting node failures
    or additions, and taking appropriate actions to maintain the desired number of
    nodes |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| Node | 监控集群中节点的状态，检测节点故障或新增节点，并采取适当的行动以维持所需的节点数量 |'
- en: '| Replication | Monitors the replicas for pods, taking action to either remove
    a pod or add a pod to get to the desired state |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| Replication | 监控 Pod 的副本，采取行动以删除或添加 Pod 以达到所需状态 |'
- en: '| Service Accounts | Monitors Service accounts |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| Service Accounts | 监控服务账户 |'
- en: 'Table 3.1: Controllers and their functions'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1：控制器及其功能
- en: Each controller runs a non-terminating (never-ending) control loop. These control
    loops monitor the state of each resource, making any changes required to normalize
    the state of the resource. For example, if you needed to scale a deployment from
    one to three nodes, the replication controller would notice that the current state
    has one pod running, and the desired state is to have three pods running. To move
    the current state to the desired state, two additional pods would be requested
    by the replication controller.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控制器运行一个非终止（永不停歇）的控制循环。这些控制循环监控每个资源的状态，并根据需要进行更改，以使资源的状态恢复正常。例如，如果你需要将一个部署从一个节点扩展到三个节点，复制控制器会发现当前状态是运行了一个
    Pod，而期望的状态是有三个 Pod 运行。为了将当前状态移动到期望状态，复制控制器会请求再增加两个 Pod。
- en: cloud-controller-manager
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cloud-controller-manager
- en: This is one component that you may not have run into, depending on how your
    clusters are configured. Similar to the `kube-controller-manager` component, this
    controller contains four controllers in a single binary.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你可能没有接触过的组件，具体取决于你的集群配置。与 `kube-controller-manager` 组件类似，这个控制器包含四个控制器，在一个二进制文件中运行。
- en: The cloud controller provides integrations specific to a particular cloud provider’s
    Kubernetes service, enabling the utilization of cloud-specific functionalities
    such as load balancers, persistent storage, auto-scaling groups, and other features.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 云控制器提供与特定云提供商的 Kubernetes 服务相关的集成功能，使得可以利用云特定的功能，如负载均衡器、持久存储、自动扩展组等其他特性。
- en: Understanding the worker node components
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解工作节点组件
- en: Worker nodes, as implied by their name, have the duty of carrying out tasks
    within a Kubernetes cluster. In our previous conversation about the `kube-scheduler`
    element in the control plane, we emphasized that when a new pod requires scheduling,
    the kube-scheduler selects the suitable node for its execution. The kube-scheduler
    relies on data provided by the worker nodes to make this determination. This data
    is regularly updated to ensure a distribution of pods throughout the cluster,
    making the most of the cluster resources.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 工作节点，顾名思义，负责在 Kubernetes 集群中执行任务。在我们之前讨论控制平面中 `kube-scheduler` 组件时，我们强调了当一个新的
    Pod 需要调度时，`kube-scheduler` 会选择合适的节点来执行该任务。`kube-scheduler` 依赖工作节点提供的数据来做出这一决定。这些数据会定期更新，以确保
    Pod 在集群中的分布，使集群资源得到充分利用。
- en: Each worker node has two main components, `kubelet` and `kube-proxy`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工作节点都有两个主要组件，`kubelet` 和 `kube-proxy`。
- en: kubelet
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kubelet
- en: You may hear a worker node referred to as a `kubelet`. The `kubelet` is an agent
    that runs on all worker nodes, and it is responsible for ensuring that containers
    are running and healthy on the node.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听到工作节点被称为 `kubelet`。`kubelet` 是一个在所有工作节点上运行的代理，负责确保容器在节点上运行并保持健康。
- en: kube-proxy
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kube-proxy
- en: Contrary to the name, `kube-proxy` is not a proxy server at all (though it was
    in the original version of Kubernetes).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与名称相反，`kube-proxy` 根本不是一个代理服务器（尽管它在 Kubernetes 的最初版本中是一个代理服务器）。
- en: Depending on the CNI deployed in your cluster, you may or may not have a `kube-proxy`
    component on your nodes. CNIs like **Cilium** can be run with `kube-proxy` or
    in a `kube-proxyless` mode. In our KinD clusters, we have deployed Calico, which
    relies on the presence of `kube-proxy`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 根据集群中部署的 CNI，你的节点可能会有也可能没有 `kube-proxy` 组件。像 **Cilium** 这样的 CNI 可以与 `kube-proxy`
    一起运行，或者在 `kube-proxyless` 模式下运行。在我们的 KinD 集群中，我们部署了 Calico，它依赖 `kube-proxy` 的存在。
- en: When `kube-proxy` is deployed, its main purpose is to oversee network connectivity
    for pods and services in the cluster, providing network traffic routing to the
    destination pod(s).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `kube-proxy` 被部署时，它的主要目的是管理集群中 Pods 和服务的网络连接，为目标 Pod(s) 提供网络流量路由。
- en: Container runtime
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器运行时
- en: Each node also needs a container runtime. A container runtime is responsible
    for running the containers. The first thing you might think of is Docker, and
    while Docker is a container runtime, it is not the only runtime option available.
    Over the last several years, other options have replaced Docker as the preferred
    container runtime for clusters.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点还需要一个容器运行时。容器运行时负责运行容器。你可能首先想到的是 Docker，虽然 Docker 是一个容器运行时，但它并不是唯一的运行时选项。近年来，其他选项已经取代了
    Docker，成为集群中首选的容器运行时。
- en: The two most prominent Docker replacements are **CRI-O** and **containerd**.
    At the time of writing this chapter, KinD only offers official support for Docker
    and Red Hat’s **Podman**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最突出的两种 Docker 替代品是 **CRI-O** 和 **containerd**。在撰写本章时，KinD 仅官方支持 Docker 和 Red
    Hat 的 **Podman**。
- en: Interacting with the API server
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 API 服务器进行交互
- en: As we mentioned earlier, you interact with the API server using either direct
    API requests or the `kubectl` utility. We will focus on using `kubectl` for the
    majority of our interaction in this book, but we will call out using direct API
    calls wherever applicable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，你可以通过直接的 API 请求或使用 `kubectl` 工具与 API 服务器进行交互。虽然我们在本书中主要集中使用 `kubectl`
    进行交互，但在适用的地方我们也会提到如何使用直接的 API 调用。
- en: Using the Kubernetes kubectl utility
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 的 kubectl 工具
- en: '`kubectl` is a single executable file that allows you to interact with the
    Kubernetes API using a **command-line interface** (**CLI**). It is available for
    most major operating systems and architectures, including Linux, Windows, and
    macOS.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 是一个单一的可执行文件，它允许你通过 **命令行界面**（**CLI**）与 Kubernetes API 进行交互。它支持大多数主流操作系统和架构，包括
    Linux、Windows 和 macOS。'
- en: 'Note: We have already installed `kubectl` using the KinD script that created
    our cluster in *Chapter 2*. Installation instructions for most operating systems
    are located on the Kubernetes site at [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/).
    Since we are using Linux as our operating system for the exercises in the book,
    we will cover installing `kubectl` on a Linux machine. Follow these steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们已经使用 KinD 脚本安装了 `kubectl`，该脚本创建了我们的集群，详见 *第 2 章*。大多数操作系统的安装说明可以在 Kubernetes
    网站上找到，网址为 [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)。由于我们使用
    Linux 作为本书练习的操作系统，接下来将介绍如何在 Linux 机器上安装 `kubectl`。请按照以下步骤操作：
- en: 'To download the latest version of `kubectl`, you can run a `curl` command that
    will download it, as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要下载最新版本的 `kubectl`，你可以运行一个 `curl` 命令来下载它，如下所示：
- en: '[PRE4]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After downloading, you need to make the file executable by running the following
    command:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载后，你需要运行以下命令使该文件变为可执行文件：
- en: '[PRE5]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we will move the executable to our path, as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将把可执行文件移动到系统路径中，如下所示：
- en: '[PRE6]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You now have the latest `kubectl` utility on your system and can execute `kubectl`
    commands from any working directory.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的系统上已经安装了最新版本的 `kubectl` 工具，并且可以从任何工作目录执行 `kubectl` 命令。
- en: 'Kubernetes is updated about every 4 months. This includes upgrades to the base
    Kubernetes cluster components and the `kubectl` utility. You may run into a version
    mismatch between a cluster and your `kubectl` command, requiring you to either
    upgrade or download your `kubectl` executable. You can always check the version
    of both by running a `kubectl` `version` command, which will output the version
    of both the API server and the `kubectl` client. The output from a version check
    is shown in the following code snippet – please note, your output may differ from
    our example output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 大约每 4 个月更新一次。这包括对基础 Kubernetes 集群组件和 `kubectl` 工具的升级。你可能会遇到集群与 `kubectl`
    命令版本不匹配的情况，这时你需要升级或下载新的 `kubectl` 可执行文件。你可以通过运行 `kubectl` `version` 命令来检查两个版本，这个命令会输出
    API 服务器和 `kubectl` 客户端的版本信息。版本检查的输出如下所示——请注意，你的输出可能与我们的示例输出不同：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see from the output, the `kubectl` client is running version `1.30.0`
    and the cluster is running `1.30.0`. A minor version difference in the two will
    not cause any issues. In fact, the official supported version difference is within
    one major version release. So, if your client is running version 1.29 and the
    cluster is running 1.30.0, you would be within the supported version difference.
    While this may be supported, it doesn’t mean that you won’t run into issues if
    you are trying to use any new commands or resources included in the higher version.
    In general, you should try to keep your cluster and client version in sync to
    avoid any issues.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出结果中可以看到，`kubectl` 客户端正在运行 `1.30.0` 版本，集群则运行 `1.30.0` 版本。两者之间的微小版本差异不会造成任何问题。事实上，官方支持的版本差异最多为一个主版本号。因此，如果你的客户端版本为
    1.29，而集群版本为 1.30.0，你仍然在支持的版本差异范围内。尽管这可能是被支持的，但如果你试图使用更高版本中包含的新命令或资源，可能会遇到一些问题。通常情况下，你应该尽量保持集群和客户端版本的一致性，以避免任何问题。
- en: 'Through the remainder of this chapter, we will discuss Kubernetes resources
    and how you interact with the API server to manage each one. But before diving
    into the different resources, we wanted to mention one commonly overlooked option
    of the `kubectl` utility: the `verbose` option.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将讨论 Kubernetes 资源以及如何与 API 服务器交互来管理每个资源。但在深入了解不同的资源之前，我们想提到一个经常被忽视的
    `kubectl` 工具选项：`verbose` 选项。
- en: Understanding the verbose option
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解详细选项
- en: When you execute a `kubectl` command, the only outputs you will see by default
    are any direct responses to your command. If you were to look at all pods in the
    `kube-system` namespace, you would receive a list of all pods. In most cases,
    this is the desired output, but what if you issued a `get` `Pods` request and
    received an error from the API server? How could you get more information about
    what might be causing the error?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行 `kubectl` 命令时，默认情况下你看到的唯一输出是对你的命令的任何直接响应。如果你查看 `kube-system` 命名空间中的所有 Pod，你将得到一个所有
    Pod 的列表。在大多数情况下，这是所期望的输出，但如果你发出 `get` `Pods` 请求并收到 API 服务器的错误，怎么办？你如何获取更多信息来找出导致错误的原因？
- en: By adding the `verbose` option to your `kubectl` command, you can get additional
    details about the API call itself and any replies from the API server. Often,
    the replies from the API server will contain additional information that may be
    useful to find the root cause of the issue.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `kubectl` 命令中添加 `verbose` 选项，你可以获取有关 API 调用本身以及 API 服务器的任何回复的附加信息。通常，API
    服务器的回复会包含一些额外的信息，这些信息可能对找到问题的根本原因很有帮助。
- en: The `verbose` option has multiple levels ranging from 0 to 9; the higher the
    number, the more output you will receive.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`verbose` 选项有多个级别，范围从 0 到 9，数字越高，输出的内容就越多。'
- en: 'The following screenshot has been taken from the Kubernetes site, detailing
    each level and what the output will include:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图来自 Kubernetes 官方网站，详细说明了每个级别及其输出内容：
- en: '![Figure 5.5 – Verbosity description ](img/B21165_03_03.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 详细程度描述](img/B21165_03_03.png)'
- en: 'Figure 3.3: Verbosity description'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：详细程度描述
- en: You can experiment with the levels by adding the `-v` or `--v` option to any
    `kubectl` command.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向任何 `kubectl` 命令添加 `-v` 或 `--v` 选项来实验不同的级别。
- en: General kubectl commands
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般 kubectl 命令
- en: The CLI allows you to interact with Kubernetes in an imperative and declarative
    manner. Using an imperative command involves you telling Kubernetes what to do—for
    example, `kubectl run nginx --image nginx`. This tells the API server to create
    a new pod called `nginx` that runs an image called `nginx`. While imperative commands
    are useful for development and quick fixes or testing, you will use declarative
    commands more often in a production environment. In a declarative command, you
    tell Kubernetes what you want. To use declarative commands, you send a manifest
    to the API server, written in either **JavaScript Object Notation** (**JSON**)
    or **YAML Ain’t Markup Language** (**YAML**), which declares what you want Kubernetes
    to create.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 允许你以命令式和声明式两种方式与 Kubernetes 进行交互。使用命令式命令意味着你告诉 Kubernetes 做什么——例如，`kubectl
    run nginx --image nginx`。这告诉 API 服务器创建一个名为 `nginx` 的 Pod，并运行一个名为 `nginx` 的镜像。虽然命令式命令在开发、快速修复或测试中很有用，但在生产环境中你将更多使用声明式命令。在声明式命令中，你告诉
    Kubernetes 你想要什么。要使用声明式命令，你需要向 API 服务器发送一个声明性清单，该清单使用 **JavaScript 对象表示法** (**JSON**)
    或 **YAML 不是标记语言** (**YAML**) 编写，声明你希望 Kubernetes 创建的内容。
- en: '`kubectl` includes commands and options that can provide general cluster information
    or information about a resource. The table below contains a cheat sheet of commands
    and what they are used for. We will use many of these commands in future chapters,
    so you will see them in action throughout the book:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 包含可以提供一般集群信息或有关资源信息的命令和选项。下表包含了一些命令及其用途的小抄。我们将在未来的章节中使用这些命令，因此你将在本书中看到它们的实际应用：'
- en: '| **Cluster Commands** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **集群命令** |'
- en: '| `api-resources` | Lists supported API resources |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `api-resources` | 列出支持的 API 资源 |'
- en: '| `api-versions` | Lists supported API versions |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `api-versions` | 列出支持的 API 版本 |'
- en: '| `cluster-info` | Lists cluster information, including the API server and
    other cluster endpoints |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `cluster-info` | 列出集群信息，包括 API 服务器和其他集群端点 |'
- en: '| **Object Commands** |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **对象命令** |'
- en: '| `get <object>` | Retrieves a list of all objects (i.e., pods, ingress, etc.)
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `get <object>` | 获取所有对象的列表（例如，pods、ingress 等） |'
- en: '| `describe <object>` | Provides details for the object |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `describe <object>` | 提供对象的详细信息 |'
- en: '| `logs <pod name>` | Retrieve the logs for a pod |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `logs <pod name>` | 获取某个 Pod 的日志 |'
- en: '| `edit <object>` | Edits an object interactively |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `edit <object>` | 交互式编辑一个对象 |'
- en: '| `delete <object>` | Deletes an object |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `delete <object>` | 删除一个对象 |'
- en: '| `label <object>` | Labels an object |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `label <object>` | 给对象打标签 |'
- en: '| `annotate <object>` | Annotates an object |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `annotate <object>` | 给对象添加注解 |'
- en: '| `run` | Creates a pod |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `run` | 创建一个 pod |'
- en: 'Table 3.2: Cluster and object commands'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2：集群和对象命令
- en: With an understanding of each Kubernetes component and how to interact with
    the API server using imperative commands, we can now move on to Kubernetes resources
    and how we use `kubectl` to manage them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解每个 Kubernetes 组件以及如何使用命令式命令与 API 服务器交互，我们现在可以继续了解 Kubernetes 资源以及如何使用 `kubectl`
    来管理它们。
- en: Introducing Kubernetes resources
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Kubernetes 资源
- en: In this section, we will provide a substantial amount of information. However,
    as this is a bootcamp, we won’t go into exhaustive details about each resource.
    It’s worth noting that each resource could easily warrant its own dedicated chapter
    or even multiple chapters in a book. Since numerous books on basic Kubernetes
    already cover these resources extensively, we will focus on the essential aspects
    necessary for a basic understanding of each resource. As we progress through the
    subsequent chapters, we will supplement additional details about the resources
    as we expand our cluster using the exercises provided in the book.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将提供大量的信息。然而，由于这是一个训练营，我们不会深入讨论每个资源的详尽细节。值得注意的是，每个资源都可能需要单独一章，甚至是一本书的多个章节。由于许多关于基础
    Kubernetes 的书籍已经广泛讨论了这些资源，我们将集中讨论每个资源的基本理解所必需的核心内容。在接下来的章节中，我们将随着通过书中练习扩展集群，补充更多关于资源的细节。
- en: Prior to delving into a comprehensive understanding of Kubernetes resources,
    let’s begin by introducing the concept of Kubernetes manifests.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入全面理解 Kubernetes 资源之前，让我们先介绍一下 Kubernetes 清单的概念。
- en: Kubernetes manifests
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 清单
- en: The files that we will use to create Kubernetes resources are referred to as
    manifests. A manifest can be created using YAML or JSON—most manifests use YAML,
    and that is the format we will use throughout the book.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用来创建 Kubernetes 资源的文件被称为清单。清单可以使用 YAML 或 JSON 创建——大多数清单使用 YAML，这也是我们在本书中使用的格式。
- en: It’s important to note that while we are working with YAML files, `kubectl`
    will convert all YAML into JSON when interacting with your API server. All API
    calls are made with JSON, even if the manifests are written in YAML.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在使用 YAML 文件时，`kubectl` 会将所有 YAML 转换为 JSON 来与您的 API 服务器交互。所有 API 调用都是使用
    JSON，即使清单是用 YAML 编写的。
- en: 'The content of a manifest will vary depending on the resource, or resources,
    that will be created. At a minimum, all manifests require a base configuration
    that includes `apiVersion`, the `kind` of resource, and `metadata` fields, as
    can be seen here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 清单的内容会根据将要创建的资源或多个资源而有所不同。最基本的，所有清单都需要包含一个基础配置，其中包括 `apiVersion`、资源的 `kind`
    和 `metadata` 字段，如下所示：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding manifest alone is not complete; we are only showing the beginning
    of a full `Deployment` manifest. As you can see in the file, we start with the
    three required fields that all manifests are required to have: the `apiVersion`,
    `kind`, and `metadata` fields.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的清单本身并不完整；我们仅展示了一个完整 `Deployment` 清单的开头。如您所见，文件中开始部分包含了所有清单必须具备的三个字段：`apiVersion`、`kind`
    和 `metadata` 字段。
- en: You may also notice that there is a format for fields in the file. YAML is very
    format-specific, and if the format of any line is off by even a single space,
    you will receive an error when you try to deploy the manifest. This takes time
    to get used to, and even after creating manifests for a long time, formatting
    issues will still pop up from time to time.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会注意到文件中的字段格式。YAML 格式非常严格，如果任何一行的格式错位了哪怕一个空格，您在尝试部署清单时会收到错误。这需要时间来适应，即使是创建清单很长时间的人，格式问题也时常会出现。
- en: What are Kubernetes resources?
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Kubernetes 资源？
- en: When you want to add or delete something from a cluster, you are interacting
    with Kubernetes resources. This interaction is how you declare your desired state
    for the resource, which may be to create, delete, or scale a resource. Based on
    the desired state, the API server will make sure that the current state equals
    the desired state. For example, if you have a deployment that starts with a single
    replica, you can change the deployment resource from 1 to 3 replicas. When the
    API server sees that the current state is 1, it will scale the deployment out
    to 3 replicas by creating the additional 2 pods.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve a list of resources a cluster supports, you can use the `kubectl
    api-resources` command. The API server will reply with a list of all resources,
    including any valid short name, namespace support, and supported API group.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: There are approximately 58 base resources included with a Kubernetes cluster,
    but it’s very common to have many more than 58 in a production cluster. Many add-on
    components, like Calico, will extend the Kubernetes API with new objects. As a
    cluster has different add-ons deployed in the cluster, don’t be surprised at 100+
    resources in a list.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'An abbreviated list of the most common resources is shown below:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '| **NAME** | **SHORT NAMES** | **API VERSION** | **NAMESPACED** |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| apiservices | apiregistration.k8s.io/v1 | FALSE |  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| certificatesigningrequests | Csr | certificates.k8s.io/v1 | FALSE |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| clusterrolebindings | rbac.authorization.k8s.io/v1 | FALSE |  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| clusterroles | rbac.authorization.k8s.io/v1 | FALSE |  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| componentstatuses | Cs | v1 | FALSE |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| configmaps | Cm | v1 | TRUE |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| controllerrevisions | apps/v1 | TRUE |  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| cronjobs | Cj | batch/v1 | TRUE |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| csidrivers | storage.k8s.io/v1 | FALSE |  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| csinodes | storage.k8s.io/v1 | FALSE |  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| csistoragecapacities | storage.k8s.io/v1 | TRUE |  |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| customresourcedefinitions | crd,crds | apiextensions.k8s.io/v1 | FALSE |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| daemonsets | Ds | apps/v1 | TRUE |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| deployments | Deploy | apps/v1 | TRUE |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| endpoints | Ep | v1 | TRUE |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| endpointslices | discovery.k8s.io/v1 | TRUE |  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| events | Ev | v1 | TRUE |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| events | Ev | events.k8s.io/v1 | TRUE |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| flowschemas | flowcontrol.apiserver.k8s.io/v1beta3 | FALSE |  |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| horizontalpodautoscalers | Hpa | autoscaling/v2 | TRUE |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| ingressclasses | networking.k8s.io/v1 | FALSE |  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| ingresses | Ing | networking.k8s.io/v1 | TRUE |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| jobs | batch/v1 | TRUE |  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| limitranges | Limits | v1 | TRUE |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| localsubjectaccessreviews | authorization.k8s.io/v1 | TRUE |  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| mutatingwebhookconfigurations | admissionregistration.k8s.io/v1 | FALSE |  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| namespaces | Ns | v1 | FALSE |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| networkpolicies | Netpol | networking.k8s.io/v1 | TRUE |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| nodes | No | v1 | FALSE |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| persistentvolumeclaims | Pvc | v1 | TRUE |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| persistentvolumes | pv | v1 | FALSE |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| poddisruptionbudgets | pdb | policy/v1 | TRUE |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| pods | po | v1 | TRUE |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| podtemplates | v1 | TRUE |  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| priorityclasses | pc | scheduling.k8s.io/v1 | FALSE |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| prioritylevelconfigurations | flowcontrol.apiserver.k8s.io/v1beta3 | FALSE
    |  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| profiles | projectcalico.org/v3 | FALSE |  |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| replicasets | rs | apps/v1 | TRUE |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| replicationcontrollers | rc | v1 | TRUE |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| resourcequotas | quota | v1 | TRUE |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| rolebindings | rbac.authorization.k8s.io/v1 | TRUE |  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| roles | rbac.authorization.k8s.io/v1 | TRUE |  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| runtimeclasses | node.k8s.io/v1 | FALSE |  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| secrets | v1 | TRUE |  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| selfsubjectaccessreviews | authorization.k8s.io/v1 | FALSE |  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| selfsubjectrulesreviews | authorization.k8s.io/v1 | FALSE |  |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| serviceaccounts | sa | v1 | TRUE |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| services | svc | v1 | TRUE |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| statefulsets | sts | apps/v1 | TRUE |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| storageclasses | sc | storage.k8s.io/v1 | FALSE |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| subjectaccessreviews | authorization.k8s.io/v1 | FALSE |  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| tokenreviews | authentication.k8s.io/v1 | FALSE |  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| validatingwebhookconfigurations | admissionregistration.k8s.io/v1 | FALSE
    |  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| volumeattachments | storage.k8s.io/v1 | FALSE |  |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: 'Table 3.3: Kubernetes API resources'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: As this chapter functions as a bootcamp, we will provide a short overview of
    the resources found in *Table 3.3*. To effectively comprehend the following chapters,
    it is important for you to possess a strong understanding of the objects and their
    respective functions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Some resources will also be explained in greater detail in future chapters,
    including `Ingress`, `RoleBindings`, `ClusterRoles`, `StorageClasses`, and more.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing Kubernetes resources
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most resources in a cluster are run in a namespace, and to create/edit/read
    them, you should supply the `-n <namespace>` option to any `kubectl` command.
    To find a list of resources that accept a namespace option, you can reference
    the output from *Table 3.3*. If a resource can be referenced by a namespace, the
    `NAMESPACED` column will show `TRUE`. If the resource is only referenced by the
    cluster level, the `NAMESPACED` column will show `FALSE`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Apiservices
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apiservices provide the primary entry point for communication and interaction
    between Kubernetes components and all external resources, such as users, applications,
    and other services. They provide a set of endpoints that allow users and applications
    to perform various operations, such as creating, updating, and deleting Kubernetes
    resources (i.e., pods, deployments, services, and namespaces).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Apiservices handle the authentication, authorization, and validation of requests,
    allowing only authorized users and applications to access or modify resources.
    They also handle resource versioning and other critical aspects of a Kubernetes
    cluster.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: They can also extend Kubernetes functionality by developing custom controllers,
    operators, or other components that interact with the API Services to manage and
    automate various aspects of the cluster’s behavior. One example of this is our
    CNI, Calico, which adds 31 extra `api-resources` to a cluster.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: CertificateSigningRequests
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **CertificateSigningRequest** (**CSR**) allows you to request a certificate
    from a certificate authority. These are typically used to obtain trusted certificates
    for securing communication within a Kubernetes cluster.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: ClusterRoles
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `ClusterRole` is a collection of permissions that enable interaction with
    the API of the cluster. It pairs an action, or verb, with an API group to define
    a specific permission. For example, if you intended to restrict a **continuous
    integration/continuous delivery** (**CI/CD**) pipeline’s ability to only patch
    Deployments for updating image tags, you could utilize a `ClusterRole` similar
    to the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A `ClusterRole` can apply to APIs at both the cluster and namespace levels.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: ClusterRoleBindings
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have specified a `ClusterRole`, the next step is to create an association
    between the `ClusterRole` and a subject using a `ClusterRoleBinding`. This binding
    links the `ClusterRole` to a user, group, or service account, granting them the
    permissions defined within the `ClusterRole`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore `ClusterRoleBinding` in more detail in *Chapter 7*, *RBAC Policies
    and Auditing*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: ComponentStatus
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Kubernetes control plane is a crucial component for a cluster; it is essential
    for the operation of the cluster. `ComponentStatus` is an object that shows the
    health and status of different Kubernetes control plane components. It provides
    an indicator of the overall health of a component, providing information on whether
    it is operating correctly or has errors.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMaps
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A ConfigMap is a resource that stores data in key-value pairs, enabling the
    separation of configuration from your application. `ConfigMaps` can hold various
    types of data, including literal values, files, or directories, allowing flexibility
    in managing your application’s configuration.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an imperative example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `<data>` option will vary based on the source of the `ConfigMap`. To use
    a file or a directory, you supply the `--from-file` option and either the path
    to a file or an entire directory, as shown here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This would create a new `ConfigMap` named `config-test`, with the `nginx.conf`
    key containing the content of the `nginx.conf` file as the value.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to have more than one key added in a single `ConfigMap`, you put
    each file into a directory and create the `ConfigMap` using all of the files in
    the directory. For example, you have three files in a directory located at `~/config/myapp`.
    The files each contain data and are called `config1`, `config2`, and `config3`.
    To create a `ConfigMap` that would add each file into a key, you need to supply
    the `--from-file` option and point to the directory, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This would create a new `ConfigMap` with three key values called `config1`,
    `config2`, and `config3`. Each key will contain a value equal to the content of
    each file in the directory.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'To quickly show a `ConfigMap`, using the example mentioned above, we can retrieve
    `it` using the `get` command, `kubectl get configmaps config-test`, resulting
    in the following output:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `ConfigMap` is comprised of three keys, indicated by the presence of the
    number `3` under the `DATA` column. For a more detailed examination, we can utilize
    the `kubectl get` command with the additional “`-o yaml`" option appended to the
    `kubectl get configmaps config-test` command. This will show the output of each
    key’s value represented in YAML format, as demonstrated below:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By examining the output, it shows that each key within the `ConfigMap` corresponds
    to the filenames found in the directory—`config1`, `config2`, and `config3`. Each
    key retains the value obtained from the data within its respective file.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: One limitation of `ConfigMaps` that you should keep in mind is that the data
    is easily accessible to anyone with permission to the resource. As you can see
    from the preceding output, a simple `get` command shows the data in cleartext.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Due to this design, you should never store sensitive information such as a password
    in a `ConfigMap`. Later in this section, we will cover a resource that was designed
    to store secret data information, called a `Secret`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: ControllerRevisions
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `ControllerRevision` is like a snapshot of a particular version or update
    to a controller’s settings. It’s mainly used by specific controllers, such as
    the `StatefulSet` controller, to keep track of and manage changes made to their
    configurations as time goes on.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Whenever there are modifications or updates to the configuration of a resource
    managed by a controller, a new `ControllerRevision` is created. Each revision
    includes the desired setup of the controller and a revision number. These revisions
    are stored in the Kubernetes API server, allowing you to refer to or revert to
    them whenever necessary.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: CronJobs
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have used Linux cronjobs in the past, then you already know what a Kubernetes
    `CronJob` resource is. If you don’t have a Linux background, a cronjob is used
    to create a scheduled task. As another example, if you are a Windows person, it’s
    similar to Windows scheduled tasks.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'An example manifest that creates a `CronJob` is shown in the following code
    snippet:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `schedule` format follows the standard `cron` format. From left to right,
    each `*` represents the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Minute (0–59)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hour (0–23)
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day (1–31)
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Month (1–12)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day of the week (0–6) (Sunday = 0, Saturday = 6)
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CronJob` accept step values, which allow you to create a schedule that can
    execute every minute, every 2 minutes, or every hour.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Our example manifest will create a `CronJob` that runs an image called `hello-world`
    every minute and outputs `Hello World!` in the Pod log.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: CSI drivers
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes uses the `CsiDriver` resource to connect nodes to a storage system.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'You can list all CSI drivers that are available on a cluster by executing the
    `kubectl get csidriver` command. In one of our lab clusters, we are using NetApp’s
    SolidFire for storage, so our cluster has the Trident CSI driver installed, as
    can be seen here:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: CSI nodes
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid storing storage information in the node’s API resource, the `CSINode`
    resource was added to the API server to store information generated by the CSI
    drivers. The information that is stored includes mapping Kubernetes node names
    to CSI node names, CSI driver availability, and the volume topology.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: CSIStorageCapacities
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`CSIStorageCapacity` is a component that stores information about the storage
    capacity for a given CSI, representing the available storage capacity for a given
    `StorageClass`. This information is used when K8s decides where to create new
    `PersistentVolumes`.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: CustomResourceDefinitions
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **CustomResourceDefinition** (**CRD**) is a way for users to make their own
    custom resources in a Kubernetes cluster.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: It outlines the structure, format, and behavior of the custom resource, including
    its API endpoints and supported operations. Once a CRD is made and added to the
    cluster, it becomes a built-in resource type that can be managed using regular
    Kubernetes tools and APIs.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: DaemonSets
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `DaemonSet` enables the deployment of a pod on each node in a cluster or on
    a specific set of nodes. It is commonly utilized to deploy essential components
    like logging, which are required on every node in the cluster. Once a `DaemonSet`
    is set up, it automatically creates a pod on each existing node.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, as new nodes are added to the cluster, the `DaemonSet` ensures that
    a pod is deployed on the newly joined nodes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Deployments
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We mentioned earlier that you should never deploy a pod directly. One reason
    for this is that you cannot scale a pod or perform a rolling upgrade when a pod
    is created in this way. `Deployments` offer you many advantages, including a way
    to manage your upgrades declaratively and the ability to roll back to previous
    revisions. Creating a `Deployment` is actually a three-step process that is executed
    by the API server: a `Deployment` is created, which creates a `ReplicaSet`, which
    then creates the pod(s) for the application.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Even if you don’t plan to scale or perform rolling upgrades to the application,
    you should still use `Deployments` by default so that you can leverage the features
    at a future date.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Endpoints
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An `Endpoint` maps a service to a pod or pods. This will make more sense when
    we explain the `Service` resource. For now, you only need to know that you can
    use the CLI to retrieve endpoints by using the `kubectl get endpoints` command.
    In a new KinD cluster, you will see a value for the Kubernetes API server in the
    default namespace, as illustrated in the following code snippet:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output shows that the cluster has a service called `kubernetes` that has
    an endpoint at the **Internet Protocol** (**IP**) address `172.17.0.2` on port
    `6443`. The IP that is returned in our example is the address to which our Docker
    control plane container has been assigned.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Later, you will see how looking at endpoints can be used to troubleshoot service
    and ingress issues.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: EndPointSlices
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Endpoints` do not scale well—they store all endpoints in a single resource.
    When dealing with a smaller deployment that may have a handful of pods, this isn’t
    an issue. As clusters grow and applications scale, endpoint sizes also grow, and
    this will impact the performance of your control plane and cause additional network
    traffic as endpoints change.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '`EndPointSlices` are designed to take on more significant and larger scenarios
    that require scalability and precise control over network endpoints. By default,
    each `EndPointSlice` can hold up to 100 endpoints, which can be increased by adding
    the `--max-endpoints-per-slice` option to the `kube-controller-manager`.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have a deployment of a Service in Kubernetes with a large number
    of pods. If one of those pods is deleted, Kubernetes will only update the specific
    slice that contains the information about that pod. When the updated slice is
    distributed across the cluster, it will only include details for a smaller subset
    of pods. By doing so, the cluster network remains efficient and avoids becoming
    overwhelmed with excessive data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Events
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Events` resource will display any events for a namespace. To get a list
    of events for the `kube-system` namespace, you would use the `kubectl get events
    -n kube-system` command.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: FlowSchemas
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes clusters have predefined settings that manage the handling of concurrent
    requests to the API server, ensuring that the traffic does not overload the server.
    However, you have the flexibility to customize and configure your own flow schema
    and priority levels for requests directed at the API server in your clusters.
    This allows you to define specific rules and preferences for how requests are
    handled and prioritized, tailoring the behavior of the API server to suit your
    specific requirements and workload.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: For example, you have a namespace that has an important application deployed.
    You could create a `FlowSchema` with a high priority so the API server would handle
    requests for the namespace before other requests.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: HorizontalPodAutoscalers
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the biggest advantages of running a workload on a Kubernetes cluster
    is the ability to automatically scale your pods. While you can scale using the
    `kubectl` command or by editing a manifest’s replica count, these are not automated
    and require manual intervention.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '**Horizontal Pod Autoscalers** (**HPAs**) provide the ability to scale an application
    based on a set of criteria. Using metrics such as CPU and memory usage, or your
    own custom metrics, you can set a rule to scale your pods out when you need more
    pods to maintain your service level.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: After a cooldown period, Kubernetes will scale the application back to the minimum
    number of pods defined in the policy.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'To quickly create an HPA for an NGINX Deployment, we can execute a `kubectl`
    command using the `autoscale` option, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also create a Kubernetes manifest to create your HPAs. Using the same
    options as those we did in the CLI, our manifest would look like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both options will create an HPA that will scale `nginx-deployment` up to 5 replicas
    when the `Deployment` hits a CPU utilization of 50%. Once the `Deployment` usage
    falls below 50% and the cooldown period is reached (by default, 5 minutes), the
    replica count will be reduced to 1.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: IngressClasses
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`IngressClasses` allow you to define and oversee various types of Ingress controllers.
    They offer the ability to personalize and adjust the behavior of these controllers
    according to specific needs, providing customizable routing of incoming traffic
    to services. `IngressClasses` allow you to manage and fine-tune Ingress controllers,
    ensuring that traffic is handled in a manner that aligns with your requirements.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The most important role an `IngressClass` has is to let you define multiple
    Ingress controllers in a single cluster. For instance, the Kubernetes Dashboard
    version 3 uses a specific `IngressClass` to make sure its `Ingress` objects are
    bound to an NGINX instance that doesn’t have a `LoadBalancer`, so it can’t be
    accessed from outside the cluster. You can also use this feature to connect Ingress
    controllers to different networks.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Ingress
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An `Ingress` resource is a tool that lets you create rules for incoming HTTP
    and HTTPS traffic to services using options like hostnames, paths, or request
    headers. It acts as a middleman between the external traffic and the services
    running in the cluster. By using `Ingress`, you can define how different types
    of traffic should be routed to specific services, giving you granular control
    over the flow of incoming requests.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss `Ingress` in depth in the next chapter, but a quick description
    of what `Ingress` provides is that it allows you to expose your application to
    the outside world using an assigned URL.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Jobs
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Jobs` allow you to execute a specific number of executions of a pod or pods.
    Unlike a `CronJob` resource, these pods are not run on a set schedule, but rather
    they will execute once when they are created.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: LimitRanges
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will discuss the `Quota` resource later in this chapter, but a `LimitRange`
    is a configuration that allows you to establish and enforce specific boundaries
    and restrictions on resource allocations for pods and containers within a given
    namespace. By utilizing `LimitRanges`, you can define limits on resources, such
    as CPU, memory, and storage, ensuring that pods and containers operate efficiently
    and prevent any negative impact on the overall cluster environment.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: LocalSubjectAccessReview
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`LocalSubjectAccessReview` is a feature that helps you check if a user or group
    in the cluster has the required permissions to perform a specific action on a
    local resource. It enables you to review access permissions directly within the
    cluster without relying on external API requests.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Using `LocalSubjectAccessReview`, you can specify the user or group identity
    along with the action and resource you want to evaluate. The Kubernetes API server
    will then verify the permissions against the local access control policies. It
    will respond with whether the requested action is allowed or denied.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: MutatingWebhookConfiguration
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`MutatingWebhookConfiguration` is used to create webhooks that can intercept
    and modify requests sent to the API server, providing a way to automatically modify
    the requested resources.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: A `MutatingWebhookConfiguration` contains a set of rules that determine which
    requests should be intercepted and processed by a webhook. When a request matches
    the defined rules, the `MutatingWebhookConfiguration` triggers the corresponding
    webhooks, which can then modify the payload. Modifications can include adding,
    removing, or modifying fields and annotations in the resource being created or
    updated.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Namespace` is a resource to divide a cluster into logical units. Each `Namespace`
    allows granular management of resources, including permissions, quotas, and reporting.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The `Namespace` resource is used for namespace tasks, which are cluster-level
    operations. Using the `namespace` resource, you can execute commands including
    `create`, `delete`, `edit`, and `get`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for the command is `kubectl <verb> ns <namespace name>`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: For example, to describe the `kube-system` namespace, we would execute a `kubectl
    describe namespaces kube-system` command.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'This will return information for the namespace, including any labels, annotations,
    and assigned quotas, as illustrated in the following code snippet:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding output, you can see that this namespace does not have any labels,
    annotations, or resource quotas assigned.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: This section is only meant to introduce the concept of namespaces as a management
    unit in multi-tenant clusters. If you plan to run clusters with multiple tenants,
    you need to understand how namespaces can be used to secure a cluster.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: NetworkPolicies
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`NetworkPolicy` resources let you define how network traffic, both ingress
    (incoming) and egress (outgoing), can flow through your cluster. They allow you
    to use Kubernetes native constructs to define which pods can talk to other Pods.
    If you’ve ever used security groups in **Amazon Web Services** (**AWS**) to lock
    down access between two groups of systems, it’s a similar concept. As an example,
    the following policy will allow traffic on port `443` to pods in the `myns` namespace
    from any namespace with the `app.kubernetes.io/name: ingress-nginx` label on it
    (which is the default label for the `nginx-ingress` namespace):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A `NetworkPolicy` is another resource that you can use to secure a cluster.
    They should be used in all production clusters, but in a multi-tenant cluster,
    they should be considered a **must-have** to secure each namespace in the cluster.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Nodes
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `nodes` resource is a cluster-level resource that is used to interact with
    the cluster’s nodes. This resource can be used with various actions including
    `get`, `describe`, `label`, and `annotate`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve a list of all of the nodes in a cluster using `kubectl`, you need
    to execute a `kubectl get nodes` command. On a new KinD cluster running a simple
    one-node cluster, this would display as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can also use the nodes resource to get details of a single node using the
    `describe` command. To get a description of the KinD node listed previously, we
    can execute `kubectl describe node kind-control-plane`, which would return details
    on the node, including consumed resources, running pods, IP **classless inter-domain
    routing** (**CIDR**) ranges, and more.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: PersistentVolumeClaims
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A PVC is a namespaced resource that is used by a pod to consume persistent storage.
    A PVC uses a **persistent volume** (**PV**) to map the actual storage resource,
    which can be on any support storage system, including **NFS** and **iSCSI**.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: As with most resources we have discussed, you can issue `get`, `describe`, and
    `delete` commands on a PVC resource. Since these are used by pods in the namespace,
    PVCs must be created in the same namespace as the pod(s) that will use the PVC.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: PersistentVolumes
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PVs are used by PVCs to create a link between the PVC and the underlying storage
    system. Manually maintaining PVs is a messy, manual task, and it should be avoided.
    Instead, Kubernetes includes the ability to manage most common storage systems
    using the **Container Storage Interface** (**CSI**).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Most CSI solutions that are used in an Enterprise cluster provide auto-provisioning
    support, as we discussed in *Chapter 2* when we introduced Rancher’s local provisioner.
    Solutions that support auto-provisioning remove the administrative overhead that
    is required to create PVs manually, taking care of the creation and mapping of
    the PVs to PVCs automatically.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: PodDisruptionBudgets
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `PodDisruptionBudget` (PDB) is a resource that creates boundaries on the maximum
    number of unavailable pods at any given time. Its purpose is to prevent situations
    where multiple pods are terminated simultaneously, which could result in service
    disruptions or failures. By defining the minimum number of available pods, referred
    to as the `"minAvailable"` parameter, you can guarantee that a specific quantity
    of pods remains functional during maintenance or other disruptive occurrences.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The `kube-scheduler` in a cloud will use this information to figure out how
    to replace nodes during an upgrade. You need to be careful when using a `PodDisruptionBudget`
    because you could find a situation where an upgrade is halted.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Pods
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The pod resource is used to interact with the pods that are running your container(s).
    Using the `kubectl` utility, you can use commands such as `get`, `delete`, and
    `describe`. For example, if you wanted to get a list of all pods in the `kube-system`
    namespace, you would execute a `kubectl get Pods -n kube-system` command that
    would return all pods in the namespace, as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While you can create a pod directly, you should avoid doing so unless you are
    using a pod for quick troubleshooting. pods that are created directly cannot use
    many of the features provided by Kubernetes, including scaling, automatic restarts,
    or rolling upgrades.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Instead of creating a pod directly, you should use a `Deployment`, `StatefulSet`,
    or, in some rare cases, `ReplicaSet` resource or replication controller.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: PodTemplates
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PodTemplates` provide a way to create templates or blueprints for creating
    pods. They function as reusable configurations that include the desired specifications
    and settings for pods. They include the metadata and specifications of a pod,
    including the name, labels, containers, volumes, and other attributes.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '`PodTemplates` are commonly used in other Kubernetes objects such as `ReplicaSets`,
    `Deployments`, and `StatefulSets`. These resources rely on a `PodTemplate` to
    generate and manage a collection of pods with consistent configurations and behavior.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: PriorityClasses
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PriorityClasses` provide a way to prioritize pods based on their importance.
    This allows the Kubernetes scheduler to make better decisions regarding resource
    allocation and pod scheduling in a cluster.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: To define `PriorityClasses`, you create a new `PriorityClass` resource associated
    with numeric values that indicate the priority level. pods with higher priority
    values are given priority over lower values when it comes to resource allocation
    and scheduling.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Using `PriorityClasses`, you can guarantee that crucial workloads are given
    higher priority in terms of resource allocation and scheduling, providing the
    necessary resources to run smoothly.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: PriorityLevelConfigurations
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PriorityLevelConfigurations` are objects that help define priority levels
    for requests sent to the API server. They provide control over how API requests
    are processed and prioritized within a cluster. Using `PriorityLevelConfigurations`,
    you can establish multiple priority levels, assigned to specific attributes. These
    attributes include setting limits on the maximum number of queries per second
    (QPS) and concurrent requests for a particular priority level. This allows for
    more efficient resource management and allocation based on the importance of different
    API requests.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '`PriorityLevelConfigurations` allow you to enforce policies that ensure critical
    requests always receive enough resources, providing flexibility in managing the
    processing and allocation of resources for API requests.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: ReplicaSets
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ReplicaSets` can be used to create a pod or a set of pods (replicas). Similar
    to the `ReplicationController` resource, a `ReplicaSet` will maintain the set
    number of pods defined in the replica count. If there are too few pods, Kubernetes
    will make up the difference and create the missing pods. If there are too many
    pods for a `ReplicaSet`, Kubernetes will delete pods until the number is equal
    to the replica count set.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: In general, you should avoid creating `ReplicaSets` directly. Instead, you should
    create a `Deployment`, which will create and manage a `ReplicaSet`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Replication controllers
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Replication controllers will manage the number of running pods, keeping the
    desired replicas specified running at all times. If you create a replication controller
    and set the replica count to `5`, the controller will always keep five pods of
    the application running.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Replication controllers have been replaced by the `ReplicaSet` resource, which
    we just discussed in its own section. While you can still use replication controllers,
    you should consider using a `Deployment` or a `ReplicaSet`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: ResourceQuotas
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is becoming very common to share a Kubernetes cluster between multiple teams,
    referred to as a **multi-tenant cluster**. Since you will have multiple teams
    working in a single cluster, you should create quotas to limit the potential of
    a single tenant consuming all the resources in a cluster or on a node.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Limits can be set on most cluster resources, including the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Central processing unit (CPU)
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PVCs
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConfigMaps`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployments
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pods, and more
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a limit will stop any additional resources from being created once the
    limit is hit. If you set a limit of 10 pods for a namespace and a user creates
    a new `Deployment` that attempts to start 11 Pods, the eleventh pod will fail
    to start up and the user will receive an error.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic manifest file to create a quota for memory and CPU would look like
    this:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will set a limit on the total amount of resources the namespace can use
    for CPU and memory requests and limits.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Many of the options you can set in a quota are self-explanatory, like pods,
    PVCs, services, etc. When you set a limit, it means that the set limit is the
    maximum allowed for that resource in the namespace. For example, if you set a
    limit on a pod to 5, when an attempt is made to create a sixth pod in that namespace,
    it will be denied.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'Some quotas have more than one option that can be set: specifically, CPU and
    memory. In our example, both resources have set a request and a limit. Both values
    are very important to understand to ensure efficient use of your resources and
    to limit the potential availability of the application.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: A request is essentially a reservation of that specific resource. When a pod
    is deployed, you should always set a request on your CPU and memory, and the value
    should be the minimum required to start your application. This value will be used
    by the scheduler to find a node that meets the request that has been set. If there
    are no nodes with the requested resource available, the pod will fail to be scheduled.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Now, since a request will reserve the resource, that means once all nodes in
    the cluster have 100% of requests assigned, any additional pod creations will
    be denied since the requests are at 100%. Even if your actual cluster CPU or memory
    utilization is at 10%, pods will fail to be scheduled since the request, or **reservation**,
    is at 100%. If requests are not carefully thought out, it will lead to wasted
    resources, and that will lead to an increased cost to run the platform.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Limits on CPU and memory set the maximum value that the pod will be able to
    utilize. This is different from a request since limits are not a reservation of
    the resource. However, limits still need to be carefully planned out from an application
    side. If you set the CPU limit too low, the application may experience performance
    issues, and if you set the memory limit too low, the pod will be terminated, impacting
    availability while it is restarted.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Once a quota has been created, you can view the usage using the `kubectl describe`
    command. In our example, we named the `ResourceQuota` as `base-memory-cpu`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the usage, we will execute the `kubectl get resourcequotas base-memory-cpu`
    command, resulting in the following output:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`ResourceQuotas` serve as a means to manage and control the allocation of resources
    within a cluster. They allow you to assign specific CPU and memory resources to
    individual namespaces, ensuring that each tenant has sufficient resources to run
    their applications effectively. Additionally, `ResourceQuotas` act as a safeguard,
    preventing a poorly optimized or resource-intensive application from adversely
    affecting the performance of other applications in the cluster.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: RoleBindings
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `RoleBinding` resource is how you associate a `Role` or `ClusterRole` with
    a subject and namespace. For instance, the following `RoleBinding` will allow
    the `aws-codebuild` user to apply the `patch-openunison ClusterRole` to the `openunison`
    namespace:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Even though this references a `ClusterRole`, it will only apply to the `openunison`
    namespace. If the `aws-codebuild` user tries to patch a Deployment in another
    namespace, the API server will stop it.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with a `ClusterRole`, Roles combine API groups and actions to define a set
    of permissions that can be assigned to a subject. The difference between a `ClusterRole`
    and a `Role` is that a `Role` can only have resources defined at the namespace
    level and they apply only within a specific namespace.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: RuntimeClasses
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`RuntimeClasses` are used to set up and customize different runtime environments
    for running containers. They provide the flexibility to choose and configure the
    container runtime that best suits your workloads. By using `RuntimeClasses`, you
    can fine-tune the container runtime according to your specific requirements.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Each `RuntimeClass` is linked to a specific container runtime, like Docker or
    Containerd. They include configurable parameters that define how the chosen container
    runtime behaves. These parameters include resource limits, security configurations,
    and environment variables.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Secrets
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier, we described how to use a `ConfigMap` resource to store configuration
    information. We mentioned that `ConfigMap` should never be used to store any type
    of sensitive data. This is the job of a `Secret`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '`Secrets` are stored as Base64-encoded strings, which aren’t a form of encryption.
    So, why separate `Secrets` from `ConfigMap`? Providing a separate resource type
    offers an easier way to maintain access controls and the ability to inject sensitive
    information using an external secret management system.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '`Secrets` can be created using a file, directory, or from a literal string.
    As an example, we have a MySQL image we want to execute, and we would like to
    pass the password to the pod using a Secret. On our workstation, we have a file
    called `dbpwd` in our current working directory that has our password in it. Using
    the `kubectl` command, we can create a `Secret` by executing `kubectl create secret
    generic mysql-admin --from-file=./dbpwd`.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'This would create a new `Secret` called `mysql-admin` in the current namespace,
    with the content of the `dbpwd` file. Using `kubectl`, we can get the output of
    the `Secret` by running the `kubectl get secret mysql-admin -o yaml` command,
    which would output the following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Looking at the preceding output, you can see that the `data` section contains
    the name of our file and then a Base64-encoded value, which was created from the
    content of the file.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'If we copy the Base64 value from the `Secret` and pipe it out to the `base64`
    utility, we can easily decode the password, as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When using the `echo` command to Base64-encode strings, add the `-n` flag to
    avoid adding an additional `\n`. Instead of `echo 'test' | base64`, use `echo
    -n 'test' | base64`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Everything is stored in `etcd` but we are concerned that someone may be able
    to hack into the `etcd` node and steal a copy of the etcd database. Once someone
    has a copy of the database, they could easily use the `etcdctl` utility to look
    through the content to retrieve all of our Base64-encoded Secrets. Luckily, Kubernetes
    added a feature to encrypt `Secrets` when they are written to a database.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Enabling this feature can be fairly complex for many users, and while it sounds
    like a good idea, it does present some potential issues that you should consider
    before implementing it. If you would like to read the steps on encrypting your
    Secrets at rest, you can view these on the Kubernetes site at [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Another option to secure Secrets is to use a third-party secrets management
    tool such as HashiCorp’s Vault or CyberArk’s Conjur. We’ll cover integration with
    secret management tools in *Chapter 9*, *Managing Secrets in Kubernetes*.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: SelfSubjectAccessReviews
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`SelfSubjectAccessReviews` objects enable users or entities to check their
    own permissions for performing specific actions on resources in their namespace.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: To use `SelfSubjectAccessReviews`, users provide their username along with the
    desired action and resource to check. The cluster evaluates the permissions of
    the provided user against the access control policies in the namespace, and the
    API server responds with whether the requested action is allowed or denied.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '`SelfSubjectAccessReviews` and the next resource, `SelfSubjectRulesReviews`,
    may look very similar, but they serve different functions. The main point to keep
    in mind for `SelfSubjectAccessReviews` is that they assess individual access permissions
    for specific actions on resources.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: SelfSubjectRulesReviews
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`SelfSubjectRulesReviews` objects are used to determine the set of rules that
    a user or entity has permissions for within a namespace, providing the ability
    to investigate the access control rules for their own actions and resources.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: To use a `SelfSubjectRulesReview`, you provide your identity, and the API server
    assesses the permissions associated with the identity in a namespace.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '`SelfSubjectRulesReviews` offer a more comprehensive view over `SelfSubjectAccessReviews`,
    providing a deeper understanding of the entire set of rules that govern a user’s
    permissions within a namespace.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Service accounts
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes uses `ServiceAccounts` to enable access controls for workloads. When
    you create a `Deployment`, you may need to access other services or Kubernetes
    resources.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Since Kubernetes is a secure system, each resource or service your application
    tries to access will evaluate **role-based access control** (**RBAC**) rules to
    accept or deny the request.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a service account using a manifest is a straightforward process, requiring
    only a few lines in the manifest. The following code snippet shows a service account
    manifest to create a service account for a Grafana Deployment:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You combine the service account with role bindings and `Roles` to allow access
    to the required services or objects.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover how to use `ServiceAccounts` in depth in *Chapter 6*, *Integrating
    Enterprise Authentication into Your Cluster*.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Services
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you create a pod, it will receive an IP address from the CIDR range that
    was assigned when the cluster was created. In most clusters, the assigned IPs
    are only addressable within the cluster itself, referred to as “**island mode**.”
    Since pods are ephemeral, the assigned IP address will likely change during an
    application’s life cycle, which becomes problematic when any service or application
    needs to connect to the pod. To address this, we can create a Kubernetes service,
    which will also receive an IP address, but since services aren’t deleted during
    an application’s life cycle, the address will remain the same.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: A service will dynamically maintain a list of pods to target based on labels
    that match the service selector, creating a list of endpoints for the service.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: A service stores information about how to expose the application, including
    which pods are running the application and the network ports to reach them.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'Each service has a network type that is assigned when they are created, and
    they include the following:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '`ClusterIP`: A network type that is only accessible inside the cluster itself.
    This type can still be used for external requests using an Ingress controller,
    which will be discussed in a later chapter. The ClusterIP type is the default
    type that will be used if no type is specified when you create a service.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NodePort`: A network type that exposes the service to a random port between
    ports `30000` and `32767`. This port becomes accessible by targeting any worker
    node in a cluster on the assigned `NodePort`. Once created, each node in the cluster
    will receive the port information, and incoming requests will be routed via `kube-proxy`.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadBalancer`: This type requires an add-on to use inside a cluster. If you
    are running Kubernetes on a public cloud provider, this type will create an external
    load balancer that will assign an IP address to your service. Most on-premises
    Kubernetes installations do not include support for the `LoadBalancer` type, but
    some offerings such as Google’s Anthos do offer support for it. In a later chapter,
    we will explain how to add an open-source project called `MetalLB` to a Kubernetes
    cluster to provide support for the `LoadBalancer` type.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExternalName`: This type is different from the other three. Unlike the other
    three options, this type will not assign an IP address to the service. Instead,
    this is used to map the internal Kubernetes **Domain Name System** (**DNS**) name
    to an external service.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, we have deployed a pod running Nginx on port `80`. We want to
    create a service that will allow this pod to receive incoming requests on port
    `80` from within the cluster. The code for this can be seen in the following snippet:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In our manifest, we create a label with a value of `app` and assign a value
    of `nginx-web-frontend`. We have called the service itself `nginx-web` and we
    exposed the service on port `80`, targeting the pod port of `80`. The last two
    lines of the manifest are used to assign the pods that the service will forward
    to, also known as Endpoints. In this manifest, any pod that has the label of `app`
    with a value of `nginx-web` in the namespace will be added as an endpoint to the
    service. Finally, you may have noticed that we didn’t specify a service type in
    our manifest. Since we didn’t specify the type, it will be created as the default
    service type of `ClusterIP`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: StatefulSets
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`StatefulSets` offer some unique features when creating pods. They provide
    features that none of the other pod creation methods offer, including the following:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Known pod names
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordered Deployment and scaling
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordered updates
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent storage creation
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best way to understand the advantages of a `StatefulSet` is to review an
    example manifest from the Kubernetes site, shown in the following screenshot:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – StatefulSet manifest example ](img/B21165_03_04.png)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: StatefulSet manifest example'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can look at the resources that the `StatefulSet` created.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'The manifest specifies that there should be three replicas of a pod named `nginx`.
    When we get a list of pods, you will see that three pods were created using the
    `nginx` name, with an additional dash and an incrementing number. This is what
    we meant in the overview when we mentioned that Pods will be created with known
    names, as illustrated in the following code snippet:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The pods are also created in order—`web-0` must be fully deployed before `web-1`
    is created, and then, finally, `web-2`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for this example, we also added a PVC to each pod using the `VolumeClaimTemplate`
    in the manifest. If you look at the output of the `kubectl get pvc` command, you
    will see that three PVCs were created with the names we expected (note that we
    removed the `VOLUME` column due to space), as illustrated in the following code
    snippet:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the `VolumeClaimTemplate` section of the manifest, you will see that we assigned
    the name `www` to the PVC claim. When you assign a volume in a `StatefulSet`,
    the PVC name will combine the name used in the claim template, combined with the
    name of the pod. Using this naming, you can see why Kubernetes assigned the PVC
    names `www-web-0`, `www-web-1`, and `www-web-2`.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Storage classes
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Storage classes are used to define a storage endpoint. Each storage class can
    be assigned labels and policies, allowing a developer to select the best storage
    location for their persistent data. You may create a storage class for a backend
    system that has all **Non-Volatile Memory Express** (**NVMe**) drives, assigning
    it the name `fast`, while assigning a different class to a NetApp **Network File
    System** (**NFS**) volume running standard drives, using the name `standard`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: When a PVC is requested, the user can assign a `StorageClass` that they wish
    to use. When the API server receives the request, it finds the matching name and
    uses the `StorageClass` configuration to create the volume on the storage system
    using a provisioner.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'At a very high level, a `StorageClass` manifest does not require a lot of information.
    Here is an example of a storage class using a provisioner from the Kubernetes
    incubator project to provide NFS auto-provisioned volumes, named `nfs`:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Storage classes allow you to offer multiple storage solutions to your users.
    You may create a class for cheaper, slower storage while offering a second class
    that supports high throughput for high data requirements. By providing a different
    class to each offering, you allow developers to select the best choice for their
    application.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: SubjectAccessReviews
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`SubjectAccessReviews` are used to check if an entity has permission to perform
    a specific action on a resource. They allow users to request access reviews and
    get information about their privileges. By providing an identity, desired action,
    and resource, the API server determines if the action is allowed or denied. This
    helps users verify their permissions to a resource, which can help to identify
    access issues to a Kubernetes resource.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: For example, Scott wants to verify his ability to create pods in a namespace
    called `sales`. To do this, Scott creates a `SubjectAccessReview` in the `sales`
    namespace, including his username, the create action, and the target resource,
    pods.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: The API server verifies whether he has permission to create pods in the `sales`
    namespace and sends a response back. The response from the API server includes
    whether the requested action is permitted or denied.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Knowing if an entity has permission to execute an action on a resource helps
    to minimize frustrations when a deployment fails due to permissions.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: TokenReviews
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TokenReviews` are API objects used to authenticate and verify the legitimacy
    of an authentication token linked to a user or entity in the cluster. If the token
    is valid, the API server retrieves the details about the associated user or entity.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: When users submit an authentication token to the Kubernetes API server, it validates
    the token against the internal authentication system. It verifies that the token
    is legitimate and determines the user or entity associated with it.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: The API server provides information about the token’s validity and the user
    or entity, including the username, **user identifier** (**UID**), and group membership.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: ValidatingWebhookConfigurations
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ValidatingWebhookConfiguration` is a collection of rules that determine what
    admission requests are intercepted and handled by a webhook. Each rule contains
    the specific resources and operations that the webhook should handle.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: It provides a way to enforce specific policies or rules by applying validation
    logic to admission requests. Many add-ons to Kubernetes provide a `ValidatingWebhookConfiguration`
    – one of the most common is the NGINX ingress controller.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view all of the `ValidatingWebhookConfigurations` in your cluster by
    executing `kubectl get validatingwebhookconfigurations`. For the KinD clusters
    we have deployed, you will have a single entry for NGINX ingress admissions:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: VolumeAttachments
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`VolumeAttachments` create connections between external storage volumes and
    nodes in a cluster. They control the association of persistent volumes with specific
    nodes, enabling the nodes to access and utilize the storage resources.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were provided with a fast-paced Kubernetes bootcamp, where
    you were exposed to a wealth of technical information. Remember that as you get
    deeper into the world of Kubernetes, everything will become more manageable and
    easier to grasp. It’s important to note that many of the resources discussed in
    this chapter will be further explored and explained in subsequent chapters, providing
    you with a deeper understanding.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: You gained insights into each Kubernetes component and their interdependencies,
    which form the cluster. Armed with this knowledge, you now possess the necessary
    skills to investigate and identify the root causes of errors or issues within
    a cluster. We explored the control plane, which encompasses `api-server`, `kube-scheduler`,
    `etcd`, and controller managers. Additionally, you familiarized yourself with
    Kubernetes nodes that run the `kubelet` and `kube-proxy` components, along with
    a container runtime.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: We also delved into the practical use of the `kubectl` utility, which will be
    your primary tool for interacting with a cluster. You learned about several essential
    commands, such as commands for accessing logs and providing descriptive information,
    which you will utilize on a daily basis.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create a development Kubernetes cluster that we
    will use as the base cluster for the remaining chapters. Throughout the remainder
    of the book, we will reference many of the resources that were presented in this
    chapter, helping to explain them by using them in real-world examples.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Kubernetes control plane does not include which of the following components?
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: api-server
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: kube-scheduler
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: etcd
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ingress controller
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: d'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: What is the name of the component that keeps all of the cluster information?
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: api-server
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Master controller
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: kubelet
  id: totrans-472
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: etcd
  id: totrans-473
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: d'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Which component is responsible for selecting the node that will run a workload?
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: kubelet
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: api-server
  id: totrans-477
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: kube-scheduler
  id: totrans-478
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Pod-scheduler
  id: totrans-479
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: c'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Which option would you add to a `kubectl` command to see additional output from
    a command?
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verbose
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: -v
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: –verbose
  id: totrans-484
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: -log
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: b'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Which service type creates a randomly generated port, allowing incoming traffic
    to any worker node on the assigned port to access the service?
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: LoadBalancer
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ClusterIP
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None—it’s the default for all services
  id: totrans-490
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: NodePort
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: d'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: If you need to deploy an application on a Kubernetes cluster that requires known
    pod names and a controlled startup of each pod, which object would you create?
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: StatefulSet
  id: totrans-494
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Deployment
  id: totrans-495
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ReplicaSet
  id: totrans-496
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ReplicationController
  id: totrans-497
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: a'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Join our book’s Discord space
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join the book’s Discord workspace for a monthly *Ask Me Anything* session with
    the authors:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/K8EntGuide](https://packt.link/K8EntGuide)'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code965214276169525265.png)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
