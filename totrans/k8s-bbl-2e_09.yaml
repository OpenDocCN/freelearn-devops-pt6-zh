- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Persistent Storage in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned about Kubernetes’ key concepts, and this
    chapter is going to be the last one about that. So far, we’ve discovered that
    Kubernetes is about representing a desired state for all the traditional IT layers
    by creating an object in its `etcd` datastore that will be converted into actual
    computing resources within your clusters.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on persistent storage for stateful applications. As
    with any other resource abstraction, this will be another set of objects that
    we will master to get persistent storage on your clusters. Persistent storage
    is achieved in Kubernetes by using the `PersistentVolume` resource type, which
    has its own mechanics. Honestly, these can be relatively difficult to approach
    at first, but we are going to discover all of them and cover them in depth!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why use persistent storage?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to mount `PersistentVolume` to your Pod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the life cycle of the `PersistentVolume` object in Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding static and dynamic `PersistentVolume` provisioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced storage topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A working Kubernetes cluster (either local or cloud-based)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working `kubectl` CLI configured to communicate with the cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do not meet these technical requirements, you can follow *Chapter 2*,
    *Kubernetes Architecture – from Container Images to Running Pods*, and *Chapter
    3*, *Installing Your Kubernetes Cluster*, to get these two prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the latest code samples for this chapter from the official
    GitHub repository at [https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: Why use persistent storage?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Storage is an important resource within the IT world, as it provides a logical
    way to **create**, **read**, **update**, and **delete** (**CRUD**) information
    ranging from employee payslips in a PDF file format to petabytes of healthcare
    records. While storage is a key element in providing relevant information to the
    users, containers and microservices should be stateless. In other words, no information
    saved within a running container will be available when rescheduled or moved to
    a different cluster. The same goes for microservices; the data component should
    be decoupled, allowing the microservice to stay micro and not care about the data
    state and availability when being rescheduled.
  prefs: []
  type: TYPE_NORMAL
- en: So, where do we save the application data? In any sort of datastore, and from
    a business continuity perspective, if the related datastore runs on the same Kubernetes
    cluster as the microservices, it should have an application-aware replication
    mechanism. But remember, Kubernetes is a resource orchestrator that will act on
    the desired state you have defined for your application. When you’re configuring
    your Pods, you have the opportunity to define the storage component to be used,
    providing your containers with a way to create, read, update, and delete data.
    Let’s explore the different options Kubernetes has to offer to persist data.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Volumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first layer of storage abstraction is to access Kubernetes objects and
    mount them within a container like a data volume. This can be done for:'
  prefs: []
  type: TYPE_NORMAL
- en: A ConfigMap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Secret
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ServiceAccount token (identical to a Secret)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows an application team to decouple the configuration of a microservice
    from the container or the deployment definition. If we consider the lifetime of
    an application, the credentials, certificates, or tokens to external services
    might need to be refreshed or a configuration parameter might need to be updated.
    We don’t want these to be hardcoded in the deployment manifests or the container
    images for obvious security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at a configMap example with the manifest `nginx-configmap.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This `ConfigMap` has two definitions for two different files, which we will
    mount within the NGINX Pod with the manifest `nginx-pod.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s apply these two manifests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s verify the status of the two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the files are available within the folder `/usr/share/nginx/hello` that
    we provided as a mount path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s verify that the data is being served by NGINX via a `port-forward` to
    avoid setting up a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In a second terminal, you can then `curl` the two URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While this is a great start, one limitation of these objects is the amount of
    data you can store. Since it depends on the `etcd` datastore, to avoid performance
    issues, the limitation is 1.5 MB (refer to [https://etcd.io/docs/v3.5/dev-guide/limit](https://etcd.io/docs/v3.5/dev-guide/limit)).
    So, the next set of objects will allow your application to store much more data,
    in fact, as much data as the system hosting those volume objects can.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a Kubernetes cluster with two worker nodes on which Pods can
    be scheduled, and explore the following five types of volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: An `emptyDir`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `hostPath`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A local volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Fiber Channel** (**FC**) block disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Network File System** (**NFS**) volume export
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first three types, `emptyDir`, `hostPath`, and local volumes, have two
    major limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: They are limited to the disk space available on the worker node they are provisioned
    on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are bound to the node on which the Pod will be deployed. If your Pod is
    provisioned on worker node 1, the data will only be stored on worker node 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These volume types could potentially lead to a degradation of service or worse,
    like a split-brain scenario. If worker node 1 becomes unhealthy, triggering a
    rescheduling of the Pod to worker node 2, the application will start without its
    data and could lead to a major outage.
  prefs: []
  type: TYPE_NORMAL
- en: Note that some applications have a native replication engine. A typical deployment
    for such an application would have two replicas running and creating a `hostPath`
    volume on each node. In this scenario, if one worker node becomes unhealthy, then
    the application becomes degraded but only from a high availability and performance
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being external to any of the compute resources of your Kubernetes cluster,
    the last two types, FC block disk and an NFS volume, address the above weaknesses
    but introduce a bit more complexity. While the first three types of volumes do
    not require you to interact with your storage administrators, the last two do.
    Without getting into too many details, your storage administrators will have:'
  prefs: []
  type: TYPE_NORMAL
- en: To provision a **Logical Unit Number** (**LUN** – the FC block disk) on their
    **Storage Area Network** (**SAN**) connected via an FC fabric to your Kubernetes
    worker nodes and allow access via a zoning configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To provision a data space on **Network Attached Storage** (**NAS**) connected
    to the corporate network and reachable by your Kubernetes worker nodes and allow
    access via an export policy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that testing these two types of volumes requires specialized equipment
    with a nontrivial setup, although NAS is more and more popular within home labs.
    However, from a Kubernetes standpoint, these volumes can be configured as easily
    as with the configMap example. Here are the modified versions of the NGINX Pod
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For an FC volume (`nginx-pod-fiberchannel.yaml`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `fc` part is where your SAN and LUN must be configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an NFS volume (`nginx-pod-nfs-volume.yaml`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `nfs` part is where your NAS and exported volume must be configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: These two types of volumes, FC block disk and NFS, will be attached to the nodes
    as required by the Pod presence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these two types of volumes can solve a series of challenges, they represent
    an anti-pattern to the decoupling of configurations and resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the configMap is mounted as a volume with the two HTML files on the container,
    the other types of volumes will require a different approach to have the data
    injected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are other volume types available: [https://kubernetes.io/docs/concepts/storage/volumes/](https://kubernetes.io/docs/concepts/storage/volumes/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of volume within Kubernetes is an amazing starting point for deploying
    stateful applications. However, with the limitation of some, the complexity of
    others, and the storage knowledge it requires, it seems to be rather difficult
    to scale hundreds or thousands of microservices with such object definition. Thanks
    to an additional layer of abstraction, Kubernetes provides an agnostic approach
    to consume storage at scale with the usage of the `PersistentVolume` object, which
    we’ll cover in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing PersistentVolumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like the `Pod` or `ConfigMap`, `PersistentVolume` is a resource type that
    is exposed through `kube-apiserver`; you can create, update, and delete **persistent
    volumes** (**PVs**) using YAML and `kubectl` just like any other Kubernetes objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will demonstrate how to list the `PersistentVolume` resource
    type currently provisioned within your Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `persistentvolume` object is also accessible with the plural form of `persistentvolumes`
    along with the alias of `pv`. The following three commands are essentially the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You’ll find that the `pv` alias is very commonly used in the Kubernetes world,
    and a lot of people refer to PVs as simply `pv`, so be aware of that. As of now,
    no `PersistentVolume` object has been created within our Kubernetes cluster, and
    that is why we don’t see any resource listed in the output of the preceding command.
  prefs: []
  type: TYPE_NORMAL
- en: '`PersistentVolume` is the object and, essentially, represents a piece of storage
    that you can attach to your Pod. That piece of storage is referred to as a *persistent*
    one because it is not supposed to be tied to the lifetime of a Pod.'
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, as mentioned in *Chapter 5*, *Using Multi-Container Pods and Design
    Patterns*, Kubernetes Pods use the notion of volumes. Additionally, we discovered
    the `emptyDir` volumes, which initiate an empty directory that your Pods can share.
    It also defines a path within the worker node filesystem that will be exposed
    to your Pods. Both volumes were supposed to be attached to the life cycle of the
    Pod. This means that once the Pod is destroyed, the data stored within the volumes
    will be destroyed as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, sometimes, you don’t want the volume to be destroyed. You just want
    it to have its life cycle to keep both the volume and its data alive even if the
    Pod fails. That’s where `PersistentVolumes` come into play: essentially, they
    are volumes that are not tied to the life cycle of a Pod. Since they are a resource
    type just like the Pods themselves, they can live on their own! In essence, PVs
    ensure that your storage remains available beyond the Pod’s existence, which is
    crucial for maintaining data integrity in stateful applications. Now, let’s break
    down `PersistentVolume`s objects: they consist of two key elements – a backend
    technology (the `PersistentVolume` type) and an access mode (like **ReadWriteOnce**
    (**RWO**)). Understanding these concepts is essential for effectively utilizing
    PVs within your Kubernetes environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that `PersistentVolumes` objects are just entries within the `etcd`
    datastore, and they are not actual disks on their own.
  prefs: []
  type: TYPE_NORMAL
- en: '`PersistentVolume` is just a kind of pointer within Kubernetes to a piece of
    storage, such as an NFS, a disk, an Amazon **Elastic Block Store** (**EBS**) volume,
    and more. This is so that you can access these technologies from within Kubernetes
    and in a Kubernetes way.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll begin by explaining what `PersistentVolume` types
    are.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing PersistentVolume types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you already know, the simplest Kubernetes setup consists of a simple `minikube`
    installation, whereas the most complex Kubernetes setup can be made of dozens
    of servers on a massively scalable infrastructure. All of these different setups
    will forcibly have different ways in which to manage persistent storage. For example,
    the three well-known public cloud providers have a lot of different solutions.
    Let’s name a few, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon EBS volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon **Elastic File System** (**EFS**) filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google GCE **Persistent Disk** (**PD**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Azure disks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These solutions have their own design and set of principles, along with their
    own logic and mechanics. Kubernetes was built with the principle that all of these
    setups should be abstracted using just one object to abstract all of the different
    technologies; that single object is the `PersistentVolume` resource type. The
    `PersistentVolume` resource type is the object that is going to be attached to
    a running Pod. Indeed, a Pod is a Kubernetes resource and does not know what an
    EBS or a PD is; Kubernetes Pods only play well with `PersistentVolumes`, which
    is also a Kubernetes resource.
  prefs: []
  type: TYPE_NORMAL
- en: Whether your Kubernetes cluster is running on Google GKE or Amazon EKS, or whether
    it is a single minikube cluster on your local machine has no importance. When
    you wish to manage persistent storage, you are going to create, use, and deploy
    `PersistentVolumes` objects, and then bind them to your Pods!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the backend technologies supported by Kubernetes out of the
    box:'
  prefs: []
  type: TYPE_NORMAL
- en: '`csi`: **Container Storage Interface** (**CSI**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fc`: FC storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iscsi`: SCSI over IP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local`: Using local storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hostPath`: HostPath volumes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nfs`: Regular network file storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding list is not exhaustive: Kubernetes is extremely versatile and
    can be used with many storage solutions that can be abstracted as `PersistentVolume`
    objects in your cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that in recent versions of Kubernetes, several `PersistentVolume`
    types have been deprecated or removed, indicating a shift in how storage is managed
    within Kubernetes environments. This change is part of the ongoing evolution of
    Kubernetes to streamline its APIs and improve compatibility with modern storage
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following `PersistentVolume` types are either removed or deprecated
    in Kubernetes 1.29 onwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '`awsElasticBlockStore` – Amazon EBS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azureDisk` – Azure Disk'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azureFile` – Azure File'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`portworxVolume` – Portworx volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flexVolume` – FlexVolume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vsphereVolume` – vSphere VMDK volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cephfs` – CephFS volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cinder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These changes reflect a broader trend toward standardized storage interfaces
    and an emphasis on more portable, cloud-agnostic solutions. For detailed guidance
    and updated information on PVs and supported types, you can refer to the official
    Kubernetes documentation at https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits brought by PersistentVolume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PVs are an essential component in Kubernetes when managing stateful applications.
    Unlike ephemeral storage, PVs ensure data persists beyond the life cycle of individual
    Pods, making them ideal for applications requiring data retention and consistency.
    These storage resources bring flexibility and reliability to the Kubernetes ecosystem,
    enhancing both performance and resilience.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three major benefits of `PersistentVolume`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A PV in Kubernetes continues to exist independently of the Pod that uses it.
    This means that if you delete or recreate a Pod attached to a `PersistentVolume`,
    the data stored on that volume remains intact. The data’s persistence depends
    on the reclaim policy of the `PersistentVolume`: with a retain policy, the data
    stays available for future use, while a delete policy removes both the volume
    and its data when the Pod is deleted. Thus, you can manage your Pods without worrying
    about losing data stored on `PersistentVolumes`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a Pod crashes, the `PersistentVolume` object will survive the fault and
    not be removed from the cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PersistentVolume` is cluster-wide; this means that it can be attached to any
    Pod running on any node. (You will learn about restrictions and methods later
    in this chapter.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bear in mind that these three statements are not always 100% valid. Indeed,
    sometimes, a `PersistentVolume` object can be affected by its underlying technology.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, let’s consider a `PersistentVolume` object that is, for
    example, a pointer to a `hostPath` storage on the compute node. In such a setup,
    `PersistentVolume` won’t be available to any other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you take another example, such as an NFS setup, it wouldn’t be the
    same. Indeed, you can access an NFS from multiple machines at once. Therefore,
    a `PersistentVolume` object that is backed by an NFS would be accessible from
    several different Pods running on different nodes without much problem. To understand
    how to make a `PersistentVolume` object on several different nodes at a time,
    we need to consider the concept of access modes, which we’ll be diving into in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing PersistentVolume access modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, access modes are an option you can set when you create
    a `PersistentVolume` type that will tell Kubernetes how the volume should be mounted.
  prefs: []
  type: TYPE_NORMAL
- en: '`PersistentVolumes` supports four access modes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ReadWriteOnce** (**RWO**): This volume allows read/write by only one node
    at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ReadOnlyMany** (**ROX**): This volume allows read-only mode by many nodes
    at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ReadWriteMany** (**RWX**): This volume allows read/write by multiple nodes
    at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ReadWriteOncePod**: This is a new mode introduced recently and is already
    stable in the Kubernetes 1.29 version. In this access mode, the volume is mountable
    as read-write by a single Pod. Employ the `ReadWriteOncePod` access mode when
    you want only one Pod throughout the entire cluster to have the capability to
    read from or write to the **Persistent Volume Claim** (**PVC**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is necessary to set at least one access mode to a `PersistentVolume` type,
    even if said volume supports multiple access modes. Indeed, not all `PersistentVolume`
    types will support all access modes, as shown in the below table.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 9.1: Access modes supported by different PersistentVolume types (Image
    source: kubernetes.io/docs/concepts/storage/persistent-volumes)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kubernetes, the access modes of a `PersistentVolume` type are closely tied
    to the underlying storage technology and how it handles data. Here’s why different
    PV types support specific modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File vs. block storage:**'
  prefs: []
  type: TYPE_NORMAL
- en: File storage (like **Network File System** (**NFS**) or **Common Internet File
    System** (**CIFS**)) allows multiple clients to access the same files concurrently.
    This is why file storage systems can support a variety of access modes, such as
    RWO, ROX, and RWX. They are built to handle multi-client access over a network,
    enabling several nodes to read and write from the same volume without data corruption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block storage (like local storage or hostPath) is fundamentally different. Block
    storage is designed for one client to access at a time because it deals with raw
    disk sectors rather than files. Concurrent access by multiple clients would lead
    to data inconsistency or corruption. For this reason, block storage supports only
    the RWO mode, where a single node can both read and write to the volume.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal vs. external storage:**'
  prefs: []
  type: TYPE_NORMAL
- en: hostPath volumes, which refer to storage on the same node as the workload, are
    inherently restricted to that node. Since this storage is tied to the physical
    node, it cannot be accessed by other nodes in the cluster. This makes it only
    compatible with the RWO mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NFS or other external storage solutions, on the other hand, are designed to
    allow access over a network, enabling multiple nodes to share the same storage.
    This flexibility allows them to support additional modes like RWX.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding this distinction helps to clarify why some `PersistentVolume`
    types support more flexible access modes, while others are constrained.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s create our first `PersistentVolume` object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first PersistentVolume object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create a `PersistentVolume` on the Kubernetes cluster using the declarative
    approach. Since `PersistentVolume`s are more complex resources, it’s highly recommended
    to avoid using the imperative method. The declarative approach allows you to define
    and manage resources consistently in YAML files, making it easier to track changes,
    version control your configurations, and ensure repeatability across different
    environments. This approach also makes it simpler to manage large or complex resources
    like `PersistentVolume`s, where precise configurations and careful planning are
    essential.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the example YAML definition below for creating a `PersistentVolume` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is the simplest form of `PersistentVolume`. Essentially, this `YAML` file
    creates a `PersistentVolume` entry within the Kubernetes cluster. So, this `PersistentVolume`
    will be a `hostPath` type.
  prefs: []
  type: TYPE_NORMAL
- en: The `hostPath` type `PersistentVolume` is not recommended for production or
    critical workloads. We are using it here for demonstration purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s apply the PV configuration to the cluster as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It could be a more complex volume, such as a cloud-based disk or an NFS, but
    in its simplest form, a `PersistentVolume` can simply be a `hostPath` type on
    the node running your Pod.
  prefs: []
  type: TYPE_NORMAL
- en: How does Kubernetes PersistentVolumes handle storage?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned earlier, the `PersistentVolume` resource type is a pointer to
    a storage location and that can be, for example, a disk, an NFS drive, or a disk
    volume controlled by a storage operator. All of these different technologies are
    managed differently. However, fortunately for us, in Kubernetes, they are all
    represented by the `PersistentVolume` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply put, the `YAML` file to create a `PersistentVolume` will be a little
    bit different depending on the backend technology that the `PersistentVolume`
    is backed by. For example, if you want your `PersistentVolume` to be a pointer
    to an NFS share, you have to meet the following two conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The NFS share is already configured and reachable from the Kubernetes nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `YAML` file for your `PersistentVolume` must include the NFS server details
    and NFS share information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following YAML definition is a sample for creating a `PersistentVolume`
    using NFS as the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For a `PersistentVolume` to work properly, it needs to be able to link Kubernetes
    and the actual storage. So, you need to create a piece of storage or provision
    it outside of Kubernetes and then create the `PersistentVolume` entry by including
    the unique ID of the disk, or the volume, that is backed by a storage technology
    that is external to Kubernetes. Next, let’s take a closer look at some examples
    of `PersistentVolume` YAML files in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating PersistentVolume with raw block volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example displays a `PersistentVolume` object that is pointing to raw block
    volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in this `YAML` file, the fc section contains the FC volume details
    that this `PersistentVolume` object is pointing to. The exact raw volume is identified
    by the `targetWWNs` key. That’s pretty much it. With this YAML file, Kubernetes
    is capable of finding the proper **World Wide Name** (**WWN**) and maintaining
    a pointer to it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss a little bit about the provisioning of storage resources.
  prefs: []
  type: TYPE_NORMAL
- en: Can Kubernetes handle the provisioning or creation of the resource itself?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fact that you need to create the actual storage resource separately and
    then create a `PersistentVolume` in Kubernetes might be tedious.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately for us, Kubernetes is also capable of communicating with the **APIs**
    of your cloud provider or other storage backends in order to create volumes or
    disks on the fly. There is something called **dynamic provisioning** that you
    can use when it comes to managing `PersistentVolume`. It makes things a lot simpler
    when dealing with `PersistentVolume` provisioning, but it only works on supported
    storage backends or cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is an advanced topic, so we will discuss it in more detail later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to provision `PersistentVolume` objects inside our cluster,
    we can try to mount them. Indeed, in Kubernetes, once you create a `PersistentVolume`,
    you need to mount it to a Pod so that it can be used. Things will get slightly
    more advanced and conceptual here; Kubernetes uses an intermediate object in order
    to mount a `PersistentVolume` to Pods. This intermediate object is called `PersistentVolumeClaim`.
    Let’s focus on it in the upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to mount a PersistentVolume to your Pod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now try to mount a `PersistentVolume` object to a Pod. To do that, we
    will need to use another object, which is the second object we need to explore
    in this chapter, called `PersistentVolumeClaim`.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing PersistentVolumeClaim
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like `PersistentVolume` or `ConfigMap`, `PersistentVolumeClaim` is another
    independent resource type living within your Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: First, bear in mind that even if both names are almost the same, `PersistentVolume`
    and `PersistentVolumeClaim` are two distinct resources that represent two different
    things.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can list the `PersistentVolumeClaim` resource type created within your
    cluster using `kubectl`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output tells us that we don’t have any `PersistentVolumeClaim`
    resources created within my cluster. Please note that the `pvc` alias works, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You’ll quickly find that a lot of people working with Kubernetes refer to the
    `PersistentVolumeClaim` resources simply with `pvc`. So, don’t be surprised if
    you see the term `pvc` here and there while working with Kubernetes. That being
    said, let’s explain what `PersistentVolumeClaim` resources are in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting storage creation and storage consumption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key to understanding the difference between `PersistentVolume` and `PersistentVolumeClaim`
    is to understand that one is meant to represent the storage itself, whereas the
    other one represents the request for storage that a Pod makes to get the actual
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is that Kubernetes is typically supposed to be used by two types
    of people:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes administrator**: This person is supposed to maintain the cluster,
    operate it, and also add computation resources and persistent storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes application developer**: This person is supposed to develop and
    deploy an application, so, put simply, consume the computation resource and storage
    offered by the administrator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, there is no problem if you handle both roles in your organization;
    however, this information is crucial to understand the workflow to mount `PersistentVolume`
    to Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes was built with the idea that a `PersistentVolume` object should belong
    to the cluster administrator scope, whereas `PersistentVolumeClaim` objects belong
    to the application developer scope. It is up to the cluster administrator to add
    `PersistentVolumes` (or dynamic volume operators) since they might be hardware
    resources, whereas developers have a better understanding of what amount of storage
    and what kind of storage is needed, and that’s why the `PersistentVolumeClaim`
    object was built.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, a Pod cannot mount a `PersistentVolume` object directly. It needs
    to explicitly ask for it. This *asking* action is achieved by creating a `PersistentVolumeClaim`
    object and attaching it to the Pod that needs a `PersistentVolume` object.
  prefs: []
  type: TYPE_NORMAL
- en: This is the only reason why this additional layer of abstraction exists. Now,
    let’s understand the `PersistentVolume` workflow summarized in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the PersistentVolume workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the developer has built the application, it is their responsibility to
    ask for a `PersistentVolume` object if needed. To do that, the developer will
    write two `YAML` manifests:'
  prefs: []
  type: TYPE_NORMAL
- en: One manifest will be written for the Pod or deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other manifest will be written for `PersistentVolumeClaim`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Pod must be written so that the `PersistentVolumeClaim` object is mounted
    as a `volumeMount` configuration key in the YAML file. Please note that for it
    to work, the `PersistentVolumeClaim` object needs to be in the same namespace
    as the application Pod that is mounting it. When both YAML files are applied and
    both resources are created in the cluster, the `PersistentVolumeClaim` object
    will look for a `PersistentVolume` object that matches the criteria required in
    the claim. Supposing that a `PersistentVolume` object capable of fulfilling the
    claim is created and ready in the Kubernetes cluster, the `PersistentVolume` object
    will be attached to the `PersistentVolumeClaim` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything is okay, the claim is considered fulfilled, and the volume is
    correctly mounted to the Pod: if you understand this workflow, essentially, you
    understand everything related to `PersistentVolume` usage.'
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram illustrates the workflow in static storage provisioning
    in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_09_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Static storage provisioning in Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: You will learn about dynamic storage provisioning in a later section of this
    chapter, *Introducing dynamic provisioning*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a developer needs persistent storage for their application running
    in Kubernetes. Here’s the choreography that ensues:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The administrator prepares `PersistentVolume`: The Kubernetes administrator
    prepares the backend storage and creates a `PersistentVolume` object. This PV
    acts like a storage declaration, specifying details like capacity, access mode
    (read-write, read-only), and the underlying storage system (e.g., hostPath, NFS).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The developer makes a claim using `PersistentVolumeClaim`: The developer creates
    a `PersistentVolumeClaim` object. This PVC acts like a storage request, outlining
    the developer’s needs. It specifies the size, access mode, and any storage class
    preferences (think of it as a wishlist for storage). The developer also defines
    a volume mount in the Pod’s YAML file, specifying how the Pod should access the
    persistent storage volume.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Kubernetes fulfills the request: After the Pod and PVC are created, Kubernetes
    searches for a suitable PV that matches the requirements listed in the PVC. It’s
    like a match-making service, ensuring the requested storage aligns with what’s
    available.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Pod leverages the storage using `volumeMount`: Once Kubernetes finds a
    matching PV, it binds it to the PVC. This makes the storage accessible to the
    Pod.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Data flow begins (**read/write operations**): Now, the Pod can interact with
    the persistent storage based on the access mode defined in the PV. It can perform
    read or write operations on the data stored in the volume, ensuring data persistence
    even if the Pod restarts.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please note that `PersistentVolume` is cluster-scoped, while `PersistentVolumeClaim`,
    Pod, and `volumeMount` are namespace-scoped objects.
  prefs: []
  type: TYPE_NORMAL
- en: This collaboration between PVs, PVCs, and Kubernetes ensures that the developers
    have access to persistent storage for their applications, enabling them to store
    and retrieve data across Pod life cycles.
  prefs: []
  type: TYPE_NORMAL
- en: This setup might seem complex to understand at first, but you will quickly get
    used to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will learn how to use the storage in Pods using
    `PersistentVolume` and `PersistentVolumeClaim`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Pod with a PersistentVolumeClaim object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will create a Pod that mounts `PersisentVolume` within a
    `minikube` cluster. This is going to be a kind of `PersisentVolume` object, but
    this time, it will not be bound to the life cycle of the Pod. Indeed, since it
    will be managed as a real `PersisentVolume` object, the `hostPath` type will get
    its life cycle independent of the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'The very first thing to do is create the `PersisentVolume` object that will
    be a `hostPath` type. Here is the YAML file to do that. Please note that we created
    this `PersisentVolume` object with some arbitrary labels in the `metadata` section.
    This is so that it will be easier to fetch it from the `PersistentVolumeClaim`
    object later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note the following items in the YAML, which we will use for matching
    the PVC later:'
  prefs: []
  type: TYPE_NORMAL
- en: '`labels`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`capacity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accessModes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StorageClassName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can now create and list the `PersisentVolume` entries available in our cluster,
    and we should observe that this one exists. Please note that the `pv` alias works,
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `PersisentVolume` was successfully created, and the status
    is `Available`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to create two things to mount the `PersisentVolume` object:'
  prefs: []
  type: TYPE_NORMAL
- en: A `PersistentVolumeClaim` object that targets this specific `PersisentVolume`
    object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Pod to use the `PersistentVolumeClaim` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate the namespace scoped items and cluster scoped items, let us
    create a namespace for the PVC and Pod (refer to the `pv-ns.yaml` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s proceed, in order, with the creation of the `PersistentVolumeClaim` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create the PVC and check that it was successfully created in the cluster.
    Please note that the `pvc` alias also works here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Please note the PVC status now – `Bound` – which means the PVC is already matched
    with a PV and ready to consume the storage.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `PersisentVolume` object and the `PersistentVolumeClaim` object
    exist, we can create a Pod that will mount the PV using the PVC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an NGINX Pod that will do the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in the `volumeMounts` section, the `PersistentVolumeClaim` object
    is referenced as a volume, and we reference the PVC by its name. Note that the
    PVC must live in the same namespace as the Pod that mounts it. This is because
    PVCs are **namespace-scoped** resources, whereas PVs are not. There are no labels
    and selectors for this one; to bind a PVC to a Pod, you simply need to use the
    PVC name.
  prefs: []
  type: TYPE_NORMAL
- en: That way, the Pod will become attached to the `PersistentVolumeClaim` object,
    which will find the corresponding `PersisentVolume` object. This, in the end,
    will make the host path available and mounted on my NGINX Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the Pod and test the status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The Pod is up and running with the hostPath `/tmp/test` mounted inside via the
    PV and PVC. So far, we have learned what `PersistentVolume` and `PersistentVolumeClaim`
    objects are and how to use them to mount persistent storage on your Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we must continue our exploration of the `PersistentVolume` and `PersistentVolumeClaim`
    mechanics by explaining the life cycle of these two objects. Because they are
    independent of the Pods, their life cycles have some dedicated behaviors that
    you need to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the life cycle of a PersistentVolume object in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`PersistentVolume` objects are good if you want to maintain the state of your
    app without being constrained by the life cycle of the Pods or containers that
    are running them.'
  prefs: []
  type: TYPE_NORMAL
- en: However, since `PersistentVolume` objects get their very own life cycle, they
    have some very specific mechanics that you need to be aware of when you’re using
    them. We’ll take a closer look at them next.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding why PersistentVolume objects are not bound to namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to be aware of when you’re using `PersistentVolume` objects
    is that they are not `namespaced` resources, but `PersistentVolumeClaim` objects
    are.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So, if the Pod wants to use the `PersistentVolume`, then the `PersistentVolumeClaim`
    must be created in the same namespace as the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PersistentVolume` will have the following life cycle stages typically:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Provisioning**: Admin creates the PV, defining capacity, access modes, and
    optional details like storage class and reclaim policy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unbound state**: Initially, the PV is available but not attached to any Pod
    (unbound).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Claiming**: The developer creates a PVC, specifying size, access mode, and
    storage class preference (request for storage).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matching and binding**: Kubernetes finds an unbound PV that matches the PVC
    requirements and binds them together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using**: Pod accesses the bound PV through a volume mount defined in its
    YAML file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Releasing**: When the Pod using the PVC is deleted, the PVC becomes unbound
    (the PV state depends on the reclaim policy).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: The PV object itself can be deleted by the administrator, following
    the configured reclaim policy for the storage resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s examine another important aspect of `PersistentVolume`, known as
    reclaiming a policy. This is something that is going to be important when you
    want to unmount a PVC from a running Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Reclaiming a PersistentVolume object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to `PersistentVolume`, there is a very important option that you
    need to understand, which is the reclaim policy. But what does this option do?
  prefs: []
  type: TYPE_NORMAL
- en: This option will tell Kubernetes what treatment it should give to your `PersistentVolume`
    object when you delete the corresponding `PersistentVolumeClaim` object that was
    attaching it to the Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, deleting a `PersistentVolumeClaim` object consists of deleting the link
    between the Pods and your `PersistentVolume` object, so it’s like you unmount
    the volume and then the volume becomes available again for another application
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: However, in some cases, you don’t want that behavior; instead, you want your
    `PersistentVolume` object to be automatically removed when its corresponding `PersistentVolumeClaim`
    object has been deleted. That’s why the reclaim policy option exists, and it is
    what you should configure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explain these three reclaim policies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Delete**: This is the simplest of the three. When you set your reclaim policy
    to delete, the `PersistentVolume` object will be wiped out and the `PersistentVolume`
    entry will be removed from the Kubernetes cluster when the corresponding `PersistentVolumeClaim`
    object is deleted. You can use this when you want your data to be deleted and
    not used by any other application. Bear in mind that this is a permanent option,
    so you might want to build a backup strategy with your underlying storage provider
    if you need to recover anything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example, the PV was created manually with hostPath and the path is `/tmp/`.
    The deletion operation will work without any issues here. However, the delete
    operation may not work for all PV types when you create it manually. It is highly
    recommended to use dynamic PV provisioning, which you will learn about later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Retain**: This is the second policy and is contrary to the delete policy.
    If you set this reclaim policy, the `PersistentVolume` object won’t be deleted
    if you delete its corresponding `PersistentVolumeClaim` object. Instead, the `PersistentVolume`
    object will enter the released status, which means it is still available in the
    cluster, and all of its data can be manually retrieved by the cluster administrator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recycle**: This is a kind of combination of the previous two policies. First,
    the volume is wiped of all its data, such as a basic `rm -rf volume/*` volume.
    However, the volume itself will remain accessible in the cluster, so you can mount
    it again on your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recycle reclaim policy has been deprecated. It is now advised to utilize
    dynamic provisioning as the preferred approach.
  prefs: []
  type: TYPE_NORMAL
- en: The reclaim policy can be set in your cluster directly in the YAML definition
    file at the `PersistentVolume` level.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a reclaim policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The good news with a reclaim policy is that you can change it after the `PersistentVolume`
    object has been created; it is a mutable setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the reclaim policy differences, let us use the previously created
    Pod, PV, and PVC as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the Pod first as it is using the PVC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, check the status of the PV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the output that the PV is in a `Released` state but not yet
    in an `Available` state for the next PVC to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us update the reclaim policy to `Delete` using the `kubectl patch` command
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding output, we have updated the reclaim policy of
    the PV and then the PV has been deleted from the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss the different statuses that PVs and PVCs can have.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PersistentVolume and PersistentVolumeClaim statuses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like Pods can be in a different state, such as `Pending`, `ContainerCreating`,
    `Running`, and more, `PersistentVolume` and `PersistentVolumeClaim` can also hold
    different states. You can identify their state by issuing the `kubectl get pv`
    and `kubectl get pvc` commands.
  prefs: []
  type: TYPE_NORMAL
- en: '`PersistentVolume` has the following different states that you need to be aware
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Available`: This is the initial state for a newly created PV. It indicates
    the PV is ready to be bound to a PVC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bound`: This status signifies that the PV is currently claimed by a specific
    PVC and is in use by a Pod. Essentially, it indicates that the volume is currently
    in use. When this status is applied to a `PersistentVolumeClaim` object, this
    indicates that the PVC is currently in use: that is, a Pod is using it and has
    access to a PV through it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Terminating`: The `Terminating` status applies to a `PersistentVolumeClaim`
    object. This is the status the PVC enters after you issue a `kubectl delete pvc`
    command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Released`: If a PVC using the PV is deleted (and the reclaim policy for the
    PV is set to “Retain”), the PV will transition to this state. It’s essentially
    unbound but still available for future PVCs to claim.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Failed`: This status indicates an issue with the PV, preventing it from being
    used. Reasons could be storage provider errors, access issues, or problems with
    the provisioner (if applicable).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unknown`: In rare cases, the PV status might be unknown due to communication
    failures with the underlying storage system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have all the basics relating to `PersistentVolume` and `PersistentVolumeClaim`,
    which should be enough to start using persistent storage in Kubernetes. However,
    there’s still something important to know about this topic, and it is called dynamic
    provisioning. This is a very impressive aspect of Kubernetes that makes it able
    to communicate with cloud provider APIs to create persistent storage on the cloud.
    Additionally, it can make this storage available on the cluster by dynamically
    creating PV objects. In the next section, we will compare static and dynamic provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding static and dynamic PersistentVolume provisioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve only provisioned `PersistentVolume` by doing static provisioning.
    Now, we’re going to discover dynamic `PersistentVolume` provisioning, which enables
    `PersistentVolume` provisioning directly from the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Static versus dynamic provisioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, when using static provisioning, you have learned that you must follow
    this workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: You create the piece of storage against the cloud provider or the backend technology.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you create the `PersistentVolume` object to serve as a Kubernetes pointer
    to this actual storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following this, you create a Pod and a PVC to bind the PV to the Pod.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That is called static provisioning. It is static because you have to create
    the piece of storage before creating the PV and the PVC in Kubernetes. It works
    well; however, at scale, it can become more and more difficult to manage, especially
    if you are managing hundreds of PVs and PVCs. Let’s say you are creating an Amazon
    EBS volume to mount it as a `PersistentVolume` object, and you would do it like
    this with static provisioning:'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticate against the AWS console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an EBS volume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy/paste its unique ID to a `PersistentVolume` YAML definition file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the PV using your YAML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a PVC to fetch this PV.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount the PVC to the Pod object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, it should work in a manual or automated way, but it would become complex
    and extremely time-consuming to do at scale, with possibly dozens and dozens of
    PVs and PVCs.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why Kubernetes developers decided that it would be better if Kubernetes
    was capable of provisioning the piece of actual storage on your behalf along with
    the `PersistentVolume` object to serve as a pointer to it. This is known as dynamic
    provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing dynamic provisioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using dynamic provisioning, you configure your Kubernetes cluster so that
    it authenticates against the backend storage provider (such as AWS, Azure, or
    other storage devices). Then, you issue a command to provision a storage disk
    or volume and automatically create a `PersistentVolume` so that the PVC can use
    it. That way, you can save a huge amount of time by getting things automated.
    Dynamic provisioning is so useful because Kubernetes supports a wide range of
    storage technologies. We already introduced a few of them earlier in this chapter,
    when we mentioned NFS and other types of storage.
  prefs: []
  type: TYPE_NORMAL
- en: But how does Kubernetes achieve this versatility? Well, the answer is that it
    makes use of a third resource type, the `StorageClass` object, which we’re going
    to learn about in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to CSI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we talk about `StorageClass`, let us learn about CSI, which acts as a
    bridge between Kubernetes and various storage solutions. It defines a standard
    interface for exposing the storage to container workloads. CSI provides an abstraction
    layer to interact with Kubernetes primitives like `PersistentVolume`, enabling
    the integration of diverse storage solutions into Kubernetes, while maintaining
    a vendor-neutral approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes dynamic storage provisioning involves the following steps typically:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install and configure `StorageClass` and provisioner: The administrator installs
    a CSI driver (or in-tree provisioner) and configures a `StorageClass`, which defines
    the storage type, parameters, and reclaim policy.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Developer creates PVC with `StorageClass` information: The developer creates
    a `PersistentVolumeClaim`, specifying the desired size and access mode and referencing
    the `StorageClass` to request dynamic provisioning.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `StorageClass`/CSI driver triggers a request to the backend provisioner:
    Kubernetes automatically triggers the CSI driver (or provisioner) when it detects
    the PVC, sending the request to provision storage from the backend storage system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provisioner communicates with backend storage and creates the volume: The provisioner
    communicates with the backend storage system, creates the volume, and generates
    a `PersistentVolume` in Kubernetes that binds to the PVC.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The PVC is mounted to the Pod, allowing storage access: The PVC is mounted
    to the requesting Pod, allowing the Pod to access the storage as specified by
    the `volumeMount` in the Pod’s configuration.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following diagram illustrates the dynamic PV provisioning workflow.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Dynamic PV provisioning in Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: '**CSI drivers** are containerized implementations by storage vendors that adhere
    to the CSI specification and provide functionalities for provisioning, attaching,
    detaching, and managing storage volumes.'
  prefs: []
  type: TYPE_NORMAL
- en: CSI node and controller services are Kubernetes services that run the CSI driver
    logic on worker nodes and a control plane respectively, facilitating communication
    between Pods and the storage system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a CSI-compatible volume driver is deployed on a Kubernetes cluster, users
    can leverage the `csi` volume type. (Refer to the documentation at [https://kubernetes-csi.github.io/docs/drivers.html](https://kubernetes-csi.github.io/docs/drivers.html)
    to see the set of CSI drivers that can be used with Kubernetes). This allows them
    to attach or mount volumes exposed by the CSI driver. There are three ways to
    utilize a `csi` volume within a Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Referencing a `PersistentVolumeClaim`: This approach links the Pod to persistent
    storage managed by Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Utilizing a generic ephemeral volume: This method provides temporary storage
    that doesn’t persist across Pod restarts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Leveraging a CSI ephemeral volume (if supported by the driver): This offers
    driver-specific ephemeral storage options beyond the generic version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, you don’t directly interact with CSI. `StorageClasses` can reference
    CSI drivers by name in the `provisioner` field, leveraging CSI for volume provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing StorageClasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`StorageClass` is another resource type exposed by `kube-apiserver`. You might
    already have noticed this field earlier in the `kubectl get pv` command output.
    This resource type is the one that grants Kubernetes the ability to deal with
    several underlying technologies transparently.'
  prefs: []
  type: TYPE_NORMAL
- en: '`StorageClasses` act as a user-facing interface for defining storage requirements.
    **CSI drivers**, referenced by `StorageClasses`, provide the actual implementation
    details for provisioning and managing storage based on the specific storage system.
    `StorageClasses` essentially bridge the gap between your storage needs and the
    capabilities exposed by CSI drivers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access and list the `storageclasses` resources created within your
    Kubernetes cluster by using `kubectl`. Here is the command to list the storage
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also check the details about the `StorageClass` using the `-o yaml`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, you can use the plural form of `storageclasses` along with the
    `sc` alias. The following three commands are essentially the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we haven’t included the output of the command for simplicity, but
    it is essentially the same for the three commands. There are two fields within
    the command output that are important to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NAME`: This is the name and the unique identifier of the `storageclass` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PROVISIONER`: This is the name of the underlying storage technology: this
    is basically a piece of code the Kubernetes cluster uses to interact with the
    underlying technology.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that you can create multiple `StorageClass` objects that use the same `provisioner`.
  prefs: []
  type: TYPE_NORMAL
- en: As we are currently using a `minikube` cluster in our lab environment, we have
    a `storageclass` resource called `standard` that is using the `k8s.io/minikube-hostpath`
    provisioner.
  prefs: []
  type: TYPE_NORMAL
- en: This provider deals with my host filesystem to automatically create provisioned
    host path volumes for my Pods, but it could be the same for Amazon EBS volumes
    or Google PDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In GKE, Google built a storage class with a provisioner that was capable of
    interacting with the Google PD’s API, which is a pure Google Cloud feature, and
    you can implement it with `StorageClass` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In contrast, in AWS, we have a `storageclass` object with a provisioner that
    is capable of dealing with EBS volume APIs. These provisioners are just libraries
    that interact with the APIs of these different cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: The `storageclass` objects are the reason why Kubernetes can deal with so many
    different storage technologies. From a Pod perspective, no matter if it is an
    EBS volume, NFS drive, or GKE volume, the Pod will only see a `PersistentVolume`
    object. All the underlying logic dealing with the actual storage technology is
    implemented by the provisioner the `storageclass` object uses.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that you can add as many `storageclass` objects with their
    provisioner as you want to your Kubernetes cluster in a plugin-like fashion.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, nothing is preventing you from expanding your cluster by adding
    `storageclasses` to your cluster. You’ll simply add the ability to deal with different
    storage technologies from your cluster. For example, we can add an Amazon EBS
    `storageclass` object to our `minikube` cluster. However, while it is possible,
    it’s going to be completely useless. Indeed, if your `minikube` setup is not running
    on an EC2 instance but on your local machine, it won’t be able to attach an EBS.
  prefs: []
  type: TYPE_NORMAL
- en: That said, for a more practical approach, you can consider using CSI drivers
    from providers that support local deployment, such as OpenEBS, TopoLVM, or Portworx.
    These allow you to work with persistent storage locally, even on minikube. Additionally,
    most cloud providers offer free tiers for small Kubernetes deployments, which
    could be useful for testing out storage solutions in a cloud environment without
    incurring significant costs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about the difference in dynamic storage provisioning
    with PVC.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the role of PersistentVolumeClaim for dynamic storage provisioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using dynamic storage provisioning, the `PersistentVolumeClaim` object
    will get an entirely new role. Since `PersistentVolume` is gone in this use case,
    the only object that will be left for you to manage is the `PersistentVolumeClaim`
    one because the `PersistentVolume` object will be managed by the `StorageClass`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s demonstrate this by creating an NGINX Pod that will mount a `hostPath`
    type dynamically. In this example, the administrator won’t have to provision a
    `PersistentVolume` object at all. This is because the `PersistentVolumeClaim`
    object and the `StorageClass` object will be able to create and provision the
    `PersistentVolume` together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new namespace called `dynamicstorage`, where we will
    run our examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s run a `kubectl get sc` command to check that we have a storage class
    that is capable of dealing with the `hostPath` that is provisioned in our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: For this specific `storageclass` object in this specific Kubernetes setup (`minikube`),
    we don’t have to do anything to get the `storageclass` object, as it is created
    by default at cluster installation. However, this might not be the case depending
    on your Kubernetes distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bear this in mind because it is very important: clusters that have been set
    up on GKE might have default storage classes that are capable of dealing with
    Google’s storage offerings, whereas an AWS-based cluster might have `storageclass`
    to communicate with Amazon’s storage offerings and more. With `minikube`, we have
    at least one default `storageclass` object that is capable of dealing with a `hostPath`-based
    `PersistentVolume` object. If you understand that, you should understand that
    the output of the `kubectl get sc` command will be different depending on where
    your cluster has been set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we do have a storage class called `standard` on our cluster
    that is capable of dealing with `hostPath`.
  prefs: []
  type: TYPE_NORMAL
- en: Some complex clusters spanning across multiple clouds and or on-premises might
    be provisioned with a lot of different `storageclass` objects to be able to communicate
    with a lot of different storage technologies. Bear in mind that Kubernetes is
    not tied to any cloud provider and, therefore, does not force or limit you in
    your usage of backing storage solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a `PersistentVolumeClaim` object that will dynamically
    create a `hostPath` type. Here is the YAML file to create the PVC. Please note
    that `storageClassName` is set to `standard`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this, we can create it in the proper namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us check the status of the PV and PVC now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the PV has been created by the `StorageClass` and bound to the
    PVC as per the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that this PVC has been created, we can add a new Pod that will mount this
    `PersistentVolumeClaim` object. Here is a YAML definition file of a Pod that will
    mount the `PersistentVolumeClaim` object that was created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create it in the correct namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Everything is OK! We’re finally done with dynamic provisioning! Please note
    that, by default, the reclaim policy will be set to `delete` so that the PV is
    removed when the PVC that created it is removed, too. Don’t hesitate to change
    the reclaim policy if you need to retain sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test it by deleting the Pod and PVC; the PV will be removed automatically
    by the `StorageClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We can see from the above snippet that the PV is also deleted automatically
    when the PVC gets deleted.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve covered the basics of PVs, PVCs, `StorageClasses`, and the differences
    between static and dynamic provisioning. In the next section, we’ll dive into
    some advanced storage topics in Kubernetes, exploring how to optimize and extend
    your storage strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced storage topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to understanding the basics of PVs, PVCs, and `StorageClasses`,
    it’s beneficial to delve into some advanced storage topics in Kubernetes. While
    not mandatory, having knowledge of these concepts can significantly enhance your
    expertise as a Kubernetes practitioner. In the following sections, we will introduce
    advanced topics such as ephemeral volumes for temporary storage, CSI Volume Cloning
    for flexible volume management, and expanding `PersistentVolumeClaims` to accommodate
    increased storage needs. These topics will provide you with a broader perspective
    on Kubernetes storage capabilities and practical applications.
  prefs: []
  type: TYPE_NORMAL
- en: Ephemeral volumes for temporary storage in Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ephemeral volumes offer a convenient way to provide temporary storage for Pods
    in Kubernetes. They’re perfect for applications that need scratch space for caching
    or require read-only data, like configuration files or Secrets. Unlike PVs, ephemeral
    volumes are automatically deleted when the Pod terminates, simplifying deployment
    and management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few key benefits of ephemeral volumes for temporary storage:'
  prefs: []
  type: TYPE_NORMAL
- en: Temporary storage for Pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic deletion with Pod termination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplified deployment and management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are multiple types of ephemeral storage available in Kubernetes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'emptyDir: This creates an empty directory on the node’s local storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ConfigMap, downwardAPI, Secret: This injects data from Kubernetes objects into
    the Pod'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CSI ephemeral volumes: These are provided by external CSI drivers (requires
    specific driver support)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generic ephemeral volumes: These are offered by storage drivers supporting
    PVs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have learned some details with regard to ephemeral volumes, let’s
    move on to gain some understanding of CSI volume cloning and volume snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: CSI volume cloning and volume snapshots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CSI introduces a powerful feature: volume cloning. This functionality allows
    you to create an exact copy of an existing `PersistentVolumeClaim` as a new PVC.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following YAML snippet illustrates a typical PVC cloning declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a few key benefits of CSI Volume Cloning:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplified workflows**: CSI Volume Cloning automates data replication, eliminating
    the need for manual copying and streamlining storage management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced efficiency**: Easily create replicas of existing volumes, optimizing
    deployments and resource utilization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Troubleshooting live data**: Instead of touching the production data, you
    can take a copy and use it for QA, troubleshooting, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Refer to the documentation to learn more about CSI volume cloning: [https://kubernetes.io/docs/concepts/storage/volume-pvc-datasource](https://kubernetes.io/docs/concepts/storage/volume-pvc-datasource).'
  prefs: []
  type: TYPE_NORMAL
- en: Like volume cloning, Kubernetes also offers another mechanism via CSI drivers
    to take data backups called volume snapshots. `VolumeSnapshot` provides a standardized
    way to create a point-in-time copy of a volume’s data. Similar to `PersistentVolume`
    and `PersistentVolumeClaim` resources, Kubernetes uses VolumeSnapshot, `VolumeSnapshotContent`,
    and `VolumeSnapshotClass` resources to manage volume snapshots. VolumeSnapshots
    are user requests for snapshots, while VolumeSnapshotContent represents the actual
    snapshots on the storage system. These resources enable users to capture the state
    of their volumes without provisioning an entirely new volume, making it useful
    for scenarios such as database backups before performing critical updates or deletions.
    Unlike regular PVs, these snapshot resources are **Custom Resource Definitions**
    (**CRDs**) and require a CSI driver that supports snapshot functionality. The
    CSI driver uses a sidecar container called `csi-snapshotter` to handle `CreateSnapshot`
    and `DeleteSnapshot` operations.
  prefs: []
  type: TYPE_NORMAL
- en: When a user creates a snapshot, it can be either pre-provisioned by an administrator
    or dynamically provisioned from an existing PVC. The snapshot controller binds
    the VolumeSnapshot and VolumeSnapshotContent in both scenarios, ensuring that
    the snapshot content matches the user request. Snapshots can be easily deleted
    or retained based on the set `DeletionPolicy`, allowing flexibility in how data
    is managed. Furthermore, Kubernetes provides the option to convert a snapshot’s
    volume mode (e.g., from filesystem to block) and restore data from a snapshot
    to a new PVC. This capability makes VolumeSnapshot a powerful tool in data protection,
    which can be complemented by CSI volume cloning to create efficient backups or
    test environments, adding another layer of flexibility to storage management in
    Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Volume cloning in Kubernetes is ideal for creating identical copies of `PersistentVolumes`,
    often used for development and testing environments. Snapshots, on the other hand,
    capture the point-in-time state of a volume, making them useful for backup and
    restore purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the documentation (https://kubernetes.io/docs/concepts/storage/volume-snapshots/)
    to learn more about volume snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will learn how to expand a PVC.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to expand PersistentVolumeClaim
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes offers built-in support for expanding PVCs, allowing you to seamlessly
    increase storage capacity for your applications. This functionality is currently
    limited to volumes provisioned by CSI drivers (as of version 1.29, other volume
    types are deprecated).
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable PVC expansion for a specific `StorageClass`, you need to set the
    `allowVolumeExpansion` field to `true` within the `StorageClass` definition. This
    flag controls whether PVCs referencing this `StorageClass` can request more storage
    space:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example StorageClass Configuration:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When your application requires additional storage, simply edit the PVC object
    and specify a larger size in the `resources.requests.storage` field. Kubernetes
    will then initiate the expansion process, resizing the underlying volume managed
    by the CSI driver. This eliminates the need to create a new volume and migrate
    data, streamlining storage management.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the documentation (https://kubernetes.io/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims)
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have arrived at the end of this chapter, which taught you how to manage persistent
    storage on Kubernetes. You discovered that `PersistentVolume` is a resource type
    that acts as a point to an underlying resource technology, such as `hostPath`
    and NFS, along with cloud-based solutions such as Amazon EBS and Google PDs.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you discovered the relationship between `PersistentVolume`, `PersistentVolumeClaim`,
    and `storageClass`. You learned that `PersistentVolume` can hold different reclaim
    policies, which makes it possible to remove, recycle, or retain them when their
    corresponding `PersistentVolumeClaim` object gets removed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discovered what dynamic provisioning is and how it can help us.
    Bear in mind that you need to be aware of this feature because if you create and
    retain too many volumes, it can have a negative impact on your cloud bill at the
    end of the month, even though you can restrict storage usage using resource quotas
    for the namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: We’re now done with the basics of Kubernetes, and this chapter is also the end
    of this section. In the next section, you’re going to discover Kubernetes controllers,
    which are objects designed to automate certain tasks in Kubernetes, such as maintaining
    a number of replicas of your Pods, either using the Deployment resource type or
    the StatefulSet resource type. There are still a lot of things to learn!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Persistent Volumes: https://kubernetes.io/docs/concepts/storage/persistent-volumes/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Types of Persistent Volumes: [https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dynamic Volume Provisioning: https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expanding Persistent Volumes Claims: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CSI Volume Cloning: https://kubernetes.io/docs/concepts/storage/volume-pvc-datasource/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code119001106479081656.png)'
  prefs: []
  type: TYPE_IMG
