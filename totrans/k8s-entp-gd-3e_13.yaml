- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: KubeArmor Securing Your Runtime
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KubeArmor保护你的运行时
- en: As the popularity of Kubernetes grows, so does the need for robust security
    measures to protect workloads. We learned how to secure a cluster using RBAC,
    which allows us to control the access that users have to resources. Using RBAC,
    we can control what users can execute on a cluster, controlling if someone can
    create or delete a pod, view logs, view Secrets, etc. We also looked at securing
    clusters using Gatekeeper policies that can protect nodes by denying the creation
    of an object that contains a value against security policies like attempting to
    allow privilege escalation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Kubernetes的普及，保护工作负载的强大安全措施的需求也在增加。我们学习了如何使用RBAC来保护集群安全，RBAC允许我们控制用户对资源的访问权限。通过RBAC，我们可以控制用户在集群上能执行什么操作，控制某人是否能够创建或删除Pod、查看日志、查看Secrets等。我们还研究了使用Gatekeeper策略来保护集群，这可以通过拒绝创建违反安全策略的对象（例如尝试允许特权升级）来保护节点。
- en: While these go a long way to securing clusters, there are certain actions that
    are often overlooked by many organizations. One of the most important examples
    is securing the container runtime.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些措施大大增强了集群的安全性，但许多组织经常忽视某些操作。最重要的例子之一就是保护容器运行时。
- en: Kubernetes has limited abilities to audit or secure actions that are executed
    within a container. While Kubernetes can handle certain security requirements
    like blocking elevated privilege attempts within a container, it doesn’t provide
    a way for operators to limit most actions that are executed in the container.
    It cannot allow or deny any actions that a user may be able to execute once they
    exec into a running container, like looking at files, deleting files, adding files,
    and more. Even worse, most actions executed inside a container are not audited
    by the Kubernetes API server, which is why they often go overlooked.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes在审计或保护容器内执行的操作方面的能力有限。尽管Kubernetes可以处理某些安全要求，例如阻止容器内的特权提升尝试，但它并没有为操作员提供限制容器中执行的大部分操作的方式。它不能允许或拒绝用户在执行进入运行中的容器时能够执行的任何操作，比如查看文件、删除文件、添加文件等。更糟糕的是，大多数在容器内执行的操作不会被Kubernetes
    API服务器审计，这也是这些操作常常被忽视的原因。
- en: In *Chapter 8*, *Managing Secrets*, we learned about using Vault to store and
    retrieve secrets. Many people think that if they use a system like Vault, they
    have secured their secrets from anyone being able to view the data in the secret.
    It is true that the secret isn’t stored in a basic K8s secret resource, where
    anyone with the required permissions to the namespace would be able to view and
    decode the secret. Since a Vault secret will be stored in your pod as an environment
    variable or a file, there is no way to stop someone who has access to exec into
    the container from viewing the container’s environment variables or the files
    where the Vault secret is stored.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第八章*，*管理机密*中，我们学习了如何使用Vault来存储和检索机密。许多人认为，如果使用像Vault这样的系统，他们就能确保机密数据不被任何人查看。的确，机密数据不会存储在基本的K8s秘密资源中，在那里，只要有适当的命名空间权限，任何人都可以查看并解码机密。然而，由于Vault机密将存储在你的Pod中作为环境变量或文件，无法阻止拥有exec权限的人查看容器的环境变量或存储Vault机密的文件。
- en: We also need a way to stop certain processes from running in containers. Your
    organization may have a policy that a container should never run an SSH daemon.
    Without an add-on tool, you have limited options to secure binaries to that level
    in a running container.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方式来阻止某些进程在容器中运行。你的组织可能有一个策略，即容器永远不应运行SSH守护进程。如果没有附加工具，你在运行中的容器中保护二进制文件到这种级别的选项非常有限。
- en: Sure, you can create pipelines and security checks when an image is created
    and deny images that don’t follow documented security standards, but once the
    image passes and is deployed, how do you stop someone from executing an exec into
    the container and adding binaries like the SSH daemon, or even worse, malware
    or crypto mining tools?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在镜像创建时创建管道和安全检查，并拒绝不符合文档安全标准的镜像，但一旦镜像通过并部署了，如何阻止某人执行exec进入容器并添加像SSH守护进程这样的二进制文件，甚至更糟的恶意软件或加密矿工工具？
- en: Luckily, a company called AccuKnox has donated a project to the CNCF called
    **KubeArmor** that provides you with the ability to secure your container runtime.
    KubeArmor isn’t limited to only the runtime; it has a number of other useful features
    that are related to securing your workloads, including restricting process execution,
    file access, and more.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，一家公司名为 AccuKnox 向 CNCF 捐赠了一个名为**KubeArmor**的项目，它为您提供了保护容器运行时的能力。KubeArmor
    不仅限于运行时，它还具有一些与保护工作负载相关的其他有用功能，包括限制进程执行、文件访问等。
- en: 'In this chapter, we will explain how to deploy KubeArmor and how to use its
    many features to enhance the security of your clusters. Here are a few topics
    that we will cover in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释如何部署 KubeArmor，以及如何使用其众多功能来增强集群的安全性。以下是我们将在本章中介绍的几个主题：
- en: What is runtime security?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是运行时安全？
- en: Introducing KubeArmor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 KubeArmor
- en: Deploying KubeArmor
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署 KubeArmor
- en: Enabling KubeArmor logging
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 KubeArmor 日志记录
- en: KubeArmor and LSM policies
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KubeArmor 和 LSM 策略
- en: Creating a KubeArmorSecurityPolicy
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 KubeArmorSecurityPolicy
- en: Using karmor to interact with KubeArmor
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 karmor 与 KubeArmor 互动
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章具有以下技术要求：
- en: An Ubuntu 22.04+ server running Docker with a minimum of 8 GB of RAM
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行 Docker 的 Ubuntu 22.04+ 服务器，内存至少为 8 GB
- en: A KinD cluster, preferably a new cluster, with Vault integrated
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 KinD 集群，最好是一个新的集群，并且集成了 Vault
- en: 'Scripts from the `chapter13` folder from the repo, which you can access by
    going to this book’s GitHub repository: [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过访问本书的 GitHub 仓库：[https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition)
    来获取 `chapter13` 文件夹中的脚本。
- en: What is runtime security?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是运行时安全？
- en: Runtime security is a vital part of security for systems, applications, and
    data when they are most exposed to attacks during active execution, while they
    are up and running on your network. Runtimes, often left unmonitored and sometimes
    lacking in any form of logging or auditing, pose a critical security challenge.
    Of course, runtime security is not exclusive to containers; it is a requirement
    for applications, containers, physical servers, virtual machines, and more. Every
    component within your infrastructure requires continuous monitoring of all potential
    security risks to quickly detect threats and vulnerabilities posed by potential
    attackers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时安全是系统、应用程序和数据在活跃执行期间最容易受到攻击时的关键安全部分，尤其是在它们运行在您的网络上时。运行时通常未被监控，有时缺乏任何形式的日志记录或审计，这带来了重大的安全挑战。当然，运行时安全不仅限于容器，它对于应用程序、容器、物理服务器、虚拟机等都是必要的。基础设施中的每个组件都需要持续监控所有潜在的安全风险，以便快速检测到潜在攻击者带来的威胁和漏洞。
- en: 'In the face of increasingly sophisticated and dynamic security threats, the
    reliance solely on static security measures is no longer adequate. This is where
    runtime security comes in, providing dynamic, real-time protection precisely when
    it is most crucial: with live systems. Through constant monitoring of the runtime
    environment, these systems can spot anomalies, suspicious activities, and unauthorized
    processes and allow or block actions based on a set of policies.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 面对日益复杂和动态的安全威胁，单纯依赖静态的安全措施已经不再足够。这就是运行时安全的作用所在，它提供动态的、实时的保护，正是在最关键的时候：在系统运行时。通过不断监控运行时环境，这些系统能够发现异常、可疑活动和未经授权的进程，并根据一组策略允许或阻止操作。
- en: To secure workloads you need to follow key practices, such as permitting only
    authorized processes in a container, implementing measures to prevent and alert
    on any unauthorized resource access, or inspecting network traffic to detect any
    hostile activities. For example, you can limit what processes can access files
    or directories in a container, denying access to a database file to any process
    that isn’t part of MySQL.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护工作负载，您需要遵循一些关键实践，例如只允许授权的进程在容器中运行、实施措施防止并警告任何未经授权的资源访问，或检查网络流量以检测任何恶意活动。例如，您可以限制哪些进程可以访问容器中的文件或目录，拒绝任何非
    MySQL 进程访问数据库文件。
- en: 'Runtime security has multiple pieces to consider: using KubeArmor is just one
    of the tools to help protect your workloads and clusters. *Figure 13.1* shows
    a picture of the components that make up a runtime environment from the CNCF security
    V2 whitepaper. You can find the whole paper on the CNCF website at [https://www.cncf.io/wp-content/uploads/2022/06/CNCF_cloud-native-security-whitepaper-May2022-v2.pdf](https://www.cncf.io/wp-content/uploads/2022/06/CNCF_cloud-native-security-whitepaper-May2022-v2.pdf).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: We have covered many of the various tools to secure your runtimes in previous
    chapters, including network policies, identity and access management, secrets,
    and policy security using **Gatekeeper**. Combining these options with the added
    security that KubeArmor supplies, you can secure your clusters from malicious
    activity.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_13_01.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: CNCF runtime security landscape'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: In summary, KubeArmor is a runtime security tool that provides dynamic, real-time
    protection for your systems against an ever-expanding spectrum of threats and
    vulnerabilities. Its purpose is to protect the security and stability of your
    infrastructure, upholding the integrity of your operations in the face of countless
    cybersecurity threats.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Introducing KubeArmor
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into KubeArmor, we need to define a few base concepts you need
    to be aware of. If you are new to Linux, you may not be familiar with these, and
    even if you are a Linux veteran, the concepts may still be new to you.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Linux Security
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you will primarily see two references that need to be understood
    to understand how KubeArmor protects clusters. The first term is **eBPF**, which
    stands for the **extended Berkley Packet Filter**, and the second one is **LSM**,
    which stands for **Linux Security Module**. In *Figure 13.2*, you can see how
    access from a pod goes through KubeArmor before it hits the host’s kernel. This
    is what allows KubeArmor to secure your runtimes: sitting between the pod runtime
    and the kernel, to take action before a request is executed.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_13_02.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: KubeArmor’s high-level design'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to explain, at a high level, what eBPF and LSMs are and how they
    help to secure a cluster.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you ever wondered how Linux handles the constant stream of data in and
    out of the system? How it monitors performance, and how it protects itself from
    security risks? Well, that’s where eBPF comes in: it handles all these responsibilities
    and more!'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Think of eBPF as a digital traffic cop. Your computer resembles a busy intersection
    where data is in constant motion. eBPF acts as a traffic controller, capable of
    controlling the data flow, inspecting it for issues, and tracking ongoing activities.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'One advantage of eBPF is its use of “virtual machines,” rather than requiring
    direct edits to the kernel to add features like monitoring network traffic. eBPF
    primarily uses programs that are written in a restricted subset of C and are executed
    within the kernel. While C is the most commonly used language for creating eBPF
    programs, you can also create them using other languages, including:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF的一个优势是它使用“虚拟机”，而不是直接编辑内核来添加监控网络流量等功能。eBPF主要使用以C语言的受限子集编写的程序，这些程序在内核内执行。虽然C语言是创建eBPF程序时最常用的语言，但你也可以使用其他语言来创建它们，包括：
- en: Go
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go
- en: Lua
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lua
- en: Python
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: Rust
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust
- en: Using a language other than C involves transpiling to C or adding the required
    libraries that abstract the C programming. The final decision on selecting a language
    is ultimately up to your use cases, standards, and expertise.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用除C语言以外的语言涉及到转译成C语言或添加所需的库来抽象C语言编程。选择语言的最终决定取决于你的使用案例、标准和专业技能。
- en: In summary, eBPF provides a number of powerful functions, without the need to
    modify the kernel directly. It is highly secured and isolated, providing a security
    boundary through its use of virtual machines, similar to a standard virtual machine
    that runs a full operating system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，eBPF提供了许多强大的功能，而无需直接修改内核。它具有高度的安全性和隔离性，通过使用虚拟机提供了一个安全边界，类似于运行完整操作系统的标准虚拟机。
- en: The other term we mentioned was **LSM**, which stands for **Linux Security Module**.
    Two of the most common LSMs today are SELinux, which is primarily used by Red
    Hat systems, and **AppArmor**, which is used by a number of systems, including
    Ubuntu, SUSE, and Debian.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到的另一个术语是**LSM**，即**Linux安全模块**。当前最常见的两个LSM是SELinux，主要用于Red Hat系统，以及**AppArmor**，它被多个系统使用，包括Ubuntu、SUSE和Debian。
- en: Like the previous eBPF section, we are going to provide a high-level overview
    of LSMs with a focus on AppArmor since we are using Ubuntu as our server operating
    system.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的eBPF部分类似，我们将提供一个关于LSM的高层概述，重点介绍AppArmor，因为我们使用Ubuntu作为我们的服务器操作系统。
- en: LSMs are used to connect the kernel with security policies and modules, providing
    enforcement of **mandatory access controls** (**MACs**) and additional security
    policies within a Linux system. They provide a framework for security, providing
    hooks into the kernel, and allowing external modules the ability to intercept
    and secure systems calls, file operations, and other various kernel activities.
    LSMs are meant to be very flexible and extensible, allowing you to select and
    create modules that meet your specific requirements, rather than a set of policies
    that a vendor thinks you should implement.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: LSM用于将内核与安全策略和模块连接起来，提供对Linux系统中**强制访问控制**（**MACs**）和额外安全策略的执行。它们提供了一个安全框架，通过内核中的钩子提供对外部模块的支持，使得外部模块能够拦截和保护系统调用、文件操作和其他各种内核活动。LSM设计为非常灵活和可扩展，允许你选择和创建符合特定需求的模块，而不是供应商认为你应该实施的一套政策。
- en: Given that both eBPF and LSMs offer security functionalities, you might be wondering
    how, or if, they are different.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于eBPF和LSM都提供安全功能，你可能会想知道它们是否有区别，或者它们是如何不同的。
- en: Despite their apparent similarities at a high level, they diverge significantly.
    eBPF employs kernel-embedded virtual machines for execution, allowing the creation
    of programs capable of executing low-level tasks such as packet filtering, tracing,
    and performance monitoring. eBPF is commonly employed for network-related tasks,
    performance optimization, or the development of custom kernel-level functions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们在高层次上看似相似，但它们有显著的不同。eBPF利用内核嵌入的虚拟机进行执行，使得能够创建能够执行低级任务的程序，如数据包过滤、追踪和性能监控。eBPF通常用于与网络相关的任务、性能优化或开发自定义内核级功能。
- en: LSMs are components executed by the kernel, operating externally to the kernel
    itself. The core purpose of LSMs is to enhance system security through the enforcement
    of policies, including MACs, and other measures designed to safeguard system resources.
    These modules have the ability to increase cluster security by restricting access
    to various elements, ranging from files and processes to the flow of network traffic.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: LSM是由内核执行的组件，外部运行于内核本身之外。LSM的核心目的是通过执行策略（包括MACs）以及其他旨在保护系统资源的措施来增强系统安全性。这些模块能够通过限制对各种元素的访问（从文件和进程到网络流量的流动）来提高集群安全性。
- en: You can create policies without a tool like KubeArmor if you know enough about
    the specific LSM, like AppArmor. Imagine if you use multiple Linux vendors, you
    would need to know each LSM that each vendor is compatible with. This makes creating
    policies a challenge, and that’s where AppArmorKubeArmor can help.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够了解特定的 LSM（如 AppArmor），你可以在没有像 KubeArmor 这样的工具的情况下创建策略。试想一下，如果你使用多个 Linux
    发行版，你需要了解每个发行版所兼容的 LSM。这使得创建策略变得具有挑战性，而这正是 AppArmorKubeArmor 可以提供帮助的地方。
- en: KubeArmor streamlines the task of creating LSM policies, saving you from having
    to know the syntax between different LSMs. When you create a policy with KubeArmor,
    it automatically generates the corresponding LSM policy on the host system. This
    guarantees that, irrespective of the underlying LSM in operation, you can create
    a uniform set of policies that provide a consistent security standard across multiple
    Linux distributions and LSMs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 简化了创建 LSM 策略的任务，免去了你需要了解不同 LSM 之间语法的麻烦。当你使用 KubeArmor 创建策略时，它会自动在主机系统上生成相应的
    LSM 策略。这保证了无论底层 LSM 是什么，你都可以创建一组统一的策略，确保跨多个 Linux 发行版和 LSM 提供一致的安全标准。
- en: As you can imagine, KubeArmor uses both eBPF and LSMs to help you secure your
    environments. Now that we know about what both eBPF and LSMs provide, we can move
    on to introducing KubeArmor.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的，KubeArmor 同时使用 eBPF 和 LSM 来帮助你保护环境。现在我们已经了解了 eBPF 和 LSM 提供的功能，接下来我们可以介绍
    KubeArmor。
- en: Welcome to KubeArmor
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欢迎使用 KubeArmor
- en: Securing any environment can be a difficult task. When it comes to protecting
    your clusters, it’s not something you can simply address after the fact; it should
    be a part of the initial design and discussions. Many organizations tend to postpone
    the security aspect of their environments because of the perceived skills, effort,
    and time required to implement security solutions. However, it’s essential to
    establish a security foundation before your cluster goes into production. This
    can present a challenge to organizations, and that’s where KubeArmor steps in
    to assist.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 保护任何环境都可能是一项艰巨的任务。保护集群时，这不是你可以事后简单处理的问题；它应该是最初设计和讨论的一部分。许多组织倾向于推迟环境的安全性问题，因为他们认为实施安全解决方案需要技能、精力和时间。然而，在集群投入生产之前建立安全基础是至关重要的。这对许多组织来说是一个挑战，这正是
    KubeArmor 可以提供帮助的地方。
- en: By deploying KubeArmor, you can increase the security and regulatory compliance
    of containerized applications. KubeArmor serves as a runtime security solution
    designed to secure containerized workloads by enforcing security protocols and
    promptly identifying and allowing or denying any activity.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过部署 KubeArmor，你可以提高容器化应用程序的安全性和合规性。KubeArmor 作为一个运行时安全解决方案，旨在通过强制执行安全协议并及时识别和允许或拒绝任何活动来保护容器化工作负载。
- en: 'The features of KubeArmor are always evolving: by the time you read this book,
    KubeArmor will likely have additional features that we do not cover in this chapter.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 的功能在不断发展：等你读完这本书时，KubeArmor 可能会增加我们在本章中没有涉及的额外功能。
- en: So, what are some of the features that KubeArmor provides to enhance our security?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，KubeArmor 提供了哪些增强我们安全性的功能呢？
- en: Container security
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器安全
- en: 'Containers are the cornerstone of modern applications, making their security
    a primary objective. This isn’t to say that we think non-containerized applications
    don’t need security: of course they do, but non-containerized apps have a lot
    of security options provided by operating systems and third-party vendors. Containers,
    as we know them today, are relatively new and many of the toolsets are still catching
    up.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是现代应用程序的基石，使得容器安全成为首要目标。这并不是说我们认为非容器化应用程序不需要安全性：当然需要，但非容器化应用程序有很多操作系统和第三方供应商提供的安全选项。我们今天所知道的容器是相对较新的，许多工具集仍在追赶。
- en: KubeArmor provides security by continuously monitoring container behavior in
    real time, mitigating risks like container escapes, binary execution, and privilege
    escalations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 通过实时监控容器行为来提供安全性，缓解诸如容器逃逸、二进制执行和权限升级等风险。
- en: Inline mitigation versus post-attack mitigation
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内联缓解与事后攻击缓解
- en: There are a number of products on the market today that are very good at detecting
    anomalies, but they do not have the ability to block or allow the request before
    it actually executes. This is a post-attack mitigation process, which means the
    action will be allowed or denied and the anomaly will be logged.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有许多非常擅长检测异常的产品，但它们没有在实际执行之前阻止或允许请求的能力。这是一个攻击后缓解过程，意味着该动作会被允许或拒绝，异常也会被记录下来。
- en: This would be like having a door without a lock and when someone walks into
    the building, all you would get is an alert from a security camera. The person
    would still be allowed into the building since there is no lock on the door.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像是有一扇没有锁的门，当有人进入建筑物时，您得到的只是来自监控摄像头的警报。由于门没有锁，这个人仍然可以进入建筑物。
- en: Many of the offerings that only detect events can be integrated with other systems
    to prevent the action(s). For example, a system detects that someone may have
    injected a crypto miner into a running container. The event would be detected
    by the anomaly engine and based on that event, you could trigger a custom written
    routine to create a network policy that would deny all egress and ingress traffic.
    This would block the application from network activity, stopping the pod from
    mining and it would save the current state of the pod since we didn’t destroy
    it; we just stopped all network traffic to and from the pod.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 许多仅检测事件的产品可以与其他系统集成，以防止动作的执行。例如，一个系统检测到可能有人将加密货币挖矿程序注入正在运行的容器中。该事件将被异常引擎检测到，基于该事件，您可以触发一个自定义编写的程序来创建一个网络策略，拒绝所有进出流量。这将阻止应用程序进行网络活动，停止
    Pod 挖矿，并且我们没有销毁 Pod，只是停止了所有进出 Pod 的网络流量。
- en: '![Post Attack Mitigation](img/B21165_13_03.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![攻击后缓解](img/B21165_13_03.png)'
- en: 'Figure 13.3: Post-attack mitigation'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3：攻击后缓解
- en: 'In *Figure 13.3*, you can see the flow of a post-mitigation attack. The flow
    of the mitigation is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 13.3*中，您可以看到攻击后缓解的流程。缓解的流程如下：
- en: Post-exploit mitigation works by actioning suspicious activity in response to
    an alert indicating malicious intent.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击后缓解通过对可疑活动采取行动，响应表示恶意意图的警报。
- en: The attacker is allowed to execute a binary or other actions. Since they have
    access, they may be able to disable security controls, logging, etc. to avoid
    detection.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击者被允许执行二进制文件或其他操作。由于他们有访问权限，他们可能能够禁用安全控制、日志记录等，以避免被检测到。
- en: Assuming the action has been detected, we send it to an event handler that can
    execute an action based on the event. However, it’s important to point out that
    by the time a malicious process is actioned, sensitive contents may have already
    been deleted, encrypted, or transmitted.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设该动作已经被检测到，我们将其发送到事件处理程序，后者可以根据事件执行相应的动作。然而，重要的是要指出，在恶意进程被执行时，敏感内容可能已经被删除、加密或传输。
- en: Based on the event, the handler will execute an action like deleting the pod
    or perform other actions like creating a network policy to block communication
    without deleting the pod.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据事件，处理程序将执行一个动作，如删除 Pod，或者执行其他动作，如创建网络策略以阻止通信，而不删除 Pod。
- en: 'One key differentiator of KubeArmor is its ability to not only detect the runtime
    event but to take action on the event, to block or allow it based on various parameters.
    Similar to post-attack mitigation, you would still see the attempted action(s)
    logged, which may be required as evidence to document the malicious activity.
    However, unlike the previous example of a door with no lock, this door would have
    a camera and a lock. When someone tries to open the door, the camera will log
    the attempt: but this time, since the door is locked, the opening action will
    be denied.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 的一个关键区别是它不仅能检测运行时事件，还能对事件采取行动，根据各种参数来阻止或允许该事件。与攻击后缓解类似，您仍然会看到尝试的动作被记录下来，这些记录可能是记录恶意活动所需的证据。然而，不像之前那个没有锁的门的例子，这扇门将配有摄像头和锁。当有人尝试打开门时，摄像机会记录下这一尝试：但这一次，由于门被锁住，开门的动作将被拒绝。
- en: '![KubeArmor Differentiation](img/B21165_13_04.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![KubeArmor 差异化](img/B21165_13_04.png)'
- en: 'Figure 13.4: Inline mitigation'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4：内联缓解
- en: 'In *Figure 13.4*, you can see how streamlined the process is: we don’t need
    an external event handler, or any custom components to act on the event. Since
    KubeArmor handles the events in line, in real time, we can stop an action instantly
    before an attacker can perform any malicious activity, all in a single product.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 13.4* 中，你可以看到该过程是如何简化的：我们无需外部事件处理程序或任何自定义组件来处理事件。由于 KubeArmor 在实时内联处理事件，我们可以在攻击者执行任何恶意操作之前立即停止该行为，所有这些都在一个单一产品中完成。
- en: As you can see, inline mitigation is a better method of mitigating runtime events.
    Threats move quickly in today’s landscape, and we need to be just as quick at
    mitigation. If we are attempting to react to events only after they happen, the
    damage will already have been done and you will just have a log entry that tells
    you someone has done something malicious.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，内联缓解是缓解运行时事件的更好方法。威胁在今天的环境中发展迅速，我们需要同样迅速地进行缓解。如果我们只是在事件发生后再进行反应，损害已经发生，你也只能在日志中看到有人做了恶意操作。
- en: Zero-day vulnerability
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 零日漏洞
- en: 'Zero-day vulnerabilities take time to remediate, not only from a vendor side
    but from an organizational side as well. If you have the ability to remediate
    any vulnerability as you wait for an official patch, you should: every minute
    counts. KubeArmor monitors container activities for any suspicious activity. It
    can stop activities, without prior knowledge regarding the specific vulnerability
    or attack pattern.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 零日漏洞需要时间来修复，不仅是厂商方面的问题，组织方面也一样。如果你能够在等待官方补丁的同时修复任何漏洞，你应该这么做：每一秒钟都至关重要。KubeArmor
    会监控容器活动中的任何可疑行为，能够在没有事先了解具体漏洞或攻击模式的情况下停止这些活动。
- en: CI/CD pipeline integration
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CI/CD 管道集成
- en: KubeArmor easily integrates into **continuous integration and continuous deployment**
    (**CI/CD**) pipelines. Integrating KubeArmor into your pipelines automates security
    checks through the entire development and deployment lifecycle, delivering a safe
    and secure image.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 可以轻松集成到**持续集成和持续部署**（**CI/CD**）管道中。将 KubeArmor 集成到你的管道中可以通过整个开发和部署生命周期自动化安全检查，从而提供一个安全可靠的镜像。
- en: Robust auditing and logging
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强大的审计和日志记录
- en: Logging is very important, and KubeArmor includes comprehensive logs and audit
    trails of container activities. These logs can be used to report compliance, provide
    troubleshooting assistance, and assist in forensic examinations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录非常重要，KubeArmor 包含容器活动的全面日志和审计跟踪。这些日志可用于报告合规性、提供故障排除帮助，并协助进行取证检查。
- en: Enhanced container visibility
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强的容器可视化
- en: Visibility into container behavior simplifies identifying and responding to
    security incidents or abnormalities. KubeArmor finds what processes are running
    in the container and what they are accessing and connecting to.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对容器行为的可视化简化了识别和应对安全事件或异常的过程。KubeArmor 可以找到容器中正在运行的进程及其访问和连接的内容。
- en: Least privilege tenet adherence
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小权限原则遵循
- en: KubeArmor is based on the least amount of privilege concept, which is a base
    security principle. This ensures that containers possess only the necessary permissions
    and access levels required for their designated functions, consequently curtailing
    the attack surface and constraining potential damage stemming from a compromised
    container.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 基于最小权限原则，这是一个基本的安全原则。它确保容器仅拥有其指定功能所需的必要权限和访问级别，从而减少攻击面并限制因容器被攻破而可能带来的损害。
- en: Policy enforcement
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略执行
- en: Policies are at the heart of KubeArmor. They provide administrators with the
    ability to create detailed security policies for containers, fine-tuning the requirements
    for each different, unique workload. Want to block the ability of any container
    executing the SSH daemon? Make a simple policy using KubeArmor and no container
    will be able to execute the SSH daemon.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是 KubeArmor 的核心。它们使管理员能够为容器创建详细的安全策略，精细调整每个不同、独特工作负载的要求。想要阻止任何容器执行 SSH 守护进程？只需使用
    KubeArmor 创建一个简单的策略，任何容器都无法执行 SSH 守护进程。
- en: Staying in compliance
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持合规性
- en: To help you stay in compliance with standards like **CIS**, **NIST-800-53**,
    and **MITRE**, KubeArmor includes policies that will secure your clusters based
    on the defined best standards, all out of the box.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你保持符合 **CIS**、**NIST-800-53** 和 **MITRE** 等标准，KubeArmor 提供了一些策略，基于定义的最佳标准自动保护你的集群，开箱即用。
- en: Policy impact testing
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略影响测试
- en: Any policy can be tested before enforcing any settings. This will help you to
    create a policy that will not cause any workloads to have downtime due to a setting
    that may impact a running application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Multi-tenancy support
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is common for enterprises to run multi-tenant clusters. With multiple teams
    or applications sharing a Kubernetes cluster, you need to provide a secure environment
    to all of the users, stopping any attacks or effects that a workload in one namespace
    may have on another namespace. KubeArmor provides isolation and security among
    tenants by implementing unique policies at the container level. It’s an important
    tool for securing containerized applications, providing compliance with regulatory
    requirements, and providing a defence against a large spectrum of security threats.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s talk about how we can deploy KubeArmor in a cluster and how to use
    it to secure our workloads.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Cluster requirements for the exercises
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you learned in *Chapter 2*, KinD is a Kubernetes cluster that runs the components
    in containers. This nesting does mean that some add-ons like KubeArmor need to
    have some extra steps to function correctly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we suggest a new cluster. If you have a previous cluster with
    Vault installed already, you should delete that cluster and start over with a
    new one. If you do need to delete an existing cluster, you can execute `kind delete
    cluster --name cluster01` to delete it and then use the scripts to deploy a new
    cluster that includes Vault integration.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: To make it easier to deploy, we have included all the required scripts in the
    `chapter13/cluster` directory. To deploy a new cluster, execute `create-cluster.sh`
    in the `cluster` directory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: We also need Vault for one of the examples. If you want to run the example,
    you will need to add Vault to your cluster. We have provided an automated Vault
    deployment in the `chapter13/vault` directory called `deploy-vault.sh`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Once both have been executed, you will have a brand-new cluster integrated with
    Vault. It will take time for Vault to deploy fully, so please wait until all of
    the pods have been created to move on to deploying KubeArmor in the cluster.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Deploying KubeArmor
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can use KubeArmor on our KinD cluster, we will need to patch Calico
    and the kubearmor-relay deployment to work with KinD. AppArmor requires some changes
    for certain workloads to deploy and run correctly in a KinD cluster. In a standard
    cluster, these patches would not be required: and once they are deployed, KubeArmor
    will work as it would on a standard Kubernetes cluster.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: KubeArmor can be easily deployed using a single binary, called karmor, or via
    Helm charts. For the book exercises, we will use the karmor utility to install
    KubeArmor. Both deployment methods offer the same protection and configuration
    options, and once deployed, you interact with KubeArmor the same way, regardless
    of the deployment method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: We have included a script in the `chapter13` folder called `kubearmor-patch.sh`
    that will download karmor, patch Calico and the kubearmor-relay deployments, and
    deploy KubeArmor.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: KubeArmor installs on most Kubernetes clusters without any issues. Since we
    are using a cluster built on KinD, we need to make a few tweaks to allow AppArmor
    to work as expected. The scripts do this work for you. The majority of the fixes
    are to add an annotation to a few deployments, like the Calico Typha controller
    to unconfined mode. We will discuss the patched deployments and what unconfined
    provides in this section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The script downloads karmor and moves it to the `/usr/local/bin` directory on
    the host. This is the utility that we will use to install KubeArmor and interact
    with it once it has been deployed in the cluster.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Since KubeArmor leverages LSMs, all nodes require an installed LSM, like AppArmor,
    for KubeArmor to function. On most Ubuntu deployments, AppArmor is already deployed,
    but since our Kubernetes cluster is running containerized, AppArmor is not included
    in the image. To resolve this, we need to add AppArmor to our nodes: the script
    takes care of this by executing `docker exec` in each container that updates the
    apt repositories, installs AppArmor, and restarts containerd.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The next step in the script will patch the `calico-typha` deployment with an
    `AppArmor` policy that is unconfined. Running policies as unconfined means they
    don’t have an AppArmor profile assigned to them, or they are assigned a profile
    that does not impose any significant restrictions. This allows the process to
    operate with the standard Linux discretionary access controls, without additional
    restrictions from AppArmor.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, you wouldn’t need these patch deployments in a standard
    Kubernetes cluster, but since we are using KinD, we need to patch `calico-typha`
    to work correctly with KubeArmor running in our KinD cluster.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'With all the requirements and changes deployed, the script continues to install
    KubeArmor using karmor install. This will take a few minutes to deploy all the
    components and, during the deployment, you will see each step that karmor is executing:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will see that the installer creates a number of Kubernetes resources, including
    CRDs, a ServiceAccount, RBAC, Services, and Deployments. Once all resources have
    been created, it will verify the deployment was successful by telling you that
    `Your Cluster is Armored Up!`
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'After a successful deployment, you will have additional pods running in the
    `kubearmor` namespace, the controller, the relay, and a `kubearmor` pod, one for
    each of your nodes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can also deploy KubeArmor using Helm charts. If you want to know more about
    deploying KubeArmor with Helm, read more about it in KubeArmor’s Git repository
    at [https://github.com/kubearmor/KubeArmor/blob/main/getting-started/deployment_guide.md](https://github.com/kubearmor/KubeArmor/blob/main/getting-started/deployment_guide.md).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the pods has a specific function that is explained below:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**kubearmor**: A daemonset that deploys the `kubearmor` pod on each node in
    the cluster. It is a non-privileged DaemonSet with capabilities that allow it
    to monitor pods and containers and the host.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kubearmor-relay**: KubeArmor’s relay server collects all messages, alerts,
    and system logs generated by KubeArmor in each node, and then it allows other
    logging systems to simply collect those through the service of the relay server.
    The relay server plays a critical role in ensuring efficient and centralized security
    monitoring and data collection within Kubernetes environments, making it easier
    for organizations to maintain robust security postures in their containerized
    infrastructures.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kubearmor-controller**: Admission controller for KubeArmor policy management,
    including policy management, distribution, synchronization, and logging.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the chapter, we’ve opted for the karmor binary installation due to its ease
    of use, making it a convenient choice for deploying KubeArmor quickly. Additionally,
    we need the same karmor binary for the exercises throughout the chapter. This
    approach not only simplifies the learning process but also underscores the versatility
    and practicality of the karmor tool in managing KubeArmor deployments and operations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have KubeArmor deployed, we will discuss configuring logging before
    we start to create policies to secure our cluster.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Enabling KubeArmor logging
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, KubeArmor is not enabled to log events or alerts to `STDOUT`. Later
    in the chapter, we will go over how to watch logging events in the console interactively,
    which is useful for troubleshooting issues with policies in real time, but it
    is not an efficient way to log a history of policy events.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Most logging solutions made for Kubernetes will pick up logged events from `STDOUT`
    and `STDERROR`. By enabling KubeArmor’s logging options, you will have a history
    of events in your standard logging solution. Using these events, you can create
    alerts and produce a history of changes and events when a security audit occurs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'KubeArmor offers three events that can be logged:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '**Alert**: When a policy is violated, an event will be logged with information
    including the action, policy name, pod name, namespace, and more'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log**: Creates a log event when a pod executes a syscall, file access, process
    creation, network socket events, etc'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message**: Creates log entries generated by the KubeArmor daemon'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The process to enable logging is different between deployments of KubeArmor.
    We used the karmor executable to deploy, so we need to edit the deployment, adding
    two environment variables: one for standard logging, `ENABLE_STDOUT_LOGS`, and
    one for alerts, `ENABLE_STDOUT_ALERTS`. Both of these require a value of true
    to be enabled. To enable logging, we need to edit or patch the deployment of the
    relay server. This has already been done by our included script that deployed
    KubeArmor. The script will use a standard YAML file to patch the deployment. The
    patching file is shown below:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, using the patch file, the `script` executes a `kubectl patch` command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once patched, all of the enabled logs will be shown in the relay-server pod
    logs. An example of an event is shown below:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'From the example log entry, you can see that the information for the event
    contains everything that you need to know for the activity. It includes a review
    of the activity including:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The source namespace
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kubernetes host
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pod name
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process name
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The violated policy name
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operation
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resource that was acted on
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results of the action, allowed or denied
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By itself, this may not include additional information that you need to know
    the full activity from end to end. For example, it doesn’t include the user of
    the initial activity. Like many events in Kubernetes, you need to correlate events
    from multiple log files to create the full story of the executed activity. In
    this example, you would need to correlate the activity from the event that audited
    the initial `kubectl exec` command with the pod and time of the runtime violation
    that KubeArmor logged.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have KubeArmor configured, and we can get into creating and
    testing policies.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: KubeArmor and LSM policies
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned, KubeArmor is a tool that helps you create policies for Linux
    LSMs. Since it creates standard LSMs, any policy that you create and deploy will
    be stored on the node(s) where the OS stores LSM policies. Since we are using
    KinD, the nodes are running Ubuntu, which uses AppArmor as the LSM. AppArmor policies
    are stored in the `/etc/apparmor.d` directory on the host.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'The output below shows an example directory from a node that has had a few
    KubeArmor policies created:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you looked at any of the policies, you would see a standard AppArmor formatted
    policy. We aren’t going to go into the details of creating an AppArmor policy,
    but the output below shows an example of a policy created by KubeArmor:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It’s possible that your nodes may have policies that were not created using
    KubeArmor. In order to know what policies were created and managed by KubeArmor
    and what policies were not, you need to look at the first line of the policy.
    If the policy was created by KubeArmor, it will start with `## == Managed by KubeArmor
    == ##`, and policies that do not start with this line were not created by KubeArmor.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s move on to the next section, on creating a `KubeArmorSecurityPolicy`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Creating a KubeArmorSecurityPolicy
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s time to create some policies! When KubeArmor is deployed, it creates three
    Custom Resource Definitions and one of those is `kubearmorpolicies.security.kubearmor.com`,
    which is used to create new policy resources.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Let’s jump right into an example policy. You do not need to deploy this to your
    cluster; it’s being used to show an example policy.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to block any attempted access to create a file in the `/bin` directory
    of our containers in the `demo` namespace, the format of this policy is shown
    below:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Breaking down this policy, we can see that it’s using the `security.kubearmor.com/v1`
    API and it’s a KubeArmorPolicy type. The metadata section has common options,
    naming the object `block-write-bin` in the `demo` namespace.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'The `spec` section is where we actually start to create a new policy. There
    are a number of options available to you for creating policies. You can learn
    about all of the options on the KubeArmor website: [https://docs.kubearmor.io/kubearmor/documentation/security_policy_specification](https://docs.kubearmor.io/kubearmor/documentation/security_policy_specification).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The action `spec` allows you to define what the policy enforces. The options
    are `Block`, `Allow`, and `Audit`: each of the options is described in the table
    below.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '| **Available Action** | **Description** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| `Block` | Tells KubeArmor to block the actions that are included in the policy
    (default if no action is provided) |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| `Allow` | Tells KubeArmor to allow the actions that are included in the policy
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| `Audit` | Tells KubeArmor to only audit the actions of the policy. The actions
    on the policy will be allowed, but in our example, we would receive a logged event
    when someone creates a file under the `/bin` directory. This is handy for testing
    how a policy will affect a workload in the cluster. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: 'Table 13.1: Available actions for policies'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: KubeArmor operates on the principle of enforcing the least permissive access.
    When you specify the allow action in a policy, it generates an allow list that
    permits access exclusively to the object(s) specified within the policy. For instance,
    if you were to establish an `allow` policy for a file named `demo/allowed-file`,
    any process within the container would have permission to access that particular
    file. All other files accessed within the container would trigger an audit event
    because they do not belong to the allowed list.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: You might be questioning the example, where if you set up an allow policy and
    someone tries to read a different file, it won’t reject the request but will instead
    log the access for auditing purposes. The default security posture, within an
    allow policy, pertains to how it manages access attempts not listed in the allowed
    entries. By default, KubeArmor’s security posture is set to audit mode.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: It’s crucial to bear in mind that when you establish an allow policy, any access
    requests that would typically be denied will not face denial; instead, they will
    merely trigger an audit alert. As a result, if you configure an allow rule to
    restrict access to a specific file, all other files will remain accessible.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'The default posture behavior can be changed at the global level or on a per
    namespace level. To make the global default posture block, instead of audit, you
    need to edit the KubeArmor config, which is stored in a ConfigMap called `kubearmor-config`
    in the `kubearmor` namespace. In the config, you can set the default security
    posture for each option, file, network, and capabilities:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Depending on your cluster configuration and the logic design of a cluster,
    you may want to change the default posture on specific namespaces. To set the
    policy on a namespace, you need to add an annotation of `kubearmor-file-posture=<value>`.
    If we wanted to add a policy to an existing demo namespace, we would just need
    to run `kubectl annotate`, as shown below:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you were creating a new namespace using a manifest, you would just add the
    annotation to the manifest before applying the file to create the namespace.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: After defining the policy action, we need to add what objects we want to block,
    allow, or audit.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four objects that we can create policies for. They are:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Process
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capabilities
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The KubeArmor website has documentation on the policies and options located
    at [https://docs.kubearmor.io/kubearmor/documentation/security_policy_specification](https://docs.kubearmor.io/kubearmor/documentation/security_policy_specification).
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In our example, our goal is to prevent any form of write access within the `/bin`
    directory. To achieve this, we will utilize the `file` object. Following the object
    declaration, you specify a `match` condition that will trigger the policy action.
    In this instance, we’ve configured the `matchDirectories` action specifically
    for the `/bin` directory, indicating to KubeArmor that the policy’s evaluation
    should only occur if the action is within that directory.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Continuing, there are optional settings for `readOnly` and `recursive`. In our
    scenario, we have enabled both. When `readOnly` is set to true, it permits the
    reading of any file located under `/bin`, but any other actions will be denied.
    Enabling the `recursive` option instructs KubeArmor to assess both the `/bin`
    directory and all of its subdirectories.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can define the message option, which will add a custom message
    in the KubeArmor logs when the policy has been triggered. In our example, we added
    the message option to add “**Alert! An attempt to write to the /bin directory
    denied.**” when an attempt is made to do anything other than read a file under
    the directory.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering about the allow action and how we said it creates an allow
    list, allowing only access to the objects in the policy, and denying access to
    every other file in the container. The example of a single file isn’t a great
    example for the real world, but it does explain what you granted access to and
    what was denied by allow policies. An allow policy will lock down a container
    tightly when used correctly. When used incorrectly, your application would likely
    crash, being denied access to a file not in the allowed list. You can imagine
    that creating an allow list for an app could require a large number of objects,
    many of which would be a challenge to find on your own.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use a real-world example policy to close out this section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Foowidgets want to secure their secrets. They have created a policy that all
    secrets must be stored in an external secret manager like Vault. As we discussed
    in the secrets chapter, you can read your secret in from Vault without having
    a base64-encoded secret in the namespace. A lot of people assume this secures
    your secret, but they overlook that someone will be able to exec into the container
    and read most files, including files that store secrets.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: How do we enhance the security of our secrets, even using an external secrets
    manager like Vault? The answer is KubeArmor!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: We can address Foowidgets’ requirement by creating a policy that will allow
    only the required running process access to the file that contains the secret,
    while any other process will be denied.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: In the `chapter13/nginx-secrets` directory, there is a script called `create-nginx-vault.sh`,
    which will create an NGNIX webserver that will display a secret file and the contents
    when you open a webpage path, `/secrets/myenv`. The secret that is shown on the
    page is pulled down from Vault and mounted in the pod using a volume at `/etc/secrets/myenv`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute the script, the last line will show you the **nip.io** URL
    for the webserver. Open the URL in any browser, or curl the `http://secret.<nip.io>/secrets/myenv`
    URL to prove that the secret shows in the output. You should see output similar
    to the below:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_13_05.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: NGINX showing contents of secret file'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Verifying that the container is working as expected, we can `exec` into the
    container and attempt to read the secret file using `cat`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The secret is mounted in the pod at `/etc/secrets` in the `myenv` file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will output the contents of the file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Hold on! I thought that employing an external secret manager would ensure the
    security of Kubernetes secrets. Although it may not store the data in an easily
    discoverable `Secret` within the namespace, an individual with container execution
    access can still retrieve the secret.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: This issue is one of the shortcomings of systems like Vault; simply using Vault
    doesn’t necessarily guarantee the security of the secret.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this with a real-world scenario, let’s consider a requirement
    by our company, Foowidgets. They want to restrict secret access exclusively to
    the processes that require access to the secret. This can be accomplished by creating
    a new KubeArmor policy that permits only the application to access the file containing
    the secret. In our example container, we intend to grant the NGINX process permission
    to read the secret file while preventing other processes from doing so.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we have created an example policy file called `nginx-secrets-block.yaml`.
    This will deploy into the `my-ext-secret` namespace:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To show the policy in action, we have included a script called `redeploy-nginx-vault.sh`
    in the `chapter13/nginx-secrets` directory, which will delete the previous NGINX
    deployment and then create a new deployment with the KubeArmor policy to secure
    the Vault secret used by NGINX.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Execute the script and wait until the new deployment and policy have been created.
    It’s important that we confirm that the outcome is what we expect from the new
    policy. To verify the policy, we will attempt to access the secret by executing
    `kubectl exec -it nginx-secrets -n my-ext-secret -- bash` to enter the pod.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Once in the pod, we can attempt to view the secret by using `cat`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You’ll notice that access to the file is no longer allowed. KubeArmor will
    intercept the request and, based on the policy, refuse access to the `/etc/secrets/myenv`
    file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Take note that even though you have root privileges within the container, you
    can’t access the `myenv` file in the `/etc/secrets` directory. The policy blocks
    any access not explicitly allowed to the directory or its files.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: So far, everything seems to be going well. However, now we must verify the website
    to ensure that the secret information still appears. If the site displays the
    same content as before implementing our policy, it demonstrates that the secret
    is allowed to be read by the NGINX binary. To verify this, navigate to the same
    URL you previously used to test the site, either by browsing or using the `curl`
    command. If you still have the same browser window open, simply refresh it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'The screenshot below verifies that the website is functioning correctly and
    continues to display the value stored in the `myenv` file in the `/etc/secrets`
    directory. This confirms that the NGINX binary has the necessary access to the
    secret file:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_13_06.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: NGINX can still read secret'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: KubeArmor simplifies the creation of LSM policies for both developers and operators.
    The potential applications are endless, granting you the capability to enhance
    the security of workloads down to the granularity of individual files or processes.
    Now that we’ve covered the process of policy creation, let’s proceed to explore
    the primary tool that you’ll employ to engage with KubeArmor.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Using karmor to interact with KubeArmor
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We installed KubeArmor using the karmor utility. Along with installing and uninstalling
    KubeArmor in a cluster, it is used for a number of other actions. The table below
    is an overview of the main options that you should understand. Each one will be
    explained in detail in its own section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '| **Options** | **Description** |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| `Install` | Installs KubeArmorKubeArmor in a clusterKubeArmor |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| `Logs` | Provides an interactive method to view logs, or to send the logs
    to a file |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: '| `Probe` | Lists the support features for the cluster |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
- en: '| `profile` | Runs an interactive utility that displays the process, file,
    network, and syscalls that KubeArmor has observed |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| `recommend` | Creates a directory that contains recommended policies that
    can be deployed in a cluster. This will download additional containers to create
    the recommendations. It could take some time depending on the number and size
    of the running containers. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| `selfupdate` | Updates the `karmor` CLI |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: '| `summary` | Shows observations from the discovery engine |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
- en: '| `sysdump` | Used to collect a system dump to help troubleshooting |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '| `uninstall` | Uninstalls KubeArmor from the cluster |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '| `version` | Shows the version of the karmor binaryKubeArmor |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
- en: '| `Vm` | Used for commands that can be used against VMs that run with `Kubevirt`,
    which runs `kvmservices` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: 'Table 13.2: karmor command options'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The list may make KubeArmor look like it doesn’t have a lot of options, but
    most of the options are incredibly powerful and some will take time to run in
    larger clusters. In the next sections, we will explain the karmor options and
    what they provide to secure your cluster.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: karmor install and uninstall
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you would imagine, the `karmor install` command will deploy KubeArmor into
    the cluster from your current `kubeconfig` file, while the `karmor uninstall`
    command will remove KubeArmor from the cluster.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: We do need to call out that `karmor uninstall`, by default, will remove KubeArmor
    from the cluster, but it will leave any LSM policies that were created on the
    hosts in an inactive state. To fully remove KubeArmor from the cluster, including
    all created policies, you need to add the `--force` flag to the `uninstall` command.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: karmor probe
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The probe option will list the KubeArmor features in the current cluster.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: When you check for the supported probes, karmor will output information including
    each node and its active LSM and the default posture of each namespace and pod.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: karmor profile
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: KubeArmor’s profile provides you with an interactive console to view what processes,
    files, network connections, and syscalls are in use. The screen below shows an
    abbreviated output from a probe with the **File** tab selected.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_13_07.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: karmor profile output'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: By default, a probe will output information for all namespaces. If you have
    clusters with a lot of namespaces and pods, you can limit the output to a single
    namespace or certain pods.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: To limit the output to a single namespace, add the option `-n` or `--namespace
    <namespace to prove>`, and to limit the output to just a pod, use `-p` or `--pod
    <pod name to probe>`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see this in action, let’s say that you wanted to watch a new
    namespace called `demo` for activity. You would execute the recommend command
    and add `-n demo`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'On the host, execute the probe command shown below:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You may not see any activity under some tabs. The profile command needs to have
    activity to show and if there is no activity for any of the watched events, they
    will not show any data. You will see a blank list until KubeArmor sees activity
    and creates new entries, as shown in *Figure 13.8*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_13_08.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: KubeArmor’s profile console'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Open another connection to the host, so we can create a new NGINX deployment.
    There is a script in the `chapter13/nginx` directory called `ngnix-ingress.sh`
    that will create a new namespace called demo with an NGINX deployment and an ingress
    rule. Execute the script and, at the end, it will show you the ingress URL to
    use.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created a deployment, your other terminal should show activity
    in the **Process** tab, as shown in *Figure 13.9*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_13_09.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: KubeArmor’s profile console'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: This will populate events in the **Process** tab as the NGINX pod starts up
    and processes are started. In your other window, you will see the profile update,
    in real time, with the processes that started in the demo namespace.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: KubeArmor’s probe is a powerful tool that provides information that would otherwise
    be very challenging to collect.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: karmor recommend
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `recommend` command is to provide security policy recommendations based
    on established industry compliance standards and attack frameworks like CIS, MITRE,
    NIST, STIGs, and various others. All of the workloads specified in the recommend
    command will be tested against any policy templates included with KubeArmor.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_13_10.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: KubeArmor recommend policies'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Since each pod and container are evaluated, you have the option to filter the
    execution to target not only the cluster but by namespace, container image, or
    pod. An example output of `karmor recommend` running is shown in *Figure 13.11*:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_13_11.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.11: karmor recommend output'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'From the output, you can see that karmor will pull the image for each container
    to test against the policies. All policies that are created by karmor are, by
    default, saved in a directory called out in the current working directory. You
    can change where the policies will be created by adding the `-o` or the `--output`
    switch to the recommend command. Since the recommendations are broken down by
    each action, you may generate a large number of files. To show an example, we
    run a recommend command against our KinD cluster’s `kube-system` namespace, which
    generates the directory structure shown below:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Along with a directory for each deployment, you will see a `report.txt` file
    that contains all recommended policies for various standards, including NIST,
    MITRE, PCI_DSS, CIS, etc. We will discuss the report and its options in a later
    section. For now, we want to focus on the created policies.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the first directory in the list, which contains
    policies for the `core-dns` deployment in the `kube-system namespace`. As you
    can see from the output, 16 policies were created by the `recommend` command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you look at the filenames, you can tell what type of action and process
    each policy uses. For example, let’s look at the `registry-k8s-io-coredns-coredns-v1-10-1-write-etc-dir.yaml`
    `policy`. From the filename, we can see that this policy was created to add an
    action to writing in the `/etc` directory. Looking into the file, we will see
    that this policy contains a block action on directories in `/etc` and it also
    locks down `/etc` to a read-only state, for anything that matches the label `k8s-app=kube-dns`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are a few added fields in this policy that we haven’t discussed previously,
    namely the severity and the tags. Unlike other tools that may add severity to
    a triggered event, KubeArmor allows you to set your own severity for policies.
    When you create a policy, you can assign it a severity rating from 1 to 10, allowing
    you to create your own rating based on your organizational requirements.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The tags section was generated by the recommend command. By default, when you
    run a recommendation, it will test all of the objects against all of the included
    hardening policies, including MITRE TTPs, STIGs, NIST, and CIS. The policies that
    are created are based on the standards supplied during the recommendation collection.
    If you don’t specify any policies to check, karmor will create policies for all
    standards, including policies that you may or may not need.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on your organization and security requirements, you can limit the
    hardening policies to only the policies that you want to include. This is done
    by adding either the `-t` or `--tag` flags to the recommend command, followed
    by the standard or standards. For example, if we wanted to run a recommend against
    the `kube-system` namespace and only include the CIS and PCI-DSS standards, we
    would execute:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Like all other recommend commands, this will create an `out` directory in the
    working directory with policies and a `report.txt`. If you took a look at the
    report, you would see a list of recommended actions around PCI-DSS and CIS standards
    for each pod. The figure below is an abbreviated example of a `report.txt` from
    the recommend command we ran against `kube-system`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_13_12.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.12: Recommend example for NIST and CIS'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Since we added tags to our command, karmor only created policies that are required
    to meet the standards for NIST and CIS. This will create fewer policies than running
    without any tags since it will only generate policies based on the specified tags
    versus all standards if you do not supply a tag.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'The last example we will discuss is using recommend to create policies and
    a report for an image that is not running in the cluster. So far, we have run
    recommendations against objects in the cluster, but KubeArmor offers the ability
    to create policies based on any container image. To run a recommendation against
    an image, you need to add the `-i` or `--image` to your command. For example,
    we want to run karmor against the `bitnami/nginx` image:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will pull down the image and run it against all of the included KubeArmor
    policies. The policies will be created in the `out` directory, just like the previous
    examples:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we ran the same test and included the tag for only the CIS policies, we
    would generate fewer policies:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As demonstrated, the recommend command empowers you to increase the security
    of your workloads in accordance with any standards required by your organization,
    government regulations, or other pertinent criteria.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: karmor logs
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The logs option provides a real-time log of KubeArmor’s activities, which is
    beneficial when you want to watch events without seeing hundreds of other logged
    activities. When you execute a karmor log, a logger will start up and watch for
    KubeArmor activity. Since it’s a real-time log, it will run interactively in your
    shell, waiting for activity:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As events are observed by KubeArmor, they will be shown in the output. For
    example, we create a policy that will block any write attempts to the `/bin` directory
    in all containers in the demo namespace. We exec into the container and attempt
    to create a file called `test` in the directory. As we can see in the output below,
    the attempt was denied:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since this was an action that KubeArmor had a policy for, it will also log
    the activity in the session running the karmor logs. The logs contain a lot of
    information. Below is an example of a logged event:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By default, the log output is set to text, which may be difficult to sort through
    when there are a lot of logged events. If you would prefer the logs to be in JSON
    format, you can add the flag `--json` to the `logs` command. The format that is
    best to use for your requirements usually depends on the system you are using
    for storing your logged events. In most cases, JSON is the format preferred by
    most logging systems.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'To show the difference, we execute the same test from the previous log entry,
    an attempt to create a file under `/bin`. This will change the output from text
    to JSON, as shown below:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The decision to use text or JSON is usually dependent on the tools you plan
    to use to parse the data. JSON is a popular format for logging since it makes
    parsing the data much easier than using a text format.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: You may be looking at the logging abilities using the karmor log and wondering
    how useful it is to have the output going to the console only.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: As a default behavior, the logs are directed to `stdout`. While real-time log
    viewing is valuable for monitoring events as they happen, it’s not always feasible
    to continuously observe events. It is more common to send your logs to a file,
    which can then be viewed or sent to an external system for processing. KubeArmor
    offers the flexibility to modify your log output preferences by using the `--logPath`
    flag. This flag lets you specify the desired destination for the log file, enabling
    you to redirect log data to a designated file location.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'When you specify the path of the log file, it must include the entire path
    and filename that you want to use. The `logPath` option can be used with other
    options, like setting the log format to JSON. The example command below will send
    the logs to the current user’s home directory using the filename `karmor.logs`
    in JSON format:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you specify a new directory in `logPath`, it must be created before sending
    any logs; KubeArmor will not create the directory for you. If you fail to create
    the directory before logging, you will receive an error on the log output screen
    and no events will be logged.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'When the first event is caught by KubeArmor, it will create the file and will
    continue to collect data until you stop logging:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Like other karmor options, logging will watch the entire cluster by default,
    which may generate a lot of events that may make it difficult to find the events
    you really need to see. Instead of logging the entire cluster, you can filter
    the logs by adding a flag to the `logs` option. The available flags include:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flag** | **Description** |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
- en: '| `--labels` | Filter the logs by a label |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
- en: '| `--namespace` | Filter the logs by namespace |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
- en: '| `--pod` | Filter the logs by pod |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
- en: 'Table 13.3: Limiting logs to certain objects'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the scope of the objects being logged offers the distinct advantage
    of tailoring the log data to focus exclusively on the specific object(s) you require
    detailed information for. By implementing this approach, you can significantly
    enhance the precision and relevance of the logged data, ensuring that it directly
    aligns with your specific monitoring, analysis, and troubleshooting needs. Limiting
    the objects being logged enables you to streamline your monitoring efforts, making
    it more efficient and effective in providing insights into the targeted object(s)
    while reducing the noise and clutter caused by unnecessary log entries.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: karmor vm
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Did you know that with Kubernetes you can run virtual machines? These VMs are
    deployed and managed differently than what you may be used to when working with
    hypervisors from VMware and Microsoft. Instead of running an OS straight on the
    hypervisor, KubeVirt VMs actually run inside of a container. They look like a
    standard pod running any other Docker image, but instead of a microservice, it’s
    an entire operating system supporting both Windows and Linux.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: KubeVirt is a complex topic and we can’t cover it in this section alone. You
    can learn more about KubeVirt on their website, [https://kubevirt.io/](https://kubevirt.io/).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The KubeArmor team saw the need to expand runtime security to include support
    for VMs running with KubeVirt. This is a powerful feature for organizations that
    run VMs in Kubernetes, extending the same security that KubeArmor provides for
    containers to VMs.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at strengthening the security of our runtime environment,
    enhancing your overall security posture. It’s a common misconception that an organization’s
    clusters are secured since many of them tend to overlook the content running within
    containers or the implications of a user connecting to a running pod using `kubectl
    exec`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also described in detail how one of the most effective approaches
    to container security involves tightly controlling the container’s processes,
    exclusively allowing the execution of only the necessary processes while denying
    access to all other files. By leveraging a tool like KubeArmor, you can grant
    access to specific files from a restricted set of binaries, blocking access to
    and securing all other processes.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following are LSMs?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accuknox
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AppArmor
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: SELinux
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: LSMLinux
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: LSMs and eBPF provide the same features.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which karmor option provides real-time information in an easy-to-see console?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Monitor
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Trace
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Profile
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Probe
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is NOT a feature provided by KubeArmor to enhance security
    in Kubernetes clusters?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restricting process execution
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: File access control
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Network traffic encryption
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating security policies
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: b - AppArmor
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b - False
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c - Profile
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c - Network traffic encryption
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our book’s Discord space
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join the book’s Discord workspace for a monthly *Ask Me Anything* session with
    the authors:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/K8EntGuide](https://packt.link/K8EntGuide)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code965214276169525265.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
