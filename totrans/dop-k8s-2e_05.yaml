- en: Cluster Administration and Extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we familiarized ourselves with basic DevOps skills and
    Kubernetes objects. This included looking at many areas, such as how to containerize
    our application and deploy our containerized software into Kubernetes. It is now
    time to gain a deeper insight into Kubernetes cluster administration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing namespaces to set administrative boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using kubeconfig to switch between multiple clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic admission control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes **Custom Resources Definition** (**CRD**) and controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While minikube is a fairly simple environment, we will use the **Google Kubernetes
    Engine** (**GKE**) in this chapter. For cluster deployment in GKE, please refer
    to [Chapter 11](d4de05e3-eb24-4e8e-bfd3-e68819b5e66c.xhtml), *Kubernetes on GCP*.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already learned about Kubernetes namespaces in [Chapter 3](a5cf080a-372a-406e-bb48-019af313c676.xhtml),
    *Getting Started with Kubernetes*, which are used to divide the resources from
    a cluster into multiple virtual clusters. Namespaces make each group share the
    same physical cluster with isolation. Each namespace provides the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A scope of names; the object name in each namespace is unique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Policies to ensure trusted authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to set up resource quotas for resource management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's learn how to use context to switch between different namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Context** is the concept of the combination of cluster information, a user
    for authentication, and a namespace. For example, the following is the context
    information for one of our clusters in GKE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use the `kubectl config current-context` command to list the current
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To list all config information, including contexts, you could use the `kubectl
    config view` command. To check out what context is currently in use, use the `kubectl
    config get-contexts` command.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to create a context. As we did in the preceding example, we''ll
    need to set a user and cluster name for the context. If we don''t specify those,
    the empty value will be set. The command to create a context is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple contexts can be created in the same cluster. The following is an example
    of how to create a context for `chapter5` in my GKE cluster, `gke_devops-with-kubernetes_us-central1-b_cluster`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Switching the current context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We could switch the context using the `use-context` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After the context is switched, every command we invoke via `kubectl` is under
    the `chapter5` context. There is no need to explicitly specify the namespace when
    listing your pods.
  prefs: []
  type: TYPE_NORMAL
- en: Kubeconfig
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubeconfig is a file that you can use to switch multiple clusters by switching
    context. We can use `kubectl config view` to view the setting and the `kubectl
    config current-context` command to check the context you''re currently using.
    The following is an example of a GCP cluster in a `kubeconfig` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we learned previously, we can use `kubectl config use-context CONTEXT_NAME` to
    switch the context. We can also specify `kubeconfig` files according to the `$KUBECONFIG` environment
    variable to determine which kubeconfig files are used. In this way, config files
    could be merged. For example, the following command will merge `kubeconfig-file1`
    and `kubeconfig-file2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We could also use `kubectl config --kubeconfig=<config file name> set-cluster
    <cluster name>` to specify the target cluster in the target `kubeconfig` file.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `kubeconfig` file is located at `$HOME/.kube/config`. This file
    will be loaded if none of the preceding settings are set.
  prefs: []
  type: TYPE_NORMAL
- en: Service account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Kubernetes, there are two kinds of user account: **service account** and
    **user account**. All the requests to the API server are sent either by a service
    account or a user account. Service accounts are managed by the Kubernetes API.
    In contrast, user accounts are not managed and stored in Kubernetes. The following
    is a simple comparison of service and user accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Service account** | **User account** |'
  prefs: []
  type: TYPE_TB
- en: '| **Scope** | Namespaced | Global  |'
  prefs: []
  type: TYPE_TB
- en: '| **Used by** | Processes | Normal user |'
  prefs: []
  type: TYPE_TB
- en: '| **Created by** | API server or via API calls | Administrators, not by API
    calls |'
  prefs: []
  type: TYPE_TB
- en: '| **Managed by** | API server | Outside the cluster |'
  prefs: []
  type: TYPE_TB
- en: 'By default, a Kubernetes cluster creates different service accounts for different
    purposes. In GKE, there are a bunch of service accounts that have been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Kubernetes will create a default service account in each namespace, which will
    be used if no service account is specified in pod specification during pod creation.
    Let''s take a look at how the default service account acts for our `chapter5`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the service account is basically using mountable secrets as
    tokens. Let''s dig into what content is inside the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The service account secret will be automatically mounted to the `/var/run/secrets/kubernetes.io/serviceaccount`
    directory. When the pod accesses the API server, the API server will check the
    cert and token to do the authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifying `automountServiceAccountToken: false` in the service account or
    pod specification could disable the auto-mount service account secret.'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and authorization are important components in Kubernetes. Authentication
    verifies users and checks that the user is who they claim to be. Authorization,
    on the other hand, checks what permission levels users have. Kubernetes supports
    different authentication and authorization modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an illustration that shows how the Kubernetes API server processes
    access control when it receives a request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ad4c779-ce36-4ace-ac4d-54fcaaaa50d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Access control in the Kubernetes API server
  prefs: []
  type: TYPE_NORMAL
- en: When the request goes to the API server, first it establishes a TLS connection
    by validating the clients' certificate with the **Certificate Authority** (**CA**)
    in the API server. The CA in the API server is usually at `/etc/kubernetes/`,
    and the clients' certificate is usually at `$HOME/.kube/config`. After the handshake,
    it moves into the authentication stage. In Kubernetes, authentication modules
    are chain-based. More than one authentication module can be used here. When receiving
    the request, Kubernetes will try all the authenticators one by one until it succeeds.
    If the request fails on all authentication modules, it will be rejected with an HTTP
    401 Unauthorized error. If not, one of the authenticators verifies the user's
    identity and the requests are authenticated. At this point, Kubernetes authorization
    modules come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization modules verify whether or not the user has sufficient permissions
    to perform the action that they have requested to perform. Authorization modules
    are also chain-based. The authorization request needs to pass through every module
    until it succeeds. If the request fails for all modules, the requester will get
    a HTTP 403 Forbidden response.
  prefs: []
  type: TYPE_NORMAL
- en: Admission control is a set of configurable plugins in an API server that determine
    whether a request is admitted or denied. At this stage, if the request doesn't
    pass through one of the plugins, then it is denied immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, a service account is token-based. When you create a service account
    or a namespace with a default service account, Kubernetes creates the token, stores
    it as a secret that is encoded by Base64, and mounts the secret as a volume into
    the pod. Then, the processes inside the pod have the ability to talk to the cluster.
    The user account, on the other hand, represents a normal user who might use `kubectl`
    to directly manipulate the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Service account token authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create a service account, a signed bearer token will be automatically created
    by the Kubernetes service account admission controller plugin. We can use that
    service account token to authenticate a user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try creating a service account named `myaccount` in the `chapter5` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Chapter 9](acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml), *Continuous Delivery*,
    in the example in which we demonstrated how to deploy `my-app`, we created a namespace
    named `cd`, and used `get-sa-token.sh` script ([https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/blob/master/chapter9/9-2_service-account-for-ci-tool/utils/push-cd/get-sa-token.sh](https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/blob/master/chapter9/9-2_service-account-for-ci-tool/utils/push-cd/get-sa-token.sh))
    to export the token for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we created a user named `mysa` via the `kubectl config set-credentials
    <user> --token=$TOKEN` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set the context to bind with a user and namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we set our `myctxt` context as the default context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we send a request, the token will be verified by the API server, which
    checks whether the requester is eligible and is what it claims to be. Let''s see
    if we can use this token to list the pods in the default namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Seems like something went wrong! This is because we haven't granted any permissions
    to this service account yet. We'll learn how to do this using `Role` and `RoleBinding` later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: User account authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several implementations for user account authentication. This includes
    anything from client certificates, bearer tokens, and static files to OpenID connect
    tokens. You can choose more than one as authentication chains. Here, we'll demonstrate
    how client certificates work.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 9](acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml), *Continuous Delivery*,
    and earlier in this chapter, we learned how to export certificates and tokens
    for service accounts. Now, let''s learn how to do this for a user. Let''s assume
    that we are still inside the `chapter5` namespace, and we want to create a user
    for our new DevOps member, Linda, who will help us do the deployment for `my-app`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll generate a private key via OpenSSL ([https://www.openssl.org](https://www.openssl.org)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create a certificate sign request (`.csr`) for Linda:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, `linda.key` and `linda.csr` should be located in the current folder. To
    let the API server validate Linda's certificate, we'll need to find the cluster
    CA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In minikube, the root CA is under `~/.minikube/`. For other self-hosted solutions,
    it's normally under `/etc/kubernetes/`. If you use `kops` to deploy the cluster,
    the location is under `/srv/kubernetes`, and you will find the path in the `/etc/kubernetes/manifests/kube-apiserver.manifest`
    file. In GKE, the cluster root CA is non-exportable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have `ca.crt` and `ca.key` under the current folder; by using
    these, we could generate a new CA for the user. By using the `-days` parameter,
    we can define the expired date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have cert signed by our cluster, we could set a user in the cluster,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember the concept of context: this is the combination of cluster information,
    a user for authentication, and a namespace. Now, we''ll set a context entry in
    `kubeconfig`. Remember to replace your cluster name, namespace, and user in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, Linda should have zero permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Linda can now pass the authentication stage as Kubernetes knows she is Linda.
    However, to give Linda permission to do the deployment, we need to set up the
    policies in authorization modules.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes supports several authorization modules. At the time of writing this
    book, it supports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: ABAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RBAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webhook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute-Based Access Control** (**ABAC**) was the major authorization mode
    before **Role-Based Access Control** (**RBAC**) was introduced. Node authorization
    is used by kubelet to make a request to the API server. Kubernetes supports the
    webhook authorization mode to establish a HTTP callback with an external RESTful
    service. It''ll do a POST whenever it faces an authorization decision. Another
    common way to do this is by implementing your in-house module by following along
    with the pre-defined authorizer interface. For more implementation information,
    refer to [https://kubernetes.io/docs/admin/authorization/#custom-modules](https://kubernetes.io/docs/admin/authorization/#custom-modules).
    In this section, we''ll walk though how to leverage and utilize RBAC in Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: Role-based access control (RBAC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Kubernetes 1.6, RBAC is enabled by default. In RBAC, the admin creates
    several `Roles` or `ClusterRoles` that define the fine-grained permissions that
    specify a set of resources and actions (verbs) that roles can access and manipulate.
    After that, the admin grants the `Role` permission to users through `RoleBinding`
    or `ClusterRoleBindings`.
  prefs: []
  type: TYPE_NORMAL
- en: If you're running minikube, add `--extra-config=apiserver.Authorization.Mode=RBAC`
    when using `minikube start`. If you're running a self-hosted cluster on AWS via
    kops, add `--authorization=rbac` when launching the cluster. Kops launches an
    API server as a pod; using the `kops edit cluster` command could modify the `spec`
    of the containers. EKS and GKE support RBAC natively.
  prefs: []
  type: TYPE_NORMAL
- en: Roles and ClusterRoles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Role` in Kubernetes is bound within a namespace. A `ClusterRole`, on the
    other hand, is cluster-wide. The following is an example of `Role`, which can
    perform all operations, including `get`, `watch`, `list`, `create`, `update`,
    `delete`, and `patch`, on the `deployments`, `replicasets`, and `pods` resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In GKE, the admin doesn't have permission to create a role by default. Instead,
    you must grant the user access to this with the following command: `kubectl create
    clusterrolebinding cluster-admin-binding --clusterrole cluster-admin --user ${USER_ACCOUNT}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `apiGroups`, an empty string `[""]` indicates the core API group. The API
    group is part of the RESTful API call. The core indicates the original API call
    path, such as `/api/v1`. The newer REST path has the group name and API version
    in it, such as `/apis/$GROUP_NAME/$VERSION`. To look up API groups you''d like
    to use, check out API references at [https://kubernetes.io/docs/reference](https://kubernetes.io/docs/reference).
    Under `resources`, you could add the `resources` you''d like to grant access to,
    and under `verbs`, you could list a set of actions that this role could perform.
    Let''s get into a more advanced example for `ClusterRoles`, which we used in [Chapter
    9](acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml), *Continuous Delivery*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`ClusterRole` is cluster-wide. Some resources don''t belong to any namespace,
    such as nodes, and can only be controlled by `ClusterRole`. The namespaces it
    can access depends on the `namespaces` field that it associates with `ClusterRoleBinding`.
    In the preceding example, we granted the permission to allow this role read and
    write `deployments`, `replicasets`, and `ingresses` in both extensions and apps
    groups. In the core API group, we only grant access for namespace and events,
    as well as all permissions for other resources, such as pods and services.'
  prefs: []
  type: TYPE_NORMAL
- en: RoleBinding and ClusterRoleBinding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `RoleBinding` binds a `Role` or `ClusterRole` to a list of users or service
    accounts. If a `ClusterRole` is bound with a `RoleBinding` instead of a `ClusterRoleBinding`,
    it will only be granted the permissions within the namespace where `RoleBinding` was specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the `RoleBinding` spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: ­In this example, we bind a `Role` with a user through `roleRef`. This grants
    Linda the permission that we defined in the `devops-role`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a `ClusterRoleBinding` is used to grant permission in all
    namespaces. Here, we''ll leverage the same concept from [Chapter 9](acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml), *Continuous
    Delivery*. First, we created a service account named `cd-agent`, then created
    a `ClusterRole` named `cd-role`, and a `ClusterRoleBinding` for `cd-agent` and
    `cd-role`. We then used `cd-agent` to do the deployment on our behalf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cd-agent` is bound with a `ClusterRole` via `ClusterRoleBinding`, so it
    can have the permission that''s specified in `cd-role` across namespaces. Since
    a service account is created in a namespace, we''ll need to specify its full name,
    including its `namespace`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`ClusterRoleBinding` also supports `Group` as a subject.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to get pods again via `devops-context`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We are no longer getting a forbidden response. What about if Linda wants to
    list namespaces—is this allowed?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The answer is no, since Linda has not been granted permission to list namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Admission control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Admission control takes place before Kubernetes processes the request and after
    authentication and authorization is passed. It''s enabled when launching an API
    server by adding the `--admission-control` parameter. Kubernetes recommends having
    the following plugins within the cluster if the cluster version is greater than
    or equal to 1.10.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The following sections introduce these plugins and why we need them. For the
    latest information about supported admission control plugins, please visit the
    official documentation: [https://kubernetes.io/docs/admin/admission-controllers](https://kubernetes.io/docs/admin/admission-controllers).
  prefs: []
  type: TYPE_NORMAL
- en: NamespaceLifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned earlier, when a namespace is deleted, all objects in that namespace
    will be evicted as well. This plugin ensures that no new object creation requests
    can be made in a namespace that is terminating or non-existent. It also prevents
    Kubernetes native namespaces from being deleted.
  prefs: []
  type: TYPE_NORMAL
- en: LimitRanger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This plugin ensures that `LimitRange` can work properly. With `LimitRange`,
    we can set default requests and limits in a namespace, which will be used when
    launching a pod without specifying the requests and limits.
  prefs: []
  type: TYPE_NORMAL
- en: ServiceAccount
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The service account plugin must be added if you use service account objects.
    For more information about `ServiceAccount`, revisit the *Service account token
    authentication* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: PersistentVolumeLabel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`PersistentVolumeLabel` adds labels to newly created PVs, based on the labels
    provided by the underlying cloud provider. This admission controller has been
    deprecated since the 1.8 release.'
  prefs: []
  type: TYPE_NORMAL
- en: DefaultStorageClass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This plugin ensures that default storage classes work as expected if no `StorageClass`
    is set in a PVC. Different cloud providers implement their own `DefaultStorageClass`
    (such as how GKE uses Google Cloud Persistent Disk). Make sure you have this enabled.
  prefs: []
  type: TYPE_NORMAL
- en: ResourceQuota
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the `LimitRange`, if you're using the `ResourceQuota` object to administer
    a different level of QoS, this plugin must be enabled. The `ResourceQuota` should
    always be put at the end of the admission control plugin list. As we mentioned
    in the *ResourceQuota* section, `ResourceQuota` is used to limit the resource
    usage per namespace. Putting the `ResourceQuota` controller at the end of the
    admission controller list could prevent the request from increasing quota usage
    prematurely if it eventually gets rejected by controllers that are put after it,
    if any are.
  prefs: []
  type: TYPE_NORMAL
- en: DefaultTolerationSeconds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `DefaultTolerationSeconds` plugin is used to set pods without any toleration
    sets. It will then apply for the default toleration for the `notready:NoExecute`
    and `unreachable:NoExecute` taints for 300 seconds. If you don't want this behavior
    to occur in the cluster, disable this plugin. For more information, please refer
    to the taints and tolerations section of [Chapter 8](a7a72300-181d-41ad-a08a-7e42744d365f.xhtml),
    *Resource Management and Scaling*.
  prefs: []
  type: TYPE_NORMAL
- en: PodNodeSelector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This plugin is used to set the `node-selector` annotation to the namespace.
    When the plugin is enabled, pass along a configuration file with the `--admission-control-config-file`
    command using the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: By doing this, the `node-selector` annotation will be applied to the `namespace`.
    The pods on that namespace will then run on those matched nodes.
  prefs: []
  type: TYPE_NORMAL
- en: AlwaysPullImages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pull policy defines the behavior when kubelet pulls images. The default
    pull policy is `IfNotPresent`, that is, it will pull the image if it is not present
    locally. If this plugin is enabled, the default pull policy will become `Always`,
    which is to always pull the latest image. This plugin also brings another benefit
    if your cluster is shared by different teams. Whenever a pod is scheduled, it'll
    always pull the latest image, regardless of whether the image exists locally or
    not. Then, we can ensure that a pod creation request always goes through an authorization
    check against the image.
  prefs: []
  type: TYPE_NORMAL
- en: DenyEscalatingExec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This plugin prevents any `kubectl exec` or `kubectl attach` commands from making
    pods escalate to privilege mode. Pods within privilege mode have access to the
    host namespace, which could become a security risk.
  prefs: []
  type: TYPE_NORMAL
- en: Other admission controller plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many other admission controller plugins we could use, such as `NodeRestriciton`
    to limit kubelet's permission, `ImagePolicyWebhook` to establish a webhook to
    control the access of the images, and `SecurityContextDeny` for controlling the
    privilege for a pod or a container. Please refer to the official documentation
    at [https://kubernetes.io/docs/admin/admission-controllers](https://kubernetes.io/docs/admin/admission-controllers/)
    to learn more about other plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic admission control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before Kubernetes 1.7, admission controllers were compiled with Kubernetes
    API server, so they could only be configured before the API server started. Dynamic
    admission control aimed to break this limitation. There are two methods to implement
    custom dynamic admission control: via initializer and admission webhooks. The
    Initializer webhook can watch an uninitialized workload and check whether it needs
    to take any action against it.'
  prefs: []
  type: TYPE_NORMAL
- en: The Admission webhook intercepts the request and checks the preset rules from
    its configuration before deciding whether the requests are allowed or not. Both
    the initializer and admission webhooks can admit and mutate the resource request
    on certain operations, so we can leverage them to force policies or validate whether
    the requests fulfill the requirement of your organization. Buggy initializer and
    admission webhooks might block all the target resources from being created. However,
    the Admission webhook provides a failure policy, which can address when the webhook
    server doesn't respond as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this book, the admission webhook has been promoted to
    beta, but the Initializer is still alpha. In this section, we''ll implement a
    simple Admission webhook controller, which will verify whether the `{"chapter":
    "5"}` annotation is set to the `podSpec` during pod creation. The request will
    go through if the annotation is set. If not, the request will fail.'
  prefs: []
  type: TYPE_NORMAL
- en: Admission webhook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two major components to implementing an Admission webhook controller:
    a webhook HTTP server to receive the resource life event and a `ValidatingWebhookConfiguration`
    or `MutatingWebhookConfiguration` resource configuration file. Please refer to [https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter5/5-3_admission-webhook/sample-validating-admission-webhook](https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter5/5-3_admission-webhook/sample-validating-admission-webhook)
    for the source code of our sample Admission webhook.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how to write a `ValidatingWebhookConfiguration`. As we can see
    in the following code, like normal objects, `ValidatingWebhookConfiguration` has
    an API version, a kind, and metadata with a name and labels. The important session
    is named `webhooks`. In `webhooks`, one or more rules need to be defined. Here,
    we are defining a rule that is triggered on any pod's creation request (`operations=CREATE,
    resources=pods`). The `failurePolicy` is used to determine the action if an error
    occurs when calling the webhook. The option of `failurePolicy` is either `Fail`
    or ignore (`Fail` means making the request fail, while ignore means the webhook
    error will be ignored). The `clientConfig` session defines the endpoint of the
    webhook server. Here, we are leveraging a Kubernetes service named `sample-webhook-service-svc`.
    If it's an external server, the URL could be specified directly rather than using a
    service. The `caBundle` is used to validate the webhook's server certificate.
    If not specified, by default, it'll use API server's system trust roots.
  prefs: []
  type: TYPE_NORMAL
- en: 'To export `caBundle` from Kubernetes Service, use the `kubectl get configmap
    -n kube-system extension-apiserver-authentication -o=jsonpath=''{.data.client-ca-file}''
    | base64 | tr -d ''\n''` command and replace the `${CA_BUNDLE}` field as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To make a webhook HTTP server, we create a simple express web application in
    Node.js ([https://expressjs.com/](https://expressjs.com/)). The main logic of
    the application is to receive a pod creation event and send an `admissionResponse` ([https://github.com/kubernetes/api/blob/master/admission/v1beta1/types.go#L81](https://github.com/kubernetes/api/blob/master/admission/v1beta1/types.go#L81))
    back. Here, we''ll return an `admissionResponse` with the `allowed` field, which
    indicates whether a request is allowed or denied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding function, we checked whether `object.metadata.annotations.chapter`
    is annotated in the pod and whether the chapter is equal to `5`. If it is, the
    webhook server will pass the request. The webhook and API servers need to establish
    a mutual trust. To do this, we''ll generate a certificate for the webhook server
    by requesting a certificate signing through the `certificates.k8s.io` API. The
    popular service mesh implementation, Istio ([https://istio.io/](https://istio.io/)),
    has a useful tool for us ([https://raw.githubusercontent.com/istio/istio/41203341818c4dada2ea5385cfedc7859c01e957/install/kubernetes/webhook-create-signed-cert.sh](https://raw.githubusercontent.com/istio/istio/41203341818c4dada2ea5385cfedc7859c01e957/install/kubernetes/webhook-create-signed-cert.sh)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`server-key.pem` and `server-cert.pem` will be generated via the script under
    the default `temp` folder in your operating system. Copying them can put them
    under the `src/keys` folder inside our sample webhook HTTP server. Now, it''s
    time to build the application with docker via `docker build -t $registry/$repository:$tag
    .` and push the target docker image to the registry (here, we used `devopswithkubernetes/sample-webhook-service:latest`).
    After doing this, we can launch the webserver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After checking that the pod is up and running, we can create a `ValidatingWebhookConfiguration`
    resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try deploying two `nginx` pods without any annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is supposed to create two pods; however, we did not see any `nginx` pods
    being created. We can only see our webhook service pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If we check the corresponding `ReplicaSet`, and use `kubectl describe rs $RS_NAME`
    to check the events, we will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, we can see that the admission webhook denies the request. Delete
    and recreate the deployment by using the `uncomment` annotation in the preceding
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do this, we should be able to see that the `nginx` pods are created accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The request passed through the authentication, authorization, and admission
    controls, including our webhook service. The pod objects were created and scheduled
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Please remember to clean up after testing the dynamic admission controllers.
    It might block pod creation in future experiments.
  prefs: []
  type: TYPE_NORMAL
- en: Custom resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Custom resources, which were first introduced in Kubernetes 1.7, were designed
    as an extension point to let users create custom API objects and act as native
    Kubernetes objects. This was done so that users could extend Kubernetes to support
    the custom objects for their application or specific use cases. Custom resources
    can be dynamically registered and unregistered. There are two ways to create custom
    resources: by using a CRD or aggregated API. CRDs are much easier, while an aggregated
    API requires additional coding in Go. In this section, we''ll learn how to write
    a CRD from scratch.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom resources definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a **Custom Resources Definition** (**CRD**) object includes two steps:
    CRD registration and object creation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a CRD configuration first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'With `CustomResourceDefinition`, we can define our own spec for the custom
    object. First, we''ll have to decide on the name of the CRD. The naming convention for
    a CRD must be `spec.names.plural+"."+spec.group`. Next, we''ll define the group,
    version, scope, and names. The scope is either `Namespaced` or `Cluster` (non-namespaced).
    After Kubernetes 1.13, we can add a validation section to validate the custom
    objects via the OpenAPI v3 schema ([https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject)).
    We can define the required fields, as well as the spec and validation condition
    for each field. In the preceding example, we created a custom object named `books.devops.kubernetes.com`
    that has three properties: `name`, `edition`, and `chapter`. `name` and `edition`
    are required during object creation. Let''s create the CRD via the `kubectl` command.
    We can also list all the CRDs via the `kubectl get crd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create an object accordingly. In `spec`, `name`, and `edition`
    are required. The `apiVersion` will be the `<group>/<version>` we defined in the
    preceding CRD configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If we set the `edition` to `second`, an error will be thrown, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should be able to get and describe it, just like a normal API object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After registering a CRD, a custom controller might be needed to handle custom
    object operations. The custom controller requires additional programming effort.
    There are also multiple tools available in the community that can help us create
    a skeleton controller, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Controller: [https://github.com/kubernetes/sample-controller](https://github.com/kubernetes/sample-controller)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubebuilder: [https://github.com/kubernetes-sigs/kubebuilder](https://github.com/kubernetes-sigs/kubebuilder)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Operator: [https://coreos.com/operators/](https://coreos.com/operators/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the sample controller (provided by Kubernetes), a set of `ResourceEventHandlerFuncs`
    will be added into `EventHandler` for handling object life cycle events, such
    as `AddFunc` for `UpdateFunc` and `DeleteFunc`.
  prefs: []
  type: TYPE_NORMAL
- en: Both **Kubebuilder** and **Operator** can simplify the preceding steps. Kubebuilder
    provides support for building APIs via CRDs, controllers, and admission webhooks. Operator,
    which was introduced by CoreOS, is an application-specific controller that's implemented
    with CRD. There are existing operators being implemented by the community, and
    they can be found at [https://github.com/operator-framework/awesome-operators](https://github.com/operator-framework/awesome-operators).
    We'll introduce how to leverage the operator SDK in the Operator framework to
    build a simple controller with the same book CRD.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll have to install the operator SDK ([https://github.com/operator-framework/operator-sdk](https://github.com/operator-framework/operator-sdk)).
    We are using v.0.3.0 in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a new operator named `devops-operator` via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'After the operator is initialized, we can start adding components to it. Let''s
    add `api` to create an API object and `controller` to handle object operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'There are multiple files we need to modify. The first one is API spec. In the
    previous CRD example, we added three custom properties in the `book` resource:
    `name`, `edition`, and `chapter`. We''ll need to add that into spec here, too.
    This can be found under `pkg/apis/devops/v1alpha1/book_types.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Run `operator-sdk generate k8s` after modifying the file, as shown in the preceding
    code. Next, we will add some custom logic to the controller logic. This is located
    in the `Reconcile` function in `pkg/controller/book/book_controller.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the existing example that was created by the framework, the controller will
    receive a `podSpec`. This is exactly what we need, and we''ll just get the `name`
    and `edition` from the `Spec` and print it out in `busybox` `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can run `operator-sdk build devopswithkubernetes/sample-operator` to
    build the docker image and push it to a registry. Here, we'll just push it to
    our public docker hub, `docker push devopswithkubernetes/sample-operator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operator is done! After that, we can start looking into how to deploy it.
    The deployment scripts are automatically created in the `deploy` folder. The file
    we need to change is `operator.yaml`, which specifies the operator container image.
    Find the `image: REPLACE_IMAGE` line in `podSpec` and update that so that it points
    into your registry (here, we''ll point it to `devopswithkubernetes/sample-operator`).
    Now, it''s good to deploy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you should be able to see an operator pod when listing the pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a `Book` resource. You could modify `deploy/crds/devops_v1alpha1_book_cr.yaml`
    in the current folder or reuse `5-4_crd/5-4-2_objectcreation.yaml` from our repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we should be able to see that another pod was created by the CRD, and
    we can also check its logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Hurray! Everything looks fine. Here, we have demonstrated a very simple example.
    Of course, we could leverage this concept and evolve more sophisticated logic
    and handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Application CRD:'
  prefs: []
  type: TYPE_NORMAL
- en: A containerized application might contain multiple Kubernetes resources, such
    as deployments, services, `ConfigMaps`, secrets, as well as custom CRDs. An application
    CRD has been implemented at [https://github.com/kubernetes-sigs/application](https://github.com/kubernetes-sigs/application),
    providing a bridge to make application metadata describable. It also has application
    level health checks so that users don't need to list all the resources after deployment
    and check whether the application has been deployed properly. Instead, they list
    the application CRD and check its status.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about what `namespace` and `context` are, including
    how they work, and a how to switch between a physical cluster and virtual cluster
    by setting the context. We then learned about an important object—service account,
    which provides the ability to identify processes that are running within a pod.
    Then, we familiarized ourselves with how to control access flow in Kubernetes.
    We learned what the difference is between authentication and authorization, and
    how these work in Kubernetes. We also learned how to leverage RBAC to have fine-grained
    permission for users. In addition, we looked at a couple of admission controller
    plugins and dynamic admission controls, which are the last goalkeepers in the
    access control flow. Finally, we learned about what the CRD is and implemented
    it and its controller via the operator SDK ([https://github.com/operator-framework/operator-sdk](https://github.com/operator-framework/operator-sdk))
    in the operator framework.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](fc67e008-b601-45a6-8297-d2fa28360b1f.xhtml), *Kubernetes Network*,
    we'll move on and learn more about cluster networking.
  prefs: []
  type: TYPE_NORMAL
