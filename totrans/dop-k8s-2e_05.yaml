- en: Cluster Administration and Extension
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群管理与扩展
- en: In previous chapters, we familiarized ourselves with basic DevOps skills and
    Kubernetes objects. This included looking at many areas, such as how to containerize
    our application and deploy our containerized software into Kubernetes. It is now
    time to gain a deeper insight into Kubernetes cluster administration.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经熟悉了基本的 DevOps 技能和 Kubernetes 对象。这包括了多个方面，如如何将我们的应用容器化，并将容器化软件部署到
    Kubernetes 中。现在是时候深入了解 Kubernetes 集群管理了。
- en: 'In this chapter, we''ll learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Utilizing namespaces to set administrative boundaries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用命名空间设置管理边界
- en: Using kubeconfig to switch between multiple clusters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 kubeconfig 在多个集群之间切换
- en: Kubernetes authentication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 身份验证
- en: Kubernetes authorization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 授权
- en: Dynamic admission control
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态准入控制
- en: Kubernetes **Custom Resources Definition** (**CRD**) and controllers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes **自定义资源定义** (**CRD**) 和控制器
- en: While minikube is a fairly simple environment, we will use the **Google Kubernetes
    Engine** (**GKE**) in this chapter. For cluster deployment in GKE, please refer
    to [Chapter 11](d4de05e3-eb24-4e8e-bfd3-e68819b5e66c.xhtml), *Kubernetes on GCP*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 minikube 是一个相对简单的环境，但在本章中我们将使用 **Google Kubernetes Engine** (**GKE**)。有关
    GKE 中集群部署的更多信息，请参考 [第 11 章](d4de05e3-eb24-4e8e-bfd3-e68819b5e66c.xhtml)，*在 GCP
    上使用 Kubernetes*。
- en: Kubernetes namespaces
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 命名空间
- en: 'We already learned about Kubernetes namespaces in [Chapter 3](a5cf080a-372a-406e-bb48-019af313c676.xhtml),
    *Getting Started with Kubernetes*, which are used to divide the resources from
    a cluster into multiple virtual clusters. Namespaces make each group share the
    same physical cluster with isolation. Each namespace provides the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 3 章](a5cf080a-372a-406e-bb48-019af313c676.xhtml)，*Kubernetes 入门* 中已经了解了
    Kubernetes 命名空间，它们用于将集群中的资源划分为多个虚拟集群。命名空间使得每个组可以共享同一个物理集群，并且具有隔离性。每个命名空间提供以下功能：
- en: A scope of names; the object name in each namespace is unique
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称的范围；每个命名空间中的对象名称是唯一的
- en: Policies to ensure trusted authentication
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保可信身份验证的策略
- en: The ability to set up resource quotas for resource management
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置资源管理的资源配额的能力
- en: Now, let's learn how to use context to switch between different namespaces.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用上下文在不同的命名空间之间切换。
- en: Context
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文
- en: '**Context** is the concept of the combination of cluster information, a user
    for authentication, and a namespace. For example, the following is the context
    information for one of our clusters in GKE:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文** 是集群信息、用于身份验证的用户和命名空间的组合。例如，以下是我们在 GKE 中一个集群的上下文信息：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We could use the `kubectl config current-context` command to list the current
    context:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `kubectl config current-context` 命令来列出当前的上下文：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To list all config information, including contexts, you could use the `kubectl
    config view` command. To check out what context is currently in use, use the `kubectl
    config get-contexts` command.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出所有配置的详细信息，包括上下文，您可以使用 `kubectl config view` 命令。要查看当前正在使用的上下文，可以使用 `kubectl
    config get-contexts` 命令。
- en: Creating a context
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个上下文
- en: 'The next step is to create a context. As we did in the preceding example, we''ll
    need to set a user and cluster name for the context. If we don''t specify those,
    the empty value will be set. The command to create a context is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个上下文。像前面示例中一样，我们需要为上下文设置用户和集群名称。如果没有指定，这些值将会为空。创建上下文的命令如下：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Multiple contexts can be created in the same cluster. The following is an example
    of how to create a context for `chapter5` in my GKE cluster, `gke_devops-with-kubernetes_us-central1-b_cluster`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一集群中可以创建多个上下文。以下是如何在我的 GKE 集群 `gke_devops-with-kubernetes_us-central1-b_cluster`
    中为 `chapter5` 创建上下文的示例：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Switching the current context
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换当前上下文
- en: 'We could switch the context using the `use-context` subcommand:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `use-context` 子命令来切换上下文：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After the context is switched, every command we invoke via `kubectl` is under
    the `chapter5` context. There is no need to explicitly specify the namespace when
    listing your pods.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 切换上下文后，通过 `kubectl` 调用的每个命令都会在 `chapter5` 上下文下执行。列出 pod 时无需显式指定命名空间。
- en: Kubeconfig
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubeconfig
- en: 'Kubeconfig is a file that you can use to switch multiple clusters by switching
    context. We can use `kubectl config view` to view the setting and the `kubectl
    config current-context` command to check the context you''re currently using.
    The following is an example of a GCP cluster in a `kubeconfig` file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Kubeconfig 是一个文件，你可以通过切换上下文来切换多个集群。我们可以使用 `kubectl config view` 查看设置，使用 `kubectl
    config current-context` 命令查看当前正在使用的上下文。以下是一个 GCP 集群在 `kubeconfig` 文件中的示例：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we learned previously, we can use `kubectl config use-context CONTEXT_NAME` to
    switch the context. We can also specify `kubeconfig` files according to the `$KUBECONFIG` environment
    variable to determine which kubeconfig files are used. In this way, config files
    could be merged. For example, the following command will merge `kubeconfig-file1`
    and `kubeconfig-file2`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所学，我们可以使用 `kubectl config use-context CONTEXT_NAME` 来切换上下文。我们还可以根据 `$KUBECONFIG`
    环境变量指定 `kubeconfig` 文件，以确定使用哪些 kubeconfig 文件。通过这种方式，可以合并配置文件。例如，以下命令将合并 `kubeconfig-file1`
    和 `kubeconfig-file2`：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We could also use `kubectl config --kubeconfig=<config file name> set-cluster
    <cluster name>` to specify the target cluster in the target `kubeconfig` file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `kubectl config --kubeconfig=<config file name> set-cluster <cluster
    name>` 来指定目标 `kubeconfig` 文件中的目标集群。
- en: By default, the `kubeconfig` file is located at `$HOME/.kube/config`. This file
    will be loaded if none of the preceding settings are set.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`kubeconfig` 文件位于 `$HOME/.kube/config`。如果没有设置前面提到的任何设置，将会加载这个文件。
- en: Service account
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务帐户
- en: 'In Kubernetes, there are two kinds of user account: **service account** and
    **user account**. All the requests to the API server are sent either by a service
    account or a user account. Service accounts are managed by the Kubernetes API.
    In contrast, user accounts are not managed and stored in Kubernetes. The following
    is a simple comparison of service and user accounts:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，有两种类型的用户帐户：**服务帐户**和**用户帐户**。所有发送到 API 服务器的请求都来自服务帐户或用户帐户。服务帐户由
    Kubernetes API 管理，而用户帐户则不在 Kubernetes 中管理或存储。以下是服务帐户和用户帐户的简单对比：
- en: '|  | **Service account** | **User account** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|  | **服务帐户** | **用户帐户** |'
- en: '| **Scope** | Namespaced | Global  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **作用域** | 命名空间级 | 全局 |'
- en: '| **Used by** | Processes | Normal user |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **使用者** | 进程 | 普通用户 |'
- en: '| **Created by** | API server or via API calls | Administrators, not by API
    calls |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **创建者** | API 服务器或通过 API 调用 | 管理员，而非通过 API 调用 |'
- en: '| **Managed by** | API server | Outside the cluster |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **由谁管理** | API 服务器 | 集群外部 |'
- en: 'By default, a Kubernetes cluster creates different service accounts for different
    purposes. In GKE, there are a bunch of service accounts that have been created:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes 集群会为不同的用途创建不同的服务帐户。在 GKE 中，已经创建了一些服务帐户：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Kubernetes will create a default service account in each namespace, which will
    be used if no service account is specified in pod specification during pod creation.
    Let''s take a look at how the default service account acts for our `chapter5`
    namespace:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 会在每个命名空间中创建一个默认的服务帐户，如果在创建 Pod 时没有在 Pod 规范中指定服务帐户，则会使用该默认服务帐户。我们来看一下默认服务帐户在
    `chapter5` 命名空间中的作用：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can see that the service account is basically using mountable secrets as
    tokens. Let''s dig into what content is inside the token:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，服务帐户基本上是使用可挂载的密钥作为令牌。让我们深入了解令牌中的内容：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The service account secret will be automatically mounted to the `/var/run/secrets/kubernetes.io/serviceaccount`
    directory. When the pod accesses the API server, the API server will check the
    cert and token to do the authentication.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 服务帐户的密钥将自动挂载到 `/var/run/secrets/kubernetes.io/serviceaccount` 目录。当 Pod 访问 API
    服务器时，API 服务器将检查证书和令牌进行认证。
- en: 'Specifying `automountServiceAccountToken: false` in the service account or
    pod specification could disable the auto-mount service account secret.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '在服务帐户或 Pod 规范中指定 `automountServiceAccountToken: false` 可以禁用自动挂载服务帐户密钥。'
- en: Authentication and authorization
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证和授权
- en: Authentication and authorization are important components in Kubernetes. Authentication
    verifies users and checks that the user is who they claim to be. Authorization,
    on the other hand, checks what permission levels users have. Kubernetes supports
    different authentication and authorization modules.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 认证和授权是 Kubernetes 中的重要组件。认证用于验证用户，并检查用户是否是他们所声称的人。而授权则检查用户拥有的权限级别。Kubernetes
    支持不同的认证和授权模块。
- en: 'The following is an illustration that shows how the Kubernetes API server processes
    access control when it receives a request:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示意图，展示了 Kubernetes API 服务器在收到请求时如何处理访问控制：
- en: '![](img/1ad4c779-ce36-4ace-ac4d-54fcaaaa50d8.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ad4c779-ce36-4ace-ac4d-54fcaaaa50d8.png)'
- en: Access control in the Kubernetes API server
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 服务器中的访问控制
- en: When the request goes to the API server, first it establishes a TLS connection
    by validating the clients' certificate with the **Certificate Authority** (**CA**)
    in the API server. The CA in the API server is usually at `/etc/kubernetes/`,
    and the clients' certificate is usually at `$HOME/.kube/config`. After the handshake,
    it moves into the authentication stage. In Kubernetes, authentication modules
    are chain-based. More than one authentication module can be used here. When receiving
    the request, Kubernetes will try all the authenticators one by one until it succeeds.
    If the request fails on all authentication modules, it will be rejected with an HTTP
    401 Unauthorized error. If not, one of the authenticators verifies the user's
    identity and the requests are authenticated. At this point, Kubernetes authorization
    modules come into play.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求到达 API 服务器时，首先通过验证客户端证书与 API 服务器中的**证书颁发机构**（**CA**）建立 TLS 连接。API 服务器中的 CA
    通常位于 `/etc/kubernetes/`，客户端的证书通常位于 `$HOME/.kube/config`。握手完成后，进入身份验证阶段。在 Kubernetes
    中，身份验证模块是链式的，可以使用多个身份验证模块。当接收到请求时，Kubernetes 会依次尝试所有身份验证器，直到成功。如果所有身份验证模块都失败，请求将被拒绝并返回
    HTTP 401 Unauthorized 错误。如果成功，通过其中一个身份验证器验证用户身份，且请求被认证。此时，Kubernetes 的授权模块开始发挥作用。
- en: Authorization modules verify whether or not the user has sufficient permissions
    to perform the action that they have requested to perform. Authorization modules
    are also chain-based. The authorization request needs to pass through every module
    until it succeeds. If the request fails for all modules, the requester will get
    a HTTP 403 Forbidden response.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 授权模块验证用户是否具有足够的权限来执行他们请求的操作。授权模块也是链式的。授权请求需要通过每个模块，直到成功。如果所有模块都失败，请求者将收到 HTTP
    403 Forbidden 响应。
- en: Admission control is a set of configurable plugins in an API server that determine
    whether a request is admitted or denied. At this stage, if the request doesn't
    pass through one of the plugins, then it is denied immediately.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 准入控制是一组可配置的插件，在 API 服务器中决定请求是否被接受或拒绝。在此阶段，如果请求未能通过某个插件的检查，将立即被拒绝。
- en: Authentication
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证
- en: By default, a service account is token-based. When you create a service account
    or a namespace with a default service account, Kubernetes creates the token, stores
    it as a secret that is encoded by Base64, and mounts the secret as a volume into
    the pod. Then, the processes inside the pod have the ability to talk to the cluster.
    The user account, on the other hand, represents a normal user who might use `kubectl`
    to directly manipulate the resource.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，服务账户是基于令牌的。当你创建一个服务账户或带有默认服务账户的命名空间时，Kubernetes 会创建令牌，将其作为一个密钥进行 Base64
    编码存储，并将该密钥作为卷挂载到 pod 中。然后，pod 内的进程就可以与集群进行通信。另一方面，用户账户代表的是一个普通用户，可能会使用 `kubectl`
    直接操作资源。
- en: Service account token authentication
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务账户令牌身份验证
- en: When we create a service account, a signed bearer token will be automatically created
    by the Kubernetes service account admission controller plugin. We can use that
    service account token to authenticate a user.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个服务账户时，Kubernetes 服务账户准入控制插件会自动创建一个签名的持有令牌。我们可以使用该服务账户令牌来验证用户身份。
- en: 'Let''s try creating a service account named `myaccount` in the `chapter5` namespace:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在 `chapter5` 命名空间中创建一个名为 `myaccount` 的服务账户：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In [Chapter 9](acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml), *Continuous Delivery*,
    in the example in which we demonstrated how to deploy `my-app`, we created a namespace
    named `cd`, and used `get-sa-token.sh` script ([https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/blob/master/chapter9/9-2_service-account-for-ci-tool/utils/push-cd/get-sa-token.sh](https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/blob/master/chapter9/9-2_service-account-for-ci-tool/utils/push-cd/get-sa-token.sh))
    to export the token for us:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml)，*持续交付*中，我们展示了如何部署`my-app`，我们创建了一个名为`cd`的命名空间，并使用`get-sa-token.sh`脚本（[https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/blob/master/chapter9/9-2_service-account-for-ci-tool/utils/push-cd/get-sa-token.sh](https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/blob/master/chapter9/9-2_service-account-for-ci-tool/utils/push-cd/get-sa-token.sh)）为我们导出了令牌：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we created a user named `mysa` via the `kubectl config set-credentials
    <user> --token=$TOKEN` command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过`kubectl config set-credentials <user> --token=$TOKEN`命令创建了一个名为`mysa`的用户：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we set the context to bind with a user and namespace:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置上下文以与用户和命名空间绑定：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we set our `myctxt` context as the default context:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`myctxt`上下文设置为默认上下文：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we send a request, the token will be verified by the API server, which
    checks whether the requester is eligible and is what it claims to be. Let''s see
    if we can use this token to list the pods in the default namespace:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发送请求时，令牌将由API服务器进行验证，API服务器会检查请求者是否符合资格并且确实是其声称的身份。让我们看看是否可以使用这个令牌列出默认命名空间中的pods：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Seems like something went wrong! This is because we haven't granted any permissions
    to this service account yet. We'll learn how to do this using `Role` and `RoleBinding` later
    in this chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好像出了点问题！这是因为我们还没有为这个服务账户授予任何权限。稍后我们将在本章中学习如何使用`Role`和`RoleBinding`来做这件事。
- en: User account authentication
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户账户认证
- en: There are several implementations for user account authentication. This includes
    anything from client certificates, bearer tokens, and static files to OpenID connect
    tokens. You can choose more than one as authentication chains. Here, we'll demonstrate
    how client certificates work.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 用户帐户认证有多种实现方式，包括客户端证书、承载令牌、静态文件以及OpenID连接令牌等。你可以选择多种方式作为认证链。在这里，我们将演示客户端证书的工作原理。
- en: 'In [Chapter 9](acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml), *Continuous Delivery*,
    and earlier in this chapter, we learned how to export certificates and tokens
    for service accounts. Now, let''s learn how to do this for a user. Let''s assume
    that we are still inside the `chapter5` namespace, and we want to create a user
    for our new DevOps member, Linda, who will help us do the deployment for `my-app`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml)，*持续交付*，以及在本章早些时候，我们学习了如何为服务账户导出证书和令牌。现在，让我们学习如何为用户执行此操作。假设我们仍然在`chapter5`命名空间中，并且我们想为我们的新DevOps成员Linda创建一个用户，她将帮助我们为`my-app`进行部署：
- en: 'First, we''ll generate a private key via OpenSSL ([https://www.openssl.org](https://www.openssl.org)):'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将通过OpenSSL生成一个私钥（[https://www.openssl.org](https://www.openssl.org)）：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we''ll create a certificate sign request (`.csr`) for Linda:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为Linda创建一个证书签署请求（`.csr`）：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, `linda.key` and `linda.csr` should be located in the current folder. To
    let the API server validate Linda's certificate, we'll need to find the cluster
    CA.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`linda.key`和`linda.csr`应该位于当前文件夹中。为了让API服务器验证Linda的证书，我们需要找到集群的CA。
- en: In minikube, the root CA is under `~/.minikube/`. For other self-hosted solutions,
    it's normally under `/etc/kubernetes/`. If you use `kops` to deploy the cluster,
    the location is under `/srv/kubernetes`, and you will find the path in the `/etc/kubernetes/manifests/kube-apiserver.manifest`
    file. In GKE, the cluster root CA is non-exportable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在minikube中，根CA位于`~/.minikube/`下。对于其他自托管解决方案，通常位于`/etc/kubernetes/`下。如果你使用`kops`来部署集群，路径通常位于`/srv/kubernetes`，你可以在`/etc/kubernetes/manifests/kube-apiserver.manifest`文件中找到该路径。在GKE中，集群的根CA是不可导出的。
- en: 'Let''s assume we have `ca.crt` and `ca.key` under the current folder; by using
    these, we could generate a new CA for the user. By using the `-days` parameter,
    we can define the expired date:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在当前文件夹下有`ca.crt`和`ca.key`；通过使用它们，我们可以为用户生成新的CA。通过使用`-days`参数，我们可以定义过期日期：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After we have cert signed by our cluster, we could set a user in the cluster,
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的集群签署证书后，我们可以在集群中设置一个用户，如下所示：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Remember the concept of context: this is the combination of cluster information,
    a user for authentication, and a namespace. Now, we''ll set a context entry in
    `kubeconfig`. Remember to replace your cluster name, namespace, and user in the
    following example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 记住上下文的概念：它是集群信息、用于认证的用户和命名空间的组合。现在，我们将在`kubeconfig`中设置一个上下文条目。记得在以下示例中替换集群名称、命名空间和用户：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, Linda should have zero permission:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Linda应该没有任何权限：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Linda can now pass the authentication stage as Kubernetes knows she is Linda.
    However, to give Linda permission to do the deployment, we need to set up the
    policies in authorization modules.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Linda可以通过认证阶段，因为Kubernetes知道她是Linda。然而，为了给予Linda部署的权限，我们需要在授权模块中设置策略。
- en: Authorization
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: 'Kubernetes supports several authorization modules. At the time of writing this
    book, it supports the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes支持多个授权模块。在编写本书时，Kubernetes支持以下模块：
- en: ABAC
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ABAC
- en: RBAC
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RBAC
- en: Node authorization
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点授权
- en: Webhook
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webhook
- en: Custom modules
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义模块
- en: '**Attribute-Based Access Control** (**ABAC**) was the major authorization mode
    before **Role-Based Access Control** (**RBAC**) was introduced. Node authorization
    is used by kubelet to make a request to the API server. Kubernetes supports the
    webhook authorization mode to establish a HTTP callback with an external RESTful
    service. It''ll do a POST whenever it faces an authorization decision. Another
    common way to do this is by implementing your in-house module by following along
    with the pre-defined authorizer interface. For more implementation information,
    refer to [https://kubernetes.io/docs/admin/authorization/#custom-modules](https://kubernetes.io/docs/admin/authorization/#custom-modules).
    In this section, we''ll walk though how to leverage and utilize RBAC in Kubernetes.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于属性的访问控制**（**ABAC**）是**基于角色的访问控制**（**RBAC**）引入之前的主要授权模式。节点授权由kubelet用于向API服务器发出请求。Kubernetes支持Webhook授权模式，以与外部RESTful服务建立HTTP回调。每当面临授权决策时，它将进行POST请求。另一种常见的做法是通过实现自定义模块，遵循预定义的授权接口。有关更多实现信息，请参考[https://kubernetes.io/docs/admin/authorization/#custom-modules](https://kubernetes.io/docs/admin/authorization/#custom-modules)。在本节中，我们将介绍如何在Kubernetes中利用和使用RBAC。'
- en: Role-based access control (RBAC)
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于角色的访问控制（RBAC）
- en: Since Kubernetes 1.6, RBAC is enabled by default. In RBAC, the admin creates
    several `Roles` or `ClusterRoles` that define the fine-grained permissions that
    specify a set of resources and actions (verbs) that roles can access and manipulate.
    After that, the admin grants the `Role` permission to users through `RoleBinding`
    or `ClusterRoleBindings`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从Kubernetes 1.6开始，RBAC默认启用。在RBAC中，管理员创建多个`Roles`或`ClusterRoles`，这些角色定义了细粒度的权限，指定一组资源和操作（动词），这些角色可以访问和操作这些资源。之后，管理员通过`RoleBinding`或`ClusterRoleBindings`将`Role`权限授予用户。
- en: If you're running minikube, add `--extra-config=apiserver.Authorization.Mode=RBAC`
    when using `minikube start`. If you're running a self-hosted cluster on AWS via
    kops, add `--authorization=rbac` when launching the cluster. Kops launches an
    API server as a pod; using the `kops edit cluster` command could modify the `spec`
    of the containers. EKS and GKE support RBAC natively.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行minikube，在使用`minikube start`时添加`--extra-config=apiserver.Authorization.Mode=RBAC`。如果您通过kops在AWS上运行自托管集群，请在启动集群时添加`--authorization=rbac`。Kops会将API服务器作为Pod启动；使用`kops
    edit cluster`命令可以修改容器的`spec`。EKS和GKE原生支持RBAC。
- en: Roles and ClusterRoles
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色和集群角色
- en: 'A `Role` in Kubernetes is bound within a namespace. A `ClusterRole`, on the
    other hand, is cluster-wide. The following is an example of `Role`, which can
    perform all operations, including `get`, `watch`, `list`, `create`, `update`,
    `delete`, and `patch`, on the `deployments`, `replicasets`, and `pods` resources:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的`Role`绑定在一个命名空间内。另一方面，`ClusterRole`是集群级别的。以下是一个`Role`的示例，它可以执行所有操作，包括`get`、`watch`、`list`、`create`、`update`、`delete`和`patch`，这些操作适用于`deployments`、`replicasets`和`pods`资源：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In GKE, the admin doesn't have permission to create a role by default. Instead,
    you must grant the user access to this with the following command: `kubectl create
    clusterrolebinding cluster-admin-binding --clusterrole cluster-admin --user ${USER_ACCOUNT}`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在GKE中，管理员默认没有创建角色的权限。相反，您必须通过以下命令授予用户此权限：`kubectl create clusterrolebinding
    cluster-admin-binding --clusterrole cluster-admin --user ${USER_ACCOUNT}`。
- en: 'In `apiGroups`, an empty string `[""]` indicates the core API group. The API
    group is part of the RESTful API call. The core indicates the original API call
    path, such as `/api/v1`. The newer REST path has the group name and API version
    in it, such as `/apis/$GROUP_NAME/$VERSION`. To look up API groups you''d like
    to use, check out API references at [https://kubernetes.io/docs/reference](https://kubernetes.io/docs/reference).
    Under `resources`, you could add the `resources` you''d like to grant access to,
    and under `verbs`, you could list a set of actions that this role could perform.
    Let''s get into a more advanced example for `ClusterRoles`, which we used in [Chapter
    9](acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml), *Continuous Delivery*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `apiGroups` 中，空字符串 `[""]` 表示核心 API 组。API 组是 RESTful API 调用的一部分。核心表示原始 API
    调用路径，如 `/api/v1`。较新的 REST 路径包含了组名和 API 版本，例如 `/apis/$GROUP_NAME/$VERSION`。要查找你想要使用的
    API 组，可以查看 API 参考文档 [https://kubernetes.io/docs/reference](https://kubernetes.io/docs/reference)。在
    `resources` 下，你可以添加想要授予访问权限的 `resources`，在 `verbs` 下，你可以列出该角色可以执行的一组操作。让我们来看看一个更高级的
    `ClusterRoles` 示例，我们在 [第 9 章](acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml) *持续交付*
    中使用过这个概念：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`ClusterRole` is cluster-wide. Some resources don''t belong to any namespace,
    such as nodes, and can only be controlled by `ClusterRole`. The namespaces it
    can access depends on the `namespaces` field that it associates with `ClusterRoleBinding`.
    In the preceding example, we granted the permission to allow this role read and
    write `deployments`, `replicasets`, and `ingresses` in both extensions and apps
    groups. In the core API group, we only grant access for namespace and events,
    as well as all permissions for other resources, such as pods and services.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClusterRole` 是集群范围的。一些资源不属于任何命名空间，例如节点，只能通过 `ClusterRole` 控制。它可以访问的命名空间取决于它与
    `ClusterRoleBinding` 关联的 `namespaces` 字段。在前面的示例中，我们授予了该角色在扩展和应用程序组中读写 `deployments`、`replicasets`
    和 `ingresses` 的权限。在核心 API 组中，我们仅授予了命名空间和事件的访问权限，以及其他资源（如 Pods 和服务）的所有权限。'
- en: RoleBinding and ClusterRoleBinding
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RoleBinding 和 ClusterRoleBinding
- en: A `RoleBinding` binds a `Role` or `ClusterRole` to a list of users or service
    accounts. If a `ClusterRole` is bound with a `RoleBinding` instead of a `ClusterRoleBinding`,
    it will only be granted the permissions within the namespace where `RoleBinding` was specified.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoleBinding` 将 `Role` 或 `ClusterRole` 绑定到一组用户或服务账户。如果 `ClusterRole` 被 `RoleBinding`
    而不是 `ClusterRoleBinding` 绑定，它将仅在 `RoleBinding` 指定的命名空间内获得权限。'
- en: 'The following is an example of the `RoleBinding` spec:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `RoleBinding` 规范的示例：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ­In this example, we bind a `Role` with a user through `roleRef`. This grants
    Linda the permission that we defined in the `devops-role`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过 `roleRef` 将一个 `Role` 与用户绑定。这样，Linda 就获得了我们在 `devops-role` 中定义的权限。
- en: 'On the other hand, a `ClusterRoleBinding` is used to grant permission in all
    namespaces. Here, we''ll leverage the same concept from [Chapter 9](acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml), *Continuous
    Delivery*. First, we created a service account named `cd-agent`, then created
    a `ClusterRole` named `cd-role`, and a `ClusterRoleBinding` for `cd-agent` and
    `cd-role`. We then used `cd-agent` to do the deployment on our behalf:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`ClusterRoleBinding` 用于在所有命名空间中授予权限。在这里，我们将使用 [第 9 章](acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml)
    *持续交付* 中的相同概念。首先，我们创建了一个名为 `cd-agent` 的服务账户，然后创建了一个名为 `cd-role` 的 `ClusterRole`，并为
    `cd-agent` 和 `cd-role` 创建了一个 `ClusterRoleBinding`。然后我们使用 `cd-agent` 代我们进行部署：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `cd-agent` is bound with a `ClusterRole` via `ClusterRoleBinding`, so it
    can have the permission that''s specified in `cd-role` across namespaces. Since
    a service account is created in a namespace, we''ll need to specify its full name,
    including its `namespace`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`cd-agent` 通过 `ClusterRoleBinding` 与 `ClusterRole` 绑定，因此它可以跨命名空间获得在 `cd-role`
    中指定的权限。由于服务账户是在一个命名空间中创建的，我们需要指定它的完整名称，包括其 `namespace`：'
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`ClusterRoleBinding` also supports `Group` as a subject.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClusterRoleBinding` 还支持 `Group` 作为主体。'
- en: 'Now, let''s try to get pods again via `devops-context`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试通过 `devops-context` 再次获取 Pods：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are no longer getting a forbidden response. What about if Linda wants to
    list namespaces—is this allowed?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再收到禁止访问的响应。那么，如果 Linda 想列出命名空间——这允许吗？
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The answer is no, since Linda has not been granted permission to list namespaces.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的，因为 Linda 没有被授予列出命名空间的权限。
- en: Admission control
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准入控制
- en: 'Admission control takes place before Kubernetes processes the request and after
    authentication and authorization is passed. It''s enabled when launching an API
    server by adding the `--admission-control` parameter. Kubernetes recommends having
    the following plugins within the cluster if the cluster version is greater than
    or equal to 1.10.0:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 处理请求之前，且认证和授权通过后，会进行准入控制。通过添加`--admission-control`参数启动 API 服务器时启用该功能。Kubernetes
    建议在集群版本大于或等于 1.10.0 时，集群中应包含以下插件：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The following sections introduce these plugins and why we need them. For the
    latest information about supported admission control plugins, please visit the
    official documentation: [https://kubernetes.io/docs/admin/admission-controllers](https://kubernetes.io/docs/admin/admission-controllers).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节介绍了这些插件及其必要性。有关支持的准入控制插件的最新信息，请访问官方文档：[https://kubernetes.io/docs/admin/admission-controllers](https://kubernetes.io/docs/admin/admission-controllers)。
- en: NamespaceLifecycle
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NamespaceLifecycle
- en: As we learned earlier, when a namespace is deleted, all objects in that namespace
    will be evicted as well. This plugin ensures that no new object creation requests
    can be made in a namespace that is terminating or non-existent. It also prevents
    Kubernetes native namespaces from being deleted.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当一个命名空间被删除时，所有该命名空间中的对象也会被驱逐。此插件确保在终止或不存在的命名空间中无法创建新对象。它还防止 Kubernetes
    原生命名空间被删除。
- en: LimitRanger
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LimitRanger
- en: This plugin ensures that `LimitRange` can work properly. With `LimitRange`,
    we can set default requests and limits in a namespace, which will be used when
    launching a pod without specifying the requests and limits.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件确保 `LimitRange` 能正常工作。通过 `LimitRange`，我们可以在命名空间中设置默认的请求和限制，在启动 pod 时，如果未指定请求和限制，将使用这些默认值。
- en: ServiceAccount
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ServiceAccount
- en: The service account plugin must be added if you use service account objects.
    For more information about `ServiceAccount`, revisit the *Service account token
    authentication* section of this chapter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用服务账户对象，必须添加服务账户插件。有关 `ServiceAccount` 的更多信息，请回顾本章节的 *Service account token
    authentication* 部分。
- en: PersistentVolumeLabel
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PersistentVolumeLabel
- en: '`PersistentVolumeLabel` adds labels to newly created PVs, based on the labels
    provided by the underlying cloud provider. This admission controller has been
    deprecated since the 1.8 release.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersistentVolumeLabel` 会根据底层云提供商提供的标签，为新创建的 PV 添加标签。自 1.8 版本以来，该准入控制器已被弃用。'
- en: DefaultStorageClass
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DefaultStorageClass
- en: This plugin ensures that default storage classes work as expected if no `StorageClass`
    is set in a PVC. Different cloud providers implement their own `DefaultStorageClass`
    (such as how GKE uses Google Cloud Persistent Disk). Make sure you have this enabled.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件确保如果 PVC 中没有设置 `StorageClass`，默认的存储类能按预期工作。不同的云提供商会实现自己的 `DefaultStorageClass`（例如
    GKE 使用 Google Cloud Persistent Disk）。确保启用了此功能。
- en: ResourceQuota
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ResourceQuota
- en: Just like the `LimitRange`, if you're using the `ResourceQuota` object to administer
    a different level of QoS, this plugin must be enabled. The `ResourceQuota` should
    always be put at the end of the admission control plugin list. As we mentioned
    in the *ResourceQuota* section, `ResourceQuota` is used to limit the resource
    usage per namespace. Putting the `ResourceQuota` controller at the end of the
    admission controller list could prevent the request from increasing quota usage
    prematurely if it eventually gets rejected by controllers that are put after it,
    if any are.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `LimitRange` 一样，如果你使用 `ResourceQuota` 对象来管理不同级别的 QoS，则必须启用此插件。`ResourceQuota`
    应始终放在准入控制插件列表的末尾。正如我们在 *ResourceQuota* 部分提到的，`ResourceQuota` 用于限制每个命名空间的资源使用。将
    `ResourceQuota` 控制器放在准入控制器列表的末尾，可以防止在请求最终被后面的控制器拒绝之前，过早地增加配额使用。
- en: DefaultTolerationSeconds
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DefaultTolerationSeconds
- en: The `DefaultTolerationSeconds` plugin is used to set pods without any toleration
    sets. It will then apply for the default toleration for the `notready:NoExecute`
    and `unreachable:NoExecute` taints for 300 seconds. If you don't want this behavior
    to occur in the cluster, disable this plugin. For more information, please refer
    to the taints and tolerations section of [Chapter 8](a7a72300-181d-41ad-a08a-7e42744d365f.xhtml),
    *Resource Management and Scaling*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultTolerationSeconds` 插件用于设置没有任何容忍设置的 pod。它会为 `notready:NoExecute` 和 `unreachable:NoExecute`
    污点应用默认容忍，持续 300 秒。如果你不希望集群中发生此行为，可以禁用此插件。更多信息，请参阅 [第 8 章](a7a72300-181d-41ad-a08a-7e42744d365f.xhtml)
    中的污点和容忍部分，*资源管理和扩展*。'
- en: PodNodeSelector
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PodNodeSelector
- en: 'This plugin is used to set the `node-selector` annotation to the namespace.
    When the plugin is enabled, pass along a configuration file with the `--admission-control-config-file`
    command using the following format:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件用于将`node-selector`注解设置到命名空间。当启用此插件时，使用`--admission-control-config-file`命令传递一个配置文件，格式如下：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: By doing this, the `node-selector` annotation will be applied to the `namespace`.
    The pods on that namespace will then run on those matched nodes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`node-selector`注解将应用于该`namespace`。该命名空间中的Pod将运行在匹配的节点上。
- en: AlwaysPullImages
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AlwaysPullImages
- en: The pull policy defines the behavior when kubelet pulls images. The default
    pull policy is `IfNotPresent`, that is, it will pull the image if it is not present
    locally. If this plugin is enabled, the default pull policy will become `Always`,
    which is to always pull the latest image. This plugin also brings another benefit
    if your cluster is shared by different teams. Whenever a pod is scheduled, it'll
    always pull the latest image, regardless of whether the image exists locally or
    not. Then, we can ensure that a pod creation request always goes through an authorization
    check against the image.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取策略定义了kubelet拉取镜像时的行为。默认的拉取策略是`IfNotPresent`，即如果镜像在本地不存在，则会拉取该镜像。如果启用了此插件，默认的拉取策略将变为`Always`，即始终拉取最新的镜像。如果集群由不同团队共享，这个插件还带来另一个好处：每当调度一个Pod时，它将始终拉取最新镜像，无论镜像是否已存在本地。这样，我们可以确保Pod创建请求始终通过对镜像的授权检查。
- en: DenyEscalatingExec
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DenyEscalatingExec
- en: This plugin prevents any `kubectl exec` or `kubectl attach` commands from making
    pods escalate to privilege mode. Pods within privilege mode have access to the
    host namespace, which could become a security risk.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件可以防止任何`kubectl exec`或`kubectl attach`命令使Pod升级到特权模式。处于特权模式中的Pod可以访问主机命名空间，这可能会成为安全风险。
- en: Other admission controller plugins
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他Admission控制插件
- en: There are many other admission controller plugins we could use, such as `NodeRestriciton`
    to limit kubelet's permission, `ImagePolicyWebhook` to establish a webhook to
    control the access of the images, and `SecurityContextDeny` for controlling the
    privilege for a pod or a container. Please refer to the official documentation
    at [https://kubernetes.io/docs/admin/admission-controllers](https://kubernetes.io/docs/admin/admission-controllers/)
    to learn more about other plugins.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用许多其他Admission控制插件，例如`NodeRestriction`，用于限制kubelet的权限，`ImagePolicyWebhook`，用于建立Webhook来控制镜像访问，和`SecurityContextDeny`，用于控制Pod或容器的权限。有关其他插件的更多信息，请参阅官方文档：[https://kubernetes.io/docs/admin/admission-controllers](https://kubernetes.io/docs/admin/admission-controllers/)。
- en: Dynamic admission control
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态Admission控制
- en: 'Before Kubernetes 1.7, admission controllers were compiled with Kubernetes
    API server, so they could only be configured before the API server started. Dynamic
    admission control aimed to break this limitation. There are two methods to implement
    custom dynamic admission control: via initializer and admission webhooks. The
    Initializer webhook can watch an uninitialized workload and check whether it needs
    to take any action against it.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes 1.7之前，Admission controllers是与Kubernetes API服务器一起编译的，因此它们只能在API服务器启动之前进行配置。动态Admission控制旨在打破这一限制。实现自定义动态Admission控制有两种方法：通过初始化器和Admission
    webhook。初始化器Webhook可以监视未初始化的工作负载，并检查是否需要对其采取任何操作。
- en: The Admission webhook intercepts the request and checks the preset rules from
    its configuration before deciding whether the requests are allowed or not. Both
    the initializer and admission webhooks can admit and mutate the resource request
    on certain operations, so we can leverage them to force policies or validate whether
    the requests fulfill the requirement of your organization. Buggy initializer and
    admission webhooks might block all the target resources from being created. However,
    the Admission webhook provides a failure policy, which can address when the webhook
    server doesn't respond as expected.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Admission webhook拦截请求并检查其配置中的预设规则，然后决定是否允许请求。初始化器和Admission webhook都可以在某些操作上允许和修改资源请求，因此我们可以利用它们强制执行策略或验证请求是否满足组织的要求。故障的初始化器和Admission
    webhook可能会阻止所有目标资源的创建。然而，Admission webhook提供了一种失败策略，当Webhook服务器没有按预期响应时，可以解决此问题。
- en: 'At the time of writing this book, the admission webhook has been promoted to
    beta, but the Initializer is still alpha. In this section, we''ll implement a
    simple Admission webhook controller, which will verify whether the `{"chapter":
    "5"}` annotation is set to the `podSpec` during pod creation. The request will
    go through if the annotation is set. If not, the request will fail.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '在撰写本书时，Admission webhook 已经升至 beta 版本，但 Initializer 仍处于 alpha 阶段。在本节中，我们将实现一个简单的
    Admission webhook 控制器，该控制器将在 pod 创建期间验证 `{"chapter": "5"}` 注解是否已设置到 `podSpec`
    中。如果设置了注解，请求将继续；如果没有设置，请求将失败。'
- en: Admission webhook
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Admission webhook
- en: 'There are two major components to implementing an Admission webhook controller:
    a webhook HTTP server to receive the resource life event and a `ValidatingWebhookConfiguration`
    or `MutatingWebhookConfiguration` resource configuration file. Please refer to [https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter5/5-3_admission-webhook/sample-validating-admission-webhook](https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter5/5-3_admission-webhook/sample-validating-admission-webhook)
    for the source code of our sample Admission webhook.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 Admission webhook 控制器有两个主要组件：一个 webhook HTTP 服务器，用于接收资源生命周期事件，以及一个 `ValidatingWebhookConfiguration`
    或 `MutatingWebhookConfiguration` 资源配置文件。请参考 [https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter5/5-3_admission-webhook/sample-validating-admission-webhook](https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter5/5-3_admission-webhook/sample-validating-admission-webhook)
    获取我们的示例 Admission webhook 的源代码。
- en: Let's look at how to write a `ValidatingWebhookConfiguration`. As we can see
    in the following code, like normal objects, `ValidatingWebhookConfiguration` has
    an API version, a kind, and metadata with a name and labels. The important session
    is named `webhooks`. In `webhooks`, one or more rules need to be defined. Here,
    we are defining a rule that is triggered on any pod's creation request (`operations=CREATE,
    resources=pods`). The `failurePolicy` is used to determine the action if an error
    occurs when calling the webhook. The option of `failurePolicy` is either `Fail`
    or ignore (`Fail` means making the request fail, while ignore means the webhook
    error will be ignored). The `clientConfig` session defines the endpoint of the
    webhook server. Here, we are leveraging a Kubernetes service named `sample-webhook-service-svc`.
    If it's an external server, the URL could be specified directly rather than using a
    service. The `caBundle` is used to validate the webhook's server certificate.
    If not specified, by default, it'll use API server's system trust roots.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何编写 `ValidatingWebhookConfiguration`。正如我们在以下代码中看到的，像普通对象一样，`ValidatingWebhookConfiguration`
    有一个 API 版本、一个类型和带有名称和标签的元数据。重要的部分是名为 `webhooks` 的部分。在 `webhooks` 中，需要定义一个或多个规则。在这里，我们定义了一个规则，该规则在任何
    pod 创建请求时触发（`operations=CREATE, resources=pods`）。`failurePolicy` 用于确定在调用 webhook
    时出现错误时的处理方式。`failurePolicy` 的选项为 `Fail` 或 ignore （`Fail` 表示使请求失败，而 ignore 表示忽略
    webhook 错误）。`clientConfig` 部分定义了 webhook 服务器的端点。这里，我们利用了一个名为 `sample-webhook-service-svc`
    的 Kubernetes 服务。如果是外部服务器，可以直接指定 URL，而不是使用服务。`caBundle` 用于验证 webhook 服务器的证书。如果未指定，默认情况下会使用
    API 服务器的系统信任根证书。
- en: 'To export `caBundle` from Kubernetes Service, use the `kubectl get configmap
    -n kube-system extension-apiserver-authentication -o=jsonpath=''{.data.client-ca-file}''
    | base64 | tr -d ''\n''` command and replace the `${CA_BUNDLE}` field as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Kubernetes 服务导出 `caBundle`，请使用 `kubectl get configmap -n kube-system extension-apiserver-authentication
    -o=jsonpath='{.data.client-ca-file}' | base64 | tr -d '\n'` 命令，并按以下方式替换 `${CA_BUNDLE}`
    字段：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To make a webhook HTTP server, we create a simple express web application in
    Node.js ([https://expressjs.com/](https://expressjs.com/)). The main logic of
    the application is to receive a pod creation event and send an `admissionResponse` ([https://github.com/kubernetes/api/blob/master/admission/v1beta1/types.go#L81](https://github.com/kubernetes/api/blob/master/admission/v1beta1/types.go#L81))
    back. Here, we''ll return an `admissionResponse` with the `allowed` field, which
    indicates whether a request is allowed or denied:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个 webhook HTTP 服务器，我们在 Node.js 中创建了一个简单的 express Web 应用程序（[https://expressjs.com/](https://expressjs.com/)）。该应用的主要逻辑是接收
    pod 创建事件并发送 `admissionResponse` ([https://github.com/kubernetes/api/blob/master/admission/v1beta1/types.go#L81](https://github.com/kubernetes/api/blob/master/admission/v1beta1/types.go#L81))
    响应。这里，我们将返回一个带有 `allowed` 字段的 `admissionResponse`，该字段指示请求是否被允许或拒绝：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding function, we checked whether `object.metadata.annotations.chapter`
    is annotated in the pod and whether the chapter is equal to `5`. If it is, the
    webhook server will pass the request. The webhook and API servers need to establish
    a mutual trust. To do this, we''ll generate a certificate for the webhook server
    by requesting a certificate signing through the `certificates.k8s.io` API. The
    popular service mesh implementation, Istio ([https://istio.io/](https://istio.io/)),
    has a useful tool for us ([https://raw.githubusercontent.com/istio/istio/41203341818c4dada2ea5385cfedc7859c01e957/install/kubernetes/webhook-create-signed-cert.sh](https://raw.githubusercontent.com/istio/istio/41203341818c4dada2ea5385cfedc7859c01e957/install/kubernetes/webhook-create-signed-cert.sh)):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的函数中，我们检查了`object.metadata.annotations.chapter`是否在pod中被注解，并且该章节是否等于`5`。如果是，webhook服务器将通过请求。webhook和API服务器需要建立相互信任。为了做到这一点，我们将通过请求`certificates.k8s.io`
    API进行证书签名，从而为webhook服务器生成证书。流行的服务网格实现Istio（[https://istio.io/](https://istio.io/)）提供了一个有用的工具（[https://raw.githubusercontent.com/istio/istio/41203341818c4dada2ea5385cfedc7859c01e957/install/kubernetes/webhook-create-signed-cert.sh](https://raw.githubusercontent.com/istio/istio/41203341818c4dada2ea5385cfedc7859c01e957/install/kubernetes/webhook-create-signed-cert.sh)）：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`server-key.pem` and `server-cert.pem` will be generated via the script under
    the default `temp` folder in your operating system. Copying them can put them
    under the `src/keys` folder inside our sample webhook HTTP server. Now, it''s
    time to build the application with docker via `docker build -t $registry/$repository:$tag
    .` and push the target docker image to the registry (here, we used `devopswithkubernetes/sample-webhook-service:latest`).
    After doing this, we can launch the webserver:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`server-key.pem`和`server-cert.pem`将在默认的`temp`文件夹下通过脚本生成。复制它们并将其放入我们示例webhook
    HTTP服务器中的`src/keys`文件夹内。现在，使用`docker build -t $registry/$repository:$tag .`通过docker构建应用程序，并将目标docker镜像推送到注册表（在此，我们使用了`devopswithkubernetes/sample-webhook-service:latest`）。完成此操作后，我们可以启动web服务器：'
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After checking that the pod is up and running, we can create a `ValidatingWebhookConfiguration`
    resource:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认pod已启动并运行后，我们可以创建一个`ValidatingWebhookConfiguration`资源：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s try deploying two `nginx` pods without any annotations:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试部署两个没有任何注解的`nginx` pod：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is supposed to create two pods; however, we did not see any `nginx` pods
    being created. We can only see our webhook service pod:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会创建两个pod；然而，我们没有看到任何`nginx` pod被创建。我们只能看到我们的webhook服务pod：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we check the corresponding `ReplicaSet`, and use `kubectl describe rs $RS_NAME`
    to check the events, we will get the following result:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查相应的`ReplicaSet`，并使用`kubectl describe rs $RS_NAME`来检查事件，我们将得到以下结果：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'From this, we can see that the admission webhook denies the request. Delete
    and recreate the deployment by using the `uncomment` annotation in the preceding
    code block:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里我们可以看出，准入webhook拒绝了请求。通过使用前述代码块中的`uncomment`注解来删除并重新创建部署：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we do this, we should be able to see that the `nginx` pods are created accordingly:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这么做，应该能够看到`nginx` pod被相应创建：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The request passed through the authentication, authorization, and admission
    controls, including our webhook service. The pod objects were created and scheduled
    accordingly.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请求已通过认证、授权和准入控制，包括我们的webhook服务。pod对象已相应创建并调度。
- en: Please remember to clean up after testing the dynamic admission controllers.
    It might block pod creation in future experiments.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在测试动态准入控制器后要进行清理。它可能会阻止未来实验中的pod创建。
- en: Custom resources
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义资源
- en: 'Custom resources, which were first introduced in Kubernetes 1.7, were designed
    as an extension point to let users create custom API objects and act as native
    Kubernetes objects. This was done so that users could extend Kubernetes to support
    the custom objects for their application or specific use cases. Custom resources
    can be dynamically registered and unregistered. There are two ways to create custom
    resources: by using a CRD or aggregated API. CRDs are much easier, while an aggregated
    API requires additional coding in Go. In this section, we''ll learn how to write
    a CRD from scratch.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源首次在Kubernetes 1.7中引入，旨在作为一个扩展点，让用户创建自定义API对象，并作为本机Kubernetes对象使用。这样做是为了让用户能够扩展Kubernetes，支持其应用程序或特定用例的自定义对象。自定义资源可以动态注册和注销。有两种方式可以创建自定义资源：使用CRD或聚合API。CRD要容易得多，而聚合API需要在Go中进行额外的编码。在本节中，我们将学习如何从零开始编写一个CRD。
- en: Custom resources definition
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义资源定义
- en: 'Creating a **Custom Resources Definition** (**CRD**) object includes two steps:
    CRD registration and object creation.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 创建**自定义资源定义**（**CRD**）对象包括两个步骤：CRD 注册和对象创建。
- en: 'Let''s create a CRD configuration first:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个 CRD 配置：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With `CustomResourceDefinition`, we can define our own spec for the custom
    object. First, we''ll have to decide on the name of the CRD. The naming convention for
    a CRD must be `spec.names.plural+"."+spec.group`. Next, we''ll define the group,
    version, scope, and names. The scope is either `Namespaced` or `Cluster` (non-namespaced).
    After Kubernetes 1.13, we can add a validation section to validate the custom
    objects via the OpenAPI v3 schema ([https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject)).
    We can define the required fields, as well as the spec and validation condition
    for each field. In the preceding example, we created a custom object named `books.devops.kubernetes.com`
    that has three properties: `name`, `edition`, and `chapter`. `name` and `edition`
    are required during object creation. Let''s create the CRD via the `kubectl` command.
    We can also list all the CRDs via the `kubectl get crd` command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CustomResourceDefinition`，我们可以为自定义对象定义自己的规格。首先，我们需要决定 CRD 的名称。CRD 的命名规则必须是`spec.names.plural+"."+spec.group`。接下来，我们将定义组、版本、范围和名称。范围可以是`Namespaced`或`Cluster`（非命名空间）。在
    Kubernetes 1.13 之后，我们可以添加验证部分，通过 OpenAPI v3 模式验证自定义对象（[https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject)）。我们可以定义所需字段以及每个字段的规格和验证条件。在前面的示例中，我们创建了一个名为`books.devops.kubernetes.com`的自定义对象，它有三个属性：`name`、`edition`
    和 `chapter`。`name`和`edition`在对象创建时是必需的。让我们通过`kubectl`命令创建 CRD。我们还可以通过`kubectl
    get crd`命令列出所有的 CRD：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we''ll create an object accordingly. In `spec`, `name`, and `edition`
    are required. The `apiVersion` will be the `<group>/<version>` we defined in the
    preceding CRD configuration:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将根据需要创建一个对象。在`spec`中，`name`和`edition`是必需的。`apiVersion`将是我们在前面的 CRD 配置中定义的`<group>/<version>`：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we set the `edition` to `second`, an error will be thrown, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`edition`设置为`second`，将抛出一个错误，如下所示：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we should be able to get and describe it, just like a normal API object:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够像普通 API 对象一样获取和描述它：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After registering a CRD, a custom controller might be needed to handle custom
    object operations. The custom controller requires additional programming effort.
    There are also multiple tools available in the community that can help us create
    a skeleton controller, such as the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注册 CRD 后，可能需要一个自定义控制器来处理自定义对象操作。自定义控制器需要额外的编程工作。社区中也有多种工具可以帮助我们创建骨架控制器，例如以下工具：
- en: Controller: [https://github.com/kubernetes/sample-controller](https://github.com/kubernetes/sample-controller)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器：[https://github.com/kubernetes/sample-controller](https://github.com/kubernetes/sample-controller)
- en: Kubebuilder: [https://github.com/kubernetes-sigs/kubebuilder](https://github.com/kubernetes-sigs/kubebuilder)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubebuilder：[https://github.com/kubernetes-sigs/kubebuilder](https://github.com/kubernetes-sigs/kubebuilder)
- en: 'Operator: [https://coreos.com/operators/](https://coreos.com/operators/)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作器：[https://coreos.com/operators/](https://coreos.com/operators/)
- en: With the sample controller (provided by Kubernetes), a set of `ResourceEventHandlerFuncs`
    will be added into `EventHandler` for handling object life cycle events, such
    as `AddFunc` for `UpdateFunc` and `DeleteFunc`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用示例控制器（由 Kubernetes 提供），将一组`ResourceEventHandlerFuncs`添加到`EventHandler`中，用于处理对象生命周期事件，如`AddFunc`、`UpdateFunc`和`DeleteFunc`。
- en: Both **Kubebuilder** and **Operator** can simplify the preceding steps. Kubebuilder
    provides support for building APIs via CRDs, controllers, and admission webhooks. Operator,
    which was introduced by CoreOS, is an application-specific controller that's implemented
    with CRD. There are existing operators being implemented by the community, and
    they can be found at [https://github.com/operator-framework/awesome-operators](https://github.com/operator-framework/awesome-operators).
    We'll introduce how to leverage the operator SDK in the Operator framework to
    build a simple controller with the same book CRD.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubebuilder**和**Operator**都可以简化前面的步骤。Kubebuilder 提供支持通过 CRD、控制器和准入 webhook
    构建 API。Operator 是由 CoreOS 引入的应用程序特定控制器，它是通过 CRD 实现的。社区中已有许多操作器被实现，并可以在[https://github.com/operator-framework/awesome-operators](https://github.com/operator-framework/awesome-operators)找到。我们将介绍如何利用
    Operator 框架中的 operator SDK 来构建一个简单的控制器，并使用相同的书籍 CRD。'
- en: 'First, we''ll have to install the operator SDK ([https://github.com/operator-framework/operator-sdk](https://github.com/operator-framework/operator-sdk)).
    We are using v.0.3.0 in the following example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装操作员 SDK（[https://github.com/operator-framework/operator-sdk](https://github.com/operator-framework/operator-sdk)）。在以下示例中，我们使用的是v.0.3.0版本：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s create a new operator named `devops-operator` via the following command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下命令创建一个名为`devops-operator`的新操作员：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After the operator is initialized, we can start adding components to it. Let''s
    add `api` to create an API object and `controller` to handle object operations:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员初始化后，我们可以开始向其中添加组件。让我们添加`api`来创建API对象，并添加`controller`来处理对象操作：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'There are multiple files we need to modify. The first one is API spec. In the
    previous CRD example, we added three custom properties in the `book` resource:
    `name`, `edition`, and `chapter`. We''ll need to add that into spec here, too.
    This can be found under `pkg/apis/devops/v1alpha1/book_types.go`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个文件需要修改。第一个是API规范。在之前的CRD示例中，我们在`book`资源中添加了三个自定义属性：`name`、`edition`和`chapter`。我们也需要在这里的spec中添加它。这可以在`pkg/apis/devops/v1alpha1/book_types.go`中找到：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Run `operator-sdk generate k8s` after modifying the file, as shown in the preceding
    code. Next, we will add some custom logic to the controller logic. This is located
    in the `Reconcile` function in `pkg/controller/book/book_controller.go`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 修改文件后，运行`operator-sdk generate k8s`，如前面的代码所示。接下来，我们将向控制器逻辑中添加一些自定义逻辑。这部分位于`pkg/controller/book/book_controller.go`的`Reconcile`函数中。
- en: 'In the existing example that was created by the framework, the controller will
    receive a `podSpec`. This is exactly what we need, and we''ll just get the `name`
    and `edition` from the `Spec` and print it out in `busybox` `stdout`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架创建的现有示例中，控制器将接收`podSpec`。这正是我们需要的，我们只需从`Spec`中获取`name`和`edition`，并将其打印到`busybox`的`stdout`中：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Then, we can run `operator-sdk build devopswithkubernetes/sample-operator` to
    build the docker image and push it to a registry. Here, we'll just push it to
    our public docker hub, `docker push devopswithkubernetes/sample-operator`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以运行`operator-sdk build devopswithkubernetes/sample-operator`来构建Docker镜像并将其推送到镜像仓库。这里，我们将其推送到公共的Docker
    Hub，`docker push devopswithkubernetes/sample-operator`。
- en: 'The operator is done! After that, we can start looking into how to deploy it.
    The deployment scripts are automatically created in the `deploy` folder. The file
    we need to change is `operator.yaml`, which specifies the operator container image.
    Find the `image: REPLACE_IMAGE` line in `podSpec` and update that so that it points
    into your registry (here, we''ll point it to `devopswithkubernetes/sample-operator`).
    Now, it''s good to deploy:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '操作员已完成！之后，我们可以开始研究如何部署它。部署脚本会自动创建在`deploy`文件夹中。我们需要修改的文件是`operator.yaml`，它指定了操作员容器镜像。找到`image:
    REPLACE_IMAGE`行并更新，使其指向你的镜像仓库（这里，我们将其指向`devopswithkubernetes/sample-operator`）。现在，可以进行部署了：'
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, you should be able to see an operator pod when listing the pods:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当列出Pod时，你应该能够看到一个操作员Pod：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, let''s create a `Book` resource. You could modify `deploy/crds/devops_v1alpha1_book_cr.yaml`
    in the current folder or reuse `5-4_crd/5-4-2_objectcreation.yaml` from our repo:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`Book`资源。你可以修改当前文件夹中的`deploy/crds/devops_v1alpha1_book_cr.yaml`，或者重用我们仓库中的`5-4_crd/5-4-2_objectcreation.yaml`：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, we should be able to see that another pod was created by the CRD, and
    we can also check its logs:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该能够看到CRD创建了另一个Pod，我们也可以查看它的日志：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Hurray! Everything looks fine. Here, we have demonstrated a very simple example.
    Of course, we could leverage this concept and evolve more sophisticated logic
    and handlers.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！一切看起来都很不错。这里，我们展示了一个非常简单的示例。当然，我们可以利用这个概念，发展出更复杂的逻辑和处理器。
- en: 'Application CRD:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 应用CRD：
- en: A containerized application might contain multiple Kubernetes resources, such
    as deployments, services, `ConfigMaps`, secrets, as well as custom CRDs. An application
    CRD has been implemented at [https://github.com/kubernetes-sigs/application](https://github.com/kubernetes-sigs/application),
    providing a bridge to make application metadata describable. It also has application
    level health checks so that users don't need to list all the resources after deployment
    and check whether the application has been deployed properly. Instead, they list
    the application CRD and check its status.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一个容器化的应用可能包含多个 Kubernetes 资源，例如部署、服务、`ConfigMaps`、secrets，以及自定义 CRD。在[https://github.com/kubernetes-sigs/application](https://github.com/kubernetes-sigs/application)中实现了一个应用
    CRD，它提供了一个桥梁，使应用的元数据可以被描述。它还具有应用级别的健康检查，这样用户就不需要在部署后列出所有资源并检查应用是否正确部署。相反，用户只需列出应用
    CRD并检查其状态。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about what `namespace` and `context` are, including
    how they work, and a how to switch between a physical cluster and virtual cluster
    by setting the context. We then learned about an important object—service account,
    which provides the ability to identify processes that are running within a pod.
    Then, we familiarized ourselves with how to control access flow in Kubernetes.
    We learned what the difference is between authentication and authorization, and
    how these work in Kubernetes. We also learned how to leverage RBAC to have fine-grained
    permission for users. In addition, we looked at a couple of admission controller
    plugins and dynamic admission controls, which are the last goalkeepers in the
    access control flow. Finally, we learned about what the CRD is and implemented
    it and its controller via the operator SDK ([https://github.com/operator-framework/operator-sdk](https://github.com/operator-framework/operator-sdk))
    in the operator framework.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了`namespace`和`context`的概念，了解了它们的工作原理，以及如何通过设置上下文在物理集群和虚拟集群之间切换。接着，我们学习了一个重要的对象——服务账户，它提供了识别在
    pod 内运行的进程的能力。然后，我们熟悉了如何控制 Kubernetes 中的访问流。我们了解了认证与授权的区别，以及它们在 Kubernetes 中是如何工作的。我们还学习了如何利用
    RBAC 为用户提供细粒度的权限。此外，我们还了解了一些 admission controller 插件和动态准入控制，它们是访问控制流中的最后一道防线。最后，我们学习了
    CRD 的概念，并通过操作员 SDK ([https://github.com/operator-framework/operator-sdk](https://github.com/operator-framework/operator-sdk))
    在操作员框架中实现了它和它的控制器。
- en: In [Chapter 6](fc67e008-b601-45a6-8297-d2fa28360b1f.xhtml), *Kubernetes Network*,
    we'll move on and learn more about cluster networking.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第六章](fc67e008-b601-45a6-8297-d2fa28360b1f.xhtml)，*Kubernetes 网络*，我们将继续深入学习集群网络。
