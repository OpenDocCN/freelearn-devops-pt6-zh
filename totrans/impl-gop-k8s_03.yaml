- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Version Control and Integration with Git and GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our exploration has shed light on the foundational concepts of GitOps
    and its critical role in managing cloud-native operations. This journey has involved
    unpacking the principles, benefits, and transformative nature of GitOps in infrastructure
    management, as well as its capacity to enhance and streamline cloud-native processes.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will further expand on these concepts. It will delve into the significance
    of Git in **version control**, an essential component of modern software development.
    The chapter will also explore GitHub’s contribution to collaborative development
    and how it can be maximized for team efficiency. Additionally, it will discuss
    the integration of GitOps practices with Git and GitHub, highlighting automated
    integration processes.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter outlines the best practices for utilizing Git and GitHub within
    a GitOps framework, aiming to enhance workflow efficiency and promote a strong
    DevOps culture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll focus on these key areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Version control systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Git?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating GitOps and GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To fully engage with the concepts and practices presented in this chapter, there
    are a few technical requirements. You should have a basic understanding of software
    development processes and a familiarity with command-line tools. Access to a computer
    with internet connectivity is necessary to follow along with examples involving
    Git and GitHub. This hands-on approach will enable you to apply the theories and
    practices of GitOps in real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter is available in the `Chapter03` folder of our GitHub
    repository at [https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes](https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring version control systems – local, centralized, and distributed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Version control systems** (**VCSs**) are essential tools in modern software
    development, as they are responsible for enabling efficient management of changes
    to files, especially code. Git, a widely used VCS, exemplifies this by tracking
    modifications, allowing users to view and revert to specific versions of files
    as needed. This functionality is crucial for collaborative projects, where it
    provides a comprehensive record of who made changes, when, and why, enhancing
    accountability and clarity.'
  prefs: []
  type: TYPE_NORMAL
- en: At its core, version control is about recording changes over time. This makes
    it easier to recover previous states of a project, whether for fixing bugs, testing,
    or undoing changes. It’s not limited to software code; version control can be
    applied to any file type, making it an asset for professionals such as graphic
    or web designers who might need to manage different versions of their work. The
    use of a VCS minimizes risks associated with file loss or errors, as it provides
    a safety net for easily reverting to earlier states and understanding the evolution
    of a project. This leads to increased efficiency and a more structured workflow
    with minimal overhead.
  prefs: []
  type: TYPE_NORMAL
- en: By integrating version control into their workflow, teams and individuals gain
    a powerful tool to navigate the complexities of project development, ensuring
    a smoother, more controlled process of continuous improvement and collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: 'VCS can be categorized into three main types: local, centralized, and distributed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local VCSs** (**LVCSs**): These are the simplest forms. They involve keeping
    track of changes in files on a local computer, typically using a database that
    stores all the changes to files under revision control. This system is straightforward
    but has limitations, especially in the contexts of collaboration and data backup.
    *Figure 3**.1* shows an example of LVCS on the left side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Centralized VCSs** (**CVCSs**): These systems, such as **Subversion** (**SVN**),
    have a single server that contains all versioned files. Various clients check
    out files from this central place. This setup significantly enhances collaboration
    compared to LVCS, as everyone knows what everyone else is working on. However,
    the central server is also a single point of failure; if it goes down, no one
    can collaborate or save versioned changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.1 – An example of LCVS and CVCS](img/B22100_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – An example of LCVS and CVCS
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent version systems and SVN
  prefs: []
  type: TYPE_NORMAL
- en: The **Concurrent Versions System** (**CVS**) was an early version control system
    that enabled collaborative software development by allowing teams to work simultaneously
    on a project using a centralized repository. However, it had limitations, especially
    in handling binary files. It also lacked advanced features. SVN was developed
    as a modern alternative to CVS, addressing these shortcomings. SVN, also a centralized
    system, improved collaboration by allowing multiple users to work efficiently
    on a project with a centralized source for file changes, enhancing the tracking
    and management of changes made by different team members.
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributed VCSs** (**DVCSs**): Systems such as Git fall into this category.
    Instead of a single central repository, each user has a complete copy of the entire
    repository. This approach allows for more complex workflows, increases redundancy
    and backup options, and enables offline work. It also allows for various forms
    of **merging** and **branching**, offering a more flexible approach to version
    control, especially for large-scale projects with many contributors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.2 – An example of DVCS](img/B22100_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – An example of DVCS
  prefs: []
  type: TYPE_NORMAL
- en: Having explored the landscape of VCSs—including LVCSs, CVCSs, and DVCSs, each
    offering distinct benefits and suited to specific project needs—it’s clear why
    Git stands out among DVCSs. Let’s delve deeper into the unique advantages and
    capabilities that make Git an essential tool in modern software development in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Why Git?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The story of Git begins with the developmental challenges of the Linux kernel
    project in the early 2000s. This period saw Linus Torvalds, the creator of Linux,
    facing a dilemma with the existing version control tools. The limitations and
    restrictions of the proprietary DVCS, BitKeeper, used by the Linux community at
    that time, led to the need for a new system. This spurred the creation of Git
    in 2005, marking a significant turn in the version control system landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Git was designed with specific goals in mind, drawing from the lessons learned
    during the use of BitKeeper. Key among these were speed, simple design, and robust
    support for non-linear development. The system was tailored to handle large projects
    such as the Linux kernel efficiently both in terms of speed and data size. This
    focus on efficiency and flexibility was crucial given the scale and complexity
    of such projects.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of Git is unique and effective. It is a distributed version control
    system, meaning that every user has the complete history of the project stored
    locally. This design not only enhances speed but also enables a more flexible
    and secure approach to version control. **Repositories** in Git are comprehensive,
    containing **commits**, which are essentially snapshots of the project at various
    stages, as well as references to these commits (known as **heads**). Over the
    years, Git has evolved and matured, retaining its initial qualities while becoming
    more user-friendly. Its integration with platforms such as GitHub (we will delve
    into more details about GitHub in the *Exploring GitHub* section of this chapter),
    **Bitbucket**, and **GitLab** has further amplified its capabilities, providing
    centralized hubs for collaboration, code sharing, and project management.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the widespread adoption of Git, it’s worth noting that the GitHub
    community announced having surpassed 100 million developers on their platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.blog/2023-01-25-100-million-developers-and-counting/](https://github.blog/2023-01-25-100-million-developers-and-counting/)'
  prefs: []
  type: TYPE_NORMAL
- en: The adoption of Git in GitOps practices underscores its reliability and efficiency,
    making it a cornerstone in modern software development and version control.
  prefs: []
  type: TYPE_NORMAL
- en: Having understood the importance of Git from various perspectives, we will now
    shift our focus to a more practical approach. In the upcoming sections, we’ll
    begin with the basics of Git commands and examples to offer a hands-on experience.
  prefs: []
  type: TYPE_NORMAL
- en: Git setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter doesn’t cover the details of Git installation in depth, but you
    can find a thorough, step-by-step guide in the official Git documentation (refer
    to [1] in the *Further reading* section at the end of this chapter). For the purposes
    of our discussions, we’ll assume that Git is already installed on a **Windows
    Subsystem for Linux** (**WSL**) Ubuntu 22.04 distribution. It is important to
    underline that Git can be natively installed on Windows (without WSL), macOS,
    and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: For additional information on setting up WSL, please refer to [*Chapter 2*](B22100_02.xhtml#_idTextAnchor027),
    particularly the *Setup of WSL* section, which provides relevant guidance and
    insights.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify your Git installation, you can enter a specific command in your command
    prompt. This command will help you confirm that Git is properly installed and
    functioning on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected response should resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Great job! In the following sections, we will delve into the basics of Git,
    explore its commands, and examine the most interesting features that are essential
    for GitOps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and cloning a Git repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Git repository is a cornerstone in the Git version control system, encompassing
    all project files and their revision histories. It’s marked by the `.git` directory
    containing necessary change-tracking data. Repositories exist either as local
    entities on a user’s computer or as remote versions on servers such as GitHub,
    enabling both individual work and collaborative efforts. They play a crucial role
    in project version management and evolution, storing files and histories as commits
    in a structured, linked-list format. This setup supports varied interactions such
    as **cloning** (creating a local copy of a repository from a remote server), **branching**
    (diverging from the main code base to create separate versions for development
    or testing without affecting the original code), and **code version comparisons**
    (examining the differences between various versions of code files to track changes
    or merge updates).
  prefs: []
  type: TYPE_NORMAL
- en: 'A Git repository can be started using two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git init`: This command is used to initialize a new Git repository in a directory
    that is not currently under version control. Executing this command creates a
    hidden subfolder named `.git` in the directory, setting up the necessary structure
    for repository management and version control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git clone`: This command is used to create a local copy of an existing Git
    repository, typically one that’s hosted remotely such as on GitHub. When you clone
    a repository, it downloads not only the project’s files but also its complete
    history and all branches into your local repository. This process ensures that
    you have the entire development history of the project at your disposal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open the command prompt and activate a WSL instance, as detailed in [*Chapter
    2*](B22100_02.xhtml#_idTextAnchor027), in the *Setup WSL* section, then follow
    the ensuing numbered steps to create and clone a Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory named `Chapter_3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once in the `Chapter_3` directory, you are ready to initialize a new Git repository
    using the `git init` command. This step is crucial for starting version control
    in your new project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output from the command should look something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By listing the contents of the working directory using the `ls -a` command,
    you should be able to see the newly created `.git` hidden directory. This directory
    is an indication that the Git repository has been successfully initialized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ls -a ./git
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: .  ..  HEAD  branches  config  description  hooks  info  objects  refs
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To initialize a repository by cloning it, you should first navigate to a different
    directory. Once there, execute the clone command with the appropriate URL to create
    a copy of an existing Git repository in that new location. This process will replicate
    the repository, including its history and branches, into your specified directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output from the command should look something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now learned how to create a new repository from scratch or by cloning
    an existing one. Next, we’ll focus on understanding and using basic Git commands
    to start recording changes in our repository. This step is crucial for managing
    and tracking the evolution of your project files.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Understanding the basics of Git involves familiarizing yourself with a set
    of fundamental commands that facilitate version control in software development.
    These commands enable you to track and manage changes to your project’s files,
    offering control over every aspect of its evolution. From staging and committing
    changes to managing branches and updating your project with the latest developments,
    mastering these commands is essential for the effective use of Git. This introductory
    overview will guide you through key commands such as `git status`, `git add`,
    `git commit`, `git branch`, `git merge`, `git pull`, and `git push`, each playing
    a critical role in the Git workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git status`: This command shows the status of changes, indicating whether
    they are untracked, modified, or staged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git add`: This command stages changes for inclusion in your project’s history.
    It prepares the changes for the next step, allowing you to control what becomes
    part of the project’s history.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git commit`: This command saves the staged changes to the project’s history,
    functioning like capturing a snapshot. It finalizes what you have staged with
    `git add`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git branch`: Use this to view the branches being worked on locally, giving
    insight into the various lines of development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git merge`: This merges different lines of development and is commonly used
    to integrate changes from one branch into another (e.g., merging a `feature` branch
    into the `master` branch).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git fetch`: This command updates your local database of changes from a remote
    repository, which is useful for reviewing updates before integrating them into
    your local branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git pull`: This updates your local development line with changes from its
    remote counterpart. It is useful when you need to reflect changes made by others
    in your local environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git push`: This updates the remote repository with commits made locally, ensuring
    that the remote repository reflects your recent changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic Git commit-status-push loop example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with a practical example of how to use Git locally using the commands
    listed in the *The basics of Git* section. You are free to use the repository
    initialized in the *Creating and cloning a Git repository* section of this chapter
    or to start with a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up a GIT identity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ git status
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On branch master
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: No commits yet
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nothing to commit (create/copy files and use "git add" to track)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new non-empty file in the working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the `git status` command again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To track modifications, to add the new file, use the `git` `add` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On branch master
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: No commits yet
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changes to be committed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (use "git rm --cached <file>..." to unstage)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: README is now marked as staged because it appears under the Changes to be committed
    section, indicating that it’s ready for the next commit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With our staging area prepared as desired, it’s now time to record our changes
    in the repository’s history using `git commit -m "Add the README file"`, whereby
    we specify the modifications that we’ve implemented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[master (root-commit) f933b54] Add the README file.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1 file changed, 1 insertion(+)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: create mode 100644 README
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Git workflows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The basic Git workflow involves a strategic approach to branching that facilitates
    efficient development and release processes. This strategy includes different
    types of branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Main (or Master)`: The foundational branch where production-ready code is
    maintained throughout the project’s life cycle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Develop`: Initiated alongside the main branch, it houses pre-production code
    and features under testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Feature`: Employed for developing new features, these branches merge back
    into the `develop` branch upon completion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Release`: Dedicated to preparing code for production release'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hotfix`: Addresses urgent fixes directly in the main branch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this workflow, changes are tracked as commits. They document the history
    of file modifications, including what changed, who changed it, and when. This
    structure not only organizes work effectively but also accelerates the release
    cycle by clearly defining the purpose of each branch and streamlining the integration
    of new features, bug fixes, and releases. *Figure 3**.3* illustrates an example
    of a Git workflow.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – An example of a Git workflow](img/B22100_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – An example of a Git workflow
  prefs: []
  type: TYPE_NORMAL
- en: Initially, the content of a repository resides in a default branch. For making
    modifications or additions, it’s recommended to create and work within your own
    branch. This practice ensures that the main code base remains stable while you
    develop features or fixes. Delving deeply into the intricacies of Git, including
    branching, merging, and remote strategies, exceeds the scope of this book. However,
    for those seeking an in-depth exploration, Mastering Git by PACKT, *[3]* in the
    *Further reading* section, offers comprehensive insights into advanced Git concepts.
    It’s an excellent resource for expanding your Git knowledge beyond the basics.
  prefs: []
  type: TYPE_NORMAL
- en: This section concludes our brief exploration of Git, marking the beginning of
    our journey into GitHub. The upcoming section will introduce and delve into GitHub,
    presenting its significance and utility in the world of GitOps.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub is a vital platform in the world of software development, serving as
    a hub for collaborative projects using Git. It extends the functionality of Git
    by providing a web-based graphical interface. GitHub facilitates the hosting of
    both public and private repositories, making it easier for individuals and teams
    to collaborate on projects regardless of their geographical location. Its importance
    lies not just in code storage but also in fostering a community where developers
    can share, contribute to, and build upon each other’s work, enhancing the open
    source development culture.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GitHub account is essential for storing source code on this widely
    used platform. This book will guide you through using GitHub to manage code in
    public and private repositories. Detailed instructions for account creation are
    available on GitHub’s website, where you can find all the information needed to
    get started ([https://github.com/](https://github.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: SSH access offers a secure way to interact with Git repositories, bypassing
    the need for entering a username and password with each command. It’s particularly
    useful for cloning public projects without an account. For forking or pushing
    changes, however, an account is necessary. For detailed setup instructions, refer
    to GitHub’s official SSH access guide ([https://docs.github.com/en/authentication/connecting-to-github-with-ssh](https://docs.github.com/en/authentication/connecting-to-github-with-ssh)).
  prefs: []
  type: TYPE_NORMAL
- en: GitHub significantly enhances collaborative software development by enabling
    remote teamwork and streamlining processes such as bug tracking and continuous
    integration. Its pull request system bolsters collaboration, facilitating code
    review and merging. Moreover, GitHub serves as a comprehensive code hosting platform,
    supporting both public and private repositories, thus bolstering both open source
    and private projects. This accessibility and integration with development tools
    makes GitHub indispensable for developers worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub’s ecosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The GitHub ecosystem is a comprehensive and dynamic environment that extends
    beyond simple code hosting. It encompasses a wide range of tools, integrations,
    community features, and services that support the entire software development
    life cycle. This includes project management tools, issue tracking, continuous
    integration and deployment services, and code review facilities. Additionally,
    GitHub offers a vast community and network of developers contributing to open
    source projects, sharing insights, and collaborating on various initiatives. This
    ecosystem has become an integral part of the software development world, fostering
    innovation and collaboration among developers globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version control**: At its core, GitHub offers Git-based version control for
    managing and tracking code changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issue tracking**: It includes tools for reporting and tracking bugs, feature
    requests, and tasks within projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaboration features**: Features such as pull requests and code reviews
    facilitate collaborative coding and team interaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub actions**: For automation of workflows, such as **Continuous Integration
    and Continuous** **Deployment** (**CI/CD**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project management**: Tools for organizing and prioritizing work, such as
    Projects and Kanban boards'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community and networking**: A platform for developers to contribute to open
    source projects, network, and collaborate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Marketplace**: Offers third-party apps and integrations to extend GitHub
    functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub Pages**: Provides hosting for static websites and documentation directly
    from a GitHub repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security Features**: Includes features for vulnerability scanning and managing
    access controls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having gained an understanding of what GitHub is and how to access it, it’s
    time to shift our focus toward practical applications.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub enhances the software development process by integrating tools for better
    code quality, such as command line operations, issue discussions, pull requests,
    and code reviews, alongside a vast array of apps available in the GitHub Marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: It fosters collaboration through the GitHub flow, enabling developers to efficiently
    manage work within repositories, outline project directions, and seamlessly merge
    updates after thorough discussion and agreement. It thereby transforms the conventional
    methodologies of software construction.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The GitHub flow is a branch-based workflow integrating Git commands for global
    teams. It involves creating branches for parallel development, adding commits
    for reversible project points, and using pull requests to foster transparency
    (see the *Git workflow* section in this chapter). Code review is central, thereby
    promoting an open culture. Merging incorporates changes seamlessly, while deployment
    ensures robust code. This workflow adapts to various collaboration scales, from
    small teams to global contributions, emphasizing pull requests for discussion
    and integration. GitHub’s tools replace traditional email reviews, streamlining
    the development process. We can summarize the GitHub Flow in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a repository. The first thing to do is to create a repository in our
    GitHub space. In the upper corner of any page of each GitHub space, click on **+**
    and then on **New Repository**, as shown in *Figure 3**.4*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Creating a new GitHub repository](img/B22100_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Creating a new GitHub repository
  prefs: []
  type: TYPE_NORMAL
- en: For the repository name, you could choose something such as `gitops-for-k8s-gitops-integration`.
    **Description** is optional. Decide between a private or public repository based
    on your preference for open access or restricted visibility. Ensure that you check
    the **Add a README file** checkbox and then proceed by clicking the **Create repository**
    button, as illustrated in *Figure 3**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – The form for creating a new repository on GitHub](img/B22100_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – The form for creating a new repository on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: Create a branch. By default, the created repository has one branch named `main`
    that is considered the one containing production-ready code. Best practices suggest
    using a different `feature` branch for each feature that we want to implement.
    To create a new branch in GitHub, click the `main` item, as shown in *Figure 3**.6*.
    To create the new branch, click on **Create branch features/docker-file-and-ci**,
    as highlighted in *Figure 3**.6*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Creating a new features/docker-file-and-ci feature branch](img/B22100_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Creating a new features/docker-file-and-ci feature branch
  prefs: []
  type: TYPE_NORMAL
- en: Add commits. It’s time to add some useful files to our repository. For this
    exercise, we will use the same Docker file seen in the *Dockerfile* section of
    [*Chapter 2*](B22100_02.xhtml#_idTextAnchor027) of this book. To add a Docker
    file, click the **Add file** button (see *Figure 3**.7*). If you opt for **Create
    new file**, an editor will open where you can paste the Docker file contents and
    commit. Alternatively, selecting **Upload files** allows you to directly upload
    the Docker file from your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Menu for adding a new file or uploading an existing one](img/B22100_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Menu for adding a new file or uploading an existing one
  prefs: []
  type: TYPE_NORMAL
- en: Copy the content of the Docker file and call the file `dockerfile`, as illustrated
    in *Figure 3**.8*. Click on `requirements.txt` file used in the *Dockerfile* section
    of [*Chapter 2*](B22100_02.xhtml#_idTextAnchor027).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 – The GitHub editor interface for editing a repository file](img/B22100_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – The GitHub editor interface for editing a repository file
  prefs: []
  type: TYPE_NORMAL
- en: 'Adopt best practices for commit messages by specifying the action taken, such
    as `Create dockerfile` as a suggested description and commit your changes. On
    the main page, select the `README` file and add the following line at the beginning,
    then commit the changes with the default description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See *[2]* in the *Further reading* section for a useful list of commit best
    practices.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open a pull request. After making changes in a branch off the `main` branch,
    you can initiate a pull request, which is a core element for collaboration in
    GitHub. This feature allows you to suggest changes, seek a review to merge your
    contributions into another branch, and highlight differences in color. You can
    start a discussion with a pull request immediately after committing, even if the
    code isn’t final. Practicing this with a pull request in your repository by merging
    it yourself is an excellent way to familiarize yourself with GitHub’s collaborative
    flow before moving on to bigger projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the repository’s tab, click on the **Pull requests** tab of our repository
    and click on **New Pull request**. In the **Example Comparison** box, select the
    **features/dockerfile-and-ci** branch to compare with the **main** branch as illustrated
    in *Figure 3**.9*, then click on the **Create pull** **request** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Creating a pull request and select which branches to compare](img/B22100_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Creating a pull request and select which branches to compare
  prefs: []
  type: TYPE_NORMAL
- en: Review the changes in the comparison view at the bottom of the page. If they
    accurately reflect your intended modifications, proceed to create a pull request.
    Assign a title to your pull request and include a concise description of your
    changes, such as detailing the addition of a Docker file and the automation of
    Docker image builds with GitHub Actions. Feel free to enhance your description
    with emojis, images, or GIFs, and then finalize it by creating the pull request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Discuss and review the code. Starting collaboration involves seeking reviews
    from your peers on pull requests. This step enables collaborators to offer feedback
    or suggest edits before finalizing changes to the `main` branch, ensuring a consensus-driven
    approach to code integration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the final step, merge your `features/dockerfile-and-ci` branch into the `main`
    branch to add your updates. Should any conflicts between your pull request and
    the `main` branch emerge, GitHub will prompt you to resolve them prior to merging.
    Assuming that there are no conflicts, the merge should be straightforward. To
    complete the process, select `main` branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve introduced the fundamentals of GitHub and GitFlow alongside a hands-on
    example. We encourage you to practice using Git command line tools for cloning
    repositories, as outlined in the *Git repository* section of this chapter. Armed
    with this essential knowledge, we’re poised to delve into integrating GitOps with
    GitHub, specifically for automating Docker deployments with commits.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating GitOps and GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub Actions offers a powerful automation tool within the GitHub ecosystem,
    enabling developers to streamline their software development workflows. Specifically,
    a GitHub Action can significantly enhance a GitOps workflow by automating the
    building and pushing of Docker images for services, followed by the deployment
    of new versions to Kubernetes clusters. This capability simplifies the CI/CD processes,
    making it easier for teams to maintain and update their applications efficiently
    in a cloud-native environment.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices suggest that when you want to use this GitHub Action, your GitHub
    repository should have a `dev` and a `master` or `main` branch, and that it should
    use tags for releases. In the following example, for brevity, we will work directly
    in the `main` branch. Best practices suggest working in separate branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to automate Docker image creation with GitHub Actions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Actions** in the repository’s tab, as shown in *Figure 3**.10*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.10 – The tab menu with the Actions button circled](img/B22100_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – The tab menu with the Actions button circled
  prefs: []
  type: TYPE_NORMAL
- en: 'On the new page, click on **set up a workflow yourself**, as shown in *Figure
    3**.11*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Manually defining a workflow in GitHub](img/B22100_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Manually defining a workflow in GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'In the editor, add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `name` field serves as the identifier for our action. In the `on` section,
    we specify the events that will trigger this action, primarily focusing on specific
    branches. This is usually set to `main`. If you happen to create a new branch
    and want to trigger this action, you’ll need to modify this section accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Within the `jobs` | `build` section, you’ll find the `runs-on` field, which
    specifies the type of GitHub servers that our job will run on. This is distinct
    from the version of our Docker image, which is determined by `Dockerfile`. In
    this case, our Docker image will be based on Ubuntu 20.04\. The Docker image build
    will take place on GitHub servers running `uses` field instructs the workflow
    to perform a checkout of our repository. The `name` field provides a label for
    the step. Finally, the `run` field specifies the command to execute. With this
    configuration, we are prepared for our first build on the Ubuntu 20.04-based Docker
    image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To initiate a new build, we need to introduce a modification to our `main` branch.
    You can easily accomplish this by making a simple comment change to the Docker
    file within the integrated editor on GitHub or editing the `README` file. In *Figure
    3**.12*, the build is triggered from an update to `README`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.12 – A list of workflows triggered by commits on the Actions page](img/B22100_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – A list of workflows triggered by commits on the Actions page
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve made the change in your repository, GitHub will automatically detect
    it and initiate a new build. You’ll notice an indicator signaling that the build
    has been triggered.
  prefs: []
  type: TYPE_NORMAL
- en: To access the build logs, simply click on **build**, as illustrated in *Figure
    3**.13*. This will lead you to the dedicated page for that build. Once on this
    page, you can delve into the individual steps of the build process and review
    the logs associated with each step, as illustrated in *Figure 3**.14*. GitHub
    also provides email notifications in case of build failures, and you can conveniently
    configure your alerting preferences within the GitHub platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.13 – A summary of a successful build](img/B22100_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – A summary of a successful build
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Detailed steps of the build process with logs for each step](img/B22100_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Detailed steps of the build process with logs for each step
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, you should have a comprehensive understanding of Git, GitFlow,
    GitHub, and how to develop a CI process that builds a Docker image for each commit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter delved into the essential role of Git for version control and GitHub
    for collaborative software development within the GitOps framework. It outlined
    the significance of these tools in enhancing team efficiency, automating deployment
    processes, and fostering a robust DevOps culture. Key areas covered include the
    technical requirements for engaging with Git and GitHub, the benefits of VCSs,
    the functionalities of Git and GitHub, and the integration of GitOps practices.
    The chapter concluded with some best practices for utilizing Git and GitHub to
    streamline workflow efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapters, we will explore additional tools such as Argo CD and
    Flux CD, along with their integration into GitOps, enabling us to complete our
    pipeline with the deployment segment.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1] [https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2] [https://gist.github.com/luismts/495d982e8c5b1a0ced4a57cf3d93cf60](https://gist.github.com/luismts/495d982e8c5b1a0ced4a57cf3d93cf60)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3] [https://www.packtpub.com/product/mastering-git/9781783553754](https://www.packtpub.com/product/mastering-git/9781783553754)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
