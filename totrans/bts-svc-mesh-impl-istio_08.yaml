- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scaling Istio to Multi-Cluster Deployments Across Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Containers** have changed not only how applications are developed but also
    how applications connect. Application networking, that is, networking between
    applications, is critical for production deployments and must be automated, elastically
    scalable, and secure. Real-world applications are deployed across on-premises,
    multiple clouds, Kubernetes clusters, and namespaces within clusters. Hence, there
    is a need to provide a Service Mesh across legacy and modern environments, providing
    seamless connectivity between applications.'
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 3*, we briefly discussed deployment models for Istio control planes.
    We discussed a single cluster with a local control plane, a primary and remote
    cluster with a single control plane, and a single cluster with an external control
    plane. A single-mesh/single-cluster deployment is the simplest but is also a non-practical
    deployment model because your production workload will include multiple Kubernetes
    clusters, possibly spread across multiple data centers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following topics to learn how to deploy
    Istio across multiple Kubernetes clusters and then how to federate them:'
  prefs: []
  type: TYPE_NORMAL
- en: Establishing mutual trust in multi-cluster deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primary-remote on multi-network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primary-remote on the same network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-primary on different networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-primary on the same network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter is extremely hands-on, so please pay special attention to the *Technical
    requirements* section. Also, in each section, please pay special attention to
    the instructions for setting up clusters and configuring Istio.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be using **Google Cloud** for hands-on activities.
    If you are a first-time user, you may be eligible for free credits, as described
    at [https://cloud.google.com/free](https://cloud.google.com/free). You will need
    a Google account to sign up; once you are signed up, please follow the Google
    documentation to install the **Google CLI**, as described at [https://cloud.google.com/sdk/docs/install](https://cloud.google.com/sdk/docs/install).
    After installing the Google CLI, you will need to initialize it using the steps
    described at [https://cloud.google.com/sdk/docs/initializing](https://cloud.google.com/sdk/docs/initializing).
    The init steps will make the necessary configurations so that you can interact
    with your Google Cloud account using the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Kubernetes clusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have the account set up, we will create two Kubernetes clusters using
    the **Google Kubernetes Engine service**. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create cluster 1 using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we are creating a cluster named `cluster1` in the `australia-southeast1-a`
    zone in the `australia-southeast1` region. The machine type to be used is `e2-medium`
    with a default pool size of `3`. You can change the regions to whatever is closest
    to your location. You can change the instance type and other parameters, but be
    conscious of any costs it may incur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create cluster 2\. The process is the same as that in the previous step,
    but we are using a different region and different subnets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, set up the environment variables to reference the created clusters. Find
    the cluster reference name from the `kubectl` config:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the following context variables in every terminal window you will be
    using in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This completes the setup of the Kubernetes cluster in Google Cloud. In the next
    section, you will set up OpenSSL on your workstation.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up OpenSSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using OpenSSL to generate a root and intermediate **certificate authority**
    (**CA**). You will need OpenSSL 3.0 or higher. Mac users can follow the instructions
    at [https://formulae.brew.sh/formula/openssl@3](https://formulae.brew.sh/formula/openssl@3).
  prefs: []
  type: TYPE_NORMAL
- en: 'You may see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, manually add OpenSSL to `PATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Please make sure that the path reflects the terminals from where you will be
    performing certificate-related commands.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Google Cloud steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps are useful for establishing connectivity between the two
    Kubernetes clusters. Please do not perform the steps in this section yet. We will
    refer to these steps while carrying out the practical exercises in the subsequent
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the **Classless Inter-Domain Routing** (**CIDR**) block of clusters
    1 and 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The value of `ALL_CLUSTER_CIDR` will be something similar to `10.124.0.0/14,10.84.0.0/14`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the `NETTAGS` of clusters 1 and 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The value of `ALL_CLUSTER_NETTAGS` will be something similar to `gke-primary-cluster-9d4f7718-node`,
    `gke-remote-cluster-c50b7cac-node`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a firewall rule to allow all traffic between clusters 1 and 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete Google Cloud Kubernetes clusters and firewall rules by performing the
    following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Delete the firewall:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'cluster2:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: This concludes all the steps required to prepare for the upcoming sections.
    In the next section, we will start with the fundamentals required for multi-cluster
    deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing mutual trust in multi-cluster deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When setting up multi-cluster deployments, we must also establish trust between
    the clusters. The Istio architecture is based on the zero-trust model, where the
    network is assumed to be hostile and there is no implicit trust for services.
    Thus, Istio authenticates each service communication to establish the authenticity
    of the workload. Every workload in the cluster is assigned an identity and service-to-service
    communication is performed over mTLS by sidecars. Also, all communication between
    the sidecar and control plane happens over mTLS. In the previous chapters, we
    used an Istio CA with a self-signed root certificate. When setting up multi-clusters,
    we must ensure that the workload is assigned identities that can be understood
    and trusted by all other services in the mesh. Istio does this by distributing
    a CA bundle to all workloads, which contains a chain of certificates that can
    then be used by sidecars to identify the sidecar at the other end of the communication.
    In a multi-cluster environment, we need to ensure that the CA bundle contains
    the correct certificate chain to validate all services in the data plane.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two options to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plugin CA certificate**: Using this option, we create root and intermediate
    certificates outside Istio and configure Istio to use the created intermediate
    certificate. This option allows you to make use of a known CA or even your own
    internal CA as a root CA to generate an intermediate CA for Istio. You provide
    the intermediate CA certificate and keys to Istio along with root CA certificates.
    Istio then makes use of the intermediate CA and key to sign workloads and embeds
    root CA certificates as a root of trust.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Intermediate CA as a plugin CA to Istio](img/B17989_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Intermediate CA as a plugin CA to Istio
  prefs: []
  type: TYPE_NORMAL
- en: '**CA external to Istio**: We make use of an external CA that can sign certificates
    without needing to store private keys inside the Kubernetes cluster. When Istio
    uses a self-signed certificate, it stores its self-signed private keys as a Secret
    in the Kubernetes cluster. If using a plugin CA, it still has to save its intermediate
    keys in the cluster. Storing private keys in the Kubernetes cluster is not a secure
    option if access to Kubernetes is not restricted. In such cases, we can make use
    of an external CA to act as a CA for signing certificates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.2 – cert-manager](img/B17989_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – cert-manager
  prefs: []
  type: TYPE_NORMAL
- en: One such certificate management software is **cert-manager**. It adds external
    certificates and certificate issuers as resource types in Kubernetes clusters
    and simplifies the process of obtaining, renewing, and using those certificates.
    It can integrate with a variety of supported sources, including Let’s Encrypt
    and HashiCorp Vault. It ensures certificates are valid and up to date, and it
    attempts to renew certificates at a configured time before expiry. The cert-manager
    software integrates with Kubernetes via the **Kubernetes CSR API**; you can read
    about it at [https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/](https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/).
    When using cert-manager, Istio approves the CSR from the service workload and
    forwards the request to cert-manager for signing. cert-manager signs the request
    and returns the certificates to istiod, which are then passed on to istio-agent.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will make use of the plugin CA certificate option, which
    is the simpler and easier option to use, so that we can focus on the multi-cluster
    setup of Istio. In the following sections, we will go through setting up Istio
    in various cluster configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Primary-remote on multi-network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the primary-remote configuration, we will install the Istio control plane
    on cluster 1\. Clusters 1 and 2 are on different networks with no direct connectivity
    between the Pods. Cluster 1 will host the Istio control plane as well as a data
    plane. Cluster 2 will only host the data plane and uses the control plane from
    cluster 1\. Clusters 1 and 2 both use an intermediate CA signed by a root CA.
    In cluster 1, istiod observes the API server in clusters 1 and 2 for any changes
    to Kubernetes resources. We will create an Ingress gateway in both clusters, which
    will be used for cross-network communications between the workloads. We will call
    this Ingress gateway the east-west gateway because it is used for east-west communication.
    The east-west gateway takes care of authentication workloads between clusters
    1 and 2 and acts as a hub for all traffic traveling between the two clusters.
    In the following diagram, the dashed arrows in data plane traffic represent service
    requests from cluster 1 to cluster 2 traversing via the east-west gateway. In
    cluster 2, the dotted arrows represent data plane traffic traveling from cluster
    2 to cluster 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Primary-remote cluster on different networks](img/B17989_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Primary-remote cluster on different networks
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will start with configuring mutual trust between the
    two Kubernetes clusters. We will make use of the plugin CA option, as described
    in the previous section, *Establishing mutual trust in* *multi-cluster deployments*.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing trust between the two clusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to configure Istio CAs on both clusters to trust each other. As described
    in the previous section, we will do that by creating a root CA and using it to
    generate intermediate CAs for both clusters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Istio installation directory and create a folder called `certs` to
    hold the generated certificates. Then, perform the following instructions from
    the `cert` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate the root certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will generate `root-key.pem`, which is the private key, and `root-cert.pem`,
    which is the root certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate the intermediate CA for `cluster1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will generate an intermediate CA for `cluster1`, with the CA key in `ca-key.pem`,
    the certificate in `ca-cert.pem`, and the chain in `cert-chain.pem`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate an intermediate CA for `cluster2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will generate an intermediate CA for `cluster2`, with the CA key in `ca-key.pem`,
    the certificate in `ca-cert.pem`, and the chain in `cert-chain.pem`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the environment variables as described in the third and fourth steps of
    the *Setting up Kubernetes clusters* subsection in the *Technical requirements*
    section. This helps to run commands targeting multiple Kubernetes clusters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create namespaces in the primary and remote clusters. We will install Istio
    in this namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `secret` in `cluster1`, which will be used by Istio as an intermediate
    CA:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `secret` in `cluster2`, which will be used by Istio as an intermediate
    CA:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Label the `namespace` in `cluster1` and `cluster2` with the network name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure `cluster1` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the Istio operator config:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The file is available in `Chapter08/01-Cluster1.yaml` on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Istio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this step, we will install the east-west gateway in `cluster1`, which will
    expose all services in the mesh in `cluster1` to services in `cluster2`. This
    gateway is accessible to all services in `cluster2` but it can only be accessed
    by services with a trusted mTLS certificate and workload ID, that is, services
    that are part of a mesh:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The east-west gateway is also used to expose istiod endpoints to `cluster2`.
    These endpoints are used by the mutating webhooks and `istio-proxy` in `cluster2`.
    The following configuration creates a gateway named `istiod-gateway` and exposes
    ports `15012` and `15017` over TLS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following virtual service routes inbound traffic on ports `15012` and `15017`
    to `15012` and `443` to the `istiod.istio-system.svc.cluster.local` service on
    `cluster1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration is available in `samples/multicluster/expose-istiod.yaml`
    in the Istio installation folder. Apply the configuration using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another gateway for exposing workload services to `cluster2`. The configuration
    is very similar to `istiod-gateway` except that we are exposing port `15443`,
    which is specifically dedicated to traffic designated for services in the mesh:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A sample file is available in `samples/multicluster/expose-services.yaml` in
    the Istio installation directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this step, we will configure `cluster2`. To do this, you will need to note
    down the external IP for the east-west gateway created in the previous step. In
    the following steps, we will first prepare the configuration file for Istio and
    then use that to install Istio in `cluster2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure the Istio operator configuration. The following is the sample configuration,
    and it has two noteworthy configurations:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`injectionPath`: Constructed as `/inject/cluster/CLUSTER_NAME OF_REMOTE_CLUSTER/net/`
    `NETWORK_NAME OF_REMOTE_CLUSTER`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remotePilotAddress`: IP of the east-west gateway exposing ports `15012` and
    `15017` and the network reachable to `cluster2`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The sample file is available in `Chapter08/01-Cluster2.yaml` on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Label and annotate the namespace. Setting the `topology.istio.io/controlPlaneClusters`
    namespace annotation to `cluster1` instructs istiod running on `cluster1` to manage
    `cluster2`, when it is attached as a remote cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the network for `cluster2` by adding a label to the `istio-system` namespace.
    The network name should be the same as you configured in the `01-Cluster2.yaml`
    file in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Istio in `cluster2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide primary cluster access to the API server of the remote cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After performing this step, istiod in `cluster1` will be able to communicate
    with the Kubernetes API server in `cluster2`, giving it visibility of services,
    endpoints, and namespaces in `cluster2`. As soon the API server is accessible
    to istiod, it will patch the certificates in webhooks in `cluster2`. Now perform
    the following before and after *step 13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that the following has been updated in the sidecar injector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the east-west gateway to handle traffic Ingress from the primary cluster
    to the remote cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install CRDs so that you can configure traffic rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expose all services in the remote cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This completes the installation and configuration of Istio in both clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the Envoy dummy application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will first deploy two versions of the Envoy dummy application
    and then test the traffic distribution of the dummy application. Let’s get started
    with deploying two versions of the Envoy dummy application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create namespaces and enable `istio-injection`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create config maps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Deploy the Envoy application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expose Envoy using a gateway and virtual services. You can use any cluster
    as `context`; istiod will propagate the configuration to another cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have now successfully deployed the `envoydummy` application across both
    clusters. Now, let’s move on to testing the traffic distribution of the dummy
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The IP is the external IP of the Ingress gateway. Please note that it is different
    from the east-west gateway. The east-west gateway is used for inter-cluster communication
    between services workloads, whereas the Ingress gateway is used for north-south
    communication. As we are using `curl` from outside the cluster, we will make use
    of the north-south gateway:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go ahead and call the Envoy dummy using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you must have observed in the output, the traffic is distributed across both
    clusters. The Ingress gateway in `cluster1` has awareness of `v2` of the Envoy
    dummy in `cluster2` and is able to route traffic between `v1` and `v2` of the
    Envoy dummy services.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the setup of primary-remote on separate networks. In the next
    section, we will set up primate-remote on the same network.
  prefs: []
  type: TYPE_NORMAL
- en: Primary-remote on the same network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In primary-remote on the same network cluster, the services can access other
    inter-cluster services because they are on the same network. That means we don’t
    need an east-west gateway for inter-cluster communication between services. We
    will make `cluster1` the primary cluster and `cluster2` the remote cluster. We
    still need an east-west gateway to proxy istiod services. All control plane-related
    traffic from cluster 2 to cluster 1 will traverse via the east-west gateway.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Primary remote cluster sharing the same network](img/B17989_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Primary remote cluster sharing the same network
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will make use of the infrastructure we set up in the previous section,
    *Primary-remote on multi-network*, but if you want, you can also create a separate
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using the Kubernetes cluster from the previous section, you will
    need to first uninstall Istio on the remote cluster using the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then open the firewall between the two clusters by following the steps
    provided in the *Additional Google Cloud* *steps* section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Step 1* will assign a value of something similar to `10.124.0.0/14,10.84.0.0/14`,
    as seen in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '*Step 2* will assign a value of something similar to `gke-primary-cluster-9d4f7718-node`,
    `gke-remote-cluster-c50b7cac-node`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* creates a firewall rule to allow all traffic between clusters 1 and
    2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: After performing these steps, both `cluster1` and `cluster2` will have bidirectional
    network access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform *step 7* from the *Primary-remote on multi-network* section. The step
    creates `secret` in `cluster2`, which will be used by Istio as an intermediate
    CA. We will also need to annotate the `istio-system` namespace using the following
    steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install Istio in `cluster2`. We will be using the following configuration in
    the installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that `injectionPath` has the value `network1` instead of `network2`. `remotePilotAddress`
    is the external IP of the east-west gateway of `cluster1`. You will find this
    configuration in `Chapter08/02-Cluster2.yaml`. The following command will install
    Istio in cluster 2 using the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This will complete the installation of Istio in `cluster2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a remote Secret that provides istiod in `cluster1` with
    access to the Kubernetes API server in `cluster2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This concludes the setup of the primary-remote cluster in the same network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will test the setup by deploying the Envoy dummy application as we
    did earlier in the *Primary-remote on multi-network* section. Follow *steps 1–4*
    of the *Deploying the Envoy dummy application* sub-section of Primary-remote on
    multi-network section to install the `envoydummy` app. Once it''s deployed, we
    can test whether the Envoy dummy service traffic is distributed across the two
    clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: From the response, you can observe that traffic is distributed across both `cluster1`
    and `cluster2`. Both clusters are aware of each other’s services and the Service
    Mesh is able to distribute traffic across the two clusters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concludes the setup of the primary remote cluster over the shared network.
    As we have made several changes to our Kubernetes cluster, it is recommended that
    you delete them, as well as the firewall rule, to get a clean slate before performing
    the tasks described in the subsequent sections. The following is an example of
    how you can delete clusters. Please change the parameter values as per your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will perform a primary-primary setup of clusters on
    separate networks.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-primary on different networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The control plane has high availability in a multi-primary setup. In the architecture
    options discussed in the previous sections, we had one primary cluster and the
    rest of the clusters didn’t use istiod, risking a loss of control if the primary
    control plane suffers an outage due to unforeseen circumstances. In a multi-primary
    cluster, we have multiple primary control planes providing uninterrupted access
    to the mesh even if one of the control planes suffers a temporary outage.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Primary-primary on separate networks](img/B17989_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Primary-primary on separate networks
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by first setting up the clusters, followed by establishing trust
    between the two clusters. Perform the following steps to establish a multi-primary
    cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the two clusters as per the initial set of steps in the *Setting up Kubernetes
    clusters* section. This will complete the creation of the cluster as well as setting
    up the context variables. Because both clusters are primary, let’s call them `primary1`
    and `primary2` when creating the cluster in Google Cloud.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform *steps 1–7* of the *Primary-remote on multi-network* section to establish
    trust between the cluster. These steps will create the certificates, create namespaces,
    and then create a Secret in the namespaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Label the `istio-system` namespaces in both clusters with their network names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, apply the `topology.istio.io/network` label with the value `network1`
    to the `istio-system` namespace in `cluster1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, apply the `topology.istio.io/network` label with the value `network2`
    to the `istio-system` namespace in `cluster2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Istio operator configuration for `cluster1` is similar to the primary remote
    configuration, so we will be using the `01-cluster1.yaml` file to install Istio
    in `cluster1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the east-west gateway in `cluster1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a gateway configuration to expose all services in `cluster1` via the
    east-west gateway:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will be using the following Istio operator configuration to configure `cluster2`
    and install Istio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that we are not providing a profile in the configuration, which means
    a default configuration profile will be selected. In the default configuration,
    `istioctl` installs the Ingress gateway and istiod. To learn more about the configuration
    profile and what is included in each profile, please use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The sample file is available in `Chapter08/03-Cluster3.yaml`. Install Istio
    in `cluster2` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the east-west gateway and expose all services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a remote Secret for `cluster1` to be able to access the API server in
    `cluster2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create a remote Secret for `cluster2` to be able to access the API
    server in `cluster1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now it’s time to deploy and test our setup.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying and testing via Envoy dummy services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we will test the setup by deploying an Envoy dummy application as we did
    in previous sections. Follow *steps 1–4* of the *Deploying the Envoy dummy application*
    section under the *Primary-remote on* *multi-network* sub-section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the Envoy dummy application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Another test to perform is for the high availability of the control plane. You
    can shut down istiod in any of the clusters but that will not impact control plane
    operations. You will still be able to publish new services into the mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following tests to validate the high availability of the control
    plane. I have left out the command instructions because we have performed those
    steps several times in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Shut down istiod in `cluster1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the Envoy dummy application from `cluster1` using `01-envoy-proxy.yaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the Envoy dummy application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the Envoy dummy application in `cluster1` using `01-envoy-proxy.yaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the Envoy dummy application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we have set up a multi-primary cluster, there should be no interruptions
    to control plane operations even if the `cluster1` control plane is not available.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will set up a multi-primary control plane where `cluster1`
    and `cluster2` share the same network.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-primary on the same network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will set up a multi-primary Istio cluster with a shared
    network. In this architecture, workloads in `cluster1` can directly access services
    in `cluster2` and vice versa. In multi-primary clusters, we don’t need an east-west
    gateway because of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Services can directly communicate with each other across cluster boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each control plane observes the API servers in both clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Multi-primary on the same network](img/B17989_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Multi-primary on the same network
  prefs: []
  type: TYPE_NORMAL
- en: 'As we set up multi-primary in a separate network in the previous section, we
    will first need to do some cleanup to set up the environment. To do this, we will
    need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Uninstall Istio in both the primary and remote clusters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove all the labels from the `istio-system` namespace in `cluster2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will then open the firewall between the two clusters following the initial
    set of deployment steps in the *Additional Google Cloud* *steps* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the preceding steps, the two clusters are ready for the next steps to
    install Istio. Perform the following steps to install Istio on both clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Istio using `01-Cluster1.yaml`. The setup for the primary `cluster1`
    is the same as other architectures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `cluster2`, we will be using the default profile, which will install istiod
    and the Ingress gateway. As `cluster2` is sharing the network with `cluster1`,
    we will use `cluster2` and `network1` values for the `clusterName` and `network`
    parameters, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample file is available in `Chapter08/04-Cluster2.yaml`. Install Istio
    using the sample file using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a remote Secret so that the `cluster1` control plane can access the
    Kubernetes API server in `cluster2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a remote Secret so that the `cluster2` control plane can access the
    Kubernetes API server in `cluster1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will test the setup by deploying the Envoy dummy application as we
    did in previous sections. To install the `envoydummy` app, follow *steps 1–4*
    in the *Deploying the Envoy dummy application* section under the *Primary-remote
    on multi-network* section. Similarly, follow *steps 5–6* to perform the testing.
    The following code block demonstrates the distribution of traffic across both
    clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Also, test the dummy application by shutting down istiod in the primary cluster
    and redeploying the application to verify whether mesh operations are uninterrupted
    even if one of the primary cluster’s control planes is not available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This concludes the setup of multi-primary on separate networks. Multi-primary
    on a shared network is arguably the simplest Istio setup, which doesn’t need an
    east-west gateway to coordinate traffic between various Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the clusters and firewall rule. The following is an example of how you
    can delete clusters. Please change the parameter values as per your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was very hands-on, but we hope you learned how to set up Istio
    in various cluster configurations. Every section used two clusters as an example
    to demonstrate the setup, but we would recommend that you extend each of the examples
    by adding more clusters. Practice various scenarios by deploying an Envoy dummy
    application and `curl` Pod from the utilities namespace and then applying virtual
    and destination rules and testing the behavior of the services in a multi-cluster
    environment. Practice east-west traffic scenarios by configuring the east-west
    gateway to only be accessible cross-cluster and see how that plays out using the
    instructions in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Although we discussed four deployment options, choosing the right deployment
    model depends on specific use cases, and you should consider your underlying infrastructure
    provider, application isolation, network boundaries, and service-level agreement
    requirements to consider which architecture is the best fit for you. By having
    multi-cluster deployments, you get better availability of the Service Mesh and
    restricted fault boundaries so that an outage doesn’t bring down the whole cluster.
    In an enterprise environment, multiple teams working together may need to isolate
    data planes but it might be OK to have a shared control plane to save operation
    costs. In that case, multi-cluster environments such as primary-remote provide
    isolation and centralized control.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will read about web assembly and how it can be used
    to extend Istio data planes.
  prefs: []
  type: TYPE_NORMAL
