- en: Kubernetes Client Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes provides multiple options for creating applications with the Kubernetes
    API. These options include tools such as `kubectl`, `helm`, `kops`, and `kubeadm`;
    and client libraries, which are officially supported or community-maintained.
    However, it is essential that you know the capabilities and boundaries of the
    clients in order to create applications that interact with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to access the Kubernetes API directly and
    use Kubernetes client libraries. Firstly, direct access to the Kubernetes API
    will be explained, and responses from the Kubernetes API will be demonstrated.
    Following that, official and community-maintained libraries will be given, including
    detailed information and example applications. Throughout this chapter, you'll
    develop applications that connect to the Kubernetes API, inside and outside the
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the Kubernetes API request and response style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect to the Kubernetes API using HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find and use official client libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write, run, and deploy client library applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate community-maintained client libraries for further projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the Kubernetes API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes consists of several loosely-coupled components, with the principal
    idea of managing versioned resources. Kubernetes components can be divided into
    two sections: the control plane and node components. The control plane consists
    of the API Server, Controller Managers, and Schedulers. The API Server is the
    core management component and has the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Serves a REST API for the clients outside the cluster and Kubernetes components
    inside the cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates, deletes, and updates all of the Kubernetes resources, such as pods,
    deployments, and services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stores the state of the objects in a distributed key/value store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes API Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes API is a RESTful service that requires all clients to create,
    read, update, and delete resources using HTTP requests, such as `GET`, `PUT`,
    `POST`, and `DELETE`. Client applications such as `kubectl` or client libraries
    in various programming languages implement the API response and request types.
    For communication, the Kubernetes API accepts and returns JSON data, just like
    most of the RESTful services that are available.
  prefs: []
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) is an architectural style for
    web applications so that they can use HTTP requests. As a convention, `GET` is
    used for reading resources, `POST` is used for creating resources, `PUT` is used
    for updating resources, and `DELETE` is used for deleting resources.'
  prefs: []
  type: TYPE_NORMAL
- en: Servers that apply the RESTful API are expected to have clients without any
    knowledge of server structure. Likewise, the server should provide all related
    information for the client so that it can operate and interact with itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**) is a popular and lightweight data
    exchange format. JSON is suitable for machine parsing and generation, and is human-readable
    and expressive. Although written in JavaScript, JSON is supported by multiple
    languages and is a crucial data type of modern asynchronous browser/server communication.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, the Kubernetes API response style will be explored
    by calling an API server REST endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a JSON Response from the Kubernetes API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section shows how to retrieve raw data from the Kubernetes API by using
    `kubectl` and analyze the data as a JSON object for the parts of the resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by implementing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the raw data with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, you will see a JSON response. Let''s get the same command and
    format the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If Python is not locally installed, any online JSON formatter can be used by
    copying and pasting the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON response shows the structure of a Kubernetes API resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes API resources have `"apiVersion"` since all resources are versioned
    in the system. `"kind"` shows the type of the resource and `"metadata"` has all
    of the meta information, such as the creation timestamp, labels, or annotations.
    `"spec"` is the part where all properties of the resource are listed. Finally,
    most of the resources have a `"status"` section to show their state, errors, or
    messages (if any).
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Kubernetes API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Kubernetes API server is secure, requiring all incoming connections to
    be authenticated. There are two common ways of connecting and securely communicating
    with the Kubernetes API server. The first one is by using the reverse proxy functionality
    of kubectl and the second one is by using the API server credentials. These approaches
    can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reverse proxy Kubernetes API with kubectl:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kubectl proxy command starts a proxy server between the localhost and the
    Kubernetes API server.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All incoming requests are forwarded to the remote Kubernetes API server port.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The API server identity is verified by using self-signed certificates so that
    no **Man-in-the-Middle** (**MITM**) attacks are is possible.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: kubectl handles authentication to the API server. This is a recommended approach
    in the official Kubernetes documentation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Further development is ongoing; client-side load balancing and failover features
    could be provided in the future.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provides the API server address and credentials directly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API server address and credentials are available within and outside the
    cluster and they can be provided as parameters.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is an alternative approach and should be used as a last resort if the client
    application cannot work with a reversed proxy.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to protect from MITM attacks, certificates should be imported to the
    clients, for example, through browsers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following activity, connecting to the Kubernetes API by using the `kubectl`
    proxy is carried out to create a new Kubernetes namespace. With this method, `kubectl`
    securely connects to the API server with its own credentials and creates a proxy
    for the applications on the local system.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the Kubernetes API and Creating Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you are assigned the job of creating namespaces for tests
    by using the Kubernetes API. Tests are running outside the cluster and communicate
    with the Kubernetes API. In order to run tests in their own namespaces, you need
    to create a namespace. With the successful completion of this task, a new namespace
    will be created within Kubernetes by sending JSON data. Let''s ensure to follow
    these steps before starting with our example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a proxy with kubectl and make it available to all applications on the
    local system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use JSON and cURL to communicate with the Kubernetes API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gather the JSON structure of the namespace resource by querying kubesystem and
    use it as a template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s begin by implementing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the reverse proxy with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In another terminal, create an HTTP request to the forwarded port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The response is expected to be a JSON structure similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7abbc564-ca11-4aee-b64d-853f2c238915.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the response of *Step 2* as a template, create a simple namespace JSON
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the new namespace by using `curl` with the payload data from *Step 3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result of this command, the newly created namespace data will be received:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f9024d6-4866-4623-ad2c-9ca54246b42c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can run the following command for cleanup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the Kubernetes API inside a Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing the Kubernetes API outside the cluster is mostly done for operational
    bases where human interaction is required. In addition to outside communication,
    accessing the Kubernetes API inside the cluster to make requests to the API server
    is also possible. It enables writing applications and running them inside the
    cluster, which could convert operational knowledge into applications.
  prefs: []
  type: TYPE_NORMAL
- en: For all of the pods in the cluster, Kubernetes injects service accounts – they
    are the recommended way of authenticating to the Kubernetes API server. For each
    pod, the following information and credentials related to service accounts are
    mounted
  prefs: []
  type: TYPE_NORMAL
- en: 'by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service account and token**: `/var/run/secrets/kubernetes.io/serviceaccount/token`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certificate bundle**: `/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Namespace**: `/var/run/secrets/kubernetes.io/serviceaccount/namespace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using this information within the cluster forms a secure way of connecting
    to the Kubernetes API server and making requests. The service account, which is
    an authentication mechanism in Kubernetes, uses signed tokens to verify requests.
    They are created and managed by the Kubernetes API server. For each pod running
    in Kubernetes, service account tokens are mounted, and they enable pods to communicate
    with the Kubernetes API server. Further information is available in the official
    documentation: [https://kubernetes.io/docs/admin/authentication](https://kubernetes.io/docs/admin/authentication).'
  prefs: []
  type: TYPE_NORMAL
- en: To Connect to the Kubernetes API inside a Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll create a simple application to query the Kubernetes API
    and get the details of the kube-system namespace. However, this application should
    run inside the cluster and work as a Kubernetes native application. We'll query
    the Kubernetes API within a cluster with the injected environment variables and
    certificates in the pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by implementing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a cURL instance inside the cluster and wait until it is up and running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the pod, check the security credentials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33a4ec4e-4602-47db-84d5-277b215b3718.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Check that the Kubernetes API server has the related environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dccd7f87-ed37-4ef0-8403-304c6d921ff0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Combine all of the credentials and address information together with the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With the collected environment variables from *Step 4*, create and send an
    HTTP request by using cURL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By using the preceding command, a GET request will be sent to the `/api/v1/namespaces/kube-system`
    endpoint. In order to authenticate to the API server, a bearer token is sent as
    a header, and certificate authority information is provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result of this command, the requested namespace information will be retrieved
    from the API server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32f0bb5d-baac-4ebd-b8bb-9a3385becd49.png)'
  prefs: []
  type: TYPE_IMG
- en: The Kubernetes API is the core management service and it is a secure RESTful
    service that consumes JSON. It requires all of the clients to be authenticated,
    and both outside and inside cluster connections are possible. In the following
    section, client libraries for various programming languages are presented that
    implement the Kubernetes API.
  prefs: []
  type: TYPE_NORMAL
- en: Official Client Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications that consume the Kubernetes REST API should implement API calls,
    including request and response types. Considering the rich set of Kubernetes resources
    that are provided to us, developing and maintaining API implementation becomes
    complex. Fortunately, Kubernetes has a rich set of official client libraries that
    are implemented in various programming languages. Client libraries do not only
    handle requests and responses, but also handle authentication to the API server.
    Besides, most of the client libraries can discover and connect to the Kubernetes
    API server if it is running inside the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, official Go and Python client libraries will be presented.
    The client repositories, documentation, how to install, and how to create simple
    applications that are running inside and outside the clusters will be covered.
  prefs: []
  type: TYPE_NORMAL
- en: Go Client Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go, which is also of en referred to as Golang, is a programming language that
    was created by Google in 2009\. Prominent features of Go include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It is statically typed so that the compiler ensures object types and conversions
    are working
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has memory safety with no development concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has garbage collection with a minimal overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The structural typing of objects is based on their composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has first-citizen concurrency handling with primitives such as go routines
    and channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go is a free, open source programming language that has compilers and environment
    tools. Go became popular within cloud-native applications because the aforementioned
    features are well-fitting to the requirements of scalable and reliable applications.
    Some of the most notable projects that use Go as their primary language are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenShift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consul
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitcoin Lightning Network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: InfluxDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CockroachDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes' Go client, namely client-go, is part of the Kubernetes official
    project, which is available at [https://github.com/kubernetes/client-go](https://github.com/kubernetes/client-go).
  prefs: []
  type: TYPE_NORMAL
- en: It is the oldest and the most comprehensive client library. Kubernetes resource
    handlers of the client library are generated with the official source code generators
    from Kubernetes. In addition, client-go is widely used inside Kubernetes projects,
  prefs: []
  type: TYPE_NORMAL
- en: such as kubectl, helm, and kops.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Go client repository consists of the following packages and respective
    focus areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubernetes`: Clientset to access the Kubernetes API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`discovery`: Discover APIs supported by the Kubernetes API server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dynamic`: Dynamic client to perform generic API access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transport`: Authentication and connection start'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tools/cache`: Helpers for writing controllers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Go client follows the official documentation style of the Go language and
    it is available at [https://godoc.org/k8s.io/client-go](https://godoc.org/k8s.io/client-go).
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Go language, its toolset provides the `go get` command as a standard
    way of downloading and installing packages with their dependencies. This command
    downloads the default branch and the latest changes from source control version
    providers. However, specific versions of the Kubernetes client are designed to
    work with particular versions of dependencies. Therefore, the standard `go get`
    command is not usable. Instead, dependency management solutions proposed for Go
    should be used to work with `client-go` reliably.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the required version of client-go should be decided, and then
    the dependency manager downloads it with the corresponding dependencies. This
    concept of handling dependencies is called **vendoring**. Accordingly, dependency
    managers collect the dependency libraries and put them in the `vendor` folder.
  prefs: []
  type: TYPE_NORMAL
- en: For a Go application that uses the `client-go` library, all related libraries
    and their dependencies should be collected under the vendor folder for reliable
    and repeatable builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kubernetes Go client supports multiple dependency management tools, such
    as dep, godeps, and glide. In addition, the required steps for casual users who
    do not want to use any dependency management tools are provided in the official
    documentation of client-go: [https://github.com/kubernetes/client-go/blob/master/INSTALL.md](https://github.com/kubernetes/client-go/blob/master/INSTALL.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Go client library provides the necessary functionalities to connect to
    the Kubernetes API server. It is easy to create the configuration so that you
    can communicate outside the cluster and inside the cluster. You can do so with
    the following code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Creating Clientset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clientset contains the clients for each groupof resources and provides access
    to them. With its redacted version, as shown in the following code, it can be
    seen that every group of resources have their clients implemented in the client
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the configuration from the previous step, clientset can be created with
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Making API Calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After creating the configuration and clientset, API calls can finally be carried
    out. All of the Kubernetes resources can be listed, updated, created, or deleted
    by using the clients in the provided clientset. Some examples are shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Code snippets are provided for the configuration, client creation, and making
    API calls using the Kubernetes Go client in the previous sections. The complete
    application code is provided in `go/main.go`, bringing together all of the snippets
    at [https://goo.gl/wJBjG5](https://goo.gl/wJBjG5).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can note the following points in the `main.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: In the main function that was started at *line 19*, all of the variables are
    defined, and the command-line arguments are parsed at *line 30*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration is created from `kubeconfig`, and as a fallback method, it is
    created by in-cluster methods between *lines 33* and *42*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clientset is created at *line 45*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between *lines 51* and *65*, an indefinite loop is defined with 10 seconds of
    sleep at the end of iterations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At every iteration of this loop, pods from all namespaces are requested at *line
    53*. The response is printed to the console between *lines 58* and *62*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following example, an application combining all of the code snippets
    in the previous sections is built and run. It shows you how to build a Go application
    and use it outside the cluster. Although the application seems straightforward,
    the flow and codebase creates a foundation for complex automation requirements.
  prefs: []
  type: TYPE_NORMAL
- en: To Use the Kubernetes Go Client outside the Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll learn to build and run a Go application, consuming
    Kubernetes Go client and connecting the application outside the cluster. Go applications
    are built by using go toolset commands such as go build. However, this requires
    the installation of Go locally. In this example, we will use the official Docker
    image of the Go language without any installation on the local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a cross-platform build using the official Docker container by using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the application using the executable we created in *Step 1* and the `kubeconfig`
    file location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e58345f5-359c-4a91-a83c-06e7412d75b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Activity: Using the Kubernetes Go Client inside the Cluster'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: You are assigned the task of deploying a Go application that lists all of the
    pods in Kubernetes. Besides this, the application will run inside the cluster
    and receive information about its cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: To run an application that consumes the Go client library inside the Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: Use the Docker image `onuryilmaz/k8s-client-example:go` image, which contains
    the executable from the previous example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the application and check the logs to see whether it is working as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: Create a deployment with the Docker image of the example client from the previous
    example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait until the pod is running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the logs of the deployment pod.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With this command, the logs of the pod are retrieved with a subcommand. In
    the subcommand, all pods are retrieved with the selector label of `run` equal
    to `go-client`, and the name of the first pod is gathered. Logs should indicate
    the client itself, in addition to other pods in the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c5a13bf-69dd-4d0d-a354-f7a3d71f74bd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the following command for cleanup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Python Client Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is a high-level and general-purpose programming language that was first
    released in 1990\. It is one of the most popular open source programming languages,
    used in various areas, including machine learning, data processing, web development,
    and scripting. The essential feature of Python is that the language is interpreted
    with dynamic type checking. Python owes its popularity to its clear programming
    style and focus on code readability. In modern cloud-native environments, Python
    is mostly used for infrastructure and automation. In addition to its popularity
    and widespread usage, Kubernetes has an official client library that's implemented
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes Python client is part of the official client repository and is
    available at [https://github.com/kubernetes-client/python](https://github.com/kubernetes-client/python).
  prefs: []
  type: TYPE_NORMAL
- en: The Python client is an OpenAPI compliant client, which means that Swagger tools
    generate resource definitions. The client library is still in progress, and its
    capabilities should be checked from the repository before using them in production.
    The Python client, like every other Kubernetes client, attempts to support a set
    of predefined functionalities, and it is classified as "Silver" according to its
    coverage.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenAPI is a specification for describing RESTful APIs. Using the OpenAPI
    specification, it is possible to create an implementation for clients and services,
    including all of the corresponding operations.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger is the tooling ecosystem for developing APIs, which is defined in OpenAPI.
    Swagger provides both open source and commercial tools to create applications
    for the provided specification.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways of installing the client library so that you can create
    a development environment. The first way is to download the source code and build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way is to download the package from the Python Package Index by
    using a package manager such as `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Client Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, a Go application that lists all the pods was developed.
    The same functionality as the previous application is performed in Python in this
    section. With the clean code and readability philosophy of Python, the same functionality
    is handled in around ten lines of code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the critical points to mention about the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: In *line 3*, the in-cluster configuration, and in *line 5*, the client for the
    `corev1` API are created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting in *line 8*, an infinite loop starts with a sleep of 10 seconds at
    each iteration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *line 9*, all pods are requested from the `v1` client and the response is
    parsed and written to the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python application should run inside a container, like all services running
    on Kubernetes. Thus, the client library defined in this section is packaged with
    the following Dockerfile. This container definition enables the application to
    run its isolated environment with its dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Please refer to the complete code at: [https://goo.gl/z78SKr](https://goo.gl/z78SKr).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are remarks about the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The container has the basis of Python supporting version 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kubernetes Python client library is installed using `pip` in *line 3*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client application is copied into the container in *line 5* and started
    in *line 7*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, the code snippets presented for Python are utilized
    to work in a Kubernetes cluster. The complete code is packaged as a Docker container
    with its dependencies. With this container, the application is deployed to Kubernetes
    in an isolated way, which follows a microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Kubernetes Python Client inside the Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll deploy a Python application that lists all of the pods
    and consumes the Python client library inside Kubernetes. Besides this, the application
    will run inside the cluster and gather information about its cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting with the implementation, we need to use the Docker image `onuryilmaz/k8s-client-example:python`,
    which was built using the Dockerfile in the last section. We also need to deploy
    the application as a deployment and check the logs to see whether it is working
    as expected. Let''s begin by implementing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a deployment with the Docker image of the example client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With this command, a deployment with the name python-client will be created
    with the Docker image `onuryilmaz/k8s-client-example:python` in an interactive
    mode so that logs will be printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logs should indicate the client itself, in addition to other pods in the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34faffbf-f9cb-4356-8c29-6c32952de9ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the following command for cleanup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Other Official Client Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, two official Kubernetes client libraries have been covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Go**: This is a statically typed compiler-based language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python**: This is a dynamically typed and interpreted language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Official client libraries also include some additional programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**: [https://github.com/kubernetes-client/java](https://github.com/kubernetes-client/java)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET**: [https://github.com/kubernetes-client/csharp](https://github.com/kubernetes-client/csharp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JavaScript**: [https://github.com/kubernetes-client/javascript](https://github.com/kubernetes-client/javascript)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the capabilities and hurdles of these libraries, you should check their
    corresponding repositories since they are all still in the development phase.
  prefs: []
  type: TYPE_NORMAL
- en: Community-Maintained Client Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes has an active and collaborative open source community, which has
    also increased its popularity. There are around 20 community-maintained client
    libraries that are listed in the Kubernetes documentation, which cover the following
    languages:'
  prefs: []
  type: TYPE_NORMAL
- en: Clojure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lisp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dotNet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elixir
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some critical points to consider before using a community-maintained
    client library:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim of the library**: It is crucial to consider the aim of the development
    team and library. Although it seems not directly related to the software itself,
    it affects how the client library is developed. For instance, some libraries focus
    on simplicity and compromise on capability coverage. If the vision of your application
    and the client library don''t match, it would be difficult to maintain the application
    in the long run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version and support**: Official libraries support specific Kubernetes API
    versions and maintain a compatibility matrix. It is critical to work with the
    client libraries that work with your Kubernetes cluster, and it is also essential
    to get support for future Kubernetes versions. A community-maintained client library
    could be very suitable today but depreciate in six months if not supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community interest**: If the considered client library is open source, its
    community should be alive and interested in making the library better. It is very
    common to see some libraries start very well but not be maintained due to a missing
    community. It is not advised to use a client library with old issues without any
    comments or pull requests that are not reviewed for a very long time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, Kubernetes API access and client libraries were discussed.
    Although there are various tools for communicating with Kubernetes, knowing the
    Kubernetes API itself and the client libraries is crucial for creating game-changing
    automation and orchestration tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the Kubernetes API style and how to connect using HTTP clients was
    presented. Following that, the client libraries of Kubernetes were covered, and
    we focused on two official client libraries. For both Go and Python, how to install,
    write code, package, and deploy this code into cluster steps was done with demonstrations
    and activities.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, community-maintained libraries for different language preferences or
    custom requirements were shown. With the knowledge and hands-on experience of
    Kubernetes client libraries, higher levels of automation and extending Kubernetes
    is possible. In the following chapter, the best practices covered in the first
    chapter and the client libraries included in this chapter are gathered together
    to create applications that extend Kubernetes.
  prefs: []
  type: TYPE_NORMAL
