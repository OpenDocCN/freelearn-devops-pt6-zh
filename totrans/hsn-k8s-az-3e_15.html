<html><head></head><body>
		<div>
			<div id="_idContainer287" class="Content">
			</div>
		</div>
		<div id="_idContainer288" class="Content">
			<h1 id="_idParaDest-112">10. <a id="_idTextAnchor115"/>Storing secrets in AKS</h1>
		</div>
		<div id="_idContainer324" class="Content">
			<p>All production applications require some sensitive information to function, such as passwords or connection strings. Kubernetes has a pluggable back end to manage these secrets. Kubernetes also provides multiple ways of using the secrets in your deployment. The ability to manage secrets and use them properly will make your applications more secure.</p>
			<p>You have already used secrets previously in this book. You used them when connecting to the WordPress site to create blog posts in <em class="italics">Chapter 3, Application deployment on AKS</em>, and <em class="italics">Chapter 4, Building scalable applications</em>. You also used secrets in <em class="italics">Chapter 6, Securing your application with HTTPS</em>, when you were configuring the Application Gateway Ingress Controller with TLS.</p>
			<p>Kubernetes has a built-in secret system that stores secrets in a semi-encrypted fashion in the default Kubernetes database. This system works well but isn't the most secure way to deal with secrets in Kubernetes. In AKS, you can make use of a project called <strong class="bold">Azure Key Vault provider for Secrets Store CSI driver</strong> (<strong class="bold">CSI driver</strong>), which is a more secure way of working with Secrets in Kubernetes. This project allows you to store and retrieve secrets in/from Azure Key Vault. </p>
			<p>In this chapter, you will learn about the various built-in secret types in Kubernetes and the different ways in which you can create these Secrets. After that, you will install the CSI driver on your cluster, and use it to retrieve Secrets.</p>
			<p>Specifically, you will cover the following topics in this chapter:</p>
			<ul>
				<li>Different types of secret in Kubernetes</li>
				<li>Creating and using secrets in Kubernetes</li>
				<li>Installing the Azure Key Vault provider for secrets Store CSI driver</li>
				<li>Using the Azure Key Vault provider for secrets Store CSI driver</li>
			</ul>
			<p>Let's start with exploring the different secret types in Kubernetes.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor116"/>Different secret types in Kubernetes</h2>
			<p>As mentioned in the introduction to this chapter, Kubernetes comes with a default secrets implementation. This default implementation will store secrets in the etcd database that Kubernetes uses to store all object metadata. When Kubernetes stores secrets in etcd, it will store them in base64-encoded format. Base64 is a way to encode data in an obfuscated manner but is not a secure way of doing encryption. Anybody with access to base64-encoded data can easily decode it. AKS adds a layer of security on top of this by encrypting all data at rest within the Azure platform.</p>
			<p>The default secret implementation in Kubernetes allows you to store multiple types of Secrets:</p>
			<ul>
				<li><strong class="bold">Opaque secrets</strong>: These can contain any arbitrary user-defined secret or data.</li>
				<li><strong class="bold">Service account tokens</strong>: These are used by Kubernetes pods for built-in cluster RBAC.</li>
				<li><strong class="bold">Docker config secrets</strong>: These are used to store Docker registry credentials for Docker command-line configuration.</li>
				<li><strong class="bold">Basic authentication secrets</strong>: These are used for storing authentication information in the form of a username and password.</li>
				<li><strong class="bold">SSH authentication secrets</strong>: These are used to store SSH private keys.</li>
				<li><strong class="bold">TLS certificates</strong>: These are used to store TLS/SSL certificates.</li>
				<li><strong class="bold">Bootstrap token Secrets</strong>: These are used to store bearer tokens that are used when creating new clusters or joining new nodes to an existing cluster.</li>
			</ul>
			<p>As a user of Kubernetes, you most typically will work with opaque secrets and TLS certificates. You've already worked with TLS secrets in <em class="italics">Chapter 6, Securing your application with HTTPS</em>. In this chapter, you will focus on opaque secrets.</p>
			<p>Kubernetes provides three ways of creating secrets, as follows:</p>
			<ul>
				<li>Creating secrets from files</li>
				<li>Creating secrets from YAML or JSON definitions</li>
				<li>Creating secrets from the command line</li>
			</ul>
			<p>Using any of the preceding methods, you can create any type of secret.</p>
			<p>Kubernetes gives you two ways of consuming secrets:</p>
			<ul>
				<li>Using secrets as an environment variable</li>
				<li>Mounting secrets as a file in a pod</li>
			</ul>
			<p>In the next section, you will create secrets using the three ways mentioned here, and you will later consume them using both the methods listed here.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor117"/>Creating secrets in Kubernetes</h2>
			<p>In Kubernetes, there are three different ways to create secrets: from files, from YAML or JSON definitions, or directly from the command line. Let's start the exploration of how to create secrets by creating them from files.</p>
			<h3 id="_idParaDest-115"><a id="_idTextAnchor118"/>Creating Secrets from files</h3>
			<p>The first way to create secrets in Kubernetes is to create them from a file. In this way, the contents of the file will become the value of the secret, and the filename will be the identifier of each value within the secret.</p>
			<p>Let's say that you need to store a URL and a secure token for accessing an API. To achieve this, follow these steps:</p>
			<ol>
				<li>Store the URL in <strong class="inline">secreturl.txt</strong>, as follows:<p class="snippet">echo https://my-url-location.topsecret.com \</p><p class="snippet">  &gt; secreturl.txt</p></li>
				<li>Store the token in another file, as follows:<p class="snippet">echo 'superSecretToken' &gt; secrettoken.txt</p></li>
				<li>Let Kubernetes create the secret from the files, as follows:<p class="snippet">kubectl create secret generic myapi-url-token \</p><p class="snippet">  --from-file=./secreturl.txt --from-file=./secrettoken.txt</p><p>Please note that you are creating a single secret object in Kubernetes, referring to both text files. In this command, you are creating an opaque secret by using the <strong class="inline">generic</strong> keyword.</p><p>The command should return an output similar to <em class="italics">Figure 10.1</em>:</p><div id="_idContainer289" class="IMG---Figure"><img src="image/B17338_10_01.jpg" alt="Creating a Secret using the contents of the secreturl.txt file"/></div><p class="figure">Figure 10.1: Creating an opaque secret</p></li>
				<li>You can check whether the secrets were created in the same way as any other Kubernetes resource by using the <strong class="inline">get</strong> command:<p class="snippet">kubectl get secrets</p><p>This command will return an output similar to <em class="italics">Figure 10.2</em>:</p><div id="_idContainer290" class="IMG---Figure"><img src="image/B17338_10_02.jpg" alt="Verifying the creation of your Secret using the kubectl get secrets command"/></div><p class="figure">Figure 10.2: List of the created secrets</p><p>Here, you will see the secret you just created, and any other secrets that are present in the <strong class="inline">default</strong> namespace. The secret is of the <strong class="inline">Opaque</strong> type, which means that, from Kubernetes' perspective, the schema of the contents is unknown. It is an arbitrary key-value pair with no constraints, as opposed to, for example, SSH auth or TLS secrets, which have a schema that will be verified as having the required details.</p></li>
				<li>For more details about the secret, you can also run the <strong class="inline">describe</strong> command:<p class="snippet">kubectl describe secrets myapi-url-token</p><p>You will get an output similar to <em class="italics">Figure 10.3</em>:</p><div id="_idContainer291" class="IMG---Figure"><img src="image/B17338_10_03.jpg" alt="Fetching the detailed description of the Secret using the describe command"/></div><p class="figure">Figure 10.3: Description of the created secret</p><p>As you can see, neither of the preceding commands displayed the actual secret values.</p></li>
				<li>To see the secret's value, you can run the following command:<p class="snippet">kubectl get -o yaml secrets/myapi-url-token</p><p>You will get an output similar to <em class="italics">Figure 10.4</em>:</p><div id="_idContainer292" class="IMG---Figure"><img src="image/B17338_10_04.jpg" alt="Using the -o yaml switch in kubectl get secret fetches the encoded value of the Secret"/></div><p class="figure">Figure 10.4: Using the -o yaml switch in kubectl get secret fetches the encoded value of the secret</p><p>The data is stored as key-value pairs, with the filename as the key and the base64-encoded contents of the file as the value.</p></li>
				<li>The preceding values are base64-encoded. Base64 encoding isn't secure. It obfuscates the secret so it isn't easily readable by an operator, but any bad actor can easily decode a base64-encoded secret. To get the actual values, you can run the following command:<p class="snippet">echo 'c3VwZXJTZWNyZXRUb2tlbgo=' | base64 -d</p><p class="snippet">echo 'aHR0cHM6Ly9teS1zZWNyZXQtdXJsLWxvY2F0aW9uLnRvcHNlY3JldC5jb20K'| base64 -d</p><p>You will get the values of the secrets that were originally created:</p></li>
			</ol>
			<div>
				<div id="_idContainer293" class="IMG---Figure">
					<img src="image/B17338_10_05.jpg" alt="The Base64-encoded Secret is decoded using the base 64 -d command"/>
				</div>
			</div>
			<p class="figure">Figure 10.5: Base64-encoded secrets can easily be decoded</p>
			<p>This shows you that the secrets are not securely encrypted in the default Kubernetes secret store.</p>
			<p>In this section, you were able to create a secret containing an example URL with a secure token using files as the source. You were also able to get the actual secret values back by decoding the base64-encoded secrets.</p>
			<p>Let's move on and explore the second method of creating Kubernetes secrets, creating secrets from YAML definitions.</p>
			<h3 id="_idParaDest-116"><a id="_idTextAnchor119"/>Creating secrets manually using YAML files</h3>
			<p>In the previous section, you created a secret from a text file. In this section, you will create the same secret using YAML files by following these steps:</p>
			<ol>
				<li value="1">First, you need to encode the secret to <strong class="inline">base64</strong>, as follows:<p class="snippet">echo 'superSecretToken' | base64</p><p>You will get the following value:</p><p class="snippet">c3VwZXJTZWNyZXRUb2tlbgo=</p><p>You might notice that this is the same value that was present when you got the <strong class="inline">yaml</strong> definition of the secret in the previous section.</p></li>
				<li>Similarly, for the <strong class="inline">url</strong> value, you can get the base64-encoded value, as shown in the following code block:<p class="snippet">echo 'https://my-secret-url-location.topsecret.com' | base64</p><p>This will give you the base64-encoded URL:</p><p class="snippet">aHR0cHM6Ly9teS1zZWNyZXQtdXJsLWxvY2F0aW9uLnRvcHNlY3JldC5jb20K</p></li>
				<li>You can now create the secret definition manually; then, save the file. This file has been provided in the code bundle as <strong class="inline">myfirstsecret.yaml</strong>:<p class="snippet">1   apiVersion: v1</p><p class="snippet">2   kind: Secret</p><p class="snippet">3   metadata:</p><p class="snippet">4     name: myapiurltoken-yaml</p><p class="snippet">5   type: Opaque</p><p class="snippet">6   data:</p><p class="snippet">7     url: aHR0cHM6Ly9teS1zZWNyZXQtdXJsLWxvY2F0aW9uLnRvcHNlY3JldC5jb20K</p><p class="snippet">8     token: c3VwZXJTZWNyZXRUb2tlbgo=</p><p>Let's investigate this file:</p><ul><li><strong class="bold">Line 2</strong>: This specifies that you are creating a secret.</li><li><strong class="bold">Line 5</strong>: This specifies that you are creating an <strong class="inline">Opaque</strong> secret, meaning that from Kubernetes' perspective, values are unconstrained key-value pairs.</li><li><strong class="bold">Lines 7-8</strong>: These are the base64-encoded values of the secret.</li></ul><p>You might notice that this YAML is very similar to the return you got in the previous section. This is because the object you use to create the secret in Kubernetes is stored with a bit more metadata on the Kubernetes API.</p></li>
				<li>Now you can create the secret in the same way as any other Kubernetes resource by using the <strong class="inline">create</strong> command:<p class="snippet">kubectl create -f myfirstsecret.yaml</p><p>This will return an output similar to <em class="italics">Figure 10.6</em>:</p><div id="_idContainer294" class="IMG---Figure"><img src="image/B17338_10_06.jpg" alt="Creating a Secret from a YAML file"/></div><p class="figure">Figure 10.6: The secret was successfully created from a YAML file</p></li>
				<li>You can verify whether the secret was successfully created using this:<p class="snippet">kubectl get secrets</p><p>This will show you an output similar to <em class="italics">Figure 10.7</em>:</p><div id="_idContainer295" class="IMG---Figure"><img src="image/B17338_10_07.jpg" alt="Verifying the creation of your Secret using the kubectl get secrets command"/></div><p class="figure">Figure 10.7: List of the created secrets</p></li>
				<li>You can double-check that the secrets are the same by using <strong class="inline">kubectl get -o yaml secrets myapiurltoken-yaml</strong> in the same way that was described in the previous section.</li>
			</ol>
			<p>This described a second way of creating secrets in Kubernetes. In the next section, you will learn the final way to create secrets, using literals in kubectl.</p>
			<h3 id="_idParaDest-117"><a id="_idTextAnchor120"/>Creating generic secrets using literals in kubectl</h3>
			<p>The third method of creating secrets is by using the <strong class="inline">literal</strong> method, which means you pass the value in kubectl on the command line. As you have seen in the previous examples, a single secret in Kubernetes can contain multiple values. In the command to create a secret using the <strong class="inline">literal</strong> method, you use the syntax <strong class="inline">--from-literal=&lt;key&gt;=&lt;value&gt;</strong> to identify the different values in a secret:</p>
			<ol>
				<li value="1">To create a secret using the <strong class="inline">literal</strong> method, run the following command:<p class="snippet">kubectl create secret generic myapiurltoken-literal \</p><p class="snippet">  --from-literal=token='superSecretToken' \</p><p class="snippet">  --from-literal=url=https://my-secret-url-location.topsecret.com</p><p>This will return an output similar to <em class="italics">Figure 10.8</em>:</p><div id="_idContainer296" class="IMG---Figure"><img src="image/B17338_10_08.jpg" alt="Creating a Secretusing a literal values"/></div><p class="figure">Figure 10.8: The secret was successfully created using a literal value in kubectl</p></li>
				<li>You can verify that the secret was created by running the following command:<p class="snippet">kubectl get secrets</p><p>This will give us a similar output to <em class="italics">Figure 10.9</em>:</p></li>
			</ol>
			<div>
				<div id="_idContainer297" class="IMG---Figure">
					<img src="image/B17338_10_09.jpg" alt="Verifying the creation of your Secret using the kubectl get secrets command"/>
				</div>
			</div>
			<p class="figure">Figure 10.9: Verifying the secret created using the literal method</p>
			<p>Thus, you have created secrets using literal values in addition to the preceding two methods.</p>
			<p>In this section, you've created Kubernetes secrets using three methods. In the next section, you'll explore two methods of using those secrets in your pods and applications.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor121"/>Using your secrets</h2>
			<p>Once secrets have been created, they need to be linked to the application. This means that Kubernetes needs to pass the value of the secret to the running pods in some way. Kubernetes offers two ways to link your secrets to your application:</p>
			<ul>
				<li>Using secrets as environment variables</li>
				<li>Mounting secrets as files</li>
			</ul>
			<p>Mounting secrets as files is the best way to consume secrets in your application. In this section, we will explain both methods, and also show why it's best to use the second method. Let's start by accessing secrets as environment variables.</p>
			<h3 id="_idParaDest-119"><a id="_idTextAnchor122"/>Secrets as environment variables</h3>
			<p>You can use a secret in Kubernetes by referencing it as an environment variable. secrets can then be referenced in the pod definition under the <strong class="inline">containers</strong> and <strong class="inline">env</strong> sections. You will use the secrets that you previously created in a pod and learn how to use them in an application:</p>
			<ol>
				<li value="1">You can configure a pod with environment variable secrets like the definition provided in <strong class="inline">pod-with-env-secrets.yaml</strong>:<p class="snippet">1   apiVersion: v1</p><p class="snippet">2   kind: Pod</p><p class="snippet">3   metadata:</p><p class="snippet">4     name: secret-using-env</p><p class="snippet">5   spec:</p><p class="snippet">6     containers:</p><p class="snippet">7     - name: nginx</p><p class="snippet">8       image: nginx</p><p class="snippet">9       env:</p><p class="snippet">10        - name: SECRET_URL</p><p class="snippet">11          valueFrom:</p><p class="snippet">12            secretKeyRef:</p><p class="snippet">13              name: myapi-url-token</p><p class="snippet">14              key: secreturl.txt</p><p class="snippet">15        - name: SECRET_TOKEN</p><p class="snippet">16          valueFrom:</p><p class="snippet">17            secretKeyRef:</p><p class="snippet">18              name: myapi-url-token</p><p class="snippet">19              key: secrettoken.txt</p><p class="snippet">20    restartPolicy: Never</p><p>Let's inspect this file:</p><ul><li><strong class="bold">Line 9</strong>: Here, you are setting the environment variables.</li><li><strong class="bold">Lines 11-14</strong>: Here, you refer to the <strong class="inline">secreturl.txt</strong> file in the <strong class="inline">myapi-url-token</strong> secret.</li><li><strong class="bold">Lines 16-19</strong>: Here, you refer to the <strong class="inline">secrettoken.txt</strong> file in the <strong class="inline">myapi-url-token</strong> secret.</li></ul><p>When Kubernetes creates a pod on a node that needs to use a secret, it will store that secret on that host in <strong class="inline">tmpfs</strong>, a temporary file system that is not written to disk. When the last pod referencing that secret is no longer running on that node, the secret is deleted from the node's <strong class="inline">tmpfs</strong>. If a node is shut down or rebooted, <strong class="inline">tmpfs</strong> is always erased.</p></li>
				<li>Let's now create the pod and see whether you can access the secrets:<p class="snippet">kubectl create -f pod-with-env-secrets.yaml</p></li>
				<li>Check whether the environment variables are set correctly:<p class="snippet">kubectl exec -it secret-using-env -- sh</p><p class="snippet">echo $SECRET_URL</p><p class="snippet">echo $SECRET_TOKEN</p><p>This should show you a result similar to <em class="italics">Figure 10.10</em>:</p><div id="_idContainer298" class="IMG---Figure"><img src="image/B17338_10_10.jpg" alt="Accessing the Secret inside the pod"/></div><p class="figure">Figure 10.10: You can get the secrets inside the pod</p></li>
				<li>You can now exit out of the shell to the container using the <strong class="inline">exit</strong> command.</li>
			</ol>
			<p>There are a couple of things to note in this example. First, note that when you access the environment variables, you get the actual value of the secret back, not the base64-encoded value. This is as expected, since the base64 encoding is only applied at the Kubernetes API level, not at the application level.</p>
			<p>The second thing to note is that you were able to access the secret by opening a shell into that running container and echoing the secret. It is important to apply the right level of RBAC to pods in Kubernetes, so that not every cluster user is able to run the <strong class="inline">exec</strong> command and open a shell.</p>
			<p>Also note that both the application, in the form of the container image, and the pod definition had no hardcoded secrets. The secrets were provided by the dynamic configuration in Kubernetes.</p>
			<p>The final thing to note is that any application can use the secret values by referencing the appropriate <strong class="inline">env</strong> variables. There is no way to limit which processes in a container can access which environment variables.</p>
			<p>An important thing to know about secrets that are used as environment variables is that the value of the environment variable will not be updated when the secret itself is updated. This might cause you to end up in a state where pods that are created after a secret is updated have a different environment variable value compared to the pods created before the secret was updated.</p>
			<p>In this section, you explored how to access secrets from within a running pod using environment variables. In the next section, you will explore how to achieve this using files.</p>
			<h3 id="_idParaDest-120"><a id="_idTextAnchor123"/>Secrets as files</h3>
			<p>Let's take<a id="_idTextAnchor124"/> a look at how to mount the same secrets as files rather than environment variables: </p>
			<ol>
				<li value="1">You will use the following pod definition to demonstrate how this can be done. It is provided in the <strong class="inline">pod-with-vol-secrets.yaml</strong> file:<p class="snippet">1   apiVersion: v1</p><p class="snippet">2   kind: Pod</p><p class="snippet">3   metadata:</p><p class="snippet">4     name: secret-using-volume</p><p class="snippet">5   spec:</p><p class="snippet">6     containers:</p><p class="snippet">7     - name: nginx</p><p class="snippet">8       image: nginx</p><p class="snippet">9       volumeMounts:</p><p class="snippet">10      - name: secretvolume</p><p class="snippet">11        mountPath: "/etc/secrets"</p><p class="snippet">12        readOnly: true</p><p class="snippet">13    volumes:</p><p class="snippet">14    - name: secretvolume</p><p class="snippet">15      secret:</p><p class="snippet">16        secretName: myapi-url-token</p><p>Let's have a closer look at this file:</p><ul><li><strong class="bold">Lines 9-12</strong>: Here, you provide the mount details. You mount the secret in the <strong class="inline">/etc/secrets</strong> directory as read-only.</li><li><strong class="bold">Lines 13-16</strong>: Here, you refer to the secret. Please note that both values in the secret will be mounted in the container. You can optionally – although not shown here – specify which parts of a secret should be mounted in a volume.</li></ul><p>Note that this is more succinct than the <strong class="inline">env</strong> definition, as you don't have to define a name for each secret. However, applications need to have special code to read the contents of the file in order to load it properly.</p></li>
				<li>Let's see whether the secrets made it through. Create the pod using the following command:<p class="snippet">kubectl create -f pod-with-vol-secret.yaml</p></li>
				<li>Echo the contents of the files in the mounted volume:<p class="snippet">kubectl exec -it secret-using-volume -- sh</p><p class="snippet">cd /etc/secrets/</p><p class="snippet">cat secreturl.txt</p><p class="snippet">cat secrettoken.txt</p><p>As you can see in <em class="italics">Figure 10.11</em>, the secrets are present in the pod:</p><div id="_idContainer299" class="IMG---Figure"><img src="image/B17338_10_11.jpg" alt="Echoing the contents of the files containing the secrets in the mounted volume "/></div><p class="figure">Figure 10.11: The secrets are available as files in our pod</p></li>
				<li>You can now exit out of the shell to the container using the <strong class="inline">exit</strong> command.</li>
			</ol>
			<p>There are a couple of things to note here as well. First, note that the secrets again are available in plain text and not in base64.</p>
			<p>Second, since the secrets are mounted as a file, file system permissions apply to these secrets. This means that you can limit which processes can get access to the contents of these files.</p>
			<p>Finally, Secrets mounted as files will be dynamically updated as the secrets are updated.</p>
			<p>You have now learned two ways in which secrets can be passed to a running container. In the next section, it will be explained why it's best practice to use the file method.</p>
			<h3>Why secrets as files is the best method</h3>
			<p>Although it is a common practice to use secrets as environment variables, it is more secure to mount secrets as files. Kubernetes treats secrets as environment variables securely, but the container runtime doesn't treat them securely. To verify this, you can run the following commands to see the secret in plain text in the Docker runtime:</p>
			<ol>
				<li value="1">Start by getting the node that the pod using environment variables from the earlier example is running on with the following command:<p class="snippet">kubectl describe pod secret-using-env | grep Node</p><p>This should show you the instance ID, as seen in <em class="italics">Figure 10.12</em>:</p><div id="_idContainer300" class="IMG---Figure"><img src="image/B17338_10_12.jpg" alt="Fetching the Instance ID of the node by describing the pod"/></div><p class="figure">Figure 10.12: Getting the instance ID</p></li>
				<li>Next, get the Docker ID of the running pod:<p class="snippet">kubectl describe pod secret-using-env | grep 'Container ID'</p><p>This should give you the container ID:</p><div id="_idContainer301" class="IMG---Figure"><img src="image/B17338_10_13.jpg" alt="Fetching the Docker ID of the running pod"/></div><p class="figure">Figure 10.13: Getting the Docker ID</p></li>
				<li>Finally, you will execute a command on the node running your container to show the secret that was passed as an environment variable. First, let's set a couple of variables you'll use later:<p class="snippet">INSTANCE=&lt;provide instance number&gt;</p><p class="snippet">DOCKERID=&lt;provide Docker ID&gt;</p><p class="snippet">VMSS=$(az vmss list --query '[].name' -o tsv)</p><p class="snippet">RGNAME=$(az vmss list --query '[].resourceGroup' -o tsv)</p><h4>Note</h4><p class="callout">The previous command assumes you have a single AKS cluster with one node pool in your subscription. If this is not the case, please change the values of <strong class="inline">VMSS</strong> and <strong class="inline">RGNAME</strong> to the name of the value of the scale set and resource group running your cluster.</p></li>
				<li>Depending on your node version, you will run either of the following commands. For clusters running on Kubernetes version 1.18.x or earlier, run the following command:<p class="snippet">az vmss run-command invoke -g $RGNAME -n $VMSS --command-id \</p><p class="snippet">RunShellScript --instance-id $INSTANCE --scripts \</p><p class="snippet">"docker inspect -f '{{ .Config.Env }}' $DOCKERID" \</p><p class="snippet">-o yaml | grep SECRET</p><p>This should return an output similar to <em class="italics">Figure 10.14</em>:</p></li>
			</ol>
			<div>
				<div id="_idContainer302" class="IMG---Figure">
					<img src="image/B17338_10_14.jpg" alt="Output showing the decoded secret in the Docker runtime "/>
				</div>
			</div>
			<p class="figure">Figure 10.14: The Secrets are decoded in the Docker runtime</p>
			<p>For clusters running version 1.19 or later, run the following command:</p>
			<p class="snippet">az vmss run-command invoke -g $RGNAME -n $VMSS --command-id \</p>
			<p class="snippet">RunShellScript --instance-id $INSTANCE --scripts \</p>
			<p class="snippet">"crictl inspect --output yaml $DOCKERID" \</p>
			<p class="snippet">-o yaml | grep SECRET</p>
			<p>This will show you an output similar to <em class="italics">Figure 10.15</em>:</p>
			<div>
				<div id="_idContainer303" class="IMG---Figure">
					<img src="image/B17338_10_15.jpg" alt="Output showing the decoded secret in the containerd runtime "/>
				</div>
			</div>
			<p class="figure">Figure 10.15: The secrets are decoded in the containerd runtime</p>
			<p>This shows you both secrets in plain text in the container runtime, whether Docker (AKS version before 1.19) or containerd (AKS versions 1.19 and above).</p>
			<p>As you can see, the secrets are decoded in the container runtime command. This means that most logging systems will log these sensitive secrets. Hence, it's advised to use secrets as files, since they are not passed in plain text except to the pod and the application. </p>
			<p>Let's make sure to clean up the resources we created in this example:</p>
			<p class="snippet">kubectl delete pod --all</p>
			<p class="snippet">kubectl delete secret myapi-url-token \</p>
			<p class="snippet">myapiurltoken-literal myapiurltoken-yaml</p>
			<p>Now that you have explored secrets in Kubernetes using the default secrets mechanism, let's go ahead and use a more secure option, namely Azure Key Vault.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor125"/>Installing the Azure Key Vault provider for Secrets Store CSI driver</h2>
			<p>In the previous section, you explored secrets that were stored natively in Kubernetes. This means they were base64-encoded on the Kubernetes API server. You saw in the previous section that base64-encoded secrets are not secure at all. For highly secure environments, you will want to use a better secret store.</p>
			<p>Azure offers an industry-compliant key and secret storage solution called Azure Key Vault. It is a managed service that makes creating, storing, and retrieving keys and secrets easy, and offers auditing of access to your keys and secrets.</p>
			<p>The Kubernetes community maintains a project called the Kubernetes Secrets Store CSI driver (<a href="">https://github.com/kubernetes-sigs/secrets-store-csi-driver</a>). This project allows you to integrate external secret stores with volumes in Kubernetes through the CSI driver. The Container Storage Interface is a standardized way in Kubernetes to interface with storage systems. There are multiple implementations of the Secret Store CSI driver. At the time of writing, the current implementations are Hashicorp Vault, Google Cloud Platform, and Azure Key Vault.</p>
			<p>Microsoft maintains the Key Vault implementation of the Secret Store CSI driver, named Azure Key Vault provider for Secrets Store CSI driver. This implementation allows you as a user to access Key Vault secrets from within Kubernetes. It is also integrated with pod identities to restrict access to secrets. Optionally, this implementation can also sync Key Vault secrets with Kubernetes secrets so you can use them as an environment variable if needed.</p>
			<h4>Note</h4>
			<p class="callout">For brevity, we'll refer to Azure Key Vault provider for Secrets Store CSI driver as the CSI driver for Key Vault.</p>
			<p>At the time of writing, the CSI driver for Key Vault is only available as an open-source project that you can install on your cluster. It is worth noting that this solution might be introduced as a managed add-on to AKS in the future. For more up-to-date details, please refer to this issue on GitHub at <a href="">https://github.com/Azure/AKS/issues/1876</a>.</p>
			<p>To work with the CSI driver for Key Vault, there are two things you need to do. First, you need to set up the driver itself on your cluster. That is the goal of this section. Secondly, you'll need to create an object in Kubernetes called a <strong class="inline">SecretProviderClass</strong> for each secret from Key Vault you need to access. You will learn more about this in the next section. </p>
			<p>In this section, you will set up the CSI driver for Key Vault. First, you will create a new user-assigned managed identity. After that, you'll create a new key vault and give the user-assigned managed identity permissions to that key vault. Finally, you'll set up the CSI driver for Key Vault on your cluster.</p>
			<p>Let's start by creating a new managed identity.</p>
			<h3 id="_idParaDest-122"><a id="_idTextAnchor126"/>Creating a managed identity</h3>
			<p>The CSI driver for Key Vault supports different ways of getting data out of Key Vault. It is recommended that you use a managed identity to link your Kubernetes cluster to Key Vault. For this, you can use the AAD pod-managed identity add-on that you set up in the previous chapter. In this section, you'll create a new managed identity in Azure to later use with Key Vault:</p>
			<ol>
				<li value="1">Let's create a new managed identity. You will use the Azure portal to do this. To start, look for <strong class="inline">managed identity</strong> in the Azure search bar, as shown in <em class="italics">Figure 10.16</em>:<div id="_idContainer304" class="IMG---Figure"><img src="image/B17338_10_16.jpg" alt="Searching for Managed Identity in the Azure search bar"/></div><p class="figure">Figure 10.16: Looking for managed identity in the Azure search bar</p></li>
				<li>In the resulting pane, click the <span class="P---Screen-Text">+ New</span> button at the top. To organize the resources for this chapter together, it's recommended to create a new resource group. In the resulting pane, click the <span class="P---Screen-Text">Create new</span> button to create a new resource group. Call it <strong class="inline">csi-key-vault</strong>, as shown in <em class="italics">Figure 10.17</em>:<div id="_idContainer305" class="IMG---Figure"><img src="image/B17338_10_17.jpg" alt="Creating a new resource group for creating a new managed identity"/></div><p class="figure">Figure 10.17: Creating a new resource group</p></li>
				<li>Now, select the region you created your cluster in as the region for your managed identity and give it a name, <strong class="inline">csi-key-vault</strong> if you follow the example, as shown in <em class="italics">Figure 10.18</em>. To finish, click the <span class="P---Screen-Text">Review + create</span> button and in the final window, click the <span class="P---Screen-Text">Create</span> button to create your managed identity:<div id="_idContainer306" class="IMG---Figure"><img src="image/B17338_10_18.jpg" alt="Providing Instance details for the managed identity"/></div><p class="figure">Figure 10.18: Providing Instance details</p></li>
				<li>Once the managed identity has been created, hit the <span class="P---Screen-Text">Go to resource</span> button to go to the resource. Here, you will need to copy the resource ID that will be used later in the next step. You can find that in the <span class="P---Screen-Text">Properties</span> pane of the managed identity, as shown in <em class="italics">Figure 10.19</em>:<div id="_idContainer307" class="IMG---Figure"><img src="image/B17338_10_19.jpg" alt="Fetching the resource ID from the Properties pane of the managed identity"/></div><p class="figure">Figure 10.19: Getting the Resource ID of the managed identity</p></li>
				<li>Now you are ready to link the managed identity to your AKS cluster. To do this, you will run a command in cloud shell as you did in the previous chapter. Afterward, you will verify that the identity is available in your cluster. Let's start with linking the identity:<p class="snippet">az aks pod-identity add --resource-group rg-handsonaks \</p><p class="snippet">  --cluster-name handsonaks --namespace default \</p><p class="snippet">  --name csi-to-key-vault \</p><p class="snippet">  --identity-resource-id &lt;Managed identity resource ID&gt;</p></li>
				<li>You can verify that your identity was successfully linked to your cluster by running the following command:<p class="snippet">kubectl get azureidentity</p><p>This should produce an output similar to <em class="italics">Figure 10.20</em>:</p></li>
			</ol>
			<div>
				<div id="_idContainer308" class="IMG---Figure">
					<img src="image/B17338_10_20.jpg" alt="Verifying that your identity is successfully linked to your cluster"/>
				</div>
			</div>
			<p class="figure">Figure 10.20: Verifying the availability of the identity in the cluster</p>
			<p>In this section, you created a new managed identity and linked that to your Kubernetes cluster using the AAD Pod-managed identity add-on. In the next section, you'll create a key vault and give the new identity you created access to the secrets. Finally, you'll create a secret in Key Vault that you try to access later from your cluster.</p>
			<h3 id="_idParaDest-123"><a id="_idTextAnchor127"/>Creating a key vault</h3>
			<p>In the previous section, you set up the managed identity that the CSI driver for Key Vault will use. In this section, you'll create the key vault that will be used:</p>
			<ol>
				<li value="1">To start the creation process, look for <strong class="inline">Key vaults</strong> in the Azure search bar:<div id="_idContainer309" class="IMG---Figure"><img src="image/B17338_10_21.jpg" alt="Navigating to Key Vault services from the Azure portal"/></div><p class="figure">Figure 10.21: Navigating to Key vaults through the Azure portal</p></li>
				<li>Click the <span class="P---Screen-Text">+ New</span> button to start the creation process:<div id="_idContainer310" class="IMG---Figure"><img src="image/B17338_10_22.jpg" alt="Creating a new key vault"/></div><p class="figure">Figure 10.22: Click the Add button to start creating a key vault</p></li>
				<li>Provide the details to create the key vault. Create the key vault in the resource group you created in the previous step. The key vault's name has to be globally unique, so consider adding your initials to the name. It is recommended that you create the key vault in the same region as your cluster:<div id="_idContainer311" class="IMG---Figure"><img src="image/B17338_10_23.jpg" alt="Providing Subscription and Instance details to create the key vault"/></div><p class="figure">Figure 10.23: Providing the details to create the key vault</p></li>
				<li>After you have provided the details for your key vault, click the <span class="P---Screen-Text">Next: Access policy &gt;</span> button to give the managed identity access to secrets. Click on the <span class="P---Screen-Text">+ Add Access Policy</span> to give permission to your managed identity, as shown in <em class="italics">Figure 10.24</em>:<div id="_idContainer312" class="IMG---Figure"><img src="image/B17338_10_24.jpg" alt="Adding a new access policy"/></div><p class="figure">Figure 10.24: Adding an Access policy</p><p>In the resulting pane, select the <span class="P---Screen-Text">Secret Management</span> template, click on the <span class="P---Screen-Text">None Selected</span> button underneath <span class="P---Screen-Text">Select principal</span>, and in the resulting pane look for the <strong class="inline">csi-to-key-vault</strong> you created earlier. Finally, click on <span class="P---Screen-Text">Select</span> at the bottom of the screen and then on <span class="P---Screen-Text">Add</span>, as shown in <em class="italics">Figure 10.25</em>:</p><div id="_idContainer313" class="IMG---Figure"><img src="image/B17338_10_25.jpg" alt="Assigning the Secret Management template in the access policy to the csi-to-key-vault managed identity"/></div><p class="figure">Figure 10.25: Assigning the Secret Management template to your managed identity</p></li>
				<li>Once you have provided permissions to this managed identity, hit the <span class="P---Screen-Text">Review + create</span> button to review and create your key vault. Hit the <span class="P---Screen-Text">Create</span> button to finish the creation process.</li>
				<li>It will take a couple of seconds to create your key vault. Once the vault is created, click on the <span class="P---Screen-Text">Go to resource</span> button, go to <span class="P---Screen-Text">Secrets</span>, and hit the <span class="P---Screen-Text">Generate/Import</span> button to create a new secret as shown in <em class="italics">Figure 10.26</em>:<div id="_idContainer314" class="IMG---Figure"><img src="image/B17338_10_26.jpg" alt="Creating a new Secret within the key vault"/></div><p class="figure">Figure 10.26: Creating a new secret</p></li>
				<li>In the secret creation wizard, provide the details about your secret. To make this demonstration easier to follow, use the name <strong class="inline">k8s-secret-demo</strong>. Give the secret a memorable value, such as <strong class="inline">secret-coming-from-key-vault</strong>. Click the <span class="P---Screen-Text">Create</span> button at the bottom of the screen to create the secret:</li>
			</ol>
			<div>
				<div id="_idContainer315" class="IMG---Figure">
					<img src="image/B17338_10_27.jpg" alt="Configuring the Secret"/>
				</div>
			</div>
			<p class="figure">Figure 10.27: Providing the details for your new secret</p>
			<p>Now that you have a secret in Key Vault, you can move ahead and install the actual CSI driver for Key Vault in your cluster.</p>
			<h3 id="_idParaDest-124"><a id="_idTextAnchor128"/>Installing the CSI driver for Key Vault</h3>
			<p>In this section, you will set up the CSI driver for Key Vault in your cluster. This will allow you, in the next section, to retrieve secrets from Key Vault. The installation is a short process, as you will see here:</p>
			<ol>
				<li value="1">The easiest way to install the CSI driver for Key Vault is to use Helm, as you've done before. Note that this feature may be available as an add-on after the release of this book. To do this, add the repo for the CSI driver for Key Vault:<p class="snippet">helm repo add csi-secrets-store-provider-azure \</p><p class="snippet">  <a href="">https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/charts</a></p></li>
				<li>Once the repo has been added, you can install the actual CSI driver for Key Vault using the following command:<p class="snippet">helm install csi-secrets \</p><p class="snippet">  csi-secrets-store-provider-azure/csi-secrets-store-provider-azure</p></li>
				<li>To verify that the installation succeeded, you can verify that the SecretProviderClass CRD has been added to your cluster via the following command:<p class="snippet">kubectl get crd</p><p>This should show you an output that contains the SecretProviderClass CRD as shown in <em class="italics">Figure 10.28</em>:</p></li>
			</ol>
			<div>
				<div id="_idContainer316" class="IMG---Figure">
					<img src="image/B17338_10_28.jpg" alt="Verifying that the SecretProviderClass CRD has been added to your cluster"/>
				</div>
			</div>
			<p class="figure">Figure 10.28: The SecretProviderClass CRD has been added to the cluster</p>
			<p>This concludes the setup of the CSI driver for Key Vault. In this section, you first created a managed identity, then created a key vault with a secret in it, and then finally set up the CSI driver for Key Vault on your cluster.</p>
			<p>You are now ready to use the CSI driver for Key Vault, which you'll do in the next section.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor129"/>Using the Azure Key Vault provider for Secrets Store CSI driver</h2>
			<p>Now that the CSI driver for Key Vault has been set up on your cluster, you are ready to start using it. In this section, you'll run through two examples of using the CSI driver for Key Vault. First, you will use it to mount a secret as a file in Kubernetes. Afterward, you will also use it to sync Key Vault secrets to Kubernetes secrets and use them as an environment variable.</p>
			<p>Let's get started with the first example, how to mount Key Vault secrets as a file.</p>
			<h3 id="_idParaDest-126"><a id="_idTextAnchor130"/>Mounting a Key Vault secret as a file</h3>
			<p>In this first example, you will create a new SecretProviderClass in your cluster. This object will allow you to link a secret in Key Vault to a pod in Kubernetes. After that, you'll create a pod that uses that SecretProviderClass and mounts the secrets in that pod. Let's get started:</p>
			<ol>
				<li value="1">The SecretProviderClass requires you to know your Azure Active Directory tenant ID. To get this, run the following command:<p class="snippet">az account show --query tenantId</p><p>This will show you an output similar to <em class="italics">Figure 10.29</em>. Copy-paste this value and store it in a file you can refer to later:</p><div id="_idContainer317" class="IMG---Figure"><img src="image/B17338_10_29.jpg" alt="Fetching the tenant ID for creatingthe SecretProviderClass"/></div><p class="figure">Figure 10.29: Getting your tenant ID</p><p>Next, you'll create the SecretProviderClass. An example has been provided in the code files for this chapter, in the <strong class="inline">secretproviderclass-file.yaml</strong> file: </p><p class="snippet">1   apiVersion: secrets-store.csi.x-k8s.io/v1alpha1</p><p class="snippet">2   kind: SecretProviderClass</p><p class="snippet">3   metadata:</p><p class="snippet">4     name: key-vault-secret-file</p><p class="snippet">5   spec:</p><p class="snippet">6     provider: azure</p><p class="snippet">7     parameters:</p><p class="snippet">8       usePodIdentity: "true"</p><p class="snippet">9       keyvaultName: "&lt;key vault name&gt;"</p><p class="snippet">10      objects:  |</p><p class="snippet">11        array:</p><p class="snippet">12          - |</p><p class="snippet">13            objectName: k8s-secret-demo</p><p class="snippet">14            objectType: secret        </p><p class="snippet">15      tenantId: "&lt;your tenant ID&gt;"</p><p>Let's investigate this file:</p><ul><li><strong class="bold">Line 2</strong>: Here, you define you are creating a <strong class="inline">SecretProviderClass</strong>.</li><li><strong class="bold">Line 6</strong>: Here, you create an Azure secret. As mentioned in the introduction, the secret-store project supports multiple implementations.</li><li><strong class="bold">Line 8</strong>: You configure this secret to use pod identities for authentication. You will link a pod identity to your pod later on.</li><li><strong class="bold">Line 9</strong>: The name of the key vault.</li><li><strong class="bold">Line 10-14</strong>: Here, you refer to the secrets that need to be accessed. In this example, you're only accessing a single secret, but you could access multiple secrets in a single <strong class="inline">SecretProviderClass</strong>.</li><li><strong class="bold">Line 15</strong>: The AAD tenant ID of your AAD tenant.</li></ul><p>Make sure to edit this with the values for your environment.</p></li>
				<li>You can create this <strong class="inline">SecretProviderClass</strong> using the following command:<p class="snippet">kubectl create -f secretproviderclass-file.yaml</p></li>
				<li>Once the SecretProviderClass has been created, you can go ahead and create a pod that references that SecretProviderClass. An example has been provided in the <strong class="inline">pod-keyvault-file.yaml</strong> file:<p class="snippet">1   kind: Pod</p><p class="snippet">2   apiVersion: v1</p><p class="snippet">3   metadata:</p><p class="snippet">4     name: csi-demo-file</p><p class="snippet">5     labels:</p><p class="snippet">6       aadpodidbinding: "csi-to-key-vault"</p><p class="snippet">7   spec:</p><p class="snippet">8     containers:</p><p class="snippet">9       - name: nginx</p><p class="snippet">10        image: nginx</p><p class="snippet">11        volumeMounts:</p><p class="snippet">12        - name: keyvault</p><p class="snippet">13          mountPath: "/mnt/secrets-store"</p><p class="snippet">14          readOnly: true</p><p class="snippet">15    volumes:</p><p class="snippet">16      - name: keyvault</p><p class="snippet">17        csi:</p><p class="snippet">18          driver: secrets-store.csi.k8s.io</p><p class="snippet">19          readOnly: true</p><p class="snippet">20          volumeAttributes:</p><p class="snippet">21            secretProviderClass: "key-vault-secret-file"</p><p>Let's have a look at the key parts of this file:</p><ul><li><strong class="bold">Line 5-6</strong>: This is where you link this pod to the managed identity you created earlier.</li><li><strong class="bold">Line 11-14</strong>: Here, you define where you want to mount the secrets.</li><li><strong class="bold">Line 15-21</strong>: Here, you define the actual Volume and the link to Key Vault. On line 21, you refer to the SecretProviderClass you created earlier.</li></ul></li>
				<li>You can create this pod using the following command:<p class="snippet">kubectl create -f pod-keyvault-file.yaml</p></li>
				<li>Monitor the Pod's creation using the following command:<p class="snippet">kubectl get pods -w</p><p>This should return an output similar to <em class="italics">Figure 10.30</em>:</p><div id="_idContainer318" class="IMG---Figure"><img src="image/B17338_10_30.jpg" alt="Verifying that the status of thecsi-demo-file pod changes to Running"/></div><p class="figure">Figure 10.30: Status of the csi-demo-file pod changes to Running </p></li>
				<li>Once the pod is created and running, you can open a shell in the pod using the <strong class="inline">kubectl exec</strong> command and verify that the secret is present:<p class="snippet">kubectl exec -it csi-demo-file -- sh</p><p class="snippet">cd /mnt/secrets-store</p><p class="snippet">cat k8s-secret-demo</p><p>This should output the secret you created in Key Vault, as seen in <em class="italics">Figure 10.31</em>:</p><div id="_idContainer319" class="IMG---Figure"><img src="image/B17338_10_31.jpg" alt="Verifying that the Secret is mounted in the Pod"/></div><p class="figure">Figure 10.31: The secret you configured in Key Vault is mounted in the pod as a file</p><p>And as expected, you are able to get the secret you configured in Key Vault to show up in Kubernetes.</p></li>
				<li>You can now exit out of the shell to the container using the <strong class="inline">exit</strong> command.</li>
			</ol>
			<p>As you can see, you successfully used the CSI driver for Key Vault to get a secret from Key Vault to show up as a file in a pod. </p>
			<p>It is also possible to sync secrets in Key Vault to secrets in Kubernetes and then use them as an environment variable in running pods. That's what you'll explore in the next and final section of this chapter.</p>
			<h3 id="_idParaDest-127"><a id="_idTextAnchor131"/>Using a Key Vault secret as an environment variable</h3>
			<p>In the previous section, you saw how to access Key Vault secrets as a file in a pod. As you learned earlier in this chapter, it is recommended that you use Kubernetes secrets as a file.</p>
			<p>However, there are situations where you cannot modify an application to use secrets as a file and you need to use them as environment variables. This can be done using the CSI driver for Key Vault, and you will configure the driver that way in this section. Please note that in order for the CSI driver to sync secrets in Key Vault to Secrets in Kubernetes, you need to mount the secret as a Volume in Kubernetes; you cannot only rely on the secret syncing. </p>
			<p>Let's configure all of this:</p>
			<ol>
				<li value="1">First, you'll create the SecretProviderClass. An example has been provided in the code files for this chapter, in the <strong class="inline">secretproviderclass-env.yaml</strong> file: <p class="snippet">1   apiVersion: secrets-store.csi.x-k8s.io/v1alpha1</p><p class="snippet">2   kind: SecretProviderClass</p><p class="snippet">3   metadata:</p><p class="snippet">4     name: key-vault-secret-env</p><p class="snippet">5   spec:</p><p class="snippet">6     provider: azure</p><p class="snippet">7     parameters:</p><p class="snippet">8       usePodIdentity: "true"</p><p class="snippet">9       keyvaultName: "&lt;key vault name&gt;"</p><p class="snippet">10      objects:  |</p><p class="snippet">11        array:</p><p class="snippet">12          - |</p><p class="snippet">13            objectName: k8s-secret-demo</p><p class="snippet">14            objectType: secret</p><p class="snippet">15      tenantId: "&lt;tenant ID&gt;"</p><p class="snippet">16    secretObjects:</p><p class="snippet">17    - secretName: key-vault-secret</p><p class="snippet">18      type: Opaque</p><p class="snippet">19      data:</p><p class="snippet">20      - objectName: k8s-secret-demo</p><p class="snippet">21        key: secret-content </p><p>Let's investigate what's different in this file versus the previous one you created:</p><ul><li><strong class="bold">Line 16-21</strong>: This is where you link the Key Vault secret to a Kubernetes secret. The names used here are important since they provide critical information about the different objects:</li><li><strong class="bold">Line 17</strong> <strong class="inline">secretName</strong>: This refers to the name of the secret in Kubernetes that will be created.</li><li><strong class="bold">Line 20</strong> <strong class="inline">objectName</strong>: This refers to the <strong class="inline">objectName</strong> on line 13, which is the name of the secret in Key Vault.</li><li><strong class="bold">Line 21</strong> <strong class="inline">key</strong>: This is the name of the key in the secret in Kubernetes. As was explained earlier in this chapter, a single secret in Kubernetes can contain multiple keys.</li></ul><p>The remaining sections of this file are similar to the earlier SecretProviderClass you created.</p></li>
				<li>You can create this SecretProviderClass using the following command:<p class="snippet">kubectl create -f secretproviderclass-env.yaml</p></li>
				<li>Once the SecretProviderClass has been created, you can go ahead and create a pod that references that SecretProviderClass. You cannot rely solely on the syncing of the secrets, the SecretProviderClass has to be mounted in order for the CSI driver to sync the secrets. An example has been provided in the <strong class="inline">pod-keyvault-env.yaml</strong> file:<p class="snippet">1   apiVersion: v1</p><p class="snippet">2   kind: Pod</p><p class="snippet">3   metadata:</p><p class="snippet">4     name: csi-demo-env</p><p class="snippet">5     labels:</p><p class="snippet">6       aadpodidbinding: "csi-to-key-vault"</p><p class="snippet">7   spec:</p><p class="snippet">8     containers:</p><p class="snippet">9     - name: nginx</p><p class="snippet">10      image: nginx</p><p class="snippet">11      env:</p><p class="snippet">12        - name: KEYVAULT_SECRET</p><p class="snippet">13          valueFrom:</p><p class="snippet">14            secretKeyRef:</p><p class="snippet">15              name: key-vault-secret</p><p class="snippet">16              key: secret-content</p><p class="snippet">17      volumeMounts:</p><p class="snippet">18        - name: keyvault</p><p class="snippet">19          mountPath: "/mnt/secrets-store"</p><p class="snippet">20          readOnly: true</p><p class="snippet">21    volumes:</p><p class="snippet">22      - name: keyvault</p><p class="snippet">23        csi:</p><p class="snippet">24          driver: secrets-store.csi.k8s.io</p><p class="snippet">25          readOnly: true</p><p class="snippet">26          volumeAttributes:</p><p class="snippet">27            secretProviderClass: "key-vault-secret-env" </p><p>The difference between this pod and the previous one you created is on <em class="italics">lines 11 to 16</em>. This should seem familiar, as this is the typical way to use a secret as an environment variable.</p></li>
				<li>You can create this pod using the following command:<p class="snippet">kubectl create -f pod-keyvault-env.yaml</p></li>
				<li>Monitor the Pod's creation using the following command:<p class="snippet">kubectl get pods -w</p><p>This should return an output similar to <em class="italics">Figure 10.32</em>:</p><div id="_idContainer320" class="IMG---Figure"><img src="image/B17338_10_32.jpg" alt="Monitoring the creation of the csi-demo-env Pod"/></div><p class="figure">Figure 10.32: Waiting for the csi-demo-env pod to run</p></li>
				<li>Once the pod is created and running, you can open a shell in the pod using the <strong class="inline">kubectl exec</strong> command and verify that the secret is present:<p class="snippet">kubectl exec -it csi-demo-env -- sh</p><p class="snippet">echo $KEYVAULT_SECRET</p><p>This should output the secret you created in Key Vault, as seen in <em class="italics">Figure 10.33</em>:</p><div id="_idContainer321" class="IMG---Figure"><img src="image/B17338_10_33.jpg" alt="The Secret you configured in Key Vaultis used as an environment variable"/></div><p class="figure">Figure 10.33: The secret you configured in Key Vault is used as an environment variable</p></li>
				<li>You can now exit out of the shell to the container using the <strong class="inline">exit</strong> command.</li>
				<li>Finally, you can also verify that the secret was created in Kubernetes by running the following command:<p class="snippet">kubectl get secret</p><p>This should show you an output similar to <em class="italics">Figure 10.34</em>:</p><div id="_idContainer322" class="IMG---Figure"><img src="image/B17338_10_34.jpg" alt="The synced secret is available using the kubectl get secret command"/></div><p class="figure">Figure 10.34: The key-vault-secret secret in Kubernetes is synced with the Key Vault secret</p></li>
				<li>This secret will disappear once no more pods that mount the secret are present. You can verify this with the following commands:<p class="snippet">kubectl delete -f pod-keyvault-env.yaml</p><p class="snippet">kubectl get secret</p><p>This should show you an output similar to <em class="italics">Figure 10.35</em>:</p></li>
			</ol>
			<div>
				<div id="_idContainer323" class="IMG---Figure">
					<img src="image/B17338_10_35.jpg" alt="Deleting the pod will automatically delete the Secret as well"/>
				</div>
			</div>
			<p class="figure">Figure 10.35: Deleting the pod automatically deletes the secret as well</p>
			<p>This shows you that although you have a SecretProviderClass that tries to sync a Key Vault secret to a Kubernetes secret, that syncing only happens once a pod references that SecretProviderClass and mounts the secret.</p>
			<p>In this section, you've been able to sync a secret in Key Vault to a secret in Kubernetes. You were able to access that secret's value in a pod using environment variables.</p>
			<p>This also concludes this chapter on secrets in Kubernetes. Let's make sure to clean up all the objects that we created:</p>
			<p class="snippet">kubectl delete -f .</p>
			<p class="snippet">helm delete csi-secrets</p>
			<p class="snippet">az aks pod-identity delete --resource-group rg-handsonaks \</p>
			<p class="snippet">  --cluster-name handsonaks --namespace default \</p>
			<p class="snippet">  --name csi-to-key-vault </p>
			<p class="snippet">az group delete -n csi-key-vault --yes</p>
			<p>Once the resources are deleted, you are ready to move on to the next chapter about network security in AKS.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor132"/>Summary</h2>
			<p>In this chapter, you learned about secrets in Kubernetes. You worked with both the default secret mechanism in Kubernetes as well as with the Azure Key Vault provider for Secrets Store CSI driver.</p>
			<p>This chapter started by explaining different secret types in Kubernetes. After that, you used different mechanisms in Kubernetes to create secrets. You then used two methods of accessing those secrets, using them as files or as environment variables.</p>
			<p>After that, you created a managed identity and a key vault to experiment with the CSI driver for Key Vault. You installed that on your cluster and used two mechanisms to access secrets in Key Vault: either using files or using environment variables.</p>
			<p>In the next chapter, you'll learn more about network security in AKS.</p>
		</div>
	</body></html>