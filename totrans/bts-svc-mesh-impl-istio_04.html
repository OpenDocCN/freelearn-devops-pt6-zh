<html><head></head><body>
		<div id="_idContainer053">
			<h1 id="_idParaDest-66" class="chapter-number"><a id="_idTextAnchor065"/><a id="_idIndexMarker347"/>4</h1>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/>Managing Application Traffic</h1>
			<p>Microservices architecture creates a sprawl of loosely coupled applications deployed as containers on platforms such as Kubernetes. With the loose coupling of applications, inter-service traffic management becomes complex. If exposed insecurely to external systems, it can cause exposure of sensitive data, making your system vulnerable to external threats. Istio provides various mechanisms to secure and govern the following kinds of <span class="No-Break">application traffic:</span></p>
			<ul>
				<li>Ingress traffic coming to your application <span class="No-Break">from outside</span></li>
				<li>Inter-mesh traffic generated between various components of <span class="No-Break">the application</span></li>
				<li>Egress traffic going out from your application to other applications outside <span class="No-Break">the mesh</span></li>
			</ul>
			<p>In this chapter, we will read about and practice managing application traffic by going through the following topics <span class="No-Break">in detail.</span></p>
			<ul>
				<li>Managing Ingress traffic using the Kubernetes Ingress resource and an <span class="No-Break">Istio Gateway</span></li>
				<li>Traffic routing and <span class="No-Break">canary release</span></li>
				<li><span class="No-Break">Traffic mirroring</span></li>
				<li>Routing traffic to services outside <span class="No-Break">the mesh</span></li>
				<li>Exposing Ingress <span class="No-Break">over HTTPS</span></li>
				<li><span class="No-Break">Managing Egress</span></li>
			</ul>
			<p>It will be a good idea to delete Istio and install it again to get a clean slate, as well as practice what you learned in <span class="No-Break"><em class="italic">Chapter 2</em></span>. Istio releases a minor version at a 3-month cadence, as described at <a href="https://istio.io/latest/docs/releases/supported-releases/">https://istio.io/latest/docs/releases/supported-releases/</a>; therefore, it is recommended to keep your Istio version up to date using the documentation on the Istio website (<a href="https://istio.io/latest/docs/setup/getting-started/#download">https://istio.io/latest/docs/setup/getting-started/#download</a>) and the concepts you learned about in <span class="No-Break"><em class="italic">Chapter 2</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Technical requirements</h1>
			<p>In this section, we will create an AWS cloud setup, which will be used to perform hands-on exercises in this and subsequent chapters. You can use any cloud provider of your choice, but to introduce some variety in this book, I have selected AWS for <em class="italic">Part 2</em> and Google Cloud for <em class="italic">Part 3</em>. You can also use minikube for the exercises, but you will need at least a quad-core processor and 16 GB or more of RAM assigned to minikube for smooth, <span class="No-Break">lag-free operations.</span></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Setting up the environment</h2>
			<p><span class="No-Break">Let’s go!</span></p>
			<ol>
				<li>Create an<a id="_idIndexMarker348"/> AWS account. If you don’t already have an AWS account, then it’s time to sign up with AWS <span class="No-Break">using </span><a href="https://portal.aws.amazon.com/billing/signup#/start/email"><span class="No-Break">https://portal.aws.amazon.com/billing/signup#/start/email</span></a><span class="No-Break">.</span></li>
				<li>Set up the <span class="No-Break">AWS CLI:</span><ol><li>Install the AWS CLI using the steps provided <span class="No-Break">at </span><a href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html"><span class="No-Break">https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html</span></a><span class="No-Break">.</span></li><li>Configure the AWS CLI using the steps provided <span class="No-Break">at </span><a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html"><span class="No-Break">https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html</span></a><span class="No-Break">.</span></li></ol></li>
				<li>Install the AWS IAM authenticator using the steps provided <span class="No-Break">at </span><a href="https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html"><span class="No-Break">https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html</span></a><span class="No-Break">.</span></li>
				<li>Install Terraform, which is infrastructure-as-code software that automates the provisioning of infrastructure. This helps you to create an infrastructure that is consistent with the infrastructure used for the exercises in this book. I hope this provides a hassle-free experience where you can spend more time learning about Istio rather than troubleshooting infrastructure issues. Follow the steps provided <span class="No-Break">at </span><a href="https://learn.hashicorp.com/tutorials/terraform/install-cli?in=terraform/aws-get-started"><span class="No-Break">https://learn.hashicorp.com/tutorials/terraform/install-cli?in=terraform/aws-get-started</span></a><span class="No-Break">.</span></li>
			</ol>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>Creating an EKS cluster</h2>
			<p>Next, you will need<a id="_idIndexMarker349"/> to create an EKS cluster. <strong class="bold">EKS</strong> stands <a id="_idIndexMarker350"/>for <strong class="bold">Elastic Kubernetes Service</strong>, which is a managed service offering from AWS. EKS provides a hassle-free and easy-to-use Kubernetes cluster where you don’t need to worry about the setup and operation of the Kubernetes control plane. We will make use of Terraform to set up an EKS cluster; the Terraform code and config are available at <strong class="source-inline">sockshop/devops/deploy/terraform</strong> in the source code repo of <span class="No-Break">this book.</span></p>
			<p>Perform the following steps from the <span class="No-Break"><strong class="source-inline">sockshop/devops/deploy/terraform/src</strong></span><span class="No-Break"> folder:</span></p>
			<ol>
				<li>Initialize Terraform. Prepare the working directory so that Terraform can run <span class="No-Break">the configurations:</span><pre class="source-code">
<strong class="bold">% terraform init</strong>
<strong class="bold">Initializing the backend...</strong>
<strong class="bold">Initializing provider plugins...</strong>
<strong class="bold">- Reusing previous version of hashicorp/aws from the dependency lock file</strong>
<strong class="bold">- Using previously-installed hashicorp/aws v4.26.0</strong>
<strong class="bold">Terraform has been successfully initialized!</strong></pre></li>
			</ol>
			<p>You can read about <strong class="source-inline">init</strong> <span class="No-Break">at </span><a href="https://developer.hashicorp.com/terraform/tutorials/cli/init"><span class="No-Break">https://developer.hashicorp.com/terraform/tutorials/cli/init</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="2">Configure Terraform variables by modifying <strong class="source-inline">sockshop/devops/deploy/terraform/src/variables.tf</strong>. Default values will work, but you can also modify them to suit <span class="No-Break">your requirements.</span></li>
				<li>Plan the deployment. In this step, Terraform creates an execution plan that you can inspect to find any discrepancies and get a preview of the infrastructure, although it is not <span class="No-Break">provisioned yet.</span></li>
			</ol>
			<p>The output in the following code snippet is shortened to <span class="No-Break">save space:</span></p>
			<pre class="source-code">
<strong class="bold">% terraform plan</strong>
<strong class="bold">………</strong>
<strong class="bold">~ cluster_endpoint       = "https://647937631DD1A55F1FDDAB99E08DEE0C.gr7.us-east-1.eks.amazonaws.com" -&gt; (known after apply)</strong></pre>
			<p>You can read more about <strong class="source-inline">plan</strong> <span class="No-Break">at </span><a href="https://developer.hashicorp.com/terraform/tutorials/cli/plan"><span class="No-Break">https://developer.hashicorp.com/terraform/tutorials/cli/plan</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="4">Provision the infrastructure. In this step, Terraform will create the infrastructure as per the execution plan created in <span class="No-Break">previous steps:</span><pre class="source-code">
<strong class="bold">% terraform apply</strong></pre></li>
			</ol>
			<p>Once the infrastructure is provisioned, Terraform will also set a variable as defined <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">sockshop/devops/deploy/terraform/src/outputs.tf</strong></span><span class="No-Break">.</span></p>
			<p>You can read<a id="_idIndexMarker351"/> more about <strong class="source-inline">apply</strong> <span class="No-Break">at </span><a href="https://developer.hashicorp.com/terraform/tutorials/cli/apply"><span class="No-Break">https://developer.hashicorp.com/terraform/tutorials/cli/apply</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Setting up kubeconfig and kubectl</h2>
			<p>Next, we will <a id="_idIndexMarker352"/>configure <a id="_idIndexMarker353"/>kubectl to be able to connect the newly created EKS cluster using Terraform. Use the following aws cli command to update kubeconfig with <span class="No-Break">cluster details:</span></p>
			<pre class="console">
% aws eks --region $(terraform output -raw region) update-kubeconfig --name $(terraform output -raw cluster_name)</pre>
			<p>Next, check that kubectl is using the <span class="No-Break">correct context:</span></p>
			<pre class="console">
% kubectl config current-context</pre>
			<p>If the value is not as expected, you can perform <span class="No-Break">the following:</span></p>
			<pre class="console">
% kubectl config view -o json | jq '.contexts[].name'
"arn:aws:eks:us-east-1:803831378417:cluster/MultiClusterDemo-Cluster1-cluster"
"minikube"</pre>
			<p>Find the correct name of the cluster and then use the following command to set the <span class="No-Break">kubectl context:</span></p>
			<pre class="console">
% kubectl config use-context "arn:aws:eks:us-east-1:803831378417:cluster/MultiClusterDemo-Cluster1-cluster"
Switched to context "arn:aws:eks:us-east-1:803831378417:cluster/MultiClusterDemo-Cluster1-cluster".</pre>
			<p>There will be instances where you will need to use minikube. In such a case, simply use the following<a id="_idIndexMarker354"/> command<a id="_idIndexMarker355"/> to switch context, and vice versa for switching back <span class="No-Break">to EKS:</span></p>
			<pre class="console">
% kubectl config use-context minikube
Switched to context "minikube".</pre>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Deploying the Sockshop application</h2>
			<p>Finally, to add<a id="_idIndexMarker356"/> some variety to hands-on exercises, we will make use of a demo application called Sockshop available at <a href="https://github.com/microservices-demo/microservices-demo">https://github.com/microservices-demo/microservices-demo</a>. You can find the deployment files <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">sockshop/devops/deploy/kubernetes/manifests</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
% kubectl create -f sockshop/devops/deploy/kubernetes/manifests/00-sock-shop-ns.yaml
% kubectl create -f  sockshop/devops/deploy/kubernetes/manifests/* -n sock-shop</pre>
			<p>This will deploy the Sockshop application, and you are all set with the environment. The next step for you is to install the latest version of Istio using the instructions at <a href="https://istio.io/latest/docs/setup/install/istioctl/">https://istio.io/latest/docs/setup/install/istioctl/</a> and the concepts you learned about in <span class="No-Break"><em class="italic">Chapter 2</em></span><span class="No-Break">.</span></p>
			<p>In the rest of the chapter and the book, we will be making use of the Sockshop application to demonstrate various Service Mesh concepts. Feel free to use the sample <strong class="source-inline">BookInfo</strong> application that is provided with Istio, or any other application you may like for performing hands-on exercises. Let’s <span class="No-Break">get started!</span></p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Managing Ingress traffic using the Kubernetes Ingress resource</h1>
			<p>When building<a id="_idIndexMarker357"/> applications<a id="_idIndexMarker358"/> that need to be consumed by other applications from outside the network boundary in which the application is deployed, you will need to build an Ingress point using which the consumers can reach the application. In Kubernetes, a Service is an abstraction through which a set of Pods are exposed as a network service. When these services need to be consumed by other applications, they need to be made externally accessible. Kubernetes supports <strong class="source-inline">ClusterIP</strong> for consuming services internally from within the cluster, <strong class="source-inline">NodePort</strong> for consuming the service outside the cluster but within the network, <strong class="source-inline">LoadBalancer</strong> for consuming the services externally via the cloud load balancer, and there are also options for exposing an internal-facing load balancer for internal traffic outside of the Kubernetes cluster. In this section, we will read about how we can configure Istio to expose a service using the Kubernetes <span class="No-Break">Ingress resource.</span></p>
			<p>In the previous chapter, we exposed the frontend service as a <strong class="source-inline">NodePort</strong> type and accessed it via minikube tunnel as well as AWS <strong class="source-inline">Loadbalancer</strong>. This approach takes away any control we might need on how the traffic to the frontend service should <span class="No-Break">be managed.</span></p>
			<p>So, instead of making use of <strong class="source-inline">Loadbalancer</strong> service types to expose the frontend service, let’s make the frontend service internal facing and rather make use of the Kubernetes Ingress resource. Update the frontend service Kubernetes configuration by removing <strong class="source-inline">NodePort</strong> (if using minikube) or <strong class="source-inline">LoadBalancer</strong> (if deploying on AWS) by removing the following lines from the <span class="No-Break">YAML file:</span></p>
			<pre class="source-code">
type: NodePort
…..
    nodePort: 30001</pre>
			<p>The preceding changes make the service type take the default value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">ClusterIp</strong></span><span class="No-Break">.</span></p>
			<p>The updated file is also available in the <strong class="source-inline">Chapter4</strong> folder under the <span class="No-Break">name </span><span class="No-Break"><strong class="source-inline">10-1-front-end-svc.yaml</strong></span><span class="No-Break">.</span></p>
			<p>Go ahead and change the frontend service type to <strong class="source-inline">ClusterIP</strong> using the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ kubectl apply -f Chapter4/ClusterIp-front-end-svc.yaml</pre>
			<p>After the changes, you will notice that the Sockshop website is not accessible from the browser due to <span class="No-Break">obvious reasons.</span></p>
			<p>Now, we will make use of the Kubernetes Ingress resource to provide access to the Sockshop frontend service. Kubernetes Ingress is a way to provide access to <strong class="source-inline">ClusterIP</strong> services in the cluster. Ingress defines the addressed host accepted by Ingress, along with a list of URIs and the services to which the request needs to be routed. The following is an illustration <a id="_idIndexMarker359"/>highlighting<a id="_idIndexMarker360"/> <span class="No-Break">this concept:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B17989_04_01.jpg" alt="Figure 4.1 – Kubernetes Ingress resource"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Kubernetes Ingress resource</p>
			<p>Along with defining Ingress, we also need to define Ingress controllers, which are another Kubernetes resource that is responsible for handling the traffic as per the specification defined in the <span class="No-Break">Ingress resource.</span></p>
			<p>The following illustrates the relationship between Ingress, Ingress controllers, and Services. Please note that Ingress is<a id="_idIndexMarker361"/> a<a id="_idIndexMarker362"/> logical construct – that is, a set of rules enforced by the <span class="No-Break">Ingress controller.</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B17989_04_02.jpg" alt="Figure 4.2 – Ingress controllers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Ingress controllers</p>
			<p>Next, we will be making use of the Istio Gateway controller to handle the Ingress; we read about the Istio Gateway in <span class="No-Break"><em class="italic">Chapter 3</em></span><span class="No-Break">.</span></p>
			<p>We will need to provide the following configuration, also defined in <strong class="source-inline">Chapter4/1-istio-ingress.yaml</strong>, to make <span class="No-Break">the changes:</span></p>
			<pre class="source-code">
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  annotations:
    kubernetes.io/ingress.class: istio
  name: sockshop-istio-ingress
  namespace: sock-shop
spec:
  rules:
  - host: "sockshop.com"
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: front-end
            port:
              number: 80</pre>
			<p>In the <a id="_idIndexMarker363"/>preceding<a id="_idIndexMarker364"/> configuration, we are doing <span class="No-Break">the following:</span></p>
			<ul>
				<li>Creating an Ingress resource with an annotation of <strong class="source-inline">kubernetes.io/ingress.class: istio</strong>, which, via admission controllers, as we discussed in <span class="No-Break"><em class="italic">Chapter 3</em></span>, tells Istio that this Ingress is to be handled by the <span class="No-Break">Istio Gateway.</span></li>
				<li>The Ingress resource is defined in the <strong class="source-inline">sock-shop</strong> namespace, as that’s where our Sockshop frontend <span class="No-Break">service exists.</span></li>
				<li>A rule that says that any request specified by <strong class="source-inline">path</strong> of the <strong class="source-inline">/</strong> value and destined for the <strong class="source-inline">"sockshop.com"</strong> host (specified by <strong class="source-inline">host</strong> and the <strong class="source-inline">sockshop.com</strong> value) should be handled by <span class="No-Break">this Ingress.</span></li>
				<li>Within the <strong class="source-inline">path</strong> configuration, we are configuring <strong class="source-inline">pathType</strong> of <strong class="source-inline">Prefix</strong>, which basically means that any request of the <strong class="source-inline">hostname/</strong> format will be matched. Other values for <strong class="source-inline">pathType</strong> are <span class="No-Break">as follows:</span><ul><li><strong class="source-inline">Exact</strong>: the path is matching exactly as specified <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">path</strong></span></li><li><strong class="source-inline">ImplementationSpecific</strong>: the matching of <strong class="source-inline">path</strong> is decided by the underlying implementation of the <span class="No-Break">Ingress controller</span></li></ul></li>
			</ul>
			<p>Apply the rule using the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ kubectl create -f Chapter4/1-istio-ingress.yaml</pre>
			<p>If you are using minikube for this exercise, then run <strong class="source-inline">minikube tunnel</strong> in a separate terminal and get<a id="_idIndexMarker365"/> the<a id="_idIndexMarker366"/> external IP from the output. Find the port at which the service is exposed by the Istio Ingress gateway using the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ kubectl get svc istio-ingressgateway -n istio-system -o wide
NAME                   TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)                                                                      AGE    SELECTOR
istio-ingressgateway   LoadBalancer   10.97.245.106   10.97.245.106   15021:32098/TCP,80:31120/TCP,443:30149/TCP,31400:30616/TCP,15443:32339/TCP   6h9m   app=istio-ingressgateway,istio=ingressgateway</pre>
			<p>In this instance, the Ingress gateway is exposing traffic from port <strong class="source-inline">80</strong> to Ingress port <strong class="source-inline">31120</strong>, and <strong class="source-inline">443</strong> to <strong class="source-inline">30149</strong>, but it may be different for <span class="No-Break">your setup.</span></p>
			<p>If you followed the instruction in <span class="No-Break"><em class="italic">Chapter 4</em></span> to use AWS EKS, then the IP and ports will be different; the following is an equivalent of minikube for <span class="No-Break">AWS EKS:</span></p>
			<pre class="console">
$ kubectl get svc istio-ingressgateway -n istio-system
NAME                   TYPE           CLUSTER-IP       EXTERNAL-IP                                                               PORT(S)                                                                      AGE
istio-ingressgateway   LoadBalancer   172.20.143.136   a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com   15021:30695/TCP,80:30613/TCP,443:30166/TCP,31400:30402/TCP,15443:31548/TCP   29h</pre>
			<p>In this example, the Ingress gateway is exposed via an AWS classic load balancer at <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">http://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com:80</strong> for <span class="No-Break">HTTP traffic</span></li>
				<li><strong class="source-inline">https://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com:443</strong> for <span class="No-Break">HTTPS traffic</span></li>
			</ul>
			<p>Going forward, please use appropriate IPs and ports depending on your choice of environment. The examples in the rest of the chapters are deployed on the AWS EKS cluster, but they will also work for any other <span class="No-Break">Kubernetes provider.</span></p>
			<p>Go ahead and test <a id="_idIndexMarker367"/>the<a id="_idIndexMarker368"/> Ingress to frontend service <span class="No-Break">via </span><span class="No-Break"><strong class="source-inline">curl</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
curl -HHost:sockshop.com http://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com/</pre>
			<p>Or if using the Chrome browser, then use extensions such as ModHeader, available at <a href="http://modheader.com/">http://modheader.com/</a>. In either case, you will need to provide the <strong class="source-inline">host</strong> header with the value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">sockshop.com</strong></span><span class="No-Break">.</span></p>
			<p>So, we saw how the Istio Ingress gateway can be configured to handle <span class="No-Break">Kubernetes Ingress.</span></p>
			<p>Let’s add another Ingress rule to see how the Istio Ingress controller can handle multiple Ingress rules. We will be making use of the <strong class="source-inline">envoy</strong> configuration we did in <span class="No-Break"><em class="italic">Chapter 3</em></span>, where we used a router filter to return a <span class="No-Break">dummy string:</span></p>
			<ol>
				<li>In the following command, we are creating a <strong class="source-inline">chapter4</strong> namespace so that we can be organized, and it will be easier to <span class="No-Break">clean up:</span><pre class="source-code">
<strong class="bold">$ kubectl create ns chapter4</strong></pre></li>
				<li>At this stage, we don’t need automatic sidecar injection, but from a visibility point of view and for getting meaningful information from Kiali, it will be a good idea to enable Istio sidecar injection using the following command we discussed in <span class="No-Break"><em class="italic">Chapter 2</em></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">$ kubectl label namespace chapter4 istio-injection=enabled --overwrite</strong></pre></li>
				<li>We will then go ahead with the creation of <strong class="source-inline">configmap</strong> to load <strong class="source-inline">envoy</strong> config (also discussed in <span class="No-Break"><em class="italic">Chapter 3</em></span>), which will be required by the Pods we will be creating in the <span class="No-Break">next step:</span><pre class="source-code">
<strong class="bold">$ kubectl create configmap envoy-dummy --from-file=Chapter3/envoy-config-1.yaml -n chapter4</strong></pre></li>
				<li>Next, we are <a id="_idIndexMarker369"/>creating <a id="_idIndexMarker370"/>the service and deployment to run <strong class="source-inline">envoy</strong> to return a dummy response for all <span class="No-Break">HTTP requests:</span><pre class="source-code">
<strong class="bold">$ kubectl apply -f Chapter4/01-envoy-proxy.yaml</strong></pre></li>
				<li>And finally, we create an Ingress rule to route all traffic destined for <strong class="source-inline">mockshop.com</strong> to the <strong class="source-inline">envoy</strong> service we created in the <span class="No-Break">previous step:</span><pre class="source-code">
<strong class="bold">$ kubectl apply -f Chapter4/2-istio-ingress.yaml</strong></pre></li>
				<li>Go ahead and test using the <strong class="source-inline">sockshop.com</strong> and <strong class="source-inline">mockshop.com</strong> hosts headers; the Istio Ingress controller will manage the routing to the appropriate destination as per defined <span class="No-Break">Ingress rules.</span></li>
			</ol>
			<p>The following illustration describes what we have configured so far. Note how the Ingress rules define the routing of traffic to Service A and B based <span class="No-Break">on hostnames:</span></p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B17989_04_03.jpg" alt="Figure 4.3 – Snapshot of Ingress configuration"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Snapshot of Ingress configuration</p>
			<p>In this section, we<a id="_idIndexMarker371"/> discussed<a id="_idIndexMarker372"/> how to expose services outside of the Kubernetes cluster using the Kubernetes Ingress resource and Istio Ingress controller. In this kind of Ingress configuration, although we are using Istio to manage the Ingress, we are limited by the spec of Kubernetes Ingress, which allows Ingress controllers to perform limited functions such as load balancing, SSL termination, and name-based virtual hosting. When using the Kubernetes Ingress resource type, we are not leveraging a wide range of functionality provided by Istio to manage Ingress. When using Istio, it is recommended to use the Istio Gateway CRD to manage Ingress; we will be discussing that in the <span class="No-Break">next section.</span></p>
			<p>Before moving on, let’s do some technical cleanup of your environment so that it doesn’t conflict<a id="_idIndexMarker373"/> with<a id="_idIndexMarker374"/> <span class="No-Break">upcoming exercises:</span></p>
			<pre class="console">
$ kubectl delete -f Chapter4/2-istio-ingress.yaml
$ kubectl delete -f Chapter4/1-istio-ingress.yaml</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout">Throughout this book, we will be leaving you reminders to reverse or clean up the configurations. You can use the preceding commands to execute <span class="No-Break">the cleanup.</span></p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Managing Ingress using the Istio Gateway</h1>
			<p>When managing<a id="_idIndexMarker375"/> Ingress, it is recommended to make use of Istio Gateway over the Kubernetes Ingress resource. Istio Gateway is like a load balancer running at the edge of the mesh receiving incoming HTTP and <span class="No-Break">TCP connections.</span></p>
			<p>When configuring Ingress via Istio Gateway, you need to perform the <span class="No-Break">following tasks.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>Creating the gateway</h2>
			<p>The following <a id="_idIndexMarker376"/>code block creates an Istio <span class="No-Break">Gateway resource:</span></p>
			<pre class="source-code">
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: chapter4-gateway
  namespace: chapter4
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - "sockshop.com"
    - "mockshop.com"</pre>
			<p>Here, we are declaring a Kubernetes resource named <strong class="source-inline">chapter4-gateway</strong> of the <strong class="source-inline">gateway.networking.istio.io</strong> type custom resource definition in the <strong class="source-inline">chapter4</strong> namespace. This is also equivalent to defining a <span class="No-Break">load balancer.</span></p>
			<p>In the <strong class="source-inline">servers</strong> property, we are defining <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">hosts</strong>: These are one or more DNS names exposed by the gateway. In the preceding example, we are defining two hosts: <strong class="source-inline">sockshop.com</strong> and <strong class="source-inline">mockshop.com</strong>. Any other hosts apart from these two will be rejected by the <span class="No-Break">Ingress gateway.</span></li>
				<li><strong class="source-inline">port</strong>: In the port configuration, we define port numbers and the protocols, which can be either <strong class="source-inline">HTTP</strong>, <strong class="source-inline">HTTPS</strong>, <strong class="source-inline">gRPC</strong>, <strong class="source-inline">TCP</strong>, <strong class="source-inline">TLS</strong>, or <strong class="source-inline">Mongo</strong>. The name of the port can be anything you like to use. In this example, we are exposing port <strong class="source-inline">80</strong> over the <span class="No-Break"><strong class="source-inline">HTTP</strong></span><span class="No-Break"> protocol.</span></li>
			</ul>
			<p>To summarize, the <a id="_idIndexMarker377"/>gateway will accept any HTTP request over port <strong class="source-inline">80</strong> with the host header of <strong class="source-inline">sockshop.com</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">mockshop.com</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Creating virtual services</h2>
			<p>A virtual service is <a id="_idIndexMarker378"/>another set of abstractions <a id="_idIndexMarker379"/>between the Ingress gateway and destination services. Using virtual services, you declare how the traffic for a single host (such as <strong class="source-inline">sockshop.com</strong>) or multiple hosts (such as <strong class="source-inline">mockshop.com</strong> and <strong class="source-inline">sockshop.com</strong>) should be routed to its destination. For example, you can define the following in a virtual service for all traffic addressed <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">sockshop.com</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Request with the <strong class="source-inline">/path1</strong> URI should go to service 1, and <strong class="source-inline">/path2</strong> should go to <span class="No-Break">service 2</span></li>
				<li>Route request based on the value of header or <span class="No-Break">query parameters</span></li>
				<li>Weight-based routing or traffic splitting – for example, 60% of the traffic goes to version 1 of the service and 40% goes to another version of <span class="No-Break">the traffic</span></li>
				<li>Define timeouts – that is, if a response is not received from the upstream service in <em class="italic">X</em> seconds, then the request should <span class="No-Break">time out</span></li>
				<li>Retry – that is, how many times a request should be attempted if the upstream system is not responding or is too slow <span class="No-Break">to respond</span></li>
			</ul>
			<p>All these routing features are implemented via virtual services, and we will read more about them in this chapter as well as the <span class="No-Break">next chapter.</span></p>
			<p>In the following configuration, we are defining two virtual services that contain rules regarding traffic<a id="_idIndexMarker380"/> matching and to what destination<a id="_idIndexMarker381"/> it should <span class="No-Break">be routed:</span></p>
			<pre class="source-code">
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: sockshop
  namespace: chapter4
spec:
  hosts:
  - "sockshop.com"
  gateways:
  - chapter4-gateway
  http:
  - match:
    - uri:
        prefix: /
    route:
    - destination:
        port:
          number: 80
        host: front-end.sock-shop.svc.cluster.local</pre>
			<p>In the preceding configuration, we have defined a virtual service named <strong class="source-inline">sockshop</strong>. In the <strong class="source-inline">spec</strong> property, we are defining <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">hosts</strong>: The rules in this virtual service will be applied to traffic destined for <strong class="source-inline">sockshop.com</strong> as defined <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">host</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">gateway</strong>: This virtual service is associated with <strong class="source-inline">chapter4-gateway</strong> we created in step 1 (<em class="italic">Creating the gateway</em>); this enforces that any other traffic not associated with the mentioned gateway will not be processed by this virtual <span class="No-Break">service configuration.</span></li>
				<li><strong class="source-inline">http</strong>: Here, we <a id="_idIndexMarker382"/>will define rules and <a id="_idIndexMarker383"/>routing information for HTTP traffic. There is also an option for defining <strong class="source-inline">tls</strong> and <strong class="source-inline">tcp</strong> routes; <strong class="source-inline">tls</strong> is used for passthrough TLS or HTTPS traffic, whereas <strong class="source-inline">tcp</strong> is used for opaque <span class="No-Break">TCP traffic.</span></li>
				<li><strong class="source-inline">match</strong>: These contain the matching criteria and can be based on path, headers, and so on. In this example, we are instructing that all traffic will be routed as per the instruction in <span class="No-Break">this section.</span></li>
				<li><strong class="source-inline">route</strong>: If the traffic is matched, the traffic is routed as per the information provided here. In this example, we are routing traffic to <strong class="source-inline">front-end.sock-shop.svc.cluster.local</strong> on <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">80</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>You can find the declaration of the corresponding virtual service for <strong class="source-inline">envoy-dummy-svc</strong> in <strong class="source-inline">Chapter4/3-istio-gateway.yaml</strong>. The file combines the declaration of the gateway and <span class="No-Break">virtual services.</span></p>
			<p>As a next step, if not already deleted as per the cleanup notes of the previous section, then please delete the Ingress resources you created in the previous section so that they do not conflict with the configuration we will be applying in <span class="No-Break">this section.</span></p>
			<p>Apply the <span class="No-Break">new configuration:</span></p>
			<pre class="console">
$ kubectl apply -f chapter4/3-istio-gateway.yaml</pre>
			<p>Please test that you are able to access <strong class="source-inline">sockshop.com</strong> and <strong class="source-inline">mockshop.com</strong> using your preferred HTTP <a id="_idIndexMarker384"/>client, and do not forget to inject<a id="_idIndexMarker385"/> the correct <span class="No-Break"><strong class="source-inline">host</strong></span><span class="No-Break"> header.</span></p>
			<p>If you are finding it difficult to visualize the end-to-end configuration, then take the help of the <span class="No-Break">following illustrations:</span></p>
			<ul>
				<li>The following diagram summarizes the configuration in <span class="No-Break">this section:</span></li>
			</ul>
			<p class="IMG---Figure">  </p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B17989_04_04.jpg" alt="Figure 4.4 – Virtual services"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Virtual services</p>
			<ul>
				<li>The following<a id="_idIndexMarker386"/> diagram <a id="_idIndexMarker387"/>summarizes the association between various Istio CRDs and <span class="No-Break">Kubernetes resources:</span></li>
			</ul>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B17989_04_05.jpg" alt="Figure 4.5 – Association between virtual services and other Istio resources"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Association between virtual services and other Istio resources</p>
			<p>In this section, we<a id="_idIndexMarker388"/> learned how to use Istio Gateway<a id="_idIndexMarker389"/> and virtual services for <span class="No-Break">managing Ingress.</span></p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">Please clean up <strong class="source-inline">chapter4/3-istio-gateway.yaml</strong> to avoid conflict with the <span class="No-Break">upcoming exercises.</span></p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Traffic routing and canary release</h1>
			<p>In the previous<a id="_idIndexMarker390"/> section, we <a id="_idIndexMarker391"/>went through some of the functionality of virtual services; in this section, let’s go through how you can distribute traffic to <span class="No-Break">multiple destinations.</span></p>
			<p>I’m assuming you have the <strong class="source-inline">envoy-dummy</strong> config map configured and the <strong class="source-inline">envoy</strong> Pod and service running as per the <strong class="source-inline">01-envoy-proxy.yaml</strong> file. If not, follow the instructions in the previous section to get <span class="No-Break">these configured.</span></p>
			<p>In the following exercise, we will be creating another version of the <strong class="source-inline">envoydummy</strong> Pod called <strong class="source-inline">v2</strong>, which returns a different response than <strong class="source-inline">v1</strong>. We will deploy <strong class="source-inline">v2</strong> alongside <strong class="source-inline">v1</strong> and then configure traffic splitting between the two versions of the <span class="No-Break"><strong class="source-inline">envoydummy</strong></span><span class="No-Break"> Pods:</span></p>
			<ol>
				<li>Create another <a id="_idIndexMarker392"/>version <a id="_idIndexMarker393"/>of the <strong class="source-inline">envoy</strong> mock service but with a <span class="No-Break">different message:</span><pre class="source-code">
direct_response:
                  status: 200
                  body:
                    inline_string: "V2----------Bootstrap Service Mesh Implementation with Istio----------V2"</pre></li>
				<li>The changes can be found in <strong class="source-inline">Chapter4/envoy-config-2.yaml</strong>; go ahead and create another <span class="No-Break">config map:</span><pre class="source-code">
<strong class="bold">$ kubectl create configmap envoy-dummy-2 --from-file=Chapter4/envoy-config-2.yaml -n chapter4</strong></pre></li>
				<li>Then, create another Deployment, but this time label the Pods <span class="No-Break">as follows:</span><pre class="source-code">
template:
    metadata:
      labels:
        name: envoyproxy
        version: v2</pre></li>
				<li>Apply <span class="No-Break">the changes:</span><pre class="source-code">
<strong class="bold">$ kubectl apply -f Chapter4/02-envoy-proxy.yaml</strong></pre></li>
				<li>Next, we will be creating another virtual service, but with the <span class="No-Break">following changes:</span><pre class="source-code">
    route:
    - destination:
        port:
          number: 80
        subset: v1
        host: envoy-dummy-svc
      weight: 10
    - destination:
        port:
          number: 80
        subset: v2
        host: envoy-dummy-svc
      weight: 90</pre></li>
			</ol>
			<p>You must have noticed that we have two destinations under the same route. <strong class="source-inline">destination</strong> indicates the location of the service to which the requests are eventually routed. Under <strong class="source-inline">destination</strong>, we have the following <span class="No-Break">three fields:</span></p>
			<ul>
				<li><strong class="source-inline">host</strong>: This states the service name to which the request should be routed. The service names are resolved against the Kubernetes service registry or hosts registered by Istio <a id="_idIndexMarker394"/>service<a id="_idIndexMarker395"/> entry. We will read about service entry in the <span class="No-Break">next section.</span></li>
				<li><strong class="source-inline">subset</strong>: This is a subset of the service defined by the destination rule, as <span class="No-Break">described next.</span></li>
				<li><strong class="source-inline">port</strong>: This is the port on which the service <span class="No-Break">is reachable.</span></li>
			</ul>
			<p>We are also associating weights to the routing rules, specifying that 10% of traffic should be sent to <strong class="source-inline">subset: v1</strong>, whereas 90% should be sent to <span class="No-Break"><strong class="source-inline">subset: v2</strong></span><span class="No-Break">.</span></p>
			<p>Following the virtual service definition, we also need to define destination rules. Destination rules are a set of rules applied to the traffic after they have gone through the virtual service <span class="No-Break">routing rules.</span></p>
			<p>In the following configuration, we are defining a destination rule called <strong class="source-inline">envoy-destination</strong>, which will be applied to traffic destined for <strong class="source-inline">envoy-dummy-svc</strong>. It further defines two subsets – <strong class="source-inline">subset: v1</strong> corresponds to the <strong class="source-inline">envoy-dummy-svc</strong> endpoints with the <strong class="source-inline">version = v1</strong> label, while <strong class="source-inline">subset: v2</strong> corresponds to endpoints with the <strong class="source-inline">version = </strong><span class="No-Break"><strong class="source-inline">v2</strong></span><span class="No-Break"> label:</span></p>
			<pre class="source-code">
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: envoy-destination
  namespace: chapter4
spec:
  host: envoy-dummy-svc
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2</pre>
			<p>Apply <span class="No-Break">the changes:</span></p>
			<pre class="console">
kubectl apply -f Chapter4/4a-istio-gateway.yaml</pre>
			<p>You will notice <a id="_idIndexMarker396"/>that 10% of the<a id="_idIndexMarker397"/> request will be returning <strong class="source-inline">Bootstrap Service Mesh Implementation with Istio</strong>, and 90% of the request will be returning the <strong class="source-inline">V2----------Bootstrap Service Mesh Implementation with </strong><span class="No-Break"><strong class="source-inline">Istio----------V2</strong></span><span class="No-Break"> response.</span></p>
			<p>If you are finding it difficult to visualize the end-to-end configuration, then take the help of the following illustration, which summarizes the configuration in <span class="No-Break">this section:</span></p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B17989_04_06.jpg" alt="Figure 4.6 – Destination rules"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Destination rules</p>
			<p>The following diagram <a id="_idIndexMarker398"/>summarizes <a id="_idIndexMarker399"/>the association between various Istio CRDs and <span class="No-Break">Kubernetes resources:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B17989_04_07.jpg" alt="Figure 4.7 – Association between destination rules and other Istio resources"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Association between destination rules and other Istio resources</p>
			<p>You can also check in the Kiali dashboard that traffic is getting routed in a 1:9 ratio between the <span class="No-Break">two services:</span></p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B17989_04_08.jpg" alt="Figure 4.8 – Kiali dashboard showing traffic split"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Kiali dashboard showing traffic split</p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">Please clean up <strong class="source-inline">Chapter4/4a-istio-gateway.yaml</strong> to avoid conflicts in the <span class="No-Break">upcoming exercises.</span></p>
			<p>In this section, you<a id="_idIndexMarker400"/> learned <a id="_idIndexMarker401"/>how to route or split traffic between two versions of a service. This is fundamental to various operations related to traffic management, with the canary release being one of them. In the next section, we will read about traffic mirroring, which is also <a id="_idIndexMarker402"/>called <strong class="bold">traffic shadowing</strong>; it is another example of <span class="No-Break">traffic routing.</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Traffic mirroring</h1>
			<p><strong class="bold">Traffic mirroring</strong> is another <a id="_idIndexMarker403"/>important feature that allows you to asynchronously copy traffic being sent to an upstream to another upstream service as well, also known as <strong class="bold">mirrored service</strong>. Traffic mirroring is on a fire-and-forget basis, where the sidecar/gateway<a id="_idIndexMarker404"/> will not wait for responses from the <span class="No-Break">mirrored upstream.</span></p>
			<p>The following is an illustration of <span class="No-Break">traffic mirroring:</span></p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B17989_04_09.jpg" alt="Figure 4.9 – Traffic mirroring"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Traffic mirroring</p>
			<p>There are very interesting<a id="_idIndexMarker405"/> use cases for traffic mirroring, including <span class="No-Break">the following:</span></p>
			<ul>
				<li>Traffic mirroring to pre-production systems for <span class="No-Break">testing purposes</span></li>
				<li>Traffic mirroring to sink systems where traffic is recorded for <span class="No-Break">out-of-band analysis</span></li>
			</ul>
			<p>In the following example, in the virtual service definition under route configuration, we are mentioning that 100% of traffic should be mirrored to <span class="No-Break"><strong class="source-inline">subset: v2</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
  route:
    - destination:
        port:
          number: 80
        subset: v1
        host: envoydummy
      weight: 100
    mirror:
      host: nginxdummy
      subset: v2
    mirrorPercentage:
      value: 100.0</pre>
			<p>Before applying the <a id="_idIndexMarker406"/>preceding changes, first, create an nginx service using <span class="No-Break">the following:</span></p>
			<pre class="console">
kubectl apply -f utilities/nginx.yaml</pre>
			<p>After that, deploy the <span class="No-Break">virtual service:</span></p>
			<pre class="console">
kubectl apply -f chapter4/4b-istio-gateway.yaml</pre>
			<p>The following illustrates the configuration of virtual services and <span class="No-Break">destination rules:</span></p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B17989_04_10.jpg" alt="Figure 4.10 – Traffic mirroring via virtual services"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – Traffic mirroring via virtual services</p>
			<p>When accessing the service using <strong class="source-inline">curl</strong> or the browser with the <strong class="source-inline">mockshop.com</strong> host header, you will notice that you are always receiving a <strong class="source-inline">Bootstrap Service Mesh Implementation with </strong><span class="No-Break"><strong class="source-inline">Istio</strong></span><span class="No-Break"> response.</span></p>
			<p>But if you check the nginx <a id="_idIndexMarker407"/>logs using the <strong class="source-inline">kubectl logs nginxdummy -c nginx -n chapter4</strong> command, you will notice that nginx is also receiving the request, indicating that the traffic has been shadowed <span class="No-Break">to nginx.</span></p>
			<p>This completes a short section on traffic mirroring, a simple but powerful feature especially for event-driven architecture, testing, and training models when using machine learning and <span class="No-Break">artificial intelligence.</span></p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">Please clean up <strong class="source-inline">Chapter4/4b-istio-gateway.yaml</strong> to avoid conflict in <span class="No-Break">upcoming exercises.</span></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Routing traffic to services outside of the cluster</h1>
			<p>In your IT <a id="_idIndexMarker408"/>environments, not all services will be deployed within the Kubernetes cluster; there will be services running on traditional VMs or bare metal environments, there will be services that will be provided by SaaS providers as well as your business partners, and there will be services running outside or on a different Kubernetes cluster. In those scenarios, there is a requirement to let services from the mesh reach out to such services. So, as the next steps, let’s try building routes to a service outside of the cluster. We will make use of the <strong class="source-inline">httpbin</strong> service, available <span class="No-Break">at </span><a href="https://httpbin.org/"><span class="No-Break">https://httpbin.org/</span></a><span class="No-Break">.</span></p>
			<p>Any request destined for <strong class="source-inline">mockshop.com/get</strong> should be routed to <strong class="source-inline">httpbin</strong>; the rest should be processed by <strong class="source-inline">envoy-dummy-svc, which</strong> we created in the <span class="No-Break">previous section.</span></p>
			<p>In the following virtual service definition, we have defined that any request with <strong class="source-inline">/get</strong> should be routed <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">httpbin.org</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
- match:
    - uri:
        prefix: /get
    route:
    - destination:
        port:
          number: 80
        host: httpbin.org</pre>
			<p>Next, we will create <strong class="source-inline">ServiceEntry</strong>, which is a way of adding entries to Istio’s internal service registry. The Istio control plane manages a registry of all services within the mesh. The registry is populated from two kinds of data sources– one being the Kubernetes API server, which in turn uses etcd for maintaining a registry of all services in the cluster, and the second being a config store that is populated by <strong class="source-inline">ServiceEntry</strong> and <strong class="source-inline">WorkloadEntry</strong>. Now, <strong class="source-inline">ServiceEntry</strong> and <strong class="source-inline">WorkloadEntry</strong> are used to populate details about services that are unknown to the Kubernetes service registry. We will read about <strong class="source-inline">WorkloadEntry</strong> in <span class="No-Break"><em class="italic">Chapter 10</em></span><span class="No-Break">.</span></p>
			<p>The following is the <strong class="source-inline">ServiceEntry</strong> declaration for adding <strong class="source-inline">httpbin.org</strong> to the Istio <span class="No-Break">service registry:</span></p>
			<pre class="source-code">
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: httpbin-svc
  namespace: chapter4
spec:
  hosts:
  - httpbin.org
  location: MESH_EXTERNAL
  ports:
  - number: 80
    name: httpbin
    protocol: http
  resolution: DNS</pre>
			<p>In the <strong class="source-inline">ServiceEntry</strong> declaration, the<a id="_idIndexMarker409"/> following configurations <span class="No-Break">are defined:</span></p>
			<ul>
				<li><strong class="source-inline">resolution</strong>: Here, we define how the hostname should be resolved; the following are the <span class="No-Break">possible values:</span><ul><li><strong class="source-inline">DNS</strong>: Makes use of available DNS to resolve <span class="No-Break">the hostname</span></li><li><strong class="source-inline">DNS_ROUND_ROBBIN</strong>: In this case, the first resolved address <span class="No-Break">is used</span></li><li><strong class="source-inline">NONE</strong>: No DNS resolution is required; the destination is specified in form of an <span class="No-Break">IP address</span></li><li><strong class="source-inline">STATIC</strong>: Uses a static endpoint against <span class="No-Break">the hostnames</span></li></ul></li>
				<li><strong class="source-inline">location</strong>: The service entry location is used to specify whether the requested service is part of the mesh or outside the mesh. Possible values are <strong class="source-inline">MESH_EXTERNAL</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">MESH_INTERNAL</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">hosts</strong>: This is the hostname associated with the service being requested; in this example, the host is <strong class="source-inline">httpbin.org</strong>. The host field in <strong class="source-inline">ServiceEntry</strong> is matched with host fields specified in virtual service and <span class="No-Break">destination rules.</span></li>
			</ul>
			<p>Go ahead and apply <span class="No-Break">the changes:</span></p>
			<pre class="console">
$ kubectl apply -f Chapter4/5a-istio-gateway.yaml</pre>
			<p>When executing <strong class="source-inline">curl</strong> to <strong class="source-inline">/get</strong>, you will receive a response from <strong class="source-inline">httpbin.org</strong>, whereas <strong class="source-inline">/ping</strong> should route to the <span class="No-Break"><strong class="source-inline">envoydummy</strong></span><span class="No-Break"> service.</span></p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B17989_04_11.jpg" alt="Figure 4.11 – Kiali dashboard showing connection to an external system via ServiceEntry"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – Kiali dashboard showing connection to an external system via ServiceEntry</p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">Please clean up <strong class="source-inline">Chapter4/5a-istio-gateway.yaml</strong> to avoid conflict in <span class="No-Break">upcoming exercises.</span></p>
			<p><strong class="source-inline">ServiceEntry</strong> provides <a id="_idIndexMarker410"/>various options to register external services to the Istio registry so that traffic within the mesh can be correctly routed to workloads outside <span class="No-Break">the mesh.</span></p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor079"/>Exposing Ingress over HTTPS</h1>
			<p>In this section, we <a id="_idIndexMarker411"/>will learn how to configure the Istio Gateway to <a id="_idIndexMarker412"/>expose the Sockshop frontend application <span class="No-Break">over HTTPs.</span></p>
			<p><em class="italic">Steps 1</em> and <em class="italic">3</em> are optional if you already<a id="_idIndexMarker413"/> have a <strong class="bold">Certificate Authority</strong> (<strong class="bold">CA</strong>); usually, for production systems, these steps will be performed by your <span class="No-Break">organization’s CA:</span></p>
			<ol>
				<li>Create a CA. Here, we are creating a CA with <strong class="source-inline">CN</strong> (<strong class="bold">Common Name</strong>) <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">sockshop.inc</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">$openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj '/O=Sockshop Inc./CN=Sockshop.inc' -keyout Sockshop.inc.key -out Sockshop.inc.crt</strong></pre></li>
				<li>Generate a <strong class="bold">Certificate Signing Request</strong> (<strong class="bold">CSR</strong>) for the sockshop. Here, we are generating a <a id="_idIndexMarker414"/>CSR for <strong class="source-inline">sockshop.com</strong>, which also generates a <span class="No-Break">private key:</span><pre class="source-code">
<strong class="bold">$openssl req -out sockshop.com.csr -newkey rsa:2048 -nodes -keyout sockshop.com.key -subj "/CN=sockshop.com/O=sockshop.inc"</strong></pre></li>
				<li>Sign the CSR using the CA with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$openssl x509 -req -sha256 -days 365 -CA Sockshop.inc.crt -CAkey Sockshop.inc.key -set_serial 0 -in sockshop.com.csr -out sockshop.com.crt</strong></pre></li>
				<li>Load the<a id="_idIndexMarker415"/> certificate <a id="_idIndexMarker416"/>and private key as a <span class="No-Break">Kubernetes Secret:</span><pre class="source-code">
<strong class="bold">$kubectl create -n istio-system secret tls sockshop-credential --key=sockshop.com.key --cert=sockshop.com.crt</strong></pre></li>
				<li>Create a gateway and virtual service using the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">kubectl apply -f Chapter4/6-istio-gateway.yaml</strong></pre></li>
			</ol>
			<p>This way, we have created a certificate and loaded that along with its private key as a <span class="No-Break">Kubernetes Secret.</span></p>
			<p>Finally, we are configuring Istio Gateway to use the Secret as a credential for TLS communications. In the <strong class="source-inline">Chapter4/6-istio-gateway.yaml</strong> file gateway, we are configuring <strong class="source-inline">IstioGateway</strong> as the Ingress, and listening on port <strong class="source-inline">443</strong> on the <strong class="source-inline">HTTPS</strong> <span class="No-Break">server protocol:</span></p>
			<pre class="source-code">
  servers:
  - port:
      number: 443
      name: https
      protocol: HTTPS
    tls:
      mode: SIMPLE
      credentialName: sockshop-credential
    hosts:
    - "sockshop.com"</pre>
			<p>In the gateway configuration, we have changed the protocol version to <strong class="source-inline">HTTPS</strong> from <strong class="source-inline">HTTP</strong>, and we added the <a id="_idIndexMarker417"/>following<a id="_idIndexMarker418"/> configurations <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">servers</strong></span><span class="No-Break">&gt;</span><span class="No-Break"><strong class="source-inline">tls</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">Mode</strong>: Indicates whether this port should be secured using TLS. Possible values for this field are <span class="No-Break">as follows:</span><ul><li><strong class="source-inline">SIMPLE</strong>: This is the standard TLS setting that we have selected to <span class="No-Break">expose Sockshop.</span></li><li><strong class="source-inline">MUTUAL</strong>: This is for mutual TLS between the gateway and any system calling <span class="No-Break">the gateway.</span></li><li><strong class="source-inline">PASSTHROUGH</strong>: This is used when a connection needs to be routed to a virtual service with the host value<a id="_idIndexMarker419"/> as the <strong class="bold">Server Name Indication</strong> (<strong class="bold">SNI</strong>) presented during <span class="No-Break">the call.</span></li></ul></li>
			</ul>
			<p class="callout-heading">SNI</p>
			<p class="callout">SNI is an extension of the TLS protocol, where the hostname or domain name of the destination service is shared at the TLS handshake process rather than Layer 7. SNI is useful where a server is hosting multiple domain names, with each represented by its own HTTPS certificate. By knowing the requested hostname at the Layer 5 handshake, the server is able to present the correct certificate as per the presented SNI during <span class="No-Break">the handshake.</span></p>
			<ul>
				<li><strong class="source-inline">AUTO_PASSTHROUGH</strong>: This is the same as <strong class="source-inline">PASSTHROUGH</strong>, except that there is no need for virtual services. The connection is forwarded to upstream services as per the details in <span class="No-Break">the SNI.</span></li>
				<li><strong class="source-inline">ISTIO_MUTUAL</strong>: This is the same as <strong class="source-inline">MUTUAL</strong>, except that the certificate used for mutual TLS is generated automatically <span class="No-Break">by Istio.</span></li>
			</ul>
			<ul>
				<li><strong class="source-inline">Credential name</strong>: This is the Secret that holds the private key and certificate to be used for the server-side connection during TLS. We created the Secret in <span class="No-Break"><em class="italic">step 4</em></span><span class="No-Break">.</span></li>
			</ul>
			<p>Go ahead and access <strong class="source-inline">sockshop.com</strong>; you will have to use <strong class="source-inline">--connect-to</strong> in <strong class="source-inline">curl</strong> to get around the name <a id="_idIndexMarker420"/>resolution issue caused by the difference in the<a id="_idIndexMarker421"/> replacement name and the actual name of <span class="No-Break">the host:</span></p>
			<pre class="console">
$ curl -v -HHost:sockshop.com --connect-to "sockshop.com:443:a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com" --cacert Sockshop.inc.crt  https://sockshop.com:443/</pre>
			<p>Please note, <strong class="source-inline">a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com</strong> is the <strong class="bold">fully qualified domain name</strong> (<strong class="bold">FQDN</strong>) of the load balancer provided by AWS. If <a id="_idIndexMarker422"/>you are using minikube, you can run the command against localhost by using <strong class="source-inline">--resolve</strong> in <strong class="source-inline">curl</strong>, similar to <span class="No-Break">the following:</span></p>
			<pre class="console">
$ curl -v -HHost:sockshop.com --resolve "sockshop.com:56407:127.0.0.1" http://sockshop.com:56407/</pre>
			<p>In the preceding command, <strong class="source-inline">56407</strong> is the local port on which the Ingress gateway <span class="No-Break">is listening.</span></p>
			<p>During the connection, you will notice in the output that the gateway correctly presented the <span class="No-Break">server-side certificates:</span></p>
			<pre class="source-code">
* SSL connection using TLSv1.3 / AEAD-CHACHA20-POLY1305-SHA256
* ALPN, server accepted to use h2
* Server certificate:
*  subject: CN=sockshop.com; O=sockshop.inc
*  start date: Aug 12 06:45:27 2022 GMT
*  expire date: Aug 12 06:45:27 2023 GMT
*  common name: sockshop.com (matched)
*  issuer: O=Sockshop Inc.; CN=Sockshop.inc
*  SSL certificate verify ok.</pre>
			<p>One special point to make here is that we exposed <strong class="source-inline">sockshop.com</strong> as an <strong class="source-inline">HTTPS</strong> service without making <a id="_idIndexMarker423"/>any <a id="_idIndexMarker424"/>changes to the frontend services that host <span class="No-Break">the website.</span></p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">Please clean up <strong class="source-inline">Chapter4/6-istio-gateway.yaml</strong> to avoid conflict with <span class="No-Break">upcoming exercises.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Enabling HTTP redirection to HTTPS</h2>
			<p>For downstream<a id="_idIndexMarker425"/> systems that are still sending requests to <a id="_idIndexMarker426"/>non-HTTPS ports, we can implement HTTP redirection by making the following changes in gateway configuration for <span class="No-Break">non-HTTPS ports:</span></p>
			<pre class="source-code">
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - "sockshop.com"
    tls:
      httpsRedirect: true</pre>
			<p>We have simply added <strong class="source-inline">httpsRedirect: true</strong>, which makes the gateway send a <strong class="source-inline">301</strong> redirect for all non-HTTPS connections. Apply the changes and test <span class="No-Break">the connection:</span></p>
			<pre class="console">
$ kubectl apply -f Chapter4/7-istio-gateway.yaml
$ curl -v -HHost:sockshop.com --connect-to "sockshop.com:80:a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com" --cacert Sockshop.inc.crt  http://sockshop.com:80/</pre>
			<p>In the output, you <a id="_idIndexMarker427"/>will<a id="_idIndexMarker428"/> notice the redirection <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">sockshop.com</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
* Mark bundle as not supporting multiuse
&lt; HTTP/1.1 301 Moved Permanently
&lt; location: https://sockshop.com/</pre>
			<p class="callout-heading">Reminder</p>
			<p class="callout">As usual, please clean up <strong class="source-inline">Chapter4/7-istio-gateway.yaml</strong> to avoid conflict with the next <span class="No-Break">section exercises.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Enabling HTTPS for multiple hosts</h2>
			<p>In the previous <a id="_idIndexMarker429"/>section, we defined the settings for <strong class="source-inline">sockshop.com</strong> on the gateway. We can also apply similar settings for multiple hosts on the gateway. In this section, we will enable TLS on the gateway for <strong class="source-inline">mockshop.com</strong> along <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">sockshop.com</strong></span><span class="No-Break">:</span></p>
			<ol>
				<li>We will make use of the CA we created in the previous section. So, as the next steps, let’s generate a CSR <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">mockshop.com</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">$openssl req -out mockshop.com.csr -newkey rsa:2048 -nodes -keyout mockshop.com.key -subj "/CN=mockshop.com/O=mockshop.inc"</strong></pre></li>
				<li>Sign the CSR using <span class="No-Break">the CA:</span><pre class="source-code">
<strong class="bold">$openssl x509 -req -sha256 -days 365 -CA Sockshop.inc.crt -CAkey Sockshop.inc.key -set_serial 0 -in mockshop.com.csr -out mockshop.com.crt</strong></pre></li>
				<li>Load the certificate and private key as a <span class="No-Break">Kubernetes Secret:</span><pre class="source-code">
<strong class="bold">$kubectl create -n istio-system secret tls mockshop-credential --key=mockshop.com.key --cert=mockshop.com.crt</strong></pre></li>
				<li>Add the following configuration for <strong class="source-inline">mockshop.com</strong> under server configuration in <span class="No-Break">the gateway:</span><pre class="source-code">
- port:
      number: 443
      name: https-mockshop
      protocol: HTTPS
    tls:
      mode: SIMPLE
      credentialName: mockshop-credential
    hosts:
    - "mockshop.com"</pre></li>
				<li>Apply <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker430"/></span><span class="No-Break">changes:</span><pre class="source-code">
<strong class="bold">kubectl apply -f Chapter4/8-istio-gateway.yaml</strong></pre></li>
			</ol>
			<p>After the changes, the gateway will resolve the correct certificates based on <span class="No-Break">the hostname.</span></p>
			<ol>
				<li value="6">Let’s now <span class="No-Break">access </span><span class="No-Break"><strong class="source-inline">sockshop.com</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">curl -v --head -HHost:sockshop.com --resolve "sockshop.com:56408:127.0.0.1" --cacert Sockshop.inc.crt https://sockshop.com:56408/</strong></pre></li>
			</ol>
			<p>In the response, you can see that the correct certificates have <span class="No-Break">been presented:</span></p>
			<pre class="source-code">
* SSL connection using TLSv1.3 / AEAD-CHACHA20-POLY1305-SHA256
* ALPN, server accepted to use h2
* Server certificate:
*  subject: CN=sockshop.com; O=sockshop.inc
*  start date: Aug 12 06:45:27 2022 GMT
*  expire date: Aug 12 06:45:27 2023 GMT
*  common name: sockshop.com (matched)
*  issuer: O=Sockshop Inc.; CN=Sockshop.inc
*  SSL certificate verify ok.
* Using HTTP2, server supports multiplexing</pre>
			<ol>
				<li value="7">Similarly, <span class="No-Break">test </span><span class="No-Break"><strong class="source-inline">mockshop.com</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">curl -v -HHost:mockshop.com --connect-to "mockshop.com:443:a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com" --cacert Sockshop.inc.crt  https://mockshop.com/</strong></pre></li>
				<li>Then, check whether<a id="_idIndexMarker431"/> the certificate presented by the gateway belongs <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">mockshop.com</strong></span><span class="No-Break">:</span><pre class="source-code">
SSL connection using TLSv1.3 / AEAD-CHACHA20-POLY1305-SHA256
* ALPN, server accepted to use h2
* Server certificate:
*  subject: CN=mockshop.com; O=mockshop.inc
*  start date: Aug 12 23:47:27 2022 GMT
*  expire date: Aug 12 23:47:27 2023 GMT
*  common name: mockshop.com (matched)
*  issuer: O=Sockshop Inc.; CN=Sockshop.inc
*  SSL certificate verify ok.
* Using HTTP2, server supports multiplexing</pre></li>
			</ol>
			<p>In this way, we have configured the Istio Ingress gateway to serve multiple TLS certificates depending on <a id="_idIndexMarker432"/>hostnames; this is also called SNI. The Istio Ingress gateway can resolve SNI at the TLS Layer 4 level, allowing it to serve multiple domain names <span class="No-Break">over TLS.</span></p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Enabling HTTPS for CNAME and wildcard records</h2>
			<p>The last topic <a id="_idIndexMarker433"/>on HTTPS is how to manage certificates for CNAME and<a id="_idIndexMarker434"/> wildcard records. Especially for traffic exposed <a id="_idIndexMarker435"/>internally, it <a id="_idIndexMarker436"/>is important to support wildcard. In this section, we will configure the gateway to support wildcard using SNI support. We will be using the CA we created in <span class="No-Break">previous sections:</span></p>
			<ol>
				<li>Create a CSR for <strong class="source-inline">*.sockshop.com</strong> and sign it using the CA certificates, then create the <span class="No-Break">Kubernetes Secret:</span><pre class="source-code">
<strong class="bold">$openssl req -out sni.sockshop.com.csr -newkey rsa:2048 -nodes -keyout sni.sockshop.com.key -subj "/CN=*.sockshop.com/O=sockshop.inc"</strong>
<strong class="bold">$openssl x509 -req -sha256 -days 365 -CA Sockshop.inc.crt -CAkey Sockshop.inc.key -set_serial 0 -in sni.sockshop.com.csr -out sni.sockshop.com.crt</strong>
<strong class="bold">$kubectl create -n istio-system secret tls sni-sockshop-credential --key=sni.sockshop.com.key --cert=sni.sockshop.com.crt</strong></pre></li>
				<li>Then, add the <strong class="source-inline">*.sockshop.com</strong> hostname to the server configuration in <span class="No-Break">the gateway:</span><pre class="source-code">
servers:
  - port:
      number: 443
      name: https-sockshop
      protocol: HTTPS
    tls:
      mode: SIMPLE
      credentialName: sni-sockshop-credential
    hosts:
    - "*.sockshop.com"</pre></li>
				<li>Also, modify the virtual service <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">*.sockshop.com</strong></span><span class="No-Break">:</span><pre class="source-code">
kind: VirtualService
metadata:
  name: sockshop
  namespace: chapter4
spec:
  hosts:
  - "*.sockshop.com"
  - "sockshop.com"</pre></li>
				<li>Apply<a id="_idIndexMarker437"/> <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker438"/></span><span class="No-Break"> configuration:</span><pre class="source-code">
<strong class="bold">$ kubectl apply -f Chapter4/9-istio-gateway.yaml</strong></pre></li>
				<li>You<a id="_idIndexMarker439"/> can <a id="_idIndexMarker440"/>test <strong class="source-inline">mockshop.com</strong>, <strong class="source-inline">sockshop.com</strong>, or any other CNAME records for <strong class="source-inline">sockshop.com</strong>. The following example is <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">my.sockshop.com</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">$ curl -v -HHost:my.sockshop.com --connect-to "my.sockshop.com:443:a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com" --cacert Sockshop.inc.crt  https://my.sockshop.com/</strong></pre></li>
			</ol>
			<p>The following is the snippet from the output of <em class="italic">step 5</em> showing that the correct certificate was presented during <span class="No-Break">the handshake:</span></p>
			<pre class="source-code">
* SSL connection using TLSv1.3 / AEAD-CHACHA20-POLY1305-SHA256
* ALPN, server accepted to use h2
* Server certificate:
*  subject: CN=*.sockshop.com; O=sockshop.inc
*  start date: Aug 13 00:27:00 2022 GMT
*  expire date: Aug 13 00:27:00 2023 GMT
*  common name: *.sockshop.com (matched)
*  issuer: O=Sockshop Inc.; CN=Sockshop.inc
*  SSL certificate verify ok.
* Using HTTP2, server supports multiplexing</pre>
			<p>As you can see, Istio presented the correct wildcard certificate for CNAME. This example demonstrates how Istio gateways can be configured to handle multiple domains <span class="No-Break">and subdomains.</span></p>
			<p>In this and prior sections, we read about the various ways Ingress and the routing of traffic within and outside of the mesh are managed by Istio. It is important that you go through the concepts of gateways, virtual services, destination rules, and service entries and play with the example provided in this chapter, as well as think of other examples and try to implement them. In <span class="No-Break"><em class="italic">Chapter 6</em></span>, we will discuss security in more depth and will cover topics such as mTLS, and<a id="_idIndexMarker441"/> so on. But <a id="_idIndexMarker442"/>for <a id="_idIndexMarker443"/>now, we will read about how Istio <a id="_idIndexMarker444"/>manages <span class="No-Break">Egress traffic.</span></p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">Don’t forget to clean up <strong class="source-inline">Chapter4/8-istio-gateway.yaml</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Chapter4/9-istio-gateway.yaml</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Managing Egress traffic using Istio</h1>
			<p>In the <em class="italic">Routing traffic to services outside of the cluster</em> section, we discovered how service entries<a id="_idIndexMarker445"/> can <a id="_idIndexMarker446"/>be used to update the Istio service registry about services external to the mesh and the cluster. Service entries are a way to add additional entries into Istio’s internal service registry for virtual services to be able to route to those entries. An Egress gateway, however, is used for controlling how the traffic for external service leaves <span class="No-Break">the mesh.</span></p>
			<p>To get familiar with Egress gateways, we will first deploy a Pod within the mesh from which we can call an <span class="No-Break">external service:</span></p>
			<pre class="console">
$ kubectl apply -f utilities/curl.yaml</pre>
			<p>The command creates a Pod from which you can perform <strong class="source-inline">curl</strong>; this mimics a workload running inside <span class="No-Break">the mesh:</span></p>
			<pre class="console">
$ kubectl exec -it curl sh -n chapter4</pre>
			<p>From the shell, access <strong class="source-inline">httpbin.org</strong> <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">curl</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$ curl -v https://httpbin.org/get</pre>
			<p>Now, we will stop all Egress traffic from the mesh using the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ istioctl install -y --set profile=demo --set meshConfig.outboundTrafficPolicy.mode=REGISTRY_ONLY</pre>
			<p>In the previous command, we are modifying the Istio installation to change the outbound traffic policy from <strong class="source-inline">ALLOW_ANY</strong> to <strong class="source-inline">REGISTRY_ONLY</strong>, which enforces that only hosts defined with <strong class="source-inline">ServiceEntry</strong> resources are part of the mesh <span class="No-Break">service registry.</span></p>
			<p>Go back and <a id="_idIndexMarker447"/>try <strong class="source-inline">curl</strong> again; you<a id="_idIndexMarker448"/> will see the <span class="No-Break">following output:</span></p>
			<pre class="console">
$ curl -v https://httpbin.org/get
curl: (35) OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to httpbin.org:443</pre>
			<p>Let’s now list <strong class="source-inline">httpbin.org</strong> in the Istio service registry by creating a service entry <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: httpbin-svc
  namespace: chapter4
spec:
  hosts:
  - httpbin.org
  location: MESH_EXTERNAL
  resolution: DNS
  ports:
  - number: 443
    name: https
    protocol: HTTPS
  - number: 80
    name: http
    protocol: HTTP</pre>
			<p>Now, you may go ahead and apply <span class="No-Break">the configuration:</span></p>
			<pre class="console">
$ kubectl apply -f Chapter4/10-a-istio-egress-gateway.yaml</pre>
			<p>Access <strong class="source-inline">https://httpbin.org/get</strong> from the <strong class="source-inline">curl</strong> Pod; this time, you <span class="No-Break">will succeed.</span></p>
			<p><strong class="source-inline">ServiceEntry</strong> added <strong class="source-inline">httpbin.org</strong> to the mesh service registry, and hence we were able to access <strong class="source-inline">httpbin.org</strong> from the <span class="No-Break"><strong class="source-inline">curl</strong></span><span class="No-Break"> Pod.</span></p>
			<p>Though <strong class="source-inline">ServiceEntry</strong> is great for providing external access, it does not provide any control over how the external endpoints should be accessed. For example, you may want only certain workloads or namespaces to be able to send traffic to an external resource. What if there is a need<a id="_idIndexMarker449"/> to <a id="_idIndexMarker450"/>verify the authenticity of an external resource by verifying <span class="No-Break">its certificates?</span></p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">Don’t forget to clean <span class="No-Break">up </span><span class="No-Break"><strong class="source-inline">Chapter4/10-a-istio-egress-gateway.yaml</strong></span><span class="No-Break">.</span></p>
			<p>The Egress gateway, along with a combination of virtual services, destination rules, and service entries, provides flexible options to manage and control traffic egressing out of the mesh. So, let’s make configuration changes to route all traffic for <strong class="source-inline">httpbin.org</strong> to the <span class="No-Break">Egress gateway:</span></p>
			<ol>
				<li>Configure the Egress gateway, which is very similar to the Ingress gateway configuration. Please note the Egress gateway is attached to <strong class="source-inline">httpbin.org</strong>; you can provide other hosts or <strong class="source-inline">*</strong> to match <span class="No-Break">all hostnames:</span><pre class="source-code">
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: istio-egressgateway
  namespace: chapter4
spec:
  selector:
    istio: egressgateway
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - httpbin.org</pre></li>
				<li>Next, configure the <a id="_idIndexMarker451"/>virtual<a id="_idIndexMarker452"/> service. Here, we are configuring the virtual service to attach to the Egress gateway as well as to <span class="No-Break">the mesh:</span><pre class="source-code">
spec:
  hosts:
  - httpbin.org
  gateways:
  - <strong class="source-inline">istio-egressgateway</strong>
  - <strong class="source-inline">mesh</strong></pre></li>
			</ol>
			<p>In the following part of the virtual service definition, we are configuring that all traffic originating from within the mesh for the <strong class="source-inline">httpbin.org</strong> host will be directed to the <span class="No-Break">Egress gateway:</span></p>
			<pre class="source-code">
http:
  - match:
    - gateways:
      - mesh
      port: 80
    route:
    - destination:
        host: istio-egressgateway.istio-system.svc.cluster.local
        subset: httpbin
        port:
          number: 80
      weight: 100</pre>
			<p>We have configured <strong class="source-inline">subset: httpbin</strong> to apply destination rules; in this example, the <a id="_idIndexMarker453"/>destination <a id="_idIndexMarker454"/>rules <span class="No-Break">are empty.</span></p>
			<p>Finally, we will add another rule to route traffic from the Egress gateway <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">httpbin.org</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
  - match:
    - gateways:
      - istio-egressgateway
      port: 80
    route:
    - destination:
        host: httpbin.org
        port:
          number: 80
      weight: 100</pre>
			<ol>
				<li value="3">Create a placeholder for any destination rules you might want <span class="No-Break">to implement:</span><pre class="source-code">
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: rules-for-httpbin-egress
  namespace: chapter4
spec:
  host: istio-egressgateway.istio-system.svc.cluster.local
  subsets:
  - name: httpbin</pre></li>
				<li>You also need to add <strong class="source-inline">ServiceEntry</strong> for <strong class="source-inline">httpbin.org</strong>, which we discussed in the <a id="_idIndexMarker455"/><span class="No-Break">previous </span><span class="No-Break"><a id="_idIndexMarker456"/></span><span class="No-Break">section.</span></li>
				<li>Go ahead and apply <span class="No-Break">the changes:</span><pre class="source-code">
<strong class="bold">kubectl apply -f Chapter4/10-b-istio-egress-gateway.yaml</strong></pre></li>
				<li>Try accessing <strong class="source-inline">httpbin.org</strong> from the <strong class="source-inline">curl</strong> Pod; you will be able to access <span class="No-Break">it now.</span></li>
			</ol>
			<p>Examine the headers in the response, as well as the logs of <strong class="source-inline">istio-egressgateway pods</strong>. You will find information about the Egress gateway under <strong class="source-inline">X-Envoy-Peer-Metadata-Id</strong>. You can also see the request in the Egress <span class="No-Break">gateway logs.</span></p>
			<p>You will notice that you are not able to access <strong class="source-inline">https://httpbin.org/get</strong>, although we have defined <strong class="source-inline">https</strong> in the service entry. Try enabling <strong class="source-inline">https</strong> access to <strong class="source-inline">httpbin.org</strong>; you will find the solution <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Chapter4/10-c-istio-egress-gateway.yaml</strong></span><span class="No-Break">.</span></p>
			<p>Egress is important to control traffic leaving the mesh. In <span class="No-Break"><em class="italic">Chapter 6</em></span>, we will focus on some of the other security aspects <span class="No-Break">of Egress.</span></p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">Delete <strong class="source-inline">chapter4/10-b-istio-egress-gateway.yaml</strong> along with <span class="No-Break"><strong class="source-inline">chapter4</strong></span><span class="No-Break"> namespace.</span></p>
			<p class="callout">Revert the authorization policy to allow all outgoing traffic from the mesh without needing an Egress gateway using the <span class="No-Break">following command:</span></p>
			<p class="callout"><strong class="source-inline">$ istioctl install -y --set profile=demo --</strong><span class="No-Break"><strong class="source-inline">set meshConfig.outboundTrafficPolicy.mode=ALLOW_ANY</strong></span></p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>Summary</h1>
			<p>In this chapter, we read about how to manage external traffic coming inside the Service Mesh using the Istio Ingress gateway, as well as how to manage internal traffic leaving the mesh via Istio <span class="No-Break">Egress gateways.</span></p>
			<p>We learned about virtual services and destination rules: how virtual services are used to describe the rules to route traffic to various destinations in the mesh, how destination rules are used to define the end destination, and how the destination processes the traffic routed via rules defined by virtual services. Using virtual services, we can perform weight-based traffic routing, which is also used for canary releases and <span class="No-Break">blue-green deployment.</span></p>
			<p>Additionally, we learned about <strong class="source-inline">ServiceEntry</strong> and how it is used to make Istio aware of external services so that workloads in the mesh can send traffic to services outside the mesh. And finally, we learned how Egress gateways are used to control the Egress to endpoints defined by <strong class="source-inline">ServiceEntry</strong> so that we can access external services securely and reliably from the mesh. This chapter sets you up for the next chapter, where we will discuss how to implement application resiliency using the concepts from <span class="No-Break">this chapter.</span></p>
		</div>
		<div>
			<div id="_idContainer054" class="IMG---Figure">
			</div>
		</div>
	</body></html>