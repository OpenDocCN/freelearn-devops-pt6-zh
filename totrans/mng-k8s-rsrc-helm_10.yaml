- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automating Helm with CD and GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we have demonstrated how to use different Helm commands
    to manage Kubernetes resources and applications. While these commands (namely
    `install`, `upgrade`, `rollback`, and `uninstall`) are effective in carrying out
    their respective tasks, we have been invoking them manually from the command line.
    Manual invocation can serve as a pain point when managing multiple different applications
    and can make it difficult for enterprises to scale. As a result, we should explore
    opportunities to automate our Helm deployments.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will investigate concepts relating to **continuous delivery**
    (**CD**) and **GitOps**. These are methodologies that involve automatically invoking
    the Helm **command-line interface** (**CLI**) to perform automated chart installations
    based on the contents of a Git repository. By implementing the CD and GitOps concepts,
    you can further increase your efficiency with Helm.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CI/CD and GitOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Argo CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a Helm chart from a Git repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a Helm chart from a remote Helm chart repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a Helm chart to multiple environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires that you have the following technologies installed on
    your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kubectl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these tools, you can find the Packt repository that contains
    the resources associated with the examples in this chapter on GitHub at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm).
    This repository will be referenced throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CI/CD and GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have addressed manually invoking the Helm CLI to install and manage
    Helm charts. While this is acceptable when getting started with Helm, as you look
    to manage a chart in a production-like environment, there are questions that you
    need to consider, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How can I be sure that the best practices for Helm chart deployments are enforced?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the implications for collaborators participating in the deployment
    process?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may be familiar with the best practices and processes around deploying Helm
    charts; however, any new collaborators or team members may not have the same level
    of knowledge or expertise. Not to mention, you may become limited in the level
    of support that you can provide to others as your responsibilities among the number
    of applications you manage increases. Through the use of automation and repeatable
    processes, we can address these challenges.
  prefs: []
  type: TYPE_NORMAL
- en: While this chapter will focus primarily on CD and GitOps, we would be remiss
    if we were to avoid introducing **continuous integration** (**CI**), which is
    commonly paired with CD. We will discuss **continuous integration/continuous delivery**
    (**CI/CD**) and GitOps in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As enterprises sought to accelerate the software development life cycle over
    the years, the need for an automated development process arose, leading to the
    creation of CI. CI is enabled by using an orchestrator to automatically build
    and test application code. As new commits are pushed to a Git repository, the
    orchestrator automatically retrieves the source code and undergoes a predetermined
    set of steps to build the application (among other tasks, such as code quality
    scanning, vulnerability scanning, and so on). By performing automatic builds when
    new commits are added, regressions and breaking changes can be spotted early on
    in the software development life cycle. CI also helps address the challenges embodied
    by the phrase *it works on my machine* by providing a common build environment.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to apply many of CI’s concepts throughout the software development
    life cycle as an application moves toward production led to the creation of CD.
    CD is a set of defined steps provided to progress software through a release process.
    CD has gained acceptance and popularity among many organizations where proper
    change control is enforced, and approvals are required for the software to progress
    to the next stage. As many of the concepts around CI/CD are automated in a repeatable
    fashion, teams can look to fully eliminate the need for manual approval steps
    once they are confident that they have a reliable framework in place.
  prefs: []
  type: TYPE_NORMAL
- en: The process of implementing a fully automated build, test, deployment, and release
    process without human intervention is known as continuous deployment. While many
    software projects may never fully achieve continuous deployment, teams that can
    implement the concepts emphasized by CI/CD can produce real business value faster
    than less automated methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will introduce GitOps as a mechanism to improve how
    applications and their configuration are managed.
  prefs: []
  type: TYPE_NORMAL
- en: Taking CI/CD to the next level using GitOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes is a platform that embraces the use of declarative configurations.
    While applications can be managed using imperative `kubectl` commands, the preferred
    approach, which we covered in [*Chapter 1*](B17979_01.xhtml#_idTextAnchor015),
    *Understanding Kubernetes and Helm*, is to declaratively state the resources through
    the use of manifests. In the same way that an application traverses its way through
    a CI/CD pipeline, Kubernetes manifests can implement many of the same CI/CD patterns.
    Like application code, Kubernetes manifests should also be stored in a source
    code repository, such as Git, and can undergo the same type of build, test, and
    deployment practices.
  prefs: []
  type: TYPE_NORMAL
- en: The rise in popularity of managing the life cycle of Kubernetes applications
    and cluster configuration within Git repositories led to the concept of GitOps.
    First introduced by the software company *WeaveWorks* in 2017, GitOps has increased
    in popularity as a way to manage Kubernetes configurations. While GitOps is best
    known in the context of Kubernetes, its principles can be applied to any type
    of environment.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to CI/CD, tools have been developed to manage the GitOps process. These
    include **Argo CD** from Intuit and **Flux** from WeaveWorks. However, you do
    not need to use a tool specifically designed for GitOps as any automation utility
    or CI/CD orchestrator can be used. The key differentiator between a traditional
    CI/CD tool and a tool designed for GitOps is a GitOps tool’s ability to constantly
    observe the state of the target environment and apply desired configurations when
    the live state does not match the desired state, as defined in the manifests stored
    in Git. In the context of Kubernetes, these tools make use of the controller pattern,
    which is fundamental to Kubernetes itself.
  prefs: []
  type: TYPE_NORMAL
- en: Since Helm charts are ultimately rendered as Kubernetes resources, they, too,
    can be used to participate in the GitOps process. In this chapter, we will leverage
    Argo CD to deploy Helm chart resources to Kubernetes in a GitOps fashion. Note
    that this is not intended to be a comprehensive overview of Argo CD, but it will
    give you an idea of how it can be integrated with Helm to provide a GitOps approach
    toward Helm deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create several namespaces to install Argo CD and deploy
    an example Helm chart across different namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands to prepare your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start `minikube` by running the `minikube start` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a new namespace called `argo`, where we will later install Argo
    CD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a namespace called `chapter10`, where we will deploy an example
    Helm chart from Argo CD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create two namespaces called `chapter10-dev` and `chapter10-prod`.
    We will use these namespaces to demonstrate deploying a Helm chart across multiple
    environments using Argo CD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With your `minikube` environment ready and your namespaces created, let’s begin
    by deploying Argo CD. Then, we will walk through examples of using Argo CD to
    deploy an application to Kubernetes with Helm.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Argo CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Argo CD can be installed in Kubernetes by using a set of manifest files or by
    installing a Helm chart. Of course, we will choose to install Argo CD using the
    community-provided Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: The repository URL for the Argo CD Helm chart is [https://argoproj.github.io/argo-helm](https://argoproj.github.io/argo-helm)
    (which can be found in Artifact Hub, a process described in [*Chapter 3*](B17979_03.xhtml#_idTextAnchor083),
    *Installing Your First App with Helm*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add this repository using the Helm CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once the repository has been added, you can install it. We have provided a `values`
    file you can use for the installation in the Packt repository at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/argo-values/values.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/argo-values/values.yaml).
    The provided `values` file disables Dex (an OpenID Connect provider), along with
    Argo’s notification system, since we will not be using these components in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s install Argo CD in the `argo` namespace by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The Helm chart installs the following components in the `argo` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Application` custom resources. When an `Application` resource is created,
    Argo CD creates resources to the desired destination cluster and namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ApplicationSet` custom resources. `ApplicationSet` provides a convenient way
    to deploy multiple different yet related `Application` resources. We will work
    with ApplicationSets when we demonstrate how to deploy a Helm chart to multiple
    different environments or namespaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redis**, which is used for caching backend data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Argo CD Repo Server**, which provides a local instance of cloned Git repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Argo CD Server**, which provides an API for interacting with Argo CD. This
    component also provides a frontend web interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once each of the pods in the `argo` namespace reports the 1/1 ready state (shown
    by running `kubectl get pods –n argo`), we can access the Argo CD web UI. First,
    we need to get the admin password that was randomly generated during the Helm
    installation. We can do this by accessing a Kubernetes `secret` in the `argo`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The username for accessing the web UI will be `admin`, and the password will
    be the string displayed after getting the password from `the argocd-initial-admin-secret`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can run `port-forward` to access the web UI. In a separate terminal,
    run the following `port-forward` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the `port-forward` command, navigate to [https://localhost:8443](https://localhost:8443)
    in a web browser. Accept the self-signed certificate exception; you will be presented
    with the Argo CD login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – The Argo CD login page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.01_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – The Argo CD login page
  prefs: []
  type: TYPE_NORMAL
- en: 'For the username, enter `admin`, and for the password, provide the string that
    was displayed after getting the password from `argocd-initial-admin-secret`. After
    successfully logging in, you should see the following page titled **APPLICATIONS
    TILES**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The Argo CD APPLICATIONS TILES page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.02_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – The Argo CD APPLICATIONS TILES page
  prefs: []
  type: TYPE_NORMAL
- en: This page can be used to create new applications, which represent application
    deployments (or any set of Kubernetes resources). However, in the spirit of adhering
    to a more declarative configuration approach, we will make deployments in this
    chapter by applying `Application` YAML resources instead. With that said, this
    UI will populate with application tiles as we apply the `Application` resources
    directly using `kubectl`. Feel free to reference this UI throughout this chapter
    to see how they are visualized.
  prefs: []
  type: TYPE_NORMAL
- en: With Argo CD successfully deployed, let’s continue by deploying a Helm chart
    from a Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Helm chart from a Git repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In true GitOps fashion, Argo CD can be used to deploy a Helm chart from a Git
    repository. The following diagram shows the flow involved in deploying a Helm
    chart from a Git repository using Argo CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Deploying a Helm chart from a Git repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.03_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Deploying a Helm chart from a Git repository
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that Argo CD clones the Git repository containing the desired
    Helm chart. Then, Argo CD interprets the repository as one containing a Helm chart,
    since it notices the presence of the `Chart.yaml` file and surrounding Helm chart
    structure. From there, Argo CD proceeds by rendering the Helm chart manifests
    and applying them to the designated Kubernetes namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Argo CD *renders* the Helm chart templates and applies them as opposed
    to installing the Helm chart directly. This is because Argo CD only applies Kubernetes
    manifests, so it first runs a helm `template` internally to produce the full Kubernetes
    manifest from the provided Helm values. If you were to run the `helm list` command
    after deploying a chart using Argo CD, you would not see any releases listed.
    You would, however, be able to see the applied resources.
  prefs: []
  type: TYPE_NORMAL
- en: You may be curious about the implications that deploying rendered Kubernetes
    manifests has on application rollbacks since the `helm rollback` command cannot
    be used. With the GitOps ideology, you would ideally roll back by performing changes
    within your Git repository to revert such actions. Argo CD would then detect any
    new commits that have been created against the target branch and apply the desired
    changes. With that said, Argo CD does have a native rollback capability to roll
    back to a previous history ID. This enables users to roll back without reverting
    to their Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin to deploy a Helm chart from Git by observing the `Application`
    resource located in the Packt repository at `chapter10/local-chart/application.yaml`
    ([https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/local-chart/application.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/local-chart/application.yaml)).
    We can break this resource down into separate components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must define the resource’s `kind` and provide the resource metadata:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the finalizer, `resources-finalizer.argocd.argoproj.io`. **Finalizers**,
    in Kubernetes, are used to trigger a pre-delete action on the managing controller.
    With this finalizer, we tell the application controller that if we delete this
    application resource, the controller should delete the rendered Kubernetes resources
    first. If we omit the finalizer, the application controller will simply remove
    the application resource without deleting the rendered Kubernetes resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must define the application source. This is where we specify the Git
    repository URL and the path to the Helm chart:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see from the configuration, Argo CD will clone the repository (https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git)
    at the most recent commit (`HEAD`). Once cloned, it navigates to the `helm-charts/charts/nginx`
    path, which contains an Nginx Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we also specified a set of Helm values, setting the resource limits and
    requests under the `helm.values` section. Values can also be provided by using
    the `helm.parameters` setting, like so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This would be similar to passing the --set flag on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, values can also be provided using the `helm.valueFiles` setting. We
    will describe this use case in greater detail in the *Deploying a Helm chart to
    multiple environments* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final portion of the `Application` resource defines the destination and
    synchronization (sync) policy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`destination` defines the Kubernetes server API of the target cluster and the
    namespace that resources should be deployed to. `syncPolicy` determines how the
    application should be synchronized. In this context, `sync` means to apply, or
    update, the resources in the cluster with those from the application source. Syncs
    can be done manually, but in this example, we have selected to automate it so
    that Nginx is deployed as soon as the application resource is created.'
  prefs: []
  type: TYPE_NORMAL
- en: Under the `syncPolicy.automated` section, several additional configurations
    can be specified. The `prune` field is a Boolean that determines whether Kubernetes
    resources should be deleted if they are removed from the source. The `selfHeal`
    setting instructs Argo CD to ensure consistency between the desired state and
    the live state. If a resource is modified within the Kubernetes cluster, `selfHeal`
    will cause Argo CD to revert the modification so that it matches the source configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand the application resource for defining our Nginx application,
    we can install this `Application` resource by using the `kubectl apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The result creates the `Application` resource in the `argo` namespace, where
    Argo CD has visibility to application resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon creating the application resource, you can see the deployment status by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`SYNC STATUS` shows whether or not the desired state has been synced with the
    live state, while `HEALTH STATUS` shows whether or not the rollout has been completed
    or if the pods are still starting up. It may take a moment for `SYNC STATUS` and
    `HEALTH STATUS` to reach these values as the `nginx` chart and the associated
    resources are installed in the cluster. We can see the status of the deployment
    using more traditional means – that is, by running the `kubectl get pods` command
    in the `chapter10` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With `Application` reporting as synchronized and healthy, you have successfully
    deployed a Helm chart from a Git repository using Argo CD! Let’s delete the application
    resource (which will also remove the `nginx` pod from the `chapter10` namespace):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Before we depart from this topic, it should be noted that, as expected in a
    GitOps model, changes to the `nginx` Helm chart in Git will automatically propagate
    to the Kubernetes environment. If you were to update the `nginx` chart and publish
    a new commit to the Git repository for the particular target branch, Argo CD would
    notice this change in the next polling interval and update the Kubernetes namespace
    with the desired state, as defined in the repository. For faster synchronization,
    webhooks can be configured on the Git repository to trigger an Argo CD sync in
    an event-driven fashion. Information on configuring webhooks is described in the
    Argo CD documentation at [https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/](https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to use Argo CD to deploy a Helm chart from a remote
    chart repository.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application from a remote Helm chart repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When installing Helm charts, users often interact with remote repositories.
    Similarly, we can use Argo CD to deploy an application from a specified Helm chart
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the flow involved in deploying an application from
    a remote Helm chart repository with Argo CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Deploying an application from a remote Helm chart repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.04_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Deploying an application from a remote Helm chart repository
  prefs: []
  type: TYPE_NORMAL
- en: First, Argo CD downloads the Helm chart configured in the `Application` resource.
    Then, it renders the Helm chart and applies the manifests to the destination cluster
    and namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have provided an example `Application` resource in the Packt repository
    at `chapter10/remote-registry/application.yaml` ([https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/remote-registry/application.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/remote-registry/application.yaml)).
    The resource is configured similarly to `Application` from the previous section,
    but we can observe one key difference in the `source` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, instead of providing a Git repository, we provided the location of a remote
    Helm chart repository, as well as the chart’s name and version. As you can see,
    this `Application` will instruct Argo CD to deploy version `9.7.6` of the `nginx`
    chart from the Bitnami chart repository.
  prefs: []
  type: TYPE_NORMAL
- en: The process of deploying a Helm chart from a chart repository is the same as
    deploying from a Git repository – simply apply the `Application` resource to the
    `argo` namespace. Feel free to walk through the same steps provided in the previous
    section to deploy the application to the `chapter10` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Where the process changes slightly is when we talk about deploying a Helm chart
    to multiple environments, a topic that we will cover in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Helm chart to multiple environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous sections, we used Argo CD to deploy a Helm chart to a single
    environment (or namespace). However, when deploying applications in the enterprise,
    you will often expect to deploy across multiple different environments, achieving
    a process similar to what’s shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Deploying to multiple namespaces'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.05_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Deploying to multiple namespaces
  prefs: []
  type: TYPE_NORMAL
- en: You may want to deploy charts to different environments (separate namespaces
    or even separate clusters) for a variety of reasons, including high availability
    or for deploying an application across multiple stages of a pipeline, such as
    dev, test, and prod. Luckily, we can achieve this in Argo CD using the `ApplicationSet`
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we have two separate namespaces – one for dev and another for
    prod. We could create two separate `Application` resources, each targeting a separate
    namespace in the destination section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dev would look as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Prod would be very similar, but we would specify `prod` in the `namespace`
    property:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using two different `Application` resources – one for each environment – is
    a perfectly valid option for approaching this type of deployment. However, Argo
    CD introduced `ApplicationSet` as a method for wrapping multiple `Application`
    instances in a single resource, allowing you to define multiple destinations without
    managing multiple resource YAML files.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of an `ApplicationSet` is provided in the Packt repository at `chapter10/multiple-envs/applicationset.yaml`
    ([https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/multiple-envs/applicationset.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/multiple-envs/applicationset.yaml)).
    Let’s break down the different sections of this resource:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first component of an `ApplicationSet` is the `generators` section, which
    generates parameters that are used later on to dynamically configure the application
    details, such as the source and destination. There are many different types of
    generators, which can be explored in greater detail in the Argo CD documentation
    at [https://argocd-applicationset.readthedocs.io/en/stable/Generators/](https://argocd-applicationset.readthedocs.io/en/stable/Generators/).
    In our example, we used the `list` generator, which allows a list of simple key-value
    pairs to be provided:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, two elements that define our different environments are specified
    – `dev` and `prod`. We will reference these environments throughout the rest of
    `ApplicationSet` to deploy the `nginx` chart to both stages of our deployment
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must define the `Application` template. We start by providing a name
    that `ApplicationSet` will inject into the generated `Applications`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `{{ env }}` syntax denotes a placeholder that will be replaced by the `env`
    elements described in the `generators` section. So, when we create `ApplicationSet`,
    we can expect two different applications to be created: `– nginx-dev` and `nginx-prod`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have specified the names of the applications that will be created,
    we can configure the sources. This will look similar to what we have seen in the
    previous sections:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This source indicates that Argo CD will deploy the Helm chart located under
    `chapter10/multiple-envs/nginx` at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git).
    However, instead of deploying the same configuration in each environment, we will
    apply slightly different values based on the environment. This can be seen under
    the `helm.valueFiles` setting, which provides a list of values files to be applied
    (similar to using the `--values` flag on the command line). Regardless of the
    environment, we will always apply a common set of values defined in the `values/common-values.yaml`
    file, but depending on the environment, we will also apply either the `values/dev/values.yaml`
    file or the `values/prod/values.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: These values files can be seen within the `chapter10/multiple-envs/nginx/values`
    directory ([https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter10/multiple-envs/nginx/values](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter10/multiple-envs/nginx/values)).
    Note that, since Argo CD has been configured to use the `chapter10/multiple-envs/nginx`
    chart path, the values files must be located underneath this path. It is also
    important to note that this method of applying values files is only applicable
    when deploying a Helm chart from Git. When deploying from a remote Helm chart
    repository, values can be provided using the `helm.values` or `helm.parameters`
    method, as described in the *Deploying a Helm chart from a Git repository* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we must define the destinations that Argo CD should deploy the resources
    to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will deploy the Helm chart to the `chapter10-dev` and `chapter10-prod`
    namespaces. In this example, we separated environments by namespace for simplicity,
    but you can also instruct Argo CD to deploy to separate clusters by parameterizing
    the `destination.server` section in a fashion similar to how we have parameterized
    the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how `ApplicationSet` is created, let’s apply it to our Kubernetes
    cluster to deploy our Helm chart across different environments. First, apply `ApplicationSet`
    located at `chapter10/multiple-envs/applicationset.yaml` ([https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/multiple-envs/applicationset.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/multiple-envs/applicationset.yaml)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Shortly, we should see two different applications appear in the `argo` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also observe the deployment running in our different environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can observe three different `nginx` pods in `chapter10-prod` because the
    `values` file under `chapter10/multiple-envs/nginx/values/prod/values.yaml` specifies
    three replicas, while the `dev values` file only specifies one.
  prefs: []
  type: TYPE_NORMAL
- en: If you were able to observe similar output in your minikube environment to those
    shown previously, congratulations! You have successfully deployed a Helm chart
    to multiple environments in a GitOps fashion with Argo CD.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s conclude this chapter by cleaning up the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let’s remove the namespaces from this chapter and the Argo installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can stop the minikube cluster with the `minikube stop` command.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CD and GitOps provide scalable methods for further abstracting the capabilities
    that Helm provides, allowing deployments to be controlled by the contents of a
    Git repository or a remote chart repository. In this chapter, we introduced the
    concepts of CI/CD and GitOps and explored them using Argo CD as a solution to
    implementing these models in the context of Helm. Then, we learned how to install
    Argo CD and how to create the `Application` and `ApplicationSet` resources, which
    are primitives for enabling Argo CD deployments and synchronizing them with specified
    Helm charts and values. Finally, we learned how to deploy a Helm chart across
    multiple different environments.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore another abstraction – the Helm operator.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between CI and CD?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the relationship between CD and GitOps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between an Argo CD `Application` and `ApplicationSet`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Argo CD equivalent of passing the `--values` flag on the command
    line?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Argo CD equivalent of passing the `--set` flag on the command line?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an `ApplicationSet` generator? Why are generators useful when deploying
    to multiple environments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
