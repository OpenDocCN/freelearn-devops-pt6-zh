- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Automating Helm with CD and GitOps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CD 和 GitOps 自动化 Helm
- en: Throughout this book, we have demonstrated how to use different Helm commands
    to manage Kubernetes resources and applications. While these commands (namely
    `install`, `upgrade`, `rollback`, and `uninstall`) are effective in carrying out
    their respective tasks, we have been invoking them manually from the command line.
    Manual invocation can serve as a pain point when managing multiple different applications
    and can make it difficult for enterprises to scale. As a result, we should explore
    opportunities to automate our Helm deployments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们展示了如何使用不同的 Helm 命令来管理 Kubernetes 资源和应用。虽然这些命令（即 `install`、`upgrade`、`rollback`
    和 `uninstall`）在执行各自的任务时非常有效，但我们一直是在命令行中手动调用它们。手动调用在管理多个不同的应用时可能成为痛点，也会使企业难以扩展。因此，我们应该探索自动化
    Helm 部署的机会。
- en: In this chapter, we will investigate concepts relating to **continuous delivery**
    (**CD**) and **GitOps**. These are methodologies that involve automatically invoking
    the Helm **command-line interface** (**CLI**) to perform automated chart installations
    based on the contents of a Git repository. By implementing the CD and GitOps concepts,
    you can further increase your efficiency with Helm.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究与**持续交付**（**CD**）和**GitOps**相关的概念。这些方法论涉及自动调用 Helm **命令行界面**（**CLI**）来基于
    Git 仓库的内容执行自动化图表安装。通过实施 CD 和 GitOps 概念，你可以进一步提高使用 Helm 的效率。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding CI/CD and GitOps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 CI/CD 和 GitOps
- en: Setting up your environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置你的环境
- en: Installing Argo CD
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Argo CD
- en: Deploying a Helm chart from a Git repository
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Git 仓库部署 Helm 图表
- en: Deploying a Helm chart from a remote Helm chart repository
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从远程 Helm 图表仓库部署 Helm 图表
- en: Deploying a Helm chart to multiple environments
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Helm 图表部署到多个环境
- en: Cleaning up
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires that you have the following technologies installed on
    your local machine:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求你在本地计算机上安装以下技术：
- en: minikube
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: minikube
- en: Helm
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm
- en: kubectl
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl
- en: Git
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: In addition to these tools, you can find the Packt repository that contains
    the resources associated with the examples in this chapter on GitHub at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm).
    This repository will be referenced throughout this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些工具外，你还可以在 GitHub 上找到包含本章示例相关资源的 Packt 仓库，地址是 [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm)。在本章中，我们将会引用该仓库。
- en: Understanding CI/CD and GitOps
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 CI/CD 和 GitOps
- en: 'So far, we have addressed manually invoking the Helm CLI to install and manage
    Helm charts. While this is acceptable when getting started with Helm, as you look
    to manage a chart in a production-like environment, there are questions that you
    need to consider, including the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了手动调用 Helm CLI 来安装和管理 Helm 图表。虽然在开始使用 Helm 时这种方式是可以接受的，但当你在类似生产的环境中管理图表时，你需要考虑一些问题，包括以下内容：
- en: How can I be sure that the best practices for Helm chart deployments are enforced?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何确保强制执行 Helm 图表部署的最佳实践？
- en: What are the implications for collaborators participating in the deployment
    process?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与部署过程的协作者会有什么影响？
- en: You may be familiar with the best practices and processes around deploying Helm
    charts; however, any new collaborators or team members may not have the same level
    of knowledge or expertise. Not to mention, you may become limited in the level
    of support that you can provide to others as your responsibilities among the number
    of applications you manage increases. Through the use of automation and repeatable
    processes, we can address these challenges.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经熟悉了部署 Helm 图表的最佳实践和流程；然而，任何新的协作者或团队成员可能没有相同的知识或专业技能。更不用说，随着你管理的应用数量增加，你在为他人提供支持时可能会受到限制。通过使用自动化和可重复的流程，我们可以解决这些挑战。
- en: While this chapter will focus primarily on CD and GitOps, we would be remiss
    if we were to avoid introducing **continuous integration** (**CI**), which is
    commonly paired with CD. We will discuss **continuous integration/continuous delivery**
    (**CI/CD**) and GitOps in the next section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将主要关注 CD 和 GitOps，但如果我们不介绍与 CD 常常搭配的**持续集成**（**CI**），那将是一个遗憾。我们将在下一节讨论**持续集成/持续交付**（**CI/CD**）和
    GitOps。
- en: CI/CD
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI/CD
- en: As enterprises sought to accelerate the software development life cycle over
    the years, the need for an automated development process arose, leading to the
    creation of CI. CI is enabled by using an orchestrator to automatically build
    and test application code. As new commits are pushed to a Git repository, the
    orchestrator automatically retrieves the source code and undergoes a predetermined
    set of steps to build the application (among other tasks, such as code quality
    scanning, vulnerability scanning, and so on). By performing automatic builds when
    new commits are added, regressions and breaking changes can be spotted early on
    in the software development life cycle. CI also helps address the challenges embodied
    by the phrase *it works on my machine* by providing a common build environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着企业多年来努力加速软件开发生命周期，自动化开发过程的需求应运而生，进而催生了 CI。CI 通过使用编排工具自动构建和测试应用程序代码来实现。当新的提交被推送到
    Git 仓库时，编排工具会自动检索源代码，并执行预定的一系列步骤来构建应用程序（包括代码质量扫描、漏洞扫描等任务）。通过在新的提交添加时进行自动构建，可以在软件开发生命周期的早期发现回归和破坏性变更。CI
    还通过提供一个共同的构建环境，帮助解决 *“它在我的机器上能工作”* 这一问题。
- en: The ability to apply many of CI’s concepts throughout the software development
    life cycle as an application moves toward production led to the creation of CD.
    CD is a set of defined steps provided to progress software through a release process.
    CD has gained acceptance and popularity among many organizations where proper
    change control is enforced, and approvals are required for the software to progress
    to the next stage. As many of the concepts around CI/CD are automated in a repeatable
    fashion, teams can look to fully eliminate the need for manual approval steps
    once they are confident that they have a reliable framework in place.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将 CI 的许多概念应用到整个软件开发生命周期中，随着应用程序向生产环境推进，最终导致了 CD 的诞生。CD 是一组定义好的步骤，用于推动软件通过发布过程。CD
    已经在许多组织中获得了接受和流行，尤其是在执行适当的变更控制并要求批准才能让软件推进到下一个阶段的组织中。由于 CI/CD 相关的许多概念都以可重复的方式自动化，团队可以着手完全消除手动审批步骤，一旦他们确信已经建立了可靠的框架。
- en: The process of implementing a fully automated build, test, deployment, and release
    process without human intervention is known as continuous deployment. While many
    software projects may never fully achieve continuous deployment, teams that can
    implement the concepts emphasized by CI/CD can produce real business value faster
    than less automated methods.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个完全自动化的构建、测试、部署和发布过程而无需人工干预的过程，称为持续部署。虽然许多软件项目可能永远无法完全实现持续部署，但能够实施 CI/CD
    强调的概念的团队，比那些采用较少自动化方法的团队能够更快地创造实际的商业价值。
- en: In the next section, we will introduce GitOps as a mechanism to improve how
    applications and their configuration are managed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍 GitOps 作为一种机制，以改善应用程序及其配置的管理方式。
- en: Taking CI/CD to the next level using GitOps
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GitOps 将 CI/CD 提升到一个新水平
- en: Kubernetes is a platform that embraces the use of declarative configurations.
    While applications can be managed using imperative `kubectl` commands, the preferred
    approach, which we covered in [*Chapter 1*](B17979_01.xhtml#_idTextAnchor015),
    *Understanding Kubernetes and Helm*, is to declaratively state the resources through
    the use of manifests. In the same way that an application traverses its way through
    a CI/CD pipeline, Kubernetes manifests can implement many of the same CI/CD patterns.
    Like application code, Kubernetes manifests should also be stored in a source
    code repository, such as Git, and can undergo the same type of build, test, and
    deployment practices.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个采用声明式配置的平台。虽然应用程序可以使用命令式的 `kubectl` 命令进行管理，但我们在[*第一章*](B17979_01.xhtml#_idTextAnchor015)《理解
    Kubernetes 和 Helm》中提到的首选方法是通过使用清单来声明性地指定资源。就像应用程序通过 CI/CD 管道运行一样，Kubernetes 清单也可以实现许多相同的
    CI/CD 模式。像应用程序代码一样，Kubernetes 清单也应存储在源代码仓库中，如 Git，并且可以进行相同类型的构建、测试和部署实践。
- en: The rise in popularity of managing the life cycle of Kubernetes applications
    and cluster configuration within Git repositories led to the concept of GitOps.
    First introduced by the software company *WeaveWorks* in 2017, GitOps has increased
    in popularity as a way to manage Kubernetes configurations. While GitOps is best
    known in the context of Kubernetes, its principles can be applied to any type
    of environment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Kubernetes 应用程序和集群配置的生命周期管理放入 Git 仓库的做法逐渐流行，这也促生了 GitOps 的概念。GitOps 首次由软件公司
    *WeaveWorks* 于 2017 年提出，随着 GitOps 被作为一种管理 Kubernetes 配置的方式，逐渐获得越来越多的关注。虽然 GitOps
    在 Kubernetes 背景下最为人知，但其原则也可以应用于任何类型的环境。
- en: Similar to CI/CD, tools have been developed to manage the GitOps process. These
    include **Argo CD** from Intuit and **Flux** from WeaveWorks. However, you do
    not need to use a tool specifically designed for GitOps as any automation utility
    or CI/CD orchestrator can be used. The key differentiator between a traditional
    CI/CD tool and a tool designed for GitOps is a GitOps tool’s ability to constantly
    observe the state of the target environment and apply desired configurations when
    the live state does not match the desired state, as defined in the manifests stored
    in Git. In the context of Kubernetes, these tools make use of the controller pattern,
    which is fundamental to Kubernetes itself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 CI/CD，已经开发出了一些工具来管理 GitOps 流程。这些工具包括 **Argo CD**（来自 Intuit）和 **Flux**（来自
    WeaveWorks）。不过，您不需要使用专门为 GitOps 设计的工具，因为任何自动化工具或 CI/CD 协调器都可以使用。传统的 CI/CD 工具和为
    GitOps 设计的工具之间的主要区别在于，GitOps 工具能够持续监控目标环境的状态，并在实时状态与 Git 中定义的清单所规定的期望状态不匹配时应用期望的配置。在
    Kubernetes 的背景下，这些工具利用了控制器模式，这也是 Kubernetes 本身的基础。
- en: Since Helm charts are ultimately rendered as Kubernetes resources, they, too,
    can be used to participate in the GitOps process. In this chapter, we will leverage
    Argo CD to deploy Helm chart resources to Kubernetes in a GitOps fashion. Note
    that this is not intended to be a comprehensive overview of Argo CD, but it will
    give you an idea of how it can be integrated with Helm to provide a GitOps approach
    toward Helm deployments.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Helm charts 最终会被渲染为 Kubernetes 资源，它们也可以用于参与 GitOps 流程。在本章中，我们将利用 Argo CD
    以 GitOps 方式将 Helm chart 资源部署到 Kubernetes。请注意，这并不是 Argo CD 的全面概述，但它会让您了解如何将 Argo
    CD 与 Helm 集成，从而为 Helm 部署提供 GitOps 方法。
- en: Setting up your environment
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置您的环境
- en: In this chapter, we will create several namespaces to install Argo CD and deploy
    an example Helm chart across different namespaces.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建几个命名空间来安装 Argo CD，并在不同的命名空间中部署示例 Helm chart。
- en: 'Run the following commands to prepare your environment:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以准备您的环境：
- en: 'Start `minikube` by running the `minikube start` command:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `minikube start` 命令启动 `minikube`：
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, create a new namespace called `argo`, where we will later install Argo
    CD:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，创建一个新的命名空间 `argo`，稍后我们将在该命名空间中安装 Argo CD：
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, create a namespace called `chapter10`, where we will deploy an example
    Helm chart from Argo CD:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `chapter10` 的命名空间，在这个命名空间中我们将从 Argo CD 部署一个示例的 Helm chart：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, create two namespaces called `chapter10-dev` and `chapter10-prod`.
    We will use these namespaces to demonstrate deploying a Helm chart across multiple
    environments using Argo CD:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建两个命名空间，分别为 `chapter10-dev` 和 `chapter10-prod`。我们将使用这些命名空间来演示如何使用 Argo CD
    在多个环境中部署 Helm chart：
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With your `minikube` environment ready and your namespaces created, let’s begin
    by deploying Argo CD. Then, we will walk through examples of using Argo CD to
    deploy an application to Kubernetes with Helm.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 `minikube` 环境准备好并创建好命名空间后，让我们从部署 Argo CD 开始。然后，我们将通过示例展示如何使用 Argo CD 使用
    Helm 将应用程序部署到 Kubernetes。
- en: Installing Argo CD
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Argo CD
- en: Argo CD can be installed in Kubernetes by using a set of manifest files or by
    installing a Helm chart. Of course, we will choose to install Argo CD using the
    community-provided Helm chart.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用一组清单文件或安装 Helm chart 来在 Kubernetes 中安装 Argo CD。当然，我们将选择使用社区提供的 Helm chart
    来安装 Argo CD。
- en: The repository URL for the Argo CD Helm chart is [https://argoproj.github.io/argo-helm](https://argoproj.github.io/argo-helm)
    (which can be found in Artifact Hub, a process described in [*Chapter 3*](B17979_03.xhtml#_idTextAnchor083),
    *Installing Your First App with Helm*).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD Helm chart 的仓库 URL 为 [https://argoproj.github.io/argo-helm](https://argoproj.github.io/argo-helm)（该链接可以在
    Artifact Hub 中找到，具体过程见 [*第 3 章*](B17979_03.xhtml#_idTextAnchor083)，*使用 Helm 安装您的第一个应用*）。
- en: 'Let’s add this repository using the Helm CLI:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Helm CLI 添加这个仓库：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once the repository has been added, you can install it. We have provided a `values`
    file you can use for the installation in the Packt repository at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/argo-values/values.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/argo-values/values.yaml).
    The provided `values` file disables Dex (an OpenID Connect provider), along with
    Argo’s notification system, since we will not be using these components in this
    chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦仓库已添加，您可以进行安装。我们提供了一个 `values` 文件，您可以在 Packt 仓库中用于安装，地址为 [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/argo-values/values.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/argo-values/values.yaml)。提供的
    `values` 文件禁用了 Dex（一个 OpenID Connect 提供者）以及 Argo 的通知系统，因为我们在本章中不会使用这些组件。
- en: 'Let’s install Argo CD in the `argo` namespace by running the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下命令在 `argo` 命名空间中安装 Argo CD：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The Helm chart installs the following components in the `argo` namespace:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 图表会在 `argo` 命名空间中安装以下组件：
- en: '`Application` custom resources. When an `Application` resource is created,
    Argo CD creates resources to the desired destination cluster and namespace.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application` 自定义资源。当创建 `Application` 资源时，Argo CD 会将资源创建到目标集群和命名空间。'
- en: '`ApplicationSet` custom resources. `ApplicationSet` provides a convenient way
    to deploy multiple different yet related `Application` resources. We will work
    with ApplicationSets when we demonstrate how to deploy a Helm chart to multiple
    different environments or namespaces.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationSet` 自定义资源。`ApplicationSet` 提供了一种便捷的方式来部署多个不同但相关的 `Application`
    资源。在演示如何将 Helm 图表部署到多个不同环境或命名空间时，我们将使用 ApplicationSets。'
- en: '**Redis**, which is used for caching backend data.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Redis**，用于缓存后端数据。'
- en: '**Argo CD Repo Server**, which provides a local instance of cloned Git repositories.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Argo CD Repo Server**，提供克隆 Git 仓库的本地实例。'
- en: '**Argo CD Server**, which provides an API for interacting with Argo CD. This
    component also provides a frontend web interface.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Argo CD Server**，提供与 Argo CD 交互的 API。此组件还提供前端 Web 界面。'
- en: 'Once each of the pods in the `argo` namespace reports the 1/1 ready state (shown
    by running `kubectl get pods –n argo`), we can access the Argo CD web UI. First,
    we need to get the admin password that was randomly generated during the Helm
    installation. We can do this by accessing a Kubernetes `secret` in the `argo`
    namespace:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `argo` 命名空间中的每个 pod 报告 1/1 就绪状态（通过运行 `kubectl get pods –n argo` 可以看到），我们就可以访问
    Argo CD Web UI。首先，我们需要获取在 Helm 安装期间随机生成的管理员密码。我们可以通过访问 `argo` 命名空间中的 Kubernetes
    `secret` 来实现：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The username for accessing the web UI will be `admin`, and the password will
    be the string displayed after getting the password from `the argocd-initial-admin-secret`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 Web UI 的用户名将是 `admin`，密码是从 `the argocd-initial-admin-secret` 中获取的字符串。
- en: 'Finally, we can run `port-forward` to access the web UI. In a separate terminal,
    run the following `port-forward` command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以运行 `port-forward` 来访问 Web UI。在一个单独的终端中，运行以下 `port-forward` 命令：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After running the `port-forward` command, navigate to [https://localhost:8443](https://localhost:8443)
    in a web browser. Accept the self-signed certificate exception; you will be presented
    with the Argo CD login page:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `port-forward` 命令后，在 Web 浏览器中导航到 [https://localhost:8443](https://localhost:8443)。接受自签名证书异常；您将看到
    Argo CD 登录页面：
- en: '![Figure 10.1 – The Argo CD login page'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.1 – Argo CD 登录页面'
- en: '](img/Figure_10.01_B17979.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.01_B17979.jpg)'
- en: Figure 10.1 – The Argo CD login page
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – Argo CD 登录页面
- en: 'For the username, enter `admin`, and for the password, provide the string that
    was displayed after getting the password from `argocd-initial-admin-secret`. After
    successfully logging in, you should see the following page titled **APPLICATIONS
    TILES**:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户名，输入 `admin`，对于密码，提供在获取密码时显示的字符串，来自 `argocd-initial-admin-secret`。成功登录后，您应该看到以下标题为
    **APPLICATIONS TILES** 的页面：
- en: '![Figure 10.2 – The Argo CD APPLICATIONS TILES page'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2 – Argo CD 应用程序面板页面'
- en: '](img/Figure_10.02_B17979.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.02_B17979.jpg)'
- en: Figure 10.2 – The Argo CD APPLICATIONS TILES page
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – Argo CD 应用程序面板页面
- en: This page can be used to create new applications, which represent application
    deployments (or any set of Kubernetes resources). However, in the spirit of adhering
    to a more declarative configuration approach, we will make deployments in this
    chapter by applying `Application` YAML resources instead. With that said, this
    UI will populate with application tiles as we apply the `Application` resources
    directly using `kubectl`. Feel free to reference this UI throughout this chapter
    to see how they are visualized.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本页面可用于创建新应用，这些应用表示应用部署（或任何一组 Kubernetes 资源）。然而，遵循更具声明式配置方法的精神，我们将在本章中通过应用 `Application`
    YAML 资源来进行部署。话虽如此，当我们使用 `kubectl` 直接应用 `Application` 资源时，UI 将会填充应用图块。可以在本章中随时参考此
    UI，查看其如何可视化。
- en: With Argo CD successfully deployed, let’s continue by deploying a Helm chart
    from a Git repository.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 成功部署后，让我们继续从 Git 仓库部署 Helm 图表。
- en: Deploying a Helm chart from a Git repository
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Git 仓库部署 Helm 图表
- en: 'In true GitOps fashion, Argo CD can be used to deploy a Helm chart from a Git
    repository. The following diagram shows the flow involved in deploying a Helm
    chart from a Git repository using Argo CD:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 按照真正的 GitOps 风格，Argo CD 可用于从 Git 仓库部署 Helm 图表。下图展示了使用 Argo CD 从 Git 仓库部署 Helm
    图表时的流程：
- en: '![Figure 10.3 – Deploying a Helm chart from a Git repository'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3 – 从 Git 仓库部署 Helm 图表'
- en: '](img/Figure_10.03_B17979.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.03_B17979.jpg)'
- en: Figure 10.3 – Deploying a Helm chart from a Git repository
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 从 Git 仓库部署 Helm 图表
- en: Here, you can see that Argo CD clones the Git repository containing the desired
    Helm chart. Then, Argo CD interprets the repository as one containing a Helm chart,
    since it notices the presence of the `Chart.yaml` file and surrounding Helm chart
    structure. From there, Argo CD proceeds by rendering the Helm chart manifests
    and applying them to the designated Kubernetes namespace.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 Argo CD 克隆了包含所需 Helm 图表的 Git 仓库。然后，Argo CD 将该仓库解释为一个包含 Helm 图表的仓库，因为它注意到
    `Chart.yaml` 文件和周围的 Helm 图表结构的存在。从那里，Argo CD 继续渲染 Helm 图表清单并将其应用到指定的 Kubernetes
    命名空间。
- en: Note that Argo CD *renders* the Helm chart templates and applies them as opposed
    to installing the Helm chart directly. This is because Argo CD only applies Kubernetes
    manifests, so it first runs a helm `template` internally to produce the full Kubernetes
    manifest from the provided Helm values. If you were to run the `helm list` command
    after deploying a chart using Argo CD, you would not see any releases listed.
    You would, however, be able to see the applied resources.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Argo CD *渲染* Helm 图表模板并将其应用，而不是直接安装 Helm 图表。这是因为 Argo CD 只会应用 Kubernetes
    清单，因此它首先会在内部运行 `helm template` 以根据提供的 Helm 值生成完整的 Kubernetes 清单。如果你在使用 Argo CD
    部署图表后运行 `helm list` 命令，你将看不到任何发布项。不过，你仍然可以看到应用的资源。
- en: You may be curious about the implications that deploying rendered Kubernetes
    manifests has on application rollbacks since the `helm rollback` command cannot
    be used. With the GitOps ideology, you would ideally roll back by performing changes
    within your Git repository to revert such actions. Argo CD would then detect any
    new commits that have been created against the target branch and apply the desired
    changes. With that said, Argo CD does have a native rollback capability to roll
    back to a previous history ID. This enables users to roll back without reverting
    to their Git repository.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇，渲染的 Kubernetes 清单在应用回滚时的影响，因为无法使用 `helm rollback` 命令。在 GitOps 思想中，你理想的回滚方式是通过在
    Git 仓库中进行更改来撤销这些操作。然后，Argo CD 会检测到任何对目标分支的新提交，并应用所需的更改。话虽如此，Argo CD 确实具有本地回滚功能，可以回滚到以前的历史
    ID。这使得用户无需回滚到 Git 仓库即可进行回滚。
- en: 'Let’s begin to deploy a Helm chart from Git by observing the `Application`
    resource located in the Packt repository at `chapter10/local-chart/application.yaml`
    ([https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/local-chart/application.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/local-chart/application.yaml)).
    We can break this resource down into separate components:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过观察位于 Packt 仓库的 `chapter10/local-chart/application.yaml` 中的 `Application`
    资源，开始从 Git 部署 Helm 图表 ([https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/local-chart/application.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/local-chart/application.yaml))。我们可以将此资源拆分为不同的组件：
- en: 'First, we must define the resource’s `kind` and provide the resource metadata:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们必须定义资源的`kind`并提供资源的元数据：
- en: '[PRE8]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice the finalizer, `resources-finalizer.argocd.argoproj.io`. **Finalizers**,
    in Kubernetes, are used to trigger a pre-delete action on the managing controller.
    With this finalizer, we tell the application controller that if we delete this
    application resource, the controller should delete the rendered Kubernetes resources
    first. If we omit the finalizer, the application controller will simply remove
    the application resource without deleting the rendered Kubernetes resources.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意最终器`resources-finalizer.argocd.argoproj.io`。**最终器**在Kubernetes中用于触发管理控制器的删除前操作。通过这个最终器，我们告诉应用程序控制器，如果我们删除此应用程序资源，控制器应该首先删除渲染的Kubernetes资源。如果省略了最终器，应用程序控制器将直接删除应用程序资源，而不删除渲染的Kubernetes资源。
- en: 'Next, we must define the application source. This is where we specify the Git
    repository URL and the path to the Helm chart:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义应用程序源。在此，我们指定Git仓库URL和Helm图表的路径：
- en: '[PRE9]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see from the configuration, Argo CD will clone the repository (https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git)
    at the most recent commit (`HEAD`). Once cloned, it navigates to the `helm-charts/charts/nginx`
    path, which contains an Nginx Helm chart.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从配置中可以看到，Argo CD将在最新的提交（`HEAD`）处克隆仓库（https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git）。克隆完成后，它会导航到`helm-charts/charts/nginx`路径，该路径包含一个Nginx
    Helm图表。
- en: 'Here, we also specified a set of Helm values, setting the resource limits and
    requests under the `helm.values` section. Values can also be provided by using
    the `helm.parameters` setting, like so:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们还指定了一组Helm值，在`helm.values`部分设置了资源限制和请求。值也可以通过使用`helm.parameters`设置来提供，如下所示：
- en: '[PRE10]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This would be similar to passing the --set flag on the command line.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于在命令行中传递`--set`标志。
- en: Finally, values can also be provided using the `helm.valueFiles` setting. We
    will describe this use case in greater detail in the *Deploying a Helm chart to
    multiple environments* section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值也可以通过`helm.valueFiles`设置提供。我们将在*将Helm图表部署到多个环境*部分中更详细地描述此用例。
- en: 'The final portion of the `Application` resource defines the destination and
    synchronization (sync) policy:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application`资源的最后部分定义了目标和同步（sync）策略：'
- en: '[PRE11]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`destination` defines the Kubernetes server API of the target cluster and the
    namespace that resources should be deployed to. `syncPolicy` determines how the
    application should be synchronized. In this context, `sync` means to apply, or
    update, the resources in the cluster with those from the application source. Syncs
    can be done manually, but in this example, we have selected to automate it so
    that Nginx is deployed as soon as the application resource is created.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`destination`定义了目标集群的Kubernetes服务器API以及资源应该部署到的命名空间。`syncPolicy`决定了应用程序应该如何同步。在此上下文中，`sync`表示将集群中的资源应用或更新为应用源中的资源。同步可以手动进行，但在此示例中，我们选择自动化同步，这样当应用程序资源创建时，Nginx就会自动部署。'
- en: Under the `syncPolicy.automated` section, several additional configurations
    can be specified. The `prune` field is a Boolean that determines whether Kubernetes
    resources should be deleted if they are removed from the source. The `selfHeal`
    setting instructs Argo CD to ensure consistency between the desired state and
    the live state. If a resource is modified within the Kubernetes cluster, `selfHeal`
    will cause Argo CD to revert the modification so that it matches the source configuration.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`syncPolicy.automated`部分下，可以指定几个其他配置项。`prune`字段是一个布尔值，决定了如果Kubernetes资源从源中移除，是否应该删除该资源。`selfHeal`设置指示Argo
    CD确保期望状态和实际状态的一致性。如果Kubernetes集群中的资源被修改，`selfHeal`将导致Argo CD还原该修改，使其与源配置匹配。
- en: 'Now that we understand the application resource for defining our Nginx application,
    we can install this `Application` resource by using the `kubectl apply` command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了定义Nginx应用程序的应用程序资源，我们可以使用`kubectl apply`命令安装此`Application`资源：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The result creates the `Application` resource in the `argo` namespace, where
    Argo CD has visibility to application resources.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 结果会在`argo`命名空间中创建`Application`资源，在那里Argo CD能够看到应用程序资源。
- en: 'Upon creating the application resource, you can see the deployment status by
    running the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序资源后，可以通过运行以下命令查看部署状态：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`SYNC STATUS` shows whether or not the desired state has been synced with the
    live state, while `HEALTH STATUS` shows whether or not the rollout has been completed
    or if the pods are still starting up. It may take a moment for `SYNC STATUS` and
    `HEALTH STATUS` to reach these values as the `nginx` chart and the associated
    resources are installed in the cluster. We can see the status of the deployment
    using more traditional means – that is, by running the `kubectl get pods` command
    in the `chapter10` namespace:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`SYNC STATUS` 显示期望状态是否已与实时状态同步，而 `HEALTH STATUS` 显示发布是否已完成，或者 pods 是否仍在启动中。由于
    `nginx` 图表和相关资源正在集群中安装，`SYNC STATUS` 和 `HEALTH STATUS` 可能需要一段时间才能显示这些值。我们可以通过更传统的方式查看部署状态——即，在
    `chapter10` 命名空间中运行 `kubectl get pods` 命令：'
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With `Application` reporting as synchronized and healthy, you have successfully
    deployed a Helm chart from a Git repository using Argo CD! Let’s delete the application
    resource (which will also remove the `nginx` pod from the `chapter10` namespace):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Application` 显示为已同步并且健康时，说明你已经成功通过 Argo CD 从 Git 仓库部署了 Helm 图表！接下来，让我们删除该应用资源（这也会从
    `chapter10` 命名空间中移除 `nginx` pod）：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Before we depart from this topic, it should be noted that, as expected in a
    GitOps model, changes to the `nginx` Helm chart in Git will automatically propagate
    to the Kubernetes environment. If you were to update the `nginx` chart and publish
    a new commit to the Git repository for the particular target branch, Argo CD would
    notice this change in the next polling interval and update the Kubernetes namespace
    with the desired state, as defined in the repository. For faster synchronization,
    webhooks can be configured on the Git repository to trigger an Argo CD sync in
    an event-driven fashion. Information on configuring webhooks is described in the
    Argo CD documentation at [https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/](https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开这个话题之前，需要注意的是，正如 GitOps 模型所预期的那样，对 Git 中 `nginx` Helm 图表的更改将自动传播到 Kubernetes
    环境。如果你更新了 `nginx` 图表并将新提交发布到目标分支的 Git 仓库中，Argo CD 会在下次轮询间隔中注意到这个变化，并根据仓库中定义的期望状态更新
    Kubernetes 命名空间。为了更快地同步，可以在 Git 仓库上配置 webhook，以事件驱动的方式触发 Argo CD 同步。有关配置 webhook
    的信息，请参见 Argo CD 文档：[https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/](https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/)。
- en: Next, we will learn how to use Argo CD to deploy a Helm chart from a remote
    chart repository.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用 Argo CD 从远程图表仓库部署 Helm 图表。
- en: Deploying an application from a remote Helm chart repository
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从远程 Helm 图表仓库部署应用程序
- en: When installing Helm charts, users often interact with remote repositories.
    Similarly, we can use Argo CD to deploy an application from a specified Helm chart
    repository.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Helm 图表时，用户通常会与远程仓库进行交互。同样，我们可以使用 Argo CD 从指定的 Helm 图表仓库部署应用程序。
- en: 'The following diagram shows the flow involved in deploying an application from
    a remote Helm chart repository with Argo CD:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了通过 Argo CD 从远程 Helm 图表仓库部署应用程序的流程：
- en: '![Figure 10.4 – Deploying an application from a remote Helm chart repository'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.4 – 从远程 Helm 图表仓库部署应用程序'
- en: '](img/Figure_10.04_B17979.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.04_B17979.jpg)'
- en: Figure 10.4 – Deploying an application from a remote Helm chart repository
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 从远程 Helm 图表仓库部署应用程序
- en: First, Argo CD downloads the Helm chart configured in the `Application` resource.
    Then, it renders the Helm chart and applies the manifests to the destination cluster
    and namespace.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Argo CD 下载在 `Application` 资源中配置的 Helm 图表。然后，它渲染该 Helm 图表并将清单应用到目标集群和命名空间。
- en: 'We have provided an example `Application` resource in the Packt repository
    at `chapter10/remote-registry/application.yaml` ([https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/remote-registry/application.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/remote-registry/application.yaml)).
    The resource is configured similarly to `Application` from the previous section,
    but we can observe one key difference in the `source` section:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Packt 仓库的 `chapter10/remote-registry/application.yaml` 中提供了一个示例 `Application`
    资源 ([https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/remote-registry/application.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/remote-registry/application.yaml))。该资源的配置与上一节中的
    `Application` 类似，但我们可以在 `source` 部分观察到一个关键的不同点：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, instead of providing a Git repository, we provided the location of a remote
    Helm chart repository, as well as the chart’s name and version. As you can see,
    this `Application` will instruct Argo CD to deploy version `9.7.6` of the `nginx`
    chart from the Bitnami chart repository.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们没有提供 Git 仓库，而是提供了远程 Helm 图表仓库的位置，以及图表的名称和版本。如您所见，此`Application`将指示 Argo
    CD 从 Bitnami 图表仓库部署`nginx`图表的版本`9.7.6`。
- en: The process of deploying a Helm chart from a chart repository is the same as
    deploying from a Git repository – simply apply the `Application` resource to the
    `argo` namespace. Feel free to walk through the same steps provided in the previous
    section to deploy the application to the `chapter10` namespace.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表仓库部署 Helm 图表的过程与从 Git 仓库部署是相同的——只需将`Application`资源应用到`argo`命名空间。您可以自由地按照前一节提供的相同步骤，将应用程序部署到`chapter10`命名空间。
- en: Where the process changes slightly is when we talk about deploying a Helm chart
    to multiple environments, a topic that we will cover in the next section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论将 Helm 图表部署到多个环境时，过程会有所变化，这个话题我们将在下一节中讨论。
- en: Deploying a Helm chart to multiple environments
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Helm 图表部署到多个环境
- en: 'In the previous sections, we used Argo CD to deploy a Helm chart to a single
    environment (or namespace). However, when deploying applications in the enterprise,
    you will often expect to deploy across multiple different environments, achieving
    a process similar to what’s shown in the following diagram:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用 Argo CD 将 Helm 图表部署到单一环境（或命名空间）。然而，在企业中部署应用程序时，您通常会期望将应用程序部署到多个不同的环境，达到类似下图所示的过程：
- en: '![Figure 10.5 – Deploying to multiple namespaces'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.5 – 部署到多个命名空间'
- en: '](img/Figure_10.05_B17979.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.05_B17979.jpg)'
- en: Figure 10.5 – Deploying to multiple namespaces
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 部署到多个命名空间
- en: You may want to deploy charts to different environments (separate namespaces
    or even separate clusters) for a variety of reasons, including high availability
    or for deploying an application across multiple stages of a pipeline, such as
    dev, test, and prod. Luckily, we can achieve this in Argo CD using the `ApplicationSet`
    construct.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望将图表部署到不同的环境（独立的命名空间甚至是独立的集群），原因多种多样，包括高可用性，或是将应用程序部署到管道的多个阶段，如开发、测试和生产环境。幸运的是，我们可以在
    Argo CD 中使用`ApplicationSet`构建来实现这一目标。
- en: 'Imagine that we have two separate namespaces – one for dev and another for
    prod. We could create two separate `Application` resources, each targeting a separate
    namespace in the destination section:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个独立的命名空间——一个用于开发（dev），另一个用于生产（prod）。我们可以创建两个独立的`Application`资源，每个资源在目标部分中指向一个独立的命名空间：
- en: 'Dev would look as follows:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dev 环境将如下所示：
- en: '[PRE17]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Prod would be very similar, but we would specify `prod` in the `namespace`
    property:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产环境（Prod）将非常相似，但我们会在`namespace`属性中指定`prod`：
- en: '[PRE18]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using two different `Application` resources – one for each environment – is
    a perfectly valid option for approaching this type of deployment. However, Argo
    CD introduced `ApplicationSet` as a method for wrapping multiple `Application`
    instances in a single resource, allowing you to define multiple destinations without
    managing multiple resource YAML files.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个不同的`Application`资源——每个环境一个——是处理这种类型部署的完全有效的选项。然而，Argo CD 引入了`ApplicationSet`，作为一种将多个`Application`实例包装成单个资源的方法，使您可以在不管理多个资源
    YAML 文件的情况下定义多个目标。
- en: 'An example of an `ApplicationSet` is provided in the Packt repository at `chapter10/multiple-envs/applicationset.yaml`
    ([https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/multiple-envs/applicationset.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/multiple-envs/applicationset.yaml)).
    Let’s break down the different sections of this resource:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationSet`的示例可以在 Packt 仓库中的`chapter10/multiple-envs/applicationset.yaml`找到（[https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/multiple-envs/applicationset.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/multiple-envs/applicationset.yaml)）。让我们来分析一下该资源的不同部分：'
- en: 'The first component of an `ApplicationSet` is the `generators` section, which
    generates parameters that are used later on to dynamically configure the application
    details, such as the source and destination. There are many different types of
    generators, which can be explored in greater detail in the Argo CD documentation
    at [https://argocd-applicationset.readthedocs.io/en/stable/Generators/](https://argocd-applicationset.readthedocs.io/en/stable/Generators/).
    In our example, we used the `list` generator, which allows a list of simple key-value
    pairs to be provided:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationSet`的第一个组件是`generators`部分，它生成用于后续动态配置应用程序详细信息（如源和目标）的参数。生成器有许多不同类型，可以在Argo
    CD文档中获得更详细的说明，文档链接为[https://argocd-applicationset.readthedocs.io/en/stable/Generators/](https://argocd-applicationset.readthedocs.io/en/stable/Generators/)。在我们的示例中，我们使用了`list`生成器，它允许提供一组简单的键值对：'
- en: '[PRE19]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, two elements that define our different environments are specified
    – `dev` and `prod`. We will reference these environments throughout the rest of
    `ApplicationSet` to deploy the `nginx` chart to both stages of our deployment
    pipeline.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，定义我们不同环境的两个元素已经指定——`dev`和`prod`。我们将在`ApplicationSet`的其余部分中引用这些环境，将`nginx`图表部署到我们的部署管道的两个阶段。
- en: 'Next, we must define the `Application` template. We start by providing a name
    that `ApplicationSet` will inject into the generated `Applications`:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义`Application`模板。我们首先提供一个名称，`ApplicationSet`将把该名称注入到生成的`Applications`中：
- en: '[PRE20]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `{{ env }}` syntax denotes a placeholder that will be replaced by the `env`
    elements described in the `generators` section. So, when we create `ApplicationSet`,
    we can expect two different applications to be created: `– nginx-dev` and `nginx-prod`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{ env }}`语法表示一个占位符，它将被`generators`部分中描述的`env`元素替换。因此，当我们创建`ApplicationSet`时，我们可以期望会创建两个不同的应用程序：`–
    nginx-dev`和`nginx-prod`。'
- en: 'Now that we have specified the names of the applications that will be created,
    we can configure the sources. This will look similar to what we have seen in the
    previous sections:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们已经指定了将要创建的应用程序的名称，接下来可以配置源。这将与我们在之前的章节中看到的内容类似：
- en: '[PRE21]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This source indicates that Argo CD will deploy the Helm chart located under
    `chapter10/multiple-envs/nginx` at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git).
    However, instead of deploying the same configuration in each environment, we will
    apply slightly different values based on the environment. This can be seen under
    the `helm.valueFiles` setting, which provides a list of values files to be applied
    (similar to using the `--values` flag on the command line). Regardless of the
    environment, we will always apply a common set of values defined in the `values/common-values.yaml`
    file, but depending on the environment, we will also apply either the `values/dev/values.yaml`
    file or the `values/prod/values.yaml` file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个源表示Argo CD将部署位于[https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git)的`chapter10/multiple-envs/nginx`下的Helm图表。然而，我们并不是在每个环境中部署相同的配置，而是会根据环境应用稍微不同的值。这可以在`helm.valueFiles`设置中看到，它提供了一个值文件列表供应用（类似于在命令行中使用`--values`标志）。无论环境如何，我们始终会应用在`values/common-values.yaml`文件中定义的通用值集，但根据环境的不同，我们还会应用`values/dev/values.yaml`文件或`values/prod/values.yaml`文件。
- en: These values files can be seen within the `chapter10/multiple-envs/nginx/values`
    directory ([https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter10/multiple-envs/nginx/values](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter10/multiple-envs/nginx/values)).
    Note that, since Argo CD has been configured to use the `chapter10/multiple-envs/nginx`
    chart path, the values files must be located underneath this path. It is also
    important to note that this method of applying values files is only applicable
    when deploying a Helm chart from Git. When deploying from a remote Helm chart
    repository, values can be provided using the `helm.values` or `helm.parameters`
    method, as described in the *Deploying a Helm chart from a Git repository* section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值文件可以在 `chapter10/multiple-envs/nginx/values` 目录中查看（[https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter10/multiple-envs/nginx/values](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter10/multiple-envs/nginx/values)）。请注意，由于
    Argo CD 已配置为使用 `chapter10/multiple-envs/nginx` chart 路径，因此值文件必须位于此路径下。同样需要注意的是，这种应用值文件的方法仅适用于从
    Git 部署 Helm chart。当从远程 Helm chart 仓库部署时，可以使用 `helm.values` 或 `helm.parameters`
    方法提供值，正如 *从 Git 仓库部署 Helm chart* 章节中所描述的那样。
- en: 'Finally, we must define the destinations that Argo CD should deploy the resources
    to:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们必须定义 Argo CD 应该将资源部署到的目标：
- en: '[PRE22]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will deploy the Helm chart to the `chapter10-dev` and `chapter10-prod`
    namespaces. In this example, we separated environments by namespace for simplicity,
    but you can also instruct Argo CD to deploy to separate clusters by parameterizing
    the `destination.server` section in a fashion similar to how we have parameterized
    the namespace.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 Helm chart 部署到 `chapter10-dev` 和 `chapter10-prod` 命名空间。在此示例中，我们通过命名空间将环境分开，出于简化的考虑，但您也可以通过参数化
    `destination.server` 部分来指示 Argo CD 部署到不同的集群，就像我们参数化命名空间一样。
- en: 'Now that we know how `ApplicationSet` is created, let’s apply it to our Kubernetes
    cluster to deploy our Helm chart across different environments. First, apply `ApplicationSet`
    located at `chapter10/multiple-envs/applicationset.yaml` ([https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/multiple-envs/applicationset.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/multiple-envs/applicationset.yaml)):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何创建 `ApplicationSet`，让我们将其应用到我们的 Kubernetes 集群中，将 Helm chart 部署到不同的环境。首先，应用位于
    `chapter10/multiple-envs/applicationset.yaml` 的 `ApplicationSet`（[https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/multiple-envs/applicationset.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter10/multiple-envs/applicationset.yaml)）：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Shortly, we should see two different applications appear in the `argo` namespace:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不久后，我们应该在 `argo` 命名空间中看到两个不同的应用：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can also observe the deployment running in our different environments:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以观察到在不同环境中运行的部署：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can observe three different `nginx` pods in `chapter10-prod` because the
    `values` file under `chapter10/multiple-envs/nginx/values/prod/values.yaml` specifies
    three replicas, while the `dev values` file only specifies one.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `chapter10-prod` 中观察到三个不同的 `nginx` pod，因为 `chapter10/multiple-envs/nginx/values/prod/values.yaml`
    中的值文件指定了三个副本，而 `dev values` 文件仅指定了一个副本。
- en: If you were able to observe similar output in your minikube environment to those
    shown previously, congratulations! You have successfully deployed a Helm chart
    to multiple environments in a GitOps fashion with Argo CD.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 minikube 环境中观察到类似于之前展示的输出，恭喜您！您已经成功地通过 Argo CD 以 GitOps 方式将 Helm chart
    部署到多个环境中。
- en: Let’s conclude this chapter by cleaning up the environment.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过清理环境来结束这一章。
- en: Cleaning up
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理环境
- en: 'First, let’s remove the namespaces from this chapter and the Argo installation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们删除这一章和 Argo 安装中的命名空间：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then, you can stop the minikube cluster with the `minikube stop` command.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用 `minikube stop` 命令停止 minikube 集群。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: CD and GitOps provide scalable methods for further abstracting the capabilities
    that Helm provides, allowing deployments to be controlled by the contents of a
    Git repository or a remote chart repository. In this chapter, we introduced the
    concepts of CI/CD and GitOps and explored them using Argo CD as a solution to
    implementing these models in the context of Helm. Then, we learned how to install
    Argo CD and how to create the `Application` and `ApplicationSet` resources, which
    are primitives for enabling Argo CD deployments and synchronizing them with specified
    Helm charts and values. Finally, we learned how to deploy a Helm chart across
    multiple different environments.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: CD和GitOps提供了可扩展的方法，进一步抽象化了Helm所提供的功能，允许通过Git仓库或远程Chart仓库的内容来控制部署。在本章中，我们介绍了CI/CD和GitOps的概念，并通过使用Argo
    CD作为实现这些模型的解决方案，探索了在Helm环境下的实现方式。接着，我们学习了如何安装Argo CD以及如何创建`Application`和`ApplicationSet`资源，它们是启用Argo
    CD部署并与指定的Helm图表和配置同步的基本组件。最后，我们学习了如何在多个不同环境中部署Helm图表。
- en: In the next chapter, we will explore another abstraction – the Helm operator.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索另一个抽象概念——Helm操作符。
- en: Questions
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答以下问题，测试你对本章内容的掌握情况：
- en: What is the difference between CI and CD?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI和CD有什么区别？
- en: What is the relationship between CD and GitOps?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CD和GitOps之间有什么关系？
- en: What is the difference between an Argo CD `Application` and `ApplicationSet`?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Argo CD`的`Application`和`ApplicationSet`之间有什么区别？'
- en: What is the Argo CD equivalent of passing the `--values` flag on the command
    line?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Argo CD中，如何等价于在命令行中传递`--values`标志？
- en: What is the Argo CD equivalent of passing the `--set` flag on the command line?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Argo CD中，如何等价于在命令行中传递`--set`标志？
- en: What is an `ApplicationSet` generator? Why are generators useful when deploying
    to multiple environments?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是`ApplicationSet`生成器？为什么在部署到多个环境时，生成器非常有用？
