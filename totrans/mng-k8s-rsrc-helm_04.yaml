- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scaffolding a New Helm Chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to use Helm from an end user perspective,
    leveraging it as a package manager to install applications to Kubernetes. Leveraging
    Helm in this fashion required you to understand how to use the Helm life cycle
    commands (`install`, `upgrade`, `rollback`, and `uninstall`), but it did not require
    you to understand how the Helm chart itself was built. While an understanding
    of the Helm CLI commands is necessary to install and manage applications installed
    by Helm, that level of knowledge alone will not allow you to package your own
    applications into Helm charts.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this book, starting with this chapter, we will switch
    gears away from being a Helm chart end user and transition into becoming a Helm
    chart developer. We will accomplish this by building a Helm chart from scratch
    over the next few chapters that deploys an instance of the Guestbook application,
    a commonly used sample application within the Kubernetes community. By the end
    of the second part, you will have an understanding of the concepts and experience
    required to write robust Helm charts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will begin to explore Helm chart development by discussing
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Guestbook application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the YAML format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `helm create` to scaffold a new Helm chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the scaffolded Guestbook chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the `Chart.yaml` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the `Chart.yaml` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section requires the `minikube` and `helm` binaries to be installed on
    your local machine. The installation and configuration of these tools are covered
    in [*Chapter 2*](B17979_02.xhtml#_idTextAnchor038), *Preparing a Kubernetes and
    Helm Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Guestbook application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the second part of this book will be centered around developing a Helm
    chart to deploy the Guestbook application, let’s first understand what this application
    does and what its architecture looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Guestbook application is a simple **PHP: Hypertext Preprocessor** (**PHP**)
    frontend designed to persist messages to a Redis backend. The frontend consists
    of a dialog box and a **Submit** button, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The Guestbook PHP frontend'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.1_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – The Guestbook PHP frontend
  prefs: []
  type: TYPE_NORMAL
- en: 'To interact with this application, users can follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Type a message in the **Messages** dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Submit** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the **Submit** button is clicked, the message will be saved to the Redis
    database and displayed at the bottom of the page, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The Guestbook frontend after a new message has been submitted'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.2_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – The Guestbook frontend after a new message has been submitted
  prefs: []
  type: TYPE_NORMAL
- en: Redis is an in-memory, key-value data store that, for our Helm chart, will be
    clustered to provide data replication. The cluster will consist of one leader
    node that the Guestbook frontend writes to. Once data is persisted, the leader
    will replicate across each of the follower nodes, from which Guestbook replicas
    will read, to retrieve and display the list of previously submitted messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram describes how the frontend interacts with Redis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Guestbook frontend and Redis interaction'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.3_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Guestbook frontend and Redis interaction
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of how this application works, let’s focus on starting
    our Guestbook Helm chart. We’ll begin with a primer on the YAML format, since
    this format is ubiquitous among the files you will interact with as a Helm chart
    developer.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the YAML format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**YAML Ain’t Markup Language** (**YAML**) is a file format used to create human-readable
    configuration. It is the file format most used to configure Kubernetes resources
    and is also the format used for many of the files in Helm charts.'
  prefs: []
  type: TYPE_NORMAL
- en: YAML files follow a **key-value** format to declare configuration. Let’s explore
    the YAML key-value construct.
  prefs: []
  type: TYPE_NORMAL
- en: Defining key-value pairs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most basic examples of a YAML key-value pair is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `name` key is given a `LearnHelm` value. In YAML,
    keys and values are separated by a colon (`:`). Characters written to the left
    of the colon represent the key, while characters written to the right of the colon
    represent the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spacing matters in YAML format. The following line does not constitute a valid
    key-value pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that a space is missing between the colon and the `LearnHelm` string. This
    would result in a parsing error. A space must exist between the colon and the
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the preceding example represents a simple key-value pair, YAML allows
    users to configure more complex pairings with nested elements, called maps. An
    example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example demonstrates a `resources` object containing a map of
    two key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `resources.limits.cpu` | `100m` |'
  prefs: []
  type: TYPE_TB
- en: '| `resources.limits.memory` | `512Mi` |'
  prefs: []
  type: TYPE_TB
- en: Keys are determined by following the indentation under a YAML block. Each indentation
    adds a dot (`.`) separator to the name of the key. The value of the key has been
    reached when there are no longer any indentations remaining in the YAML block.
    By common practice, indentations in YAML should use two spaces, but users can
    provide as many spaces as they desire as long as the spacing is consistent throughout
    the document.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: '**Tabs** are not supported by YAML, and their use will result in a parsing
    error.'
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of YAML key-value pairs, let’s now explore some of the
    common types that values can be defined as.
  prefs: []
  type: TYPE_NORMAL
- en: Value types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Values in a YAML file can be of different types. The most common type is a
    string, which is a text value. Strings can be declared by wrapping a value in
    quotation marks, but this is not always required. If a value contains at least
    one alphabetical letter or special character, the value is considered a string,
    with or without quotation marks. Multiline strings can be set by using the pipe
    (`|`) symbol, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Values can also be integers. A value is an integer when it is a numeric character
    that is not wrapped in quotations. The following YAML declares an integer value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare this to the following YAML, which assigns `replicas` to a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Boolean values are often used as well, which can be declared with either `true`
    or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This YAML sets `ingress.enable` to the `true` Boolean value. Other acceptable
    Boolean values are `yes`, `no`, `on`, `off`, `y`, `n`, `Y`, and `N`.
  prefs: []
  type: TYPE_NORMAL
- en: Values can also be set to more complex types, such as lists. Items in a list
    in YAML are identified by the dash (`-`) symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following demonstrates a YAML list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This YAML sets `servicePorts` to a list of integers (such as `8080` and `8443`).
    This syntax can also be used to describe a list of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `env` is set to a list of objects containing the `name` and `value`
    fields. Lists are often used in both Kubernetes and Helm configuration, and understanding
    them is valuable to using Helm to its fullest potential.
  prefs: []
  type: TYPE_NORMAL
- en: While YAML is more commonly used in the worlds of Kubernetes and Helm for its
    ease of readability, the **JavaScript Object Notation** (**JSON**) format can
    be used as well. Let’s briefly describe this format.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: YAML is a superset of another widely used format—JSON. This is a string of key-value
    pairs, similar to YAML. The key difference is that while YAML relies on spacing
    and indentation to properly configure key-value pairs, JSON relies on braces and
    brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example converts the previous YAML example into the JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'All the keys in JSON are wrapped in quotation marks and positioned before a
    colon:'
  prefs: []
  type: TYPE_NORMAL
- en: Curly braces (`{`) denote a block in a similar way to how indentations denote
    a block in YAML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Square brackets (`[`) denote a list in a similar way to how dashes denote a
    list in YAML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more constructs to the YAML and JSON formats, but this introduction
    provides more than enough information to understand how they can be used in Helm
    charts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will begin to develop our Guestbook Helm chart by first
    learning how to scaffold Helm charts.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding the Guestbook Helm chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When developing a new Helm chart from scratch, it is often useful to start
    by running the `helm create` command, which has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `helm create` command provides a new project folder for your Helm chart.
    Inside, the folder contains a basic Helm chart scaffolding that you can use to
    begin developing your chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the `helm create` command to scaffold our Guestbook Helm chart:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your terminal, within a directory where you would like to store Helm charts,
    run the `helm create` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Review the list of files that have been created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the `helm create` command generated a new folder for you called
    `guestbook`, which represents the name of the Helm chart. It is not necessarily
    required to call this folder `guestbook`, but since this is the name of the Helm
    chart we are creating, it is a good idea to make sure the folder name matches.
  prefs: []
  type: TYPE_NORMAL
- en: Under the `guestbook` folder, there are several different files and folders
    that make up your Helm chart. This may appear overwhelming at first, but we will
    dive deeper into each component as we develop the Guestbook chart over the next
    few chapters. By the end of the second part, each of these files will become clearer,
    and you will be able to jump into your next Helm chart with ease!
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let’s take a high-level look at each of the files that `helm create`
    generated for us. As you’ll see in the following table, some of the files are
    not strictly required for a new Helm chart, but `helm create` provided them for
    us as a best practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **File/Directory** | **Definition** | **Required?** |'
  prefs: []
  type: TYPE_TB
- en: '| `charts/` | A directory that contains dependencies or Helm charts that the
    parent chart depends on. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `Chart.yaml` | A file that contains metadata about the Helm chart. | Yes
    |'
  prefs: []
  type: TYPE_TB
- en: '| `.helmignore` | A file that contains a list of files and directories that
    should be omitted from the Helm chart’s packaging. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `templates/` | A directory that contains Golang templates, which are primarily
    used for generating Kubernetes resources. | Yes, unless the chart contains dependencies
    |'
  prefs: []
  type: TYPE_TB
- en: '| `templates/*.yaml` | A template file used to generate a Kubernetes resource.
    | Yes, unless the chart contains dependencies |'
  prefs: []
  type: TYPE_TB
- en: '| `templates/_*.tpl` | A file that contains boilerplate helper templates. |
    No |'
  prefs: []
  type: TYPE_TB
- en: '| `templates/NOTES.txt` | A template file that is used to generate usage instructions
    after chart installation. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `templates/tests/ (or more generically, templates/*/)` | A folder used for
    grouping different templates. This is strictly for aesthetics and has no effect
    on how the Helm chart operates – for example, `templates/tests` is used to group
    templates that are used for testing. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `values.yaml` | A file that contains the chart’s default values. | No, but
    every chart should contain this file as a best practice |'
  prefs: []
  type: TYPE_TB
- en: Table 4.2 – Files created with the “helm create” command
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the files listed in the preceding table, there are a few other
    files that a Helm chart can contain that `helm create` did not include for us.
    Let’s take a high-level look at these files in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **File/Directory** | **Definition** | **Required?** |'
  prefs: []
  type: TYPE_TB
- en: '| `Chart.lock` | A file used to save, or *lock in*, the previously applied
    dependency versions. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `crds/` | A directory that contains `templates/`. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `README.md` | A file that contains installation and usage information about
    the Helm chart. | No, but every Helm chart should contain this file as a best
    practice |'
  prefs: []
  type: TYPE_TB
- en: '| `LICENSE` | A file that contains the chart’s license, which provides information
    about usage and redistribution rights. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `values.schema.json` | A file that contains the chart’s values schema in
    the JSON format. Used to provide input validation. | No |'
  prefs: []
  type: TYPE_TB
- en: Table 4.3– Additional Helm chart files
  prefs: []
  type: TYPE_NORMAL
- en: Again, we will explore each of these files in greater detail when they become
    relevant to the topics we will discuss later in this chapter and over the next
    few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let’s focus on the content in the `guestbook` directory that `helm
    create` generated for us. You may be surprised to know that, upon running `helm
    create`, you already have a fully functional Helm chart contained within your
    `guestbook` folder! Let’s install the Guestbook chart in its current state to
    see what gets deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the scaffolded Guestbook chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we install the chart, let’s set up your Kubernetes environment by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start Minikube by running the `minikube start` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new namespace called `chapter4`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s proceed by installing your scaffolded chart and reviewing the deployed
    resources. In [*Chapter 3*](B17979_03.xhtml#_idTextAnchor083), *Installing Your
    First App With Helm*, we installed a Helm chart from a remote repository by providing
    the name `bitnami/wordpress`, which references the name of the remote repository
    and the chart contained within this repository. Alternatively, you can also install
    a chart by providing the local path to a valid Helm chart project folder. This
    makes it easy to test your Helm charts and see your progress without needing to
    publish the chart to a repository first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s install your chart by running the following command, where `./guestbook`
    represents the folder generated by `helm create`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run `helm get manifest` to review the resources that were deployed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As denoted in the output, your scaffolded Guestbook chart (with the default
    values applied) contains one service account, one service, and one deployment.
    If you look carefully at the deployment, you’ll find something interesting about
    the image that was deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Sure enough, a new Helm chart that was scaffolded using `helm create` begins
    as a basic NGINX chart. **NGINX** is a popular open source web server and reverse
    proxy. Because its installation requires many of the same resources as many other
    Kubernetes applications, it serves as a great starting point when writing new
    Helm charts.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue by accessing the NGINX application to verify it was installed
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the Helm chart created a `ClusterIP` service, let’s run `kubectl port-forward`
    so that we can access the NGINX pod. Keep in mind that, although our Guestbook
    chart has installed NGINX, the deployed resources are still called `guestbook`,
    since that is the name of our chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a new terminal window (since the current one will block while the `kubectl
    port-forward` command is active), use the `curl` command to reach NGINX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we are able to reach NGINX successfully. Now, let’s continue
    by cleaning up this Helm release.
  prefs: []
  type: TYPE_NORMAL
- en: Press *Ctrl* + *c* in the terminal window running the `kubectl port-forward`
    command. Alternatively, you can close the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Uninstall the `guestbook` Helm release:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you can delete the `chapter4` namespace, since we won’t need it for the
    remainder of the chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you can shut down your `minikube` cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You may realize after this exercise that our Guestbook chart doesn’t resemble
    the architecture we presented at the beginning of this chapter very much. However,
    by providing a scaffold that we will use as a starting point, we have already
    made great progress toward creating a Helm chart for deploying the desired architecture.
    We will continue making progress on our Guestbook chart in the next chapter when
    we learn about dependencies. At that time, we will declare a dependency to install
    Redis and the backend of our Guestbook architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll take a deeper dive into one of the most important
    Helm chart files, `Chart.yaml`. Then, at the end of the chapter, we will update
    this file to provide new settings that align with our Guestbook chart.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Chart.yaml file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Chart.yaml` file, also referred to as the **chart definition**, is used
    for storing different pieces of metadata about a Helm chart. This file is required,
    and if it is not included within a chart, you’ll receive the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Chart.yaml` file was created for you earlier when you ran `helm create`.
    Let’s review this file by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'An output like the following will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The Guestbook Chart.yaml file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.4_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – The Guestbook Chart.yaml file
  prefs: []
  type: TYPE_NORMAL
- en: A `Chart.yaml` file can contain many different fields, some of which are required,
    while most other fields are optional. Let’s take a closer look at each of the
    fields provided in our Guestbook chart’s `Chart.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Description** | **Required?** |'
  prefs: []
  type: TYPE_TB
- en: '| `apiVersion` | The chart API version | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | The name of the Helm chart | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `description` | A brief description of the Helm chart | No |'
  prefs: []
  type: TYPE_TB
- en: '| `type` | The type of Helm chart (either `Application` or `Library`) | No
    |'
  prefs: []
  type: TYPE_TB
- en: '| `version` | The version of the Helm chart, in SemVer format. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `appVersion` | The version of the application that the Helm chart deploys.
    This does not need to be in the SemVer format. | No |'
  prefs: []
  type: TYPE_TB
- en: Table 4.4 – Fields from the generated Chart.yaml file
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from Guestbook’s chart definition, the `apiVersion` value for
    our chart is set to `v2`. Charts with an `apiVersion` value of `v2` are only compatible
    with Helm 3\. The other possible `apiVersion` value is `v1`, but this is a legacy
    version that was geared towards Helm 2\. Charts with an `apiVersion` value of
    `v1` handled dependencies differently and did not support library charts (topics
    that we will discuss in greater detail later in this book). Helm 3 is in fact
    backward-compatible with `apiVersion v1`, but in order to leverage Helm’s latest
    features and to avoid deprecations, new Helm charts should be created using `apiVersion
    v2`.
  prefs: []
  type: TYPE_NORMAL
- en: The type of Helm chart we have scaffolded, according to the `Chart.yaml` file,
    is an `application` chart. A Helm chart can be either an `application` chart or
    a `library` chart. An application chart is used to deploy an application to Kubernetes,
    while a library chart is used to provide reusable helper templates. We will discuss
    library charts in greater detail in [*Chapter 6*](B17979_06.xhtml#_idTextAnchor167),
    *Understanding Helm Templates* . The `type` field in the `Chart.yaml` file is
    optional and defaults to `application`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other fields in our chart definition, `name`, `description`, `version`,
    and `appVersion`, are used to provide metadata that identifies our chart. As an
    example, think back to [*Chapter 3*](B17979_03.xhtml#_idTextAnchor083), *Installing
    Your First App with Helm, w*hen we searched Artifact Hub from the command line
    for WordPress charts. We ran the `helm search hub wordpress` command and saw an
    output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – An example of name, version, appVersion, and description'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.5_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – An example of name, version, appVersion, and description
  prefs: []
  type: TYPE_NORMAL
- en: These fields are acquired from their corresponding fields in `Chart.yaml`. Note
    that you can also see this information on any chart’s Artifact Hub page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the fields included in our scaffolded `Chart.yaml` file, there
    are many other fields used to describe your chart, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Description** | **Required?** |'
  prefs: []
  type: TYPE_TB
- en: '| `kubeVersion` | A range of compatible Kubernetes versions in the SemVer format.
    | No |'
  prefs: []
  type: TYPE_TB
- en: '| `keywords` | A list of keywords used to describe the Helm chart. Keywords
    are also used to provide search terms for the `helm search` command. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `home` | The URL to the Helm chart’s home page. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `sources` | A list of URLs that link to source code used by the Helm chart.
    | No |'
  prefs: []
  type: TYPE_TB
- en: '| `dependencies` | A list of charts that your Helm chart is reliant on. | No
    |'
  prefs: []
  type: TYPE_TB
- en: '| `maintainers` | A list of Helm chart maintainers. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `icon` | An icon in SVG or PNG format used to represent the Helm chart. Displayed
    on the chart’s Artifact Hub page. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `deprecated` | Indicates whether the Helm chart has been deprecated. | No
    |'
  prefs: []
  type: TYPE_TB
- en: '| `annotations` | A list of annotations used to provide custom metadata. |
    No |'
  prefs: []
  type: TYPE_TB
- en: Table 4.5 – Additional Chart.yaml fields
  prefs: []
  type: TYPE_NORMAL
- en: The `kubeVersion` field is used to provide validation against the target Kubernetes
    cluster version. This is useful if your Helm chart uses resources that are only
    compatible with certain versions of Kubernetes. You could set `kubeVersion` to
    a string such as `>= 1.18.0 < 1.20.0`, and Helm will ensure that the chart is
    installed only if Kubernetes is greater than or equal to version `1.18.0` and
    less than (exclusive) `1.20.0`. You can also use the `OR` (`||`) operator, as
    in `>= 1.15.0 <= 1.17.0 || >= 1.18.0 < 1.20.0`.
  prefs: []
  type: TYPE_NORMAL
- en: The `dependencies` field is the most functional of these optional fields. Charts
    added under the `dependencies` field will be installed alongside your Helm chart’s
    resources. We will explore dependencies more in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown earlier with the `name`, `version`, `appVersion`, and `description`
    fields, each of the other `Chart.yaml` properties also have an impact on how a
    Helm chart is displayed in Artifact Hub. Look at the following screenshot, taken
    from Bitnami’s WordPress page in Artifact Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Chart.yaml metadata displayed on Artifact Hub'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.6_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Chart.yaml metadata displayed on Artifact Hub
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compare this to WordPress’s `Chart.yaml` file, retrieved by running `helm
    show values bitnami/wordpress`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – The Bitnami/WordPress Chart.yaml file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.7_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – The Bitnami/WordPress Chart.yaml file
  prefs: []
  type: TYPE_NORMAL
- en: Note how `home`, `sources`, `maintainers`, `dependencies`, and `keywords` from
    `Chart.yaml` are also displayed in Artifact Hub.
  prefs: []
  type: TYPE_NORMAL
- en: It is not required to provide all the `Chart.yaml` fields in full, but it is
    a good thing to do if you are publishing your charts to Artifact Hub or another
    repository that can display chart metadata. Otherwise, feel free to use your discretion
    and provide the fields that you find relevant and necessary. Besides `apiVersion`,
    `name`, and `version`, we recommend providing at least `appVersion` and `description`,
    since these fields provide a good high-level glance at the application your Helm
    chart is packaging. If you are writing a Helm chart for public use, you should
    consider also adding `maintainers`, `home`, and `sources`, and if you are publishing
    to Artifact Hub, you should also include `keywords` so that the chart can be easily
    discovered.
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of the `Chart.yaml` fields, let’s finish this chapter
    by updating our scaffolded chart definition to better suit our Guestbook application.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Guestbook Chart.yaml file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The scaffolded `Chart.yaml` file that `helm create` generated is catered around
    NGINX and not Guestbook as we would desire. Let’s make a couple of quick changes
    to improve the content:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s update the chart description to better describe the application
    our chart will deploy. Update the `description` field of `Chart.yaml` to the following
    (or feel free to provide your own):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s provide a more appropriate `appVersion` setting that better suits
    the version of Guestbook that our chart will deploy. The latest version of Guestbook
    is `v5`, so let’s use this as our `appVersion`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `Chart.yaml` file should now look like this (with the comments removed):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The updated Chart.yaml file for Guestbook'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.8_B17979.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – The updated Chart.yaml file for Guestbook
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to add any of the other `Chart.yaml` fields as well, but these changes,
    at a minimum, will put us in a good state where the `Chart.yaml` metadata accurately
    reflects the application that we will deploy.
  prefs: []
  type: TYPE_NORMAL
- en: We will revisit the `Chart.yaml` field in the next chapter when we add a chart
    dependency for deploying Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we began to peek into the world of Helm chart development by
    introducing the Helm chart and chart definition structure. A Helm chart consists
    of a chart definition (a `Chart.yaml` file) and template files used for generating
    Kubernetes resources. A chart definition is used to provide an identity around
    the chart, including metadata such as the chart name, version, description, and
    the application version that the chart deploys.
  prefs: []
  type: TYPE_NORMAL
- en: We also introduced an application called Guestbook, and we began writing a Helm
    chart that will be used to deploy this application. We ran the `helm create` command
    to scaffold a new Helm chart, and we updated the `Chart.yaml` file to better reflect
    the application that our chart will deploy. In the next chapter, we will return
    to the `Chart.yaml` file when we add a dependency for installing Redis, the backend
    service that our Guestbook frontend relies on.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more about Helm chart structure and `Chart.yaml` files, visit the Helm
    documentation at [https://helm.sh/docs/topics/charts/](https://helm.sh/docs/topics/charts/).
    For more information on the Guestbook application, visit [https://kubernetes.io/docs/tutorials/stateless-application/guestbook/](https://kubernetes.io/docs/tutorials/stateless-application/guestbook/).
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the file format most used in Kubernetes and Helm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the command used to scaffold a new Helm chart?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where is the Helm chart name and version defined?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three required fields in the `Chart.yaml` file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Helm charts can be made up of many different files. Which files are required?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which folder of a Helm chart is used to contain Kubernetes resource templates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which `Chart.yaml` field is used to describe the application version that a
    Helm chart deploys?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
