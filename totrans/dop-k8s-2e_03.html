<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting Started with Kubernetes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">So far, we've learned about the benefits that containers can bring us, but what if we need to scale out our services to meet the needs of our business? </span><span class="koboSpan" id="kobo.2.2">Is there a way to build services across multiple machines without dealing with cumbersome network and storage settings? </span><span class="koboSpan" id="kobo.2.3">Is there an easy way to manage and roll out our microservices with a different service cycle? </span><span class="koboSpan" id="kobo.2.4">This is where Kubernetes comes into play. </span><span class="koboSpan" id="kobo.2.5">In this chapter, we'll look at the following concepts:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">Understanding Kubernetes</span></li>
<li><span class="koboSpan" id="kobo.4.1">Components of Kubernetes</span></li>
<li><span class="koboSpan" id="kobo.5.1">Kubernetes resources and their configuration files</span></li>
<li><span class="koboSpan" id="kobo.6.1">How to launch the kiosk application using Kubernetes</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Understanding Kubernetes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Kubernetes is a platform for managing containers across multiple hosts. </span><span class="koboSpan" id="kobo.2.2">It provides lots of management features for container-oriented applications, such as auto-scaling, rolling deployments, compute resources, and storage management. </span><span class="koboSpan" id="kobo.2.3">Like containers, it's designed to run anywhere, including on bare metal, in our data center, in the public cloud, or even in the hybrid cloud.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Kubernetes fulfills most application container operational needs. </span><span class="koboSpan" id="kobo.3.2">Its highlights include the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.4.1">Container deployment</span></li>
<li><span class="koboSpan" id="kobo.5.1">Persistent storage</span></li>
<li><span class="koboSpan" id="kobo.6.1">Container health monitoring</span></li>
<li><span class="koboSpan" id="kobo.7.1">Compute resource management</span></li>
<li><span class="koboSpan" id="kobo.8.1">Auto-scaling</span></li>
<li><span class="koboSpan" id="kobo.9.1">High availability by cluster federation</span></li>
</ul>
<p><span class="koboSpan" id="kobo.10.1">With Kubernetes, we can manage containerized applications easily. </span><span class="koboSpan" id="kobo.10.2">For example, by creating </span><kbd><span class="koboSpan" id="kobo.11.1">Deployment</span></kbd><span class="koboSpan" id="kobo.12.1">, we can roll out, roll over, or roll back selected containers (</span><a href="acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.13.1">Chapter 9</span></span></a><span class="koboSpan" id="kobo.14.1">, </span><em><span class="koboSpan" id="kobo.15.1">Continuous Delivery</span></em><span class="koboSpan" id="kobo.16.1">) with just a single command. </span><span class="koboSpan" id="kobo.16.2">Containers are considered ephemeral. </span><span><span class="koboSpan" id="kobo.17.1">If we only have one host, we could mount host volumes into containers to preserve data</span></span><span class="koboSpan" id="kobo.18.1">. </span><span class="koboSpan" id="kobo.18.2">In the cluster world, however, a container might be scheduled to run on any host in the cluster. </span><span class="koboSpan" id="kobo.18.3">How do we mount a volume without specifying which host it's run on? </span><span class="koboSpan" id="kobo.18.4">Kubernetes </span><strong><span class="koboSpan" id="kobo.19.1">volumes</span></strong><span class="koboSpan" id="kobo.20.1"> and </span><strong><span class="koboSpan" id="kobo.21.1">persistent volumes</span></strong><span class="koboSpan" id="kobo.22.1"> were introduced to solve this problem (</span><span class="ChapterrefPACKT"><a href="c3083748-0f68-488f-87e0-f8c61deeeb80.xhtml"><span class="koboSpan" id="kobo.23.1">Chapter 4</span></a></span><span class="koboSpan" id="kobo.24.1">, </span><em><span class="koboSpan" id="kobo.25.1">Managing Stateful Workloads</span></em><span class="koboSpan" id="kobo.26.1">).</span></p>
<p><span class="koboSpan" id="kobo.27.1">The lifetime of containers might be short; they may be killed or stopped anytime when they exceed the </span><span><span class="koboSpan" id="kobo.28.1">resource</span></span><span class="koboSpan" id="kobo.29.1"> limit. </span><span class="koboSpan" id="kobo.29.2">How do we ensure our services are always on and are served by a certain number of containers? </span><span class="koboSpan" id="kobo.29.3">Deployment in Kubernetes ensures that a certain number of groups of containers are up and running. </span><span class="koboSpan" id="kobo.29.4">Kubernetes also supports </span><strong><span class="koboSpan" id="kobo.30.1">liveness probes</span></strong><span class="koboSpan" id="kobo.31.1"> to help you define and monitor your application's health. </span><span class="koboSpan" id="kobo.31.2">For better resource management, we can define the maximum capacity for Kubernetes nodes and the resource limit for each group of containers (also known as </span><strong><span class="koboSpan" id="kobo.32.1">pods</span></strong><span class="koboSpan" id="kobo.33.1">). </span><span class="koboSpan" id="kobo.33.2">The Kubernetes scheduler will select a node that fulfills the resource criteria to run the containers. </span><span class="koboSpan" id="kobo.33.3">We'll learn about this further in </span><a href="a7a72300-181d-41ad-a08a-7e42744d365f.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.34.1">Chapter 8</span></span></a><span class="koboSpan" id="kobo.35.1">, </span><em><span class="koboSpan" id="kobo.36.1">Resource Management and Scaling</span></em><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">Kubernetes also provides an optional horizontal pod auto-scaling feature, which we can use to scale a pod horizontally by core or custom metrics. </span><span class="koboSpan" id="kobo.37.3">Kubernetes is also designed to have </span><strong><span class="koboSpan" id="kobo.38.1">high availability</span></strong><span class="koboSpan" id="kobo.39.1"> (</span><strong><span class="koboSpan" id="kobo.40.1">HA</span></strong><span class="koboSpan" id="kobo.41.1">). </span><span class="koboSpan" id="kobo.41.2">We're able to create multiple master nodes and prevent single points of failure.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Kubernetes components</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Kubernetes includes two major players:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.3.1">Masters</span></strong><span class="koboSpan" id="kobo.4.1">: The master is the heart of Kubernetes; it controls and schedules all of the activities in the cluster</span></li>
<li><strong><span class="koboSpan" id="kobo.5.1">Nodes</span></strong><span class="koboSpan" id="kobo.6.1">: Nodes are the workers that run our containers</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Master components</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The master includes the </span><strong><span class="koboSpan" id="kobo.3.1">API Server</span></strong><span class="koboSpan" id="kobo.4.1">, the</span><span class="packt_screen"><span class="koboSpan" id="kobo.5.1"> </span></span><strong><span class="koboSpan" id="kobo.6.1">Controller Manager</span></strong><span class="koboSpan" id="kobo.7.1">, the </span><strong><span class="koboSpan" id="kobo.8.1">Scheduler</span></strong><span class="koboSpan" id="kobo.9.1">, and </span><strong><span class="koboSpan" id="kobo.10.1">etcd</span></strong><span class="koboSpan" id="kobo.11.1">. </span><span class="koboSpan" id="kobo.11.2">All components can run on different hosts with clustering. </span><span class="koboSpan" id="kobo.11.3">However, in this case, we'll make all of the components run on the same node as shown in the following diagram:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1"><img src="assets/a18ae85c-32c3-49cc-9d9f-4ffe4cb8cf54.png" style="width:32.33em;height:22.83em;"/></span></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.13.1">Master components</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">API server (kube-apiserver)</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The API server provides an HTTP/HTTPS server, which provides a RESTful API for the components in the Kubernetes master. </span><span class="koboSpan" id="kobo.2.2">For example, we could use </span><kbd><span class="koboSpan" id="kobo.3.1">GET</span></kbd><span class="koboSpan" id="kobo.4.1"> to get the resource status or </span><kbd><span class="koboSpan" id="kobo.5.1">POST</span></kbd><span class="koboSpan" id="kobo.6.1"> to create a new resource. </span><span class="koboSpan" id="kobo.6.2">We can also watch for updates for resources. </span><span class="koboSpan" id="kobo.6.3">The API server stores the object information into etcd, which is Kubernetes' backend data store.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Controller manager (kube-controller-manager)</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The controller manager is a set of control loops that watch the changes in the API server and ensure the cluster is in the desired state. </span><span class="koboSpan" id="kobo.2.2">For example, the deployment controller ensures </span><span><span class="koboSpan" id="kobo.3.1">that the whole deployment is run on the desired amount of containers</span></span><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">The node controller responds and evicts the pod when the nodes go down. </span><span class="koboSpan" id="kobo.4.3">The endpoint controller is used to create a relationship between services and pods. </span><span class="koboSpan" id="kobo.4.4">The service account and the token controller are used to create a default account and API access tokens.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.5.1">To accommodate different development </span><span><span class="koboSpan" id="kobo.6.1">paces </span></span><span class="koboSpan" id="kobo.7.1">and release cycles from different cloud providers, from Kubernetes version 1.6, cloud provider-specific logic was moved from </span><kbd><span class="koboSpan" id="kobo.8.1">kube-controller-manager</span></kbd><span class="koboSpan" id="kobo.9.1"> to the </span><span><span class="koboSpan" id="kobo.10.1">cloud controller manager (</span><kbd><span class="koboSpan" id="kobo.11.1">cloud-controller-manager</span></kbd><span class="koboSpan" id="kobo.12.1">).</span></span><span class="koboSpan" id="kobo.13.1"> This was promoted to beta in version 1.11.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">etcd</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">etcd is an open source distributed key-value store (</span><a href="https://coreos.com/etcd" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.3.1">https://coreos.com/etcd</span></span></a><span class="koboSpan" id="kobo.4.1">). </span><span class="koboSpan" id="kobo.4.2">Kubernetes stores all of the RESTful API objects here. </span><span class="koboSpan" id="kobo.4.3">etcd is responsible for storing and replicating data.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Scheduler (kube-scheduler)</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The scheduler determines which nodes are suitable candidates for pods to run on. </span><span class="koboSpan" id="kobo.2.2">It </span><span><span class="koboSpan" id="kobo.3.1">uses </span></span><span class="koboSpan" id="kobo.4.1">not only </span><span><span class="koboSpan" id="kobo.5.1">resource capacity and the balance of the resource utilization on the node but also node affinity, taints, and toleration. </span><span class="koboSpan" id="kobo.5.2">For more information, refer to </span><a href="a7a72300-181d-41ad-a08a-7e42744d365f.xhtml"><span class="koboSpan" id="kobo.6.1">Chapter 8</span></a><em><span class="koboSpan" id="kobo.7.1">,</span></em><span class="koboSpan" id="kobo.8.1"> </span><em><span class="koboSpan" id="kobo.9.1">Resource Management and Scaling</span></em></span><span class="koboSpan" id="kobo.10.1">. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Node components</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Node components are provisioned and run on every node, which report the runtime status of the pod to the </span><strong><span class="koboSpan" id="kobo.3.1">master</span></strong><span class="koboSpan" id="kobo.4.1">:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1"><img src="assets/ac50f8a6-f1f5-4154-b21b-1ca694c4ea13.png" style="width:22.58em;height:12.50em;"/></span></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref"><span class="koboSpan" id="kobo.6.1">Node components</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Kubelet</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Kubelet is a major process in the nodes. </span><span class="koboSpan" id="kobo.2.2">It reports node activities back to </span><kbd><span class="koboSpan" id="kobo.3.1">kube-apiserver</span></kbd><span class="koboSpan" id="kobo.4.1"> periodically, including pod health, node health, and liveness probe. </span><span class="koboSpan" id="kobo.4.2">As the preceding diagram shows, it runs containers via container runtimes, such as Docker or rkt.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Proxy (kube-proxy)</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The proxy handles the routing between a pod load balancer (also known as a </span><strong><span class="koboSpan" id="kobo.3.1">service</span></strong><span class="koboSpan" id="kobo.4.1">) and pods. </span><span class="koboSpan" id="kobo.4.2">It also provides routing from external internet to services. </span><span class="koboSpan" id="kobo.4.3">There are three proxy modes: </span><kbd><span class="koboSpan" id="kobo.5.1">userspace</span></kbd><span class="koboSpan" id="kobo.6.1">, </span><kbd><span class="koboSpan" id="kobo.7.1">iptables</span></kbd><span class="koboSpan" id="kobo.8.1">, and </span><kbd><span class="koboSpan" id="kobo.9.1">ipvs</span></kbd><span class="koboSpan" id="kobo.10.1">. </span><span class="koboSpan" id="kobo.10.2">The </span><kbd><span class="koboSpan" id="kobo.11.1">userspace</span></kbd><span class="koboSpan" id="kobo.12.1"> mode creates a large overhead by switching the kernel space and user space. </span><span class="koboSpan" id="kobo.12.2">The </span><kbd><span class="koboSpan" id="kobo.13.1">iptables</span></kbd><span class="koboSpan" id="kobo.14.1"> mode, on the other hand, is the latest default proxy mode. </span><span class="koboSpan" id="kobo.14.2">It changes the </span><kbd><span class="koboSpan" id="kobo.15.1">iptables</span></kbd><span class="koboSpan" id="kobo.16.1"> </span><span><span class="koboSpan" id="kobo.17.1">Network Address Translation</span></span><span class="koboSpan" id="kobo.18.1"> (NAT:</span><span><span class="koboSpan" id="kobo.19.1"> </span></span><a href="https://en.wikipedia.org/wiki/Network_address_translation"><span class="koboSpan" id="kobo.20.1">https://en.wikipedia.org/wiki/Network_address_translation</span></a><span><span class="koboSpan" id="kobo.21.1">) in Linux to achieve routing TCP and UDP packets</span></span><span class="koboSpan" id="kobo.22.1"> across </span><span><span class="koboSpan" id="kobo.23.1">all containers. </span></span><span><strong><span class="koboSpan" id="kobo.24.1">IP Virtual Servers</span></strong><span class="koboSpan" id="kobo.25.1"> (</span></span><span><strong><span class="koboSpan" id="kobo.26.1">IPVS</span></strong><span class="koboSpan" id="kobo.27.1">) was </span><strong><span class="koboSpan" id="kobo.28.1">general available</span></strong><span class="koboSpan" id="kobo.29.1"> (</span><strong><span class="koboSpan" id="kobo.30.1">GA</span></strong><span class="koboSpan" id="kobo.31.1">) in Kubernetes 1.11 and is used to address performance degradations when running 1,000+ services in a cluster. </span><span class="koboSpan" id="kobo.31.2">It runs on a host and acts as a load balancer, forwarding the connection to real servers. </span><span class="koboSpan" id="kobo.31.3">IPVS mode will fall back to </span><kbd><span class="koboSpan" id="kobo.32.1">iptables</span></kbd><span class="koboSpan" id="kobo.33.1"> in some scenarios; please refer to </span></span><a href="https://github.com/kubernetes/kubernetes/tree/master/pkg/proxy/ipvs"><span class="koboSpan" id="kobo.34.1">https://github.com/kubernetes/kubernetes/tree/master/pkg/proxy/ipvs</span></a> <span><span class="koboSpan" id="kobo.35.1">for more detailed information.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Docker</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As described in </span><a href="05e2d0b4-0e70-4480-b5a0-f3860ddb24f2.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.3.1">Chapter 2</span></span></a><span class="koboSpan" id="kobo.4.1">, </span><em><span class="koboSpan" id="kobo.5.1">DevOps with Containers</span></em><span class="koboSpan" id="kobo.6.1">, Docker is a container runtime implementation. </span><span class="koboSpan" id="kobo.6.2">Kubernetes uses Docker as a default container engine, and it also supports other container runtimes, such as rkt (</span><a href="https://coreos.com/rkt/"><span class="koboSpan" id="kobo.7.1">https://coreos.com/rkt/</span></a><span class="koboSpan" id="kobo.8.1">) and runc (</span><a href="https://github.com/opencontainers/runc"><span class="koboSpan" id="kobo.9.1">https://github.com/opencontainers/runc</span></a><span class="koboSpan" id="kobo.10.1">).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The interaction between the Kubernetes master and nodes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As we can see in the following diagram, the client uses </span><strong><span class="koboSpan" id="kobo.3.1">kubectl</span></strong><span class="koboSpan" id="kobo.4.1">, which is a command-line interface, to send requests to the </span><strong><span class="koboSpan" id="kobo.5.1">API Server</span></strong><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">The </span><strong><span class="koboSpan" id="kobo.7.1">API Server</span></strong><span><span class="koboSpan" id="kobo.8.1">, a hub between the master components, will </span></span><span class="koboSpan" id="kobo.9.1">respond to the client requests and push and pull the object information from etcd. </span><span class="koboSpan" id="kobo.9.2">If a new task is created, such as run pods, the scheduler will determine which node should be assigned to do that task. </span><span class="koboSpan" id="kobo.9.3">The </span><strong><span class="koboSpan" id="kobo.10.1">Controller Manager</span></strong><span class="koboSpan" id="kobo.11.1"> monitors the running tasks and responds if any undesired state occurs.</span></p>
<p><span class="koboSpan" id="kobo.12.1">The </span><strong><span class="koboSpan" id="kobo.13.1">API Server</span></strong><span class="koboSpan" id="kobo.14.1"> fetches the logs from pods via the </span><strong><span class="koboSpan" id="kobo.15.1">kubelet</span></strong><span class="koboSpan" id="kobo.16.1">:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.17.1"><img src="assets/61844dcf-b0e1-44f6-966a-ea04715091c4.png" style="width:27.17em;height:17.83em;"/></span></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.18.1">Interaction between master and nodes</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting started with Kubernetes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this section, we'll learn how to set up a single-node cluster. </span><span class="koboSpan" id="kobo.2.2">Then, we'll learn how to interact with Kubernetes via its command-line tool: kubectl. </span><span class="koboSpan" id="kobo.2.3">We'll go through all of the important Kubernetes API objects and their expressions in YAML format, which is the input to kubectl. </span><span class="koboSpan" id="kobo.2.4">We'll then see how kubectl sends requests to the API server to create the desired objects accordingly. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Preparing the environment</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Firstly, kubectl has to be installed. </span><span class="koboSpan" id="kobo.2.2">In major </span><span><span class="koboSpan" id="kobo.3.1">Linux</span></span><span class="koboSpan" id="kobo.4.1"> distributions (such as Ubuntu or CentOS), you can just search for and install the package named </span><kbd><span class="koboSpan" id="kobo.5.1">kubectl</span></kbd><span class="koboSpan" id="kobo.6.1"> via the package manager. </span><span class="koboSpan" id="kobo.6.2">In macOS, we can choose to use Homebrew</span><span><span class="koboSpan" id="kobo.7.1"> </span></span><span><span class="koboSpan" id="kobo.8.1">(</span></span><span class="URLPACKT"><a href="https://brew.sh/" target="_blank"><span class="koboSpan" id="kobo.9.1">https://brew.sh/</span></a><span class="koboSpan" id="kobo.10.1">)</span><span><span class="koboSpan" id="kobo.11.1"> </span></span></span><span class="koboSpan" id="kobo.12.1">to install it. </span><span class="URLPACKT"><span class="koboSpan" id="kobo.13.1">Homebrew is a useful package manager in macOS. </span><span class="koboSpan" id="kobo.13.2">We can easily </span></span><span class="koboSpan" id="kobo.14.1">install </span><span class="URLPACKT"><span class="koboSpan" id="kobo.15.1">Homebrew via the </span><kbd><span class="koboSpan" id="kobo.16.1">/usr/bin/ruby -e "$(curl</span></kbd></span> <kbd><span class="koboSpan" id="kobo.17.1">-</span><span class="URLPACKT"><span class="koboSpan" id="kobo.18.1">fsSL</span><span><span class="koboSpan" id="kobo.19.1"> </span></span><span class="koboSpan" id="kobo.20.1">https://raw.githubusercontent.com/Homebrew/install/master/install)"</span></span></kbd><span class="koboSpan" id="kobo.21.1"> command. </span><span class="koboSpan" id="kobo.21.2">Then, we can run brew install kubernetes-cli to install kubectl via Homebrew.</span></p>
<p><span class="koboSpan" id="kobo.22.1">Let's now start to provision a Kubernetes cluster. </span><span class="koboSpan" id="kobo.22.2">The easiest way to do this is to run minikube (</span><a href="https://github.com/kubernetes/minikube" target="_blank"><span class="koboSpan" id="kobo.23.1">https://github.com/kubernetes/minikube</span></a><span class="koboSpan" id="kobo.24.1">), which is a tool to run Kubernetes on a single-node locally. </span><span class="koboSpan" id="kobo.24.2">It can be run on Windows, Linux, and macOS. </span><span class="koboSpan" id="kobo.24.3">In the following example, we'll run on macOS. </span><span class="koboSpan" id="kobo.24.4">Minikube will launch a VM with Kubernetes installed. </span><span class="koboSpan" id="kobo.24.5">We'll then be able to interact with it via kubectl.</span></p>
<p><span class="koboSpan" id="kobo.25.1">Note that minikube isn't suitable for production or any heavy-load environment. </span><span class="koboSpan" id="kobo.25.2">It has some limitations due to its single node nature. </span><span class="koboSpan" id="kobo.25.3">We'll learn how to run a real cluster in </span><a href="f55d3fa8-e791-4473-83ba-ed8c4f848a90.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.26.1">Chapter 10</span></span></a><span class="koboSpan" id="kobo.27.1">, </span><em><span class="koboSpan" id="kobo.28.1">Kubernetes on AWS</span></em><span class="koboSpan" id="kobo.29.1">,</span><em><span class="koboSpan" id="kobo.30.1"> </span></em><a href="d4de05e3-eb24-4e8e-bfd3-e68819b5e66c.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.31.1">Chapter 11</span></span></a><span class="koboSpan" id="kobo.32.1">, </span><em><span class="koboSpan" id="kobo.33.1">Kubernetes on GCP</span></em><span class="koboSpan" id="kobo.34.1">, and</span><span><span class="koboSpan" id="kobo.35.1"> </span></span><a href="89891610-4ca4-4216-9d76-2613d186421c.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.36.1">Chapter 12</span></span></a><span class="koboSpan" id="kobo.37.1">, </span><em><span class="koboSpan" id="kobo.38.1">Kubernetes on Azure</span></em><span class="koboSpan" id="kobo.39.1">, instead.</span></p>
<p><span class="koboSpan" id="kobo.40.1">Before installing minikube, we have to install some dependencies first. </span><span><span class="koboSpan" id="kobo.41.1">Minikube's official GitHub repository (</span><a href="https://github.com/kubernetes/minikube"><span class="koboSpan" id="kobo.42.1">https://github.com/kubernetes/minikube</span></a><span class="koboSpan" id="kobo.43.1">) lists the dependencies and drivers for the different platforms. </span></span><span class="koboSpan" id="kobo.44.1">In our case, we're using VirtualBox</span><span><span class="koboSpan" id="kobo.45.1"> (</span></span><span class="URLPACKT"><a href="https://www.virtualbox.org/" target="_blank"><span class="koboSpan" id="kobo.46.1">https://www.virtualbox.org/</span></a><span class="koboSpan" id="kobo.47.1">)</span></span><span class="koboSpan" id="kobo.48.1"> as the driver in macOS. </span><span class="koboSpan" id="kobo.48.2">You're free to use other drivers; visit the preceding minikube GitHub link to find more options.</span></p>
<p><span class="koboSpan" id="kobo.49.1">After downloading and installing VirtualBox from its official website, we're ready to go. </span><span class="koboSpan" id="kobo.49.2">We can install minikube via </span><kbd><span class="koboSpan" id="kobo.50.1">brew cask install minikube</span></kbd><span class="koboSpan" id="kobo.51.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.52.1">// install minikube</span><br/><span class="koboSpan" id="kobo.53.1"># brew cask install minikube</span><br/><span class="koboSpan" id="kobo.54.1">==&gt; Tapping caskroom/cask</span><br/><span class="koboSpan" id="kobo.55.1">==&gt; Linking Binary 'minikube-darwin-amd64' to '/usr/local/bin/minikube'.</span><br/><span class="koboSpan" id="kobo.56.1">...</span><br/><span class="koboSpan" id="kobo.57.1">minikube was successfully installed!</span></strong></pre>
<p><span class="koboSpan" id="kobo.58.1">After minikube is installed, we can start the cluster via the </span><kbd><span class="koboSpan" id="kobo.59.1">minikube start</span></kbd><span class="koboSpan" id="kobo.60.1"> command. </span><span><span class="koboSpan" id="kobo.61.1">This will launch a Kubernetes cluster locally. </span><span class="koboSpan" id="kobo.61.2">At the time of writing, the default Kubernetes version that minikube v0.30.0 supports is </span></span><kbd><span class="koboSpan" id="kobo.62.1">v.1.12.0</span></kbd><span><span class="koboSpan" id="kobo.63.1">. </span><span class="koboSpan" id="kobo.63.2">You also can add the </span></span><kbd><span class="koboSpan" id="kobo.64.1">--kubernetes-version</span></kbd><span><span class="koboSpan" id="kobo.65.1"> argument to specify the particular Kubernetes version you'd like to run. </span><span class="koboSpan" id="kobo.65.2">For example, assume we want to run a cluster with the version v1.12.1:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.66.1">// start the cluster (via minikube v0.30.0)</span><br/><span class="koboSpan" id="kobo.67.1"># </span><br/><span class="koboSpan" id="kobo.68.1">Starting local Kubernetes v1.12.1 cluster...</span><br/><span class="koboSpan" id="kobo.69.1">Starting VM...</span><br/><span class="koboSpan" id="kobo.70.1">Getting VM IP address...</span><br/><span class="koboSpan" id="kobo.71.1">Moving files into cluster...</span><br/><span class="koboSpan" id="kobo.72.1">Downloading kubeadm v1.12.1</span><br/><span class="koboSpan" id="kobo.73.1">Downloading kubelet v1.12.1</span><br/><span class="koboSpan" id="kobo.74.1">Finished Downloading kubeadm v1.12.1</span><br/><span class="koboSpan" id="kobo.75.1">Finished Downloading kubelet v1.12.1</span><br/><span class="koboSpan" id="kobo.76.1">Setting up certs...</span><br/><span class="koboSpan" id="kobo.77.1">Connecting to cluster...</span><br/><span class="koboSpan" id="kobo.78.1">Setting up kubeconfig...</span><br/><span class="koboSpan" id="kobo.79.1">Starting cluster components...</span><br/><span class="koboSpan" id="kobo.80.1">Kubectl is now configured to use the cluster.</span><br/><span class="koboSpan" id="kobo.81.1">Loading cached images from config file.</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.82.1">This will then proceed to start a VM named </span><kbd><span class="koboSpan" id="kobo.83.1">minikube</span></kbd><span class="koboSpan" id="kobo.84.1"> in VirtualBox and set up the cluster via </span><kbd><span class="koboSpan" id="kobo.85.1">kubeadm</span></kbd><span class="koboSpan" id="kobo.86.1">, a Kubernetes provisioning tool. </span><span class="koboSpan" id="kobo.86.2">It'll also set up </span><kbd><span class="koboSpan" id="kobo.87.1">kubeconfig</span></kbd><span class="koboSpan" id="kobo.88.1">, which is a configuration file to define the context and authentication settings of the cluster. </span><span class="koboSpan" id="kobo.88.2">With </span><kbd><span class="koboSpan" id="kobo.89.1">kubeconfig</span></kbd><span class="koboSpan" id="kobo.90.1">, we're able to switch to different clusters via the </span><kbd><span class="koboSpan" id="kobo.91.1">kubectl</span></kbd><span class="koboSpan" id="kobo.92.1"> command. </span><span class="koboSpan" id="kobo.92.2">We could use the </span><kbd><span class="koboSpan" id="kobo.93.1">kubectl config view</span></kbd><span class="koboSpan" id="kobo.94.1"> command to see the current settings in </span><kbd><span class="koboSpan" id="kobo.95.1">kubeconfig</span></kbd><span class="koboSpan" id="kobo.96.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.97.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.98.1"># cluster and certificate information</span><br/><span class="koboSpan" id="kobo.99.1">clusters:</span><br/><span class="koboSpan" id="kobo.100.1">- cluster:</span><br/><span class="koboSpan" id="kobo.101.1">    certificate-authority: /Users/chloelee/.minikube/ca.crt</span><br/><span class="koboSpan" id="kobo.102.1">    server: https://192.168.99.100:8443</span><br/><span class="koboSpan" id="kobo.103.1">  name: minikube
</span><br/><span class="koboSpan" id="kobo.104.1"># context is the combination of cluster, user and namespace</span><br/><span class="koboSpan" id="kobo.105.1">contexts:</span><br/><span class="koboSpan" id="kobo.106.1">- context:</span><br/><span class="koboSpan" id="kobo.107.1">   cluster: minikube</span><br/><span class="koboSpan" id="kobo.108.1">   user: minikube</span><br/><span class="koboSpan" id="kobo.109.1">  name: minikube</span><br/><span class="koboSpan" id="kobo.110.1">current-context: minikube</span><br/><span class="koboSpan" id="kobo.111.1">kind: Config</span><br/><span class="koboSpan" id="kobo.112.1">preferences: {}

# user information</span><br/><br/><span class="koboSpan" id="kobo.113.1">users:  </span><br/><span class="koboSpan" id="kobo.114.1">- name: minikube</span><br/><span class="koboSpan" id="kobo.115.1">user:</span><br/><span class="koboSpan" id="kobo.116.1">  client-certificate: /Users/chloelee/.minikube/client.crt</span><br/><span class="koboSpan" id="kobo.117.1">  client-key: /Users/chloelee/.minikube/client.key</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.118.1">Here, we're currently using the </span><kbd><span class="koboSpan" id="kobo.119.1">minikube</span></kbd><span class="koboSpan" id="kobo.120.1"> context. </span><span class="koboSpan" id="kobo.120.2">The context is a combination of the authentication information and the cluster connection information. </span><span class="koboSpan" id="kobo.120.3">You could use </span><kbd><span class="koboSpan" id="kobo.121.1">kubectl config</span></kbd><span class="koboSpan" id="kobo.122.1"> use-context </span><kbd><span class="koboSpan" id="kobo.123.1">$context</span></kbd><span class="koboSpan" id="kobo.124.1"> to forcibly switch the context if you have more than one context.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">kubectl</span></h1>
                </header>
            
            <article>
                
<p><kbd><span class="koboSpan" id="kobo.2.1">kubectl</span></kbd><span class="koboSpan" id="kobo.3.1"> is the command-line tool to manage Kubernetes clusters. </span><span class="koboSpan" id="kobo.3.2">The most general usage of </span><kbd><span class="koboSpan" id="kobo.4.1">kubectl</span></kbd><span class="koboSpan" id="kobo.5.1"> is to check the </span><kbd><span class="koboSpan" id="kobo.6.1">version</span></kbd><span class="koboSpan" id="kobo.7.1"> of the cluster:</span></p>
<pre><strong><span class="koboSpan" id="kobo.8.1">// check Kubernetes version</span><br/><span class="koboSpan" id="kobo.9.1"># kubectl version</span><br/><br/><span class="koboSpan" id="kobo.10.1">Client Version: version.Info{Major:"1", Minor:"12", GitVersion:"v1.12.0", GitCommit:"0ed33881dc4355495f623c6f22e7dd0b7632b7c0", GitTreeState:"clean", BuildDate:"2018-10-01T00:59:42Z", GoVersion:"go1.11", Compiler:"gc", Platform:"darwin/amd64"}</span><br/><span class="koboSpan" id="kobo.11.1">Server Version: version.Info{Major:"1", Minor:"11", GitVersion:"v1.11.3", GitCommit:"a4529464e4629c21224b3d52edfe0ea91b072862", GitTreeState:"clean", BuildDate:"2018-09-09T17:53:03Z", GoVersion:"go1.10.3", Compiler:"gc", Platform:"linux/amd64"}</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.12.1">We then know our server version is upto date, which is the latest at the time of writing—version 1.12.0. </span><span class="koboSpan" id="kobo.12.2">The general syntax of </span><kbd><span class="koboSpan" id="kobo.13.1">kubectl</span></kbd><span class="koboSpan" id="kobo.14.1"> is as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.15.1">kubectl [command] [type] [name] [flags] </span></strong></pre>
<p><kbd><span class="koboSpan" id="kobo.16.1">command</span></kbd><span class="koboSpan" id="kobo.17.1"> indicates the operation you want to perform. </span><span class="koboSpan" id="kobo.17.2">If you type </span><kbd><span class="koboSpan" id="kobo.18.1">kubectl help</span></kbd><span class="koboSpan" id="kobo.19.1"> in Terminal, it'll show the supported commands. </span><kbd><span class="koboSpan" id="kobo.20.1">type</span></kbd><span class="koboSpan" id="kobo.21.1"> means the resource type. </span><span class="koboSpan" id="kobo.21.2">We'll learn about the major resource types in the next section. </span><kbd><span class="koboSpan" id="kobo.22.1">name</span></kbd><span class="koboSpan" id="kobo.23.1"> is how we name our resources. </span><span class="koboSpan" id="kobo.23.2">It's always good practice to have clear and informative names throughout. </span><span class="koboSpan" id="kobo.23.3">For the </span><kbd><span class="koboSpan" id="kobo.24.1">flags</span></kbd><span class="koboSpan" id="kobo.25.1">, if you type </span><kbd><span class="koboSpan" id="kobo.26.1">kubectl options</span></kbd><span class="koboSpan" id="kobo.27.1">, the </span><kbd><span class="koboSpan" id="kobo.28.1">stdout </span></kbd><span class="koboSpan" id="kobo.29.1">will show all of the flags you could pass on.</span></p>
<p><span class="koboSpan" id="kobo.30.1">We can always add </span><kbd><span class="koboSpan" id="kobo.31.1">--help</span></kbd><span class="koboSpan" id="kobo.32.1"> to get more detailed information on specific commands, as in the example:</span></p>
<pre><strong><span class="koboSpan" id="kobo.33.1">// show detailed info for logs command</span><br/><span class="koboSpan" id="kobo.34.1">kubectl logs --help</span><br/><span class="koboSpan" id="kobo.35.1">Print the logs for a container in a pod or specified resource. </span><span class="koboSpan" id="kobo.35.2">If the pod has only one container, the container name is optional.
</span><br/><br/><span class="koboSpan" id="kobo.36.1">Aliases:</span><br/><span class="koboSpan" id="kobo.37.1">logs, log
</span><br/><br/><span class="koboSpan" id="kobo.38.1">Examples:</span><br/><span class="koboSpan" id="kobo.39.1">  # Return snapshot logs from pod nginx with only one container</span><br/><span class="koboSpan" id="kobo.40.1">  kubectl logs nginx</span><br/><br/><span class="koboSpan" id="kobo.41.1">  # Return snapshot logs for the pods defined by label </span></strong><strong><span class="koboSpan" id="kobo.42.1">app=nginx</span><br/><span class="koboSpan" id="kobo.43.1">  kubectl logs -lapp=nginx</span><br/></strong><strong><span class="koboSpan" id="kobo.44.1">
...</span><br/><span class="koboSpan" id="kobo.45.1">Options</span><br/><span class="koboSpan" id="kobo.46.1">...</span></strong></pre>
<p><span class="koboSpan" id="kobo.47.1">We can then get examples and supported options in the </span><kbd><span class="koboSpan" id="kobo.48.1">kubectl logs</span></kbd><span class="koboSpan" id="kobo.49.1"> command.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Kubernetes resources</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Kubernetes objects are the entries in the cluster, which are stored in etcd. </span><span class="koboSpan" id="kobo.2.2">They represent the desired state of your cluster. </span><span class="koboSpan" id="kobo.2.3">When we create an object, we send the request to the API server by kubectl or a RESTful API. </span><span class="koboSpan" id="kobo.2.4">The API server will check whether the request is valid, store the state in etcd, and interact with other master components to ensure the object exists. </span><span class="koboSpan" id="kobo.2.5">Kubernetes uses namespaces to isolate the objects virtually, so we could create different namespaces for different teams, usages, projects, or environments. </span><span class="koboSpan" id="kobo.2.6">Every object has its own name and unique ID. </span><span class="koboSpan" id="kobo.2.7">Kubernetes also supports labels and annotations to let us tag our objects. </span><span class="koboSpan" id="kobo.2.8">Labels in particular can be used to group the objects together.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Kubernetes objects</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The object </span><kbd><span class="koboSpan" id="kobo.3.1">spec</span></kbd><span class="koboSpan" id="kobo.4.1"> describes the desired state of Kubernetes objects. </span><span class="koboSpan" id="kobo.4.2">Most of the time, we write an object </span><kbd><span class="koboSpan" id="kobo.5.1">spec</span></kbd><span class="koboSpan" id="kobo.6.1"> and send it to the API server via </span><kbd><span class="koboSpan" id="kobo.7.1">kubectl</span></kbd><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">Kubernetes will try to fulfill that desired </span><kbd><span class="koboSpan" id="kobo.9.1">state</span></kbd><span class="koboSpan" id="kobo.10.1"> and </span><kbd><span class="koboSpan" id="kobo.11.1">update</span></kbd><span class="koboSpan" id="kobo.12.1"> the object's status.</span></p>
<p><span class="koboSpan" id="kobo.13.1">The object </span><kbd><span class="koboSpan" id="kobo.14.1">spec</span></kbd><span class="koboSpan" id="kobo.15.1"> could be written in YAML (</span><a href="http://www.yaml.org/" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.16.1">http://www.yaml.org/</span></span></a><span class="koboSpan" id="kobo.17.1">) or JSON (</span><a href="http://www.json.org/" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.18.1">http://www.json.org/</span></span></a><span class="koboSpan" id="kobo.19.1">). </span><span class="koboSpan" id="kobo.19.2">YAML is more common in the Kubernetes world. </span><span class="koboSpan" id="kobo.19.3">We'll use YAML to write object </span><kbd><span class="koboSpan" id="kobo.20.1">spec</span></kbd><span class="koboSpan" id="kobo.21.1"> in the rest of this book. </span><span class="koboSpan" id="kobo.21.2">The following code block shows a YAML-formatted spec fragment:</span></p>
<pre><strong><span class="koboSpan" id="kobo.22.1">apiVersion: Kubernetes API version </span><br/><span class="koboSpan" id="kobo.23.1">kind: object type</span><br/><span class="koboSpan" id="kobo.24.1">metadata:</span><br/><span class="koboSpan" id="kobo.25.1">  spec metadata, i.e. </span><span class="koboSpan" id="kobo.25.2">namespace, name, labels and annotations</span><br/><span class="koboSpan" id="kobo.26.1">spec:</span><br/><span class="koboSpan" id="kobo.27.1">  the spec of Kubernetes object</span><br/></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Namespaces</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">Kubernetes namespaces allow us to implement isolation of multiple virtual clusters</span></span><span class="koboSpan" id="kobo.3.1">. </span><span class="koboSpan" id="kobo.3.2">Objects in different namespaces are invisible to each other. </span><span class="koboSpan" id="kobo.3.3">This is useful when different teams or projects share the same cluster. </span><span class="koboSpan" id="kobo.3.4">Most resources come under a namespace (these are known as namespaced resources); however, some generic resources, such as nodes or namespaces themselves, don't belong to any namespace. </span><span class="koboSpan" id="kobo.3.5">Kubernetes has three namespaces:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.4.1">default</span></kbd></li>
<li><kbd><span class="koboSpan" id="kobo.5.1">kube-system</span></kbd></li>
<li><kbd><span class="koboSpan" id="kobo.6.1">kube-public</span></kbd></li>
</ul>
<p><span class="koboSpan" id="kobo.7.1">If we don't explicitly assign a namespace to a namespaced resource, it'll be located in the namespace of the current context. </span><span class="koboSpan" id="kobo.7.2">If we never add a new namespace, a default namespace will be used.</span></p>
<p><span class="koboSpan" id="kobo.8.1">Kube-system namespaces are used by objects created by the Kubernetes system, such as addon, which are the pods or services that implement cluster features, such as dashboard. </span><span class="koboSpan" id="kobo.8.2">Kube-public namespace was introduced in Kubernetes version 1.6, which is used by a beta controller manager (BootstrapSigner: </span><a href="https://kubernetes.io/docs/admin/bootstrap-tokens" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.9.1">https://kubernetes</span></span><span class="URLPACKT"><span class="koboSpan" id="kobo.10.1">.io/docs/admin/bootstrap-tokens</span></span></a><span class="koboSpan" id="kobo.11.1">), putting the signed cluster location information into the </span><kbd><span class="koboSpan" id="kobo.12.1">kube-public</span></kbd><span class="koboSpan" id="kobo.13.1"> namespace. </span><span class="koboSpan" id="kobo.13.2">This information could be viewed by authenticated or unauthenticated users.</span></p>
<p><span class="koboSpan" id="kobo.14.1">In the following sections, all of the namespaced resources </span><span><span><span class="koboSpan" id="kobo.15.1">are</span></span></span><span class="koboSpan" id="kobo.16.1"> located in a default namespace. </span><span class="koboSpan" id="kobo.16.2">Namespaces are also very important for resource management and roles. </span><span class="koboSpan" id="kobo.16.3">We'll provide further information in </span><a href="a7a72300-181d-41ad-a08a-7e42744d365f.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.17.1">Chapter 8</span></span></a><span class="koboSpan" id="kobo.18.1">, </span><em><span><span class="koboSpan" id="kobo.19.1">Resource Management and Scaling</span></span></em><span class="koboSpan" id="kobo.20.1">.</span></p>
<p><span class="koboSpan" id="kobo.21.1">Let's see how to create a namespace. </span><span class="koboSpan" id="kobo.21.2">A namespace is a Kubernetes object. </span><span class="koboSpan" id="kobo.21.3">We can specify the type to be a namespace, just like other objects. </span><span class="koboSpan" id="kobo.21.4">An example of how to create a namespace called</span><span><span class="koboSpan" id="kobo.22.1"> </span></span><kbd><span class="koboSpan" id="kobo.23.1">project1</span></kbd><span class="koboSpan" id="kobo.24.1"> follows:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.25.1">// configuration file of namespace</span><br/><span class="koboSpan" id="kobo.26.1"># cat 3-2-1_ns1.yml</span><br/><span class="koboSpan" id="kobo.27.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.28.1">kind: Namespace</span><br/><span class="koboSpan" id="kobo.29.1">metadata:</span><br/><span class="koboSpan" id="kobo.30.1">  name: project1</span><br/><br/></strong><strong><span class="koboSpan" id="kobo.31.1">// create namespace for project1</span><br/><span class="koboSpan" id="kobo.32.1"># kubectl create -f 3-2-1_ns.yaml</span><br/><span class="koboSpan" id="kobo.33.1">namespace/project1 created
</span><br/><br/></strong><strong><span class="koboSpan" id="kobo.34.1">// list namespace, the abbreviation of namespaces is ns. </span><span class="koboSpan" id="kobo.34.2">We could use `kubectl get ns` to list it as well.</span><br/><span class="koboSpan" id="kobo.35.1"># kubectl get namespaces</span><br/><span class="koboSpan" id="kobo.36.1">NAME          STATUS    AGE</span><br/><span class="koboSpan" id="kobo.37.1">default       Active    1d</span><br/><span class="koboSpan" id="kobo.38.1">kube-public   Active    1d</span><br/><span class="koboSpan" id="kobo.39.1">kube-system   Active    1d</span><br/><span class="koboSpan" id="kobo.40.1">project1      Active    11s</span></strong></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.41.1">Let's now try to start two nginx containers via deployment in</span><span><span class="koboSpan" id="kobo.42.1"> the </span></span><kbd><span class="koboSpan" id="kobo.43.1">project1</span></kbd><span><span class="koboSpan" id="kobo.44.1"> </span></span><span class="koboSpan" id="kobo.45.1">namespace:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.46.1">// run a nginx deployment in project1 ns</span><br/><span class="koboSpan" id="kobo.47.1"># kubectl run nginx --image=nginx:1.12.0 --replicas=2 --port=80 --namespace=project1</span><br/><br/><span class="koboSpan" id="kobo.48.1">deployment.apps/nginx created</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.49.1">When we list pods by</span><span><span class="koboSpan" id="kobo.50.1"> </span></span><kbd><span class="koboSpan" id="kobo.51.1">kubectl get pods</span></kbd><span class="koboSpan" id="kobo.52.1">, we'll see nothing in our cluster. </span><span class="koboSpan" id="kobo.52.2">This is because Kubernetes uses the current context to decide which namespace is current. </span><span class="koboSpan" id="kobo.52.3">If we don't explicitly specify namespaces in the context or the</span><span><span class="koboSpan" id="kobo.53.1"> </span></span><kbd><span class="koboSpan" id="kobo.54.1">kubectl</span></kbd><span><span class="koboSpan" id="kobo.55.1"> </span></span><span class="koboSpan" id="kobo.56.1">command line, the</span><span><span class="koboSpan" id="kobo.57.1"> </span></span><kbd><span class="koboSpan" id="kobo.58.1">default</span></kbd><span><span class="koboSpan" id="kobo.59.1"> </span></span><span class="koboSpan" id="kobo.60.1">namespace will be used:</span></p>
<pre><strong><span class="koboSpan" id="kobo.61.1">// We'll see the Pods if we explicitly specify --namespace
# kubectl get pods --namespace=project1</span><br/><span class="koboSpan" id="kobo.62.1">NAME                  READY STATUS  RESTARTS AGE</span><br/><span class="koboSpan" id="kobo.63.1">nginx-8cdc99758-btgzj 1/1   Running 0        22s</span><br/><span class="koboSpan" id="kobo.64.1">nginx-8cdc99758-xpk58 1/1   Running 0        22s</span></strong></pre>
<div class="packt_tip"><span class="koboSpan" id="kobo.65.1">You could use</span><span><span class="koboSpan" id="kobo.66.1"> </span></span><kbd><span class="koboSpan" id="kobo.67.1">--namespace &lt;namespace_name&gt;</span></kbd><span class="koboSpan" id="kobo.68.1">,</span><span><span class="koboSpan" id="kobo.69.1"> </span></span><kbd><span class="koboSpan" id="kobo.70.1">--namespace=&lt;namespace_name&gt;</span></kbd><span class="koboSpan" id="kobo.71.1">,</span><span><span class="koboSpan" id="kobo.72.1"> </span></span><kbd><span class="koboSpan" id="kobo.73.1">-n &lt;namespace_name&gt;</span></kbd><span><span class="koboSpan" id="kobo.74.1">, </span></span><span class="koboSpan" id="kobo.75.1">or</span><span><span class="koboSpan" id="kobo.76.1"> </span></span><kbd><span class="koboSpan" id="kobo.77.1">-n=&lt;namespace_name&gt;</span></kbd><span><span class="koboSpan" id="kobo.78.1"> </span></span><span class="koboSpan" id="kobo.79.1">to specify the namespace for a command. </span><span class="koboSpan" id="kobo.79.2">To list the resources across namespaces, use</span><span><span class="koboSpan" id="kobo.80.1"> the </span></span><kbd><span class="koboSpan" id="kobo.81.1">--all-namespaces</span></kbd><span><span class="koboSpan" id="kobo.82.1"> </span></span><span class="koboSpan" id="kobo.83.1">parameter.</span></div>
<p><span class="koboSpan" id="kobo.84.1">Another way to do this is to change the current context to point to the desired namespace rather than the </span><kbd><span class="koboSpan" id="kobo.85.1">default</span></kbd><span class="koboSpan" id="kobo.86.1"> namespace.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Name</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Every object in Kubernetes owns its own name that's uniquely identified within the same namespace. </span><span class="koboSpan" id="kobo.2.2">Kubernetes uses object names as part of a resource's URL for the API server, so it has be a combination of lowercase alphanumeric characters and dashes and dots, and it has to be less than 254 characters long. </span><span class="koboSpan" id="kobo.2.3">Besides the object name, Kubernetes also assigns a </span><strong><span class="koboSpan" id="kobo.3.1">Unique ID</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">UID</span></strong><span class="koboSpan" id="kobo.6.1">) to every object to distinguish historical occurrences of similar entities.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Label and selector</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Labels are sets of key/pair values that attach to objects. </span><span class="koboSpan" id="kobo.2.2">They're designed to provide meaningful, identifying information about objects. </span><span class="koboSpan" id="kobo.2.3">Common usages are to indicate the name of the micro-service, the tier, the environment, and the software version. </span><span class="koboSpan" id="kobo.2.4">Users can define meaningful labels that could be used with selectors later. </span><span class="koboSpan" id="kobo.2.5">The syntax of labels in an object </span><kbd><span class="koboSpan" id="kobo.3.1">spec</span></kbd><span class="koboSpan" id="kobo.4.1"> is as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.5.1">labels:</span><br/><span class="koboSpan" id="kobo.6.1">  $key1: $value1</span><br/><span class="koboSpan" id="kobo.7.1">  $key2: $value2</span></strong></pre>
<p><span class="koboSpan" id="kobo.8.1">Along with labels, label selectors are used to filter sets of objects. </span><span class="koboSpan" id="kobo.8.2">Separated by commas, multiple requirements will be joined by the </span><kbd><span class="koboSpan" id="kobo.9.1">AND</span></kbd><span class="koboSpan" id="kobo.10.1"> logical operator. </span><span class="koboSpan" id="kobo.10.2">There are two ways to filter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Equality-based requirements</span></li>
<li><span class="koboSpan" id="kobo.12.1">Set-based requirements</span></li>
</ul>
<p><span class="koboSpan" id="kobo.13.1">Equality-based requirements support the following operators: </span><kbd><span class="koboSpan" id="kobo.14.1">=</span></kbd><span class="koboSpan" id="kobo.15.1">, </span><kbd><span class="koboSpan" id="kobo.16.1">==</span></kbd><span class="koboSpan" id="kobo.17.1">, and </span><kbd><span class="koboSpan" id="kobo.18.1">!=</span></kbd><span class="koboSpan" id="kobo.19.1">. </span><span class="koboSpan" id="kobo.19.2">Take the following diagram as an example: if the selector is </span><kbd><span class="koboSpan" id="kobo.20.1">chapter=2,version!=0.1</span></kbd><span class="koboSpan" id="kobo.21.1">, the result will be </span><strong><span class="koboSpan" id="kobo.22.1">object C</span></strong><span class="koboSpan" id="kobo.23.1">. </span><span class="koboSpan" id="kobo.23.2">If the requirement is </span><kbd><span class="koboSpan" id="kobo.24.1">version=0.1</span></kbd><span class="koboSpan" id="kobo.25.1">, the result will be </span><strong><span class="koboSpan" id="kobo.26.1">object A</span></strong><span class="koboSpan" id="kobo.27.1"> and </span><strong><span class="koboSpan" id="kobo.28.1">object B</span></strong><span class="koboSpan" id="kobo.29.1">:</span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.30.1"><img src="assets/cc386b25-27c1-4c82-b314-e58590b38c19.png" style="width:33.75em;height:14.33em;"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span><span class="koboSpan" id="kobo.31.1">Selector example</span></span></div>
<p><span class="koboSpan" id="kobo.32.1">If we write the requirement in the supported object </span><kbd><span class="koboSpan" id="kobo.33.1">spec</span></kbd><span class="koboSpan" id="kobo.34.1">, it'll be as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.35.1">selector:</span><br/><span class="koboSpan" id="kobo.36.1">  $key1: $value1</span></strong></pre>
<p><span class="koboSpan" id="kobo.37.1">Set-based requirement supports </span><kbd><span class="koboSpan" id="kobo.38.1">in</span></kbd><span class="koboSpan" id="kobo.39.1">, </span><kbd><span class="koboSpan" id="kobo.40.1">notin</span></kbd><span class="koboSpan" id="kobo.41.1">, and </span><kbd><span class="koboSpan" id="kobo.42.1">exists</span></kbd><span class="koboSpan" id="kobo.43.1"> (for </span><kbd><span class="koboSpan" id="kobo.44.1">key</span></kbd><span class="koboSpan" id="kobo.45.1"> only). </span><span class="koboSpan" id="kobo.45.2">For example, if the requirement is </span><kbd><span class="koboSpan" id="kobo.46.1">chapter in (3, 4),version</span></kbd><span class="koboSpan" id="kobo.47.1">, then </span><strong><span class="koboSpan" id="kobo.48.1">object A</span></strong><span class="koboSpan" id="kobo.49.1"> will be returned. </span><span class="koboSpan" id="kobo.49.2">If the requirement is </span><kbd><span class="koboSpan" id="kobo.50.1">version notin (0.2), !author_info</span></kbd><span class="koboSpan" id="kobo.51.1">, the result will be </span><strong><span class="koboSpan" id="kobo.52.1">object A</span></strong><span class="koboSpan" id="kobo.53.1"> and </span><strong><span class="koboSpan" id="kobo.54.1">object B</span></strong><span class="koboSpan" id="kobo.55.1">. </span><span><span class="koboSpan" id="kobo.56.1">The following example shows an object </span><kbd><span class="koboSpan" id="kobo.57.1">spec</span></kbd><span class="koboSpan" id="kobo.58.1"> that uses set-based requirements:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.59.1">selector:</span><br/><span class="koboSpan" id="kobo.60.1">  matchLabels:</span><br/><span class="koboSpan" id="kobo.61.1">    $key1: $value1</span><br/><span class="koboSpan" id="kobo.62.1">  matchExpressions:</span><br/><span class="koboSpan" id="kobo.63.1">  - {key: $key2, operator: In, values: [$value1, $value2]}</span></strong></pre>
<p><span class="koboSpan" id="kobo.64.1">The requirements of </span><kbd><span class="koboSpan" id="kobo.65.1">matchLabels</span></kbd><span class="koboSpan" id="kobo.66.1"> and </span><kbd><span class="koboSpan" id="kobo.67.1">matchExpressions</span></kbd><span class="koboSpan" id="kobo.68.1"> are combined together. </span><span class="koboSpan" id="kobo.68.2">This means that the filtered objects need to be true for both requirements.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Annotation</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Annotation is a set of user-specified key-value pairs, used for specifying non-identifying metadata. </span><span class="koboSpan" id="kobo.2.2">With annotation acts such as normal tagging, for example, a user could add timestamps, commit hashes, or build numbers to an annotation. </span><span class="koboSpan" id="kobo.2.3">Some kubectl commands support the </span><kbd><span class="koboSpan" id="kobo.3.1">--record</span></kbd><span class="koboSpan" id="kobo.4.1"> option to record commands that make changes to the objects. </span><span class="koboSpan" id="kobo.4.2">Another use case of annotation is storing the configuration, such as Kubernetes deployments (</span><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.5.1">https://kubernetes.io/docs/concepts/workloads/controllers/deployment</span></span></a><span class="koboSpan" id="kobo.6.1">) or critical add-on pods (</span><a href="https://coreos.com/kubernetes/docs/latest/deploy-addons.html" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.7.1">https://coreos.com/kubernetes/docs/latest/deploy-addons.html</span></span></a><span class="koboSpan" id="kobo.8.1">). </span><span class="koboSpan" id="kobo.8.2">The syntax of annotations is as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.9.1">annotations:</span><br/><span class="koboSpan" id="kobo.10.1">  $key1: $value1</span><br/><span class="koboSpan" id="kobo.11.1">  $key2: $value2</span></strong></pre>
<div class="packt_infobox"><span class="koboSpan" id="kobo.12.1">Namespace, name, label, and annotation are located in the metadata section of the object </span><kbd><span class="koboSpan" id="kobo.13.1">spec</span></kbd><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">Selector is located in the </span><kbd><span class="koboSpan" id="kobo.15.1">spec</span></kbd><span class="koboSpan" id="kobo.16.1"> section of selector-supported resources, such as pod, service, ReplicaSet, and deployment.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Pods</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A pod is the smallest deployable unit in Kubernetes. </span><span class="koboSpan" id="kobo.2.2">It can contain one or more containers. </span><span class="koboSpan" id="kobo.2.3">Most of the time, we just need one container per pod. </span><span class="koboSpan" id="kobo.2.4">In some special cases, more than one container is included in the same pod, such as sidecar containers (</span><span class="URLPACKT"><a href="http://blog.kubernetes.io/2015/06/the-distributed-system-toolkit-patterns.html" target="_blank"><span class="koboSpan" id="kobo.3.1">http://blog.kubernetes.io/2015/06/the-distributed-system-toolkit-patterns.html</span></a><span class="koboSpan" id="kobo.4.1">)</span></span><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">Containers in the same pod run in a shared context, on the same node, sharing the network namespace and shared volumes. </span><span class="koboSpan" id="kobo.5.3">Pods are also designed as mortal. </span><span class="koboSpan" id="kobo.5.4">When a pod dies for some reason, for example, if it's killed by Kubernetes controller if resources are lacking, it won't recover by itself. </span><span class="koboSpan" id="kobo.5.5">Instead, Kubernetes uses controllers to create and manage the desired state of pods for us.</span></p>
<p><span class="koboSpan" id="kobo.6.1">We can use </span><kbd><span class="koboSpan" id="kobo.7.1">kubectl explain &lt;resource&gt;</span></kbd><span class="koboSpan" id="kobo.8.1"> to get the detailed description of the resource by the command line. </span><span class="koboSpan" id="kobo.8.2">This will show the fields that the resource supports:</span></p>
<pre><strong><span class="koboSpan" id="kobo.9.1">// get detailed info for `pods`</span><br/><span class="koboSpan" id="kobo.10.1"># kubectl explain pods</span><br/><span class="koboSpan" id="kobo.11.1">KIND: Pod</span><br/><span class="koboSpan" id="kobo.12.1">VERSION: v1</span><br/><br/><span class="koboSpan" id="kobo.13.1">DESCRIPTION:</span><br/><span class="koboSpan" id="kobo.14.1">     Pod is a collection of containers that can run on a host. </span><span class="koboSpan" id="kobo.14.2">This resource is</span><br/><span class="koboSpan" id="kobo.15.1">     created by clients and scheduled onto hosts.</span><br/><br/><span class="koboSpan" id="kobo.16.1">FIELDS:</span><br/><span class="koboSpan" id="kobo.17.1">   apiVersion &lt;string&gt;</span><br/><span class="koboSpan" id="kobo.18.1">     APIVersion defines the versioned schema of this representation of an</span><br/><span class="koboSpan" id="kobo.19.1">     object. </span><span class="koboSpan" id="kobo.19.2">Servers should convert recognized schemas to the latest internal</span><br/><span class="koboSpan" id="kobo.20.1">     value, and may reject unrecognized values. </span><span class="koboSpan" id="kobo.20.2">More info:</span><br/><span class="koboSpan" id="kobo.21.1">     https://git.k8s.io/community/contributors/devel/api-conventions.md#resources</span><br/><br/><span class="koboSpan" id="kobo.22.1">   kind &lt;string&gt;</span><br/><span class="koboSpan" id="kobo.23.1">     Kind is a string value representing the REST resource this object</span><br/><span class="koboSpan" id="kobo.24.1">     represents. </span><span class="koboSpan" id="kobo.24.2">Servers may infer this from the endpoint the client submits</span><br/><span class="koboSpan" id="kobo.25.1">     requests to. </span><span class="koboSpan" id="kobo.25.2">Cannot be updated. </span><span class="koboSpan" id="kobo.25.3">In CamelCase. </span><span class="koboSpan" id="kobo.25.4">More info:</span><br/><span class="koboSpan" id="kobo.26.1">     https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds</span><br/><br/><span class="koboSpan" id="kobo.27.1">   metadata &lt;Object&gt;</span><br/><span class="koboSpan" id="kobo.28.1">     Standard object's metadata. </span><span class="koboSpan" id="kobo.28.2">More info:</span><br/><span class="koboSpan" id="kobo.29.1">     https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata</span><br/><br/><span class="koboSpan" id="kobo.30.1">   spec &lt;Object&gt;</span><br/><span class="koboSpan" id="kobo.31.1">     Specification of the desired behavior of the pod. </span><span class="koboSpan" id="kobo.31.2">More info:</span><br/><span class="koboSpan" id="kobo.32.1">     https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status</span><br/><br/><span class="koboSpan" id="kobo.33.1">   status &lt;Object&gt;</span><br/><span class="koboSpan" id="kobo.34.1">     Most recently observed status of the pod. </span><span class="koboSpan" id="kobo.34.2">This data may not be up to date.</span><br/><span class="koboSpan" id="kobo.35.1">     Populated by the system. </span><span class="koboSpan" id="kobo.35.2">Read-only. </span><span class="koboSpan" id="kobo.35.3">More info:</span><br/><span class="koboSpan" id="kobo.36.1">     https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.37.1">In the following example, we'll show how to create two containers in a pod, and demonstrate how they access each other. </span><span class="koboSpan" id="kobo.37.2">Please note that this is neither a meaningful nor a classic sidecar pattern example. </span><span class="koboSpan" id="kobo.37.3">Instead, it's just an example of how we can access other containers within a pod:</span></p>
<pre><strong><span class="koboSpan" id="kobo.38.1">// an example for creating co-located and co-scheduled container by pod</span><br/><span class="koboSpan" id="kobo.39.1"># cat 3-2-1_pod.yaml</span><br/><span class="koboSpan" id="kobo.40.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.41.1">kind: Pod</span><br/><span class="koboSpan" id="kobo.42.1">metadata:</span><br/><span class="koboSpan" id="kobo.43.1">  name: example</span><br/><span class="koboSpan" id="kobo.44.1">spec:</span><br/><span class="koboSpan" id="kobo.45.1">  containers:</span><br/><span class="koboSpan" id="kobo.46.1">  - name: web</span><br/><span class="koboSpan" id="kobo.47.1">    image: nginx</span><br/><span class="koboSpan" id="kobo.48.1">  - name: centos</span><br/><span class="koboSpan" id="kobo.49.1">    image: centos</span><br/><span class="koboSpan" id="kobo.50.1">    command: ["/bin/sh", "-c", "while : ;do curl http://localhost:80/; sleep 10; done"]</span></strong></pre>
<p><span><span><span class="koboSpan" id="kobo.51.1">The following diagram shows the relationship between containers in a</span></span></span> <strong><span class="koboSpan" id="kobo.52.1">Pod</span></strong><span><span><span class="koboSpan" id="kobo.53.1">. </span><span class="koboSpan" id="kobo.53.2">They share the same network namespace:</span></span></span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.54.1"><img src="assets/c5d57b7a-537b-4e2a-8fd6-5b6745261a6d.png" style="width:23.00em;height:11.17em;"/></span></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref"><span class="koboSpan" id="kobo.55.1">Containers inside a pod are visible via localhost</span></div>
<p><span class="koboSpan" id="kobo.56.1">This spec will create two containers, </span><kbd><span class="koboSpan" id="kobo.57.1">web</span></kbd><span class="koboSpan" id="kobo.58.1"> and </span><kbd><span class="koboSpan" id="kobo.59.1">centos</span></kbd><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">Web is an </span><kbd><span class="koboSpan" id="kobo.61.1">nginx</span></kbd><span class="koboSpan" id="kobo.62.1"> container (</span><a href="https://hub.docker.com/_/nginx/" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.63.1">https://hub.docker.com/_/nginx/</span></span></a><span class="koboSpan" id="kobo.64.1">). </span><span><span class="koboSpan" id="kobo.65.1">The container port </span><kbd><span class="koboSpan" id="kobo.66.1">80</span></kbd><span class="koboSpan" id="kobo.67.1"> is exposed by default. </span><span class="koboSpan" id="kobo.67.2">Since </span><kbd><span class="koboSpan" id="kobo.68.1">centos</span></kbd><span class="koboSpan" id="kobo.69.1"> shares the same context as nginx, when using </span><kbd><span class="koboSpan" id="kobo.70.1">curl</span></kbd><span class="koboSpan" id="kobo.71.1"> in </span><kbd><span class="koboSpan" id="kobo.72.1">http://localhost:80/</span></kbd><span class="koboSpan" id="kobo.73.1">, it should be able to access nginx.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">Next, use the </span><kbd><span class="koboSpan" id="kobo.75.1">kubectl create</span></kbd><span class="koboSpan" id="kobo.76.1"> command to launch the pod. </span><span class="koboSpan" id="kobo.76.2">The </span><kbd><span class="koboSpan" id="kobo.77.1">-f</span></kbd><span class="koboSpan" id="kobo.78.1"> argument allows us to feed a configuration file to the </span><kbd><span class="koboSpan" id="kobo.79.1">kubectl</span></kbd><span class="koboSpan" id="kobo.80.1"> command and creates the desired resources specified in the file:</span></p>
<pre><strong><span class="koboSpan" id="kobo.81.1">// create the resource by `kubectl create` - Create a resource by filename or stdin</span><br/><span class="koboSpan" id="kobo.82.1"># kubectl create -f 3-2-1_pod.yaml
pod "example" created  </span></strong></pre>
<div class="packt_tip"><span class="koboSpan" id="kobo.83.1">If we add </span><kbd><span class="koboSpan" id="kobo.84.1">--record=true</span></kbd><span class="koboSpan" id="kobo.85.1"> at the end of the </span><kbd><span class="koboSpan" id="kobo.86.1">kubectl</span></kbd><span class="koboSpan" id="kobo.87.1"> command when we create the resources, Kubernetes will add the latest command while creating or updating this resource. </span><span class="koboSpan" id="kobo.87.2">Therefore, we won't forget which resources are created by which spec.</span></div>
<p><span class="koboSpan" id="kobo.88.1">We can use the </span><kbd><span class="koboSpan" id="kobo.89.1">kubectl get &lt;resource&gt;</span></kbd><span class="koboSpan" id="kobo.90.1"> command to get the current status of the object. </span><span class="koboSpan" id="kobo.90.2">In this case, we use the </span><kbd><span class="koboSpan" id="kobo.91.1">kubectl get pods</span></kbd><span class="koboSpan" id="kobo.92.1"> command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.93.1">// get the current running pods </span><br/><span class="koboSpan" id="kobo.94.1"># kubectl get pods</span><br/><span class="koboSpan" id="kobo.95.1">NAME      READY     STATUS              RESTARTS   AGE</span><br/><span class="koboSpan" id="kobo.96.1">example   0/2       ContainerCreating   0          1s</span></strong></pre>
<div class="packt_infobox"><span class="koboSpan" id="kobo.97.1">Adding </span><kbd><span class="koboSpan" id="kobo.98.1">--namespace=$namespace_name</span></kbd><span class="koboSpan" id="kobo.99.1"> allows us to access the object in different namespaces. </span><span class="koboSpan" id="kobo.99.2">The following is an example of how to check the pods in the </span><kbd><span class="koboSpan" id="kobo.100.1">kube-system</span></kbd><span class="koboSpan" id="kobo.101.1"> namespace, which is used by system-type pods:</span><br/>
<kbd><strong><span class="koboSpan" id="kobo.102.1">// list pods in kube-system namespace</span></strong></kbd><br/>
<kbd><strong><span class="koboSpan" id="kobo.103.1"># kubectl get pods --namespace=kube-system</span></strong></kbd><br/>
<kbd><strong><span class="koboSpan" id="kobo.104.1">NAME                            READY STATUS RESTARTS AGE</span></strong></kbd><br/>
<kbd><strong><span class="koboSpan" id="kobo.105.1">coredns-99b9bb8bd-p2dvw               1/1 Running 0 1m</span></strong></kbd><br/>
<kbd><strong><span class="koboSpan" id="kobo.106.1">etcd-minikube                         1/1 Running 0 47s</span></strong></kbd><br/>
<kbd><strong><span class="koboSpan" id="kobo.107.1">kube-addon-manager-minikube           1/1 Running 0 13s</span></strong></kbd><br/>
<kbd><strong><span class="koboSpan" id="kobo.108.1">kube-apiserver-minikube               1/1 Running 0 38s</span></strong></kbd><br/>
<kbd><strong><span class="koboSpan" id="kobo.109.1">kube-controller-manager-minikube      1/1 Running 0 32s</span></strong></kbd><br/>
<kbd><strong><span class="koboSpan" id="kobo.110.1">kube-proxy-pvww2                      1/1 Running 0 1m</span></strong></kbd><br/>
<kbd><strong><span class="koboSpan" id="kobo.111.1">kube-scheduler-minikube               1/1 Running 0 26s</span></strong></kbd><br/>
<kbd><strong><span class="koboSpan" id="kobo.112.1">kubernetes-dashboard-7db4dc666b-f8b2w 1/1 Running 0 1m</span></strong></kbd><br/>
<kbd><strong><span class="koboSpan" id="kobo.113.1">storage-provisioner                   1/1 Running 0 1m</span></strong></kbd></div>
<p><span><span class="koboSpan" id="kobo.114.1">The status of our example pod is </span></span><kbd><span class="koboSpan" id="kobo.115.1">ContainerCreating</span></kbd><span><span class="koboSpan" id="kobo.116.1">. </span><span class="koboSpan" id="kobo.116.2">In this phase, Kubernetes has accepted the request and is trying to schedule the pod and pull down the image. </span><span class="koboSpan" id="kobo.116.3">Zero containers </span></span><span class="koboSpan" id="kobo.117.1">are </span><span><span class="koboSpan" id="kobo.118.1">currently running. </span></span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.119.1">Most objects have short names, which come in handy when we use </span><kbd><span class="koboSpan" id="kobo.120.1">kubectl get &lt;object&gt;</span></kbd><span class="koboSpan" id="kobo.121.1"> to list their status. </span><span class="koboSpan" id="kobo.121.2">For example, pods could be called </span><kbd><span class="koboSpan" id="kobo.122.1">po</span></kbd><span class="koboSpan" id="kobo.123.1">, services could be called </span><kbd><span class="koboSpan" id="kobo.124.1">svc</span></kbd><span class="koboSpan" id="kobo.125.1">, and deployment could be called </span><kbd><span class="koboSpan" id="kobo.126.1">deploy</span></kbd><span class="koboSpan" id="kobo.127.1">. </span><span class="koboSpan" id="kobo.127.2">Type </span><kbd><span class="koboSpan" id="kobo.128.1">kubectl get</span></kbd><span class="koboSpan" id="kobo.129.1"> to know more. </span><span class="koboSpan" id="kobo.129.2">Alternatively, the </span><span><kbd><span class="koboSpan" id="kobo.130.1">kubectl api-resources</span></kbd><span class="koboSpan" id="kobo.131.1"> command could list all resources with their short names and attributes. </span></span></div>
<p><span class="koboSpan" id="kobo.132.1">After waiting a moment, we could get the status again:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.133.1">// get the current running pods</span><br/><span class="koboSpan" id="kobo.134.1"># kubectl get pods</span><br/><span class="koboSpan" id="kobo.135.1">NAME      READY     STATUS    RESTARTS   AGE</span><br/><span class="koboSpan" id="kobo.136.1">example   2/2       Running   0          3s</span></strong></pre>
<p><span class="koboSpan" id="kobo.137.1">We can see that two containers are currently running. </span><span class="koboSpan" id="kobo.137.2">The uptime is three seconds. </span><span class="koboSpan" id="kobo.137.3">Using </span><kbd><span class="koboSpan" id="kobo.138.1">kubectl logs &lt;pod_name&gt; -c &lt;container_name&gt;</span></kbd><span class="koboSpan" id="kobo.139.1"> gets </span><kbd><span class="koboSpan" id="kobo.140.1">stdout</span></kbd><span class="koboSpan" id="kobo.141.1"> for the container, similar to </span><kbd><span class="koboSpan" id="kobo.142.1">docker logs &lt;container_name&gt;</span></kbd><span class="koboSpan" id="kobo.143.1">:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.144.1">// get stdout for centos</span><br/><span class="koboSpan" id="kobo.145.1"># kubectl logs example -c centos</span><br/><span class="koboSpan" id="kobo.146.1">&lt;!DOCTYPE html&gt;</span><br/><span class="koboSpan" id="kobo.147.1">&lt;html&gt;</span><br/><span class="koboSpan" id="kobo.148.1">&lt;head&gt;</span><br/><span class="koboSpan" id="kobo.149.1">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br/><span class="koboSpan" id="kobo.150.1">...</span></strong></pre>
<p><kbd><span class="koboSpan" id="kobo.151.1">centos</span></kbd><span class="koboSpan" id="kobo.152.1"> in the pod shares the same networking with nginx via localhost. </span><span class="koboSpan" id="kobo.152.2">Kubernetes creates a network container along with the pod. </span><span class="koboSpan" id="kobo.152.3">One of the functions in the network container is to forward the traffic between containers within a pod. </span><span class="koboSpan" id="kobo.152.4">We'll learn more about this in </span><a href="fc67e008-b601-45a6-8297-d2fa28360b1f.xhtml"><span class="koboSpan" id="kobo.153.1">Chapter 6</span></a><span class="koboSpan" id="kobo.154.1">, </span><span><em><span class="koboSpan" id="kobo.155.1">Kubernetes Network</span></em><span class="koboSpan" id="kobo.156.1">.</span></span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.157.1">If we specify labels in the pod spec, we could use the </span><kbd><span class="koboSpan" id="kobo.158.1">kubectl get pods -l &lt;requirement&gt;</span></kbd><span class="koboSpan" id="kobo.159.1"> command to get the pods that satisfy the requirements, for example, </span><kbd><span class="koboSpan" id="kobo.160.1">kubectl get pods -l 'tier in (frontend, backend)'</span></kbd><span class="koboSpan" id="kobo.161.1">. </span><span class="koboSpan" id="kobo.161.2">Additionally, if we use </span><kbd><span class="koboSpan" id="kobo.162.1">kubectl pods -o wide</span></kbd><span class="koboSpan" id="kobo.163.1">, this will list which pods are running on which nodes.</span></div>
<p><span class="koboSpan" id="kobo.164.1">We could use </span><kbd><span class="koboSpan" id="kobo.165.1">kubectl describe &lt;resource&gt; &lt;resource_name&gt;</span></kbd><span class="koboSpan" id="kobo.166.1"> to get detailed information about a resource:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.167.1">// get detailed information for a pod</span><br/><span class="koboSpan" id="kobo.168.1"># kubectl describe pods example
Name:              example</span><br/><span class="koboSpan" id="kobo.169.1">Namespace:         default</span><br/><span class="koboSpan" id="kobo.170.1">Priority:          0</span><br/><span class="koboSpan" id="kobo.171.1">PriorityClassName: &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.172.1">Node:              minikube/10.0.2.15</span><br/><span class="koboSpan" id="kobo.173.1">Start Time:        Sun, 07 Oct 2018 15:15:36 -0400</span><br/><span class="koboSpan" id="kobo.174.1">Labels:            &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.175.1">Annotations:       &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.176.1">Status:            Running</span><br/><span class="koboSpan" id="kobo.177.1">IP:                172.17.0.4</span><br/><span class="koboSpan" id="kobo.178.1">Containers:        ...</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.179.1">At this point, we know which node this pod is running on. </span><span class="koboSpan" id="kobo.179.2">In </span><kbd><span class="koboSpan" id="kobo.180.1">minikube</span></kbd><span class="koboSpan" id="kobo.181.1">, we only get a single node so it won't make any difference. </span><span class="koboSpan" id="kobo.181.2">In the real cluster environment, knowing </span><span><span class="koboSpan" id="kobo.182.1">which node the pod is running on</span></span><span class="koboSpan" id="kobo.183.1"> is useful for troubleshooting. </span><span class="koboSpan" id="kobo.183.2">We haven't associated any labels, annotations, or controllers for it:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.184.1">  web:</span></strong><br/><strong><span class="koboSpan" id="kobo.185.1">    Container ID: docker://d8284e14942cbe0b8a91f78afc132e09c0b522e8a311e44f6a9a60ac2ca7103a</span></strong><br/><strong><span class="koboSpan" id="kobo.186.1">    Image: nginx</span></strong><br/><strong><span class="koboSpan" id="kobo.187.1">    Image ID: docker-pullable://nginx@sha256:9ad0746d8f2ea6df3a17ba89eca40b48c47066dfab55a75e08e2b70fc80d929e</span></strong><br/><strong><span class="koboSpan" id="kobo.188.1">    Port: &lt;none&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.189.1">    Host Port: &lt;none&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.190.1">    State: Running</span></strong><br/><strong><span class="koboSpan" id="kobo.191.1">      Started: Sun, 07 Oct 2018 15:15:50 -0400</span></strong><br/><strong><span class="koboSpan" id="kobo.192.1">    Ready: True</span></strong><br/><strong><span class="koboSpan" id="kobo.193.1">    Restart Count: 0</span></strong><br/><strong><span class="koboSpan" id="kobo.194.1">    Environment: &lt;none&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.195.1">    Mounts:</span></strong><br/><strong><span class="koboSpan" id="kobo.196.1">      /var/run/secrets/kubernetes.io/serviceaccount from default-token-bm6vn (ro)</span></strong></pre>
<p><span class="koboSpan" id="kobo.197.1">In the containers section, we'll see there are two containers included in this pod. </span><span class="koboSpan" id="kobo.197.2">We can see their states, source images, port mappings, and restart count:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.198.1">Conditions:</span></strong><br/><strong><span class="koboSpan" id="kobo.199.1">  Type Status</span></strong><br/><strong><span class="koboSpan" id="kobo.200.1">  Initialized True</span></strong><br/><strong><span class="koboSpan" id="kobo.201.1">  Ready True</span></strong><br/><strong><span class="koboSpan" id="kobo.202.1">  ContainersReady True</span></strong><br/><strong><span class="koboSpan" id="kobo.203.1">  PodScheduled True</span></strong></pre>
<p><span class="koboSpan" id="kobo.204.1">A pod has </span><kbd><span class="koboSpan" id="kobo.205.1">PodStatus</span></kbd><span class="koboSpan" id="kobo.206.1">, which includes a map of array representations as </span><kbd><span class="koboSpan" id="kobo.207.1">PodConditions</span></kbd><span class="koboSpan" id="kobo.208.1">. </span><span class="koboSpan" id="kobo.208.2">The possible types of </span><kbd><span class="koboSpan" id="kobo.209.1">PodConditions</span></kbd><span class="koboSpan" id="kobo.210.1"> are </span><kbd><span class="koboSpan" id="kobo.211.1">PodScheduled</span></kbd><span class="koboSpan" id="kobo.212.1">, </span><kbd><span class="koboSpan" id="kobo.213.1">Ready</span></kbd><span class="koboSpan" id="kobo.214.1">, </span><kbd><span class="koboSpan" id="kobo.215.1">Initialized</span></kbd><span class="koboSpan" id="kobo.216.1">, </span><kbd><span class="koboSpan" id="kobo.217.1">Unschedulable</span></kbd><span class="koboSpan" id="kobo.218.1">, and </span><kbd><span class="koboSpan" id="kobo.219.1">ContainersReady</span></kbd><span class="koboSpan" id="kobo.220.1">. </span><span class="koboSpan" id="kobo.220.2">The value will be </span><kbd><span class="koboSpan" id="kobo.221.1">true</span></kbd><span class="koboSpan" id="kobo.222.1">, </span><kbd><span class="koboSpan" id="kobo.223.1">false</span></kbd><span class="koboSpan" id="kobo.224.1">, or unknown. </span><span class="koboSpan" id="kobo.224.2">If the pod isn't created accordingly, </span><kbd><span class="koboSpan" id="kobo.225.1">PodStatus</span></kbd><span class="koboSpan" id="kobo.226.1"> will give us a brief overview of which part failed. </span><span class="koboSpan" id="kobo.226.2">In the preceding example, we launched the pod successfully in each phase without any errors:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.227.1">Volumes:</span></strong><br/><strong><span class="koboSpan" id="kobo.228.1">  default-token-bm6vn:</span></strong><br/><strong><span class="koboSpan" id="kobo.229.1">    Type: Secret (a volume populated by a Secret)</span></strong><br/><strong><span class="koboSpan" id="kobo.230.1">    SecretName: default-token-bm6vn</span></strong><br/><strong><span class="koboSpan" id="kobo.231.1">    Optional: false</span></strong></pre>
<p><span class="koboSpan" id="kobo.232.1">A pod is associated with a service account that provides an identity for processes that are running the pod. </span><span class="koboSpan" id="kobo.232.2">It's controlled by service account and a token controller in the API Server.</span></p>
<p><span class="koboSpan" id="kobo.233.1">It'll mount a read-only volume to each container under </span><kbd><span class="koboSpan" id="kobo.234.1">/var/run/secrets/kubernetes.io/serviceaccount</span></kbd><span class="koboSpan" id="kobo.235.1"> in a pod that contains a token for API access. </span><span class="koboSpan" id="kobo.235.2">Kubernetes creates a default service account. </span><span class="koboSpan" id="kobo.235.3">We can use the </span><kbd><span class="koboSpan" id="kobo.236.1">kubectl get serviceaccounts</span></kbd><span class="koboSpan" id="kobo.237.1"> command to list the service accounts:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.238.1">QoS Class: BestEffort</span></strong><br/><strong><span class="koboSpan" id="kobo.239.1">Node-Selectors: &lt;none&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.240.1">Tolerations: node.kubernetes.io/not-ready:NoExecute for 300s</span></strong><br/><strong><span class="koboSpan" id="kobo.241.1">             node.kubernetes.io/unreachable:NoExecute for 300s</span></strong></pre>
<p><span class="koboSpan" id="kobo.242.1">We don't assign any selectors to this pod yet. </span><span class="koboSpan" id="kobo.242.2">Toleration is used to restrict how many pods a node can use. </span><span class="koboSpan" id="kobo.242.3">We'll learn more about this in </span><a href="a7a72300-181d-41ad-a08a-7e42744d365f.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.243.1">Chapter 8</span></span></a><span class="koboSpan" id="kobo.244.1">, </span><em><span><span class="koboSpan" id="kobo.245.1">Resource Management and Scaling</span></span></em><span class="koboSpan" id="kobo.246.1">:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.247.1">Events:</span></strong><br/><strong><span class="koboSpan" id="kobo.248.1"> Type Reason Age From Message</span></strong><br/><strong><span class="koboSpan" id="kobo.249.1"> ---- ------ ---- ---- -------</span></strong><br/><strong><span class="koboSpan" id="kobo.250.1"> Normal Scheduled 2m22s default-scheduler Successfully assigned default/example to minikube</span></strong><br/><strong><span class="koboSpan" id="kobo.251.1"> Normal Pulling 2m21s kubelet, minikube pulling image "nginx"</span></strong><br/><strong><span class="koboSpan" id="kobo.252.1"> Normal Pulled 2m8s kubelet, minikube Successfully pulled image "nginx"</span></strong><br/><strong><span class="koboSpan" id="kobo.253.1"> Normal Created 2m8s kubelet, minikube Created container</span></strong><br/><strong><span class="koboSpan" id="kobo.254.1"> Normal Started 2m8s kubelet, minikube Started container</span></strong><br/><strong><span class="koboSpan" id="kobo.255.1"> Normal Pulling 2m8s kubelet, minikube pulling image "centos"</span></strong><br/><strong><span class="koboSpan" id="kobo.256.1"> Normal Pulled 93s kubelet, minikube Successfully pulled image "centos"</span></strong><br/><strong><span class="koboSpan" id="kobo.257.1"> Normal Created 92s kubelet, minikube Created container</span></strong><br/><strong><span class="koboSpan" id="kobo.258.1"> Normal Started 92s kubelet, minikube Started container</span></strong></pre>
<p><span class="koboSpan" id="kobo.259.1">By seeing the events, we can identify the steps required for Kubernetes to run a node. </span><span class="koboSpan" id="kobo.259.2">First, the scheduler assigns the task to a node, which here </span><span><span class="koboSpan" id="kobo.260.1">is </span></span><span class="koboSpan" id="kobo.261.1">called </span><kbd><span class="koboSpan" id="kobo.262.1">minikube</span></kbd><span class="koboSpan" id="kobo.263.1">. </span><span class="koboSpan" id="kobo.263.2">Then, kubelet starts pulling the first image and creates a container accordingly. </span><span class="koboSpan" id="kobo.263.3">After that, kubelet pulls down the second container and </span><span><span><span class="koboSpan" id="kobo.264.1">starts the container</span></span></span><span class="koboSpan" id="kobo.265.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">ReplicaSet</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A pod isn't self-healing. </span><span class="koboSpan" id="kobo.2.2">When a pod encounters failure, it won't recover on its own. </span><span class="koboSpan" id="kobo.2.3">This is where </span><strong><span class="koboSpan" id="kobo.3.1">ReplicaSet</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">RS</span></strong><span class="koboSpan" id="kobo.6.1">) comes into play. </span><span class="koboSpan" id="kobo.6.2">ReplicaSet ensures that the specified number of replica pods are always up and running in the cluster. </span><span class="koboSpan" id="kobo.6.3">If a pod crashes for any reason, ReplicaSet will send a request to spin up a new pod.</span></p>
<div class="packt_infobox"><span><span class="koboSpan" id="kobo.7.1">ReplicaSet is similar to </span><strong><span class="koboSpan" id="kobo.8.1">ReplicationController</span></strong><span class="koboSpan" id="kobo.9.1"> (</span><strong><span class="koboSpan" id="kobo.10.1">RC</span></strong><span class="koboSpan" id="kobo.11.1">), which was used in older versions of Kubernetes. </span><span class="koboSpan" id="kobo.11.2">Unlike ReplicaSet, which uses set-based selector requirement, ReplicationController used equality-based selector requirements. It has now been completely replaced by ReplicaSet.</span></span></div>
<p><span class="koboSpan" id="kobo.12.1">Let's see how ReplicaSet works:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.13.1"><img src="assets/040fd899-1e2e-4a91-bef9-8cfb5eb08a1e.png" style="width:30.92em;height:19.00em;"/></span></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref"><span class="koboSpan" id="kobo.14.1">ReplicaSet with a desired count of 2</span></div>
<p><span class="koboSpan" id="kobo.15.1">Let's say that we want to create a </span><kbd><span class="koboSpan" id="kobo.16.1">ReplicaSet</span></kbd><span class="koboSpan" id="kobo.17.1"> object, with a desired count of 2. </span><span class="koboSpan" id="kobo.17.2">This means that we'll always have two pods in the service. </span><span class="koboSpan" id="kobo.17.3">Before we write the spec for ReplicaSet, we'll have to decide on the pod template first. </span><span class="koboSpan" id="kobo.17.4">This is similar to the spec of a pod. </span><span class="koboSpan" id="kobo.17.5">In a ReplicaSet, labels </span><span><span class="koboSpan" id="kobo.18.1">are require</span></span><span><span class="koboSpan" id="kobo.19.1">d </span></span><span><span class="koboSpan" id="kobo.20.1">in the metadata section</span></span><span><span class="koboSpan" id="kobo.21.1">. </span><span class="koboSpan" id="kobo.21.2">A </span></span><span><span class="koboSpan" id="kobo.22.1">ReplicaSet</span></span> <span><span class="koboSpan" id="kobo.23.1">uses a pod selector to</span></span><span class="koboSpan" id="kobo.24.1"> select </span><span><span class="koboSpan" id="kobo.25.1">which</span></span><span class="koboSpan" id="kobo.26.1"> pods </span><span><span class="koboSpan" id="kobo.27.1">it manages. </span><span class="koboSpan" id="kobo.27.2">Labels allow </span></span><span><span class="koboSpan" id="kobo.28.1">ReplicaSet</span></span> <span><span class="koboSpan" id="kobo.29.1">to distinguish whether all of the pods matching the selectors are all on track.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">In this example, we'll create two pods, each with the labels </span><kbd><span class="koboSpan" id="kobo.31.1">project</span></kbd><span class="koboSpan" id="kobo.32.1">, </span><kbd><span class="koboSpan" id="kobo.33.1">service</span></kbd><span class="koboSpan" id="kobo.34.1">, and </span><kbd><span class="koboSpan" id="kobo.35.1">version</span></kbd><span class="koboSpan" id="kobo.36.1">, as shown in the preceding diagram:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.37.1">// an example for RS spec</span><br/><span class="koboSpan" id="kobo.38.1"># cat 3-2-2_rs.yaml</span><br/><span class="koboSpan" id="kobo.39.1">apiVersion: apps/v1</span><br/><span class="koboSpan" id="kobo.40.1">kind: ReplicaSet</span><br/><span class="koboSpan" id="kobo.41.1">metadata:</span><br/><span class="koboSpan" id="kobo.42.1">  name: nginx</span><br/><span class="koboSpan" id="kobo.43.1">spec:</span><br/><span class="koboSpan" id="kobo.44.1">  replicas: 2</span><br/><span class="koboSpan" id="kobo.45.1">  selector:</span><br/><span class="koboSpan" id="kobo.46.1">    matchLabels:</span><br/><span class="koboSpan" id="kobo.47.1">      project: chapter3</span><br/><span class="koboSpan" id="kobo.48.1">    matchExpressions:</span><br/><span class="koboSpan" id="kobo.49.1">      - {key: version, operator: In, values: ["0.1", "0.2"]}</span><br/><span class="koboSpan" id="kobo.50.1">  template:</span><br/><span class="koboSpan" id="kobo.51.1">    metadata:</span><br/><span class="koboSpan" id="kobo.52.1">      name: nginx</span><br/><span class="koboSpan" id="kobo.53.1">      labels:</span><br/><span class="koboSpan" id="kobo.54.1">        project: chapter3</span><br/><span class="koboSpan" id="kobo.55.1">        service: web</span><br/><span class="koboSpan" id="kobo.56.1">        version: "0.1"</span><br/><span class="koboSpan" id="kobo.57.1">    spec:</span><br/><span class="koboSpan" id="kobo.58.1">      containers:</span><br/><span class="koboSpan" id="kobo.59.1">      - name: nginx</span><br/><span class="koboSpan" id="kobo.60.1">        image: nginx</span><br/><span class="koboSpan" id="kobo.61.1">        ports:</span><br/><span class="koboSpan" id="kobo.62.1">        - containerPort: 80</span><br/><br/><span class="koboSpan" id="kobo.63.1">// create the RS</span><br/><span class="koboSpan" id="kobo.64.1"># kubectl create -f 3-2-2_rs.yaml</span><br/><span class="koboSpan" id="kobo.65.1">replicaset.apps/nginx created</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.66.1">Then, we can use </span><kbd><span class="koboSpan" id="kobo.67.1">kubectl</span></kbd><span class="koboSpan" id="kobo.68.1"> to get the current RS status:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.69.1">// get current RSs</span><br/><span class="koboSpan" id="kobo.70.1"># kubectl get rs</span><br/><span class="koboSpan" id="kobo.71.1">NAME  DESIRED CURRENT READY AGE</span><br/><span class="koboSpan" id="kobo.72.1">nginx 2       2       2     29s</span></strong></pre>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.73.1">This shows that we desire two pods, we currently have two pods, and two pods are ready. </span><span class="koboSpan" id="kobo.73.2">How many pods do we have now? </span><span class="koboSpan" id="kobo.73.3">Let's check it out via the </span><kbd><span class="koboSpan" id="kobo.74.1">kubectl</span></kbd><span class="koboSpan" id="kobo.75.1"> command:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.76.1">// get current running pod</span><br/><span class="koboSpan" id="kobo.77.1"># kubectl get pods</span><br/><span class="koboSpan" id="kobo.78.1">NAME          READY     STATUS    RESTARTS   AGE</span><br/><span class="koboSpan" id="kobo.79.1">nginx-l5mdn   1/1       Running   0          11s</span><br/><span class="koboSpan" id="kobo.80.1">nginx-pjjw9   1/1       Running   0          11s  </span></strong></pre>
<p><span class="koboSpan" id="kobo.81.1">This shows we have two pods up and running. </span><span class="koboSpan" id="kobo.81.2">As described previously, ReplicaSet manages all of the pods matching the selector. </span><span class="koboSpan" id="kobo.81.3">If we create a pod with the same label manually, in theory, it should match the pod selector of the RS we just created. </span><span class="koboSpan" id="kobo.81.4">Let's try it out:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.82.1">// manually create a pod with same labels</span><br/><span class="koboSpan" id="kobo.83.1"># cat 3-2-2_rs_self_created_pod.yaml</span><br/><span class="koboSpan" id="kobo.84.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.85.1">kind: Pod</span><br/><span class="koboSpan" id="kobo.86.1">metadata:</span><br/><span class="koboSpan" id="kobo.87.1">  name: our-nginx</span><br/><span class="koboSpan" id="kobo.88.1">  labels:</span><br/><span class="koboSpan" id="kobo.89.1">   project: chapter3</span><br/><span class="koboSpan" id="kobo.90.1">   service: web</span><br/><span class="koboSpan" id="kobo.91.1">   version: "0.1"</span><br/><span class="koboSpan" id="kobo.92.1">spec:</span><br/><span class="koboSpan" id="kobo.93.1">  containers:</span><br/><span class="koboSpan" id="kobo.94.1">  - name: nginx</span><br/><span class="koboSpan" id="kobo.95.1">    image: nginx</span><br/><span class="koboSpan" id="kobo.96.1">    ports:</span><br/><span class="koboSpan" id="kobo.97.1">    - containerPort: 80</span><br/><span class="koboSpan" id="kobo.98.1">// create a pod with same labels manually</span><br/><span class="koboSpan" id="kobo.99.1"># kubectl create -f 3-2-2_rs_self_created_pod.yaml </span><br/><span class="koboSpan" id="kobo.100.1">pod "our-nginx" created  </span></strong></pre>
<p><span class="koboSpan" id="kobo.101.1">Let's see if it's up and running:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.102.1">// get pod status</span><br/><span class="koboSpan" id="kobo.103.1"># kubectl get pods</span><br/><span class="koboSpan" id="kobo.104.1">NAME          READY     STATUS        RESTARTS   AGE</span><br/><span class="koboSpan" id="kobo.105.1">nginx-l5mdn   1/1       Running       0          4m</span><br/><span class="koboSpan" id="kobo.106.1">nginx-pjjw9   1/1       Running       0          4m</span><br/><span class="koboSpan" id="kobo.107.1">our-nginx     0/1       Terminating   0          4s  </span></strong></pre>
<p><span class="koboSpan" id="kobo.108.1">It's scheduled, and ReplicaSet catches it. </span><span class="koboSpan" id="kobo.108.2">The amount of pods becomes three, which exceeds our desired count. </span><span class="koboSpan" id="kobo.108.3">The pod is eventually killed:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.109.1">// get pod status</span><br/><span class="koboSpan" id="kobo.110.1"># kubectl get pods</span><br/><span class="koboSpan" id="kobo.111.1">NAME          READY     STATUS    RESTARTS   AGE</span><br/><span class="koboSpan" id="kobo.112.1">nginx-l5mdn   1/1       Running   0          5m</span><br/><span class="koboSpan" id="kobo.113.1">nginx-pjjw9   1/1       Running   0          5m  </span></strong></pre>
<p><span><span><span class="koboSpan" id="kobo.114.1">The following diagram is an illustration of how our self-created pod was evicted. </span><span class="koboSpan" id="kobo.114.2">The labels are matched with ReplicaSet, but the desired count is 2. </span><span class="koboSpan" id="kobo.114.3">Therefore, the additional pod was evicted:</span></span></span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.115.1"><img src="assets/892b39bb-e749-4a51-a070-90a0530ab9eb.png" style="width:46.00em;height:19.33em;"/></span></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref"><span class="koboSpan" id="kobo.116.1">ReplicaSet makes sure pods are in the desired state</span></div>
<p><span class="koboSpan" id="kobo.117.1">If we want to scale on demand, we could simply use </span><kbd><span class="koboSpan" id="kobo.118.1">kubectl edit &lt;resource&gt; &lt;resource_name&gt;</span></kbd><span class="koboSpan" id="kobo.119.1"> to update the spec. </span><span class="koboSpan" id="kobo.119.2">Here, we'll change the replica count from </span><kbd><span class="koboSpan" id="kobo.120.1">2</span></kbd><span class="koboSpan" id="kobo.121.1"> to </span><kbd><span class="koboSpan" id="kobo.122.1">5</span></kbd><span class="koboSpan" id="kobo.123.1">:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.124.1">// change replica count from 2 to 5, default system editor will pop out. </span><br/><span class="koboSpan" id="kobo.125.1">Change `replicas` number</span><br/><span class="koboSpan" id="kobo.126.1"># kubectl edit rs nginx</span><br/><span class="koboSpan" id="kobo.127.1">replicaset.extensions/nginx edited</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.128.1">Let's check the RS information:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.129.1">// get RS information</span><br/><span class="koboSpan" id="kobo.130.1"># kubectl get rs</span><br/><span class="koboSpan" id="kobo.131.1">NAME      DESIRED   CURRENT   READY     AGE</span><br/><span class="koboSpan" id="kobo.132.1">nginx     5         5         5         5m      </span></strong></pre>
<p><span class="koboSpan" id="kobo.133.1">We now have five pods. </span><span class="koboSpan" id="kobo.133.2">Let's check how RS works:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.134.1">// describe RS resource `nginx`</span><br/><span class="koboSpan" id="kobo.135.1"># kubectl describe rs nginx</span><br/></strong><strong><span class="koboSpan" id="kobo.136.1">Name: nginx</span><br/><span class="koboSpan" id="kobo.137.1">Namespace: default</span><br/><span class="koboSpan" id="kobo.138.1">Selector: project=chapter3,version in (0.1,0.2)</span><br/><span class="koboSpan" id="kobo.139.1">Labels: project=chapter3</span><br/><span class="koboSpan" id="kobo.140.1">              service=web</span><br/><span class="koboSpan" id="kobo.141.1">              version=0.1</span><br/><span class="koboSpan" id="kobo.142.1">Annotations: &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.143.1">Replicas: 5 current / 5 desired</span><br/><span class="koboSpan" id="kobo.144.1">Pods Status: 5 Running / 0 Waiting / 0 Succeeded / 0 Failed</span><br/><span class="koboSpan" id="kobo.145.1">Pod Template:</span><br/><span class="koboSpan" id="kobo.146.1">  Labels: project=chapter3</span><br/><span class="koboSpan" id="kobo.147.1">           service=web</span><br/><span class="koboSpan" id="kobo.148.1">           version=0.1</span><br/><span class="koboSpan" id="kobo.149.1">  Containers:</span><br/><span class="koboSpan" id="kobo.150.1">   nginx:</span><br/><span class="koboSpan" id="kobo.151.1">    Image: nginx</span><br/><span class="koboSpan" id="kobo.152.1">    Port: 80/TCP</span><br/><span class="koboSpan" id="kobo.153.1">    Host Port: 0/TCP</span><br/><span class="koboSpan" id="kobo.154.1">    Environment: &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.155.1">    Mounts: &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.156.1">  Volumes: &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.157.1">Events:</span><br/><span class="koboSpan" id="kobo.158.1">  Type Reason Age From Message</span><br/><span class="koboSpan" id="kobo.159.1">  ---- ------ ---- ---- -------</span><br/><span class="koboSpan" id="kobo.160.1">  Normal SuccessfulCreate 3m34s replicaset-controller Created pod: nginx-l5mdn</span><br/><span class="koboSpan" id="kobo.161.1">  Normal SuccessfulCreate 3m34s replicaset-controller Created pod: nginx-pjjw9</span><br/><span class="koboSpan" id="kobo.162.1">  Normal SuccessfulDelete 102s replicaset-controller Deleted pod: our-nginx</span><br/><span class="koboSpan" id="kobo.163.1">  Normal SuccessfulCreate 37s replicaset-controller Created pod: nginx-v9trs</span><br/><span class="koboSpan" id="kobo.164.1">  Normal SuccessfulCreate 37s replicaset-controller Created pod: nginx-n95mv</span><br/><span class="koboSpan" id="kobo.165.1">  Normal SuccessfulCreate 37s replicaset-controller Created pod: nginx-xgdhq  </span></strong></pre>
<p><span class="koboSpan" id="kobo.166.1">By describing the command, we can learn the spec of </span><span><span class="koboSpan" id="kobo.167.1">RS and</span></span><span class="koboSpan" id="kobo.168.1"> the events. </span><span class="koboSpan" id="kobo.168.2">When we created the </span><kbd><span class="koboSpan" id="kobo.169.1">nginx</span></kbd> <span><span class="koboSpan" id="kobo.170.1">RS</span></span><span class="koboSpan" id="kobo.171.1">, it launched two containers by spec. </span><span class="koboSpan" id="kobo.171.2">Then, we created another pod manually by another spec, named </span><kbd><span class="koboSpan" id="kobo.172.1">our-nginx</span></kbd><span class="koboSpan" id="kobo.173.1">. </span><span class="koboSpan" id="kobo.173.2">RS detected that the pod matches its pod selector. </span><span class="koboSpan" id="kobo.173.3">After the amount exceeded our desired count, it evicted it. </span><span class="koboSpan" id="kobo.173.4">Then, we scaled out the replicas to five. </span><span><span class="koboSpan" id="kobo.174.1">RS</span></span><span class="koboSpan" id="kobo.175.1"> detected that it didn't fulfill our desired state and launched three pods to fill the gap.</span></p>
<p><span class="koboSpan" id="kobo.176.1">If we want to delete an RC, simply use the </span><kbd><span class="koboSpan" id="kobo.177.1">kubectl</span></kbd><span class="koboSpan" id="kobo.178.1"> command: </span><kbd><span class="koboSpan" id="kobo.179.1">kubectl delete &lt;resource&gt; &lt;resource_name&gt;</span></kbd><span class="koboSpan" id="kobo.180.1">. </span><span class="koboSpan" id="kobo.180.2">Since we have a configuration file on hand, we could also use </span><kbd><span class="koboSpan" id="kobo.181.1">kubectl delete -f &lt;configuration_file&gt;</span></kbd><span class="koboSpan" id="kobo.182.1"> to delete the resources listing in the file:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.183.1">// delete a rc</span><br/><span class="koboSpan" id="kobo.184.1"># kubectl delete rs nginx</span><br/><span class="koboSpan" id="kobo.185.1">replicaset.extensions/nginx deleted</span><br/><br/><span class="koboSpan" id="kobo.186.1">// get pod status</span><br/><span class="koboSpan" id="kobo.187.1"># kubectl get pods</span><br/><span class="koboSpan" id="kobo.188.1">NAME          READY     STATUS        RESTARTS   AGE</span><br/><span class="koboSpan" id="kobo.189.1">nginx-pjjw9   0/1       Terminating   0          29m  </span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Deployments</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Deployments are the best primitive to manage and deploy our software in Kubernetes after version 1.2. </span><span class="koboSpan" id="kobo.2.2">They allow us to deploy pods, carry out rolling updates, and roll back pods and ReplicaSets. </span><span class="koboSpan" id="kobo.2.3">We can define our desired software updates </span><span><span class="koboSpan" id="kobo.3.1">declaratively </span></span><span><span class="koboSpan" id="kobo.4.1">using Deployments and then Deployments will do them for us progressively.</span></span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.5.1">Before Deployments, ReplicationController and kubectl rolling-update were the major ways to implement rolling updates for software. </span><span class="koboSpan" id="kobo.5.2">These methods were much more imperative and slower. </span><span class="koboSpan" id="kobo.5.3">Deployment is now the main high-level object used to manage our application.</span></div>
<p><span class="koboSpan" id="kobo.6.1">Let's take a look at how it works. </span><span class="koboSpan" id="kobo.6.2">In this section, we'll get a taste of how a Deployment is created, how to perform rolling updates, and rollbacks. </span><a href="acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.7.1">Chapter 9</span></span></a><span class="koboSpan" id="kobo.8.1">, </span><em><span class="koboSpan" id="kobo.9.1">Continuous Delivery</span></em><span class="koboSpan" id="kobo.10.1">, has more information with practical examples about how we can integrate Deployments into our continuous delivery pipeline.</span></p>
<p><span class="koboSpan" id="kobo.11.1">First, we use the </span><kbd><span class="koboSpan" id="kobo.12.1">kubectl run</span></kbd><span class="koboSpan" id="kobo.13.1"> command to create </span><kbd><span class="koboSpan" id="kobo.14.1">deployment</span></kbd><span class="koboSpan" id="kobo.15.1"> for us:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.16.1">// using kubectl run to launch the Pods</span><br/><span class="koboSpan" id="kobo.17.1"># kubectl run nginx --image=nginx:1.12.0 --replicas=2 --port=80</span><br/><span class="koboSpan" id="kobo.18.1">deployment "nginx" created</span><br/><span class="koboSpan" id="kobo.19.1">// check the deployment status</span><br/><span class="koboSpan" id="kobo.20.1"># kubectl get deployments</span><br/><span class="koboSpan" id="kobo.21.1">NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br/><span class="koboSpan" id="kobo.22.1">nginx     2         2         2            2           4h</span></strong></pre>
<div class="packt_infobox"><span class="koboSpan" id="kobo.23.1">Before Kubernetes 1.2, the </span><kbd><span class="koboSpan" id="kobo.24.1">kubectl run</span></kbd><span class="koboSpan" id="kobo.25.1"> command would create pods instead.</span></div>
<p><span class="koboSpan" id="kobo.26.1">There are two pods that are deployed by </span><kbd><span class="koboSpan" id="kobo.27.1">deployment</span></kbd><span class="koboSpan" id="kobo.28.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.29.1">// check if pods match our desired count</span><br/><span class="koboSpan" id="kobo.30.1"># kubectl get pods</span><br/><span class="koboSpan" id="kobo.31.1">NAME                     READY     STATUS        RESTARTS   AGE</span><br/><span class="koboSpan" id="kobo.32.1">nginx-2371676037-2brn5   1/1       Running       0          4h</span><br/><span class="koboSpan" id="kobo.33.1">nginx-2371676037-gjfhp   1/1       Running       0          4h  </span></strong></pre>
<p><span class="koboSpan" id="kobo.34.1">The following is a diagram of the relationship between Deployments, ReplicaSets, and pods. In general, Deployments manage ReplicaSets and ReplicaSets manage pods. </span><span class="koboSpan" id="kobo.34.2">Note that we shouldn't manipulate ReplicaSets that are managed by Deployments, just like there's no reason to directly change pods if they're managed by ReplicaSets:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.35.1"><img src="assets/0dae5898-fe53-4992-9c95-5c96ab5dc84b.png" style="width:26.50em;height:14.00em;"/></span></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.36.1">The relationship between Deployments, ReplicaSets, and pods</span></div>
<p><span class="koboSpan" id="kobo.37.1">If we delete one of the pods, the replaced pod will be scheduled and launched immediately. </span><span class="koboSpan" id="kobo.37.2">This is because Deployments create a ReplicaSet behind the scenes, which will ensure that the number of replicas matches our desired count:</span></p>
<pre><strong><span class="koboSpan" id="kobo.38.1">// list replica sets</span><br/><span class="koboSpan" id="kobo.39.1"># kubectl get rs</span><br/><span class="koboSpan" id="kobo.40.1">NAME               DESIRED   CURRENT   READY     AGE</span><br/><span class="koboSpan" id="kobo.41.1">nginx-2371676037   2         2         2         4h      </span></strong></pre>
<p><span class="koboSpan" id="kobo.42.1">We could also expose the port for deployment using the </span><kbd><span class="koboSpan" id="kobo.43.1">kubectl</span></kbd><span class="koboSpan" id="kobo.44.1"> command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.45.1">// expose port 80 to service port 80</span><br/><span class="koboSpan" id="kobo.46.1"># kubectl expose deployment nginx --port=80 --target-port=80</span><br/><span class="koboSpan" id="kobo.47.1">service "nginx" exposed</span><br/><span class="koboSpan" id="kobo.48.1">// list services</span><br/><span class="koboSpan" id="kobo.49.1"># kubectl get services</span><br/><span class="koboSpan" id="kobo.50.1">NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br/><span class="koboSpan" id="kobo.51.1">kubernetes   10.0.0.1     &lt;none&gt;        443/TCP   3d</span><br/><span class="koboSpan" id="kobo.52.1">nginx        10.0.0.94    &lt;none&gt;        80/TCP    5s  </span></strong></pre>
<p><span class="koboSpan" id="kobo.53.1">Deployments can be created by spec as well. </span><span class="koboSpan" id="kobo.53.2">The previous Deployments and Service launched by kubectl can be converted into the following spec:</span></p>
<pre><strong><span class="koboSpan" id="kobo.54.1">// create deployments by spec</span><br/><span class="koboSpan" id="kobo.55.1"># cat 3-2-3_deployments.yaml</span><br/><span class="koboSpan" id="kobo.56.1">apiVersion: apps/v1</span><br/><span class="koboSpan" id="kobo.57.1">kind: Deployment</span><br/><span class="koboSpan" id="kobo.58.1">metadata:</span><br/><span class="koboSpan" id="kobo.59.1">  name: nginx</span><br/><span class="koboSpan" id="kobo.60.1">spec:</span><br/><span class="koboSpan" id="kobo.61.1">  replicas: 2</span><br/><span class="koboSpan" id="kobo.62.1">  template:</span><br/><span class="koboSpan" id="kobo.63.1">   metadata:</span><br/><span class="koboSpan" id="kobo.64.1">    labels:</span><br/><span class="koboSpan" id="kobo.65.1">     run: nginx</span><br/><span class="koboSpan" id="kobo.66.1">   spec:</span><br/><span class="koboSpan" id="kobo.67.1">    containers:</span><br/><span class="koboSpan" id="kobo.68.1">    - name: nginx</span><br/><span class="koboSpan" id="kobo.69.1">      image: nginx:1.12.0</span><br/><span class="koboSpan" id="kobo.70.1">      ports:</span><br/><span class="koboSpan" id="kobo.71.1">      - containerPort: 80</span><br/><span class="koboSpan" id="kobo.72.1">---</span><br/><span class="koboSpan" id="kobo.73.1">kind: Service</span><br/><span class="koboSpan" id="kobo.74.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.75.1">metadata:</span><br/><span class="koboSpan" id="kobo.76.1">  name: nginx</span><br/><span class="koboSpan" id="kobo.77.1">  labels:</span><br/><span class="koboSpan" id="kobo.78.1">   run: nginx</span><br/><span class="koboSpan" id="kobo.79.1">spec:</span><br/><span class="koboSpan" id="kobo.80.1">  selector:</span><br/><span class="koboSpan" id="kobo.81.1">   run: nginx</span><br/><span class="koboSpan" id="kobo.82.1">  ports:</span><br/><span class="koboSpan" id="kobo.83.1">    - protocol: TCP</span><br/><span class="koboSpan" id="kobo.84.1">      port: 80</span><br/><span class="koboSpan" id="kobo.85.1">      targetPort: 80</span><br/><span class="koboSpan" id="kobo.86.1">      name: http
</span></strong><br/><strong><span class="koboSpan" id="kobo.87.1">// create deployments and service</span><br/><span class="koboSpan" id="kobo.88.1"># kubectl create -f 3-2-3_deployments.yaml</span><br/><span class="koboSpan" id="kobo.89.1">deployment "nginx" created</span><br/><span class="koboSpan" id="kobo.90.1">service "nginx" created­­­­  </span></strong></pre>
<p><span class="koboSpan" id="kobo.91.1">In order to perform rolling updates, we'll need to add a rolling update strategy. </span><span class="koboSpan" id="kobo.91.2">There are three parameters used to control the process:</span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong><span class="koboSpan" id="kobo.92.1">Parameters</span></strong></p>
</td>
<td>
<p><strong><span class="koboSpan" id="kobo.93.1">Description</span></strong></p>
</td>
<td>
<p><strong><span class="koboSpan" id="kobo.94.1">Default value</span></strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span class="koboSpan" id="kobo.95.1">minReadySeconds</span></kbd></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.96.1">This is the warm-up time and indicates how long a newly created pod is considered to be available. </span><span class="koboSpan" id="kobo.96.2">By default, Kubernetes assumes the application will be available once it's successfully launched.</span></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.97.1">0</span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span class="koboSpan" id="kobo.98.1">maxSurge</span></kbd></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.99.1">This indicates how many pods can be surged when carrying out rolling update processes.</span></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.100.1">25%</span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span class="koboSpan" id="kobo.101.1">maxUnavailable</span></kbd></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.102.1">This indicates how many pods can be unavailable when carrying out rolling update processes.</span></p>
</td>
<td>
<p><span class="koboSpan" id="kobo.103.1">25%</span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.104.1"> </span></p>
<p><kbd><span class="koboSpan" id="kobo.105.1">minReadySecond</span></kbd><span class="koboSpan" id="kobo.106.1"> is an important setting. </span><span class="koboSpan" id="kobo.106.2">If our application isn't available immediately when the pod is up, the pods will roll too fast without proper waiting. </span><span class="koboSpan" id="kobo.106.3">Although all of the new pods are up, the application might be still warming up; there's a chance that a service outage might occur. </span><span class="koboSpan" id="kobo.106.4">In the following example, we'll add the configuration into the </span><kbd><span class="koboSpan" id="kobo.107.1">Deployment.spec</span></kbd><span class="koboSpan" id="kobo.108.1"> section:</span></p>
<pre><strong><span class="koboSpan" id="kobo.109.1">// add to Deployments.spec, save as 3-2-3_deployments_rollingupdate.yaml</span><br/><span class="koboSpan" id="kobo.110.1">minReadySeconds: 3</span><br/><span class="koboSpan" id="kobo.111.1">strategy:</span><br/><span class="koboSpan" id="kobo.112.1">  type: RollingUpdate</span><br/><span class="koboSpan" id="kobo.113.1">  rollingUpdate:</span><br/><span class="koboSpan" id="kobo.114.1">    maxSurge: 1</span><br/><span class="koboSpan" id="kobo.115.1">    maxUnavailable: 1</span></strong></pre>
<p><span class="koboSpan" id="kobo.116.1">This indicates that we allow only one of the pods to be unavailable at any time and one pod to be launched when rolling the pods. </span><span class="koboSpan" id="kobo.116.2">The warm-up time before proceeding to the next operation is three seconds. </span><span class="koboSpan" id="kobo.116.3">We can use either </span><kbd><span class="koboSpan" id="kobo.117.1">kubectl edit deployments nginx</span></kbd><span class="koboSpan" id="kobo.118.1"> (edit directly) or </span><kbd><span class="koboSpan" id="kobo.119.1">kubectl replace -f 3-2-3_deployments_rollingupdate.yaml</span></kbd><span class="koboSpan" id="kobo.120.1"> to update the strategy.</span></p>
<p><span class="koboSpan" id="kobo.121.1">Let's say we want to simulate a new software rollout from nginx 1.12.0 to 1.13.1. </span><span class="koboSpan" id="kobo.121.2">We can still use the preceding two commands to change the image version or use </span><kbd><span class="koboSpan" id="kobo.122.1">kubectl set image deployment nginx nginx=nginx</span></kbd><kbd><span class="koboSpan" id="kobo.123.1">:1.13.1</span></kbd><span class="koboSpan" id="kobo.124.1"> to trigger the update. </span><span class="koboSpan" id="kobo.124.2">If we use </span><kbd><span class="koboSpan" id="kobo.125.1">kubectl describe</span></kbd><span class="koboSpan" id="kobo.126.1"> to check what's going on, we'll see that Deployments have triggered rolling updates on ReplicaSets by deleting/creating pods:</span></p>
<pre><strong><span class="koboSpan" id="kobo.127.1">// list rs</span><br/><span class="koboSpan" id="kobo.128.1"># kubectl get rs</span><br/><span class="koboSpan" id="kobo.129.1">NAME             DESIRED CURRENT READY AGE</span><br/><span class="koboSpan" id="kobo.130.1">nginx-596b999b89 2       2       2     2m</span><br/><br/><span class="koboSpan" id="kobo.131.1">// check detailed rs information</span><br/><span class="koboSpan" id="kobo.132.1"># kubectl describe rs nginx-596b999b89</span><br/><span class="koboSpan" id="kobo.133.1">Name: nginx-596b999b89</span><br/><span class="koboSpan" id="kobo.134.1">Namespace: default</span><br/><span class="koboSpan" id="kobo.135.1">Selector: pod-template-hash=1526555645,run=nginx</span><br/><span class="koboSpan" id="kobo.136.1">Labels: pod-template-hash=1526555645</span><br/><span class="koboSpan" id="kobo.137.1">        run=nginx</span><br/><span class="koboSpan" id="kobo.138.1">Annotations: deployment.kubernetes.io/desired-replicas: 2</span><br/><span class="koboSpan" id="kobo.139.1">             deployment.kubernetes.io/max-replicas: 3</span><br/><span class="koboSpan" id="kobo.140.1">             deployment.kubernetes.io/revision: 1</span><br/><span class="koboSpan" id="kobo.141.1">Controlled By: Deployment/nginx</span><br/><span class="koboSpan" id="kobo.142.1">Replicas: 2 current / 2 desired</span><br/><span class="koboSpan" id="kobo.143.1">Pods Status: 2 Running / 0 Waiting / 0 Succeeded / 0 Failed</span><br/><span class="koboSpan" id="kobo.144.1">Pod Template:</span><br/><span class="koboSpan" id="kobo.145.1">  Labels: pod-template-hash=1526555645</span><br/><span class="koboSpan" id="kobo.146.1">          run=nginx</span><br/><span class="koboSpan" id="kobo.147.1">  Containers:</span><br/><span class="koboSpan" id="kobo.148.1">   nginx:</span><br/><span class="koboSpan" id="kobo.149.1">    Image: nginx:1.12.0</span><br/><span class="koboSpan" id="kobo.150.1">    Port: 80/TCP</span><br/><span class="koboSpan" id="kobo.151.1">    Host Port: 0/TCP</span><br/><span class="koboSpan" id="kobo.152.1">Events:</span><br/><span class="koboSpan" id="kobo.153.1">  Type Reason Age From Message</span><br/><span class="koboSpan" id="kobo.154.1">  ---- ------ ---- ---- -------</span><br/><span class="koboSpan" id="kobo.155.1">  Normal SuccessfulCreate 3m41s replicaset-controller Created pod: nginx-596b999b89-th9rx</span><br/><span class="koboSpan" id="kobo.156.1">  Normal SuccessfulCreate 3m41s replicaset-controller Created pod: nginx-596b999b89-2pp7b</span></strong></pre>
<p><span><span><span class="koboSpan" id="kobo.157.1">The following is a diagram of how rolling update works in a Deployment:</span></span></span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.158.1"><img src="assets/ff5abaf1-dbb3-4c85-a2ee-84c98925e6cd.png" style="width:43.33em;height:35.75em;"/></span></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.159.1">Illustration of a Deployment</span></div>
<p><span class="koboSpan" id="kobo.160.1">The preceding diagram shows an illustration of a Deployment. </span><span><span class="koboSpan" id="kobo.161.1">At a certain point in time, our desired count is 2 and we have one maxSurge pod</span></span><span class="koboSpan" id="kobo.162.1">. </span><span class="koboSpan" id="kobo.162.2">After launching each new pod, Kubernetes will wait three </span><span><span class="koboSpan" id="kobo.163.1">seconds </span></span><span><span class="koboSpan" id="kobo.164.1">(</span></span><kbd><span class="koboSpan" id="kobo.165.1">minReadySeconds</span></kbd><span><span class="koboSpan" id="kobo.166.1">) and then perform the next action.</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">If we use the </span><kbd><span class="koboSpan" id="kobo.168.1">kubectl set image deployment nginx nginx=nginx:1.12.0</span></kbd><span class="koboSpan" id="kobo.169.1"> </span><span><span class="koboSpan" id="kobo.170.1">command</span></span><span><span class="koboSpan" id="kobo.171.1"> </span></span><span><span class="koboSpan" id="kobo.172.1">to roll back to the previous version 1.12.0, Deployments will do the rollback for us.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Services</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Services in Kubernetes are abstraction layers for routing traffic to a logical set of pods. </span><span class="koboSpan" id="kobo.2.2">With Services, we don't need to trace the IP address of each pod. </span><span class="koboSpan" id="kobo.2.3">Services usually use the label selector to select the pods that they need to route to while, in some cases, Services are created without a selector on purpose. </span><span class="koboSpan" id="kobo.2.4">The Service abstraction is powerful. </span><span class="koboSpan" id="kobo.2.5">It enables decoupling and makes communication between micro-services possible. </span><span class="koboSpan" id="kobo.2.6">Currently, Kubernetes Services support TCP, UDP, and SCTP.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Services don't care about how we create the pod. </span><span class="koboSpan" id="kobo.3.2">Just like </span><span><span class="koboSpan" id="kobo.4.1">ReplicaSet</span></span><span class="koboSpan" id="kobo.5.1">, it only cares that the pods match its label selectors, so the pods could belong to different </span><span><span class="koboSpan" id="kobo.6.1">ReplicaSets:</span></span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.7.1"><img src="assets/98efea3b-cc56-41b0-af68-a8f78701f916.png" style="width:43.33em;height:21.58em;"/></span></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref"><span class="koboSpan" id="kobo.8.1">Service maps pods via label selector</span></div>
<p><span class="koboSpan" id="kobo.9.1">In the preceding diagram, all of the pods match the service selector, </span><kbd><span class="koboSpan" id="kobo.10.1">project=chapter3, service=web</span></kbd><span class="koboSpan" id="kobo.11.1">, so the Service will be responsible for distributing the traffic into all of the pods without explicit assignment.</span></p>
<p><span class="koboSpan" id="kobo.12.1">There are four types of Services: </span><kbd><span class="koboSpan" id="kobo.13.1">ClusterIP</span></kbd><span class="koboSpan" id="kobo.14.1">, </span><kbd><span class="koboSpan" id="kobo.15.1">NodePort</span></kbd><span class="koboSpan" id="kobo.16.1">, </span><kbd><span class="koboSpan" id="kobo.17.1">LoadBalancer</span></kbd><span class="koboSpan" id="kobo.18.1">, and </span><kbd><span class="koboSpan" id="kobo.19.1">ExternalName</span></kbd><span class="koboSpan" id="kobo.20.1">:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.21.1"><img src="assets/1e5774fc-aeb4-4247-80d4-853782f8c68f.png" style="width:28.08em;height:27.83em;"/></span></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.22.1">LoadBalancer includes the features of NodePort and ClusterIP</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">ClusterIP</span></h1>
                </header>
            
            <article>
                
<p><kbd><span class="koboSpan" id="kobo.2.1">ClusterIP</span></kbd><span class="koboSpan" id="kobo.3.1"> is the default Service type. </span><span class="koboSpan" id="kobo.3.2">It exposes the Service on a cluster-internal IP. </span><span class="koboSpan" id="kobo.3.3">Pods in the cluster could reach the Service via the IP address, environment variables, or DNS. </span><span class="koboSpan" id="kobo.3.4">In the following example, we'll learn how to use both native Service environment variables and DNS to access the pods behind Services in the cluster.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Before starting a Service, we'd like to create two sets of RS with different version labels, as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.5.1">// create RS 1 with nginx 1.12.0 version</span><br/><span class="koboSpan" id="kobo.6.1"># cat 3-2-3_rs1.yaml</span><br/><span class="koboSpan" id="kobo.7.1">apiVersion: apps/v1</span><br/><span class="koboSpan" id="kobo.8.1">kind: ReplicaSet</span><br/><span class="koboSpan" id="kobo.9.1">metadata:</span><br/><span class="koboSpan" id="kobo.10.1">  name: nginx-1.12</span><br/><span class="koboSpan" id="kobo.11.1">spec:</span><br/><span class="koboSpan" id="kobo.12.1">  replicas: 2</span><br/><span class="koboSpan" id="kobo.13.1">  selector:</span><br/><span class="koboSpan" id="kobo.14.1">    matchLabels:</span><br/><span class="koboSpan" id="kobo.15.1">      project: chapter3</span><br/><span class="koboSpan" id="kobo.16.1">      service: web</span><br/><span class="koboSpan" id="kobo.17.1">      version: "0.1" </span><br/><span class="koboSpan" id="kobo.18.1">  template:</span><br/><span class="koboSpan" id="kobo.19.1">    metadata:</span><br/><span class="koboSpan" id="kobo.20.1">      name: nginx</span><br/><span class="koboSpan" id="kobo.21.1">      labels:</span><br/><span class="koboSpan" id="kobo.22.1">        project: chapter3</span><br/><span class="koboSpan" id="kobo.23.1">        service: web</span><br/><span class="koboSpan" id="kobo.24.1">        version: "0.1"</span><br/><span class="koboSpan" id="kobo.25.1">    spec:</span><br/><span class="koboSpan" id="kobo.26.1">      containers:</span><br/><span class="koboSpan" id="kobo.27.1">      - name: nginx</span><br/><span class="koboSpan" id="kobo.28.1">        image: nginx:1.12.0</span><br/><span class="koboSpan" id="kobo.29.1">        ports:</span><br/><span class="koboSpan" id="kobo.30.1">        - containerPort: 80</span><br/><br/><span class="koboSpan" id="kobo.31.1">// create RS 2 with nginx 1.13.1 version</span><br/><span class="koboSpan" id="kobo.32.1"># cat 3-2-3_rs2.yaml
</span><br/><span class="koboSpan" id="kobo.33.1">apiVersion: apps/v1</span><br/><span class="koboSpan" id="kobo.34.1">kind: ReplicaSet</span><br/><span class="koboSpan" id="kobo.35.1">metadata:</span><br/><span class="koboSpan" id="kobo.36.1">  name: nginx-1.13</span><br/><span class="koboSpan" id="kobo.37.1">spec:</span><br/><span class="koboSpan" id="kobo.38.1">  replicas: 2</span><br/><span class="koboSpan" id="kobo.39.1">  selector:</span><br/><span class="koboSpan" id="kobo.40.1">    matchLabels:</span><br/><span class="koboSpan" id="kobo.41.1">      project: chapter3</span><br/><span class="koboSpan" id="kobo.42.1">      service: web</span><br/><span class="koboSpan" id="kobo.43.1">      version: "0.2" </span><br/><span class="koboSpan" id="kobo.44.1">  template:</span><br/><span class="koboSpan" id="kobo.45.1">    metadata:</span><br/><span class="koboSpan" id="kobo.46.1">      name: nginx</span><br/><span class="koboSpan" id="kobo.47.1">      labels:</span><br/><span class="koboSpan" id="kobo.48.1">        project: chapter3</span><br/><span class="koboSpan" id="kobo.49.1">        service: web</span><br/><span class="koboSpan" id="kobo.50.1">        version: "0.2"</span><br/><span class="koboSpan" id="kobo.51.1">    spec:</span><br/><span class="koboSpan" id="kobo.52.1">      containers:</span><br/><span class="koboSpan" id="kobo.53.1">      - name: nginx</span><br/><span class="koboSpan" id="kobo.54.1">        image: nginx:1.13.1</span><br/><span class="koboSpan" id="kobo.55.1">        ports:</span><br/><span class="koboSpan" id="kobo.56.1">        - containerPort: 80</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.57.1">Then, we could make our pod selector, targeting project and service labels:</span></p>
<pre><strong><span class="koboSpan" id="kobo.58.1">// simple nginx service </span><br/><span class="koboSpan" id="kobo.59.1"># cat 3-2-3_service.yaml</span><br/><span class="koboSpan" id="kobo.60.1">kind: Service</span><br/><span class="koboSpan" id="kobo.61.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.62.1">metadata:</span><br/><span class="koboSpan" id="kobo.63.1">  name: nginx-service</span><br/><span class="koboSpan" id="kobo.64.1">spec:</span><br/><span class="koboSpan" id="kobo.65.1">  selector:</span><br/><span class="koboSpan" id="kobo.66.1">   project: chapter3</span><br/><span class="koboSpan" id="kobo.67.1">   service: web</span><br/><span class="koboSpan" id="kobo.68.1">  ports:</span><br/><span class="koboSpan" id="kobo.69.1">  - protocol: TCP</span><br/><span class="koboSpan" id="kobo.70.1">    port: 80</span><br/><span class="koboSpan" id="kobo.71.1">    targetPort: 80</span><br/><span class="koboSpan" id="kobo.72.1">    name: http</span><br/><br/><span class="koboSpan" id="kobo.73.1">// create the RSs </span><br/><span class="koboSpan" id="kobo.74.1"># kubectl create -f 3-2-3_rs1.yaml</span><br/><span class="koboSpan" id="kobo.75.1">replicaset.apps/nginx-1.12 created</span><br/><span class="koboSpan" id="kobo.76.1"># kubectl create -f 3-2-3_rs2.yaml</span><br/><span class="koboSpan" id="kobo.77.1">replicaset.apps/nginx-1.13 created</span><br/><span class="koboSpan" id="kobo.78.1">// create the service</span><br/><span class="koboSpan" id="kobo.79.1"># kubectl create -f 3-2-3_service.yaml</span><br/><span class="koboSpan" id="kobo.80.1">service "nginx-service" created </span></strong> </pre>
<div class="packt_infobox"><span class="koboSpan" id="kobo.81.1">Since a </span><kbd><span class="koboSpan" id="kobo.82.1">Service</span></kbd><span class="koboSpan" id="kobo.83.1"> object might create a DNS label, the service name </span><span><span class="koboSpan" id="kobo.84.1">must be a combination of alphanumeric characters and hyphens</span></span><span class="koboSpan" id="kobo.85.1">. </span><span class="koboSpan" id="kobo.85.2">A hyphen at the beginning or end of a label isn't allowed.</span></div>
<p><span class="koboSpan" id="kobo.86.1">We can then use </span><kbd><span class="koboSpan" id="kobo.87.1">kubectl describe service &lt;service_name&gt;</span></kbd><span class="koboSpan" id="kobo.88.1"> to check the Service information:</span></p>
<pre><strong><span class="koboSpan" id="kobo.89.1">// check nginx-service information</span><br/><span class="koboSpan" id="kobo.90.1"># kubectl describe service nginx-service</span><br/><span class="koboSpan" id="kobo.91.1">Name:      nginx-service</span><br/><span class="koboSpan" id="kobo.92.1">Namespace:    default</span><br/><span class="koboSpan" id="kobo.93.1">Labels:      &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.94.1">Annotations:    &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.95.1">Selector:    project=chapter3,service=web</span><br/><span class="koboSpan" id="kobo.96.1">Type:      ClusterIP</span><br/><span class="koboSpan" id="kobo.97.1">IP:      10.0.0.188</span><br/><span class="koboSpan" id="kobo.98.1">Port:      http  80/TCP</span><br/></strong></pre>
<pre><strong><span class="koboSpan" id="kobo.99.1">Endpoints:    172.17.0.5:80,172.17.0.6:80,172.17.0.7:80 + 1 more...</span><br/><span class="koboSpan" id="kobo.100.1">Session Affinity:  None</span><br/><span class="koboSpan" id="kobo.101.1">Events:      &lt;none&gt;</span></strong></pre>
<div class="packt_tip"><span class="koboSpan" id="kobo.102.1">One Service could expose multiple ports. </span><span class="koboSpan" id="kobo.102.2">Just extend the </span><kbd><span class="koboSpan" id="kobo.103.1">.spec.ports</span></kbd><span class="koboSpan" id="kobo.104.1"> list in the </span><kbd><span class="koboSpan" id="kobo.105.1">service</span></kbd><span class="koboSpan" id="kobo.106.1"> spec.</span></div>
<p><span class="koboSpan" id="kobo.107.1">We can see that it's a </span><kbd><span class="koboSpan" id="kobo.108.1">ClusterIP</span></kbd><span class="koboSpan" id="kobo.109.1"> type Service and its assigned internal IP is </span><kbd><span class="koboSpan" id="kobo.110.1">10.0.0.188</span></kbd><span class="koboSpan" id="kobo.111.1">. </span><span class="koboSpan" id="kobo.111.2">The endpoints show that we have four IPs behind the Service. </span><span class="koboSpan" id="kobo.111.3">The pod IPs can be found by the </span><kbd><span class="koboSpan" id="kobo.112.1">kubectl describe pods &lt;pod_name&gt;</span></kbd><span class="koboSpan" id="kobo.113.1"> command. </span><span class="koboSpan" id="kobo.113.2">Kubernetes creates an </span><kbd><span class="koboSpan" id="kobo.114.1">endpoints</span></kbd><span class="koboSpan" id="kobo.115.1"> object along with a </span><kbd><span class="koboSpan" id="kobo.116.1">service</span></kbd><span class="koboSpan" id="kobo.117.1"> object to route the traffic to the matching pods.</span></p>
<p><span class="koboSpan" id="kobo.118.1">When the Service is created with selectors, Kubernetes will create corresponding endpoint entries and keep updating, which will indicate the destination that the Service routes to:</span></p>
<pre><strong><span class="koboSpan" id="kobo.119.1">// list current endpoints. </span><span class="koboSpan" id="kobo.119.2">Nginx-service endpoints are created and pointing to the ip of our 4 nginx pods.</span><br/><span class="koboSpan" id="kobo.120.1"># kubectl get endpoints</span><br/><span class="koboSpan" id="kobo.121.1">NAME            ENDPOINTS                                               AGE</span><br/><span class="koboSpan" id="kobo.122.1">kubernetes      10.0.2.15:8443                                          2d
nginx-service   172.17.0.5:80,172.17.0.6:80,172.17.0.7:80 + 1 more...   </span><span class="koboSpan" id="kobo.122.2">10s  </span></strong></pre>
<div class="packt_tip"><span class="koboSpan" id="kobo.123.1">The ClusterIP could be defined within your cluster, though most of the time we don't explicitly use the IP address to access clusters. </span><span class="koboSpan" id="kobo.123.2">Using </span><kbd><span class="koboSpan" id="kobo.124.1">.spec.clusterIP</span></kbd><span class="koboSpan" id="kobo.125.1"> can do this for us.</span></div>
<p><span class="koboSpan" id="kobo.126.1">By default, Kubernetes will expose seven environment variables for each Service. </span><span class="koboSpan" id="kobo.126.2">In most cases, the first two allow us to use the </span><kbd><span class="koboSpan" id="kobo.127.1">kube-dns</span></kbd><span class="koboSpan" id="kobo.128.1"> add-on to carry out service discovery for us:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.129.1">${SVCNAME}_SERVICE_HOST</span></kbd></li>
<li><kbd><span class="koboSpan" id="kobo.130.1">${SVCNAME}_SERVICE_PORT</span></kbd></li>
<li><kbd><span class="koboSpan" id="kobo.131.1">${SVCNAME}_PORT</span></kbd></li>
<li><kbd><span class="koboSpan" id="kobo.132.1">${SVCNAME}_PORT_${PORT}_${PROTOCAL}</span></kbd></li>
<li><kbd><span class="koboSpan" id="kobo.133.1">${SVCNAME}_PORT_${PORT}_${PROTOCAL}_PROTO</span></kbd></li>
<li><kbd><span class="koboSpan" id="kobo.134.1">${SVCNAME}_PORT_${PORT}_${PROTOCAL}_PORT</span></kbd></li>
<li><kbd><span class="koboSpan" id="kobo.135.1">${SVCNAME}_PORT_${PORT}_${PROTOCAL}_ADDR</span></kbd></li>
</ul>
<p><span class="koboSpan" id="kobo.136.1">In the following example, we'll use </span><kbd><span class="koboSpan" id="kobo.137.1">${SVCNAME}_SERVICE_HOST</span></kbd><span class="koboSpan" id="kobo.138.1"> in another pod to check whether we can access our nginx pods:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.139.1"><img src="assets/96e290d8-2b77-4137-820c-8b48abf5c963.png" style="width:58.50em;height:35.58em;"/></span></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref"><span class="koboSpan" id="kobo.140.1">Accessing ClusterIP via environment variables and DNS names</span></div>
<p><span class="koboSpan" id="kobo.141.1">We'll then create a pod called </span><kbd><span class="koboSpan" id="kobo.142.1">clusterip-chk</span></kbd><span class="koboSpan" id="kobo.143.1"> to access nginx containers via </span><kbd><span class="koboSpan" id="kobo.144.1">nginx-service</span></kbd><span class="koboSpan" id="kobo.145.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.146.1">// access nginx service via ${NGINX_SERVICE_SERVICE_HOST}</span><br/><span class="koboSpan" id="kobo.147.1"># cat 3-2-3_clusterip_chk.yaml</span><br/><span class="koboSpan" id="kobo.148.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.149.1">kind: Pod</span><br/><span class="koboSpan" id="kobo.150.1">metadata:</span><br/><span class="koboSpan" id="kobo.151.1">  name: clusterip-chk</span><br/><span class="koboSpan" id="kobo.152.1">spec:</span><br/><span class="koboSpan" id="kobo.153.1">  containers:</span><br/><span class="koboSpan" id="kobo.154.1">  - name: centos</span><br/><span class="koboSpan" id="kobo.155.1">    image: centos</span><br/><span class="koboSpan" id="kobo.156.1">    command: ["/bin/sh", "-c", "while : ;do curl    </span></strong><br/><strong><span class="koboSpan" id="kobo.157.1">http://${NGINX_SERVICE_SERVICE_HOST}:80/; sleep 10; done"]  </span></strong></pre>
<p><span class="koboSpan" id="kobo.158.1">We can check </span><kbd><span class="koboSpan" id="kobo.159.1">stdout</span></kbd><span class="koboSpan" id="kobo.160.1"> of the </span><kbd><span class="koboSpan" id="kobo.161.1">cluserip-chk</span></kbd><span class="koboSpan" id="kobo.162.1"> pod via the </span><kbd><span class="koboSpan" id="kobo.163.1">kubectl logs</span></kbd><span class="koboSpan" id="kobo.164.1"> command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.165.1">// check stdout, see if we can access nginx pod successfully</span><br/><span class="koboSpan" id="kobo.166.1"># kubectl logs -f clusterip-chk</span><br/><span class="koboSpan" id="kobo.167.1">% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                     Dload  Upload   Total   Spent    Left  Speed</span><br/><span class="koboSpan" id="kobo.168.1">100   612  100   612    0     0   156k      0 --:--:-- --:--:-- --:--:--  199k
 ...
</span><span class="koboSpan" id="kobo.168.2">&lt;title&gt;Welcome to nginx!&lt;/title&gt;
    ... </span></strong> </pre>
<p><span class="koboSpan" id="kobo.169.1">This abstraction level decouples the communication between pods. </span><span class="koboSpan" id="kobo.169.2">Pods are mortal. </span><span class="koboSpan" id="kobo.169.3">With RS and Services, we can build robust services without worrying about whether one pod will influence all microservices.</span></p>
<p><span class="koboSpan" id="kobo.170.1">With the </span><span><span><span class="koboSpan" id="kobo.171.1">DNS server</span></span></span><span class="koboSpan" id="kobo.172.1"> enabled, the pods in the same cluster and the same namespace as the Services can access Services via their DNS records.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.173.1">CoreDNS GA was introduced in Kubernetes 1.11 and is now the default option in Kubernetes. </span><span class="koboSpan" id="kobo.173.2">Before this, the kube-dns add-on was in charge of DNS-based service discovery</span></div>
<p><span class="koboSpan" id="kobo.174.1">The DNS server creates DNS records for newly created services by watching the Kubernetes API. </span><span class="koboSpan" id="kobo.174.2">The DNS format for the cluster IP is </span><kbd><span class="koboSpan" id="kobo.175.1">$servicename.$namespace</span></kbd><span class="koboSpan" id="kobo.176.1"> and the port is </span><kbd><span class="koboSpan" id="kobo.177.1">_$portname_$protocal.$servicename.$namespace</span></kbd><span class="koboSpan" id="kobo.178.1">. </span><span class="koboSpan" id="kobo.178.2">The spec of the </span><kbd><span class="koboSpan" id="kobo.179.1">clusterip_chk</span></kbd><span class="koboSpan" id="kobo.180.1"> pod will be similar to the environment variables one. </span><span class="koboSpan" id="kobo.180.2">Change the URL to </span><kbd><span class="koboSpan" id="kobo.181.1">http://nginx-service.default:_http_tcp.nginx-service.default/</span></kbd><span class="koboSpan" id="kobo.182.1"> in our previous example, and they should work exactly the same.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">NodePort</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">If the Service is set as </span><kbd><span class="koboSpan" id="kobo.3.1">NodePort</span></kbd><span class="koboSpan" id="kobo.4.1">, Kubernetes will allocate a port within a certain range on each node. </span><span class="koboSpan" id="kobo.4.2">Any traffic going to the nodes on that port will be routed to the Service port. </span><span class="koboSpan" id="kobo.4.3">The port number may be user-specified. </span><span class="koboSpan" id="kobo.4.4">If not, Kubernetes will randomly choose a port between 30,000 and 32,767 </span><span><span class="koboSpan" id="kobo.5.1">that doesn't cause any collision</span></span><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">On the other hand, if it's specified, the user should be responsible for managing the collision by themselves. </span><kbd><span class="koboSpan" id="kobo.7.1">NodePort</span></kbd><span class="koboSpan" id="kobo.8.1"> includes a </span><kbd><span><span class="koboSpan" id="kobo.9.1">ClusterIP </span></span></kbd><span><span class="koboSpan" id="kobo.10.1"> feature. </span><span class="koboSpan" id="kobo.10.2">Kubernetes assigns an internal IP to the Service.</span></span></p>
<p><span><span class="koboSpan" id="kobo.11.1">In the following example, we'll see how we can create a </span><kbd><span class="koboSpan" id="kobo.12.1">NodePort</span></kbd><span class="koboSpan" id="kobo.13.1"> Service and use it:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.14.1">// write a nodeport type service</span><br/><span class="koboSpan" id="kobo.15.1"># cat 3-2-3_nodeport.yaml</span><br/><span class="koboSpan" id="kobo.16.1">kind: Service</span><br/><span class="koboSpan" id="kobo.17.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.18.1">metadata:</span><br/><span class="koboSpan" id="kobo.19.1">  name: nginx-nodeport</span><br/><span class="koboSpan" id="kobo.20.1">spec:</span><br/><span class="koboSpan" id="kobo.21.1">  type: NodePort</span><br/><span class="koboSpan" id="kobo.22.1">  selector:</span><br/><span class="koboSpan" id="kobo.23.1">    project: chapter3</span><br/><span class="koboSpan" id="kobo.24.1">    service: web</span><br/><span class="koboSpan" id="kobo.25.1">  ports:</span><br/><span class="koboSpan" id="kobo.26.1">    - protocol: TCP</span><br/><span class="koboSpan" id="kobo.27.1">      port: 80</span><br/><span class="koboSpan" id="kobo.28.1">      targetPort: 80</span><br/><br/><span class="koboSpan" id="kobo.29.1">// create a nodeport service</span><br/><span class="koboSpan" id="kobo.30.1"># kubectl create -f 3-2-3_nodeport.yaml</span><br/><span class="koboSpan" id="kobo.31.1">service "nginx-nodeport" created  </span></strong></pre>
<p><span class="koboSpan" id="kobo.32.1">You should then be able to access the Service via </span><kbd><span class="koboSpan" id="kobo.33.1">http://${NODE_IP}:80</span></kbd><span class="koboSpan" id="kobo.34.1">. </span><span class="koboSpan" id="kobo.34.2">The node could be any node. </span><span class="koboSpan" id="kobo.34.3">The </span><kbd><span class="koboSpan" id="kobo.35.1">kube-proxy</span></kbd><span class="koboSpan" id="kobo.36.1"> watches for any updates by the Service and the endpoints, and updates the iptable rules accordingly (if using default </span><kbd><span class="koboSpan" id="kobo.37.1">iptables</span></kbd><span class="koboSpan" id="kobo.38.1"> proxy-mode).</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.39.1">If you're using minikube, you can access the Service via the </span><kbd><span class="koboSpan" id="kobo.40.1">minikube service [-n NAMESPACE] [--url] NAME</span></kbd><span class="koboSpan" id="kobo.41.1"> command. </span><span class="koboSpan" id="kobo.41.2">In this example, this is </span><kbd><span class="koboSpan" id="kobo.42.1">minikube service nginx-nodeport</span></kbd><span class="koboSpan" id="kobo.43.1">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">LoadBalancer</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This type is only usable with cloud provider support, such as </span><span><span class="koboSpan" id="kobo.3.1">Amazon Web Services</span></span><span class="koboSpan" id="kobo.4.1"> (</span><a href="f55d3fa8-e791-4473-83ba-ed8c4f848a90.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.5.1">Chapter 10</span></span></a><span class="koboSpan" id="kobo.6.1">, </span><em><span class="koboSpan" id="kobo.7.1">Kubernetes on AWS</span></em><span class="koboSpan" id="kobo.8.1">), </span><span><span class="koboSpan" id="kobo.9.1">Google Cloud Platform </span></span><span class="koboSpan" id="kobo.10.1">(</span><a href="d4de05e3-eb24-4e8e-bfd3-e68819b5e66c.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.11.1">Chapter 11</span></span></a><span class="koboSpan" id="kobo.12.1">, </span><em><span class="koboSpan" id="kobo.13.1">Kubernetes on GCP</span></em><span class="koboSpan" id="kobo.14.1">), and Azure (</span><a href="89891610-4ca4-4216-9d76-2613d186421c.xhtml"><span class="koboSpan" id="kobo.15.1">Chapter 12</span></a><span class="koboSpan" id="kobo.16.1">, </span><em><span class="koboSpan" id="kobo.17.1">Kubernetes on Azure</span></em><span class="koboSpan" id="kobo.18.1">). </span><span class="koboSpan" id="kobo.18.2">If we create a LoadBalancer Service, Kubernetes will provision a load balancer by the cloud provider to the Service.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">ExternalName (kube-dns version &gt;= 1.7)</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Sometimes, we use different services in the cloud. </span><span class="koboSpan" id="kobo.2.2">Kubernetes is flexible enough to be hybrid. </span><span><span class="koboSpan" id="kobo.3.1">We can use ExternalName to create a CNAME for the external endpoints in the cluster.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Service without selectors</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Services use selectors to match the pods to direct the traffic. </span><span class="koboSpan" id="kobo.2.2">However, sometimes you need to implement a proxy to be the bridge between the Kubernetes cluster and another namespace, another cluster, or an external resource. </span><span class="koboSpan" id="kobo.2.3">In the following example, we'll demonstrate how to implement a proxy for </span><a href="http://www.google.com"><span class="URLPACKT"><span class="koboSpan" id="kobo.3.1">http://www.google.com</span></span></a><span class="koboSpan" id="kobo.4.1"> in your cluster. </span><span class="koboSpan" id="kobo.4.2">This is just an example; the source of the proxy in your case might be the endpoint of your database or another resource in the cloud:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1"><img src="assets/aad76cc0-0822-460d-9680-8ab29368220a.png" style="width:28.25em;height:8.83em;"/></span></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref"><span class="koboSpan" id="kobo.6.1">How a Service without a selector works</span></div>
<p><span class="koboSpan" id="kobo.7.1">The configuration file is similar to the previous one, just without the selector section:</span></p>
<pre><strong><span class="koboSpan" id="kobo.8.1">// create a service without selectors</span><br/><span class="koboSpan" id="kobo.9.1"># cat 3-2-3_service_wo_selector_srv.yaml</span><br/><span class="koboSpan" id="kobo.10.1">kind: Service</span><br/><span class="koboSpan" id="kobo.11.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.12.1">metadata:</span><br/><span class="koboSpan" id="kobo.13.1">  name: google-proxy</span><br/><span class="koboSpan" id="kobo.14.1">spec:</span><br/><span class="koboSpan" id="kobo.15.1">  ports:</span><br/><span class="koboSpan" id="kobo.16.1">    - protocol: TCP</span><br/><span class="koboSpan" id="kobo.17.1">      port: 80</span><br/><span class="koboSpan" id="kobo.18.1">      targetPort: 80

// create service without selectors</span><br/><span class="koboSpan" id="kobo.19.1"># kubectl create -f 3-2-3_service_wo_selector_srv.yaml</span><br/><span class="koboSpan" id="kobo.20.1">service "google-proxy" created  </span></strong></pre>
<p><span class="koboSpan" id="kobo.21.1">No Kubernetes endpoint will be created, since there's no selector. </span><span class="koboSpan" id="kobo.21.2">Kubernetes doesn't know where to route the traffic, since no selector can match the pods. </span><span class="koboSpan" id="kobo.21.3">We'll have to create the endpoints manually.</span></p>
<p><span class="koboSpan" id="kobo.22.1">In the </span><kbd><span class="koboSpan" id="kobo.23.1">Endpoints</span></kbd><span class="koboSpan" id="kobo.24.1"> object, the source addresses can't be the DNS name, so we'll use </span><kbd><span class="koboSpan" id="kobo.25.1">nslookup</span></kbd><span class="koboSpan" id="kobo.26.1"> to find the current Google IP from the domain, and add it to </span><kbd><span class="koboSpan" id="kobo.27.1">Endpoints.subsets.addresses.ip</span></kbd><span class="koboSpan" id="kobo.28.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.29.1">// get an IP from google.com</span><br/><span class="koboSpan" id="kobo.30.1"># nslookup www.google.com</span><br/><span class="koboSpan" id="kobo.31.1">Server:    192.168.1.1</span><br/><span class="koboSpan" id="kobo.32.1">Address:  192.168.1.1#53

Non-authoritative answer:</span><br/><span class="koboSpan" id="kobo.33.1">Name:  google.com</span><br/><span class="koboSpan" id="kobo.34.1">Address: 172.217.0.238
</span><br/><span class="koboSpan" id="kobo.35.1">// create endpoints for the ip from google.com</span><br/><span class="koboSpan" id="kobo.36.1"># cat 3-2-3_service_wo_selector_endpoints.yaml</span><br/><span class="koboSpan" id="kobo.37.1">kind: Endpoints</span><br/><span class="koboSpan" id="kobo.38.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.39.1">metadata:</span><br/><span class="koboSpan" id="kobo.40.1">  name: google-proxy</span><br/><span class="koboSpan" id="kobo.41.1">subsets:</span><br/><span class="koboSpan" id="kobo.42.1">  - addresses:</span><br/><span class="koboSpan" id="kobo.43.1">      - ip: 172.217.0.238</span><br/><span class="koboSpan" id="kobo.44.1">    ports:</span><br/><span class="koboSpan" id="kobo.45.1">      - port: 80
    
// create Endpoints</span><br/><span class="koboSpan" id="kobo.46.1"># kubectl create -f 3-2-3_service_wo_selector_endpoints.yaml</span><br/><span class="koboSpan" id="kobo.47.1">endpoints "google-proxy" created  </span></strong></pre>
<p><span class="koboSpan" id="kobo.48.1">Let's create another pod in the cluster to access our Google proxy:</span></p>
<pre><strong><span class="koboSpan" id="kobo.49.1">// pod for accessing google proxy</span><br/><span class="koboSpan" id="kobo.50.1"># cat 3-2-3_proxy-chk.yaml</span><br/><span class="koboSpan" id="kobo.51.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.52.1">kind: Pod</span><br/><span class="koboSpan" id="kobo.53.1">metadata:</span><br/><span class="koboSpan" id="kobo.54.1">  name: proxy-chk</span><br/><span class="koboSpan" id="kobo.55.1">spec:</span><br/><span class="koboSpan" id="kobo.56.1">  containers:</span><br/><span class="koboSpan" id="kobo.57.1">  - name: centos</span><br/><span class="koboSpan" id="kobo.58.1">    image: centos</span><br/><span class="koboSpan" id="kobo.59.1">    command: ["/bin/sh", "-c", "while : ;do curl -L http://${GOOGLE_PROXY_SERVICE_HOST}:80/; sleep 10; done"]</span><br/><br/><br/><span class="koboSpan" id="kobo.60.1">// create the pod</span><br/><span class="koboSpan" id="kobo.61.1"># kubectl create -f 3-2-3_proxy-chk.yaml</span><br/><span class="koboSpan" id="kobo.62.1">pod "proxy-chk" created  </span></strong></pre>
<p><span class="koboSpan" id="kobo.63.1">Let's check </span><kbd><span class="koboSpan" id="kobo.64.1">stdout</span></kbd><span class="koboSpan" id="kobo.65.1"> from the pod:</span></p>
<pre><strong><span class="koboSpan" id="kobo.66.1">// get logs from proxy-chk</span><br/><span class="koboSpan" id="kobo.67.1"># kubectl logs proxy-chk</span><br/><span class="koboSpan" id="kobo.68.1">% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                     Dload  Upload   Total   Spent    Left  Speed</span><br/><span class="koboSpan" id="kobo.69.1">100   219  100   219    0     0   2596      0 --:--:-- --:--:-- --:--:--  2607</span><br/><span class="koboSpan" id="kobo.70.1">100   258  100   258    0     0   1931      0 --:--:-- --:--:-- --:--:--  1931</span><br/><span class="koboSpan" id="kobo.71.1">&lt;!doctype html&gt;&lt;html itemscope="" itemtype="http://schema.org/WebPage" lang="en-CA"&gt;</span><br/></strong><br/><strong><span class="koboSpan" id="kobo.72.1"> ...  </span></strong></pre>
<p><span class="koboSpan" id="kobo.73.1">Hurray! </span><span class="koboSpan" id="kobo.73.2">We can now confirm that the proxy works. </span><span class="koboSpan" id="kobo.73.3">The traffic to the Service will be routed to the endpoints we specified. </span><span class="koboSpan" id="kobo.73.4">If it doesn't work, make sure you add the proper inbound rules to the network of your external resources.</span></p>
<p><span class="koboSpan" id="kobo.74.1">Endpoints don't support DNS as a source. </span><span class="koboSpan" id="kobo.74.2">Alternatively, we can use the ExternalName, which doesn't have selectors either. </span><span class="koboSpan" id="kobo.74.3">This requires kube-dns version &gt;= 1.7.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.75.1">In some use cases, users need neither load balancing nor proxy functionalities for the Service. </span><span class="koboSpan" id="kobo.75.2">In those cases, we can set </span><kbd><span class="koboSpan" id="kobo.76.1">CluterIP = "None"</span></kbd><span class="koboSpan" id="kobo.77.1"> as a so-called headless service. </span><span class="koboSpan" id="kobo.77.2">For more information, please refer to </span><a href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.78.1">https://kubernetes.io/docs/concepts/services-networking/service/#headless-services</span></span></a><span class="koboSpan" id="kobo.79.1">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Volumes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A container is ephemeral and so is its disk. </span><span class="koboSpan" id="kobo.2.2">We either use the </span><kbd><span class="koboSpan" id="kobo.3.1">docker commit [CONTAINER]</span></kbd><span class="koboSpan" id="kobo.4.1"> command or mount data volumes into a container (</span><a href="05e2d0b4-0e70-4480-b5a0-f3860ddb24f2.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.5.1">Chapter 2</span></span></a><span class="koboSpan" id="kobo.6.1">, </span><em><span class="koboSpan" id="kobo.7.1">DevOps with Containers</span></em><span class="koboSpan" id="kobo.8.1">). </span><span class="koboSpan" id="kobo.8.2">In the Kubernetes domain, volume management is critical, since pods might run on any node. </span><span class="koboSpan" id="kobo.8.3">Also, ensuring that containers in the same pod can share the same files becomes extremely hard. </span><span class="koboSpan" id="kobo.8.4">This is an important topic in Kubernetes. </span><span class="ChapterrefPACKT"><a href="c3083748-0f68-488f-87e0-f8c61deeeb80.xhtml"><span class="koboSpan" id="kobo.9.1">Chapter 4</span></a></span><span class="koboSpan" id="kobo.10.1">, </span><em><span class="koboSpan" id="kobo.11.1">Managing Stateful Workloads</span></em><span class="koboSpan" id="kobo.12.1">, introduces volume management.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Secrets</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A secret, as its name suggests, is an object that stores secrets in key-value format for providing sensitive information to pods. </span><span class="koboSpan" id="kobo.2.2">It might be a password, an access key, or a token.</span><span><span class="koboSpan" id="kobo.3.1"> A secret isn't stored in the disk</span></span><span class="koboSpan" id="kobo.4.1">; instead, it's stored in a per-node </span><kbd><span class="koboSpan" id="kobo.5.1">tmpfs</span></kbd><span class="koboSpan" id="kobo.6.1"> filesystem. </span><span class="koboSpan" id="kobo.6.2">Kubelet on the node will create a </span><kbd><span class="koboSpan" id="kobo.7.1">tmpfs</span></kbd><span class="koboSpan" id="kobo.8.1"> filesystem to store the secret. </span><span class="koboSpan" id="kobo.8.2">A secret isn't designed to store large amounts of data due to storage management considerations. </span><span class="koboSpan" id="kobo.8.3">The current size limit of one secret is 1 MB.</span></p>
<p><span class="koboSpan" id="kobo.9.1">We can create a secret based on a file, a directory, or a specified literal value by launching kubectl to create a secret command or by the spec. </span><span class="koboSpan" id="kobo.9.2">There are three types of secret format: generic (or opaque, if encoded), docker registry, and TLS.</span></p>
<p><span><span class="koboSpan" id="kobo.10.1">We'll use either the generic or opaque type in </span></span><span class="koboSpan" id="kobo.11.1">our application. The docker registry type is used to store the credentials of a private docker registry. </span><span class="koboSpan" id="kobo.11.2">A TLS secret is used to store the CA certificate bundle for cluster administration.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.12.1">The </span><kbd><span class="koboSpan" id="kobo.13.1">docker-registry</span></kbd><span class="koboSpan" id="kobo.14.1"> type of secret is also called </span><kbd><span class="koboSpan" id="kobo.15.1">imagePullSecrets</span></kbd><span class="koboSpan" id="kobo.16.1"> and is used to pass the password of a private Docker registry via kubelet when pulling the image. </span><span class="koboSpan" id="kobo.16.2">This means we don't have to enter </span><kbd><span class="koboSpan" id="kobo.17.1">docker login</span></kbd><span class="koboSpan" id="kobo.18.1"> for each provisioned node. </span><span class="koboSpan" id="kobo.18.2">The command is as follows: </span><kbd><span class="koboSpan" id="kobo.19.1">kubectl create secret docker-registry</span></kbd> <kbd><span class="koboSpan" id="kobo.20.1">&lt;registry_name&gt;</span></kbd> <kbd><span class="koboSpan" id="kobo.21.1">--docker-server</span></kbd><kbd><span class="koboSpan" id="kobo.22.1">=&lt;docker_server&gt; --docker-username=&lt;docker_username&gt;</span></kbd> <kbd><span class="koboSpan" id="kobo.23.1">--docker-password=&lt;docker_password&gt; --docker-email=&lt;docker_email&gt;</span></kbd><span class="koboSpan" id="kobo.24.1">.</span></div>
<p><span class="koboSpan" id="kobo.25.1">We'll start with a generic example to show how it works:</span></p>
<pre><strong><span class="koboSpan" id="kobo.26.1">// create a secret by command line</span><br/><span class="koboSpan" id="kobo.27.1"># kubectl create secret generic mypassword --from-file=./mypassword.txt</span><br/><span class="koboSpan" id="kobo.28.1">secret "mypassword" created  </span></strong></pre>
<div class="packt_infobox"><span class="koboSpan" id="kobo.29.1">The options for creating secrets based on a directory and a literal value are pretty similar to the file ones. </span><span class="koboSpan" id="kobo.29.2">If we specify a directory after </span><kbd><span class="koboSpan" id="kobo.30.1">--from-file</span></kbd><span class="koboSpan" id="kobo.31.1">, the files in the directory will be iterated. </span><span class="koboSpan" id="kobo.31.2">The filename will be the secret key if it's a legal secret name. </span><span><span class="koboSpan" id="kobo.32.1">Non-regular files, such as subdirectories, symlinks, devices, or pipes, will be ignored</span></span><span class="koboSpan" id="kobo.33.1">. </span><span class="koboSpan" id="kobo.33.2">On the other hand, </span><kbd><span class="koboSpan" id="kobo.34.1">--from-literal=&lt;key&gt;=&lt;value&gt;</span></kbd><span class="koboSpan" id="kobo.35.1"> is the option to use if you want to specify plain text directly from the command, for example, </span><kbd><span class="koboSpan" id="kobo.36.1">--from-literal=username=root</span></kbd><span class="koboSpan" id="kobo.37.1">.</span></div>
<p><span class="koboSpan" id="kobo.38.1">Here, we create a secret name, </span><kbd><span class="koboSpan" id="kobo.39.1">mypassword</span></kbd><span class="koboSpan" id="kobo.40.1">, from the </span><kbd><span class="koboSpan" id="kobo.41.1">mypassword.txt</span></kbd><span class="koboSpan" id="kobo.42.1"> file. </span><span class="koboSpan" id="kobo.42.2">By default, the key of the secret is the filename, which is equivalent to the </span><kbd><span class="koboSpan" id="kobo.43.1">--from-file=mypassword=./mypassword.txt</span></kbd><span class="koboSpan" id="kobo.44.1"> option. </span><span class="koboSpan" id="kobo.44.2">We could append multiple </span><kbd><span class="koboSpan" id="kobo.45.1">--from-file</span></kbd><span class="koboSpan" id="kobo.46.1"> instances as well. </span><span><span class="koboSpan" id="kobo.47.1">We can use the </span><kbd><span class="koboSpan" id="kobo.48.1">kubectl get secret -o yaml</span></kbd><span class="koboSpan" id="kobo.49.1"> command to see more detailed information about the secret:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.50.1">// get the detailed info of the secret</span><br/><span class="koboSpan" id="kobo.51.1"># kubectl get secret mypassword -o yaml</span><br/><span class="koboSpan" id="kobo.52.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.53.1">data:</span><br/><span class="koboSpan" id="kobo.54.1">  mypassword: bXlwYXNzd29yZA==</span><br/><span class="koboSpan" id="kobo.55.1">kind: Secret</span><br/><span class="koboSpan" id="kobo.56.1">metadata:</span><br/><span class="koboSpan" id="kobo.57.1">  creationTimestamp: 2017-06-13T08:09:35Z</span><br/><span class="koboSpan" id="kobo.58.1">  name: mypassword</span><br/><span class="koboSpan" id="kobo.59.1">  namespace: default</span><br/><span class="koboSpan" id="kobo.60.1">  resourceVersion: "256749"</span><br/><span class="koboSpan" id="kobo.61.1">  selfLink: /api/v1/namespaces/default/secrets/mypassword</span><br/><span class="koboSpan" id="kobo.62.1">  uid: a33576b0-500f-11e7-9c45-080027cafd37</span><br/><span class="koboSpan" id="kobo.63.1">type: Opaque  </span></strong></pre>
<p><span class="koboSpan" id="kobo.64.1">We can see that the type of the secret becomes </span><kbd><span class="koboSpan" id="kobo.65.1">Opaque</span></kbd><span class="koboSpan" id="kobo.66.1"> since the text has been encrypted by kubectl. </span><span class="koboSpan" id="kobo.66.2">It's </span><kbd><span class="koboSpan" id="kobo.67.1">base64</span></kbd><span class="koboSpan" id="kobo.68.1"> encoded. </span><span class="koboSpan" id="kobo.68.2">We can use a simple </span><kbd><span class="koboSpan" id="kobo.69.1">bash</span></kbd><span class="koboSpan" id="kobo.70.1"> command to decode it:</span></p>
<pre><strong><span class="koboSpan" id="kobo.71.1"># echo "bXlwYXNzd29yZA==" | base64 --decode</span><br/><span class="koboSpan" id="kobo.72.1">mypassword</span></strong></pre>
<p><span class="koboSpan" id="kobo.73.1">There are two ways for a pod to retrieve the secret. </span><span class="koboSpan" id="kobo.73.2">The first one is by a file, and the second one is by an environment variable. </span><span class="koboSpan" id="kobo.73.3">The first method is implemented by the volume. </span><span class="koboSpan" id="kobo.73.4">The syntax involves adding </span><kbd><span class="koboSpan" id="kobo.74.1">containers.volumeMounts</span></kbd><span class="koboSpan" id="kobo.75.1"> in container specs and adding a volumes section with the secret configuration.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Retrieving secrets via files</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's see how to read secrets from files inside a pod first:</span></p>
<pre><strong><span class="koboSpan" id="kobo.3.1">// example for how a Pod retrieve secret</span><br/><span class="koboSpan" id="kobo.4.1"># cat 3-2-3_pod_vol_secret.yaml</span><br/><span class="koboSpan" id="kobo.5.1">apiVersion: v1</span></strong><br/><strong><span class="koboSpan" id="kobo.6.1">kind: Pod</span></strong><br/><strong><span class="koboSpan" id="kobo.7.1">metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.8.1">  name: secret-access</span></strong><br/><strong><span class="koboSpan" id="kobo.9.1">spec:</span></strong><br/><strong><span class="koboSpan" id="kobo.10.1">  containers:</span></strong><br/><strong><span class="koboSpan" id="kobo.11.1">  - name: centos</span></strong><br/><strong><span class="koboSpan" id="kobo.12.1">    image: centos</span></strong><br/><strong><span class="koboSpan" id="kobo.13.1">    command: ["/bin/sh", "-c", "while : ;do cat /secret/password-example; sleep 10; done"]</span></strong><br/><strong><span class="koboSpan" id="kobo.14.1">    volumeMounts:</span></strong><br/><strong><span class="koboSpan" id="kobo.15.1">      - name: secret-vol</span></strong><br/><strong><span class="koboSpan" id="kobo.16.1">        mountPath: /secret</span></strong><br/><strong><span class="koboSpan" id="kobo.17.1">        readOnly: true</span></strong><br/><strong><span class="koboSpan" id="kobo.18.1">  volumes:</span></strong><br/><strong><span class="koboSpan" id="kobo.19.1">    - name: secret-vol</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">      secret:</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">        secretName: mypassword</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">        items:</span></strong><br/><strong><span class="koboSpan" id="kobo.23.1">        - key: mypassword</span></strong><br/><strong><span class="koboSpan" id="kobo.24.1">          path: password-example</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.25.1">// create the pod </span><br/><span class="koboSpan" id="kobo.26.1"># kubectl create -f 3-2-3_pod_vol_secret.yaml </span><br/><span class="koboSpan" id="kobo.27.1">pod "secret-access" created </span></strong></pre>
<p><span class="koboSpan" id="kobo.28.1">The secret file will be mounted in </span><kbd><span class="koboSpan" id="kobo.29.1">/&lt;mount_point&gt;/&lt;secret_name&gt;</span></kbd><span class="koboSpan" id="kobo.30.1"> without specifying </span><kbd><span class="koboSpan" id="kobo.31.1">items</span></kbd><kbd><span class="koboSpan" id="kobo.32.1">key</span></kbd><span class="koboSpan" id="kobo.33.1">, </span><kbd><span class="koboSpan" id="kobo.34.1">path</span></kbd><span class="koboSpan" id="kobo.35.1">, or </span><kbd><span class="koboSpan" id="kobo.36.1">/&lt;mount_point&gt;/&lt;path&gt;</span></kbd><span class="koboSpan" id="kobo.37.1"> in the pod. </span><span class="koboSpan" id="kobo.37.2">In this case, </span><span><span><span class="koboSpan" id="kobo.38.1">the file path is</span></span></span><span class="koboSpan" id="kobo.39.1"> </span><kbd><span class="koboSpan" id="kobo.40.1">/secret/password-example</span></kbd><span class="koboSpan" id="kobo.41.1">. </span><span class="koboSpan" id="kobo.41.2">If we describe the pod, we find that there are two mount points in this pod: the read-only volume that stores our secret and the one that stores the credentials to communicate with the API servers, which is created and managed by Kubernetes. </span><span class="koboSpan" id="kobo.41.3">We'll learn more about this in </span><a href="fc67e008-b601-45a6-8297-d2fa28360b1f.xhtml"><span class="koboSpan" id="kobo.42.1">Chapter 6</span></a><span class="koboSpan" id="kobo.43.1">, </span><em><span class="koboSpan" id="kobo.44.1">Kubernetes Network</span></em><span class="koboSpan" id="kobo.45.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.46.1"># kubectl describe pod secret-access</span><br/><span class="koboSpan" id="kobo.47.1">...</span><br/><span class="koboSpan" id="kobo.48.1">Mounts:</span><br/><span class="koboSpan" id="kobo.49.1">      /secret from secret-vol (ro)</span><br/><span class="koboSpan" id="kobo.50.1">      /var/run/secrets/kubernetes.io/serviceaccount from default-token-jd1dq (ro)</span><br/><span class="koboSpan" id="kobo.51.1">... </span></strong> </pre>
<p><span class="koboSpan" id="kobo.52.1">We can delete a secret using the </span><kbd><span class="koboSpan" id="kobo.53.1">kubectl delete secret</span></kbd> <kbd><span class="koboSpan" id="kobo.54.1">&lt;secret_name&gt;</span></kbd><span class="koboSpan" id="kobo.55.1"> command.</span></p>
<p><span class="koboSpan" id="kobo.56.1">After describing the pod, we can find a </span><kbd><span class="koboSpan" id="kobo.57.1">FailedMount</span></kbd><span class="koboSpan" id="kobo.58.1"> event, since the volume no longer exists:</span></p>
<pre><strong><span class="koboSpan" id="kobo.59.1"># kubectl describe pod secret-access</span><br/><span class="koboSpan" id="kobo.60.1">...</span><br/><span class="koboSpan" id="kobo.61.1">FailedMount  MountVolume.SetUp failed for volume </span><br/><span class="koboSpan" id="kobo.62.1">"kubernetes.io/secret/28889b1d-5015-11e7-9c45-080027cafd37-secret-vol" (spec.Name: "secret-vol") pod "28889b1d-5015-11e7-9c45-080027cafd37" (UID: "28889b1d-5015-11e7-9c45-080027cafd37") with: secrets "mypassword" not found</span><br/><span class="koboSpan" id="kobo.63.1">... </span></strong> </pre>
<p><span class="koboSpan" id="kobo.64.1">If the pod is generated before a secret is created, the pod will encounter failure as well. </span></p>
<p><span class="koboSpan" id="kobo.65.1">We'll now learn how to create a secret using the command line. </span><span class="koboSpan" id="kobo.65.2">We'll briefly introduce its spec format:</span></p>
<pre><strong><span class="koboSpan" id="kobo.66.1">// secret example</span></strong><br/><strong><span class="koboSpan" id="kobo.67.1"># cat 3-2-3_secret.yaml </span></strong><br/><strong><span class="koboSpan" id="kobo.68.1">apiVersion: v1 </span></strong><br/><strong><span class="koboSpan" id="kobo.69.1">kind: Secret </span></strong><br/><strong><span class="koboSpan" id="kobo.70.1">metadata:  </span></strong><br/><strong><span class="koboSpan" id="kobo.71.1">  name: mypassword </span></strong><br/><strong><span class="koboSpan" id="kobo.72.1">type: Opaque </span></strong><br/><strong><span class="koboSpan" id="kobo.73.1">data:  </span></strong><br/><strong><span class="koboSpan" id="kobo.74.1">  mypassword: bXlwYXNzd29yZA==</span></strong></pre>
<p><span class="koboSpan" id="kobo.75.1">Since the spec is plain text, we need to encode the secret by our own </span><kbd><span class="koboSpan" id="kobo.76.1">echo -n &lt;password&gt;</span></kbd> <kbd><span class="koboSpan" id="kobo.77.1">| base64</span></kbd><span class="koboSpan" id="kobo.78.1"> command. </span><span class="koboSpan" id="kobo.78.2">Please note that the type here becomes </span><kbd><span class="koboSpan" id="kobo.79.1">Opaque</span></kbd><span class="koboSpan" id="kobo.80.1">. </span><span class="koboSpan" id="kobo.80.2">This should work in the same way as the one we create via the command line.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Retrieving secrets via environment variables</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Alternatively, we could use environment variables to retrieve secrets, which is more flexible for short credentials, such as a password. </span><span class="koboSpan" id="kobo.2.2">Applications are able to use environment variables to retrieve database passwords without tackling files and volumes:</span></p>
<pre><strong><span class="koboSpan" id="kobo.3.1">// example to use environment variable to retrieve the secret</span><br/><span class="koboSpan" id="kobo.4.1"># cat 3-2-3_pod_ev_secret.yaml</span><br/><span class="koboSpan" id="kobo.5.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.6.1">kind: Pod</span><br/><span class="koboSpan" id="kobo.7.1">metadata:</span><br/><span class="koboSpan" id="kobo.8.1">  name: secret-access-ev</span><br/><span class="koboSpan" id="kobo.9.1">spec:</span><br/><span class="koboSpan" id="kobo.10.1">  containers:</span><br/><span class="koboSpan" id="kobo.11.1">  - name: centos</span><br/><span class="koboSpan" id="kobo.12.1">    image: centos</span><br/><span class="koboSpan" id="kobo.13.1">    command: ["/bin/sh", "-c", "while : ;do echo $MY_PASSWORD; sleep 10; done"]</span><br/><span class="koboSpan" id="kobo.14.1">    env:</span><br/><span class="koboSpan" id="kobo.15.1">       - name: MY_PASSWORD</span><br/><span class="koboSpan" id="kobo.16.1">         valueFrom:</span><br/><span class="koboSpan" id="kobo.17.1">          secretKeyRef:</span><br/><span class="koboSpan" id="kobo.18.1">           name: mypassword</span><br/><span class="koboSpan" id="kobo.19.1">           key: mypassword
</span><br/><span class="koboSpan" id="kobo.20.1">// create the pod </span><br/><span class="koboSpan" id="kobo.21.1"># kubectl create -f 3-2-3_pod_ev_secret.yaml</span><br/><span class="koboSpan" id="kobo.22.1">pod "secret-access-ev" created </span></strong></pre>
<div class="packt_infobox"><span class="koboSpan" id="kobo.23.1">A secret should always be created before the pods that need it. </span><span class="koboSpan" id="kobo.23.2">Otherwise, the pods won't be launched successfully.</span></div>
<p><span class="koboSpan" id="kobo.24.1">The declaration is under </span><kbd><span class="koboSpan" id="kobo.25.1">spec.containers[].env[]</span></kbd><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">We'll need the secret name and the key name. </span><span class="koboSpan" id="kobo.26.3">Both are </span><kbd><span class="koboSpan" id="kobo.27.1">mypassword</span></kbd><span class="koboSpan" id="kobo.28.1"> in this case. </span><span class="koboSpan" id="kobo.28.2">The example should work the same as the one we looked at previously.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">ConfigMap</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">ConfigMap is a resource that allows you to leave your configuration outside a Docker image. </span><span class="koboSpan" id="kobo.2.2">It injects the configuration data as key-value pairs into pods. </span><span class="koboSpan" id="kobo.2.3">Its properties are similar to secrets, but, whereas secrets are used to store sensitive data, such as passwords, ConfigMaps are used to store insensitive configuration data.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Like secrets, ConfigMaps could be based on files, directories, or specified literal value. </span><span class="koboSpan" id="kobo.3.2">They also have a similar syntax to secrets but use </span><kbd><span class="koboSpan" id="kobo.4.1">kubectl create configmap</span></kbd><span class="koboSpan" id="kobo.5.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.6.1">// create configmap</span><br/><span class="koboSpan" id="kobo.7.1"># kubectl create configmap example --from-file=config/app.properties --from-file=config/database.properties</span><br/><span class="koboSpan" id="kobo.8.1">configmap "example" created </span></strong> </pre>
<p><span class="koboSpan" id="kobo.9.1">Since two </span><kbd><span class="koboSpan" id="kobo.10.1">config</span></kbd><span class="koboSpan" id="kobo.11.1"> files are located in the same folder name, </span><kbd><span class="koboSpan" id="kobo.12.1">config</span></kbd><span class="koboSpan" id="kobo.13.1">, we could pass a </span><kbd><span class="koboSpan" id="kobo.14.1">config</span></kbd><span class="koboSpan" id="kobo.15.1"> folder instead of specifying the files one by one. </span><span class="koboSpan" id="kobo.15.2">The equivalent command to the preceding command is </span><kbd><span class="koboSpan" id="kobo.16.1">kubectl create configmap example --from-file=config</span></kbd><span class="koboSpan" id="kobo.17.1"> in this case.</span></p>
<p><span class="koboSpan" id="kobo.18.1">If we describe the ConfigMap, it'll show the current information:</span></p>
<pre><strong><span class="koboSpan" id="kobo.19.1">// check out detailed information for configmap</span><br/><span class="koboSpan" id="kobo.20.1"># kubectl describe configmap example</span><br/><span class="koboSpan" id="kobo.21.1">Name:    example</span><br/><span class="koboSpan" id="kobo.22.1">Namespace:  default</span><br/><span class="koboSpan" id="kobo.23.1">Labels:    &lt;none&gt;</span><br/><span class="koboSpan" id="kobo.24.1">Annotations:  &lt;none&gt;
</span><br/><span class="koboSpan" id="kobo.25.1">Data</span><br/><span class="koboSpan" id="kobo.26.1">====</span><br/><span class="koboSpan" id="kobo.27.1">app.properties:</span><br/><span class="koboSpan" id="kobo.28.1">----</span><br/><span class="koboSpan" id="kobo.29.1">name=DevOps-with-Kubernetes</span><br/><span class="koboSpan" id="kobo.30.1">port=4420
</span><br/><span class="koboSpan" id="kobo.31.1">database.properties:</span><br/><span class="koboSpan" id="kobo.32.1">----</span><br/><span class="koboSpan" id="kobo.33.1">endpoint=k8s.us-east-1.rds.amazonaws.com</span><br/><span class="koboSpan" id="kobo.34.1">port=1521</span></strong></pre>
<p><span class="koboSpan" id="kobo.35.1">We could use </span><kbd><span class="koboSpan" id="kobo.36.1">kubectl edit configmap</span></kbd> <kbd><span class="koboSpan" id="kobo.37.1">&lt;configmap_name&gt;</span></kbd><span class="koboSpan" id="kobo.38.1"> to update the configuration after creation.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.39.1">We also could use </span><kbd><span class="koboSpan" id="kobo.40.1">literal</span></kbd><span class="koboSpan" id="kobo.41.1"> as the input. </span><span class="koboSpan" id="kobo.41.2">The equivalent commands for the preceding example would be </span><kbd><span class="koboSpan" id="kobo.42.1">kubectl create configmap example --from-literal=app.properties.name=name=DevOps-with-Kubernetes</span></kbd><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">This isn't always very practical when we have many configurations in an app.</span></div>
<p><span class="koboSpan" id="kobo.44.1">Let's see how to use this inside a pod. </span><span class="koboSpan" id="kobo.44.2">There are two ways to use ConfigMap inside a pod: by volume or environment variables.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using ConfigMap via volume</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Similar to previous examples in the </span><em><span class="koboSpan" id="kobo.3.1">Secrets</span></em><span class="koboSpan" id="kobo.4.1"> subsection, we mount a volume with </span><kbd><span class="koboSpan" id="kobo.5.1">configmap</span></kbd><span class="koboSpan" id="kobo.6.1"> </span><span><span class="koboSpan" id="kobo.7.1">syntax</span></span><span><span class="koboSpan" id="kobo.8.1"> and add</span></span> <kbd><span class="koboSpan" id="kobo.9.1">volumeMounts</span></kbd> <span><span class="koboSpan" id="kobo.10.1">inside a container template. </span><span class="koboSpan" id="kobo.10.2">The command in</span></span> <kbd><span class="koboSpan" id="kobo.11.1">centos</span></kbd> <span><span class="koboSpan" id="kobo.12.1">will loop to</span></span> <kbd><span class="koboSpan" id="kobo.13.1">cat ${MOUNTPOINT}/$CONFIG_FILENAME</span></kbd><span><span class="koboSpan" id="kobo.14.1">:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.15.1">cat 3-2-3_pod_vol_configmap.yaml</span><br/><span class="koboSpan" id="kobo.16.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.17.1">kind: Pod</span><br/><span class="koboSpan" id="kobo.18.1">metadata:</span><br/><span class="koboSpan" id="kobo.19.1">  name: configmap-vol</span><br/><span class="koboSpan" id="kobo.20.1">spec:</span><br/><span class="koboSpan" id="kobo.21.1">  containers:</span><br/><span class="koboSpan" id="kobo.22.1">    - name: configmap</span><br/><span class="koboSpan" id="kobo.23.1">      image: centos</span><br/><span class="koboSpan" id="kobo.24.1">      command: ["/bin/sh", "-c", "while : ;do cat /src/app/config/database.properties; sleep 10; done"]</span><br/><span class="koboSpan" id="kobo.25.1">      volumeMounts:</span><br/><span class="koboSpan" id="kobo.26.1">        - name: config-volume</span><br/><span class="koboSpan" id="kobo.27.1">          mountPath: /src/app/config</span><br/><span class="koboSpan" id="kobo.28.1">  volumes:</span><br/><span class="koboSpan" id="kobo.29.1">    - name: config-volume</span><br/><span class="koboSpan" id="kobo.30.1">      configMap:</span><br/><span class="koboSpan" id="kobo.31.1">        name: example
</span><br/><span class="koboSpan" id="kobo.32.1">// create configmap</span><br/><span class="koboSpan" id="kobo.33.1"># kubectl create -f 3-2-3_pod_vol_configmap.yaml</span><br/><span class="koboSpan" id="kobo.34.1">pod "configmap-vol" created
</span><br/><span class="koboSpan" id="kobo.35.1">// check out the logs</span><br/><span class="koboSpan" id="kobo.36.1"># kubectl logs -f configmap-vol</span><br/><span class="koboSpan" id="kobo.37.1">endpoint=k8s.us-east-1.rds.amazonaws.com</span><br/><span class="koboSpan" id="kobo.38.1">port=1521 </span></strong> </pre>
<p><span class="koboSpan" id="kobo.39.1">We then could use this method to inject our non-sensitive configuration into the pod.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using ConfigMap via environment variables</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To use ConfigMap inside a pod, you'll have to use </span><kbd><span class="koboSpan" id="kobo.3.1">configMapKeyRef</span></kbd><span class="koboSpan" id="kobo.4.1"> as the value source in the </span><kbd><span class="koboSpan" id="kobo.5.1">env</span></kbd><span class="koboSpan" id="kobo.6.1"> section. </span><span class="koboSpan" id="kobo.6.2">This will populate whole ConfigMap pairs to environment variables:</span></p>
<pre><strong><span class="koboSpan" id="kobo.7.1"># cat 3-2-3_pod_ev_configmap.yaml</span><br/><span class="koboSpan" id="kobo.8.1">apiVersion: v1</span></strong><br/><strong><span class="koboSpan" id="kobo.9.1">kind: Pod</span></strong><br/><strong><span class="koboSpan" id="kobo.10.1">metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.11.1">  name: configmap-ev</span></strong><br/><strong><span class="koboSpan" id="kobo.12.1">spec:</span></strong><br/><strong><span class="koboSpan" id="kobo.13.1">  containers:</span></strong><br/><strong><span class="koboSpan" id="kobo.14.1">    - name: configmap</span></strong><br/><strong><span class="koboSpan" id="kobo.15.1">      image: centos</span></strong><br/><strong><span class="koboSpan" id="kobo.16.1">      command: ["/bin/sh", "-c", "while : ;do echo $DATABASE_ENDPOINT; sleep 10; done"]</span></strong><br/><strong><span class="koboSpan" id="kobo.17.1">      env:</span></strong><br/><strong><span class="koboSpan" id="kobo.18.1">        - name: DATABASE_ENDPOINT</span></strong><br/><strong><span class="koboSpan" id="kobo.19.1">          valueFrom:</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">            configMapKeyRef:</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">              name: example</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">              key: database.properties</span></strong><br/><strong><span class="koboSpan" id="kobo.23.1">// create configmap</span></strong><br/><strong><span class="koboSpan" id="kobo.24.1"># kubectl create -f 3-2-3_pod_ev_configmap.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.25.1">pod/configmap-ev created</span></strong><br/><strong><span class="koboSpan" id="kobo.26.1">// check out the logs</span></strong><br/><strong><span class="koboSpan" id="kobo.27.1"># kubectl logs configmap-ev</span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">endpoint=k8s.us-east-1.rds.amazonaws.com port=1521</span></strong></pre>
<p><span class="koboSpan" id="kobo.29.1">The Kubernetes system itself also uses ConfigMap to do some authentication. </span><span class="koboSpan" id="kobo.29.2">Check out the system ConfigMap by adding </span><kbd><span class="koboSpan" id="kobo.30.1">--namespace=kube-system</span></kbd><span class="koboSpan" id="kobo.31.1"> in the </span><kbd><span class="koboSpan" id="kobo.32.1">kubectl describe configmap</span></kbd><span class="koboSpan" id="kobo.33.1"> command.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Multi-container orchestration</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this section, we'll revisit our ticketing service: a kiosk web service as a frontend that provides an interface for get/put tickets. </span><span class="koboSpan" id="kobo.2.2">There is a Redis acting as cache to manage how many tickets we have. </span><span class="koboSpan" id="kobo.2.3">Redis also acts as a publisher/subscriber channel. </span><span class="koboSpan" id="kobo.2.4">Once a ticket is sold, the kiosk will publish an event into it. </span><span class="koboSpan" id="kobo.2.5">The subscriber is called recorder and will write a timestamp and record it to the MySQL database. </span><span class="koboSpan" id="kobo.2.6">Please refer to the last section in </span><a href="05e2d0b4-0e70-4480-b5a0-f3860ddb24f2.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.3.1">Chapter 2</span></span></a><span class="koboSpan" id="kobo.4.1">, </span><em><span class="koboSpan" id="kobo.5.1">DevOps with Containers</span></em><span class="koboSpan" id="kobo.6.1">, for a detailed Dockerfile and Docker compose implementation. </span><span class="koboSpan" id="kobo.6.2">We'll use </span><kbd><span class="koboSpan" id="kobo.7.1">Deployment</span></kbd><span class="koboSpan" id="kobo.8.1">, </span><kbd><span class="koboSpan" id="kobo.9.1">Service</span></kbd><span class="koboSpan" id="kobo.10.1">, </span><kbd><span class="koboSpan" id="kobo.11.1">Secret</span></kbd><span class="koboSpan" id="kobo.12.1">, </span><kbd><span class="koboSpan" id="kobo.13.1">Volume</span></kbd><span class="koboSpan" id="kobo.14.1">, and </span><kbd><span class="koboSpan" id="kobo.15.1">ConfigMap</span></kbd><span class="koboSpan" id="kobo.16.1"> objects to implement this example in Kubernetes. </span><span class="koboSpan" id="kobo.16.2">The source code can be found at the following link: </span><a href="https://github.com/DevOps-with-Kubernetes/examples/tree/master/chapter3/3-3_kiosk" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.17.1">https://github.com/DevOps-with-Kubernetes/examples/tree/master/chapter3/3-3_kiosk</span></span></a><span class="koboSpan" id="kobo.18.1">.</span></p>
<p><span><span><span class="koboSpan" id="kobo.19.1">The service architecture with Kubernetes resources is shown in the following diagram:</span></span></span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.20.1"><img src="assets/c0837b43-ba18-449e-becf-62a3c83c5913.png" style="width:49.25em;height:28.83em;"/></span></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref"><span class="koboSpan" id="kobo.21.1">An example of a kiosk in the Kubernetes world</span></div>
<p><span class="koboSpan" id="kobo.22.1">We'll need four kinds of pods. </span><span class="koboSpan" id="kobo.22.2">Deployment is the best choice to manage or deploy the pods. </span><span class="koboSpan" id="kobo.22.3">This will reduce the effort required when we carry out deployments in the future thanks to its deployment strategy feature. </span><span class="koboSpan" id="kobo.22.4">Since the kiosk, Redis, and MySQL will be accessed by other components, we'll associate services to their pods. </span><span class="koboSpan" id="kobo.22.5">MySQL acts as a datastore and, for simplicity, we'll mount a local volume to it. </span><span class="koboSpan" id="kobo.22.6">Note that Kubernetes offers a bunch of choices. </span><span class="koboSpan" id="kobo.22.7">Check out the details and examples in </span><span class="ChapterrefPACKT"><a href="c3083748-0f68-488f-87e0-f8c61deeeb80.xhtml"><span class="koboSpan" id="kobo.23.1">Chapter 4</span></a><span class="koboSpan" id="kobo.24.1">,</span></span> <em><span class="koboSpan" id="kobo.25.1">Managing Stateful Workload</span></em><span class="koboSpan" id="kobo.26.1">s. </span><span class="koboSpan" id="kobo.26.2">We'll want to store sensitive information such as our MySQL root and user password in secrets. </span><span class="koboSpan" id="kobo.26.3">The other insensitive configuration, such as the DB name or username, we'll leave to ConfigMap.</span></p>
<p><span class="koboSpan" id="kobo.27.1">We'll launch MySQL first, as the recorder depends on it. </span><span class="koboSpan" id="kobo.27.2">Before creating MySQL, we'll have to create a corresponding </span><kbd><span class="koboSpan" id="kobo.28.1">secret</span></kbd><span class="koboSpan" id="kobo.29.1"> and </span><kbd><span class="koboSpan" id="kobo.30.1">ConfigMap</span></kbd><span class="koboSpan" id="kobo.31.1"> first. </span><span class="koboSpan" id="kobo.31.2">To create a </span><kbd><span class="koboSpan" id="kobo.32.1">secret</span></kbd><span class="koboSpan" id="kobo.33.1">, we need to generate </span><kbd><span class="koboSpan" id="kobo.34.1">base64</span></kbd><span class="koboSpan" id="kobo.35.1"> encrypted data:</span></p>
<pre><strong><span class="koboSpan" id="kobo.36.1">// generate base64 secret for MYSQL_PASSWORD and MYSQL_ROOT_PASSWORD</span><br/><span class="koboSpan" id="kobo.37.1"># echo -n "pass" | base64</span><br/><span class="koboSpan" id="kobo.38.1">cGFzcw==</span><br/><span class="koboSpan" id="kobo.39.1"># echo -n "mysqlpass" | base64</span><br/><span class="koboSpan" id="kobo.40.1">bXlzcWxwYXNz</span></strong></pre>
<p><span class="koboSpan" id="kobo.41.1">Then, we're able to create the secret:</span></p>
<pre><strong><span class="koboSpan" id="kobo.42.1"># cat secret.yaml</span><br/><span class="koboSpan" id="kobo.43.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.44.1">kind: Secret</span><br/><span class="koboSpan" id="kobo.45.1">metadata:</span><br/><span class="koboSpan" id="kobo.46.1">  name: mysql-user</span><br/><span class="koboSpan" id="kobo.47.1">type: Opaque</span><br/><span class="koboSpan" id="kobo.48.1">data:</span><br/><span class="koboSpan" id="kobo.49.1">  password: cGFzcw==
</span><br/><span class="koboSpan" id="kobo.50.1">---</span><br/><span class="koboSpan" id="kobo.51.1"># MYSQL_ROOT_PASSWORD</span><br/><span class="koboSpan" id="kobo.52.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.53.1">kind: Secret</span><br/><span class="koboSpan" id="kobo.54.1">metadata:</span><br/><span class="koboSpan" id="kobo.55.1">  name: mysql-root</span><br/><span class="koboSpan" id="kobo.56.1">type: Opaque</span><br/><span class="koboSpan" id="kobo.57.1">data:</span><br/><span class="koboSpan" id="kobo.58.1">  password: bXlzcWxwYXNz
</span><br/><span class="koboSpan" id="kobo.59.1">// create mysql secret</span><br/><span class="koboSpan" id="kobo.60.1"># kubectl create -f secret.yaml --record</span><br/><span class="koboSpan" id="kobo.61.1">secret "mysql-user" created</span><br/><span class="koboSpan" id="kobo.62.1">secret "mysql-root" created</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.63.1">After that, we come to our ConfigMap. </span><span class="koboSpan" id="kobo.63.2">Here, we put the database user and the database name as an example:</span></p>
<pre><strong><span class="koboSpan" id="kobo.64.1"># cat config.yaml</span><br/><span class="koboSpan" id="kobo.65.1">kind: ConfigMap</span><br/><span class="koboSpan" id="kobo.66.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.67.1">metadata:</span><br/><span class="koboSpan" id="kobo.68.1">  name: mysql-config</span><br/><span class="koboSpan" id="kobo.69.1">data:</span><br/><span class="koboSpan" id="kobo.70.1">  user: user</span><br/><span class="koboSpan" id="kobo.71.1">  database: db
</span><br/><span class="koboSpan" id="kobo.72.1">// create ConfigMap</span><br/><span class="koboSpan" id="kobo.73.1"># kubectl create -f config.yaml --record</span><br/><span class="koboSpan" id="kobo.74.1">configmap "mysql-config" created</span><br/><br/></strong></pre>
<p><span class="koboSpan" id="kobo.75.1">It's then time to launch MySQL and its service:</span></p>
<pre><strong><span class="koboSpan" id="kobo.76.1"># cat mysql.yaml</span><br/><span class="koboSpan" id="kobo.77.1">apiVersion: apps/v1</span><br/><span class="koboSpan" id="kobo.78.1">kind: Deployment</span><br/><span class="koboSpan" id="kobo.79.1">metadata:</span><br/><span class="koboSpan" id="kobo.80.1">  name: lmysql</span><br/><span class="koboSpan" id="kobo.81.1">spec:</span><br/><span class="koboSpan" id="kobo.82.1">  replicas: 1</span><br/><span class="koboSpan" id="kobo.83.1">  selector:</span><br/><span class="koboSpan" id="kobo.84.1">    matchLabels:</span><br/><span class="koboSpan" id="kobo.85.1">      tier: database</span><br/><span class="koboSpan" id="kobo.86.1">      version: "5.7"</span><br/><span class="koboSpan" id="kobo.87.1">  template:</span><br/><span class="koboSpan" id="kobo.88.1">    metadata:</span><br/><span class="koboSpan" id="kobo.89.1">      labels:</span><br/><span class="koboSpan" id="kobo.90.1">        tier: database</span><br/><span class="koboSpan" id="kobo.91.1">        version: "5.7"</span><br/><span class="koboSpan" id="kobo.92.1">    spec:</span><br/><span class="koboSpan" id="kobo.93.1">      containers:</span><br/><span class="koboSpan" id="kobo.94.1">      - name: lmysql</span><br/><span class="koboSpan" id="kobo.95.1">        image: mysql:5.7</span><br/><span class="koboSpan" id="kobo.96.1">        volumeMounts:</span><br/><span class="koboSpan" id="kobo.97.1">          - mountPath: /var/lib/mysql</span><br/><span class="koboSpan" id="kobo.98.1">            name: mysql-vol</span><br/><span class="koboSpan" id="kobo.99.1">        ports:</span><br/><span class="koboSpan" id="kobo.100.1">        - containerPort: 3306</span><br/><span class="koboSpan" id="kobo.101.1">        env:</span><br/><span class="koboSpan" id="kobo.102.1">        - name: MYSQL_ROOT_PASSWORD</span><br/><span class="koboSpan" id="kobo.103.1">          valueFrom:</span><br/><span class="koboSpan" id="kobo.104.1">            secretKeyRef:</span><br/><span class="koboSpan" id="kobo.105.1">              name: mysql-root</span><br/><span class="koboSpan" id="kobo.106.1">              key: password</span><br/><span class="koboSpan" id="kobo.107.1">        - name: MYSQL_DATABASE</span><br/><span class="koboSpan" id="kobo.108.1">          valueFrom:</span><br/><span class="koboSpan" id="kobo.109.1">            configMapKeyRef:</span><br/><span class="koboSpan" id="kobo.110.1">              name: mysql-config</span><br/><span class="koboSpan" id="kobo.111.1">              key: database</span><br/><span class="koboSpan" id="kobo.112.1">        - name: MYSQL_USER</span><br/><span class="koboSpan" id="kobo.113.1">          valueFrom:</span><br/><span class="koboSpan" id="kobo.114.1">            configMapKeyRef:</span><br/><span class="koboSpan" id="kobo.115.1">              name: mysql-config</span><br/><span class="koboSpan" id="kobo.116.1">              key: user</span><br/><span class="koboSpan" id="kobo.117.1">        - name: MYSQL_PASSWORD</span><br/><span class="koboSpan" id="kobo.118.1">          valueFrom:</span><br/><span class="koboSpan" id="kobo.119.1">            secretKeyRef:</span><br/><span class="koboSpan" id="kobo.120.1">              name: mysql-user</span><br/><span class="koboSpan" id="kobo.121.1">              key: password</span><br/><span class="koboSpan" id="kobo.122.1">      volumes:</span><br/><span class="koboSpan" id="kobo.123.1">      - name: mysql-vol</span><br/><span class="koboSpan" id="kobo.124.1">        hostPath:</span><br/><span class="koboSpan" id="kobo.125.1">          path: /mysql/data</span><br/><span class="koboSpan" id="kobo.126.1">  minReadySeconds: 10</span><br/><span class="koboSpan" id="kobo.127.1">  strategy:</span><br/><span class="koboSpan" id="kobo.128.1">    type: RollingUpdate</span><br/><span class="koboSpan" id="kobo.129.1">    rollingUpdate:</span><br/><span class="koboSpan" id="kobo.130.1">      maxSurge: 1</span><br/><span class="koboSpan" id="kobo.131.1">      maxUnavailable: 1</span><br/><span class="koboSpan" id="kobo.132.1">---</span><br/><span class="koboSpan" id="kobo.133.1">kind: Service</span><br/><span class="koboSpan" id="kobo.134.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.135.1">metadata:</span><br/><span class="koboSpan" id="kobo.136.1">  name: lmysql-service</span><br/><span class="koboSpan" id="kobo.137.1">spec:</span><br/><span class="koboSpan" id="kobo.138.1">  selector:</span><br/><span class="koboSpan" id="kobo.139.1">    tier: database</span><br/><span class="koboSpan" id="kobo.140.1">  ports:</span><br/><span class="koboSpan" id="kobo.141.1">    - protocol: TCP</span><br/><span class="koboSpan" id="kobo.142.1">      port: 3306</span><br/><span class="koboSpan" id="kobo.143.1">      targetPort: 3306</span><br/><span class="koboSpan" id="kobo.144.1">      name: tcp3306
</span></strong></pre>
<p><span class="koboSpan" id="kobo.145.1">We can put more than one spec into a file by adding three dashes as separation. </span><span class="koboSpan" id="kobo.145.2">Here, we mount </span><kbd><span class="koboSpan" id="kobo.146.1">hostPath /mysql/data</span></kbd><span class="koboSpan" id="kobo.147.1"> into pods with the path </span><kbd><span class="koboSpan" id="kobo.148.1">/var/lib/mysql</span></kbd><span class="koboSpan" id="kobo.149.1">. </span><span class="koboSpan" id="kobo.149.2">In the environment section, we use the secret and ConfigMap syntax with </span><kbd><span class="koboSpan" id="kobo.150.1">secretKeyRef</span></kbd><span class="koboSpan" id="kobo.151.1"> and </span><kbd><span class="koboSpan" id="kobo.152.1">configMapKeyRef</span></kbd><span class="koboSpan" id="kobo.153.1">.</span></p>
<p><span class="koboSpan" id="kobo.154.1">After creating MySQL, Redis would be the next best candidate, s</span><span><span class="koboSpan" id="kobo.155.1">ince other services are dependent on it but it doesn't have any prerequisites:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.156.1">// create Redis deployment </span><br/><span class="koboSpan" id="kobo.157.1"># cat redis.yaml</span><br/><span class="koboSpan" id="kobo.158.1">apiVersion: apps/v1</span><br/><span class="koboSpan" id="kobo.159.1">kind: Deployment</span><br/><span class="koboSpan" id="kobo.160.1">metadata:</span><br/><span class="koboSpan" id="kobo.161.1">  name: lcredis</span><br/><span class="koboSpan" id="kobo.162.1">spec:</span><br/><span class="koboSpan" id="kobo.163.1">  replicas: 1</span><br/><span class="koboSpan" id="kobo.164.1">  selector:</span><br/><span class="koboSpan" id="kobo.165.1">    matchLabels:</span><br/><span class="koboSpan" id="kobo.166.1">      tier: cache</span><br/><span class="koboSpan" id="kobo.167.1">      version: "3.0"</span><br/><span class="koboSpan" id="kobo.168.1">  template:</span><br/><span class="koboSpan" id="kobo.169.1">    metadata:</span><br/><span class="koboSpan" id="kobo.170.1">      labels:</span><br/><span class="koboSpan" id="kobo.171.1">        tier: cache</span><br/><span class="koboSpan" id="kobo.172.1">        version: "3.0"</span><br/><span class="koboSpan" id="kobo.173.1">    spec:</span><br/><span class="koboSpan" id="kobo.174.1">      containers:</span><br/><span class="koboSpan" id="kobo.175.1">      - name: lcredis</span><br/><span class="koboSpan" id="kobo.176.1">        image: redis:3.0</span><br/><span class="koboSpan" id="kobo.177.1">        ports:</span><br/><span class="koboSpan" id="kobo.178.1">        - containerPort: 6379</span><br/><span class="koboSpan" id="kobo.179.1">  minReadySeconds: 1</span><br/><span class="koboSpan" id="kobo.180.1">  strategy:</span><br/><span class="koboSpan" id="kobo.181.1">    type: RollingUpdate</span><br/><span class="koboSpan" id="kobo.182.1">    rollingUpdate:</span><br/><span class="koboSpan" id="kobo.183.1">      maxSurge: 1</span><br/><span class="koboSpan" id="kobo.184.1">      maxUnavailable: 1</span><br/><span class="koboSpan" id="kobo.185.1">---</span><br/><span class="koboSpan" id="kobo.186.1">kind: Service</span><br/><span class="koboSpan" id="kobo.187.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.188.1">metadata:</span><br/><span class="koboSpan" id="kobo.189.1">  name: lcredis-service</span><br/><span class="koboSpan" id="kobo.190.1">spec:</span><br/><span class="koboSpan" id="kobo.191.1">  selector:</span><br/><span class="koboSpan" id="kobo.192.1">    tier: cache</span><br/><span class="koboSpan" id="kobo.193.1">  ports:</span><br/><span class="koboSpan" id="kobo.194.1">    - protocol: TCP</span><br/><span class="koboSpan" id="kobo.195.1">      port: 6379</span><br/><span class="koboSpan" id="kobo.196.1">      targetPort: 6379</span><br/><span class="koboSpan" id="kobo.197.1">      name: tcp6379</span></strong>
<br/><strong><span class="koboSpan" id="kobo.198.1">// create redis deployements and service</span><br/><span class="koboSpan" id="kobo.199.1"># kubectl create -f redis.yaml</span><br/><span class="koboSpan" id="kobo.200.1">deployment "lcredis" created</span><br/><span class="koboSpan" id="kobo.201.1">service "lcredis-service" created</span></strong></pre>
<p><span class="koboSpan" id="kobo.202.1">It would then be a good time to start the kiosk:</span></p>
<pre><strong><span class="koboSpan" id="kobo.203.1"># cat kiosk-example.yaml</span><br/><span class="koboSpan" id="kobo.204.1">apiVersion: apps/v1</span></strong><br/><strong><span class="koboSpan" id="kobo.205.1">kind: Deployment</span><br/><span class="koboSpan" id="kobo.206.1">metadata:</span><br/><span class="koboSpan" id="kobo.207.1">  name: kiosk-example</span><br/><span class="koboSpan" id="kobo.208.1">spec:</span><br/><span class="koboSpan" id="kobo.209.1">  replicas: 5</span><br/><span class="koboSpan" id="kobo.210.1">  selector:</span><br/><span class="koboSpan" id="kobo.211.1">    matchLabels:</span><br/><span class="koboSpan" id="kobo.212.1">      tier: frontend</span><br/><span class="koboSpan" id="kobo.213.1">      version: "3"</span><br/><span class="koboSpan" id="kobo.214.1">  template:</span><br/><span class="koboSpan" id="kobo.215.1">    metadata:</span><br/><span class="koboSpan" id="kobo.216.1">      labels:</span><br/><span class="koboSpan" id="kobo.217.1">        tier: frontend</span><br/><span class="koboSpan" id="kobo.218.1">        version: "3"</span><br/><span class="koboSpan" id="kobo.219.1">      annotations:</span><br/><span class="koboSpan" id="kobo.220.1">        maintainer: cywu</span><br/><span class="koboSpan" id="kobo.221.1">    spec:</span><br/><span class="koboSpan" id="kobo.222.1">      containers:</span><br/><span class="koboSpan" id="kobo.223.1">      - name: kiosk-example</span><br/><span class="koboSpan" id="kobo.224.1">        image: devopswithkubernetes/kiosk-example</span><br/><span class="koboSpan" id="kobo.225.1">        ports:</span><br/><span class="koboSpan" id="kobo.226.1">        - containerPort: 5000</span><br/><span class="koboSpan" id="kobo.227.1">        env:</span><br/><span class="koboSpan" id="kobo.228.1">        - name: REDIS_HOST</span><br/><span class="koboSpan" id="kobo.229.1">          value: lcredis-service.default</span><br/><span class="koboSpan" id="kobo.230.1">  minReadySeconds: 5</span><br/><span class="koboSpan" id="kobo.231.1">  strategy:</span><br/><span class="koboSpan" id="kobo.232.1">    type: RollingUpdate</span><br/><span class="koboSpan" id="kobo.233.1">    rollingUpdate:</span><br/><span class="koboSpan" id="kobo.234.1">      maxSurge: 1</span><br/><span class="koboSpan" id="kobo.235.1">      maxUnavailable: 1</span><br/><span class="koboSpan" id="kobo.236.1">---</span><br/><span class="koboSpan" id="kobo.237.1">kind: Service</span><br/><span class="koboSpan" id="kobo.238.1">apiVersion: v1</span><br/><span class="koboSpan" id="kobo.239.1">metadata:</span><br/><span class="koboSpan" id="kobo.240.1">  name: kiosk-service</span><br/><span class="koboSpan" id="kobo.241.1">spec:</span><br/><span class="koboSpan" id="kobo.242.1">  type: NodePort</span><br/><span class="koboSpan" id="kobo.243.1">  selector:</span><br/><span class="koboSpan" id="kobo.244.1">    tier: frontend</span><br/><span class="koboSpan" id="kobo.245.1">  ports:</span><br/><span class="koboSpan" id="kobo.246.1">    - protocol: TCP</span><br/><span class="koboSpan" id="kobo.247.1">      port: 80</span><br/><span class="koboSpan" id="kobo.248.1">      targetPort: 5000</span><br/><span class="koboSpan" id="kobo.249.1">      name: tcp5000</span><br/></strong>
<strong><span class="koboSpan" id="kobo.250.1">// launch the spec</span><br/><span class="koboSpan" id="kobo.251.1"> # kubectl create -f kiosk-example.yaml</span><br/><span class="koboSpan" id="kobo.252.1"> deployment "kiosk-example" created</span><br/><span class="koboSpan" id="kobo.253.1"> service "kiosk-service" created </span></strong></pre>
<p><span class="koboSpan" id="kobo.254.1">Here, we expose </span><kbd><span class="koboSpan" id="kobo.255.1">lcredis-service.default</span></kbd><span class="koboSpan" id="kobo.256.1"> to environment variables to kiosk pods. </span><span class="koboSpan" id="kobo.256.2">This is the DNS name that kube-dns creates for </span><kbd><span class="koboSpan" id="kobo.257.1">Service</span></kbd><span class="koboSpan" id="kobo.258.1"> objects (referred to as Services in this chapter). </span><span class="koboSpan" id="kobo.258.2">Hence, the kiosk can access the Redis host via environment variables.</span></p>
<p><span class="koboSpan" id="kobo.259.1">In the end, we'll create a recorder. </span><span class="koboSpan" id="kobo.259.2">This doesn't expose any interface to others, so it doesn't need a </span><kbd><span class="koboSpan" id="kobo.260.1">Service</span></kbd><span class="koboSpan" id="kobo.261.1"> object:</span></p>
<pre><strong><span class="koboSpan" id="kobo.262.1"># cat recorder-example.yaml</span><br/><span class="koboSpan" id="kobo.263.1">apiVersion: apps/v1</span><br/><span class="koboSpan" id="kobo.264.1">kind: Deployment</span><br/><span class="koboSpan" id="kobo.265.1">metadata:</span><br/><span class="koboSpan" id="kobo.266.1">  name: recorder-example</span><br/><span class="koboSpan" id="kobo.267.1">spec:</span><br/><span class="koboSpan" id="kobo.268.1">  replicas: 3</span><br/><span class="koboSpan" id="kobo.269.1">  selector:</span><br/><span class="koboSpan" id="kobo.270.1">    matchLabels:</span><br/><span class="koboSpan" id="kobo.271.1">        tier: backend</span><br/><span class="koboSpan" id="kobo.272.1">        version: "3"</span><br/><span class="koboSpan" id="kobo.273.1">  template:</span><br/><span class="koboSpan" id="kobo.274.1">    metadata:</span><br/><span class="koboSpan" id="kobo.275.1">      labels:</span><br/><span class="koboSpan" id="kobo.276.1">        tier: backend</span><br/><span class="koboSpan" id="kobo.277.1">        version: "3"</span><br/><span class="koboSpan" id="kobo.278.1">      annotations:</span><br/><span class="koboSpan" id="kobo.279.1">        maintainer: cywu</span><br/><span class="koboSpan" id="kobo.280.1">    spec:</span><br/><span class="koboSpan" id="kobo.281.1">      containers:</span><br/><span class="koboSpan" id="kobo.282.1">      - name: recorder-example</span><br/><span class="koboSpan" id="kobo.283.1">        image: devopswithkubernetes/recorder-example</span><br/><span class="koboSpan" id="kobo.284.1">        env:</span><br/><span class="koboSpan" id="kobo.285.1">        - name: REDIS_HOST</span><br/><span class="koboSpan" id="kobo.286.1">          value: lcredis-service.default</span><br/><span class="koboSpan" id="kobo.287.1">        - name: MYSQL_HOST</span><br/><span class="koboSpan" id="kobo.288.1">          value: lmysql-service.default</span><br/><span class="koboSpan" id="kobo.289.1">        - name: MYSQL_USER</span><br/><span class="koboSpan" id="kobo.290.1">          value: root</span><br/><span class="koboSpan" id="kobo.291.1">        - name: MYSQL_ROOT_PASSWORD</span><br/><span class="koboSpan" id="kobo.292.1">          valueFrom:</span><br/><span class="koboSpan" id="kobo.293.1">            secretKeyRef:</span><br/><span class="koboSpan" id="kobo.294.1">              name: mysql-root</span><br/><span class="koboSpan" id="kobo.295.1">              key: password</span><br/><span class="koboSpan" id="kobo.296.1">  minReadySeconds: 3</span><br/><span class="koboSpan" id="kobo.297.1">  strategy:</span><br/><span class="koboSpan" id="kobo.298.1">    type: RollingUpdate</span><br/><span class="koboSpan" id="kobo.299.1">    rollingUpdate:</span><br/><span class="koboSpan" id="kobo.300.1">      maxSurge: 1</span><br/><span class="koboSpan" id="kobo.301.1">      maxUnavailable: 1</span></strong>
<br/><strong><span class="koboSpan" id="kobo.302.1">// create recorder deployment</span><br/><span class="koboSpan" id="kobo.303.1"> # kubectl create -f recorder-example.yaml</span><br/><span class="koboSpan" id="kobo.304.1"> deployment "recorder-example" created </span></strong></pre>
<p><span class="koboSpan" id="kobo.305.1">The recorder needs to access both Redis and MySQL. </span><span class="koboSpan" id="kobo.305.2">It uses root credentials that are injected via a secret. </span><span class="koboSpan" id="kobo.305.3">Both endpoints for Redis and MySQL are accessed via a service DNS name, </span><kbd><span class="koboSpan" id="kobo.306.1">&lt;service_name&gt;.&lt;namespace&gt;</span></kbd><span class="koboSpan" id="kobo.307.1">.</span></p>
<p><span class="koboSpan" id="kobo.308.1">We could </span><span><span class="koboSpan" id="kobo.309.1">then </span></span><span><span class="koboSpan" id="kobo.310.1">check the </span></span><kbd><span class="koboSpan" id="kobo.311.1">Deployment</span></kbd> <span><span class="koboSpan" id="kobo.312.1">objects:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.313.1">// check deployment details</span><br/><span class="koboSpan" id="kobo.314.1"># kubectl get deployments</span><br/><span class="koboSpan" id="kobo.315.1">NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br/><span class="koboSpan" id="kobo.316.1">kiosk-example      5         5         5            5           1h</span><br/><span class="koboSpan" id="kobo.317.1">lcredis            1         1         1            1           1h</span><br/><span class="koboSpan" id="kobo.318.1">lmysql             1         1         1            1           1h</span><br/><span class="koboSpan" id="kobo.319.1">recorder-example   3         3         3            3           1h  </span></strong></pre>
<p><span class="koboSpan" id="kobo.320.1">As expected, we have four </span><kbd><span class="koboSpan" id="kobo.321.1">Deployment</span></kbd><span class="koboSpan" id="kobo.322.1"> objects with a different desired count of pods.</span></p>
<p><span class="koboSpan" id="kobo.323.1">As we expose the kiosk as a NodePort, we should be able to access its service endpoint and see whether it works properly. </span><span class="koboSpan" id="kobo.323.2">Assume we have a node, the IP of which is </span><kbd><span class="koboSpan" id="kobo.324.1">192.168.99.100</span></kbd><span class="koboSpan" id="kobo.325.1">, and the NodePort that Kubernetes allocates is </span><kbd><span class="koboSpan" id="kobo.326.1">30520</span></kbd><span class="koboSpan" id="kobo.327.1">.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.328.1">If you're using minikube, </span><kbd><span class="koboSpan" id="kobo.329.1">minikube service [-n NAMESPACE] [--url] NAME</span></kbd><span class="koboSpan" id="kobo.330.1"> could help you access service NodePort via your default browser:
</span><p><kbd><strong><span class="koboSpan" id="kobo.331.1">// open kiosk console</span></strong></kbd></p>
<p><kbd><strong><span class="koboSpan" id="kobo.332.1"># minikube service kiosk-service</span></strong></kbd></p>
<p><kbd><strong><span class="koboSpan" id="kobo.333.1">Opening kubernetes service default/kiosk-service in default browser...</span></strong></kbd></p>
<p><span><span class="koboSpan" id="kobo.334.1">This will allow us to find out the IP and the port.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.335.1">We could then create and get a ticket using </span><kbd><span class="koboSpan" id="kobo.336.1">POST</span></kbd><span class="koboSpan" id="kobo.337.1"> and </span><kbd><span class="koboSpan" id="kobo.338.1">GET /tickets</span></kbd><span class="koboSpan" id="kobo.339.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.340.1">// post ticket</span><br/><span class="koboSpan" id="kobo.341.1"># curl -XPOST -F 'value=100' http://192.168.99.100:30520/tickets</span><br/><span class="koboSpan" id="kobo.342.1">SUCCESS
</span><br/><span class="koboSpan" id="kobo.343.1">// get ticket</span><br/><span class="koboSpan" id="kobo.344.1"># curl -XGET http://192.168.99.100:30520/tickets</span><br/><span class="koboSpan" id="kobo.345.1">100</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, we learned the basic concepts of Kubernetes. </span><span class="koboSpan" id="kobo.2.2">We learned that a Kubernetes master has kube-apiserver to handle requests and controller managers are the control center of Kubernetes. </span><span class="koboSpan" id="kobo.2.3">These ensure our desired container amount is fulfilled, they control the endpoint to associate pods and services, and they control API access tokens. </span><span class="koboSpan" id="kobo.2.4">We also have Kubernetes nodes, which are the workers to host the containers, receive the information from the master, and route the traffic based on the configuration.</span></p>
<p><span class="koboSpan" id="kobo.3.1">We then used minikube to demonstrate basic Kubernetes objects, including pods, ReplicaSets, Deployments, Services, secrets, and ConfigMaps. </span><span class="koboSpan" id="kobo.3.2">Finally, we demonstrated how to combine all of the concepts we've learned into our kiosk application.</span></p>
<p><span class="koboSpan" id="kobo.4.1">As we mentioned previously, the data inside containers will disappear when a container is gone. </span><span class="koboSpan" id="kobo.4.2">Therefore, volume is extremely important to persist the data in the container world. </span><span class="koboSpan" id="kobo.4.3">In </span><a href="c3083748-0f68-488f-87e0-f8c61deeeb80.xhtml"><span class="koboSpan" id="kobo.5.1">Chapter 4</span></a><span class="koboSpan" id="kobo.6.1">, </span><em><span class="koboSpan" id="kobo.7.1">Managing Stateful Workloads</span></em><span class="koboSpan" id="kobo.8.1">, we'll be learning how volume works and how to use persistent volume.</span></p>


            </article>

            
        </section>
    </body></html>